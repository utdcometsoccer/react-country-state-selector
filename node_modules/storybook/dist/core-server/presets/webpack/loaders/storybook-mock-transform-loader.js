import ESM_COMPAT_Module from "node:module";
import { fileURLToPath as ESM_COMPAT_fileURLToPath } from 'node:url';
import { dirname as ESM_COMPAT_dirname } from 'node:path';
const __filename = ESM_COMPAT_fileURLToPath(import.meta.url);
const __dirname = ESM_COMPAT_dirname(__filename);
const require = ESM_COMPAT_Module.createRequire(import.meta.url);
var Np = Object.create;
var ns = Object.defineProperty;
var Op = Object.getOwnPropertyDescriptor;
var _p = Object.getOwnPropertyNames;
var Dp = Object.getPrototypeOf, kp = Object.prototype.hasOwnProperty;
var s = (t, e) => ns(t, "name", { value: e, configurable: !0 });
var O = (t, e) => () => (e || t((e = { exports: {} }).exports, e), e.exports);
var Lp = (t, e, r, i) => {
  if (e && typeof e == "object" || typeof e == "function")
    for (let n of _p(e))
      !kp.call(t, n) && n !== r && ns(t, n, { get: () => e[n], enumerable: !(i = Op(e, n)) || i.enumerable });
  return t;
};
var as = (t, e, r) => (r = t != null ? Np(Dp(t)) : {}, Lp(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  e || !t || !t.__esModule ? ns(r, "default", { value: t, enumerable: !0 }) : r,
  t
));

// ../node_modules/@jridgewell/set-array/dist/set-array.umd.js
var ko = O((ri, Do) => {
  (function(t, e) {
    typeof ri == "object" && typeof Do < "u" ? e(ri) : typeof define == "function" && define.amd ? define(["exports"], e) : (t = typeof globalThis <
    "u" ? globalThis : t || self, e(t.setArray = {}));
  })(ri, function(t) {
    "use strict";
    class e {
      static {
        s(this, "SetArray");
      }
      constructor() {
        this._indexes = { __proto__: null }, this.array = [];
      }
    }
    function r(l) {
      return l;
    }
    s(r, "cast");
    function i(l, u) {
      return l._indexes[u];
    }
    s(i, "get");
    function n(l, u) {
      let p = i(l, u);
      if (p !== void 0)
        return p;
      let { array: m, _indexes: g } = l, I = m.push(u);
      return g[u] = I - 1;
    }
    s(n, "put");
    function a(l) {
      let { array: u, _indexes: p } = l;
      if (u.length === 0)
        return;
      let m = u.pop();
      p[m] = void 0;
    }
    s(a, "pop");
    function o(l, u) {
      let p = i(l, u);
      if (p === void 0)
        return;
      let { array: m, _indexes: g } = l;
      for (let I = p + 1; I < m.length; I++) {
        let v = m[I];
        m[I - 1] = v, g[v]--;
      }
      g[u] = void 0, m.pop();
    }
    s(o, "remove"), t.SetArray = e, t.get = i, t.pop = a, t.put = n, t.remove = o, Object.defineProperty(t, "__esModule", { value: !0 });
  });
});

// ../node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.umd.js
var os = O((ii, Lo) => {
  (function(t, e) {
    typeof ii == "object" && typeof Lo < "u" ? e(ii) : typeof define == "function" && define.amd ? define(["exports"], e) : (t = typeof globalThis <
    "u" ? globalThis : t || self, e(t.sourcemapCodec = {}));
  })(ii, function(t) {
    "use strict";
    let i = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", n = new Uint8Array(64), a = new Uint8Array(128);
    for (let $ = 0; $ < i.length; $++) {
      let Y = i.charCodeAt($);
      n[$] = Y, a[Y] = $;
    }
    function o($, Y) {
      let w = 0, W = 0, le = 0;
      do {
        let U = $.next();
        le = a[U], w |= (le & 31) << W, W += 5;
      } while (le & 32);
      let be = w & 1;
      return w >>>= 1, be && (w = -2147483648 | -w), Y + w;
    }
    s(o, "decodeInteger");
    function l($, Y, w) {
      let W = Y - w;
      W = W < 0 ? -W << 1 | 1 : W << 1;
      do {
        let le = W & 31;
        W >>>= 5, W > 0 && (le |= 32), $.write(n[le]);
      } while (W > 0);
      return Y;
    }
    s(l, "encodeInteger");
    function u($, Y) {
      return $.pos >= Y ? !1 : $.peek() !== 44;
    }
    s(u, "hasMoreVlq");
    let p = 1024 * 16, m = typeof TextDecoder < "u" ? /* @__PURE__ */ new TextDecoder() : typeof Buffer < "u" ? {
      decode($) {
        return Buffer.from($.buffer, $.byteOffset, $.byteLength).toString();
      }
    } : {
      decode($) {
        let Y = "";
        for (let w = 0; w < $.length; w++)
          Y += String.fromCharCode($[w]);
        return Y;
      }
    };
    class g {
      static {
        s(this, "StringWriter");
      }
      constructor() {
        this.pos = 0, this.out = "", this.buffer = new Uint8Array(p);
      }
      write(Y) {
        let { buffer: w } = this;
        w[this.pos++] = Y, this.pos === p && (this.out += m.decode(w), this.pos = 0);
      }
      flush() {
        let { buffer: Y, out: w, pos: W } = this;
        return W > 0 ? w + m.decode(Y.subarray(0, W)) : w;
      }
    }
    class I {
      static {
        s(this, "StringReader");
      }
      constructor(Y) {
        this.pos = 0, this.buffer = Y;
      }
      next() {
        return this.buffer.charCodeAt(this.pos++);
      }
      peek() {
        return this.buffer.charCodeAt(this.pos);
      }
      indexOf(Y) {
        let { buffer: w, pos: W } = this, le = w.indexOf(Y, W);
        return le === -1 ? w.length : le;
      }
    }
    let v = [];
    function _($) {
      let { length: Y } = $, w = new I($), W = [], le = [], be = 0;
      for (; w.pos < Y; w.pos++) {
        be = o(w, be);
        let U = o(w, 0);
        if (!u(w, Y)) {
          let ce = le.pop();
          ce[2] = be, ce[3] = U;
          continue;
        }
        let q = o(w, 0), ne = o(w, 0) & 1 ? [be, U, 0, 0, q, o(w, 0)] : [be, U, 0, 0, q], oe = v;
        if (u(w, Y)) {
          oe = [];
          do {
            let ce = o(w, 0);
            oe.push(ce);
          } while (u(w, Y));
        }
        ne.vars = oe, W.push(ne), le.push(ne);
      }
      return W;
    }
    s(_, "decodeOriginalScopes");
    function V($) {
      let Y = new g();
      for (let w = 0; w < $.length; )
        w = D($, w, Y, [0]);
      return Y.flush();
    }
    s(V, "encodeOriginalScopes");
    function D($, Y, w, W) {
      let le = $[Y], { 0: be, 1: U, 2: q, 3: z, 4: G, vars: ne } = le;
      Y > 0 && w.write(44), W[0] = l(w, be, W[0]), l(w, U, 0), l(w, G, 0);
      let oe = le.length === 6 ? 1 : 0;
      l(w, oe, 0), le.length === 6 && l(w, le[5], 0);
      for (let ce of ne)
        l(w, ce, 0);
      for (Y++; Y < $.length; ) {
        let ce = $[Y], { 0: pe, 1: ye } = ce;
        if (pe > q || pe === q && ye >= z)
          break;
        Y = D($, Y, w, W);
      }
      return w.write(44), W[0] = l(w, q, W[0]), l(w, z, 0), Y;
    }
    s(D, "_encodeOriginalScopes");
    function L($) {
      let { length: Y } = $, w = new I($), W = [], le = [], be = 0, U = 0, q = 0, z = 0, G = 0, ne = 0, oe = 0, ce = 0;
      do {
        let pe = w.indexOf(";"), ye = 0;
        for (; w.pos < pe; w.pos++) {
          if (ye = o(w, ye), !u(w, pe)) {
            let Re = le.pop();
            Re[2] = be, Re[3] = ye;
            continue;
          }
          let Ke = o(w, 0), ft = Ke & 1, st = Ke & 2, nt = Ke & 4, yt = null, ht = v, Xe;
          if (ft) {
            let Re = o(w, U);
            q = o(w, U === Re ? q : 0), U = Re, Xe = [be, ye, 0, 0, Re, q];
          } else
            Xe = [be, ye, 0, 0];
          if (Xe.isScope = !!nt, st) {
            let Re = z, gt = G;
            z = o(w, z);
            let Vt = Re === z;
            G = o(w, Vt ? G : 0), ne = o(w, Vt && gt === G ? ne : 0), yt = [z, G, ne];
          }
          if (Xe.callsite = yt, u(w, pe)) {
            ht = [];
            do {
              oe = be, ce = ye;
              let Re = o(w, 0), gt;
              if (Re < -1) {
                gt = [[o(w, 0)]];
                for (let Vt = -1; Vt > Re; Vt--) {
                  let ts = oe;
                  oe = o(w, oe), ce = o(w, oe === ts ? ce : 0);
                  let xr = o(w, 0);
                  gt.push([xr, oe, ce]);
                }
              } else
                gt = [[Re]];
              ht.push(gt);
            } while (u(w, pe));
          }
          Xe.bindings = ht, W.push(Xe), le.push(Xe);
        }
        be++, w.pos = pe + 1;
      } while (w.pos < Y);
      return W;
    }
    s(L, "decodeGeneratedRanges");
    function B($) {
      if ($.length === 0)
        return "";
      let Y = new g();
      for (let w = 0; w < $.length; )
        w = fe($, w, Y, [0, 0, 0, 0, 0, 0, 0]);
      return Y.flush();
    }
    s(B, "encodeGeneratedRanges");
    function fe($, Y, w, W) {
      let le = $[Y], { 0: be, 1: U, 2: q, 3: z, isScope: G, callsite: ne, bindings: oe } = le;
      W[0] < be ? (ee(w, W[0], be), W[0] = be, W[1] = 0) : Y > 0 && w.write(44), W[1] = l(w, le[1], W[1]);
      let ce = (le.length === 6 ? 1 : 0) | (ne ? 2 : 0) | (G ? 4 : 0);
      if (l(w, ce, 0), le.length === 6) {
        let { 4: pe, 5: ye } = le;
        pe !== W[2] && (W[3] = 0), W[2] = l(w, pe, W[2]), W[3] = l(w, ye, W[3]);
      }
      if (ne) {
        let { 0: pe, 1: ye, 2: Ke } = le.callsite;
        pe !== W[4] ? (W[5] = 0, W[6] = 0) : ye !== W[5] && (W[6] = 0), W[4] = l(w, pe, W[4]), W[5] = l(w, ye, W[5]), W[6] = l(w, Ke, W[6]);
      }
      if (oe)
        for (let pe of oe) {
          pe.length > 1 && l(w, -pe.length, 0);
          let ye = pe[0][0];
          l(w, ye, 0);
          let Ke = be, ft = U;
          for (let st = 1; st < pe.length; st++) {
            let nt = pe[st];
            Ke = l(w, nt[1], Ke), ft = l(w, nt[2], ft), l(w, nt[0], 0);
          }
        }
      for (Y++; Y < $.length; ) {
        let pe = $[Y], { 0: ye, 1: Ke } = pe;
        if (ye > q || ye === q && Ke >= z)
          break;
        Y = fe($, Y, w, W);
      }
      return W[0] < q ? (ee(w, W[0], q), W[0] = q, W[1] = 0) : w.write(44), W[1] = l(w, z, W[1]), Y;
    }
    s(fe, "_encodeGeneratedRanges");
    function ee($, Y, w) {
      do
        $.write(59);
      while (++Y < w);
    }
    s(ee, "catchupLine");
    function Te($) {
      let { length: Y } = $, w = new I($), W = [], le = 0, be = 0, U = 0, q = 0, z = 0;
      do {
        let G = w.indexOf(";"), ne = [], oe = !0, ce = 0;
        for (le = 0; w.pos < G; ) {
          let pe;
          le = o(w, le), le < ce && (oe = !1), ce = le, u(w, G) ? (be = o(w, be), U = o(w, U), q = o(w, q), u(w, G) ? (z = o(w, z), pe = [le,
          be, U, q, z]) : pe = [le, be, U, q]) : pe = [le], ne.push(pe), w.pos++;
        }
        oe || Le(ne), W.push(ne), w.pos = G + 1;
      } while (w.pos <= Y);
      return W;
    }
    s(Te, "decode");
    function Le($) {
      $.sort(Ue);
    }
    s(Le, "sort");
    function Ue($, Y) {
      return $[0] - Y[0];
    }
    s(Ue, "sortComparator");
    function Je($) {
      let Y = new g(), w = 0, W = 0, le = 0, be = 0;
      for (let U = 0; U < $.length; U++) {
        let q = $[U];
        if (U > 0 && Y.write(59), q.length === 0)
          continue;
        let z = 0;
        for (let G = 0; G < q.length; G++) {
          let ne = q[G];
          G > 0 && Y.write(44), z = l(Y, ne[0], z), ne.length !== 1 && (w = l(Y, ne[1], w), W = l(Y, ne[2], W), le = l(Y, ne[3], le), ne.length !==
          4 && (be = l(Y, ne[4], be)));
        }
      }
      return Y.flush();
    }
    s(Je, "encode"), t.decode = Te, t.decodeGeneratedRanges = L, t.decodeOriginalScopes = _, t.encode = Je, t.encodeGeneratedRanges = B, t.encodeOriginalScopes =
    V, Object.defineProperty(t, "__esModule", { value: !0 });
  });
});

// ../node_modules/@jridgewell/resolve-uri/dist/resolve-uri.umd.js
var Mo = O((ls, us) => {
  (function(t, e) {
    typeof ls == "object" && typeof us < "u" ? us.exports = e() : typeof define == "function" && define.amd ? define(e) : (t = typeof globalThis <
    "u" ? globalThis : t || self, t.resolveURI = e());
  })(ls, function() {
    "use strict";
    let t = /^[\w+.-]+:\/\//, e = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/, r = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;
    function i(D) {
      return t.test(D);
    }
    s(i, "isAbsoluteUrl");
    function n(D) {
      return D.startsWith("//");
    }
    s(n, "isSchemeRelativeUrl");
    function a(D) {
      return D.startsWith("/");
    }
    s(a, "isAbsolutePath");
    function o(D) {
      return D.startsWith("file:");
    }
    s(o, "isFileUrl");
    function l(D) {
      return /^[.?#]/.test(D);
    }
    s(l, "isRelative");
    function u(D) {
      let L = e.exec(D);
      return m(L[1], L[2] || "", L[3], L[4] || "", L[5] || "/", L[6] || "", L[7] || "");
    }
    s(u, "parseAbsoluteUrl");
    function p(D) {
      let L = r.exec(D), B = L[2];
      return m("file:", "", L[1] || "", "", a(B) ? B : "/" + B, L[3] || "", L[4] || "");
    }
    s(p, "parseFileUrl");
    function m(D, L, B, fe, ee, Te, Le) {
      return {
        scheme: D,
        user: L,
        host: B,
        port: fe,
        path: ee,
        query: Te,
        hash: Le,
        type: 7
      };
    }
    s(m, "makeUrl");
    function g(D) {
      if (n(D)) {
        let B = u("http:" + D);
        return B.scheme = "", B.type = 6, B;
      }
      if (a(D)) {
        let B = u("http://foo.com" + D);
        return B.scheme = "", B.host = "", B.type = 5, B;
      }
      if (o(D))
        return p(D);
      if (i(D))
        return u(D);
      let L = u("http://foo.com/" + D);
      return L.scheme = "", L.host = "", L.type = D ? D.startsWith("?") ? 3 : D.startsWith("#") ? 2 : 4 : 1, L;
    }
    s(g, "parseUrl");
    function I(D) {
      if (D.endsWith("/.."))
        return D;
      let L = D.lastIndexOf("/");
      return D.slice(0, L + 1);
    }
    s(I, "stripPathFilename");
    function v(D, L) {
      _(L, L.type), D.path === "/" ? D.path = L.path : D.path = I(L.path) + D.path;
    }
    s(v, "mergePaths");
    function _(D, L) {
      let B = L <= 4, fe = D.path.split("/"), ee = 1, Te = 0, Le = !1;
      for (let Je = 1; Je < fe.length; Je++) {
        let $ = fe[Je];
        if (!$) {
          Le = !0;
          continue;
        }
        if (Le = !1, $ !== ".") {
          if ($ === "..") {
            Te ? (Le = !0, Te--, ee--) : B && (fe[ee++] = $);
            continue;
          }
          fe[ee++] = $, Te++;
        }
      }
      let Ue = "";
      for (let Je = 1; Je < ee; Je++)
        Ue += "/" + fe[Je];
      (!Ue || Le && !Ue.endsWith("/..")) && (Ue += "/"), D.path = Ue;
    }
    s(_, "normalizePath");
    function V(D, L) {
      if (!D && !L)
        return "";
      let B = g(D), fe = B.type;
      if (L && fe !== 7) {
        let Te = g(L), Le = Te.type;
        switch (fe) {
          case 1:
            B.hash = Te.hash;
          // fall through
          case 2:
            B.query = Te.query;
          // fall through
          case 3:
          case 4:
            v(B, Te);
          // fall through
          case 5:
            B.user = Te.user, B.host = Te.host, B.port = Te.port;
          // fall through
          case 6:
            B.scheme = Te.scheme;
        }
        Le > fe && (fe = Le);
      }
      _(B, fe);
      let ee = B.query + B.hash;
      switch (fe) {
        // This is impossible, because of the empty checks at the start of the function.
        // case UrlType.Empty:
        case 2:
        case 3:
          return ee;
        case 4: {
          let Te = B.path.slice(1);
          return Te ? l(L || D) && !l(Te) ? "./" + Te + ee : Te + ee : ee || ".";
        }
        case 5:
          return B.path + ee;
        default:
          return B.scheme + "//" + B.user + B.host + B.port + B.path + ee;
      }
    }
    return s(V, "resolve"), V;
  });
});

// ../node_modules/@jridgewell/trace-mapping/dist/trace-mapping.umd.js
var cs = O((si, Bo) => {
  (function(t, e) {
    typeof si == "object" && typeof Bo < "u" ? e(si, os(), Mo()) : typeof define == "function" && define.amd ? define(["exports", "@jridgewe\
ll/sourcemap-codec", "@jridgewell/resolve-uri"], e) : (t = typeof globalThis < "u" ? globalThis : t || self, e(t.traceMapping = {}, t.sourcemapCodec,
    t.resolveURI));
  })(si, function(t, e, r) {
    "use strict";
    function i(C, M) {
      return M && !M.endsWith("/") && (M += "/"), r(C, M);
    }
    s(i, "resolve");
    function n(C) {
      if (!C)
        return "";
      let M = C.lastIndexOf("/");
      return C.slice(0, M + 1);
    }
    s(n, "stripFilename");
    let a = 0, o = 1, l = 2, u = 3, p = 4, m = 1, g = 2;
    function I(C, M) {
      let j = v(C, 0);
      if (j === C.length)
        return C;
      M || (C = C.slice());
      for (let J = j; J < C.length; J = v(C, J + 1))
        C[J] = V(C[J], M);
      return C;
    }
    s(I, "maybeSort");
    function v(C, M) {
      for (let j = M; j < C.length; j++)
        if (!_(C[j]))
          return j;
      return C.length;
    }
    s(v, "nextUnsortedSegmentLine");
    function _(C) {
      for (let M = 1; M < C.length; M++)
        if (C[M][a] < C[M - 1][a])
          return !1;
      return !0;
    }
    s(_, "isSorted");
    function V(C, M) {
      return M || (C = C.slice()), C.sort(D);
    }
    s(V, "sortSegments");
    function D(C, M) {
      return C[a] - M[a];
    }
    s(D, "sortComparator");
    let L = !1;
    function B(C, M, j, J) {
      for (; j <= J; ) {
        let ue = j + (J - j >> 1), re = C[ue][a] - M;
        if (re === 0)
          return L = !0, ue;
        re < 0 ? j = ue + 1 : J = ue - 1;
      }
      return L = !1, j - 1;
    }
    s(B, "binarySearch");
    function fe(C, M, j) {
      for (let J = j + 1; J < C.length && C[J][a] === M; j = J++)
        ;
      return j;
    }
    s(fe, "upperBound");
    function ee(C, M, j) {
      for (let J = j - 1; J >= 0 && C[J][a] === M; j = J--)
        ;
      return j;
    }
    s(ee, "lowerBound");
    function Te() {
      return {
        lastKey: -1,
        lastNeedle: -1,
        lastIndex: -1
      };
    }
    s(Te, "memoizedState");
    function Le(C, M, j, J) {
      let { lastKey: ue, lastNeedle: re, lastIndex: Ae } = j, we = 0, Se = C.length - 1;
      if (J === ue) {
        if (M === re)
          return L = Ae !== -1 && C[Ae][a] === M, Ae;
        M >= re ? we = Ae === -1 ? 0 : Ae : Se = Ae;
      }
      return j.lastKey = J, j.lastNeedle = M, j.lastIndex = B(C, M, we, Se);
    }
    s(Le, "memoizedBinarySearch");
    function Ue(C, M) {
      let j = M.map($);
      for (let J = 0; J < C.length; J++) {
        let ue = C[J];
        for (let re = 0; re < ue.length; re++) {
          let Ae = ue[re];
          if (Ae.length === 1)
            continue;
          let we = Ae[o], Se = Ae[l], Ne = Ae[u], et = j[we], je = et[Se] || (et[Se] = []), Me = M[we], We = fe(je, Ne, Le(je, Ne, Me, Se));
          Me.lastIndex = ++We, Je(je, We, [Ne, J, Ae[a]]);
        }
      }
      return j;
    }
    s(Ue, "buildBySources");
    function Je(C, M, j) {
      for (let J = C.length; J > M; J--)
        C[J] = C[J - 1];
      C[M] = j;
    }
    s(Je, "insert");
    function $() {
      return { __proto__: null };
    }
    s($, "buildNullArray");
    let Y = /* @__PURE__ */ s(function(C, M) {
      let j = w(C);
      if (!("sections" in j))
        return new oe(j, M);
      let J = [], ue = [], re = [], Ae = [], we = [];
      W(j, M, J, ue, re, Ae, we, 0, 0, 1 / 0, 1 / 0);
      let Se = {
        version: 3,
        file: j.file,
        names: Ae,
        sources: ue,
        sourcesContent: re,
        mappings: J,
        ignoreList: we
      };
      return gt(Se);
    }, "AnyMap");
    function w(C) {
      return typeof C == "string" ? JSON.parse(C) : C;
    }
    s(w, "parse");
    function W(C, M, j, J, ue, re, Ae, we, Se, Ne, et) {
      let { sections: je } = C;
      for (let Me = 0; Me < je.length; Me++) {
        let { map: We, offset: Tt } = je[Me], Yt = Ne, tr = et;
        if (Me + 1 < je.length) {
          let rr = je[Me + 1].offset;
          Yt = Math.min(Ne, we + rr.line), Yt === Ne ? tr = Math.min(et, Se + rr.column) : Yt < Ne && (tr = Se + rr.column);
        }
        le(We, M, j, J, ue, re, Ae, we + Tt.line, Se + Tt.column, Yt, tr);
      }
    }
    s(W, "recurse");
    function le(C, M, j, J, ue, re, Ae, we, Se, Ne, et) {
      let je = w(C);
      if ("sections" in je)
        return W(...arguments);
      let Me = new oe(je, M), We = J.length, Tt = re.length, Yt = ye(Me), { resolvedSources: tr, sourcesContent: rr, ignoreList: rs } = Me;
      if (be(J, tr), be(re, Me.names), rr)
        be(ue, rr);
      else
        for (let at = 0; at < tr.length; at++)
          ue.push(null);
      if (rs)
        for (let at = 0; at < rs.length; at++)
          Ae.push(rs[at] + We);
      for (let at = 0; at < Yt.length; at++) {
        let is = we + at;
        if (is > Ne)
          return;
        let Co = U(j, is), wp = at === 0 ? Se : 0, wo = Yt[at];
        for (let ss = 0; ss < wo.length; ss++) {
          let Jt = wo[ss], ti = wp + Jt[a];
          if (is === Ne && ti >= et)
            return;
          if (Jt.length === 1) {
            Co.push([ti]);
            continue;
          }
          let No = We + Jt[o], Oo = Jt[l], _o = Jt[u];
          Co.push(Jt.length === 4 ? [ti, No, Oo, _o] : [ti, No, Oo, _o, Tt + Jt[p]]);
        }
      }
    }
    s(le, "addSection");
    function be(C, M) {
      for (let j = 0; j < M.length; j++)
        C.push(M[j]);
    }
    s(be, "append");
    function U(C, M) {
      for (let j = C.length; j <= M; j++)
        C[j] = [];
      return C[M];
    }
    s(U, "getLine");
    let q = "`line` must be greater than 0 (lines start at line 1)", z = "`column` must be greater than or equal to 0 (columns start at colu\
mn 0)", G = -1, ne = 1;
    class oe {
      static {
        s(this, "TraceMap");
      }
      constructor(M, j) {
        let J = typeof M == "string";
        if (!J && M._decodedMemo)
          return M;
        let ue = J ? JSON.parse(M) : M, { version: re, file: Ae, names: we, sourceRoot: Se, sources: Ne, sourcesContent: et } = ue;
        this.version = re, this.file = Ae, this.names = we || [], this.sourceRoot = Se, this.sources = Ne, this.sourcesContent = et, this.ignoreList =
        ue.ignoreList || ue.x_google_ignoreList || void 0;
        let je = i(Se || "", n(j));
        this.resolvedSources = Ne.map((We) => i(We || "", je));
        let { mappings: Me } = ue;
        typeof Me == "string" ? (this._encoded = Me, this._decoded = void 0) : (this._encoded = void 0, this._decoded = I(Me, J)), this._decodedMemo =
        Te(), this._bySources = void 0, this._bySourceMemos = void 0;
      }
    }
    function ce(C) {
      return C;
    }
    s(ce, "cast");
    function pe(C) {
      var M, j;
      return (M = (j = C)._encoded) !== null && M !== void 0 ? M : j._encoded = e.encode(C._decoded);
    }
    s(pe, "encodedMappings");
    function ye(C) {
      var M;
      return (M = C)._decoded || (M._decoded = e.decode(C._encoded));
    }
    s(ye, "decodedMappings");
    function Ke(C, M, j) {
      let J = ye(C);
      if (M >= J.length)
        return null;
      let ue = J[M], re = ei(ue, C._decodedMemo, M, j, ne);
      return re === -1 ? null : ue[re];
    }
    s(Ke, "traceSegment");
    function ft(C, M) {
      let { line: j, column: J, bias: ue } = M;
      if (j--, j < 0)
        throw new Error(q);
      if (J < 0)
        throw new Error(z);
      let re = ye(C);
      if (j >= re.length)
        return Zr(null, null, null, null);
      let Ae = re[j], we = ei(Ae, C._decodedMemo, j, J, ue || ne);
      if (we === -1)
        return Zr(null, null, null, null);
      let Se = Ae[we];
      if (Se.length === 1)
        return Zr(null, null, null, null);
      let { names: Ne, resolvedSources: et } = C;
      return Zr(et[Se[o]], Se[l] + 1, Se[u], Se.length === 5 ? Ne[Se[p]] : null);
    }
    s(ft, "originalPositionFor");
    function st(C, M) {
      let { source: j, line: J, column: ue, bias: re } = M;
      return vo(C, j, J, ue, re || ne, !1);
    }
    s(st, "generatedPositionFor");
    function nt(C, M) {
      let { source: j, line: J, column: ue, bias: re } = M;
      return vo(C, j, J, ue, re || G, !0);
    }
    s(nt, "allGeneratedPositionsFor");
    function yt(C, M) {
      let j = ye(C), { names: J, resolvedSources: ue } = C;
      for (let re = 0; re < j.length; re++) {
        let Ae = j[re];
        for (let we = 0; we < Ae.length; we++) {
          let Se = Ae[we], Ne = re + 1, et = Se[0], je = null, Me = null, We = null, Tt = null;
          Se.length !== 1 && (je = ue[Se[1]], Me = Se[2] + 1, We = Se[3]), Se.length === 5 && (Tt = J[Se[4]]), M({
            generatedLine: Ne,
            generatedColumn: et,
            source: je,
            originalLine: Me,
            originalColumn: We,
            name: Tt
          });
        }
      }
    }
    s(yt, "eachMapping");
    function ht(C, M) {
      let { sources: j, resolvedSources: J } = C, ue = j.indexOf(M);
      return ue === -1 && (ue = J.indexOf(M)), ue;
    }
    s(ht, "sourceIndex");
    function Xe(C, M) {
      let { sourcesContent: j } = C;
      if (j == null)
        return null;
      let J = ht(C, M);
      return J === -1 ? null : j[J];
    }
    s(Xe, "sourceContentFor");
    function Re(C, M) {
      let { ignoreList: j } = C;
      if (j == null)
        return !1;
      let J = ht(C, M);
      return J === -1 ? !1 : j.includes(J);
    }
    s(Re, "isIgnored");
    function gt(C, M) {
      let j = new oe(xr(C, []), M);
      return j._decoded = C.mappings, j;
    }
    s(gt, "presortedDecodedMap");
    function Vt(C) {
      return xr(C, ye(C));
    }
    s(Vt, "decodedMap");
    function ts(C) {
      return xr(C, pe(C));
    }
    s(ts, "encodedMap");
    function xr(C, M) {
      return {
        version: C.version,
        file: C.file,
        names: C.names,
        sourceRoot: C.sourceRoot,
        sources: C.sources,
        sourcesContent: C.sourcesContent,
        mappings: M,
        ignoreList: C.ignoreList || C.x_google_ignoreList
      };
    }
    s(xr, "clone");
    function Zr(C, M, j, J) {
      return { source: C, line: M, column: j, name: J };
    }
    s(Zr, "OMapping");
    function Pr(C, M) {
      return { line: C, column: M };
    }
    s(Pr, "GMapping");
    function ei(C, M, j, J, ue) {
      let re = Le(C, J, M, j);
      return L ? re = (ue === G ? fe : ee)(C, J, re) : ue === G && re++, re === -1 || re === C.length ? -1 : re;
    }
    s(ei, "traceSegmentInternal");
    function Cp(C, M, j, J, ue) {
      let re = ei(C, M, j, J, ne);
      if (!L && ue === G && re++, re === -1 || re === C.length)
        return [];
      let Ae = L ? J : C[re][a];
      L || (re = ee(C, Ae, re));
      let we = fe(C, Ae, re), Se = [];
      for (; re <= we; re++) {
        let Ne = C[re];
        Se.push(Pr(Ne[m] + 1, Ne[g]));
      }
      return Se;
    }
    s(Cp, "sliceGeneratedPositions");
    function vo(C, M, j, J, ue, re) {
      var Ae;
      if (j--, j < 0)
        throw new Error(q);
      if (J < 0)
        throw new Error(z);
      let { sources: we, resolvedSources: Se } = C, Ne = we.indexOf(M);
      if (Ne === -1 && (Ne = Se.indexOf(M)), Ne === -1)
        return re ? [] : Pr(null, null);
      let je = ((Ae = C)._bySources || (Ae._bySources = Ue(ye(C), C._bySourceMemos = we.map(Te))))[Ne][j];
      if (je == null)
        return re ? [] : Pr(null, null);
      let Me = C._bySourceMemos[Ne];
      if (re)
        return Cp(je, Me, j, J, ue);
      let We = ei(je, Me, j, J, ue);
      if (We === -1)
        return Pr(null, null);
      let Tt = je[We];
      return Pr(Tt[m] + 1, Tt[g]);
    }
    s(vo, "generatedPosition"), t.AnyMap = Y, t.GREATEST_LOWER_BOUND = ne, t.LEAST_UPPER_BOUND = G, t.TraceMap = oe, t.allGeneratedPositionsFor =
    nt, t.decodedMap = Vt, t.decodedMappings = ye, t.eachMapping = yt, t.encodedMap = ts, t.encodedMappings = pe, t.generatedPositionFor = st,
    t.isIgnored = Re, t.originalPositionFor = ft, t.presortedDecodedMap = gt, t.sourceContentFor = Xe, t.traceSegment = Ke;
  });
});

// ../node_modules/@jridgewell/gen-mapping/dist/gen-mapping.umd.js
var Fo = O((ni, jo) => {
  (function(t, e) {
    typeof ni == "object" && typeof jo < "u" ? e(ni, ko(), os(), cs()) : typeof define == "function" && define.amd ? define(["exports", "@jr\
idgewell/set-array", "@jridgewell/sourcemap-codec", "@jridgewell/trace-mapping"], e) : (t = typeof globalThis < "u" ? globalThis : t || self,
    e(t.genMapping = {}, t.setArray, t.sourcemapCodec, t.traceMapping));
  })(ni, function(t, e, r, i) {
    "use strict";
    class m {
      static {
        s(this, "GenMapping");
      }
      constructor({ file: q, sourceRoot: z } = {}) {
        this._names = new e.SetArray(), this._sources = new e.SetArray(), this._sourcesContent = [], this._mappings = [], this.file = q, this.
        sourceRoot = z, this._ignoreList = new e.SetArray();
      }
    }
    function g(U) {
      return U;
    }
    s(g, "cast");
    function I(U, q, z, G, ne, oe, ce, pe) {
      return Le(!1, U, q, z, G, ne, oe, ce, pe);
    }
    s(I, "addSegment");
    function v(U, q) {
      return be(!1, U, q);
    }
    s(v, "addMapping");
    let _ = /* @__PURE__ */ s((U, q, z, G, ne, oe, ce, pe) => Le(!0, U, q, z, G, ne, oe, ce, pe), "maybeAddSegment"), V = /* @__PURE__ */ s(
    (U, q) => be(!0, U, q), "maybeAddMapping");
    function D(U, q, z) {
      let { _sources: G, _sourcesContent: ne } = U, oe = e.put(G, q);
      ne[oe] = z;
    }
    s(D, "setSourceContent");
    function L(U, q, z = !0) {
      let { _sources: G, _sourcesContent: ne, _ignoreList: oe } = U, ce = e.put(G, q);
      ce === ne.length && (ne[ce] = null), z ? e.put(oe, ce) : e.remove(oe, ce);
    }
    s(L, "setIgnore");
    function B(U) {
      let { _mappings: q, _sources: z, _sourcesContent: G, _names: ne, _ignoreList: oe } = U;
      return Y(q), {
        version: 3,
        file: U.file || void 0,
        names: ne.array,
        sourceRoot: U.sourceRoot || void 0,
        sources: z.array,
        sourcesContent: G,
        mappings: q,
        ignoreList: oe.array
      };
    }
    s(B, "toDecodedMap");
    function fe(U) {
      let q = B(U);
      return Object.assign(Object.assign({}, q), { mappings: r.encode(q.mappings) });
    }
    s(fe, "toEncodedMap");
    function ee(U) {
      let q = new i.TraceMap(U), z = new m({ file: q.file, sourceRoot: q.sourceRoot });
      return w(z._names, q.names), w(z._sources, q.sources), z._sourcesContent = q.sourcesContent || q.sources.map(() => null), z._mappings =
      i.decodedMappings(q), q.ignoreList && w(z._ignoreList, q.ignoreList), z;
    }
    s(ee, "fromMap");
    function Te(U) {
      let q = [], { _mappings: z, _sources: G, _names: ne } = U;
      for (let oe = 0; oe < z.length; oe++) {
        let ce = z[oe];
        for (let pe = 0; pe < ce.length; pe++) {
          let ye = ce[pe], Ke = { line: oe + 1, column: ye[0] }, ft, st, nt;
          ye.length !== 1 && (ft = G.array[ye[1]], st = { line: ye[2] + 1, column: ye[3] }, ye.length === 5 && (nt = ne.array[ye[4]])), q.push(
          { generated: Ke, source: ft, original: st, name: nt });
        }
      }
      return q;
    }
    s(Te, "allMappings");
    function Le(U, q, z, G, ne, oe, ce, pe, ye) {
      let { _mappings: Ke, _sources: ft, _sourcesContent: st, _names: nt } = q, yt = Ue(Ke, z), ht = Je(yt, G);
      if (!ne)
        return U && W(yt, ht) ? void 0 : $(yt, ht, [G]);
      let Xe = e.put(ft, ne), Re = pe ? e.put(nt, pe) : -1;
      if (Xe === st.length && (st[Xe] = ye ?? null), !(U && le(yt, ht, Xe, oe, ce, Re)))
        return $(yt, ht, pe ? [G, Xe, oe, ce, Re] : [G, Xe, oe, ce]);
    }
    s(Le, "addSegmentInternal");
    function Ue(U, q) {
      for (let z = U.length; z <= q; z++)
        U[z] = [];
      return U[q];
    }
    s(Ue, "getLine");
    function Je(U, q) {
      let z = U.length;
      for (let G = z - 1; G >= 0; z = G--) {
        let ne = U[G];
        if (q >= ne[0])
          break;
      }
      return z;
    }
    s(Je, "getColumnIndex");
    function $(U, q, z) {
      for (let G = U.length; G > q; G--)
        U[G] = U[G - 1];
      U[q] = z;
    }
    s($, "insert");
    function Y(U) {
      let { length: q } = U, z = q;
      for (let G = z - 1; G >= 0 && !(U[G].length > 0); z = G, G--)
        ;
      z < q && (U.length = z);
    }
    s(Y, "removeEmptyFinalLines");
    function w(U, q) {
      for (let z = 0; z < q.length; z++)
        e.put(U, q[z]);
    }
    s(w, "putAll");
    function W(U, q) {
      return q === 0 ? !0 : U[q - 1].length === 1;
    }
    s(W, "skipSourceless");
    function le(U, q, z, G, ne, oe) {
      if (q === 0)
        return !1;
      let ce = U[q - 1];
      return ce.length === 1 ? !1 : z === ce[1] && G === ce[2] && ne === ce[3] && oe === (ce.length === 5 ? ce[4] : -1);
    }
    s(le, "skipSource");
    function be(U, q, z) {
      let { generated: G, source: ne, original: oe, name: ce, content: pe } = z;
      return ne ? Le(U, q, G.line - 1, G.column, ne, oe.line - 1, oe.column, ce, pe) : Le(U, q, G.line - 1, G.column, null, null, null, null,
      null);
    }
    s(be, "addMappingInternal"), t.GenMapping = m, t.addMapping = v, t.addSegment = I, t.allMappings = Te, t.fromMap = ee, t.maybeAddMapping =
    V, t.maybeAddSegment = _, t.setIgnore = L, t.setSourceContent = D, t.toDecodedMap = B, t.toEncodedMap = fe, Object.defineProperty(t, "__\
esModule", { value: !0 });
  });
});

// ../node_modules/@babel/generator/lib/source-map.js
var Ro = O((ai) => {
  "use strict";
  Object.defineProperty(ai, "__esModule", {
    value: !0
  });
  ai.default = void 0;
  var kt = Fo(), ps = cs(), fs = class {
    static {
      s(this, "SourceMap");
    }
    constructor(e, r) {
      var i;
      this._map = void 0, this._rawMappings = void 0, this._sourceFileName = void 0, this._lastGenLine = 0, this._lastSourceLine = 0, this._lastSourceColumn =
      0, this._inputMap = void 0;
      let n = this._map = new kt.GenMapping({
        sourceRoot: e.sourceRoot
      });
      if (this._sourceFileName = (i = e.sourceFileName) == null ? void 0 : i.replace(/\\/g, "/"), this._rawMappings = void 0, e.inputSourceMap) {
        this._inputMap = new ps.TraceMap(e.inputSourceMap);
        let o = this._inputMap.resolvedSources;
        if (o.length)
          for (let l = 0; l < o.length; l++) {
            var a;
            (0, kt.setSourceContent)(n, o[l], (a = this._inputMap.sourcesContent) == null ? void 0 : a[l]);
          }
      }
      if (typeof r == "string" && !e.inputSourceMap)
        (0, kt.setSourceContent)(n, this._sourceFileName, r);
      else if (typeof r == "object")
        for (let o of Object.keys(r))
          (0, kt.setSourceContent)(n, o.replace(/\\/g, "/"), r[o]);
    }
    get() {
      return (0, kt.toEncodedMap)(this._map);
    }
    getDecoded() {
      return (0, kt.toDecodedMap)(this._map);
    }
    getRawMappings() {
      return this._rawMappings || (this._rawMappings = (0, kt.allMappings)(this._map));
    }
    mark(e, r, i, n, a, o) {
      var l;
      this._rawMappings = void 0;
      let u;
      if (r != null)
        if (this._inputMap) {
          if (u = (0, ps.originalPositionFor)(this._inputMap, {
            line: r,
            column: i
          }), !u.name && a) {
            let p = (0, ps.originalPositionFor)(this._inputMap, a);
            p.name && (n = p.name);
          }
        } else
          u = {
            source: o?.replace(/\\/g, "/") || this._sourceFileName,
            line: r,
            column: i
          };
      (0, kt.maybeAddMapping)(this._map, {
        name: n,
        generated: e,
        source: (l = u) == null ? void 0 : l.source,
        original: u
      });
    }
  };
  ai.default = fs;
});

// ../node_modules/@babel/generator/lib/buffer.js
var qo = O((oi) => {
  "use strict";
  Object.defineProperty(oi, "__esModule", {
    value: !0
  });
  oi.default = void 0;
  var hs = class {
    static {
      s(this, "Buffer");
    }
    constructor(e, r) {
      this._map = null, this._buf = "", this._str = "", this._appendCount = 0, this._last = 0, this._queue = [], this._queueCursor = 0, this.
      _canMarkIdName = !0, this._indentChar = "", this._fastIndentations = [], this._position = {
        line: 1,
        column: 0
      }, this._sourcePosition = {
        identifierName: void 0,
        identifierNamePos: void 0,
        line: void 0,
        column: void 0,
        filename: void 0
      }, this._map = e, this._indentChar = r;
      for (let i = 0; i < 64; i++)
        this._fastIndentations.push(r.repeat(i));
      this._allocQueue();
    }
    _allocQueue() {
      let e = this._queue;
      for (let r = 0; r < 16; r++)
        e.push({
          char: 0,
          repeat: 1,
          line: void 0,
          column: void 0,
          identifierName: void 0,
          identifierNamePos: void 0,
          filename: ""
        });
    }
    _pushQueue(e, r, i, n, a) {
      let o = this._queueCursor;
      o === this._queue.length && this._allocQueue();
      let l = this._queue[o];
      l.char = e, l.repeat = r, l.line = i, l.column = n, l.filename = a, this._queueCursor++;
    }
    _popQueue() {
      if (this._queueCursor === 0)
        throw new Error("Cannot pop from empty queue");
      return this._queue[--this._queueCursor];
    }
    get() {
      this._flush();
      let e = this._map, r = {
        code: (this._buf + this._str).trimRight(),
        decodedMap: e?.getDecoded(),
        get __mergedMap() {
          return this.map;
        },
        get map() {
          let i = e ? e.get() : null;
          return r.map = i, i;
        },
        set map(i) {
          Object.defineProperty(r, "map", {
            value: i,
            writable: !0
          });
        },
        get rawMappings() {
          let i = e?.getRawMappings();
          return r.rawMappings = i, i;
        },
        set rawMappings(i) {
          Object.defineProperty(r, "rawMappings", {
            value: i,
            writable: !0
          });
        }
      };
      return r;
    }
    append(e, r) {
      this._flush(), this._append(e, this._sourcePosition, r);
    }
    appendChar(e) {
      this._flush(), this._appendChar(e, 1, this._sourcePosition);
    }
    queue(e) {
      if (e === 10)
        for (; this._queueCursor !== 0; ) {
          let i = this._queue[this._queueCursor - 1].char;
          if (i !== 32 && i !== 9)
            break;
          this._queueCursor--;
        }
      let r = this._sourcePosition;
      this._pushQueue(e, 1, r.line, r.column, r.filename);
    }
    queueIndentation(e) {
      e !== 0 && this._pushQueue(-1, e, void 0, void 0, void 0);
    }
    _flush() {
      let e = this._queueCursor, r = this._queue;
      for (let i = 0; i < e; i++) {
        let n = r[i];
        this._appendChar(n.char, n.repeat, n);
      }
      this._queueCursor = 0;
    }
    _appendChar(e, r, i) {
      if (this._last = e, e === -1) {
        let n = this._fastIndentations[r];
        n !== void 0 ? this._str += n : this._str += r > 1 ? this._indentChar.repeat(r) : this._indentChar;
      } else
        this._str += r > 1 ? String.fromCharCode(e).repeat(r) : String.fromCharCode(e);
      e !== 10 ? (this._mark(i.line, i.column, i.identifierName, i.identifierNamePos, i.filename), this._position.column += r) : (this._position.
      line++, this._position.column = 0), this._canMarkIdName && (i.identifierName = void 0, i.identifierNamePos = void 0);
    }
    _append(e, r, i) {
      let n = e.length, a = this._position;
      if (this._last = e.charCodeAt(n - 1), ++this._appendCount > 4096 ? (+this._str, this._buf += this._str, this._str = e, this._appendCount =
      0) : this._str += e, !i && !this._map) {
        a.column += n;
        return;
      }
      let {
        column: o,
        identifierName: l,
        identifierNamePos: u,
        filename: p
      } = r, m = r.line;
      (l != null || u != null) && this._canMarkIdName && (r.identifierName = void 0, r.identifierNamePos = void 0);
      let g = e.indexOf(`
`), I = 0;
      for (g !== 0 && this._mark(m, o, l, u, p); g !== -1; )
        a.line++, a.column = 0, I = g + 1, I < n && m !== void 0 && this._mark(++m, 0, null, null, p), g = e.indexOf(`
`, I);
      a.column += n - I;
    }
    _mark(e, r, i, n, a) {
      var o;
      (o = this._map) == null || o.mark(this._position, e, r, i, n, a);
    }
    removeTrailingNewline() {
      let e = this._queueCursor;
      e !== 0 && this._queue[e - 1].char === 10 && this._queueCursor--;
    }
    removeLastSemicolon() {
      let e = this._queueCursor;
      e !== 0 && this._queue[e - 1].char === 59 && this._queueCursor--;
    }
    getLastChar() {
      let e = this._queueCursor;
      return e !== 0 ? this._queue[e - 1].char : this._last;
    }
    getNewlineCount() {
      let e = this._queueCursor, r = 0;
      if (e === 0) return this._last === 10 ? 1 : 0;
      for (let i = e - 1; i >= 0 && this._queue[i].char === 10; i--)
        r++;
      return r === e && this._last === 10 ? r + 1 : r;
    }
    endsWithCharAndNewline() {
      let e = this._queue, r = this._queueCursor;
      if (r !== 0)
        return e[r - 1].char !== 10 ? void 0 : r > 1 ? e[r - 2].char : this._last;
    }
    hasContent() {
      return this._queueCursor !== 0 || !!this._last;
    }
    exactSource(e, r) {
      if (!this._map) {
        r();
        return;
      }
      this.source("start", e);
      let i = e.identifierName, n = this._sourcePosition;
      i && (this._canMarkIdName = !1, n.identifierName = i), r(), i && (this._canMarkIdName = !0, n.identifierName = void 0, n.identifierNamePos =
      void 0), this.source("end", e);
    }
    source(e, r) {
      this._map && this._normalizePosition(e, r, 0);
    }
    sourceWithOffset(e, r, i) {
      this._map && this._normalizePosition(e, r, i);
    }
    _normalizePosition(e, r, i) {
      let n = r[e], a = this._sourcePosition;
      n && (a.line = n.line, a.column = Math.max(n.column + i, 0), a.filename = r.filename);
    }
    getCurrentColumn() {
      let e = this._queue, r = this._queueCursor, i = -1, n = 0;
      for (let a = 0; a < r; a++) {
        let o = e[a];
        o.char === 10 && (i = n), n += o.repeat;
      }
      return i === -1 ? this._position.column + n : n - 1 - i;
    }
    getCurrentLine() {
      let e = 0, r = this._queue;
      for (let i = 0; i < this._queueCursor; i++)
        r[i].char === 10 && e++;
      return this._position.line + e;
    }
  };
  oi.default = hs;
});

// ../node_modules/@babel/types/lib/utils/shallowEqual.js
var li = O((ds) => {
  "use strict";
  Object.defineProperty(ds, "__esModule", {
    value: !0
  });
  ds.default = Mp;
  function Mp(t, e) {
    let r = Object.keys(e);
    for (let i of r)
      if (t[i] !== e[i])
        return !1;
    return !0;
  }
  s(Mp, "shallowEqual");
});

// ../node_modules/@babel/types/lib/utils/deprecationWarning.js
var Er = O((ms) => {
  "use strict";
  Object.defineProperty(ms, "__esModule", {
    value: !0
  });
  ms.default = Bp;
  var Uo = /* @__PURE__ */ new Set();
  function Bp(t, e, r = "") {
    if (Uo.has(t)) return;
    Uo.add(t);
    let {
      internal: i,
      trace: n
    } = jp(1, 2);
    i || console.warn(`${r}\`${t}\` has been deprecated, please migrate to \`${e}\`
${n}`);
  }
  s(Bp, "deprecationWarning");
  function jp(t, e) {
    let {
      stackTraceLimit: r,
      prepareStackTrace: i
    } = Error, n;
    if (Error.stackTraceLimit = 1 + t + e, Error.prepareStackTrace = function(o, l) {
      n = l;
    }, new Error().stack, Error.stackTraceLimit = r, Error.prepareStackTrace = i, !n) return {
      internal: !1,
      trace: ""
    };
    let a = n.slice(1 + t, 1 + t + e);
    return {
      internal: /[\\/]@babel[\\/]/.test(a[1].getFileName()),
      trace: a.map((o) => `    at ${o}`).join(`
`)
    };
  }
  s(jp, "captureShortStackTrace");
});

// ../node_modules/@babel/types/lib/validators/generated/index.js
var Be = O((h) => {
  "use strict";
  Object.defineProperty(h, "__esModule", {
    value: !0
  });
  h.isAccessor = eT;
  h.isAnyTypeAnnotation = xh;
  h.isArgumentPlaceholder = $d;
  h.isArrayExpression = Fp;
  h.isArrayPattern = jf;
  h.isArrayTypeAnnotation = Ph;
  h.isArrowFunctionExpression = Ff;
  h.isAssignmentExpression = Rp;
  h.isAssignmentPattern = Bf;
  h.isAwaitExpression = oh;
  h.isBigIntLiteral = uh;
  h.isBinary = gy;
  h.isBinaryExpression = qp;
  h.isBindExpression = Hd;
  h.isBlock = vy;
  h.isBlockParent = Iy;
  h.isBlockStatement = Yp;
  h.isBooleanLiteral = ff;
  h.isBooleanLiteralTypeAnnotation = gh;
  h.isBooleanTypeAnnotation = Eh;
  h.isBreakStatement = Jp;
  h.isCallExpression = Xp;
  h.isCatchClause = Wp;
  h.isClass = Gy;
  h.isClassAccessorProperty = dh;
  h.isClassBody = Rf;
  h.isClassDeclaration = Uf;
  h.isClassExpression = qf;
  h.isClassImplements = Ih;
  h.isClassMethod = Zf;
  h.isClassPrivateMethod = yh;
  h.isClassPrivateProperty = mh;
  h.isClassProperty = hh;
  h.isCompletionStatement = Ny;
  h.isConditional = Oy;
  h.isConditionalExpression = zp;
  h.isContinueStatement = $p;
  h.isDebuggerStatement = Hp;
  h.isDecimalLiteral = rm;
  h.isDeclaration = Ry;
  h.isDeclareClass = vh;
  h.isDeclareExportAllDeclaration = Mh;
  h.isDeclareExportDeclaration = Lh;
  h.isDeclareFunction = Ch;
  h.isDeclareInterface = wh;
  h.isDeclareModule = Nh;
  h.isDeclareModuleExports = Oh;
  h.isDeclareOpaqueType = Dh;
  h.isDeclareTypeAlias = _h;
  h.isDeclareVariable = kh;
  h.isDeclaredPredicate = Bh;
  h.isDecorator = Gd;
  h.isDirective = Kp;
  h.isDirectiveLiteral = Vp;
  h.isDoExpression = Qd;
  h.isDoWhileStatement = Gp;
  h.isEmptyStatement = Qp;
  h.isEmptyTypeAnnotation = Wh;
  h.isEnumBody = oT;
  h.isEnumBooleanBody = Pd;
  h.isEnumBooleanMember = Id;
  h.isEnumDeclaration = xd;
  h.isEnumDefaultedMember = wd;
  h.isEnumMember = lT;
  h.isEnumNumberBody = Ed;
  h.isEnumNumberMember = vd;
  h.isEnumStringBody = gd;
  h.isEnumStringMember = Cd;
  h.isEnumSymbolBody = Ad;
  h.isExistsTypeAnnotation = jh;
  h.isExportAllDeclaration = Kf;
  h.isExportDeclaration = Qy;
  h.isExportDefaultDeclaration = Vf;
  h.isExportDefaultSpecifier = Zd;
  h.isExportNamedDeclaration = Yf;
  h.isExportNamespaceSpecifier = ch;
  h.isExportSpecifier = Jf;
  h.isExpression = Ey;
  h.isExpressionStatement = Zp;
  h.isExpressionWrapper = ky;
  h.isFile = ef;
  h.isFlow = rT;
  h.isFlowBaseAnnotation = sT;
  h.isFlowDeclaration = nT;
  h.isFlowPredicate = aT;
  h.isFlowType = iT;
  h.isFor = Ly;
  h.isForInStatement = tf;
  h.isForOfStatement = Xf;
  h.isForStatement = rf;
  h.isForXStatement = My;
  h.isFunction = By;
  h.isFunctionDeclaration = sf;
  h.isFunctionExpression = nf;
  h.isFunctionParent = jy;
  h.isFunctionTypeAnnotation = Fh;
  h.isFunctionTypeParam = Rh;
  h.isGenericTypeAnnotation = qh;
  h.isIdentifier = af;
  h.isIfStatement = of;
  h.isImmutable = Yy;
  h.isImport = lh;
  h.isImportAttribute = bh;
  h.isImportDeclaration = Wf;
  h.isImportDefaultSpecifier = zf;
  h.isImportExpression = Gf;
  h.isImportNamespaceSpecifier = $f;
  h.isImportOrExportDeclaration = Ko;
  h.isImportSpecifier = Hf;
  h.isIndexedAccessType = Nd;
  h.isInferredPredicate = Uh;
  h.isInterfaceDeclaration = Vh;
  h.isInterfaceExtends = Kh;
  h.isInterfaceTypeAnnotation = Yh;
  h.isInterpreterDirective = Up;
  h.isIntersectionTypeAnnotation = Jh;
  h.isJSX = uT;
  h.isJSXAttribute = _d;
  h.isJSXClosingElement = Dd;
  h.isJSXClosingFragment = Jd;
  h.isJSXElement = kd;
  h.isJSXEmptyExpression = Ld;
  h.isJSXExpressionContainer = Md;
  h.isJSXFragment = Vd;
  h.isJSXIdentifier = jd;
  h.isJSXMemberExpression = Fd;
  h.isJSXNamespacedName = Rd;
  h.isJSXOpeningElement = qd;
  h.isJSXOpeningFragment = Yd;
  h.isJSXSpreadAttribute = Ud;
  h.isJSXSpreadChild = Bd;
  h.isJSXText = Kd;
  h.isLVal = Uy;
  h.isLabeledStatement = lf;
  h.isLiteral = Vy;
  h.isLogicalExpression = df;
  h.isLoop = _y;
  h.isMemberExpression = mf;
  h.isMetaProperty = Qf;
  h.isMethod = Xy;
  h.isMiscellaneous = cT;
  h.isMixedTypeAnnotation = Xh;
  h.isModuleDeclaration = bT;
  h.isModuleExpression = im;
  h.isModuleSpecifier = Zy;
  h.isNewExpression = yf;
  h.isNoop = Xd;
  h.isNullLiteral = pf;
  h.isNullLiteralTypeAnnotation = Ah;
  h.isNullableTypeAnnotation = zh;
  h.isNumberLiteral = mT;
  h.isNumberLiteralTypeAnnotation = $h;
  h.isNumberTypeAnnotation = Hh;
  h.isNumericLiteral = cf;
  h.isObjectExpression = Sf;
  h.isObjectMember = Wy;
  h.isObjectMethod = bf;
  h.isObjectPattern = eh;
  h.isObjectProperty = xf;
  h.isObjectTypeAnnotation = Gh;
  h.isObjectTypeCallProperty = Zh;
  h.isObjectTypeIndexer = ed;
  h.isObjectTypeInternalSlot = Qh;
  h.isObjectTypeProperty = td;
  h.isObjectTypeSpreadProperty = rd;
  h.isOpaqueType = id;
  h.isOptionalCallExpression = fh;
  h.isOptionalIndexedAccessType = Od;
  h.isOptionalMemberExpression = ph;
  h.isParenthesizedExpression = Af;
  h.isPattern = Hy;
  h.isPatternLike = qy;
  h.isPipelineBareFunction = am;
  h.isPipelinePrimaryTopicReference = om;
  h.isPipelineTopicExpression = nm;
  h.isPlaceholder = Wd;
  h.isPrivate = tT;
  h.isPrivateName = Th;
  h.isProgram = Tf;
  h.isProperty = zy;
  h.isPureish = Fy;
  h.isQualifiedTypeIdentifier = sd;
  h.isRecordExpression = em;
  h.isRegExpLiteral = hf;
  h.isRegexLiteral = yT;
  h.isRestElement = Pf;
  h.isRestProperty = TT;
  h.isReturnStatement = Ef;
  h.isScopable = Ay;
  h.isSequenceExpression = gf;
  h.isSpreadElement = th;
  h.isSpreadProperty = ST;
  h.isStandardized = Py;
  h.isStatement = Cy;
  h.isStaticBlock = Sh;
  h.isStringLiteral = uf;
  h.isStringLiteralTypeAnnotation = nd;
  h.isStringTypeAnnotation = ad;
  h.isSuper = rh;
  h.isSwitchCase = If;
  h.isSwitchStatement = vf;
  h.isSymbolTypeAnnotation = od;
  h.isTSAnyKeyword = Tm;
  h.isTSArrayType = jm;
  h.isTSAsExpression = iy;
  h.isTSBaseType = dT;
  h.isTSBigIntKeyword = bm;
  h.isTSBooleanKeyword = Sm;
  h.isTSCallSignatureDeclaration = fm;
  h.isTSConditionalType = Ym;
  h.isTSConstructSignatureDeclaration = hm;
  h.isTSConstructorType = Dm;
  h.isTSDeclareFunction = um;
  h.isTSDeclareMethod = cm;
  h.isTSEntityName = Ky;
  h.isTSEnumBody = ay;
  h.isTSEnumDeclaration = oy;
  h.isTSEnumMember = ly;
  h.isTSExportAssignment = my;
  h.isTSExpressionWithTypeArguments = Qm;
  h.isTSExternalModuleReference = hy;
  h.isTSFunctionType = _m;
  h.isTSImportEqualsDeclaration = fy;
  h.isTSImportType = py;
  h.isTSIndexSignature = ym;
  h.isTSIndexedAccessType = zm;
  h.isTSInferType = Jm;
  h.isTSInstantiationExpression = ry;
  h.isTSInterfaceBody = ey;
  h.isTSInterfaceDeclaration = Zm;
  h.isTSIntersectionType = Vm;
  h.isTSIntrinsicKeyword = xm;
  h.isTSLiteralType = Gm;
  h.isTSMappedType = $m;
  h.isTSMethodSignature = mm;
  h.isTSModuleBlock = cy;
  h.isTSModuleDeclaration = uy;
  h.isTSNamedTupleMember = Um;
  h.isTSNamespaceExportDeclaration = yy;
  h.isTSNeverKeyword = Pm;
  h.isTSNonNullExpression = dy;
  h.isTSNullKeyword = Em;
  h.isTSNumberKeyword = gm;
  h.isTSObjectKeyword = Am;
  h.isTSOptionalType = Rm;
  h.isTSParameterProperty = lm;
  h.isTSParenthesizedType = Xm;
  h.isTSPropertySignature = dm;
  h.isTSQualifiedName = pm;
  h.isTSRestType = qm;
  h.isTSSatisfiesExpression = sy;
  h.isTSStringKeyword = Im;
  h.isTSSymbolKeyword = vm;
  h.isTSTemplateLiteralType = Hm;
  h.isTSThisType = Om;
  h.isTSTupleType = Fm;
  h.isTSType = hT;
  h.isTSTypeAliasDeclaration = ty;
  h.isTSTypeAnnotation = Ty;
  h.isTSTypeAssertion = ny;
  h.isTSTypeElement = fT;
  h.isTSTypeLiteral = Bm;
  h.isTSTypeOperator = Wm;
  h.isTSTypeParameter = xy;
  h.isTSTypeParameterDeclaration = by;
  h.isTSTypeParameterInstantiation = Sy;
  h.isTSTypePredicate = Lm;
  h.isTSTypeQuery = Mm;
  h.isTSTypeReference = km;
  h.isTSUndefinedKeyword = Cm;
  h.isTSUnionType = Km;
  h.isTSUnknownKeyword = wm;
  h.isTSVoidKeyword = Nm;
  h.isTaggedTemplateExpression = ih;
  h.isTemplateElement = sh;
  h.isTemplateLiteral = nh;
  h.isTerminatorless = wy;
  h.isThisExpression = Cf;
  h.isThisTypeAnnotation = ld;
  h.isThrowStatement = wf;
  h.isTopicReference = sm;
  h.isTryStatement = Nf;
  h.isTupleExpression = tm;
  h.isTupleTypeAnnotation = ud;
  h.isTypeAlias = pd;
  h.isTypeAnnotation = fd;
  h.isTypeCastExpression = hd;
  h.isTypeParameter = dd;
  h.isTypeParameterDeclaration = md;
  h.isTypeParameterInstantiation = yd;
  h.isTypeScript = pT;
  h.isTypeofTypeAnnotation = cd;
  h.isUnaryExpression = Of;
  h.isUnaryLike = $y;
  h.isUnionTypeAnnotation = Td;
  h.isUpdateExpression = _f;
  h.isUserWhitespacable = Jy;
  h.isV8IntrinsicIdentifier = zd;
  h.isVariableDeclaration = Df;
  h.isVariableDeclarator = kf;
  h.isVariance = Sd;
  h.isVoidTypeAnnotation = bd;
  h.isWhile = Dy;
  h.isWhileStatement = Lf;
  h.isWithStatement = Mf;
  h.isYieldExpression = ah;
  var T = li(), gr = Er();
  function Fp(t, e) {
    return !t || t.type !== "ArrayExpression" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Fp, "isArrayExpression");
  function Rp(t, e) {
    return !t || t.type !== "AssignmentExpression" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Rp, "isAssignmentExpression");
  function qp(t, e) {
    return !t || t.type !== "BinaryExpression" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(qp, "isBinaryExpression");
  function Up(t, e) {
    return !t || t.type !== "InterpreterDirective" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Up, "isInterpreterDirective");
  function Kp(t, e) {
    return !t || t.type !== "Directive" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Kp, "isDirective");
  function Vp(t, e) {
    return !t || t.type !== "DirectiveLiteral" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Vp, "isDirectiveLiteral");
  function Yp(t, e) {
    return !t || t.type !== "BlockStatement" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Yp, "isBlockStatement");
  function Jp(t, e) {
    return !t || t.type !== "BreakStatement" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Jp, "isBreakStatement");
  function Xp(t, e) {
    return !t || t.type !== "CallExpression" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Xp, "isCallExpression");
  function Wp(t, e) {
    return !t || t.type !== "CatchClause" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Wp, "isCatchClause");
  function zp(t, e) {
    return !t || t.type !== "ConditionalExpression" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(zp, "isConditionalExpression");
  function $p(t, e) {
    return !t || t.type !== "ContinueStatement" ? !1 : e == null || (0, T.default)(t, e);
  }
  s($p, "isContinueStatement");
  function Hp(t, e) {
    return !t || t.type !== "DebuggerStatement" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Hp, "isDebuggerStatement");
  function Gp(t, e) {
    return !t || t.type !== "DoWhileStatement" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Gp, "isDoWhileStatement");
  function Qp(t, e) {
    return !t || t.type !== "EmptyStatement" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Qp, "isEmptyStatement");
  function Zp(t, e) {
    return !t || t.type !== "ExpressionStatement" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Zp, "isExpressionStatement");
  function ef(t, e) {
    return !t || t.type !== "File" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(ef, "isFile");
  function tf(t, e) {
    return !t || t.type !== "ForInStatement" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(tf, "isForInStatement");
  function rf(t, e) {
    return !t || t.type !== "ForStatement" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(rf, "isForStatement");
  function sf(t, e) {
    return !t || t.type !== "FunctionDeclaration" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(sf, "isFunctionDeclaration");
  function nf(t, e) {
    return !t || t.type !== "FunctionExpression" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(nf, "isFunctionExpression");
  function af(t, e) {
    return !t || t.type !== "Identifier" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(af, "isIdentifier");
  function of(t, e) {
    return !t || t.type !== "IfStatement" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(of, "isIfStatement");
  function lf(t, e) {
    return !t || t.type !== "LabeledStatement" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(lf, "isLabeledStatement");
  function uf(t, e) {
    return !t || t.type !== "StringLiteral" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(uf, "isStringLiteral");
  function cf(t, e) {
    return !t || t.type !== "NumericLiteral" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(cf, "isNumericLiteral");
  function pf(t, e) {
    return !t || t.type !== "NullLiteral" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(pf, "isNullLiteral");
  function ff(t, e) {
    return !t || t.type !== "BooleanLiteral" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(ff, "isBooleanLiteral");
  function hf(t, e) {
    return !t || t.type !== "RegExpLiteral" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(hf, "isRegExpLiteral");
  function df(t, e) {
    return !t || t.type !== "LogicalExpression" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(df, "isLogicalExpression");
  function mf(t, e) {
    return !t || t.type !== "MemberExpression" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(mf, "isMemberExpression");
  function yf(t, e) {
    return !t || t.type !== "NewExpression" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(yf, "isNewExpression");
  function Tf(t, e) {
    return !t || t.type !== "Program" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Tf, "isProgram");
  function Sf(t, e) {
    return !t || t.type !== "ObjectExpression" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Sf, "isObjectExpression");
  function bf(t, e) {
    return !t || t.type !== "ObjectMethod" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(bf, "isObjectMethod");
  function xf(t, e) {
    return !t || t.type !== "ObjectProperty" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(xf, "isObjectProperty");
  function Pf(t, e) {
    return !t || t.type !== "RestElement" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Pf, "isRestElement");
  function Ef(t, e) {
    return !t || t.type !== "ReturnStatement" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Ef, "isReturnStatement");
  function gf(t, e) {
    return !t || t.type !== "SequenceExpression" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(gf, "isSequenceExpression");
  function Af(t, e) {
    return !t || t.type !== "ParenthesizedExpression" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Af, "isParenthesizedExpression");
  function If(t, e) {
    return !t || t.type !== "SwitchCase" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(If, "isSwitchCase");
  function vf(t, e) {
    return !t || t.type !== "SwitchStatement" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(vf, "isSwitchStatement");
  function Cf(t, e) {
    return !t || t.type !== "ThisExpression" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Cf, "isThisExpression");
  function wf(t, e) {
    return !t || t.type !== "ThrowStatement" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(wf, "isThrowStatement");
  function Nf(t, e) {
    return !t || t.type !== "TryStatement" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Nf, "isTryStatement");
  function Of(t, e) {
    return !t || t.type !== "UnaryExpression" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Of, "isUnaryExpression");
  function _f(t, e) {
    return !t || t.type !== "UpdateExpression" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(_f, "isUpdateExpression");
  function Df(t, e) {
    return !t || t.type !== "VariableDeclaration" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Df, "isVariableDeclaration");
  function kf(t, e) {
    return !t || t.type !== "VariableDeclarator" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(kf, "isVariableDeclarator");
  function Lf(t, e) {
    return !t || t.type !== "WhileStatement" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Lf, "isWhileStatement");
  function Mf(t, e) {
    return !t || t.type !== "WithStatement" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Mf, "isWithStatement");
  function Bf(t, e) {
    return !t || t.type !== "AssignmentPattern" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Bf, "isAssignmentPattern");
  function jf(t, e) {
    return !t || t.type !== "ArrayPattern" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(jf, "isArrayPattern");
  function Ff(t, e) {
    return !t || t.type !== "ArrowFunctionExpression" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Ff, "isArrowFunctionExpression");
  function Rf(t, e) {
    return !t || t.type !== "ClassBody" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Rf, "isClassBody");
  function qf(t, e) {
    return !t || t.type !== "ClassExpression" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(qf, "isClassExpression");
  function Uf(t, e) {
    return !t || t.type !== "ClassDeclaration" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Uf, "isClassDeclaration");
  function Kf(t, e) {
    return !t || t.type !== "ExportAllDeclaration" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Kf, "isExportAllDeclaration");
  function Vf(t, e) {
    return !t || t.type !== "ExportDefaultDeclaration" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Vf, "isExportDefaultDeclaration");
  function Yf(t, e) {
    return !t || t.type !== "ExportNamedDeclaration" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Yf, "isExportNamedDeclaration");
  function Jf(t, e) {
    return !t || t.type !== "ExportSpecifier" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Jf, "isExportSpecifier");
  function Xf(t, e) {
    return !t || t.type !== "ForOfStatement" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Xf, "isForOfStatement");
  function Wf(t, e) {
    return !t || t.type !== "ImportDeclaration" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Wf, "isImportDeclaration");
  function zf(t, e) {
    return !t || t.type !== "ImportDefaultSpecifier" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(zf, "isImportDefaultSpecifier");
  function $f(t, e) {
    return !t || t.type !== "ImportNamespaceSpecifier" ? !1 : e == null || (0, T.default)(t, e);
  }
  s($f, "isImportNamespaceSpecifier");
  function Hf(t, e) {
    return !t || t.type !== "ImportSpecifier" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Hf, "isImportSpecifier");
  function Gf(t, e) {
    return !t || t.type !== "ImportExpression" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Gf, "isImportExpression");
  function Qf(t, e) {
    return !t || t.type !== "MetaProperty" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Qf, "isMetaProperty");
  function Zf(t, e) {
    return !t || t.type !== "ClassMethod" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Zf, "isClassMethod");
  function eh(t, e) {
    return !t || t.type !== "ObjectPattern" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(eh, "isObjectPattern");
  function th(t, e) {
    return !t || t.type !== "SpreadElement" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(th, "isSpreadElement");
  function rh(t, e) {
    return !t || t.type !== "Super" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(rh, "isSuper");
  function ih(t, e) {
    return !t || t.type !== "TaggedTemplateExpression" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(ih, "isTaggedTemplateExpression");
  function sh(t, e) {
    return !t || t.type !== "TemplateElement" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(sh, "isTemplateElement");
  function nh(t, e) {
    return !t || t.type !== "TemplateLiteral" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(nh, "isTemplateLiteral");
  function ah(t, e) {
    return !t || t.type !== "YieldExpression" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(ah, "isYieldExpression");
  function oh(t, e) {
    return !t || t.type !== "AwaitExpression" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(oh, "isAwaitExpression");
  function lh(t, e) {
    return !t || t.type !== "Import" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(lh, "isImport");
  function uh(t, e) {
    return !t || t.type !== "BigIntLiteral" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(uh, "isBigIntLiteral");
  function ch(t, e) {
    return !t || t.type !== "ExportNamespaceSpecifier" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(ch, "isExportNamespaceSpecifier");
  function ph(t, e) {
    return !t || t.type !== "OptionalMemberExpression" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(ph, "isOptionalMemberExpression");
  function fh(t, e) {
    return !t || t.type !== "OptionalCallExpression" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(fh, "isOptionalCallExpression");
  function hh(t, e) {
    return !t || t.type !== "ClassProperty" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(hh, "isClassProperty");
  function dh(t, e) {
    return !t || t.type !== "ClassAccessorProperty" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(dh, "isClassAccessorProperty");
  function mh(t, e) {
    return !t || t.type !== "ClassPrivateProperty" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(mh, "isClassPrivateProperty");
  function yh(t, e) {
    return !t || t.type !== "ClassPrivateMethod" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(yh, "isClassPrivateMethod");
  function Th(t, e) {
    return !t || t.type !== "PrivateName" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Th, "isPrivateName");
  function Sh(t, e) {
    return !t || t.type !== "StaticBlock" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Sh, "isStaticBlock");
  function bh(t, e) {
    return !t || t.type !== "ImportAttribute" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(bh, "isImportAttribute");
  function xh(t, e) {
    return !t || t.type !== "AnyTypeAnnotation" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(xh, "isAnyTypeAnnotation");
  function Ph(t, e) {
    return !t || t.type !== "ArrayTypeAnnotation" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Ph, "isArrayTypeAnnotation");
  function Eh(t, e) {
    return !t || t.type !== "BooleanTypeAnnotation" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Eh, "isBooleanTypeAnnotation");
  function gh(t, e) {
    return !t || t.type !== "BooleanLiteralTypeAnnotation" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(gh, "isBooleanLiteralTypeAnnotation");
  function Ah(t, e) {
    return !t || t.type !== "NullLiteralTypeAnnotation" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Ah, "isNullLiteralTypeAnnotation");
  function Ih(t, e) {
    return !t || t.type !== "ClassImplements" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Ih, "isClassImplements");
  function vh(t, e) {
    return !t || t.type !== "DeclareClass" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(vh, "isDeclareClass");
  function Ch(t, e) {
    return !t || t.type !== "DeclareFunction" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Ch, "isDeclareFunction");
  function wh(t, e) {
    return !t || t.type !== "DeclareInterface" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(wh, "isDeclareInterface");
  function Nh(t, e) {
    return !t || t.type !== "DeclareModule" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Nh, "isDeclareModule");
  function Oh(t, e) {
    return !t || t.type !== "DeclareModuleExports" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Oh, "isDeclareModuleExports");
  function _h(t, e) {
    return !t || t.type !== "DeclareTypeAlias" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(_h, "isDeclareTypeAlias");
  function Dh(t, e) {
    return !t || t.type !== "DeclareOpaqueType" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Dh, "isDeclareOpaqueType");
  function kh(t, e) {
    return !t || t.type !== "DeclareVariable" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(kh, "isDeclareVariable");
  function Lh(t, e) {
    return !t || t.type !== "DeclareExportDeclaration" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Lh, "isDeclareExportDeclaration");
  function Mh(t, e) {
    return !t || t.type !== "DeclareExportAllDeclaration" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Mh, "isDeclareExportAllDeclaration");
  function Bh(t, e) {
    return !t || t.type !== "DeclaredPredicate" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Bh, "isDeclaredPredicate");
  function jh(t, e) {
    return !t || t.type !== "ExistsTypeAnnotation" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(jh, "isExistsTypeAnnotation");
  function Fh(t, e) {
    return !t || t.type !== "FunctionTypeAnnotation" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Fh, "isFunctionTypeAnnotation");
  function Rh(t, e) {
    return !t || t.type !== "FunctionTypeParam" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Rh, "isFunctionTypeParam");
  function qh(t, e) {
    return !t || t.type !== "GenericTypeAnnotation" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(qh, "isGenericTypeAnnotation");
  function Uh(t, e) {
    return !t || t.type !== "InferredPredicate" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Uh, "isInferredPredicate");
  function Kh(t, e) {
    return !t || t.type !== "InterfaceExtends" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Kh, "isInterfaceExtends");
  function Vh(t, e) {
    return !t || t.type !== "InterfaceDeclaration" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Vh, "isInterfaceDeclaration");
  function Yh(t, e) {
    return !t || t.type !== "InterfaceTypeAnnotation" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Yh, "isInterfaceTypeAnnotation");
  function Jh(t, e) {
    return !t || t.type !== "IntersectionTypeAnnotation" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Jh, "isIntersectionTypeAnnotation");
  function Xh(t, e) {
    return !t || t.type !== "MixedTypeAnnotation" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Xh, "isMixedTypeAnnotation");
  function Wh(t, e) {
    return !t || t.type !== "EmptyTypeAnnotation" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Wh, "isEmptyTypeAnnotation");
  function zh(t, e) {
    return !t || t.type !== "NullableTypeAnnotation" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(zh, "isNullableTypeAnnotation");
  function $h(t, e) {
    return !t || t.type !== "NumberLiteralTypeAnnotation" ? !1 : e == null || (0, T.default)(t, e);
  }
  s($h, "isNumberLiteralTypeAnnotation");
  function Hh(t, e) {
    return !t || t.type !== "NumberTypeAnnotation" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Hh, "isNumberTypeAnnotation");
  function Gh(t, e) {
    return !t || t.type !== "ObjectTypeAnnotation" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Gh, "isObjectTypeAnnotation");
  function Qh(t, e) {
    return !t || t.type !== "ObjectTypeInternalSlot" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Qh, "isObjectTypeInternalSlot");
  function Zh(t, e) {
    return !t || t.type !== "ObjectTypeCallProperty" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Zh, "isObjectTypeCallProperty");
  function ed(t, e) {
    return !t || t.type !== "ObjectTypeIndexer" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(ed, "isObjectTypeIndexer");
  function td(t, e) {
    return !t || t.type !== "ObjectTypeProperty" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(td, "isObjectTypeProperty");
  function rd(t, e) {
    return !t || t.type !== "ObjectTypeSpreadProperty" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(rd, "isObjectTypeSpreadProperty");
  function id(t, e) {
    return !t || t.type !== "OpaqueType" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(id, "isOpaqueType");
  function sd(t, e) {
    return !t || t.type !== "QualifiedTypeIdentifier" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(sd, "isQualifiedTypeIdentifier");
  function nd(t, e) {
    return !t || t.type !== "StringLiteralTypeAnnotation" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(nd, "isStringLiteralTypeAnnotation");
  function ad(t, e) {
    return !t || t.type !== "StringTypeAnnotation" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(ad, "isStringTypeAnnotation");
  function od(t, e) {
    return !t || t.type !== "SymbolTypeAnnotation" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(od, "isSymbolTypeAnnotation");
  function ld(t, e) {
    return !t || t.type !== "ThisTypeAnnotation" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(ld, "isThisTypeAnnotation");
  function ud(t, e) {
    return !t || t.type !== "TupleTypeAnnotation" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(ud, "isTupleTypeAnnotation");
  function cd(t, e) {
    return !t || t.type !== "TypeofTypeAnnotation" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(cd, "isTypeofTypeAnnotation");
  function pd(t, e) {
    return !t || t.type !== "TypeAlias" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(pd, "isTypeAlias");
  function fd(t, e) {
    return !t || t.type !== "TypeAnnotation" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(fd, "isTypeAnnotation");
  function hd(t, e) {
    return !t || t.type !== "TypeCastExpression" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(hd, "isTypeCastExpression");
  function dd(t, e) {
    return !t || t.type !== "TypeParameter" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(dd, "isTypeParameter");
  function md(t, e) {
    return !t || t.type !== "TypeParameterDeclaration" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(md, "isTypeParameterDeclaration");
  function yd(t, e) {
    return !t || t.type !== "TypeParameterInstantiation" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(yd, "isTypeParameterInstantiation");
  function Td(t, e) {
    return !t || t.type !== "UnionTypeAnnotation" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Td, "isUnionTypeAnnotation");
  function Sd(t, e) {
    return !t || t.type !== "Variance" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Sd, "isVariance");
  function bd(t, e) {
    return !t || t.type !== "VoidTypeAnnotation" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(bd, "isVoidTypeAnnotation");
  function xd(t, e) {
    return !t || t.type !== "EnumDeclaration" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(xd, "isEnumDeclaration");
  function Pd(t, e) {
    return !t || t.type !== "EnumBooleanBody" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Pd, "isEnumBooleanBody");
  function Ed(t, e) {
    return !t || t.type !== "EnumNumberBody" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Ed, "isEnumNumberBody");
  function gd(t, e) {
    return !t || t.type !== "EnumStringBody" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(gd, "isEnumStringBody");
  function Ad(t, e) {
    return !t || t.type !== "EnumSymbolBody" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Ad, "isEnumSymbolBody");
  function Id(t, e) {
    return !t || t.type !== "EnumBooleanMember" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Id, "isEnumBooleanMember");
  function vd(t, e) {
    return !t || t.type !== "EnumNumberMember" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(vd, "isEnumNumberMember");
  function Cd(t, e) {
    return !t || t.type !== "EnumStringMember" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Cd, "isEnumStringMember");
  function wd(t, e) {
    return !t || t.type !== "EnumDefaultedMember" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(wd, "isEnumDefaultedMember");
  function Nd(t, e) {
    return !t || t.type !== "IndexedAccessType" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Nd, "isIndexedAccessType");
  function Od(t, e) {
    return !t || t.type !== "OptionalIndexedAccessType" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Od, "isOptionalIndexedAccessType");
  function _d(t, e) {
    return !t || t.type !== "JSXAttribute" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(_d, "isJSXAttribute");
  function Dd(t, e) {
    return !t || t.type !== "JSXClosingElement" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Dd, "isJSXClosingElement");
  function kd(t, e) {
    return !t || t.type !== "JSXElement" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(kd, "isJSXElement");
  function Ld(t, e) {
    return !t || t.type !== "JSXEmptyExpression" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Ld, "isJSXEmptyExpression");
  function Md(t, e) {
    return !t || t.type !== "JSXExpressionContainer" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Md, "isJSXExpressionContainer");
  function Bd(t, e) {
    return !t || t.type !== "JSXSpreadChild" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Bd, "isJSXSpreadChild");
  function jd(t, e) {
    return !t || t.type !== "JSXIdentifier" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(jd, "isJSXIdentifier");
  function Fd(t, e) {
    return !t || t.type !== "JSXMemberExpression" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Fd, "isJSXMemberExpression");
  function Rd(t, e) {
    return !t || t.type !== "JSXNamespacedName" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Rd, "isJSXNamespacedName");
  function qd(t, e) {
    return !t || t.type !== "JSXOpeningElement" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(qd, "isJSXOpeningElement");
  function Ud(t, e) {
    return !t || t.type !== "JSXSpreadAttribute" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Ud, "isJSXSpreadAttribute");
  function Kd(t, e) {
    return !t || t.type !== "JSXText" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Kd, "isJSXText");
  function Vd(t, e) {
    return !t || t.type !== "JSXFragment" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Vd, "isJSXFragment");
  function Yd(t, e) {
    return !t || t.type !== "JSXOpeningFragment" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Yd, "isJSXOpeningFragment");
  function Jd(t, e) {
    return !t || t.type !== "JSXClosingFragment" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Jd, "isJSXClosingFragment");
  function Xd(t, e) {
    return !t || t.type !== "Noop" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Xd, "isNoop");
  function Wd(t, e) {
    return !t || t.type !== "Placeholder" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Wd, "isPlaceholder");
  function zd(t, e) {
    return !t || t.type !== "V8IntrinsicIdentifier" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(zd, "isV8IntrinsicIdentifier");
  function $d(t, e) {
    return !t || t.type !== "ArgumentPlaceholder" ? !1 : e == null || (0, T.default)(t, e);
  }
  s($d, "isArgumentPlaceholder");
  function Hd(t, e) {
    return !t || t.type !== "BindExpression" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Hd, "isBindExpression");
  function Gd(t, e) {
    return !t || t.type !== "Decorator" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Gd, "isDecorator");
  function Qd(t, e) {
    return !t || t.type !== "DoExpression" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Qd, "isDoExpression");
  function Zd(t, e) {
    return !t || t.type !== "ExportDefaultSpecifier" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Zd, "isExportDefaultSpecifier");
  function em(t, e) {
    return !t || t.type !== "RecordExpression" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(em, "isRecordExpression");
  function tm(t, e) {
    return !t || t.type !== "TupleExpression" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(tm, "isTupleExpression");
  function rm(t, e) {
    return !t || t.type !== "DecimalLiteral" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(rm, "isDecimalLiteral");
  function im(t, e) {
    return !t || t.type !== "ModuleExpression" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(im, "isModuleExpression");
  function sm(t, e) {
    return !t || t.type !== "TopicReference" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(sm, "isTopicReference");
  function nm(t, e) {
    return !t || t.type !== "PipelineTopicExpression" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(nm, "isPipelineTopicExpression");
  function am(t, e) {
    return !t || t.type !== "PipelineBareFunction" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(am, "isPipelineBareFunction");
  function om(t, e) {
    return !t || t.type !== "PipelinePrimaryTopicReference" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(om, "isPipelinePrimaryTopicReference");
  function lm(t, e) {
    return !t || t.type !== "TSParameterProperty" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(lm, "isTSParameterProperty");
  function um(t, e) {
    return !t || t.type !== "TSDeclareFunction" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(um, "isTSDeclareFunction");
  function cm(t, e) {
    return !t || t.type !== "TSDeclareMethod" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(cm, "isTSDeclareMethod");
  function pm(t, e) {
    return !t || t.type !== "TSQualifiedName" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(pm, "isTSQualifiedName");
  function fm(t, e) {
    return !t || t.type !== "TSCallSignatureDeclaration" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(fm, "isTSCallSignatureDeclaration");
  function hm(t, e) {
    return !t || t.type !== "TSConstructSignatureDeclaration" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(hm, "isTSConstructSignatureDeclaration");
  function dm(t, e) {
    return !t || t.type !== "TSPropertySignature" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(dm, "isTSPropertySignature");
  function mm(t, e) {
    return !t || t.type !== "TSMethodSignature" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(mm, "isTSMethodSignature");
  function ym(t, e) {
    return !t || t.type !== "TSIndexSignature" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(ym, "isTSIndexSignature");
  function Tm(t, e) {
    return !t || t.type !== "TSAnyKeyword" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Tm, "isTSAnyKeyword");
  function Sm(t, e) {
    return !t || t.type !== "TSBooleanKeyword" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Sm, "isTSBooleanKeyword");
  function bm(t, e) {
    return !t || t.type !== "TSBigIntKeyword" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(bm, "isTSBigIntKeyword");
  function xm(t, e) {
    return !t || t.type !== "TSIntrinsicKeyword" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(xm, "isTSIntrinsicKeyword");
  function Pm(t, e) {
    return !t || t.type !== "TSNeverKeyword" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Pm, "isTSNeverKeyword");
  function Em(t, e) {
    return !t || t.type !== "TSNullKeyword" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Em, "isTSNullKeyword");
  function gm(t, e) {
    return !t || t.type !== "TSNumberKeyword" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(gm, "isTSNumberKeyword");
  function Am(t, e) {
    return !t || t.type !== "TSObjectKeyword" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Am, "isTSObjectKeyword");
  function Im(t, e) {
    return !t || t.type !== "TSStringKeyword" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Im, "isTSStringKeyword");
  function vm(t, e) {
    return !t || t.type !== "TSSymbolKeyword" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(vm, "isTSSymbolKeyword");
  function Cm(t, e) {
    return !t || t.type !== "TSUndefinedKeyword" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Cm, "isTSUndefinedKeyword");
  function wm(t, e) {
    return !t || t.type !== "TSUnknownKeyword" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(wm, "isTSUnknownKeyword");
  function Nm(t, e) {
    return !t || t.type !== "TSVoidKeyword" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Nm, "isTSVoidKeyword");
  function Om(t, e) {
    return !t || t.type !== "TSThisType" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Om, "isTSThisType");
  function _m(t, e) {
    return !t || t.type !== "TSFunctionType" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(_m, "isTSFunctionType");
  function Dm(t, e) {
    return !t || t.type !== "TSConstructorType" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Dm, "isTSConstructorType");
  function km(t, e) {
    return !t || t.type !== "TSTypeReference" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(km, "isTSTypeReference");
  function Lm(t, e) {
    return !t || t.type !== "TSTypePredicate" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Lm, "isTSTypePredicate");
  function Mm(t, e) {
    return !t || t.type !== "TSTypeQuery" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Mm, "isTSTypeQuery");
  function Bm(t, e) {
    return !t || t.type !== "TSTypeLiteral" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Bm, "isTSTypeLiteral");
  function jm(t, e) {
    return !t || t.type !== "TSArrayType" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(jm, "isTSArrayType");
  function Fm(t, e) {
    return !t || t.type !== "TSTupleType" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Fm, "isTSTupleType");
  function Rm(t, e) {
    return !t || t.type !== "TSOptionalType" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Rm, "isTSOptionalType");
  function qm(t, e) {
    return !t || t.type !== "TSRestType" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(qm, "isTSRestType");
  function Um(t, e) {
    return !t || t.type !== "TSNamedTupleMember" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Um, "isTSNamedTupleMember");
  function Km(t, e) {
    return !t || t.type !== "TSUnionType" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Km, "isTSUnionType");
  function Vm(t, e) {
    return !t || t.type !== "TSIntersectionType" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Vm, "isTSIntersectionType");
  function Ym(t, e) {
    return !t || t.type !== "TSConditionalType" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Ym, "isTSConditionalType");
  function Jm(t, e) {
    return !t || t.type !== "TSInferType" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Jm, "isTSInferType");
  function Xm(t, e) {
    return !t || t.type !== "TSParenthesizedType" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Xm, "isTSParenthesizedType");
  function Wm(t, e) {
    return !t || t.type !== "TSTypeOperator" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Wm, "isTSTypeOperator");
  function zm(t, e) {
    return !t || t.type !== "TSIndexedAccessType" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(zm, "isTSIndexedAccessType");
  function $m(t, e) {
    return !t || t.type !== "TSMappedType" ? !1 : e == null || (0, T.default)(t, e);
  }
  s($m, "isTSMappedType");
  function Hm(t, e) {
    return !t || t.type !== "TSTemplateLiteralType" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Hm, "isTSTemplateLiteralType");
  function Gm(t, e) {
    return !t || t.type !== "TSLiteralType" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Gm, "isTSLiteralType");
  function Qm(t, e) {
    return !t || t.type !== "TSExpressionWithTypeArguments" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Qm, "isTSExpressionWithTypeArguments");
  function Zm(t, e) {
    return !t || t.type !== "TSInterfaceDeclaration" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Zm, "isTSInterfaceDeclaration");
  function ey(t, e) {
    return !t || t.type !== "TSInterfaceBody" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(ey, "isTSInterfaceBody");
  function ty(t, e) {
    return !t || t.type !== "TSTypeAliasDeclaration" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(ty, "isTSTypeAliasDeclaration");
  function ry(t, e) {
    return !t || t.type !== "TSInstantiationExpression" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(ry, "isTSInstantiationExpression");
  function iy(t, e) {
    return !t || t.type !== "TSAsExpression" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(iy, "isTSAsExpression");
  function sy(t, e) {
    return !t || t.type !== "TSSatisfiesExpression" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(sy, "isTSSatisfiesExpression");
  function ny(t, e) {
    return !t || t.type !== "TSTypeAssertion" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(ny, "isTSTypeAssertion");
  function ay(t, e) {
    return !t || t.type !== "TSEnumBody" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(ay, "isTSEnumBody");
  function oy(t, e) {
    return !t || t.type !== "TSEnumDeclaration" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(oy, "isTSEnumDeclaration");
  function ly(t, e) {
    return !t || t.type !== "TSEnumMember" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(ly, "isTSEnumMember");
  function uy(t, e) {
    return !t || t.type !== "TSModuleDeclaration" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(uy, "isTSModuleDeclaration");
  function cy(t, e) {
    return !t || t.type !== "TSModuleBlock" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(cy, "isTSModuleBlock");
  function py(t, e) {
    return !t || t.type !== "TSImportType" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(py, "isTSImportType");
  function fy(t, e) {
    return !t || t.type !== "TSImportEqualsDeclaration" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(fy, "isTSImportEqualsDeclaration");
  function hy(t, e) {
    return !t || t.type !== "TSExternalModuleReference" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(hy, "isTSExternalModuleReference");
  function dy(t, e) {
    return !t || t.type !== "TSNonNullExpression" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(dy, "isTSNonNullExpression");
  function my(t, e) {
    return !t || t.type !== "TSExportAssignment" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(my, "isTSExportAssignment");
  function yy(t, e) {
    return !t || t.type !== "TSNamespaceExportDeclaration" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(yy, "isTSNamespaceExportDeclaration");
  function Ty(t, e) {
    return !t || t.type !== "TSTypeAnnotation" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Ty, "isTSTypeAnnotation");
  function Sy(t, e) {
    return !t || t.type !== "TSTypeParameterInstantiation" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Sy, "isTSTypeParameterInstantiation");
  function by(t, e) {
    return !t || t.type !== "TSTypeParameterDeclaration" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(by, "isTSTypeParameterDeclaration");
  function xy(t, e) {
    return !t || t.type !== "TSTypeParameter" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(xy, "isTSTypeParameter");
  function Py(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ArrayExpression":
      case "AssignmentExpression":
      case "BinaryExpression":
      case "InterpreterDirective":
      case "Directive":
      case "DirectiveLiteral":
      case "BlockStatement":
      case "BreakStatement":
      case "CallExpression":
      case "CatchClause":
      case "ConditionalExpression":
      case "ContinueStatement":
      case "DebuggerStatement":
      case "DoWhileStatement":
      case "EmptyStatement":
      case "ExpressionStatement":
      case "File":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "Identifier":
      case "IfStatement":
      case "LabeledStatement":
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "LogicalExpression":
      case "MemberExpression":
      case "NewExpression":
      case "Program":
      case "ObjectExpression":
      case "ObjectMethod":
      case "ObjectProperty":
      case "RestElement":
      case "ReturnStatement":
      case "SequenceExpression":
      case "ParenthesizedExpression":
      case "SwitchCase":
      case "SwitchStatement":
      case "ThisExpression":
      case "ThrowStatement":
      case "TryStatement":
      case "UnaryExpression":
      case "UpdateExpression":
      case "VariableDeclaration":
      case "VariableDeclarator":
      case "WhileStatement":
      case "WithStatement":
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ArrowFunctionExpression":
      case "ClassBody":
      case "ClassExpression":
      case "ClassDeclaration":
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ExportSpecifier":
      case "ForOfStatement":
      case "ImportDeclaration":
      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "ImportSpecifier":
      case "ImportExpression":
      case "MetaProperty":
      case "ClassMethod":
      case "ObjectPattern":
      case "SpreadElement":
      case "Super":
      case "TaggedTemplateExpression":
      case "TemplateElement":
      case "TemplateLiteral":
      case "YieldExpression":
      case "AwaitExpression":
      case "Import":
      case "BigIntLiteral":
      case "ExportNamespaceSpecifier":
      case "OptionalMemberExpression":
      case "OptionalCallExpression":
      case "ClassProperty":
      case "ClassAccessorProperty":
      case "ClassPrivateProperty":
      case "ClassPrivateMethod":
      case "PrivateName":
      case "StaticBlock":
      case "ImportAttribute":
        break;
      case "Placeholder":
        switch (t.expectedNode) {
          case "Identifier":
          case "StringLiteral":
          case "BlockStatement":
          case "ClassBody":
            break;
          default:
            return !1;
        }
        break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(Py, "isStandardized");
  function Ey(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ArrayExpression":
      case "AssignmentExpression":
      case "BinaryExpression":
      case "CallExpression":
      case "ConditionalExpression":
      case "FunctionExpression":
      case "Identifier":
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "LogicalExpression":
      case "MemberExpression":
      case "NewExpression":
      case "ObjectExpression":
      case "SequenceExpression":
      case "ParenthesizedExpression":
      case "ThisExpression":
      case "UnaryExpression":
      case "UpdateExpression":
      case "ArrowFunctionExpression":
      case "ClassExpression":
      case "ImportExpression":
      case "MetaProperty":
      case "Super":
      case "TaggedTemplateExpression":
      case "TemplateLiteral":
      case "YieldExpression":
      case "AwaitExpression":
      case "Import":
      case "BigIntLiteral":
      case "OptionalMemberExpression":
      case "OptionalCallExpression":
      case "TypeCastExpression":
      case "JSXElement":
      case "JSXFragment":
      case "BindExpression":
      case "DoExpression":
      case "RecordExpression":
      case "TupleExpression":
      case "DecimalLiteral":
      case "ModuleExpression":
      case "TopicReference":
      case "PipelineTopicExpression":
      case "PipelineBareFunction":
      case "PipelinePrimaryTopicReference":
      case "TSInstantiationExpression":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSNonNullExpression":
        break;
      case "Placeholder":
        switch (t.expectedNode) {
          case "Expression":
          case "Identifier":
          case "StringLiteral":
            break;
          default:
            return !1;
        }
        break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(Ey, "isExpression");
  function gy(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "BinaryExpression":
      case "LogicalExpression":
        break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(gy, "isBinary");
  function Ay(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "BlockStatement":
      case "CatchClause":
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "Program":
      case "ObjectMethod":
      case "SwitchStatement":
      case "WhileStatement":
      case "ArrowFunctionExpression":
      case "ClassExpression":
      case "ClassDeclaration":
      case "ForOfStatement":
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "StaticBlock":
      case "TSModuleBlock":
        break;
      case "Placeholder":
        if (t.expectedNode === "BlockStatement") break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(Ay, "isScopable");
  function Iy(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "BlockStatement":
      case "CatchClause":
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "Program":
      case "ObjectMethod":
      case "SwitchStatement":
      case "WhileStatement":
      case "ArrowFunctionExpression":
      case "ForOfStatement":
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "StaticBlock":
      case "TSModuleBlock":
        break;
      case "Placeholder":
        if (t.expectedNode === "BlockStatement") break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(Iy, "isBlockParent");
  function vy(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "BlockStatement":
      case "Program":
      case "TSModuleBlock":
        break;
      case "Placeholder":
        if (t.expectedNode === "BlockStatement") break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(vy, "isBlock");
  function Cy(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "BlockStatement":
      case "BreakStatement":
      case "ContinueStatement":
      case "DebuggerStatement":
      case "DoWhileStatement":
      case "EmptyStatement":
      case "ExpressionStatement":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "IfStatement":
      case "LabeledStatement":
      case "ReturnStatement":
      case "SwitchStatement":
      case "ThrowStatement":
      case "TryStatement":
      case "VariableDeclaration":
      case "WhileStatement":
      case "WithStatement":
      case "ClassDeclaration":
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ForOfStatement":
      case "ImportDeclaration":
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "InterfaceDeclaration":
      case "OpaqueType":
      case "TypeAlias":
      case "EnumDeclaration":
      case "TSDeclareFunction":
      case "TSInterfaceDeclaration":
      case "TSTypeAliasDeclaration":
      case "TSEnumDeclaration":
      case "TSModuleDeclaration":
      case "TSImportEqualsDeclaration":
      case "TSExportAssignment":
      case "TSNamespaceExportDeclaration":
        break;
      case "Placeholder":
        switch (t.expectedNode) {
          case "Statement":
          case "Declaration":
          case "BlockStatement":
            break;
          default:
            return !1;
        }
        break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(Cy, "isStatement");
  function wy(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "BreakStatement":
      case "ContinueStatement":
      case "ReturnStatement":
      case "ThrowStatement":
      case "YieldExpression":
      case "AwaitExpression":
        break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(wy, "isTerminatorless");
  function Ny(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "BreakStatement":
      case "ContinueStatement":
      case "ReturnStatement":
      case "ThrowStatement":
        break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(Ny, "isCompletionStatement");
  function Oy(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ConditionalExpression":
      case "IfStatement":
        break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(Oy, "isConditional");
  function _y(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForStatement":
      case "WhileStatement":
      case "ForOfStatement":
        break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(_y, "isLoop");
  function Dy(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "DoWhileStatement":
      case "WhileStatement":
        break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(Dy, "isWhile");
  function ky(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ExpressionStatement":
      case "ParenthesizedExpression":
      case "TypeCastExpression":
        break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(ky, "isExpressionWrapper");
  function Ly(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ForInStatement":
      case "ForStatement":
      case "ForOfStatement":
        break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(Ly, "isFor");
  function My(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ForInStatement":
      case "ForOfStatement":
        break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(My, "isForXStatement");
  function By(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "ObjectMethod":
      case "ArrowFunctionExpression":
      case "ClassMethod":
      case "ClassPrivateMethod":
        break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(By, "isFunction");
  function jy(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "ObjectMethod":
      case "ArrowFunctionExpression":
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "StaticBlock":
      case "TSModuleBlock":
        break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(jy, "isFunctionParent");
  function Fy(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "ArrowFunctionExpression":
      case "BigIntLiteral":
      case "DecimalLiteral":
        break;
      case "Placeholder":
        if (t.expectedNode === "StringLiteral") break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(Fy, "isPureish");
  function Ry(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "FunctionDeclaration":
      case "VariableDeclaration":
      case "ClassDeclaration":
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ImportDeclaration":
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "InterfaceDeclaration":
      case "OpaqueType":
      case "TypeAlias":
      case "EnumDeclaration":
      case "TSDeclareFunction":
      case "TSInterfaceDeclaration":
      case "TSTypeAliasDeclaration":
      case "TSEnumDeclaration":
      case "TSModuleDeclaration":
      case "TSImportEqualsDeclaration":
        break;
      case "Placeholder":
        if (t.expectedNode === "Declaration") break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(Ry, "isDeclaration");
  function qy(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "Identifier":
      case "RestElement":
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ObjectPattern":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSNonNullExpression":
        break;
      case "Placeholder":
        switch (t.expectedNode) {
          case "Pattern":
          case "Identifier":
            break;
          default:
            return !1;
        }
        break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(qy, "isPatternLike");
  function Uy(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "Identifier":
      case "MemberExpression":
      case "RestElement":
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ObjectPattern":
      case "TSParameterProperty":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSNonNullExpression":
        break;
      case "Placeholder":
        switch (t.expectedNode) {
          case "Pattern":
          case "Identifier":
            break;
          default:
            return !1;
        }
        break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(Uy, "isLVal");
  function Ky(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "Identifier":
      case "TSQualifiedName":
        break;
      case "Placeholder":
        if (t.expectedNode === "Identifier") break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(Ky, "isTSEntityName");
  function Vy(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "TemplateLiteral":
      case "BigIntLiteral":
      case "DecimalLiteral":
        break;
      case "Placeholder":
        if (t.expectedNode === "StringLiteral") break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(Vy, "isLiteral");
  function Yy(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "BigIntLiteral":
      case "JSXAttribute":
      case "JSXClosingElement":
      case "JSXElement":
      case "JSXExpressionContainer":
      case "JSXSpreadChild":
      case "JSXOpeningElement":
      case "JSXText":
      case "JSXFragment":
      case "JSXOpeningFragment":
      case "JSXClosingFragment":
      case "DecimalLiteral":
        break;
      case "Placeholder":
        if (t.expectedNode === "StringLiteral") break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(Yy, "isImmutable");
  function Jy(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ObjectMethod":
      case "ObjectProperty":
      case "ObjectTypeInternalSlot":
      case "ObjectTypeCallProperty":
      case "ObjectTypeIndexer":
      case "ObjectTypeProperty":
      case "ObjectTypeSpreadProperty":
        break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(Jy, "isUserWhitespacable");
  function Xy(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ObjectMethod":
      case "ClassMethod":
      case "ClassPrivateMethod":
        break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(Xy, "isMethod");
  function Wy(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ObjectMethod":
      case "ObjectProperty":
        break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(Wy, "isObjectMember");
  function zy(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ObjectProperty":
      case "ClassProperty":
      case "ClassAccessorProperty":
      case "ClassPrivateProperty":
        break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(zy, "isProperty");
  function $y(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "UnaryExpression":
      case "SpreadElement":
        break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s($y, "isUnaryLike");
  function Hy(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ObjectPattern":
        break;
      case "Placeholder":
        if (t.expectedNode === "Pattern") break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(Hy, "isPattern");
  function Gy(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ClassExpression":
      case "ClassDeclaration":
        break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(Gy, "isClass");
  function Ko(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ImportDeclaration":
        break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(Ko, "isImportOrExportDeclaration");
  function Qy(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
        break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(Qy, "isExportDeclaration");
  function Zy(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ExportSpecifier":
      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "ImportSpecifier":
      case "ExportNamespaceSpecifier":
      case "ExportDefaultSpecifier":
        break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(Zy, "isModuleSpecifier");
  function eT(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ClassAccessorProperty":
        break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(eT, "isAccessor");
  function tT(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ClassPrivateProperty":
      case "ClassPrivateMethod":
      case "PrivateName":
        break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(tT, "isPrivate");
  function rT(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "AnyTypeAnnotation":
      case "ArrayTypeAnnotation":
      case "BooleanTypeAnnotation":
      case "BooleanLiteralTypeAnnotation":
      case "NullLiteralTypeAnnotation":
      case "ClassImplements":
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "DeclaredPredicate":
      case "ExistsTypeAnnotation":
      case "FunctionTypeAnnotation":
      case "FunctionTypeParam":
      case "GenericTypeAnnotation":
      case "InferredPredicate":
      case "InterfaceExtends":
      case "InterfaceDeclaration":
      case "InterfaceTypeAnnotation":
      case "IntersectionTypeAnnotation":
      case "MixedTypeAnnotation":
      case "EmptyTypeAnnotation":
      case "NullableTypeAnnotation":
      case "NumberLiteralTypeAnnotation":
      case "NumberTypeAnnotation":
      case "ObjectTypeAnnotation":
      case "ObjectTypeInternalSlot":
      case "ObjectTypeCallProperty":
      case "ObjectTypeIndexer":
      case "ObjectTypeProperty":
      case "ObjectTypeSpreadProperty":
      case "OpaqueType":
      case "QualifiedTypeIdentifier":
      case "StringLiteralTypeAnnotation":
      case "StringTypeAnnotation":
      case "SymbolTypeAnnotation":
      case "ThisTypeAnnotation":
      case "TupleTypeAnnotation":
      case "TypeofTypeAnnotation":
      case "TypeAlias":
      case "TypeAnnotation":
      case "TypeCastExpression":
      case "TypeParameter":
      case "TypeParameterDeclaration":
      case "TypeParameterInstantiation":
      case "UnionTypeAnnotation":
      case "Variance":
      case "VoidTypeAnnotation":
      case "EnumDeclaration":
      case "EnumBooleanBody":
      case "EnumNumberBody":
      case "EnumStringBody":
      case "EnumSymbolBody":
      case "EnumBooleanMember":
      case "EnumNumberMember":
      case "EnumStringMember":
      case "EnumDefaultedMember":
      case "IndexedAccessType":
      case "OptionalIndexedAccessType":
        break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(rT, "isFlow");
  function iT(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "AnyTypeAnnotation":
      case "ArrayTypeAnnotation":
      case "BooleanTypeAnnotation":
      case "BooleanLiteralTypeAnnotation":
      case "NullLiteralTypeAnnotation":
      case "ExistsTypeAnnotation":
      case "FunctionTypeAnnotation":
      case "GenericTypeAnnotation":
      case "InterfaceTypeAnnotation":
      case "IntersectionTypeAnnotation":
      case "MixedTypeAnnotation":
      case "EmptyTypeAnnotation":
      case "NullableTypeAnnotation":
      case "NumberLiteralTypeAnnotation":
      case "NumberTypeAnnotation":
      case "ObjectTypeAnnotation":
      case "StringLiteralTypeAnnotation":
      case "StringTypeAnnotation":
      case "SymbolTypeAnnotation":
      case "ThisTypeAnnotation":
      case "TupleTypeAnnotation":
      case "TypeofTypeAnnotation":
      case "UnionTypeAnnotation":
      case "VoidTypeAnnotation":
      case "IndexedAccessType":
      case "OptionalIndexedAccessType":
        break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(iT, "isFlowType");
  function sT(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "AnyTypeAnnotation":
      case "BooleanTypeAnnotation":
      case "NullLiteralTypeAnnotation":
      case "MixedTypeAnnotation":
      case "EmptyTypeAnnotation":
      case "NumberTypeAnnotation":
      case "StringTypeAnnotation":
      case "SymbolTypeAnnotation":
      case "ThisTypeAnnotation":
      case "VoidTypeAnnotation":
        break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(sT, "isFlowBaseAnnotation");
  function nT(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "InterfaceDeclaration":
      case "OpaqueType":
      case "TypeAlias":
        break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(nT, "isFlowDeclaration");
  function aT(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "DeclaredPredicate":
      case "InferredPredicate":
        break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(aT, "isFlowPredicate");
  function oT(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "EnumBooleanBody":
      case "EnumNumberBody":
      case "EnumStringBody":
      case "EnumSymbolBody":
        break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(oT, "isEnumBody");
  function lT(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "EnumBooleanMember":
      case "EnumNumberMember":
      case "EnumStringMember":
      case "EnumDefaultedMember":
        break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(lT, "isEnumMember");
  function uT(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "JSXAttribute":
      case "JSXClosingElement":
      case "JSXElement":
      case "JSXEmptyExpression":
      case "JSXExpressionContainer":
      case "JSXSpreadChild":
      case "JSXIdentifier":
      case "JSXMemberExpression":
      case "JSXNamespacedName":
      case "JSXOpeningElement":
      case "JSXSpreadAttribute":
      case "JSXText":
      case "JSXFragment":
      case "JSXOpeningFragment":
      case "JSXClosingFragment":
        break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(uT, "isJSX");
  function cT(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "Noop":
      case "Placeholder":
      case "V8IntrinsicIdentifier":
        break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(cT, "isMiscellaneous");
  function pT(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "TSParameterProperty":
      case "TSDeclareFunction":
      case "TSDeclareMethod":
      case "TSQualifiedName":
      case "TSCallSignatureDeclaration":
      case "TSConstructSignatureDeclaration":
      case "TSPropertySignature":
      case "TSMethodSignature":
      case "TSIndexSignature":
      case "TSAnyKeyword":
      case "TSBooleanKeyword":
      case "TSBigIntKeyword":
      case "TSIntrinsicKeyword":
      case "TSNeverKeyword":
      case "TSNullKeyword":
      case "TSNumberKeyword":
      case "TSObjectKeyword":
      case "TSStringKeyword":
      case "TSSymbolKeyword":
      case "TSUndefinedKeyword":
      case "TSUnknownKeyword":
      case "TSVoidKeyword":
      case "TSThisType":
      case "TSFunctionType":
      case "TSConstructorType":
      case "TSTypeReference":
      case "TSTypePredicate":
      case "TSTypeQuery":
      case "TSTypeLiteral":
      case "TSArrayType":
      case "TSTupleType":
      case "TSOptionalType":
      case "TSRestType":
      case "TSNamedTupleMember":
      case "TSUnionType":
      case "TSIntersectionType":
      case "TSConditionalType":
      case "TSInferType":
      case "TSParenthesizedType":
      case "TSTypeOperator":
      case "TSIndexedAccessType":
      case "TSMappedType":
      case "TSTemplateLiteralType":
      case "TSLiteralType":
      case "TSExpressionWithTypeArguments":
      case "TSInterfaceDeclaration":
      case "TSInterfaceBody":
      case "TSTypeAliasDeclaration":
      case "TSInstantiationExpression":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSEnumBody":
      case "TSEnumDeclaration":
      case "TSEnumMember":
      case "TSModuleDeclaration":
      case "TSModuleBlock":
      case "TSImportType":
      case "TSImportEqualsDeclaration":
      case "TSExternalModuleReference":
      case "TSNonNullExpression":
      case "TSExportAssignment":
      case "TSNamespaceExportDeclaration":
      case "TSTypeAnnotation":
      case "TSTypeParameterInstantiation":
      case "TSTypeParameterDeclaration":
      case "TSTypeParameter":
        break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(pT, "isTypeScript");
  function fT(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "TSCallSignatureDeclaration":
      case "TSConstructSignatureDeclaration":
      case "TSPropertySignature":
      case "TSMethodSignature":
      case "TSIndexSignature":
        break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(fT, "isTSTypeElement");
  function hT(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "TSAnyKeyword":
      case "TSBooleanKeyword":
      case "TSBigIntKeyword":
      case "TSIntrinsicKeyword":
      case "TSNeverKeyword":
      case "TSNullKeyword":
      case "TSNumberKeyword":
      case "TSObjectKeyword":
      case "TSStringKeyword":
      case "TSSymbolKeyword":
      case "TSUndefinedKeyword":
      case "TSUnknownKeyword":
      case "TSVoidKeyword":
      case "TSThisType":
      case "TSFunctionType":
      case "TSConstructorType":
      case "TSTypeReference":
      case "TSTypePredicate":
      case "TSTypeQuery":
      case "TSTypeLiteral":
      case "TSArrayType":
      case "TSTupleType":
      case "TSOptionalType":
      case "TSRestType":
      case "TSUnionType":
      case "TSIntersectionType":
      case "TSConditionalType":
      case "TSInferType":
      case "TSParenthesizedType":
      case "TSTypeOperator":
      case "TSIndexedAccessType":
      case "TSMappedType":
      case "TSTemplateLiteralType":
      case "TSLiteralType":
      case "TSExpressionWithTypeArguments":
      case "TSImportType":
        break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(hT, "isTSType");
  function dT(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "TSAnyKeyword":
      case "TSBooleanKeyword":
      case "TSBigIntKeyword":
      case "TSIntrinsicKeyword":
      case "TSNeverKeyword":
      case "TSNullKeyword":
      case "TSNumberKeyword":
      case "TSObjectKeyword":
      case "TSStringKeyword":
      case "TSSymbolKeyword":
      case "TSUndefinedKeyword":
      case "TSUnknownKeyword":
      case "TSVoidKeyword":
      case "TSThisType":
      case "TSTemplateLiteralType":
      case "TSLiteralType":
        break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(dT, "isTSBaseType");
  function mT(t, e) {
    return (0, gr.default)("isNumberLiteral", "isNumericLiteral"), !t || t.type !== "NumberLiteral" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(mT, "isNumberLiteral");
  function yT(t, e) {
    return (0, gr.default)("isRegexLiteral", "isRegExpLiteral"), !t || t.type !== "RegexLiteral" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(yT, "isRegexLiteral");
  function TT(t, e) {
    return (0, gr.default)("isRestProperty", "isRestElement"), !t || t.type !== "RestProperty" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(TT, "isRestProperty");
  function ST(t, e) {
    return (0, gr.default)("isSpreadProperty", "isSpreadElement"), !t || t.type !== "SpreadProperty" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(ST, "isSpreadProperty");
  function bT(t, e) {
    return (0, gr.default)("isModuleDeclaration", "isImportOrExportDeclaration"), Ko(t, e);
  }
  s(bT, "isModuleDeclaration");
});

// ../node_modules/@babel/types/lib/validators/matchesPattern.js
var Ts = O((ys) => {
  "use strict";
  Object.defineProperty(ys, "__esModule", {
    value: !0
  });
  ys.default = xT;
  var Ar = Be();
  function xT(t, e, r) {
    if (!(0, Ar.isMemberExpression)(t)) return !1;
    let i = Array.isArray(e) ? e : e.split("."), n = [], a;
    for (a = t; (0, Ar.isMemberExpression)(a); a = a.object)
      n.push(a.property);
    if (n.push(a), n.length < i.length || !r && n.length > i.length) return !1;
    for (let o = 0, l = n.length - 1; o < i.length; o++, l--) {
      let u = n[l], p;
      if ((0, Ar.isIdentifier)(u))
        p = u.name;
      else if ((0, Ar.isStringLiteral)(u))
        p = u.value;
      else if ((0, Ar.isThisExpression)(u))
        p = "this";
      else
        return !1;
      if (i[o] !== p) return !1;
    }
    return !0;
  }
  s(xT, "matchesPattern");
});

// ../node_modules/@babel/types/lib/validators/buildMatchMemberExpression.js
var bs = O((Ss) => {
  "use strict";
  Object.defineProperty(Ss, "__esModule", {
    value: !0
  });
  Ss.default = ET;
  var PT = Ts();
  function ET(t, e) {
    let r = t.split(".");
    return (i) => (0, PT.default)(i, r, e);
  }
  s(ET, "buildMatchMemberExpression");
});

// ../node_modules/@babel/types/lib/validators/react/isReactComponent.js
var Vo = O((ui) => {
  "use strict";
  Object.defineProperty(ui, "__esModule", {
    value: !0
  });
  ui.default = void 0;
  var gT = bs(), AT = (0, gT.default)("React.Component"), HB = ui.default = AT;
});

// ../node_modules/@babel/types/lib/validators/react/isCompatTag.js
var Yo = O((xs) => {
  "use strict";
  Object.defineProperty(xs, "__esModule", {
    value: !0
  });
  xs.default = IT;
  function IT(t) {
    return !!t && /^[a-z]/.test(t);
  }
  s(IT, "isCompatTag");
});

// ../node_modules/@babel/types/lib/validators/isType.js
var ci = O((Ps) => {
  "use strict";
  Object.defineProperty(Ps, "__esModule", {
    value: !0
  });
  Ps.default = vT;
  var Jo = ot();
  function vT(t, e) {
    if (t === e) return !0;
    if (t == null || Jo.ALIAS_KEYS[e]) return !1;
    let r = Jo.FLIPPED_ALIAS_KEYS[e];
    return !!(r != null && r.includes(t));
  }
  s(vT, "isType");
});

// ../node_modules/@babel/types/lib/validators/isPlaceholderType.js
var gs = O((Es) => {
  "use strict";
  Object.defineProperty(Es, "__esModule", {
    value: !0
  });
  Es.default = wT;
  var CT = ot();
  function wT(t, e) {
    if (t === e) return !0;
    let r = CT.PLACEHOLDERS_ALIAS[t];
    return !!(r != null && r.includes(e));
  }
  s(wT, "isPlaceholderType");
});

// ../node_modules/@babel/types/lib/validators/is.js
var ir = O((As) => {
  "use strict";
  Object.defineProperty(As, "__esModule", {
    value: !0
  });
  As.default = kT;
  var NT = li(), OT = ci(), _T = gs(), DT = ot();
  function kT(t, e, r) {
    return e ? (0, OT.default)(e.type, t) ? r === void 0 ? !0 : (0, NT.default)(e, r) : !r && e.type === "Placeholder" && t in DT.FLIPPED_ALIAS_KEYS ?
    (0, _T.default)(e.expectedNode, t) : !1 : !1;
  }
  s(kT, "is");
});

// ../node_modules/@babel/helper-validator-identifier/lib/identifier.js
var Ho = O((Ir) => {
  "use strict";
  Object.defineProperty(Ir, "__esModule", {
    value: !0
  });
  Ir.isIdentifierChar = $o;
  Ir.isIdentifierName = jT;
  Ir.isIdentifierStart = zo;
  var vs = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993\
-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\
\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\
\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\
\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\
\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CD\uA7D0\uA7D1\uA7D3\uA7D5-\uA7DC\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01\
-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC",
  Xo = "\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\
\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\
\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6\
-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20\
-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65", LT = new RegExp("[" + vs + "]"), MT = new RegExp("[" + vs + Xo + "]");
  vs = Xo = null;
  var Wo = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157,
  19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5,
  3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7,
  2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 2, 60, 28, 11, 0, 9, 21, 43, 17,
  47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64,
  6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45,
  52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2,
  1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29,
  113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071,
  18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 129, 74, 6, 0, 67, 12,
  65, 1, 2, 0, 29, 6135, 9, 1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991,
  84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30,
  2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3,
  0, 496, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2,
  2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153,
  7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191], BT = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0,
  166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2,
  9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68,
  8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14,
  5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 343, 9, 54, 7, 2,
  7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0,
  7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4,
  4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10,
  9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 726, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
  function Is(t, e) {
    let r = 65536;
    for (let i = 0, n = e.length; i < n; i += 2) {
      if (r += e[i], r > t) return !1;
      if (r += e[i + 1], r >= t) return !0;
    }
    return !1;
  }
  s(Is, "isInAstralSet");
  function zo(t) {
    return t < 65 ? t === 36 : t <= 90 ? !0 : t < 97 ? t === 95 : t <= 122 ? !0 : t <= 65535 ? t >= 170 && LT.test(String.fromCharCode(t)) :
    Is(t, Wo);
  }
  s(zo, "isIdentifierStart");
  function $o(t) {
    return t < 48 ? t === 36 : t < 58 ? !0 : t < 65 ? !1 : t <= 90 ? !0 : t < 97 ? t === 95 : t <= 122 ? !0 : t <= 65535 ? t >= 170 && MT.test(
    String.fromCharCode(t)) : Is(t, Wo) || Is(t, BT);
  }
  s($o, "isIdentifierChar");
  function jT(t) {
    let e = !0;
    for (let r = 0; r < t.length; r++) {
      let i = t.charCodeAt(r);
      if ((i & 64512) === 55296 && r + 1 < t.length) {
        let n = t.charCodeAt(++r);
        (n & 64512) === 56320 && (i = 65536 + ((i & 1023) << 10) + (n & 1023));
      }
      if (e) {
        if (e = !1, !zo(i))
          return !1;
      } else if (!$o(i))
        return !1;
    }
    return !e;
  }
  s(jT, "isIdentifierName");
});

// ../node_modules/@babel/helper-validator-identifier/lib/keyword.js
var el = O((Xt) => {
  "use strict";
  Object.defineProperty(Xt, "__esModule", {
    value: !0
  });
  Xt.isKeyword = KT;
  Xt.isReservedWord = Go;
  Xt.isStrictBindOnlyReservedWord = Zo;
  Xt.isStrictBindReservedWord = UT;
  Xt.isStrictReservedWord = Qo;
  var Cs = {
    keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "swit\
ch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false",
    "in", "instanceof", "typeof", "void", "delete"],
    strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
    strictBind: ["eval", "arguments"]
  }, FT = new Set(Cs.keyword), RT = new Set(Cs.strict), qT = new Set(Cs.strictBind);
  function Go(t, e) {
    return e && t === "await" || t === "enum";
  }
  s(Go, "isReservedWord");
  function Qo(t, e) {
    return Go(t, e) || RT.has(t);
  }
  s(Qo, "isStrictReservedWord");
  function Zo(t) {
    return qT.has(t);
  }
  s(Zo, "isStrictBindOnlyReservedWord");
  function UT(t, e) {
    return Qo(t, e) || Zo(t);
  }
  s(UT, "isStrictBindReservedWord");
  function KT(t) {
    return FT.has(t);
  }
  s(KT, "isKeyword");
});

// ../node_modules/@babel/helper-validator-identifier/lib/index.js
var pi = O((St) => {
  "use strict";
  Object.defineProperty(St, "__esModule", {
    value: !0
  });
  Object.defineProperty(St, "isIdentifierChar", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return ws.isIdentifierChar;
    }, "get")
  });
  Object.defineProperty(St, "isIdentifierName", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return ws.isIdentifierName;
    }, "get")
  });
  Object.defineProperty(St, "isIdentifierStart", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return ws.isIdentifierStart;
    }, "get")
  });
  Object.defineProperty(St, "isKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return vr.isKeyword;
    }, "get")
  });
  Object.defineProperty(St, "isReservedWord", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return vr.isReservedWord;
    }, "get")
  });
  Object.defineProperty(St, "isStrictBindOnlyReservedWord", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return vr.isStrictBindOnlyReservedWord;
    }, "get")
  });
  Object.defineProperty(St, "isStrictBindReservedWord", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return vr.isStrictBindReservedWord;
    }, "get")
  });
  Object.defineProperty(St, "isStrictReservedWord", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return vr.isStrictReservedWord;
    }, "get")
  });
  var ws = Ho(), vr = el();
});

// ../node_modules/@babel/types/lib/validators/isValidIdentifier.js
var sr = O((Os) => {
  "use strict";
  Object.defineProperty(Os, "__esModule", {
    value: !0
  });
  Os.default = VT;
  var Ns = pi();
  function VT(t, e = !0) {
    return typeof t != "string" || e && ((0, Ns.isKeyword)(t) || (0, Ns.isStrictReservedWord)(t, !0)) ? !1 : (0, Ns.isIdentifierName)(t);
  }
  s(VT, "isValidIdentifier");
});

// ../node_modules/@babel/helper-string-parser/lib/index.js
var sl = O((Cr) => {
  "use strict";
  Object.defineProperty(Cr, "__esModule", {
    value: !0
  });
  Cr.readCodePoint = il;
  Cr.readInt = rl;
  Cr.readStringContents = JT;
  var YT = /* @__PURE__ */ s(function(e) {
    return e >= 48 && e <= 57;
  }, "isDigit"), tl = {
    decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]),
    hex: /* @__PURE__ */ new Set([46, 88, 95, 120])
  }, fi = {
    bin: /* @__PURE__ */ s((t) => t === 48 || t === 49, "bin"),
    oct: /* @__PURE__ */ s((t) => t >= 48 && t <= 55, "oct"),
    dec: /* @__PURE__ */ s((t) => t >= 48 && t <= 57, "dec"),
    hex: /* @__PURE__ */ s((t) => t >= 48 && t <= 57 || t >= 65 && t <= 70 || t >= 97 && t <= 102, "hex")
  };
  function JT(t, e, r, i, n, a) {
    let o = r, l = i, u = n, p = "", m = null, g = r, {
      length: I
    } = e;
    for (; ; ) {
      if (r >= I) {
        a.unterminated(o, l, u), p += e.slice(g, r);
        break;
      }
      let v = e.charCodeAt(r);
      if (XT(t, v, e, r)) {
        p += e.slice(g, r);
        break;
      }
      if (v === 92) {
        p += e.slice(g, r);
        let _ = WT(e, r, i, n, t === "template", a);
        _.ch === null && !m ? m = {
          pos: r,
          lineStart: i,
          curLine: n
        } : p += _.ch, {
          pos: r,
          lineStart: i,
          curLine: n
        } = _, g = r;
      } else v === 8232 || v === 8233 ? (++r, ++n, i = r) : v === 10 || v === 13 ? t === "template" ? (p += e.slice(g, r) + `
`, ++r, v === 13 && e.charCodeAt(r) === 10 && ++r, ++n, g = i = r) : a.unterminated(o, l, u) : ++r;
    }
    return {
      pos: r,
      str: p,
      firstInvalidLoc: m,
      lineStart: i,
      curLine: n,
      containsInvalid: !!m
    };
  }
  s(JT, "readStringContents");
  function XT(t, e, r, i) {
    return t === "template" ? e === 96 || e === 36 && r.charCodeAt(i + 1) === 123 : e === (t === "double" ? 34 : 39);
  }
  s(XT, "isStringEnd");
  function WT(t, e, r, i, n, a) {
    let o = !n;
    e++;
    let l = /* @__PURE__ */ s((p) => ({
      pos: e,
      ch: p,
      lineStart: r,
      curLine: i
    }), "res"), u = t.charCodeAt(e++);
    switch (u) {
      case 110:
        return l(`
`);
      case 114:
        return l("\r");
      case 120: {
        let p;
        return {
          code: p,
          pos: e
        } = _s(t, e, r, i, 2, !1, o, a), l(p === null ? null : String.fromCharCode(p));
      }
      case 117: {
        let p;
        return {
          code: p,
          pos: e
        } = il(t, e, r, i, o, a), l(p === null ? null : String.fromCodePoint(p));
      }
      case 116:
        return l("	");
      case 98:
        return l("\b");
      case 118:
        return l("\v");
      case 102:
        return l("\f");
      case 13:
        t.charCodeAt(e) === 10 && ++e;
      case 10:
        r = e, ++i;
      case 8232:
      case 8233:
        return l("");
      case 56:
      case 57:
        if (n)
          return l(null);
        a.strictNumericEscape(e - 1, r, i);
      default:
        if (u >= 48 && u <= 55) {
          let p = e - 1, g = /^[0-7]+/.exec(t.slice(p, e + 2))[0], I = parseInt(g, 8);
          I > 255 && (g = g.slice(0, -1), I = parseInt(g, 8)), e += g.length - 1;
          let v = t.charCodeAt(e);
          if (g !== "0" || v === 56 || v === 57) {
            if (n)
              return l(null);
            a.strictNumericEscape(p, r, i);
          }
          return l(String.fromCharCode(I));
        }
        return l(String.fromCharCode(u));
    }
  }
  s(WT, "readEscapedChar");
  function _s(t, e, r, i, n, a, o, l) {
    let u = e, p;
    return {
      n: p,
      pos: e
    } = rl(t, e, r, i, 16, n, a, !1, l, !o), p === null && (o ? l.invalidEscapeSequence(u, r, i) : e = u - 1), {
      code: p,
      pos: e
    };
  }
  s(_s, "readHexChar");
  function rl(t, e, r, i, n, a, o, l, u, p) {
    let m = e, g = n === 16 ? tl.hex : tl.decBinOct, I = n === 16 ? fi.hex : n === 10 ? fi.dec : n === 8 ? fi.oct : fi.bin, v = !1, _ = 0;
    for (let V = 0, D = a ?? 1 / 0; V < D; ++V) {
      let L = t.charCodeAt(e), B;
      if (L === 95 && l !== "bail") {
        let fe = t.charCodeAt(e - 1), ee = t.charCodeAt(e + 1);
        if (l) {
          if (Number.isNaN(ee) || !I(ee) || g.has(fe) || g.has(ee)) {
            if (p) return {
              n: null,
              pos: e
            };
            u.unexpectedNumericSeparator(e, r, i);
          }
        } else {
          if (p) return {
            n: null,
            pos: e
          };
          u.numericSeparatorInEscapeSequence(e, r, i);
        }
        ++e;
        continue;
      }
      if (L >= 97 ? B = L - 97 + 10 : L >= 65 ? B = L - 65 + 10 : YT(L) ? B = L - 48 : B = 1 / 0, B >= n) {
        if (B <= 9 && p)
          return {
            n: null,
            pos: e
          };
        if (B <= 9 && u.invalidDigit(e, r, i, n))
          B = 0;
        else if (o)
          B = 0, v = !0;
        else
          break;
      }
      ++e, _ = _ * n + B;
    }
    return e === m || a != null && e - m !== a || v ? {
      n: null,
      pos: e
    } : {
      n: _,
      pos: e
    };
  }
  s(rl, "readInt");
  function il(t, e, r, i, n, a) {
    let o = t.charCodeAt(e), l;
    if (o === 123) {
      if (++e, {
        code: l,
        pos: e
      } = _s(t, e, r, i, t.indexOf("}", e) - e, !0, n, a), ++e, l !== null && l > 1114111)
        if (n)
          a.invalidCodePoint(e, r, i);
        else
          return {
            code: null,
            pos: e
          };
    } else
      ({
        code: l,
        pos: e
      } = _s(t, e, r, i, 4, !1, n, a));
    return {
      code: l,
      pos: e
    };
  }
  s(il, "readCodePoint");
});

// ../node_modules/@babel/types/lib/constants/index.js
var nr = O((he) => {
  "use strict";
  Object.defineProperty(he, "__esModule", {
    value: !0
  });
  he.UPDATE_OPERATORS = he.UNARY_OPERATORS = he.STRING_UNARY_OPERATORS = he.STATEMENT_OR_BLOCK_KEYS = he.NUMBER_UNARY_OPERATORS = he.NUMBER_BINARY_OPERATORS =
  he.LOGICAL_OPERATORS = he.INHERIT_KEYS = he.FOR_INIT_KEYS = he.FLATTENABLE_KEYS = he.EQUALITY_BINARY_OPERATORS = he.COMPARISON_BINARY_OPERATORS =
  he.COMMENT_KEYS = he.BOOLEAN_UNARY_OPERATORS = he.BOOLEAN_NUMBER_BINARY_OPERATORS = he.BOOLEAN_BINARY_OPERATORS = he.BINARY_OPERATORS = he.
  ASSIGNMENT_OPERATORS = void 0;
  var yj = he.STATEMENT_OR_BLOCK_KEYS = ["consequent", "body", "alternate"], Tj = he.FLATTENABLE_KEYS = ["body", "expressions"], Sj = he.FOR_INIT_KEYS =
  ["left", "init"], bj = he.COMMENT_KEYS = ["leadingComments", "trailingComments", "innerComments"], zT = he.LOGICAL_OPERATORS = ["||", "&&",
  "??"], xj = he.UPDATE_OPERATORS = ["++", "--"], $T = he.BOOLEAN_NUMBER_BINARY_OPERATORS = [">", "<", ">=", "<="], HT = he.EQUALITY_BINARY_OPERATORS =
  ["==", "===", "!=", "!=="], GT = he.COMPARISON_BINARY_OPERATORS = [...HT, "in", "instanceof"], QT = he.BOOLEAN_BINARY_OPERATORS = [...GT, ...$T],
  nl = he.NUMBER_BINARY_OPERATORS = ["-", "/", "%", "*", "**", "&", "|", ">>", ">>>", "<<", "^"], Pj = he.BINARY_OPERATORS = ["+", ...nl, ...QT,
  "|>"], Ej = he.ASSIGNMENT_OPERATORS = ["=", "+=", ...nl.map((t) => t + "="), ...zT.map((t) => t + "=")], ZT = he.BOOLEAN_UNARY_OPERATORS =
  ["delete", "!"], eS = he.NUMBER_UNARY_OPERATORS = ["+", "-", "~"], tS = he.STRING_UNARY_OPERATORS = ["typeof"], gj = he.UNARY_OPERATORS = [
  "void", "throw", ...ZT, ...eS, ...tS], Aj = he.INHERIT_KEYS = {
    optional: ["typeAnnotation", "typeParameters", "returnType"],
    force: ["start", "loc", "end"]
  };
  he.BLOCK_SCOPED_SYMBOL = Symbol.for("var used to be block scoped"), he.NOT_LOCAL_BINDING = Symbol.for("should not be considered a local bi\
nding");
});

// ../node_modules/@babel/types/lib/definitions/utils.js
var bt = O((Pe) => {
  "use strict";
  Object.defineProperty(Pe, "__esModule", {
    value: !0
  });
  Pe.allExpandedTypes = Pe.VISITOR_KEYS = Pe.NODE_PARENT_VALIDATIONS = Pe.NODE_FIELDS = Pe.FLIPPED_ALIAS_KEYS = Pe.DEPRECATED_KEYS = Pe.BUILDER_KEYS =
  Pe.ALIAS_KEYS = void 0;
  Pe.arrayOf = ol;
  Pe.arrayOfType = ll;
  Pe.assertEach = ul;
  Pe.assertNodeOrValueType = dS;
  Pe.assertNodeType = di;
  Pe.assertOneOf = fS;
  Pe.assertOptionalChainStart = yS;
  Pe.assertShape = mS;
  Pe.assertValueType = Ms;
  Pe.chain = cl;
  Pe.default = pl;
  Pe.defineAliasedType = bS;
  Pe.validate = Ls;
  Pe.validateArrayOfType = pS;
  Pe.validateOptional = uS;
  Pe.validateOptionalType = cS;
  Pe.validateType = lS;
  var al = ir(), wr = mi(), rS = Pe.VISITOR_KEYS = {}, iS = Pe.ALIAS_KEYS = {}, Ds = Pe.FLIPPED_ALIAS_KEYS = {}, sS = Pe.NODE_FIELDS = {}, nS = Pe.
  BUILDER_KEYS = {}, aS = Pe.DEPRECATED_KEYS = {}, oS = Pe.NODE_PARENT_VALIDATIONS = {};
  function hi(t) {
    return Array.isArray(t) ? "array" : t === null ? "null" : typeof t;
  }
  s(hi, "getType");
  function Ls(t) {
    return {
      validate: t
    };
  }
  s(Ls, "validate");
  function lS(...t) {
    return Ls(di(...t));
  }
  s(lS, "validateType");
  function uS(t) {
    return {
      validate: t,
      optional: !0
    };
  }
  s(uS, "validateOptional");
  function cS(...t) {
    return {
      validate: di(...t),
      optional: !0
    };
  }
  s(cS, "validateOptionalType");
  function ol(t) {
    return cl(Ms("array"), ul(t));
  }
  s(ol, "arrayOf");
  function ll(...t) {
    return ol(di(...t));
  }
  s(ll, "arrayOfType");
  function pS(...t) {
    return Ls(ll(...t));
  }
  s(pS, "validateArrayOfType");
  function ul(t) {
    let e = process.env.BABEL_TYPES_8_BREAKING ? wr.validateChild : () => {
    };
    function r(i, n, a) {
      if (!Array.isArray(a)) return;
      let o = 0, l = {
        toString() {
          return `${n}[${o}]`;
        }
      };
      for (; o < a.length; o++) {
        let u = a[o];
        t(i, l, u), e(i, l, u);
      }
    }
    return s(r, "validator"), r.each = t, r;
  }
  s(ul, "assertEach");
  function fS(...t) {
    function e(r, i, n) {
      if (!t.includes(n))
        throw new TypeError(`Property ${i} expected value to be one of ${JSON.stringify(t)} but got ${JSON.stringify(n)}`);
    }
    return s(e, "validate"), e.oneOf = t, e;
  }
  s(fS, "assertOneOf");
  var hS = Pe.allExpandedTypes = [];
  function di(...t) {
    let e = /* @__PURE__ */ new Set();
    hS.push({
      types: t,
      set: e
    });
    function r(i, n, a) {
      let o = a?.type;
      if (o != null) {
        if (e.has(o)) {
          (0, wr.validateChild)(i, n, a);
          return;
        }
        if (o === "Placeholder") {
          for (let l of t)
            if ((0, al.default)(l, a)) {
              (0, wr.validateChild)(i, n, a);
              return;
            }
        }
      }
      throw new TypeError(`Property ${n} of ${i.type} expected node to be of a type ${JSON.stringify(t)} but instead got ${JSON.stringify(o)}`);
    }
    return s(r, "validate"), r.oneOfNodeTypes = t, r;
  }
  s(di, "assertNodeType");
  function dS(...t) {
    function e(r, i, n) {
      let a = hi(n);
      for (let o of t)
        if (a === o || (0, al.default)(o, n)) {
          (0, wr.validateChild)(r, i, n);
          return;
        }
      throw new TypeError(`Property ${i} of ${r.type} expected node to be of a type ${JSON.stringify(t)} but instead got ${JSON.stringify(n?.
      type)}`);
    }
    return s(e, "validate"), e.oneOfNodeOrValueTypes = t, e;
  }
  s(dS, "assertNodeOrValueType");
  function Ms(t) {
    function e(r, i, n) {
      if (hi(n) !== t)
        throw new TypeError(`Property ${i} expected type of ${t} but got ${hi(n)}`);
    }
    return s(e, "validate"), e.type = t, e;
  }
  s(Ms, "assertValueType");
  function mS(t) {
    let e = Object.keys(t);
    function r(i, n, a) {
      let o = [];
      for (let l of e)
        try {
          (0, wr.validateField)(i, l, a[l], t[l]);
        } catch (u) {
          if (u instanceof TypeError) {
            o.push(u.message);
            continue;
          }
          throw u;
        }
      if (o.length)
        throw new TypeError(`Property ${n} of ${i.type} expected to have the following:
${o.join(`
`)}`);
    }
    return s(r, "validate"), r.shapeOf = t, r;
  }
  s(mS, "assertShape");
  function yS() {
    function t(e) {
      var r;
      let i = e;
      for (; e; ) {
        let {
          type: n
        } = i;
        if (n === "OptionalCallExpression") {
          if (i.optional) return;
          i = i.callee;
          continue;
        }
        if (n === "OptionalMemberExpression") {
          if (i.optional) return;
          i = i.object;
          continue;
        }
        break;
      }
      throw new TypeError(`Non-optional ${e.type} must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chai\
n from ${(r = i) == null ? void 0 : r.type}`);
    }
    return s(t, "validate"), t;
  }
  s(yS, "assertOptionalChainStart");
  function cl(...t) {
    function e(...r) {
      for (let i of t)
        i(...r);
    }
    if (s(e, "validate"), e.chainOf = t, t.length >= 2 && "type" in t[0] && t[0].type === "array" && !("each" in t[1]))
      throw new Error('An assertValueType("array") validator can only be followed by an assertEach(...) validator.');
    return e;
  }
  s(cl, "chain");
  var TS = /* @__PURE__ */ new Set(["aliases", "builder", "deprecatedAlias", "fields", "inherits", "visitor", "validate"]), SS = /* @__PURE__ */ new Set(
  ["default", "optional", "deprecated", "validate"]), ks = {};
  function bS(...t) {
    return (e, r = {}) => {
      let i = r.aliases;
      if (!i) {
        var n;
        r.inherits && (i = (n = ks[r.inherits].aliases) == null ? void 0 : n.slice()), i ?? (i = []), r.aliases = i;
      }
      let a = t.filter((o) => !i.includes(o));
      i.unshift(...a), pl(e, r);
    };
  }
  s(bS, "defineAliasedType");
  function pl(t, e = {}) {
    let r = e.inherits && ks[e.inherits] || {}, i = e.fields;
    if (!i && (i = {}, r.fields)) {
      let l = Object.getOwnPropertyNames(r.fields);
      for (let u of l) {
        let p = r.fields[u], m = p.default;
        if (Array.isArray(m) ? m.length > 0 : m && typeof m == "object")
          throw new Error("field defaults can only be primitives or empty arrays currently");
        i[u] = {
          default: Array.isArray(m) ? [] : m,
          optional: p.optional,
          deprecated: p.deprecated,
          validate: p.validate
        };
      }
    }
    let n = e.visitor || r.visitor || [], a = e.aliases || r.aliases || [], o = e.builder || r.builder || e.visitor || [];
    for (let l of Object.keys(e))
      if (!TS.has(l))
        throw new Error(`Unknown type option "${l}" on ${t}`);
    e.deprecatedAlias && (aS[e.deprecatedAlias] = t);
    for (let l of n.concat(o))
      i[l] = i[l] || {};
    for (let l of Object.keys(i)) {
      let u = i[l];
      u.default !== void 0 && !o.includes(l) && (u.optional = !0), u.default === void 0 ? u.default = null : !u.validate && u.default != null &&
      (u.validate = Ms(hi(u.default)));
      for (let p of Object.keys(u))
        if (!SS.has(p))
          throw new Error(`Unknown field key "${p}" on ${t}.${l}`);
    }
    rS[t] = e.visitor = n, nS[t] = e.builder = o, sS[t] = e.fields = i, iS[t] = e.aliases = a, a.forEach((l) => {
      Ds[l] = Ds[l] || [], Ds[l].push(t);
    }), e.validate && (oS[t] = e.validate), ks[t] = e;
  }
  s(pl, "defineType");
});

// ../node_modules/@babel/types/lib/definitions/core.js
var Or = O((Ve) => {
  "use strict";
  Object.defineProperty(Ve, "__esModule", {
    value: !0
  });
  Ve.patternLikeCommon = Ve.importAttributes = Ve.functionTypeAnnotationCommon = Ve.functionDeclarationCommon = Ve.functionCommon = Ve.classMethodOrPropertyCommon =
  Ve.classMethodOrDeclareMethodCommon = void 0;
  var ze = ir(), xS = sr(), fl = pi(), PS = sl(), Nr = nr(), S = bt(), F = (0, S.defineAliasedType)("Standardized");
  F("ArrayExpression", {
    fields: {
      elements: {
        validate: (0, S.arrayOf)((0, S.assertNodeOrValueType)("null", "Expression", "SpreadElement")),
        default: process.env.BABEL_TYPES_8_BREAKING ? void 0 : []
      }
    },
    visitor: ["elements"],
    aliases: ["Expression"]
  });
  F("AssignmentExpression", {
    fields: {
      operator: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? Object.assign(function() {
          let t = (0, S.assertOneOf)(...Nr.ASSIGNMENT_OPERATORS), e = (0, S.assertOneOf)("=");
          return function(r, i, n) {
            ((0, ze.default)("Pattern", r.left) ? e : t)(r, i, n);
          };
        }(), {
          type: "string"
        }) : (0, S.assertValueType)("string")
      },
      left: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, S.assertNodeType)("Identifier", "MemberExpression", "OptionalMemberExpression", "\
ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") : (0, S.assertNodeType)(
        "LVal", "OptionalMemberExpression")
      },
      right: {
        validate: (0, S.assertNodeType)("Expression")
      }
    },
    builder: ["operator", "left", "right"],
    visitor: ["left", "right"],
    aliases: ["Expression"]
  });
  F("BinaryExpression", {
    builder: ["operator", "left", "right"],
    fields: {
      operator: {
        validate: (0, S.assertOneOf)(...Nr.BINARY_OPERATORS)
      },
      left: {
        validate: function() {
          let t = (0, S.assertNodeType)("Expression"), e = (0, S.assertNodeType)("Expression", "PrivateName");
          return Object.assign(function(i, n, a) {
            (i.operator === "in" ? e : t)(i, n, a);
          }, {
            oneOfNodeTypes: ["Expression", "PrivateName"]
          });
        }()
      },
      right: {
        validate: (0, S.assertNodeType)("Expression")
      }
    },
    visitor: ["left", "right"],
    aliases: ["Binary", "Expression"]
  });
  F("InterpreterDirective", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, S.assertValueType)("string")
      }
    }
  });
  F("Directive", {
    visitor: ["value"],
    fields: {
      value: {
        validate: (0, S.assertNodeType)("DirectiveLiteral")
      }
    }
  });
  F("DirectiveLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, S.assertValueType)("string")
      }
    }
  });
  F("BlockStatement", {
    builder: ["body", "directives"],
    visitor: ["directives", "body"],
    fields: {
      directives: {
        validate: (0, S.arrayOfType)("Directive"),
        default: []
      },
      body: (0, S.validateArrayOfType)("Statement")
    },
    aliases: ["Scopable", "BlockParent", "Block", "Statement"]
  });
  F("BreakStatement", {
    visitor: ["label"],
    fields: {
      label: {
        validate: (0, S.assertNodeType)("Identifier"),
        optional: !0
      }
    },
    aliases: ["Statement", "Terminatorless", "CompletionStatement"]
  });
  F("CallExpression", {
    visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
    builder: ["callee", "arguments"],
    aliases: ["Expression"],
    fields: Object.assign({
      callee: {
        validate: (0, S.assertNodeType)("Expression", "Super", "V8IntrinsicIdentifier")
      },
      arguments: (0, S.validateArrayOfType)("Expression", "SpreadElement", "ArgumentPlaceholder"),
      typeArguments: {
        validate: (0, S.assertNodeType)("TypeParameterInstantiation"),
        optional: !0
      }
    }, {
      optional: {
        validate: (0, S.assertValueType)("boolean"),
        optional: !0
      },
      typeParameters: {
        validate: (0, S.assertNodeType)("TSTypeParameterInstantiation"),
        optional: !0
      }
    }, process.env.BABEL_TYPES_8_BREAKING ? {} : {
      optional: {
        validate: (0, S.assertValueType)("boolean"),
        optional: !0
      }
    })
  });
  F("CatchClause", {
    visitor: ["param", "body"],
    fields: {
      param: {
        validate: (0, S.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"),
        optional: !0
      },
      body: {
        validate: (0, S.assertNodeType)("BlockStatement")
      }
    },
    aliases: ["Scopable", "BlockParent"]
  });
  F("ConditionalExpression", {
    visitor: ["test", "consequent", "alternate"],
    fields: {
      test: {
        validate: (0, S.assertNodeType)("Expression")
      },
      consequent: {
        validate: (0, S.assertNodeType)("Expression")
      },
      alternate: {
        validate: (0, S.assertNodeType)("Expression")
      }
    },
    aliases: ["Expression", "Conditional"]
  });
  F("ContinueStatement", {
    visitor: ["label"],
    fields: {
      label: {
        validate: (0, S.assertNodeType)("Identifier"),
        optional: !0
      }
    },
    aliases: ["Statement", "Terminatorless", "CompletionStatement"]
  });
  F("DebuggerStatement", {
    aliases: ["Statement"]
  });
  F("DoWhileStatement", {
    builder: ["test", "body"],
    visitor: ["body", "test"],
    fields: {
      test: {
        validate: (0, S.assertNodeType)("Expression")
      },
      body: {
        validate: (0, S.assertNodeType)("Statement")
      }
    },
    aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"]
  });
  F("EmptyStatement", {
    aliases: ["Statement"]
  });
  F("ExpressionStatement", {
    visitor: ["expression"],
    fields: {
      expression: {
        validate: (0, S.assertNodeType)("Expression")
      }
    },
    aliases: ["Statement", "ExpressionWrapper"]
  });
  F("File", {
    builder: ["program", "comments", "tokens"],
    visitor: ["program"],
    fields: {
      program: {
        validate: (0, S.assertNodeType)("Program")
      },
      comments: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, S.assertEach)((0, S.assertNodeType)("CommentBlock", "CommentLine")) : Object.assign(
        () => {
        }, {
          each: {
            oneOfNodeTypes: ["CommentBlock", "CommentLine"]
          }
        }),
        optional: !0
      },
      tokens: {
        validate: (0, S.assertEach)(Object.assign(() => {
        }, {
          type: "any"
        })),
        optional: !0
      }
    }
  });
  F("ForInStatement", {
    visitor: ["left", "right", "body"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
    fields: {
      left: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, S.assertNodeType)("VariableDeclaration", "Identifier", "MemberExpression", "Array\
Pattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") : (0, S.assertNodeType)("Var\
iableDeclaration", "LVal")
      },
      right: {
        validate: (0, S.assertNodeType)("Expression")
      },
      body: {
        validate: (0, S.assertNodeType)("Statement")
      }
    }
  });
  F("ForStatement", {
    visitor: ["init", "test", "update", "body"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop"],
    fields: {
      init: {
        validate: (0, S.assertNodeType)("VariableDeclaration", "Expression"),
        optional: !0
      },
      test: {
        validate: (0, S.assertNodeType)("Expression"),
        optional: !0
      },
      update: {
        validate: (0, S.assertNodeType)("Expression"),
        optional: !0
      },
      body: {
        validate: (0, S.assertNodeType)("Statement")
      }
    }
  });
  var ar = /* @__PURE__ */ s(() => ({
    params: (0, S.validateArrayOfType)("Identifier", "Pattern", "RestElement"),
    generator: {
      default: !1
    },
    async: {
      default: !1
    }
  }), "functionCommon");
  Ve.functionCommon = ar;
  var Wt = /* @__PURE__ */ s(() => ({
    returnType: {
      validate: (0, S.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
      optional: !0
    },
    typeParameters: {
      validate: (0, S.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
      optional: !0
    }
  }), "functionTypeAnnotationCommon");
  Ve.functionTypeAnnotationCommon = Wt;
  var hl = /* @__PURE__ */ s(() => Object.assign({}, ar(), {
    declare: {
      validate: (0, S.assertValueType)("boolean"),
      optional: !0
    },
    id: {
      validate: (0, S.assertNodeType)("Identifier"),
      optional: !0
    }
  }), "functionDeclarationCommon");
  Ve.functionDeclarationCommon = hl;
  F("FunctionDeclaration", {
    builder: ["id", "params", "body", "generator", "async"],
    visitor: ["id", "typeParameters", "params", "predicate", "returnType", "body"],
    fields: Object.assign({}, hl(), Wt(), {
      body: {
        validate: (0, S.assertNodeType)("BlockStatement")
      },
      predicate: {
        validate: (0, S.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
        optional: !0
      }
    }),
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Statement", "Pureish", "Declaration"],
    validate: process.env.BABEL_TYPES_8_BREAKING ? function() {
      let t = (0, S.assertNodeType)("Identifier");
      return function(e, r, i) {
        (0, ze.default)("ExportDefaultDeclaration", e) || t(i, "id", i.id);
      };
    }() : void 0
  });
  F("FunctionExpression", {
    inherits: "FunctionDeclaration",
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
    fields: Object.assign({}, ar(), Wt(), {
      id: {
        validate: (0, S.assertNodeType)("Identifier"),
        optional: !0
      },
      body: {
        validate: (0, S.assertNodeType)("BlockStatement")
      },
      predicate: {
        validate: (0, S.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
        optional: !0
      }
    })
  });
  var or = /* @__PURE__ */ s(() => ({
    typeAnnotation: {
      validate: (0, S.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
      optional: !0
    },
    optional: {
      validate: (0, S.assertValueType)("boolean"),
      optional: !0
    },
    decorators: {
      validate: (0, S.arrayOfType)("Decorator"),
      optional: !0
    }
  }), "patternLikeCommon");
  Ve.patternLikeCommon = or;
  F("Identifier", {
    builder: ["name"],
    visitor: ["typeAnnotation", "decorators"],
    aliases: ["Expression", "PatternLike", "LVal", "TSEntityName"],
    fields: Object.assign({}, or(), {
      name: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, S.chain)((0, S.assertValueType)("string"), Object.assign(function(t, e, r) {
          if (!(0, xS.default)(r, !1))
            throw new TypeError(`"${r}" is not a valid identifier name`);
        }, {
          type: "string"
        })) : (0, S.assertValueType)("string")
      }
    }),
    validate: process.env.BABEL_TYPES_8_BREAKING ? function(t, e, r) {
      let i = /\.(\w+)$/.exec(e.toString());
      if (!i) return;
      let [, n] = i, a = {
        computed: !1
      };
      if (n === "property") {
        if ((0, ze.default)("MemberExpression", t, a) || (0, ze.default)("OptionalMemberExpression", t, a)) return;
      } else if (n === "key") {
        if ((0, ze.default)("Property", t, a) || (0, ze.default)("Method", t, a)) return;
      } else if (n === "exported") {
        if ((0, ze.default)("ExportSpecifier", t)) return;
      } else if (n === "imported") {
        if ((0, ze.default)("ImportSpecifier", t, {
          imported: r
        })) return;
      } else if (n === "meta" && (0, ze.default)("MetaProperty", t, {
        meta: r
      }))
        return;
      if (((0, fl.isKeyword)(r.name) || (0, fl.isReservedWord)(r.name, !1)) && r.name !== "this")
        throw new TypeError(`"${r.name}" is not a valid identifier`);
    } : void 0
  });
  F("IfStatement", {
    visitor: ["test", "consequent", "alternate"],
    aliases: ["Statement", "Conditional"],
    fields: {
      test: {
        validate: (0, S.assertNodeType)("Expression")
      },
      consequent: {
        validate: (0, S.assertNodeType)("Statement")
      },
      alternate: {
        optional: !0,
        validate: (0, S.assertNodeType)("Statement")
      }
    }
  });
  F("LabeledStatement", {
    visitor: ["label", "body"],
    aliases: ["Statement"],
    fields: {
      label: {
        validate: (0, S.assertNodeType)("Identifier")
      },
      body: {
        validate: (0, S.assertNodeType)("Statement")
      }
    }
  });
  F("StringLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, S.assertValueType)("string")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  F("NumericLiteral", {
    builder: ["value"],
    deprecatedAlias: "NumberLiteral",
    fields: {
      value: {
        validate: (0, S.chain)((0, S.assertValueType)("number"), Object.assign(function(t, e, r) {
          if (1 / r < 0 || !Number.isFinite(r)) {
            let i = new Error(`NumericLiterals must be non-negative finite numbers. You can use t.valueToNode(${r}) instead.`);
          }
        }, {
          type: "number"
        }))
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  F("NullLiteral", {
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  F("BooleanLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, S.assertValueType)("boolean")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  F("RegExpLiteral", {
    builder: ["pattern", "flags"],
    deprecatedAlias: "RegexLiteral",
    aliases: ["Expression", "Pureish", "Literal"],
    fields: {
      pattern: {
        validate: (0, S.assertValueType)("string")
      },
      flags: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, S.chain)((0, S.assertValueType)("string"), Object.assign(function(t, e, r) {
          let i = /[^gimsuy]/.exec(r);
          if (i)
            throw new TypeError(`"${i[0]}" is not a valid RegExp flag`);
        }, {
          type: "string"
        })) : (0, S.assertValueType)("string"),
        default: ""
      }
    }
  });
  F("LogicalExpression", {
    builder: ["operator", "left", "right"],
    visitor: ["left", "right"],
    aliases: ["Binary", "Expression"],
    fields: {
      operator: {
        validate: (0, S.assertOneOf)(...Nr.LOGICAL_OPERATORS)
      },
      left: {
        validate: (0, S.assertNodeType)("Expression")
      },
      right: {
        validate: (0, S.assertNodeType)("Expression")
      }
    }
  });
  F("MemberExpression", {
    builder: ["object", "property", "computed", ...process.env.BABEL_TYPES_8_BREAKING ? [] : ["optional"]],
    visitor: ["object", "property"],
    aliases: ["Expression", "LVal"],
    fields: Object.assign({
      object: {
        validate: (0, S.assertNodeType)("Expression", "Super")
      },
      property: {
        validate: function() {
          let t = (0, S.assertNodeType)("Identifier", "PrivateName"), e = (0, S.assertNodeType)("Expression"), r = /* @__PURE__ */ s(function(i, n, a) {
            (i.computed ? e : t)(i, n, a);
          }, "validator");
          return r.oneOfNodeTypes = ["Expression", "Identifier", "PrivateName"], r;
        }()
      },
      computed: {
        default: !1
      }
    }, process.env.BABEL_TYPES_8_BREAKING ? {} : {
      optional: {
        validate: (0, S.assertValueType)("boolean"),
        optional: !0
      }
    })
  });
  F("NewExpression", {
    inherits: "CallExpression"
  });
  F("Program", {
    visitor: ["directives", "body"],
    builder: ["body", "directives", "sourceType", "interpreter"],
    fields: {
      sourceType: {
        validate: (0, S.assertOneOf)("script", "module"),
        default: "script"
      },
      interpreter: {
        validate: (0, S.assertNodeType)("InterpreterDirective"),
        default: null,
        optional: !0
      },
      directives: {
        validate: (0, S.arrayOfType)("Directive"),
        default: []
      },
      body: (0, S.validateArrayOfType)("Statement")
    },
    aliases: ["Scopable", "BlockParent", "Block"]
  });
  F("ObjectExpression", {
    visitor: ["properties"],
    aliases: ["Expression"],
    fields: {
      properties: (0, S.validateArrayOfType)("ObjectMethod", "ObjectProperty", "SpreadElement")
    }
  });
  F("ObjectMethod", {
    builder: ["kind", "key", "params", "body", "computed", "generator", "async"],
    visitor: ["decorators", "key", "typeParameters", "params", "returnType", "body"],
    fields: Object.assign({}, ar(), Wt(), {
      kind: Object.assign({
        validate: (0, S.assertOneOf)("method", "get", "set")
      }, process.env.BABEL_TYPES_8_BREAKING ? {} : {
        default: "method"
      }),
      computed: {
        default: !1
      },
      key: {
        validate: function() {
          let t = (0, S.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"), e = (0, S.assertNodeType)("Expres\
sion"), r = /* @__PURE__ */ s(function(i, n, a) {
            (i.computed ? e : t)(i, n, a);
          }, "validator");
          return r.oneOfNodeTypes = ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"], r;
        }()
      },
      decorators: {
        validate: (0, S.arrayOfType)("Decorator"),
        optional: !0
      },
      body: {
        validate: (0, S.assertNodeType)("BlockStatement")
      }
    }),
    aliases: ["UserWhitespacable", "Function", "Scopable", "BlockParent", "FunctionParent", "Method", "ObjectMember"]
  });
  F("ObjectProperty", {
    builder: ["key", "value", "computed", "shorthand", ...process.env.BABEL_TYPES_8_BREAKING ? [] : ["decorators"]],
    fields: {
      computed: {
        default: !1
      },
      key: {
        validate: function() {
          let t = (0, S.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName"), e = (0, S.
          assertNodeType)("Expression");
          return Object.assign(function(i, n, a) {
            (i.computed ? e : t)(i, n, a);
          }, {
            oneOfNodeTypes: ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName"]
          });
        }()
      },
      value: {
        validate: (0, S.assertNodeType)("Expression", "PatternLike")
      },
      shorthand: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, S.chain)((0, S.assertValueType)("boolean"), Object.assign(function(t, e, r) {
          if (r) {
            if (t.computed)
              throw new TypeError("Property shorthand of ObjectProperty cannot be true if computed is true");
            if (!(0, ze.default)("Identifier", t.key))
              throw new TypeError("Property shorthand of ObjectProperty cannot be true if key is not an Identifier");
          }
        }, {
          type: "boolean"
        })) : (0, S.assertValueType)("boolean"),
        default: !1
      },
      decorators: {
        validate: (0, S.arrayOfType)("Decorator"),
        optional: !0
      }
    },
    visitor: ["key", "value", "decorators"],
    aliases: ["UserWhitespacable", "Property", "ObjectMember"],
    validate: process.env.BABEL_TYPES_8_BREAKING ? function() {
      let t = (0, S.assertNodeType)("Identifier", "Pattern", "TSAsExpression", "TSSatisfiesExpression", "TSNonNullExpression", "TSTypeAssert\
ion"), e = (0, S.assertNodeType)("Expression");
      return function(r, i, n) {
        ((0, ze.default)("ObjectPattern", r) ? t : e)(n, "value", n.value);
      };
    }() : void 0
  });
  F("RestElement", {
    visitor: ["argument", "typeAnnotation"],
    builder: ["argument"],
    aliases: ["LVal", "PatternLike"],
    deprecatedAlias: "RestProperty",
    fields: Object.assign({}, or(), {
      argument: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, S.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern", "MemberExpressio\
n", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") : (0, S.assertNodeType)("LVal")
      }
    }),
    validate: process.env.BABEL_TYPES_8_BREAKING ? function(t, e) {
      let r = /(\w+)\[(\d+)\]/.exec(e.toString());
      if (!r) throw new Error("Internal Babel error: malformed key.");
      let [, i, n] = r;
      if (t[i].length > +n + 1)
        throw new TypeError(`RestElement must be last element of ${i}`);
    } : void 0
  });
  F("ReturnStatement", {
    visitor: ["argument"],
    aliases: ["Statement", "Terminatorless", "CompletionStatement"],
    fields: {
      argument: {
        validate: (0, S.assertNodeType)("Expression"),
        optional: !0
      }
    }
  });
  F("SequenceExpression", {
    visitor: ["expressions"],
    fields: {
      expressions: (0, S.validateArrayOfType)("Expression")
    },
    aliases: ["Expression"]
  });
  F("ParenthesizedExpression", {
    visitor: ["expression"],
    aliases: ["Expression", "ExpressionWrapper"],
    fields: {
      expression: {
        validate: (0, S.assertNodeType)("Expression")
      }
    }
  });
  F("SwitchCase", {
    visitor: ["test", "consequent"],
    fields: {
      test: {
        validate: (0, S.assertNodeType)("Expression"),
        optional: !0
      },
      consequent: (0, S.validateArrayOfType)("Statement")
    }
  });
  F("SwitchStatement", {
    visitor: ["discriminant", "cases"],
    aliases: ["Statement", "BlockParent", "Scopable"],
    fields: {
      discriminant: {
        validate: (0, S.assertNodeType)("Expression")
      },
      cases: (0, S.validateArrayOfType)("SwitchCase")
    }
  });
  F("ThisExpression", {
    aliases: ["Expression"]
  });
  F("ThrowStatement", {
    visitor: ["argument"],
    aliases: ["Statement", "Terminatorless", "CompletionStatement"],
    fields: {
      argument: {
        validate: (0, S.assertNodeType)("Expression")
      }
    }
  });
  F("TryStatement", {
    visitor: ["block", "handler", "finalizer"],
    aliases: ["Statement"],
    fields: {
      block: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, S.chain)((0, S.assertNodeType)("BlockStatement"), Object.assign(function(t) {
          if (!t.handler && !t.finalizer)
            throw new TypeError("TryStatement expects either a handler or finalizer, or both");
        }, {
          oneOfNodeTypes: ["BlockStatement"]
        })) : (0, S.assertNodeType)("BlockStatement")
      },
      handler: {
        optional: !0,
        validate: (0, S.assertNodeType)("CatchClause")
      },
      finalizer: {
        optional: !0,
        validate: (0, S.assertNodeType)("BlockStatement")
      }
    }
  });
  F("UnaryExpression", {
    builder: ["operator", "argument", "prefix"],
    fields: {
      prefix: {
        default: !0
      },
      argument: {
        validate: (0, S.assertNodeType)("Expression")
      },
      operator: {
        validate: (0, S.assertOneOf)(...Nr.UNARY_OPERATORS)
      }
    },
    visitor: ["argument"],
    aliases: ["UnaryLike", "Expression"]
  });
  F("UpdateExpression", {
    builder: ["operator", "argument", "prefix"],
    fields: {
      prefix: {
        default: !1
      },
      argument: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, S.assertNodeType)("Identifier", "MemberExpression") : (0, S.assertNodeType)("Expr\
ession")
      },
      operator: {
        validate: (0, S.assertOneOf)(...Nr.UPDATE_OPERATORS)
      }
    },
    visitor: ["argument"],
    aliases: ["Expression"]
  });
  F("VariableDeclaration", {
    builder: ["kind", "declarations"],
    visitor: ["declarations"],
    aliases: ["Statement", "Declaration"],
    fields: {
      declare: {
        validate: (0, S.assertValueType)("boolean"),
        optional: !0
      },
      kind: {
        validate: (0, S.assertOneOf)("var", "let", "const", "using", "await using")
      },
      declarations: (0, S.validateArrayOfType)("VariableDeclarator")
    },
    validate: process.env.BABEL_TYPES_8_BREAKING ? (() => {
      let t = (0, S.assertNodeType)("Identifier");
      return function(e, r, i) {
        if ((0, ze.default)("ForXStatement", e, {
          left: i
        })) {
          if (i.declarations.length !== 1)
            throw new TypeError(`Exactly one VariableDeclarator is required in the VariableDeclaration of a ${e.type}`);
        } else
          i.declarations.forEach((n) => {
            n.init || t(n, "id", n.id);
          });
      };
    })() : void 0
  });
  F("VariableDeclarator", {
    visitor: ["id", "init"],
    fields: {
      id: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, S.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern") : (0, S.assertNodeType)(
        "LVal")
      },
      definite: {
        optional: !0,
        validate: (0, S.assertValueType)("boolean")
      },
      init: {
        optional: !0,
        validate: (0, S.assertNodeType)("Expression")
      }
    }
  });
  F("WhileStatement", {
    visitor: ["test", "body"],
    aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"],
    fields: {
      test: {
        validate: (0, S.assertNodeType)("Expression")
      },
      body: {
        validate: (0, S.assertNodeType)("Statement")
      }
    }
  });
  F("WithStatement", {
    visitor: ["object", "body"],
    aliases: ["Statement"],
    fields: {
      object: {
        validate: (0, S.assertNodeType)("Expression")
      },
      body: {
        validate: (0, S.assertNodeType)("Statement")
      }
    }
  });
  F("AssignmentPattern", {
    visitor: ["left", "right", "decorators"],
    builder: ["left", "right"],
    aliases: ["Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, or(), {
      left: {
        validate: (0, S.assertNodeType)("Identifier", "ObjectPattern", "ArrayPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExp\
ression", "TSTypeAssertion", "TSNonNullExpression")
      },
      right: {
        validate: (0, S.assertNodeType)("Expression")
      },
      decorators: {
        validate: (0, S.arrayOfType)("Decorator"),
        optional: !0
      }
    })
  });
  F("ArrayPattern", {
    visitor: ["elements", "typeAnnotation"],
    builder: ["elements"],
    aliases: ["Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, or(), {
      elements: {
        validate: (0, S.chain)((0, S.assertValueType)("array"), (0, S.assertEach)((0, S.assertNodeOrValueType)("null", "PatternLike", "LVal")))
      }
    })
  });
  F("ArrowFunctionExpression", {
    builder: ["params", "body", "async"],
    visitor: ["typeParameters", "params", "predicate", "returnType", "body"],
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
    fields: Object.assign({}, ar(), Wt(), {
      expression: {
        validate: (0, S.assertValueType)("boolean")
      },
      body: {
        validate: (0, S.assertNodeType)("BlockStatement", "Expression")
      },
      predicate: {
        validate: (0, S.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
        optional: !0
      }
    })
  });
  F("ClassBody", {
    visitor: ["body"],
    fields: {
      body: (0, S.validateArrayOfType)("ClassMethod", "ClassPrivateMethod", "ClassProperty", "ClassPrivateProperty", "ClassAccessorProperty",
      "TSDeclareMethod", "TSIndexSignature", "StaticBlock")
    }
  });
  F("ClassExpression", {
    builder: ["id", "superClass", "body", "decorators"],
    visitor: ["decorators", "id", "typeParameters", "superClass", "superTypeParameters", "mixins", "implements", "body"],
    aliases: ["Scopable", "Class", "Expression"],
    fields: {
      id: {
        validate: (0, S.assertNodeType)("Identifier"),
        optional: !0
      },
      typeParameters: {
        validate: (0, S.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
        optional: !0
      },
      body: {
        validate: (0, S.assertNodeType)("ClassBody")
      },
      superClass: {
        optional: !0,
        validate: (0, S.assertNodeType)("Expression")
      },
      superTypeParameters: {
        validate: (0, S.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: !0
      },
      implements: {
        validate: (0, S.arrayOfType)("TSExpressionWithTypeArguments", "ClassImplements"),
        optional: !0
      },
      decorators: {
        validate: (0, S.arrayOfType)("Decorator"),
        optional: !0
      },
      mixins: {
        validate: (0, S.assertNodeType)("InterfaceExtends"),
        optional: !0
      }
    }
  });
  F("ClassDeclaration", {
    inherits: "ClassExpression",
    aliases: ["Scopable", "Class", "Statement", "Declaration"],
    fields: {
      id: {
        validate: (0, S.assertNodeType)("Identifier"),
        optional: !0
      },
      typeParameters: {
        validate: (0, S.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
        optional: !0
      },
      body: {
        validate: (0, S.assertNodeType)("ClassBody")
      },
      superClass: {
        optional: !0,
        validate: (0, S.assertNodeType)("Expression")
      },
      superTypeParameters: {
        validate: (0, S.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: !0
      },
      implements: {
        validate: (0, S.arrayOfType)("TSExpressionWithTypeArguments", "ClassImplements"),
        optional: !0
      },
      decorators: {
        validate: (0, S.arrayOfType)("Decorator"),
        optional: !0
      },
      mixins: {
        validate: (0, S.assertNodeType)("InterfaceExtends"),
        optional: !0
      },
      declare: {
        validate: (0, S.assertValueType)("boolean"),
        optional: !0
      },
      abstract: {
        validate: (0, S.assertValueType)("boolean"),
        optional: !0
      }
    },
    validate: process.env.BABEL_TYPES_8_BREAKING ? function() {
      let t = (0, S.assertNodeType)("Identifier");
      return function(e, r, i) {
        (0, ze.default)("ExportDefaultDeclaration", e) || t(i, "id", i.id);
      };
    }() : void 0
  });
  var Bs = Ve.importAttributes = {
    attributes: {
      optional: !0,
      validate: (0, S.arrayOfType)("ImportAttribute")
    },
    assertions: {
      deprecated: !0,
      optional: !0,
      validate: (0, S.arrayOfType)("ImportAttribute")
    }
  };
  F("ExportAllDeclaration", {
    builder: ["source"],
    visitor: ["source", "attributes", "assertions"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
    fields: Object.assign({
      source: {
        validate: (0, S.assertNodeType)("StringLiteral")
      },
      exportKind: (0, S.validateOptional)((0, S.assertOneOf)("type", "value"))
    }, Bs)
  });
  F("ExportDefaultDeclaration", {
    visitor: ["declaration"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
    fields: {
      declaration: (0, S.validateType)("TSDeclareFunction", "FunctionDeclaration", "ClassDeclaration", "Expression"),
      exportKind: (0, S.validateOptional)((0, S.assertOneOf)("value"))
    }
  });
  F("ExportNamedDeclaration", {
    builder: ["declaration", "specifiers", "source"],
    visitor: process.env ? ["declaration", "specifiers", "source", "attributes"] : ["declaration", "specifiers", "source", "attributes", "as\
sertions"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
    fields: Object.assign({
      declaration: {
        optional: !0,
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, S.chain)((0, S.assertNodeType)("Declaration"), Object.assign(function(t, e, r) {
          if (r && t.specifiers.length)
            throw new TypeError("Only declaration or specifiers is allowed on ExportNamedDeclaration");
          if (r && t.source)
            throw new TypeError("Cannot export a declaration from a source");
        }, {
          oneOfNodeTypes: ["Declaration"]
        })) : (0, S.assertNodeType)("Declaration")
      }
    }, Bs, {
      specifiers: {
        default: [],
        validate: (0, S.arrayOf)(function() {
          let t = (0, S.assertNodeType)("ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier"), e = (0, S.assertNodeType)(
          "ExportSpecifier");
          return process.env.BABEL_TYPES_8_BREAKING ? Object.assign(function(r, i, n) {
            (r.source ? t : e)(r, i, n);
          }, {
            oneOfNodeTypes: ["ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier"]
          }) : t;
        }())
      },
      source: {
        validate: (0, S.assertNodeType)("StringLiteral"),
        optional: !0
      },
      exportKind: (0, S.validateOptional)((0, S.assertOneOf)("type", "value"))
    })
  });
  F("ExportSpecifier", {
    visitor: ["local", "exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, S.assertNodeType)("Identifier")
      },
      exported: {
        validate: (0, S.assertNodeType)("Identifier", "StringLiteral")
      },
      exportKind: {
        validate: (0, S.assertOneOf)("type", "value"),
        optional: !0
      }
    }
  });
  F("ForOfStatement", {
    visitor: ["left", "right", "body"],
    builder: ["left", "right", "body", "await"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
    fields: {
      left: {
        validate: function() {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return (0, S.assertNodeType)("VariableDeclaration", "LVal");
          let t = (0, S.assertNodeType)("VariableDeclaration"), e = (0, S.assertNodeType)("Identifier", "MemberExpression", "ArrayPattern", "\
ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression");
          return Object.assign(function(r, i, n) {
            (0, ze.default)("VariableDeclaration", n) ? t(r, i, n) : e(r, i, n);
          }, {
            oneOfNodeTypes: ["VariableDeclaration", "Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TS\
SatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression"]
          });
        }()
      },
      right: {
        validate: (0, S.assertNodeType)("Expression")
      },
      body: {
        validate: (0, S.assertNodeType)("Statement")
      },
      await: {
        default: !1
      }
    }
  });
  F("ImportDeclaration", {
    builder: ["specifiers", "source"],
    visitor: ["specifiers", "source", "attributes", "assertions"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration"],
    fields: Object.assign({}, Bs, {
      module: {
        optional: !0,
        validate: (0, S.assertValueType)("boolean")
      },
      phase: {
        default: null,
        validate: (0, S.assertOneOf)("source", "defer")
      },
      specifiers: (0, S.validateArrayOfType)("ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier"),
      source: {
        validate: (0, S.assertNodeType)("StringLiteral")
      },
      importKind: {
        validate: (0, S.assertOneOf)("type", "typeof", "value"),
        optional: !0
      }
    })
  });
  F("ImportDefaultSpecifier", {
    visitor: ["local"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, S.assertNodeType)("Identifier")
      }
    }
  });
  F("ImportNamespaceSpecifier", {
    visitor: ["local"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, S.assertNodeType)("Identifier")
      }
    }
  });
  F("ImportSpecifier", {
    visitor: ["imported", "local"],
    builder: ["local", "imported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, S.assertNodeType)("Identifier")
      },
      imported: {
        validate: (0, S.assertNodeType)("Identifier", "StringLiteral")
      },
      importKind: {
        validate: (0, S.assertOneOf)("type", "typeof", "value"),
        optional: !0
      }
    }
  });
  F("ImportExpression", {
    visitor: ["source", "options"],
    aliases: ["Expression"],
    fields: {
      phase: {
        default: null,
        validate: (0, S.assertOneOf)("source", "defer")
      },
      source: {
        validate: (0, S.assertNodeType)("Expression")
      },
      options: {
        validate: (0, S.assertNodeType)("Expression"),
        optional: !0
      }
    }
  });
  F("MetaProperty", {
    visitor: ["meta", "property"],
    aliases: ["Expression"],
    fields: {
      meta: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, S.chain)((0, S.assertNodeType)("Identifier"), Object.assign(function(t, e, r) {
          let i;
          switch (r.name) {
            case "function":
              i = "sent";
              break;
            case "new":
              i = "target";
              break;
            case "import":
              i = "meta";
              break;
          }
          if (!(0, ze.default)("Identifier", t.property, {
            name: i
          }))
            throw new TypeError("Unrecognised MetaProperty");
        }, {
          oneOfNodeTypes: ["Identifier"]
        })) : (0, S.assertNodeType)("Identifier")
      },
      property: {
        validate: (0, S.assertNodeType)("Identifier")
      }
    }
  });
  var yi = /* @__PURE__ */ s(() => ({
    abstract: {
      validate: (0, S.assertValueType)("boolean"),
      optional: !0
    },
    accessibility: {
      validate: (0, S.assertOneOf)("public", "private", "protected"),
      optional: !0
    },
    static: {
      default: !1
    },
    override: {
      default: !1
    },
    computed: {
      default: !1
    },
    optional: {
      validate: (0, S.assertValueType)("boolean"),
      optional: !0
    },
    key: {
      validate: (0, S.chain)(function() {
        let t = (0, S.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"), e = (0, S.assertNodeType)("Expressi\
on");
        return function(r, i, n) {
          (r.computed ? e : t)(r, i, n);
        };
      }(), (0, S.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression"))
    }
  }), "classMethodOrPropertyCommon");
  Ve.classMethodOrPropertyCommon = yi;
  var js = /* @__PURE__ */ s(() => Object.assign({}, ar(), yi(), {
    params: (0, S.validateArrayOfType)("Identifier", "Pattern", "RestElement", "TSParameterProperty"),
    kind: {
      validate: (0, S.assertOneOf)("get", "set", "method", "constructor"),
      default: "method"
    },
    access: {
      validate: (0, S.chain)((0, S.assertValueType)("string"), (0, S.assertOneOf)("public", "private", "protected")),
      optional: !0
    },
    decorators: {
      validate: (0, S.arrayOfType)("Decorator"),
      optional: !0
    }
  }), "classMethodOrDeclareMethodCommon");
  Ve.classMethodOrDeclareMethodCommon = js;
  F("ClassMethod", {
    aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method"],
    builder: ["kind", "key", "params", "body", "computed", "static", "generator", "async"],
    visitor: ["decorators", "key", "typeParameters", "params", "returnType", "body"],
    fields: Object.assign({}, js(), Wt(), {
      body: {
        validate: (0, S.assertNodeType)("BlockStatement")
      }
    })
  });
  F("ObjectPattern", {
    visitor: ["properties", "typeAnnotation", "decorators"],
    builder: ["properties"],
    aliases: ["Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, or(), {
      properties: (0, S.validateArrayOfType)("RestElement", "ObjectProperty")
    })
  });
  F("SpreadElement", {
    visitor: ["argument"],
    aliases: ["UnaryLike"],
    deprecatedAlias: "SpreadProperty",
    fields: {
      argument: {
        validate: (0, S.assertNodeType)("Expression")
      }
    }
  });
  F("Super", {
    aliases: ["Expression"]
  });
  F("TaggedTemplateExpression", {
    visitor: ["tag", "typeParameters", "quasi"],
    builder: ["tag", "quasi"],
    aliases: ["Expression"],
    fields: {
      tag: {
        validate: (0, S.assertNodeType)("Expression")
      },
      quasi: {
        validate: (0, S.assertNodeType)("TemplateLiteral")
      },
      typeParameters: {
        validate: (0, S.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: !0
      }
    }
  });
  F("TemplateElement", {
    builder: ["value", "tail"],
    fields: {
      value: {
        validate: (0, S.chain)((0, S.assertShape)({
          raw: {
            validate: (0, S.assertValueType)("string")
          },
          cooked: {
            validate: (0, S.assertValueType)("string"),
            optional: !0
          }
        }), /* @__PURE__ */ s(function(e) {
          let r = e.value.raw, i = !1, n = /* @__PURE__ */ s(() => {
            throw new Error("Internal @babel/types error.");
          }, "error"), {
            str: a,
            firstInvalidLoc: o
          } = (0, PS.readStringContents)("template", r, 0, 0, 0, {
            unterminated() {
              i = !0;
            },
            strictNumericEscape: n,
            invalidEscapeSequence: n,
            numericSeparatorInEscapeSequence: n,
            unexpectedNumericSeparator: n,
            invalidDigit: n,
            invalidCodePoint: n
          });
          if (!i) throw new Error("Invalid raw");
          e.value.cooked = o ? null : a;
        }, "templateElementCookedValidator"))
      },
      tail: {
        default: !1
      }
    }
  });
  F("TemplateLiteral", {
    visitor: ["quasis", "expressions"],
    aliases: ["Expression", "Literal"],
    fields: {
      quasis: (0, S.validateArrayOfType)("TemplateElement"),
      expressions: {
        validate: (0, S.chain)((0, S.assertValueType)("array"), (0, S.assertEach)((0, S.assertNodeType)("Expression", "TSType")), function(t, e, r) {
          if (t.quasis.length !== r.length + 1)
            throw new TypeError(`Number of ${t.type} quasis should be exactly one more than the number of expressions.
Expected ${r.length + 1} quasis but got ${t.quasis.length}`);
        })
      }
    }
  });
  F("YieldExpression", {
    builder: ["argument", "delegate"],
    visitor: ["argument"],
    aliases: ["Expression", "Terminatorless"],
    fields: {
      delegate: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, S.chain)((0, S.assertValueType)("boolean"), Object.assign(function(t, e, r) {
          if (r && !t.argument)
            throw new TypeError("Property delegate of YieldExpression cannot be true if there is no argument");
        }, {
          type: "boolean"
        })) : (0, S.assertValueType)("boolean"),
        default: !1
      },
      argument: {
        optional: !0,
        validate: (0, S.assertNodeType)("Expression")
      }
    }
  });
  F("AwaitExpression", {
    builder: ["argument"],
    visitor: ["argument"],
    aliases: ["Expression", "Terminatorless"],
    fields: {
      argument: {
        validate: (0, S.assertNodeType)("Expression")
      }
    }
  });
  F("Import", {
    aliases: ["Expression"]
  });
  F("BigIntLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, S.assertValueType)("string")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  F("ExportNamespaceSpecifier", {
    visitor: ["exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      exported: {
        validate: (0, S.assertNodeType)("Identifier")
      }
    }
  });
  F("OptionalMemberExpression", {
    builder: ["object", "property", "computed", "optional"],
    visitor: ["object", "property"],
    aliases: ["Expression"],
    fields: {
      object: {
        validate: (0, S.assertNodeType)("Expression")
      },
      property: {
        validate: function() {
          let t = (0, S.assertNodeType)("Identifier"), e = (0, S.assertNodeType)("Expression");
          return Object.assign(function(i, n, a) {
            (i.computed ? e : t)(i, n, a);
          }, {
            oneOfNodeTypes: ["Expression", "Identifier"]
          });
        }()
      },
      computed: {
        default: !1
      },
      optional: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, S.chain)((0, S.assertValueType)("boolean"), (0, S.assertOptionalChainStart)()) : (0, S.
        assertValueType)("boolean")
      }
    }
  });
  F("OptionalCallExpression", {
    visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
    builder: ["callee", "arguments", "optional"],
    aliases: ["Expression"],
    fields: Object.assign({
      callee: {
        validate: (0, S.assertNodeType)("Expression")
      },
      arguments: (0, S.validateArrayOfType)("Expression", "SpreadElement", "ArgumentPlaceholder"),
      optional: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, S.chain)((0, S.assertValueType)("boolean"), (0, S.assertOptionalChainStart)()) : (0, S.
        assertValueType)("boolean")
      },
      typeArguments: {
        validate: (0, S.assertNodeType)("TypeParameterInstantiation"),
        optional: !0
      }
    }, {
      typeParameters: {
        validate: (0, S.assertNodeType)("TSTypeParameterInstantiation"),
        optional: !0
      }
    })
  });
  F("ClassProperty", {
    visitor: ["decorators", "variance", "key", "typeAnnotation", "value"],
    builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
    aliases: ["Property"],
    fields: Object.assign({}, yi(), {
      value: {
        validate: (0, S.assertNodeType)("Expression"),
        optional: !0
      },
      definite: {
        validate: (0, S.assertValueType)("boolean"),
        optional: !0
      },
      typeAnnotation: {
        validate: (0, S.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: !0
      },
      decorators: {
        validate: (0, S.arrayOfType)("Decorator"),
        optional: !0
      },
      readonly: {
        validate: (0, S.assertValueType)("boolean"),
        optional: !0
      },
      declare: {
        validate: (0, S.assertValueType)("boolean"),
        optional: !0
      },
      variance: {
        validate: (0, S.assertNodeType)("Variance"),
        optional: !0
      }
    })
  });
  F("ClassAccessorProperty", {
    visitor: ["decorators", "key", "typeAnnotation", "value"],
    builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
    aliases: ["Property", "Accessor"],
    fields: Object.assign({}, yi(), {
      key: {
        validate: (0, S.chain)(function() {
          let t = (0, S.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "PrivateName"), e = (0, S.assertNodeType)(
          "Expression");
          return function(r, i, n) {
            (r.computed ? e : t)(r, i, n);
          };
        }(), (0, S.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression", "PrivateName"))
      },
      value: {
        validate: (0, S.assertNodeType)("Expression"),
        optional: !0
      },
      definite: {
        validate: (0, S.assertValueType)("boolean"),
        optional: !0
      },
      typeAnnotation: {
        validate: (0, S.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: !0
      },
      decorators: {
        validate: (0, S.arrayOfType)("Decorator"),
        optional: !0
      },
      readonly: {
        validate: (0, S.assertValueType)("boolean"),
        optional: !0
      },
      declare: {
        validate: (0, S.assertValueType)("boolean"),
        optional: !0
      },
      variance: {
        validate: (0, S.assertNodeType)("Variance"),
        optional: !0
      }
    })
  });
  F("ClassPrivateProperty", {
    visitor: ["decorators", "variance", "key", "typeAnnotation", "value"],
    builder: ["key", "value", "decorators", "static"],
    aliases: ["Property", "Private"],
    fields: {
      key: {
        validate: (0, S.assertNodeType)("PrivateName")
      },
      value: {
        validate: (0, S.assertNodeType)("Expression"),
        optional: !0
      },
      typeAnnotation: {
        validate: (0, S.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: !0
      },
      decorators: {
        validate: (0, S.arrayOfType)("Decorator"),
        optional: !0
      },
      static: {
        validate: (0, S.assertValueType)("boolean"),
        default: !1
      },
      readonly: {
        validate: (0, S.assertValueType)("boolean"),
        optional: !0
      },
      optional: {
        validate: (0, S.assertValueType)("boolean"),
        optional: !0
      },
      definite: {
        validate: (0, S.assertValueType)("boolean"),
        optional: !0
      },
      variance: {
        validate: (0, S.assertNodeType)("Variance"),
        optional: !0
      }
    }
  });
  F("ClassPrivateMethod", {
    builder: ["kind", "key", "params", "body", "static"],
    visitor: ["decorators", "key", "typeParameters", "params", "returnType", "body"],
    aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method", "Private"],
    fields: Object.assign({}, js(), Wt(), {
      kind: {
        validate: (0, S.assertOneOf)("get", "set", "method"),
        default: "method"
      },
      key: {
        validate: (0, S.assertNodeType)("PrivateName")
      },
      body: {
        validate: (0, S.assertNodeType)("BlockStatement")
      }
    })
  });
  F("PrivateName", {
    visitor: ["id"],
    aliases: ["Private"],
    fields: {
      id: {
        validate: (0, S.assertNodeType)("Identifier")
      }
    }
  });
  F("StaticBlock", {
    visitor: ["body"],
    fields: {
      body: (0, S.validateArrayOfType)("Statement")
    },
    aliases: ["Scopable", "BlockParent", "FunctionParent"]
  });
  F("ImportAttribute", {
    visitor: ["key", "value"],
    fields: {
      key: {
        validate: (0, S.assertNodeType)("Identifier", "StringLiteral")
      },
      value: {
        validate: (0, S.assertNodeType)("StringLiteral")
      }
    }
  });
});

// ../node_modules/@babel/types/lib/definitions/flow.js
var ml = O(() => {
  "use strict";
  var dl = Or(), A = bt(), Z = (0, A.defineAliasedType)("Flow"), Fs = /* @__PURE__ */ s((t) => {
    let e = t === "DeclareClass";
    Z(t, {
      builder: ["id", "typeParameters", "extends", "body"],
      visitor: ["id", "typeParameters", "extends", ...e ? ["mixins", "implements"] : [], "body"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: Object.assign({
        id: (0, A.validateType)("Identifier"),
        typeParameters: (0, A.validateOptionalType)("TypeParameterDeclaration"),
        extends: (0, A.validateOptional)((0, A.arrayOfType)("InterfaceExtends"))
      }, e ? {
        mixins: (0, A.validateOptional)((0, A.arrayOfType)("InterfaceExtends")),
        implements: (0, A.validateOptional)((0, A.arrayOfType)("ClassImplements"))
      } : {}, {
        body: (0, A.validateType)("ObjectTypeAnnotation")
      })
    });
  }, "defineInterfaceishType");
  Z("AnyTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  Z("ArrayTypeAnnotation", {
    visitor: ["elementType"],
    aliases: ["FlowType"],
    fields: {
      elementType: (0, A.validateType)("FlowType")
    }
  });
  Z("BooleanTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  Z("BooleanLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["FlowType"],
    fields: {
      value: (0, A.validate)((0, A.assertValueType)("boolean"))
    }
  });
  Z("NullLiteralTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  Z("ClassImplements", {
    visitor: ["id", "typeParameters"],
    fields: {
      id: (0, A.validateType)("Identifier"),
      typeParameters: (0, A.validateOptionalType)("TypeParameterInstantiation")
    }
  });
  Fs("DeclareClass");
  Z("DeclareFunction", {
    builder: ["id"],
    visitor: ["id", "predicate"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, A.validateType)("Identifier"),
      predicate: (0, A.validateOptionalType)("DeclaredPredicate")
    }
  });
  Fs("DeclareInterface");
  Z("DeclareModule", {
    builder: ["id", "body", "kind"],
    visitor: ["id", "body"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, A.validateType)("Identifier", "StringLiteral"),
      body: (0, A.validateType)("BlockStatement"),
      kind: (0, A.validateOptional)((0, A.assertOneOf)("CommonJS", "ES"))
    }
  });
  Z("DeclareModuleExports", {
    visitor: ["typeAnnotation"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      typeAnnotation: (0, A.validateType)("TypeAnnotation")
    }
  });
  Z("DeclareTypeAlias", {
    visitor: ["id", "typeParameters", "right"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, A.validateType)("Identifier"),
      typeParameters: (0, A.validateOptionalType)("TypeParameterDeclaration"),
      right: (0, A.validateType)("FlowType")
    }
  });
  Z("DeclareOpaqueType", {
    visitor: ["id", "typeParameters", "supertype"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, A.validateType)("Identifier"),
      typeParameters: (0, A.validateOptionalType)("TypeParameterDeclaration"),
      supertype: (0, A.validateOptionalType)("FlowType"),
      impltype: (0, A.validateOptionalType)("FlowType")
    }
  });
  Z("DeclareVariable", {
    visitor: ["id"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, A.validateType)("Identifier")
    }
  });
  Z("DeclareExportDeclaration", {
    visitor: ["declaration", "specifiers", "source", "attributes"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: Object.assign({
      declaration: (0, A.validateOptionalType)("Flow"),
      specifiers: (0, A.validateOptional)((0, A.arrayOfType)("ExportSpecifier", "ExportNamespaceSpecifier")),
      source: (0, A.validateOptionalType)("StringLiteral"),
      default: (0, A.validateOptional)((0, A.assertValueType)("boolean"))
    }, dl.importAttributes)
  });
  Z("DeclareExportAllDeclaration", {
    visitor: ["source", "attributes"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: Object.assign({
      source: (0, A.validateType)("StringLiteral"),
      exportKind: (0, A.validateOptional)((0, A.assertOneOf)("type", "value"))
    }, dl.importAttributes)
  });
  Z("DeclaredPredicate", {
    visitor: ["value"],
    aliases: ["FlowPredicate"],
    fields: {
      value: (0, A.validateType)("Flow")
    }
  });
  Z("ExistsTypeAnnotation", {
    aliases: ["FlowType"]
  });
  Z("FunctionTypeAnnotation", {
    builder: ["typeParameters", "params", "rest", "returnType"],
    visitor: ["typeParameters", "this", "params", "rest", "returnType"],
    aliases: ["FlowType"],
    fields: {
      typeParameters: (0, A.validateOptionalType)("TypeParameterDeclaration"),
      params: (0, A.validateArrayOfType)("FunctionTypeParam"),
      rest: (0, A.validateOptionalType)("FunctionTypeParam"),
      this: (0, A.validateOptionalType)("FunctionTypeParam"),
      returnType: (0, A.validateType)("FlowType")
    }
  });
  Z("FunctionTypeParam", {
    visitor: ["name", "typeAnnotation"],
    fields: {
      name: (0, A.validateOptionalType)("Identifier"),
      typeAnnotation: (0, A.validateType)("FlowType"),
      optional: (0, A.validateOptional)((0, A.assertValueType)("boolean"))
    }
  });
  Z("GenericTypeAnnotation", {
    visitor: ["id", "typeParameters"],
    aliases: ["FlowType"],
    fields: {
      id: (0, A.validateType)("Identifier", "QualifiedTypeIdentifier"),
      typeParameters: (0, A.validateOptionalType)("TypeParameterInstantiation")
    }
  });
  Z("InferredPredicate", {
    aliases: ["FlowPredicate"]
  });
  Z("InterfaceExtends", {
    visitor: ["id", "typeParameters"],
    fields: {
      id: (0, A.validateType)("Identifier", "QualifiedTypeIdentifier"),
      typeParameters: (0, A.validateOptionalType)("TypeParameterInstantiation")
    }
  });
  Fs("InterfaceDeclaration");
  Z("InterfaceTypeAnnotation", {
    visitor: ["extends", "body"],
    aliases: ["FlowType"],
    fields: {
      extends: (0, A.validateOptional)((0, A.arrayOfType)("InterfaceExtends")),
      body: (0, A.validateType)("ObjectTypeAnnotation")
    }
  });
  Z("IntersectionTypeAnnotation", {
    visitor: ["types"],
    aliases: ["FlowType"],
    fields: {
      types: (0, A.validate)((0, A.arrayOfType)("FlowType"))
    }
  });
  Z("MixedTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  Z("EmptyTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  Z("NullableTypeAnnotation", {
    visitor: ["typeAnnotation"],
    aliases: ["FlowType"],
    fields: {
      typeAnnotation: (0, A.validateType)("FlowType")
    }
  });
  Z("NumberLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["FlowType"],
    fields: {
      value: (0, A.validate)((0, A.assertValueType)("number"))
    }
  });
  Z("NumberTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  Z("ObjectTypeAnnotation", {
    visitor: ["properties", "indexers", "callProperties", "internalSlots"],
    aliases: ["FlowType"],
    builder: ["properties", "indexers", "callProperties", "internalSlots", "exact"],
    fields: {
      properties: (0, A.validate)((0, A.arrayOfType)("ObjectTypeProperty", "ObjectTypeSpreadProperty")),
      indexers: {
        validate: (0, A.arrayOfType)("ObjectTypeIndexer"),
        optional: !0,
        default: []
      },
      callProperties: {
        validate: (0, A.arrayOfType)("ObjectTypeCallProperty"),
        optional: !0,
        default: []
      },
      internalSlots: {
        validate: (0, A.arrayOfType)("ObjectTypeInternalSlot"),
        optional: !0,
        default: []
      },
      exact: {
        validate: (0, A.assertValueType)("boolean"),
        default: !1
      },
      inexact: (0, A.validateOptional)((0, A.assertValueType)("boolean"))
    }
  });
  Z("ObjectTypeInternalSlot", {
    visitor: ["id", "value"],
    builder: ["id", "value", "optional", "static", "method"],
    aliases: ["UserWhitespacable"],
    fields: {
      id: (0, A.validateType)("Identifier"),
      value: (0, A.validateType)("FlowType"),
      optional: (0, A.validate)((0, A.assertValueType)("boolean")),
      static: (0, A.validate)((0, A.assertValueType)("boolean")),
      method: (0, A.validate)((0, A.assertValueType)("boolean"))
    }
  });
  Z("ObjectTypeCallProperty", {
    visitor: ["value"],
    aliases: ["UserWhitespacable"],
    fields: {
      value: (0, A.validateType)("FlowType"),
      static: (0, A.validate)((0, A.assertValueType)("boolean"))
    }
  });
  Z("ObjectTypeIndexer", {
    visitor: ["variance", "id", "key", "value"],
    builder: ["id", "key", "value", "variance"],
    aliases: ["UserWhitespacable"],
    fields: {
      id: (0, A.validateOptionalType)("Identifier"),
      key: (0, A.validateType)("FlowType"),
      value: (0, A.validateType)("FlowType"),
      static: (0, A.validate)((0, A.assertValueType)("boolean")),
      variance: (0, A.validateOptionalType)("Variance")
    }
  });
  Z("ObjectTypeProperty", {
    visitor: ["key", "value", "variance"],
    aliases: ["UserWhitespacable"],
    fields: {
      key: (0, A.validateType)("Identifier", "StringLiteral"),
      value: (0, A.validateType)("FlowType"),
      kind: (0, A.validate)((0, A.assertOneOf)("init", "get", "set")),
      static: (0, A.validate)((0, A.assertValueType)("boolean")),
      proto: (0, A.validate)((0, A.assertValueType)("boolean")),
      optional: (0, A.validate)((0, A.assertValueType)("boolean")),
      variance: (0, A.validateOptionalType)("Variance"),
      method: (0, A.validate)((0, A.assertValueType)("boolean"))
    }
  });
  Z("ObjectTypeSpreadProperty", {
    visitor: ["argument"],
    aliases: ["UserWhitespacable"],
    fields: {
      argument: (0, A.validateType)("FlowType")
    }
  });
  Z("OpaqueType", {
    visitor: ["id", "typeParameters", "supertype", "impltype"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, A.validateType)("Identifier"),
      typeParameters: (0, A.validateOptionalType)("TypeParameterDeclaration"),
      supertype: (0, A.validateOptionalType)("FlowType"),
      impltype: (0, A.validateType)("FlowType")
    }
  });
  Z("QualifiedTypeIdentifier", {
    visitor: ["qualification", "id"],
    builder: ["id", "qualification"],
    fields: {
      id: (0, A.validateType)("Identifier"),
      qualification: (0, A.validateType)("Identifier", "QualifiedTypeIdentifier")
    }
  });
  Z("StringLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["FlowType"],
    fields: {
      value: (0, A.validate)((0, A.assertValueType)("string"))
    }
  });
  Z("StringTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  Z("SymbolTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  Z("ThisTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  Z("TupleTypeAnnotation", {
    visitor: ["types"],
    aliases: ["FlowType"],
    fields: {
      types: (0, A.validate)((0, A.arrayOfType)("FlowType"))
    }
  });
  Z("TypeofTypeAnnotation", {
    visitor: ["argument"],
    aliases: ["FlowType"],
    fields: {
      argument: (0, A.validateType)("FlowType")
    }
  });
  Z("TypeAlias", {
    visitor: ["id", "typeParameters", "right"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, A.validateType)("Identifier"),
      typeParameters: (0, A.validateOptionalType)("TypeParameterDeclaration"),
      right: (0, A.validateType)("FlowType")
    }
  });
  Z("TypeAnnotation", {
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, A.validateType)("FlowType")
    }
  });
  Z("TypeCastExpression", {
    visitor: ["expression", "typeAnnotation"],
    aliases: ["ExpressionWrapper", "Expression"],
    fields: {
      expression: (0, A.validateType)("Expression"),
      typeAnnotation: (0, A.validateType)("TypeAnnotation")
    }
  });
  Z("TypeParameter", {
    visitor: ["bound", "default", "variance"],
    fields: {
      name: (0, A.validate)((0, A.assertValueType)("string")),
      bound: (0, A.validateOptionalType)("TypeAnnotation"),
      default: (0, A.validateOptionalType)("FlowType"),
      variance: (0, A.validateOptionalType)("Variance")
    }
  });
  Z("TypeParameterDeclaration", {
    visitor: ["params"],
    fields: {
      params: (0, A.validate)((0, A.arrayOfType)("TypeParameter"))
    }
  });
  Z("TypeParameterInstantiation", {
    visitor: ["params"],
    fields: {
      params: (0, A.validate)((0, A.arrayOfType)("FlowType"))
    }
  });
  Z("UnionTypeAnnotation", {
    visitor: ["types"],
    aliases: ["FlowType"],
    fields: {
      types: (0, A.validate)((0, A.arrayOfType)("FlowType"))
    }
  });
  Z("Variance", {
    builder: ["kind"],
    fields: {
      kind: (0, A.validate)((0, A.assertOneOf)("minus", "plus"))
    }
  });
  Z("VoidTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  Z("EnumDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "body"],
    fields: {
      id: (0, A.validateType)("Identifier"),
      body: (0, A.validateType)("EnumBooleanBody", "EnumNumberBody", "EnumStringBody", "EnumSymbolBody")
    }
  });
  Z("EnumBooleanBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: (0, A.validate)((0, A.assertValueType)("boolean")),
      members: (0, A.validateArrayOfType)("EnumBooleanMember"),
      hasUnknownMembers: (0, A.validate)((0, A.assertValueType)("boolean"))
    }
  });
  Z("EnumNumberBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: (0, A.validate)((0, A.assertValueType)("boolean")),
      members: (0, A.validateArrayOfType)("EnumNumberMember"),
      hasUnknownMembers: (0, A.validate)((0, A.assertValueType)("boolean"))
    }
  });
  Z("EnumStringBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: (0, A.validate)((0, A.assertValueType)("boolean")),
      members: (0, A.validateArrayOfType)("EnumStringMember", "EnumDefaultedMember"),
      hasUnknownMembers: (0, A.validate)((0, A.assertValueType)("boolean"))
    }
  });
  Z("EnumSymbolBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      members: (0, A.validateArrayOfType)("EnumDefaultedMember"),
      hasUnknownMembers: (0, A.validate)((0, A.assertValueType)("boolean"))
    }
  });
  Z("EnumBooleanMember", {
    aliases: ["EnumMember"],
    builder: ["id"],
    visitor: ["id", "init"],
    fields: {
      id: (0, A.validateType)("Identifier"),
      init: (0, A.validateType)("BooleanLiteral")
    }
  });
  Z("EnumNumberMember", {
    aliases: ["EnumMember"],
    visitor: ["id", "init"],
    fields: {
      id: (0, A.validateType)("Identifier"),
      init: (0, A.validateType)("NumericLiteral")
    }
  });
  Z("EnumStringMember", {
    aliases: ["EnumMember"],
    visitor: ["id", "init"],
    fields: {
      id: (0, A.validateType)("Identifier"),
      init: (0, A.validateType)("StringLiteral")
    }
  });
  Z("EnumDefaultedMember", {
    aliases: ["EnumMember"],
    visitor: ["id"],
    fields: {
      id: (0, A.validateType)("Identifier")
    }
  });
  Z("IndexedAccessType", {
    visitor: ["objectType", "indexType"],
    aliases: ["FlowType"],
    fields: {
      objectType: (0, A.validateType)("FlowType"),
      indexType: (0, A.validateType)("FlowType")
    }
  });
  Z("OptionalIndexedAccessType", {
    visitor: ["objectType", "indexType"],
    aliases: ["FlowType"],
    fields: {
      objectType: (0, A.validateType)("FlowType"),
      indexType: (0, A.validateType)("FlowType"),
      optional: (0, A.validate)((0, A.assertValueType)("boolean"))
    }
  });
});

// ../node_modules/@babel/types/lib/definitions/jsx.js
var yl = O(() => {
  "use strict";
  var De = bt(), $e = (0, De.defineAliasedType)("JSX");
  $e("JSXAttribute", {
    visitor: ["name", "value"],
    aliases: ["Immutable"],
    fields: {
      name: {
        validate: (0, De.assertNodeType)("JSXIdentifier", "JSXNamespacedName")
      },
      value: {
        optional: !0,
        validate: (0, De.assertNodeType)("JSXElement", "JSXFragment", "StringLiteral", "JSXExpressionContainer")
      }
    }
  });
  $e("JSXClosingElement", {
    visitor: ["name"],
    aliases: ["Immutable"],
    fields: {
      name: {
        validate: (0, De.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
      }
    }
  });
  $e("JSXElement", {
    builder: ["openingElement", "closingElement", "children", "selfClosing"],
    visitor: ["openingElement", "children", "closingElement"],
    aliases: ["Immutable", "Expression"],
    fields: Object.assign({
      openingElement: {
        validate: (0, De.assertNodeType)("JSXOpeningElement")
      },
      closingElement: {
        optional: !0,
        validate: (0, De.assertNodeType)("JSXClosingElement")
      },
      children: (0, De.validateArrayOfType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")
    }, {
      selfClosing: {
        validate: (0, De.assertValueType)("boolean"),
        optional: !0
      }
    })
  });
  $e("JSXEmptyExpression", {});
  $e("JSXExpressionContainer", {
    visitor: ["expression"],
    aliases: ["Immutable"],
    fields: {
      expression: {
        validate: (0, De.assertNodeType)("Expression", "JSXEmptyExpression")
      }
    }
  });
  $e("JSXSpreadChild", {
    visitor: ["expression"],
    aliases: ["Immutable"],
    fields: {
      expression: {
        validate: (0, De.assertNodeType)("Expression")
      }
    }
  });
  $e("JSXIdentifier", {
    builder: ["name"],
    fields: {
      name: {
        validate: (0, De.assertValueType)("string")
      }
    }
  });
  $e("JSXMemberExpression", {
    visitor: ["object", "property"],
    fields: {
      object: {
        validate: (0, De.assertNodeType)("JSXMemberExpression", "JSXIdentifier")
      },
      property: {
        validate: (0, De.assertNodeType)("JSXIdentifier")
      }
    }
  });
  $e("JSXNamespacedName", {
    visitor: ["namespace", "name"],
    fields: {
      namespace: {
        validate: (0, De.assertNodeType)("JSXIdentifier")
      },
      name: {
        validate: (0, De.assertNodeType)("JSXIdentifier")
      }
    }
  });
  $e("JSXOpeningElement", {
    builder: ["name", "attributes", "selfClosing"],
    visitor: ["name", "typeParameters", "typeArguments", "attributes"],
    aliases: ["Immutable"],
    fields: Object.assign({
      name: {
        validate: (0, De.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
      },
      selfClosing: {
        default: !1
      },
      attributes: (0, De.validateArrayOfType)("JSXAttribute", "JSXSpreadAttribute"),
      typeArguments: {
        validate: (0, De.assertNodeType)("TypeParameterInstantiation"),
        optional: !0
      }
    }, {
      typeParameters: {
        validate: (0, De.assertNodeType)("TSTypeParameterInstantiation"),
        optional: !0
      }
    })
  });
  $e("JSXSpreadAttribute", {
    visitor: ["argument"],
    fields: {
      argument: {
        validate: (0, De.assertNodeType)("Expression")
      }
    }
  });
  $e("JSXText", {
    aliases: ["Immutable"],
    builder: ["value"],
    fields: {
      value: {
        validate: (0, De.assertValueType)("string")
      }
    }
  });
  $e("JSXFragment", {
    builder: ["openingFragment", "closingFragment", "children"],
    visitor: ["openingFragment", "children", "closingFragment"],
    aliases: ["Immutable", "Expression"],
    fields: {
      openingFragment: {
        validate: (0, De.assertNodeType)("JSXOpeningFragment")
      },
      closingFragment: {
        validate: (0, De.assertNodeType)("JSXClosingFragment")
      },
      children: (0, De.validateArrayOfType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")
    }
  });
  $e("JSXOpeningFragment", {
    aliases: ["Immutable"]
  });
  $e("JSXClosingFragment", {
    aliases: ["Immutable"]
  });
});

// ../node_modules/@babel/types/lib/definitions/placeholders.js
var Us = O((Lt) => {
  "use strict";
  Object.defineProperty(Lt, "__esModule", {
    value: !0
  });
  Lt.PLACEHOLDERS_FLIPPED_ALIAS = Lt.PLACEHOLDERS_ALIAS = Lt.PLACEHOLDERS = void 0;
  var ES = bt(), gS = Lt.PLACEHOLDERS = ["Identifier", "StringLiteral", "Expression", "Statement", "Declaration", "BlockStatement", "ClassBo\
dy", "Pattern"], qs = Lt.PLACEHOLDERS_ALIAS = {
    Declaration: ["Statement"],
    Pattern: ["PatternLike", "LVal"]
  };
  for (let t of gS) {
    let e = ES.ALIAS_KEYS[t];
    e != null && e.length && (qs[t] = e);
  }
  var Rs = Lt.PLACEHOLDERS_FLIPPED_ALIAS = {};
  Object.keys(qs).forEach((t) => {
    qs[t].forEach((e) => {
      hasOwnProperty.call(Rs, e) || (Rs[e] = []), Rs[e].push(t);
    });
  });
});

// ../node_modules/@babel/types/lib/definitions/misc.js
var Tl = O(() => {
  "use strict";
  var Ti = bt(), AS = Us(), IS = Or(), Ks = (0, Ti.defineAliasedType)("Miscellaneous");
  Ks("Noop", {
    visitor: []
  });
  Ks("Placeholder", {
    visitor: [],
    builder: ["expectedNode", "name"],
    fields: Object.assign({
      name: {
        validate: (0, Ti.assertNodeType)("Identifier")
      },
      expectedNode: {
        validate: (0, Ti.assertOneOf)(...AS.PLACEHOLDERS)
      }
    }, (0, IS.patternLikeCommon)())
  });
  Ks("V8IntrinsicIdentifier", {
    builder: ["name"],
    fields: {
      name: {
        validate: (0, Ti.assertValueType)("string")
      }
    }
  });
});

// ../node_modules/@babel/types/lib/definitions/experimental.js
var Sl = O(() => {
  "use strict";
  var Oe = bt();
  (0, Oe.default)("ArgumentPlaceholder", {});
  (0, Oe.default)("BindExpression", {
    visitor: ["object", "callee"],
    aliases: ["Expression"],
    fields: process.env.BABEL_TYPES_8_BREAKING ? {
      object: {
        validate: (0, Oe.assertNodeType)("Expression")
      },
      callee: {
        validate: (0, Oe.assertNodeType)("Expression")
      }
    } : {
      object: {
        validate: Object.assign(() => {
        }, {
          oneOfNodeTypes: ["Expression"]
        })
      },
      callee: {
        validate: Object.assign(() => {
        }, {
          oneOfNodeTypes: ["Expression"]
        })
      }
    }
  });
  (0, Oe.default)("Decorator", {
    visitor: ["expression"],
    fields: {
      expression: {
        validate: (0, Oe.assertNodeType)("Expression")
      }
    }
  });
  (0, Oe.default)("DoExpression", {
    visitor: ["body"],
    builder: ["body", "async"],
    aliases: ["Expression"],
    fields: {
      body: {
        validate: (0, Oe.assertNodeType)("BlockStatement")
      },
      async: {
        validate: (0, Oe.assertValueType)("boolean"),
        default: !1
      }
    }
  });
  (0, Oe.default)("ExportDefaultSpecifier", {
    visitor: ["exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      exported: {
        validate: (0, Oe.assertNodeType)("Identifier")
      }
    }
  });
  (0, Oe.default)("RecordExpression", {
    visitor: ["properties"],
    aliases: ["Expression"],
    fields: {
      properties: (0, Oe.validateArrayOfType)("ObjectProperty", "SpreadElement")
    }
  });
  (0, Oe.default)("TupleExpression", {
    fields: {
      elements: {
        validate: (0, Oe.arrayOfType)("Expression", "SpreadElement"),
        default: []
      }
    },
    visitor: ["elements"],
    aliases: ["Expression"]
  });
  (0, Oe.default)("DecimalLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, Oe.assertValueType)("string")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  (0, Oe.default)("ModuleExpression", {
    visitor: ["body"],
    fields: {
      body: {
        validate: (0, Oe.assertNodeType)("Program")
      }
    },
    aliases: ["Expression"]
  });
  (0, Oe.default)("TopicReference", {
    aliases: ["Expression"]
  });
  (0, Oe.default)("PipelineTopicExpression", {
    builder: ["expression"],
    visitor: ["expression"],
    fields: {
      expression: {
        validate: (0, Oe.assertNodeType)("Expression")
      }
    },
    aliases: ["Expression"]
  });
  (0, Oe.default)("PipelineBareFunction", {
    builder: ["callee"],
    visitor: ["callee"],
    fields: {
      callee: {
        validate: (0, Oe.assertNodeType)("Expression")
      }
    },
    aliases: ["Expression"]
  });
  (0, Oe.default)("PipelinePrimaryTopicReference", {
    aliases: ["Expression"]
  });
});

// ../node_modules/@babel/types/lib/definitions/typescript.js
var vl = O(() => {
  "use strict";
  var N = bt(), bl = Or(), vS = ir(), ie = (0, N.defineAliasedType)("TypeScript"), tt = (0, N.assertValueType)("boolean"), xl = /* @__PURE__ */ s(
  () => ({
    returnType: {
      validate: (0, N.assertNodeType)("TSTypeAnnotation", "Noop"),
      optional: !0
    },
    typeParameters: {
      validate: (0, N.assertNodeType)("TSTypeParameterDeclaration", "Noop"),
      optional: !0
    }
  }), "tSFunctionTypeAnnotationCommon");
  ie("TSParameterProperty", {
    aliases: ["LVal"],
    visitor: ["parameter"],
    fields: {
      accessibility: {
        validate: (0, N.assertOneOf)("public", "private", "protected"),
        optional: !0
      },
      readonly: {
        validate: (0, N.assertValueType)("boolean"),
        optional: !0
      },
      parameter: {
        validate: (0, N.assertNodeType)("Identifier", "AssignmentPattern")
      },
      override: {
        validate: (0, N.assertValueType)("boolean"),
        optional: !0
      },
      decorators: {
        validate: (0, N.arrayOfType)("Decorator"),
        optional: !0
      }
    }
  });
  ie("TSDeclareFunction", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "params", "returnType"],
    fields: Object.assign({}, (0, bl.functionDeclarationCommon)(), xl())
  });
  ie("TSDeclareMethod", {
    visitor: ["decorators", "key", "typeParameters", "params", "returnType"],
    fields: Object.assign({}, (0, bl.classMethodOrDeclareMethodCommon)(), xl())
  });
  ie("TSQualifiedName", {
    aliases: ["TSEntityName"],
    visitor: ["left", "right"],
    fields: {
      left: (0, N.validateType)("TSEntityName"),
      right: (0, N.validateType)("Identifier")
    }
  });
  var Si = /* @__PURE__ */ s(() => ({
    typeParameters: (0, N.validateOptionalType)("TSTypeParameterDeclaration"),
    parameters: (0, N.validateArrayOfType)("ArrayPattern", "Identifier", "ObjectPattern", "RestElement"),
    typeAnnotation: (0, N.validateOptionalType)("TSTypeAnnotation")
  }), "signatureDeclarationCommon"), Pl = {
    aliases: ["TSTypeElement"],
    visitor: ["typeParameters", "parameters", "typeAnnotation"],
    fields: Si()
  };
  ie("TSCallSignatureDeclaration", Pl);
  ie("TSConstructSignatureDeclaration", Pl);
  var El = /* @__PURE__ */ s(() => ({
    key: (0, N.validateType)("Expression"),
    computed: {
      default: !1
    },
    optional: (0, N.validateOptional)(tt)
  }), "namedTypeElementCommon");
  ie("TSPropertySignature", {
    aliases: ["TSTypeElement"],
    visitor: ["key", "typeAnnotation"],
    fields: Object.assign({}, El(), {
      readonly: (0, N.validateOptional)(tt),
      typeAnnotation: (0, N.validateOptionalType)("TSTypeAnnotation"),
      kind: {
        optional: !0,
        validate: (0, N.assertOneOf)("get", "set")
      }
    })
  });
  ie("TSMethodSignature", {
    aliases: ["TSTypeElement"],
    visitor: ["key", "typeParameters", "parameters", "typeAnnotation"],
    fields: Object.assign({}, Si(), El(), {
      kind: {
        validate: (0, N.assertOneOf)("method", "get", "set")
      }
    })
  });
  ie("TSIndexSignature", {
    aliases: ["TSTypeElement"],
    visitor: ["parameters", "typeAnnotation"],
    fields: {
      readonly: (0, N.validateOptional)(tt),
      static: (0, N.validateOptional)(tt),
      parameters: (0, N.validateArrayOfType)("Identifier"),
      typeAnnotation: (0, N.validateOptionalType)("TSTypeAnnotation")
    }
  });
  var CS = ["TSAnyKeyword", "TSBooleanKeyword", "TSBigIntKeyword", "TSIntrinsicKeyword", "TSNeverKeyword", "TSNullKeyword", "TSNumberKeyword",
  "TSObjectKeyword", "TSStringKeyword", "TSSymbolKeyword", "TSUndefinedKeyword", "TSUnknownKeyword", "TSVoidKeyword"];
  for (let t of CS)
    ie(t, {
      aliases: ["TSType", "TSBaseType"],
      visitor: [],
      fields: {}
    });
  ie("TSThisType", {
    aliases: ["TSType", "TSBaseType"],
    visitor: [],
    fields: {}
  });
  var gl = {
    aliases: ["TSType"],
    visitor: ["typeParameters", "parameters", "typeAnnotation"]
  };
  ie("TSFunctionType", Object.assign({}, gl, {
    fields: Si()
  }));
  ie("TSConstructorType", Object.assign({}, gl, {
    fields: Object.assign({}, Si(), {
      abstract: (0, N.validateOptional)(tt)
    })
  }));
  ie("TSTypeReference", {
    aliases: ["TSType"],
    visitor: ["typeName", "typeParameters"],
    fields: {
      typeName: (0, N.validateType)("TSEntityName"),
      typeParameters: (0, N.validateOptionalType)("TSTypeParameterInstantiation")
    }
  });
  ie("TSTypePredicate", {
    aliases: ["TSType"],
    visitor: ["parameterName", "typeAnnotation"],
    builder: ["parameterName", "typeAnnotation", "asserts"],
    fields: {
      parameterName: (0, N.validateType)("Identifier", "TSThisType"),
      typeAnnotation: (0, N.validateOptionalType)("TSTypeAnnotation"),
      asserts: (0, N.validateOptional)(tt)
    }
  });
  ie("TSTypeQuery", {
    aliases: ["TSType"],
    visitor: ["exprName", "typeParameters"],
    fields: {
      exprName: (0, N.validateType)("TSEntityName", "TSImportType"),
      typeParameters: (0, N.validateOptionalType)("TSTypeParameterInstantiation")
    }
  });
  ie("TSTypeLiteral", {
    aliases: ["TSType"],
    visitor: ["members"],
    fields: {
      members: (0, N.validateArrayOfType)("TSTypeElement")
    }
  });
  ie("TSArrayType", {
    aliases: ["TSType"],
    visitor: ["elementType"],
    fields: {
      elementType: (0, N.validateType)("TSType")
    }
  });
  ie("TSTupleType", {
    aliases: ["TSType"],
    visitor: ["elementTypes"],
    fields: {
      elementTypes: (0, N.validateArrayOfType)("TSType", "TSNamedTupleMember")
    }
  });
  ie("TSOptionalType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, N.validateType)("TSType")
    }
  });
  ie("TSRestType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, N.validateType)("TSType")
    }
  });
  ie("TSNamedTupleMember", {
    visitor: ["label", "elementType"],
    builder: ["label", "elementType", "optional"],
    fields: {
      label: (0, N.validateType)("Identifier"),
      optional: {
        validate: tt,
        default: !1
      },
      elementType: (0, N.validateType)("TSType")
    }
  });
  var Al = {
    aliases: ["TSType"],
    visitor: ["types"],
    fields: {
      types: (0, N.validateArrayOfType)("TSType")
    }
  };
  ie("TSUnionType", Al);
  ie("TSIntersectionType", Al);
  ie("TSConditionalType", {
    aliases: ["TSType"],
    visitor: ["checkType", "extendsType", "trueType", "falseType"],
    fields: {
      checkType: (0, N.validateType)("TSType"),
      extendsType: (0, N.validateType)("TSType"),
      trueType: (0, N.validateType)("TSType"),
      falseType: (0, N.validateType)("TSType")
    }
  });
  ie("TSInferType", {
    aliases: ["TSType"],
    visitor: ["typeParameter"],
    fields: {
      typeParameter: (0, N.validateType)("TSTypeParameter")
    }
  });
  ie("TSParenthesizedType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, N.validateType)("TSType")
    }
  });
  ie("TSTypeOperator", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      operator: (0, N.validate)((0, N.assertValueType)("string")),
      typeAnnotation: (0, N.validateType)("TSType")
    }
  });
  ie("TSIndexedAccessType", {
    aliases: ["TSType"],
    visitor: ["objectType", "indexType"],
    fields: {
      objectType: (0, N.validateType)("TSType"),
      indexType: (0, N.validateType)("TSType")
    }
  });
  ie("TSMappedType", {
    aliases: ["TSType"],
    visitor: ["typeParameter", "nameType", "typeAnnotation"],
    builder: ["typeParameter", "typeAnnotation", "nameType"],
    fields: Object.assign({}, {
      typeParameter: (0, N.validateType)("TSTypeParameter")
    }, {
      readonly: (0, N.validateOptional)((0, N.assertOneOf)(!0, !1, "+", "-")),
      optional: (0, N.validateOptional)((0, N.assertOneOf)(!0, !1, "+", "-")),
      typeAnnotation: (0, N.validateOptionalType)("TSType"),
      nameType: (0, N.validateOptionalType)("TSType")
    })
  });
  ie("TSTemplateLiteralType", {
    aliases: ["TSType", "TSBaseType"],
    visitor: ["quasis", "types"],
    fields: {
      quasis: (0, N.validateArrayOfType)("TemplateElement"),
      types: {
        validate: (0, N.chain)((0, N.assertValueType)("array"), (0, N.assertEach)((0, N.assertNodeType)("TSType")), function(t, e, r) {
          if (t.quasis.length !== r.length + 1)
            throw new TypeError(`Number of ${t.type} quasis should be exactly one more than the number of types.
Expected ${r.length + 1} quasis but got ${t.quasis.length}`);
        })
      }
    }
  });
  ie("TSLiteralType", {
    aliases: ["TSType", "TSBaseType"],
    visitor: ["literal"],
    fields: {
      literal: {
        validate: function() {
          let t = (0, N.assertNodeType)("NumericLiteral", "BigIntLiteral"), e = (0, N.assertOneOf)("-"), r = (0, N.assertNodeType)("NumericL\
iteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral");
          function i(n, a, o) {
            (0, vS.default)("UnaryExpression", o) ? (e(o, "operator", o.operator), t(o, "argument", o.argument)) : r(n, a, o);
          }
          return s(i, "validator"), i.oneOfNodeTypes = ["NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiter\
al", "UnaryExpression"], i;
        }()
      }
    }
  });
  ie("TSExpressionWithTypeArguments", {
    aliases: ["TSType"],
    visitor: ["expression", "typeParameters"],
    fields: {
      expression: (0, N.validateType)("TSEntityName"),
      typeParameters: (0, N.validateOptionalType)("TSTypeParameterInstantiation")
    }
  });
  ie("TSInterfaceDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "extends", "body"],
    fields: {
      declare: (0, N.validateOptional)(tt),
      id: (0, N.validateType)("Identifier"),
      typeParameters: (0, N.validateOptionalType)("TSTypeParameterDeclaration"),
      extends: (0, N.validateOptional)((0, N.arrayOfType)("TSExpressionWithTypeArguments")),
      body: (0, N.validateType)("TSInterfaceBody")
    }
  });
  ie("TSInterfaceBody", {
    visitor: ["body"],
    fields: {
      body: (0, N.validateArrayOfType)("TSTypeElement")
    }
  });
  ie("TSTypeAliasDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "typeAnnotation"],
    fields: {
      declare: (0, N.validateOptional)(tt),
      id: (0, N.validateType)("Identifier"),
      typeParameters: (0, N.validateOptionalType)("TSTypeParameterDeclaration"),
      typeAnnotation: (0, N.validateType)("TSType")
    }
  });
  ie("TSInstantiationExpression", {
    aliases: ["Expression"],
    visitor: ["expression", "typeParameters"],
    fields: {
      expression: (0, N.validateType)("Expression"),
      typeParameters: (0, N.validateOptionalType)("TSTypeParameterInstantiation")
    }
  });
  var Il = {
    aliases: ["Expression", "LVal", "PatternLike"],
    visitor: ["expression", "typeAnnotation"],
    fields: {
      expression: (0, N.validateType)("Expression"),
      typeAnnotation: (0, N.validateType)("TSType")
    }
  };
  ie("TSAsExpression", Il);
  ie("TSSatisfiesExpression", Il);
  ie("TSTypeAssertion", {
    aliases: ["Expression", "LVal", "PatternLike"],
    visitor: ["typeAnnotation", "expression"],
    fields: {
      typeAnnotation: (0, N.validateType)("TSType"),
      expression: (0, N.validateType)("Expression")
    }
  });
  ie("TSEnumBody", {
    visitor: ["members"],
    fields: {
      members: (0, N.validateArrayOfType)("TSEnumMember")
    }
  });
  ie("TSEnumDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "members"],
    fields: {
      declare: (0, N.validateOptional)(tt),
      const: (0, N.validateOptional)(tt),
      id: (0, N.validateType)("Identifier"),
      members: (0, N.validateArrayOfType)("TSEnumMember"),
      initializer: (0, N.validateOptionalType)("Expression"),
      body: (0, N.validateOptionalType)("TSEnumBody")
    }
  });
  ie("TSEnumMember", {
    visitor: ["id", "initializer"],
    fields: {
      id: (0, N.validateType)("Identifier", "StringLiteral"),
      initializer: (0, N.validateOptionalType)("Expression")
    }
  });
  ie("TSModuleDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "body"],
    fields: Object.assign({
      kind: {
        validate: (0, N.assertOneOf)("global", "module", "namespace")
      },
      declare: (0, N.validateOptional)(tt)
    }, {
      global: (0, N.validateOptional)(tt)
    }, {
      id: (0, N.validateType)("Identifier", "StringLiteral"),
      body: (0, N.validateType)("TSModuleBlock", "TSModuleDeclaration")
    })
  });
  ie("TSModuleBlock", {
    aliases: ["Scopable", "Block", "BlockParent", "FunctionParent"],
    visitor: ["body"],
    fields: {
      body: (0, N.validateArrayOfType)("Statement")
    }
  });
  ie("TSImportType", {
    aliases: ["TSType"],
    builder: ["argument", "qualifier", "typeParameters"],
    visitor: ["argument", "options", "qualifier", "typeParameters"],
    fields: {
      argument: (0, N.validateType)("StringLiteral"),
      qualifier: (0, N.validateOptionalType)("TSEntityName"),
      typeParameters: (0, N.validateOptionalType)("TSTypeParameterInstantiation"),
      options: {
        validate: (0, N.assertNodeType)("Expression"),
        optional: !0
      }
    }
  });
  ie("TSImportEqualsDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "moduleReference"],
    fields: Object.assign({}, {
      isExport: (0, N.validate)(tt)
    }, {
      id: (0, N.validateType)("Identifier"),
      moduleReference: (0, N.validateType)("TSEntityName", "TSExternalModuleReference"),
      importKind: {
        validate: (0, N.assertOneOf)("type", "value"),
        optional: !0
      }
    })
  });
  ie("TSExternalModuleReference", {
    visitor: ["expression"],
    fields: {
      expression: (0, N.validateType)("StringLiteral")
    }
  });
  ie("TSNonNullExpression", {
    aliases: ["Expression", "LVal", "PatternLike"],
    visitor: ["expression"],
    fields: {
      expression: (0, N.validateType)("Expression")
    }
  });
  ie("TSExportAssignment", {
    aliases: ["Statement"],
    visitor: ["expression"],
    fields: {
      expression: (0, N.validateType)("Expression")
    }
  });
  ie("TSNamespaceExportDeclaration", {
    aliases: ["Statement"],
    visitor: ["id"],
    fields: {
      id: (0, N.validateType)("Identifier")
    }
  });
  ie("TSTypeAnnotation", {
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: {
        validate: (0, N.assertNodeType)("TSType")
      }
    }
  });
  ie("TSTypeParameterInstantiation", {
    visitor: ["params"],
    fields: {
      params: (0, N.validateArrayOfType)("TSType")
    }
  });
  ie("TSTypeParameterDeclaration", {
    visitor: ["params"],
    fields: {
      params: (0, N.validateArrayOfType)("TSTypeParameter")
    }
  });
  ie("TSTypeParameter", {
    builder: ["constraint", "default", "name"],
    visitor: ["constraint", "default"],
    fields: {
      name: {
        validate: (0, N.assertValueType)("string")
      },
      in: {
        validate: (0, N.assertValueType)("boolean"),
        optional: !0
      },
      out: {
        validate: (0, N.assertValueType)("boolean"),
        optional: !0
      },
      const: {
        validate: (0, N.assertValueType)("boolean"),
        optional: !0
      },
      constraint: {
        validate: (0, N.assertNodeType)("TSType"),
        optional: !0
      },
      default: {
        validate: (0, N.assertNodeType)("TSType"),
        optional: !0
      }
    }
  });
});

// ../node_modules/@babel/types/lib/definitions/deprecated-aliases.js
var Cl = O((bi) => {
  "use strict";
  Object.defineProperty(bi, "__esModule", {
    value: !0
  });
  bi.DEPRECATED_ALIASES = void 0;
  var Vj = bi.DEPRECATED_ALIASES = {
    ModuleDeclaration: "ImportOrExportDeclaration"
  };
});

// ../node_modules/@babel/types/lib/definitions/index.js
var ot = O((He) => {
  "use strict";
  Object.defineProperty(He, "__esModule", {
    value: !0
  });
  Object.defineProperty(He, "ALIAS_KEYS", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return rt.ALIAS_KEYS;
    }, "get")
  });
  Object.defineProperty(He, "BUILDER_KEYS", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return rt.BUILDER_KEYS;
    }, "get")
  });
  Object.defineProperty(He, "DEPRECATED_ALIASES", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Vs.DEPRECATED_ALIASES;
    }, "get")
  });
  Object.defineProperty(He, "DEPRECATED_KEYS", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return rt.DEPRECATED_KEYS;
    }, "get")
  });
  Object.defineProperty(He, "FLIPPED_ALIAS_KEYS", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return rt.FLIPPED_ALIAS_KEYS;
    }, "get")
  });
  Object.defineProperty(He, "NODE_FIELDS", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return rt.NODE_FIELDS;
    }, "get")
  });
  Object.defineProperty(He, "NODE_PARENT_VALIDATIONS", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return rt.NODE_PARENT_VALIDATIONS;
    }, "get")
  });
  Object.defineProperty(He, "PLACEHOLDERS", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Ys.PLACEHOLDERS;
    }, "get")
  });
  Object.defineProperty(He, "PLACEHOLDERS_ALIAS", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Ys.PLACEHOLDERS_ALIAS;
    }, "get")
  });
  Object.defineProperty(He, "PLACEHOLDERS_FLIPPED_ALIAS", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Ys.PLACEHOLDERS_FLIPPED_ALIAS;
    }, "get")
  });
  He.TYPES = void 0;
  Object.defineProperty(He, "VISITOR_KEYS", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return rt.VISITOR_KEYS;
    }, "get")
  });
  Or();
  ml();
  yl();
  Tl();
  Sl();
  vl();
  var rt = bt(), Ys = Us(), Vs = Cl();
  Object.keys(Vs.DEPRECATED_ALIASES).forEach((t) => {
    rt.FLIPPED_ALIAS_KEYS[t] = rt.FLIPPED_ALIAS_KEYS[Vs.DEPRECATED_ALIASES[t]];
  });
  for (let {
    types: t,
    set: e
  } of rt.allExpandedTypes)
    for (let r of t) {
      let i = rt.FLIPPED_ALIAS_KEYS[r];
      i ? i.forEach(e.add, e) : e.add(r);
    }
  var Jj = He.TYPES = [].concat(Object.keys(rt.VISITOR_KEYS), Object.keys(rt.FLIPPED_ALIAS_KEYS), Object.keys(rt.DEPRECATED_KEYS));
});

// ../node_modules/@babel/types/lib/validators/validate.js
var mi = O((lr) => {
  "use strict";
  Object.defineProperty(lr, "__esModule", {
    value: !0
  });
  lr.default = wS;
  lr.validateChild = Nl;
  lr.validateField = wl;
  lr.validateInternal = NS;
  var _r = ot();
  function wS(t, e, r) {
    if (!t) return;
    let i = _r.NODE_FIELDS[t.type];
    if (!i) return;
    let n = i[e];
    wl(t, e, r, n), Nl(t, e, r);
  }
  s(wS, "validate");
  function NS(t, e, r, i, n) {
    if (t != null && t.validate && !(t.optional && i == null) && (t.validate(e, r, i), n)) {
      var a;
      let o = i.type;
      if (o == null) return;
      (a = _r.NODE_PARENT_VALIDATIONS[o]) == null || a.call(_r.NODE_PARENT_VALIDATIONS, e, r, i);
    }
  }
  s(NS, "validateInternal");
  function wl(t, e, r, i) {
    i != null && i.validate && (i.optional && r == null || i.validate(t, e, r));
  }
  s(wl, "validateField");
  function Nl(t, e, r) {
    var i;
    let n = r?.type;
    n != null && ((i = _r.NODE_PARENT_VALIDATIONS[n]) == null || i.call(_r.NODE_PARENT_VALIDATIONS, t, e, r));
  }
  s(Nl, "validateChild");
});

// ../node_modules/@babel/types/lib/builders/generated/lowercase.js
var Js = O((f) => {
  "use strict";
  Object.defineProperty(f, "__esModule", {
    value: !0
  });
  f.anyTypeAnnotation = ub;
  f.argumentPlaceholder = Fx;
  f.arrayExpression = DS;
  f.arrayPattern = C0;
  f.arrayTypeAnnotation = cb;
  f.arrowFunctionExpression = w0;
  f.assignmentExpression = kS;
  f.assignmentPattern = v0;
  f.awaitExpression = H0;
  f.bigIntLiteral = Q0;
  f.binaryExpression = LS;
  f.bindExpression = Rx;
  f.blockStatement = FS;
  f.booleanLiteral = s0;
  f.booleanLiteralTypeAnnotation = fb;
  f.booleanTypeAnnotation = pb;
  f.breakStatement = RS;
  f.callExpression = qS;
  f.catchClause = US;
  f.classAccessorProperty = ib;
  f.classBody = N0;
  f.classDeclaration = _0;
  f.classExpression = O0;
  f.classImplements = db;
  f.classMethod = V0;
  f.classPrivateMethod = nb;
  f.classPrivateProperty = sb;
  f.classProperty = rb;
  f.conditionalExpression = KS;
  f.continueStatement = VS;
  f.debuggerStatement = YS;
  f.decimalLiteral = Jx;
  f.declareClass = mb;
  f.declareExportAllDeclaration = Ab;
  f.declareExportDeclaration = gb;
  f.declareFunction = yb;
  f.declareInterface = Tb;
  f.declareModule = Sb;
  f.declareModuleExports = bb;
  f.declareOpaqueType = Pb;
  f.declareTypeAlias = xb;
  f.declareVariable = Eb;
  f.declaredPredicate = Ib;
  f.decorator = qx;
  f.directive = BS;
  f.directiveLiteral = jS;
  f.doExpression = Ux;
  f.doWhileStatement = JS;
  f.emptyStatement = XS;
  f.emptyTypeAnnotation = Bb;
  f.enumBooleanBody = cx;
  f.enumBooleanMember = dx;
  f.enumDeclaration = ux;
  f.enumDefaultedMember = Tx;
  f.enumNumberBody = px;
  f.enumNumberMember = mx;
  f.enumStringBody = fx;
  f.enumStringMember = yx;
  f.enumSymbolBody = hx;
  f.existsTypeAnnotation = vb;
  f.exportAllDeclaration = D0;
  f.exportDefaultDeclaration = k0;
  f.exportDefaultSpecifier = Kx;
  f.exportNamedDeclaration = L0;
  f.exportNamespaceSpecifier = Z0;
  f.exportSpecifier = M0;
  f.expressionStatement = WS;
  f.file = zS;
  f.forInStatement = $S;
  f.forOfStatement = B0;
  f.forStatement = HS;
  f.functionDeclaration = GS;
  f.functionExpression = QS;
  f.functionTypeAnnotation = Cb;
  f.functionTypeParam = wb;
  f.genericTypeAnnotation = Nb;
  f.identifier = ZS;
  f.ifStatement = e0;
  f.import = G0;
  f.importAttribute = lb;
  f.importDeclaration = j0;
  f.importDefaultSpecifier = F0;
  f.importExpression = U0;
  f.importNamespaceSpecifier = R0;
  f.importSpecifier = q0;
  f.indexedAccessType = Sx;
  f.inferredPredicate = Ob;
  f.interfaceDeclaration = Db;
  f.interfaceExtends = _b;
  f.interfaceTypeAnnotation = kb;
  f.interpreterDirective = MS;
  f.intersectionTypeAnnotation = Lb;
  f.jSXAttribute = f.jsxAttribute = xx;
  f.jSXClosingElement = f.jsxClosingElement = Px;
  f.jSXClosingFragment = f.jsxClosingFragment = Lx;
  f.jSXElement = f.jsxElement = Ex;
  f.jSXEmptyExpression = f.jsxEmptyExpression = gx;
  f.jSXExpressionContainer = f.jsxExpressionContainer = Ax;
  f.jSXFragment = f.jsxFragment = Dx;
  f.jSXIdentifier = f.jsxIdentifier = vx;
  f.jSXMemberExpression = f.jsxMemberExpression = Cx;
  f.jSXNamespacedName = f.jsxNamespacedName = wx;
  f.jSXOpeningElement = f.jsxOpeningElement = Nx;
  f.jSXOpeningFragment = f.jsxOpeningFragment = kx;
  f.jSXSpreadAttribute = f.jsxSpreadAttribute = Ox;
  f.jSXSpreadChild = f.jsxSpreadChild = Ix;
  f.jSXText = f.jsxText = _x;
  f.labeledStatement = t0;
  f.logicalExpression = n0;
  f.memberExpression = a0;
  f.metaProperty = K0;
  f.mixedTypeAnnotation = Mb;
  f.moduleExpression = Xx;
  f.newExpression = o0;
  f.noop = Mx;
  f.nullLiteral = i0;
  f.nullLiteralTypeAnnotation = hb;
  f.nullableTypeAnnotation = jb;
  f.numberLiteral = cE;
  f.numberLiteralTypeAnnotation = Fb;
  f.numberTypeAnnotation = Rb;
  f.numericLiteral = Ol;
  f.objectExpression = u0;
  f.objectMethod = c0;
  f.objectPattern = Y0;
  f.objectProperty = p0;
  f.objectTypeAnnotation = qb;
  f.objectTypeCallProperty = Kb;
  f.objectTypeIndexer = Vb;
  f.objectTypeInternalSlot = Ub;
  f.objectTypeProperty = Yb;
  f.objectTypeSpreadProperty = Jb;
  f.opaqueType = Xb;
  f.optionalCallExpression = tb;
  f.optionalIndexedAccessType = bx;
  f.optionalMemberExpression = eb;
  f.parenthesizedExpression = d0;
  f.pipelineBareFunction = $x;
  f.pipelinePrimaryTopicReference = Hx;
  f.pipelineTopicExpression = zx;
  f.placeholder = Bx;
  f.privateName = ab;
  f.program = l0;
  f.qualifiedTypeIdentifier = Wb;
  f.recordExpression = Vx;
  f.regExpLiteral = _l;
  f.regexLiteral = pE;
  f.restElement = Dl;
  f.restProperty = fE;
  f.returnStatement = f0;
  f.sequenceExpression = h0;
  f.spreadElement = kl;
  f.spreadProperty = hE;
  f.staticBlock = ob;
  f.stringLiteral = r0;
  f.stringLiteralTypeAnnotation = zb;
  f.stringTypeAnnotation = $b;
  f.super = J0;
  f.switchCase = m0;
  f.switchStatement = y0;
  f.symbolTypeAnnotation = Hb;
  f.taggedTemplateExpression = X0;
  f.templateElement = W0;
  f.templateLiteral = z0;
  f.thisExpression = T0;
  f.thisTypeAnnotation = Gb;
  f.throwStatement = S0;
  f.topicReference = Wx;
  f.tryStatement = b0;
  f.tSAnyKeyword = f.tsAnyKeyword = aP;
  f.tSArrayType = f.tsArrayType = vP;
  f.tSAsExpression = f.tsAsExpression = XP;
  f.tSBigIntKeyword = f.tsBigIntKeyword = lP;
  f.tSBooleanKeyword = f.tsBooleanKeyword = oP;
  f.tSCallSignatureDeclaration = f.tsCallSignatureDeclaration = tP;
  f.tSConditionalType = f.tsConditionalType = kP;
  f.tSConstructSignatureDeclaration = f.tsConstructSignatureDeclaration = rP;
  f.tSConstructorType = f.tsConstructorType = PP;
  f.tSDeclareFunction = f.tsDeclareFunction = Qx;
  f.tSDeclareMethod = f.tsDeclareMethod = Zx;
  f.tSEnumBody = f.tsEnumBody = $P;
  f.tSEnumDeclaration = f.tsEnumDeclaration = HP;
  f.tSEnumMember = f.tsEnumMember = GP;
  f.tSExportAssignment = f.tsExportAssignment = sE;
  f.tSExpressionWithTypeArguments = f.tsExpressionWithTypeArguments = UP;
  f.tSExternalModuleReference = f.tsExternalModuleReference = rE;
  f.tSFunctionType = f.tsFunctionType = xP;
  f.tSImportEqualsDeclaration = f.tsImportEqualsDeclaration = tE;
  f.tSImportType = f.tsImportType = eE;
  f.tSIndexSignature = f.tsIndexSignature = nP;
  f.tSIndexedAccessType = f.tsIndexedAccessType = jP;
  f.tSInferType = f.tsInferType = LP;
  f.tSInstantiationExpression = f.tsInstantiationExpression = JP;
  f.tSInterfaceBody = f.tsInterfaceBody = VP;
  f.tSInterfaceDeclaration = f.tsInterfaceDeclaration = KP;
  f.tSIntersectionType = f.tsIntersectionType = DP;
  f.tSIntrinsicKeyword = f.tsIntrinsicKeyword = uP;
  f.tSLiteralType = f.tsLiteralType = qP;
  f.tSMappedType = f.tsMappedType = FP;
  f.tSMethodSignature = f.tsMethodSignature = sP;
  f.tSModuleBlock = f.tsModuleBlock = ZP;
  f.tSModuleDeclaration = f.tsModuleDeclaration = QP;
  f.tSNamedTupleMember = f.tsNamedTupleMember = OP;
  f.tSNamespaceExportDeclaration = f.tsNamespaceExportDeclaration = nE;
  f.tSNeverKeyword = f.tsNeverKeyword = cP;
  f.tSNonNullExpression = f.tsNonNullExpression = iE;
  f.tSNullKeyword = f.tsNullKeyword = pP;
  f.tSNumberKeyword = f.tsNumberKeyword = fP;
  f.tSObjectKeyword = f.tsObjectKeyword = hP;
  f.tSOptionalType = f.tsOptionalType = wP;
  f.tSParameterProperty = f.tsParameterProperty = Gx;
  f.tSParenthesizedType = f.tsParenthesizedType = MP;
  f.tSPropertySignature = f.tsPropertySignature = iP;
  f.tSQualifiedName = f.tsQualifiedName = eP;
  f.tSRestType = f.tsRestType = NP;
  f.tSSatisfiesExpression = f.tsSatisfiesExpression = WP;
  f.tSStringKeyword = f.tsStringKeyword = dP;
  f.tSSymbolKeyword = f.tsSymbolKeyword = mP;
  f.tSTemplateLiteralType = f.tsTemplateLiteralType = RP;
  f.tSThisType = f.tsThisType = bP;
  f.tSTupleType = f.tsTupleType = CP;
  f.tSTypeAliasDeclaration = f.tsTypeAliasDeclaration = YP;
  f.tSTypeAnnotation = f.tsTypeAnnotation = aE;
  f.tSTypeAssertion = f.tsTypeAssertion = zP;
  f.tSTypeLiteral = f.tsTypeLiteral = IP;
  f.tSTypeOperator = f.tsTypeOperator = BP;
  f.tSTypeParameter = f.tsTypeParameter = uE;
  f.tSTypeParameterDeclaration = f.tsTypeParameterDeclaration = lE;
  f.tSTypeParameterInstantiation = f.tsTypeParameterInstantiation = oE;
  f.tSTypePredicate = f.tsTypePredicate = gP;
  f.tSTypeQuery = f.tsTypeQuery = AP;
  f.tSTypeReference = f.tsTypeReference = EP;
  f.tSUndefinedKeyword = f.tsUndefinedKeyword = yP;
  f.tSUnionType = f.tsUnionType = _P;
  f.tSUnknownKeyword = f.tsUnknownKeyword = TP;
  f.tSVoidKeyword = f.tsVoidKeyword = SP;
  f.tupleExpression = Yx;
  f.tupleTypeAnnotation = Qb;
  f.typeAlias = ex;
  f.typeAnnotation = tx;
  f.typeCastExpression = rx;
  f.typeParameter = ix;
  f.typeParameterDeclaration = sx;
  f.typeParameterInstantiation = nx;
  f.typeofTypeAnnotation = Zb;
  f.unaryExpression = x0;
  f.unionTypeAnnotation = ax;
  f.updateExpression = P0;
  f.v8IntrinsicIdentifier = jx;
  f.variableDeclaration = E0;
  f.variableDeclarator = g0;
  f.variance = ox;
  f.voidTypeAnnotation = lx;
  f.whileStatement = A0;
  f.withStatement = I0;
  f.yieldExpression = $0;
  var OS = mi(), xi = Er(), _S = bt(), {
    validateInternal: c
  } = OS, {
    NODE_FIELDS: E
  } = _S;
  function DS(t = []) {
    let e = {
      type: "ArrayExpression",
      elements: t
    }, r = E.ArrayExpression;
    return c(r.elements, e, "elements", t, 1), e;
  }
  s(DS, "arrayExpression");
  function kS(t, e, r) {
    let i = {
      type: "AssignmentExpression",
      operator: t,
      left: e,
      right: r
    }, n = E.AssignmentExpression;
    return c(n.operator, i, "operator", t), c(n.left, i, "left", e, 1), c(n.right, i, "right", r, 1), i;
  }
  s(kS, "assignmentExpression");
  function LS(t, e, r) {
    let i = {
      type: "BinaryExpression",
      operator: t,
      left: e,
      right: r
    }, n = E.BinaryExpression;
    return c(n.operator, i, "operator", t), c(n.left, i, "left", e, 1), c(n.right, i, "right", r, 1), i;
  }
  s(LS, "binaryExpression");
  function MS(t) {
    let e = {
      type: "InterpreterDirective",
      value: t
    }, r = E.InterpreterDirective;
    return c(r.value, e, "value", t), e;
  }
  s(MS, "interpreterDirective");
  function BS(t) {
    let e = {
      type: "Directive",
      value: t
    }, r = E.Directive;
    return c(r.value, e, "value", t, 1), e;
  }
  s(BS, "directive");
  function jS(t) {
    let e = {
      type: "DirectiveLiteral",
      value: t
    }, r = E.DirectiveLiteral;
    return c(r.value, e, "value", t), e;
  }
  s(jS, "directiveLiteral");
  function FS(t, e = []) {
    let r = {
      type: "BlockStatement",
      body: t,
      directives: e
    }, i = E.BlockStatement;
    return c(i.body, r, "body", t, 1), c(i.directives, r, "directives", e, 1), r;
  }
  s(FS, "blockStatement");
  function RS(t = null) {
    let e = {
      type: "BreakStatement",
      label: t
    }, r = E.BreakStatement;
    return c(r.label, e, "label", t, 1), e;
  }
  s(RS, "breakStatement");
  function qS(t, e) {
    let r = {
      type: "CallExpression",
      callee: t,
      arguments: e
    }, i = E.CallExpression;
    return c(i.callee, r, "callee", t, 1), c(i.arguments, r, "arguments", e, 1), r;
  }
  s(qS, "callExpression");
  function US(t = null, e) {
    let r = {
      type: "CatchClause",
      param: t,
      body: e
    }, i = E.CatchClause;
    return c(i.param, r, "param", t, 1), c(i.body, r, "body", e, 1), r;
  }
  s(US, "catchClause");
  function KS(t, e, r) {
    let i = {
      type: "ConditionalExpression",
      test: t,
      consequent: e,
      alternate: r
    }, n = E.ConditionalExpression;
    return c(n.test, i, "test", t, 1), c(n.consequent, i, "consequent", e, 1), c(n.alternate, i, "alternate", r, 1), i;
  }
  s(KS, "conditionalExpression");
  function VS(t = null) {
    let e = {
      type: "ContinueStatement",
      label: t
    }, r = E.ContinueStatement;
    return c(r.label, e, "label", t, 1), e;
  }
  s(VS, "continueStatement");
  function YS() {
    return {
      type: "DebuggerStatement"
    };
  }
  s(YS, "debuggerStatement");
  function JS(t, e) {
    let r = {
      type: "DoWhileStatement",
      test: t,
      body: e
    }, i = E.DoWhileStatement;
    return c(i.test, r, "test", t, 1), c(i.body, r, "body", e, 1), r;
  }
  s(JS, "doWhileStatement");
  function XS() {
    return {
      type: "EmptyStatement"
    };
  }
  s(XS, "emptyStatement");
  function WS(t) {
    let e = {
      type: "ExpressionStatement",
      expression: t
    }, r = E.ExpressionStatement;
    return c(r.expression, e, "expression", t, 1), e;
  }
  s(WS, "expressionStatement");
  function zS(t, e = null, r = null) {
    let i = {
      type: "File",
      program: t,
      comments: e,
      tokens: r
    }, n = E.File;
    return c(n.program, i, "program", t, 1), c(n.comments, i, "comments", e, 1), c(n.tokens, i, "tokens", r), i;
  }
  s(zS, "file");
  function $S(t, e, r) {
    let i = {
      type: "ForInStatement",
      left: t,
      right: e,
      body: r
    }, n = E.ForInStatement;
    return c(n.left, i, "left", t, 1), c(n.right, i, "right", e, 1), c(n.body, i, "body", r, 1), i;
  }
  s($S, "forInStatement");
  function HS(t = null, e = null, r = null, i) {
    let n = {
      type: "ForStatement",
      init: t,
      test: e,
      update: r,
      body: i
    }, a = E.ForStatement;
    return c(a.init, n, "init", t, 1), c(a.test, n, "test", e, 1), c(a.update, n, "update", r, 1), c(a.body, n, "body", i, 1), n;
  }
  s(HS, "forStatement");
  function GS(t = null, e, r, i = !1, n = !1) {
    let a = {
      type: "FunctionDeclaration",
      id: t,
      params: e,
      body: r,
      generator: i,
      async: n
    }, o = E.FunctionDeclaration;
    return c(o.id, a, "id", t, 1), c(o.params, a, "params", e, 1), c(o.body, a, "body", r, 1), c(o.generator, a, "generator", i), c(o.async,
    a, "async", n), a;
  }
  s(GS, "functionDeclaration");
  function QS(t = null, e, r, i = !1, n = !1) {
    let a = {
      type: "FunctionExpression",
      id: t,
      params: e,
      body: r,
      generator: i,
      async: n
    }, o = E.FunctionExpression;
    return c(o.id, a, "id", t, 1), c(o.params, a, "params", e, 1), c(o.body, a, "body", r, 1), c(o.generator, a, "generator", i), c(o.async,
    a, "async", n), a;
  }
  s(QS, "functionExpression");
  function ZS(t) {
    let e = {
      type: "Identifier",
      name: t
    }, r = E.Identifier;
    return c(r.name, e, "name", t), e;
  }
  s(ZS, "identifier");
  function e0(t, e, r = null) {
    let i = {
      type: "IfStatement",
      test: t,
      consequent: e,
      alternate: r
    }, n = E.IfStatement;
    return c(n.test, i, "test", t, 1), c(n.consequent, i, "consequent", e, 1), c(n.alternate, i, "alternate", r, 1), i;
  }
  s(e0, "ifStatement");
  function t0(t, e) {
    let r = {
      type: "LabeledStatement",
      label: t,
      body: e
    }, i = E.LabeledStatement;
    return c(i.label, r, "label", t, 1), c(i.body, r, "body", e, 1), r;
  }
  s(t0, "labeledStatement");
  function r0(t) {
    let e = {
      type: "StringLiteral",
      value: t
    }, r = E.StringLiteral;
    return c(r.value, e, "value", t), e;
  }
  s(r0, "stringLiteral");
  function Ol(t) {
    let e = {
      type: "NumericLiteral",
      value: t
    }, r = E.NumericLiteral;
    return c(r.value, e, "value", t), e;
  }
  s(Ol, "numericLiteral");
  function i0() {
    return {
      type: "NullLiteral"
    };
  }
  s(i0, "nullLiteral");
  function s0(t) {
    let e = {
      type: "BooleanLiteral",
      value: t
    }, r = E.BooleanLiteral;
    return c(r.value, e, "value", t), e;
  }
  s(s0, "booleanLiteral");
  function _l(t, e = "") {
    let r = {
      type: "RegExpLiteral",
      pattern: t,
      flags: e
    }, i = E.RegExpLiteral;
    return c(i.pattern, r, "pattern", t), c(i.flags, r, "flags", e), r;
  }
  s(_l, "regExpLiteral");
  function n0(t, e, r) {
    let i = {
      type: "LogicalExpression",
      operator: t,
      left: e,
      right: r
    }, n = E.LogicalExpression;
    return c(n.operator, i, "operator", t), c(n.left, i, "left", e, 1), c(n.right, i, "right", r, 1), i;
  }
  s(n0, "logicalExpression");
  function a0(t, e, r = !1, i = null) {
    let n = {
      type: "MemberExpression",
      object: t,
      property: e,
      computed: r,
      optional: i
    }, a = E.MemberExpression;
    return c(a.object, n, "object", t, 1), c(a.property, n, "property", e, 1), c(a.computed, n, "computed", r), c(a.optional, n, "optional",
    i), n;
  }
  s(a0, "memberExpression");
  function o0(t, e) {
    let r = {
      type: "NewExpression",
      callee: t,
      arguments: e
    }, i = E.NewExpression;
    return c(i.callee, r, "callee", t, 1), c(i.arguments, r, "arguments", e, 1), r;
  }
  s(o0, "newExpression");
  function l0(t, e = [], r = "script", i = null) {
    let n = {
      type: "Program",
      body: t,
      directives: e,
      sourceType: r,
      interpreter: i
    }, a = E.Program;
    return c(a.body, n, "body", t, 1), c(a.directives, n, "directives", e, 1), c(a.sourceType, n, "sourceType", r), c(a.interpreter, n, "int\
erpreter", i, 1), n;
  }
  s(l0, "program");
  function u0(t) {
    let e = {
      type: "ObjectExpression",
      properties: t
    }, r = E.ObjectExpression;
    return c(r.properties, e, "properties", t, 1), e;
  }
  s(u0, "objectExpression");
  function c0(t = "method", e, r, i, n = !1, a = !1, o = !1) {
    let l = {
      type: "ObjectMethod",
      kind: t,
      key: e,
      params: r,
      body: i,
      computed: n,
      generator: a,
      async: o
    }, u = E.ObjectMethod;
    return c(u.kind, l, "kind", t), c(u.key, l, "key", e, 1), c(u.params, l, "params", r, 1), c(u.body, l, "body", i, 1), c(u.computed, l, "\
computed", n), c(u.generator, l, "generator", a), c(u.async, l, "async", o), l;
  }
  s(c0, "objectMethod");
  function p0(t, e, r = !1, i = !1, n = null) {
    let a = {
      type: "ObjectProperty",
      key: t,
      value: e,
      computed: r,
      shorthand: i,
      decorators: n
    }, o = E.ObjectProperty;
    return c(o.key, a, "key", t, 1), c(o.value, a, "value", e, 1), c(o.computed, a, "computed", r), c(o.shorthand, a, "shorthand", i), c(o.decorators,
    a, "decorators", n, 1), a;
  }
  s(p0, "objectProperty");
  function Dl(t) {
    let e = {
      type: "RestElement",
      argument: t
    }, r = E.RestElement;
    return c(r.argument, e, "argument", t, 1), e;
  }
  s(Dl, "restElement");
  function f0(t = null) {
    let e = {
      type: "ReturnStatement",
      argument: t
    }, r = E.ReturnStatement;
    return c(r.argument, e, "argument", t, 1), e;
  }
  s(f0, "returnStatement");
  function h0(t) {
    let e = {
      type: "SequenceExpression",
      expressions: t
    }, r = E.SequenceExpression;
    return c(r.expressions, e, "expressions", t, 1), e;
  }
  s(h0, "sequenceExpression");
  function d0(t) {
    let e = {
      type: "ParenthesizedExpression",
      expression: t
    }, r = E.ParenthesizedExpression;
    return c(r.expression, e, "expression", t, 1), e;
  }
  s(d0, "parenthesizedExpression");
  function m0(t = null, e) {
    let r = {
      type: "SwitchCase",
      test: t,
      consequent: e
    }, i = E.SwitchCase;
    return c(i.test, r, "test", t, 1), c(i.consequent, r, "consequent", e, 1), r;
  }
  s(m0, "switchCase");
  function y0(t, e) {
    let r = {
      type: "SwitchStatement",
      discriminant: t,
      cases: e
    }, i = E.SwitchStatement;
    return c(i.discriminant, r, "discriminant", t, 1), c(i.cases, r, "cases", e, 1), r;
  }
  s(y0, "switchStatement");
  function T0() {
    return {
      type: "ThisExpression"
    };
  }
  s(T0, "thisExpression");
  function S0(t) {
    let e = {
      type: "ThrowStatement",
      argument: t
    }, r = E.ThrowStatement;
    return c(r.argument, e, "argument", t, 1), e;
  }
  s(S0, "throwStatement");
  function b0(t, e = null, r = null) {
    let i = {
      type: "TryStatement",
      block: t,
      handler: e,
      finalizer: r
    }, n = E.TryStatement;
    return c(n.block, i, "block", t, 1), c(n.handler, i, "handler", e, 1), c(n.finalizer, i, "finalizer", r, 1), i;
  }
  s(b0, "tryStatement");
  function x0(t, e, r = !0) {
    let i = {
      type: "UnaryExpression",
      operator: t,
      argument: e,
      prefix: r
    }, n = E.UnaryExpression;
    return c(n.operator, i, "operator", t), c(n.argument, i, "argument", e, 1), c(n.prefix, i, "prefix", r), i;
  }
  s(x0, "unaryExpression");
  function P0(t, e, r = !1) {
    let i = {
      type: "UpdateExpression",
      operator: t,
      argument: e,
      prefix: r
    }, n = E.UpdateExpression;
    return c(n.operator, i, "operator", t), c(n.argument, i, "argument", e, 1), c(n.prefix, i, "prefix", r), i;
  }
  s(P0, "updateExpression");
  function E0(t, e) {
    let r = {
      type: "VariableDeclaration",
      kind: t,
      declarations: e
    }, i = E.VariableDeclaration;
    return c(i.kind, r, "kind", t), c(i.declarations, r, "declarations", e, 1), r;
  }
  s(E0, "variableDeclaration");
  function g0(t, e = null) {
    let r = {
      type: "VariableDeclarator",
      id: t,
      init: e
    }, i = E.VariableDeclarator;
    return c(i.id, r, "id", t, 1), c(i.init, r, "init", e, 1), r;
  }
  s(g0, "variableDeclarator");
  function A0(t, e) {
    let r = {
      type: "WhileStatement",
      test: t,
      body: e
    }, i = E.WhileStatement;
    return c(i.test, r, "test", t, 1), c(i.body, r, "body", e, 1), r;
  }
  s(A0, "whileStatement");
  function I0(t, e) {
    let r = {
      type: "WithStatement",
      object: t,
      body: e
    }, i = E.WithStatement;
    return c(i.object, r, "object", t, 1), c(i.body, r, "body", e, 1), r;
  }
  s(I0, "withStatement");
  function v0(t, e) {
    let r = {
      type: "AssignmentPattern",
      left: t,
      right: e
    }, i = E.AssignmentPattern;
    return c(i.left, r, "left", t, 1), c(i.right, r, "right", e, 1), r;
  }
  s(v0, "assignmentPattern");
  function C0(t) {
    let e = {
      type: "ArrayPattern",
      elements: t
    }, r = E.ArrayPattern;
    return c(r.elements, e, "elements", t, 1), e;
  }
  s(C0, "arrayPattern");
  function w0(t, e, r = !1) {
    let i = {
      type: "ArrowFunctionExpression",
      params: t,
      body: e,
      async: r,
      expression: null
    }, n = E.ArrowFunctionExpression;
    return c(n.params, i, "params", t, 1), c(n.body, i, "body", e, 1), c(n.async, i, "async", r), i;
  }
  s(w0, "arrowFunctionExpression");
  function N0(t) {
    let e = {
      type: "ClassBody",
      body: t
    }, r = E.ClassBody;
    return c(r.body, e, "body", t, 1), e;
  }
  s(N0, "classBody");
  function O0(t = null, e = null, r, i = null) {
    let n = {
      type: "ClassExpression",
      id: t,
      superClass: e,
      body: r,
      decorators: i
    }, a = E.ClassExpression;
    return c(a.id, n, "id", t, 1), c(a.superClass, n, "superClass", e, 1), c(a.body, n, "body", r, 1), c(a.decorators, n, "decorators", i, 1),
    n;
  }
  s(O0, "classExpression");
  function _0(t = null, e = null, r, i = null) {
    let n = {
      type: "ClassDeclaration",
      id: t,
      superClass: e,
      body: r,
      decorators: i
    }, a = E.ClassDeclaration;
    return c(a.id, n, "id", t, 1), c(a.superClass, n, "superClass", e, 1), c(a.body, n, "body", r, 1), c(a.decorators, n, "decorators", i, 1),
    n;
  }
  s(_0, "classDeclaration");
  function D0(t) {
    let e = {
      type: "ExportAllDeclaration",
      source: t
    }, r = E.ExportAllDeclaration;
    return c(r.source, e, "source", t, 1), e;
  }
  s(D0, "exportAllDeclaration");
  function k0(t) {
    let e = {
      type: "ExportDefaultDeclaration",
      declaration: t
    }, r = E.ExportDefaultDeclaration;
    return c(r.declaration, e, "declaration", t, 1), e;
  }
  s(k0, "exportDefaultDeclaration");
  function L0(t = null, e = [], r = null) {
    let i = {
      type: "ExportNamedDeclaration",
      declaration: t,
      specifiers: e,
      source: r
    }, n = E.ExportNamedDeclaration;
    return c(n.declaration, i, "declaration", t, 1), c(n.specifiers, i, "specifiers", e, 1), c(n.source, i, "source", r, 1), i;
  }
  s(L0, "exportNamedDeclaration");
  function M0(t, e) {
    let r = {
      type: "ExportSpecifier",
      local: t,
      exported: e
    }, i = E.ExportSpecifier;
    return c(i.local, r, "local", t, 1), c(i.exported, r, "exported", e, 1), r;
  }
  s(M0, "exportSpecifier");
  function B0(t, e, r, i = !1) {
    let n = {
      type: "ForOfStatement",
      left: t,
      right: e,
      body: r,
      await: i
    }, a = E.ForOfStatement;
    return c(a.left, n, "left", t, 1), c(a.right, n, "right", e, 1), c(a.body, n, "body", r, 1), c(a.await, n, "await", i), n;
  }
  s(B0, "forOfStatement");
  function j0(t, e) {
    let r = {
      type: "ImportDeclaration",
      specifiers: t,
      source: e
    }, i = E.ImportDeclaration;
    return c(i.specifiers, r, "specifiers", t, 1), c(i.source, r, "source", e, 1), r;
  }
  s(j0, "importDeclaration");
  function F0(t) {
    let e = {
      type: "ImportDefaultSpecifier",
      local: t
    }, r = E.ImportDefaultSpecifier;
    return c(r.local, e, "local", t, 1), e;
  }
  s(F0, "importDefaultSpecifier");
  function R0(t) {
    let e = {
      type: "ImportNamespaceSpecifier",
      local: t
    }, r = E.ImportNamespaceSpecifier;
    return c(r.local, e, "local", t, 1), e;
  }
  s(R0, "importNamespaceSpecifier");
  function q0(t, e) {
    let r = {
      type: "ImportSpecifier",
      local: t,
      imported: e
    }, i = E.ImportSpecifier;
    return c(i.local, r, "local", t, 1), c(i.imported, r, "imported", e, 1), r;
  }
  s(q0, "importSpecifier");
  function U0(t, e = null) {
    let r = {
      type: "ImportExpression",
      source: t,
      options: e
    }, i = E.ImportExpression;
    return c(i.source, r, "source", t, 1), c(i.options, r, "options", e, 1), r;
  }
  s(U0, "importExpression");
  function K0(t, e) {
    let r = {
      type: "MetaProperty",
      meta: t,
      property: e
    }, i = E.MetaProperty;
    return c(i.meta, r, "meta", t, 1), c(i.property, r, "property", e, 1), r;
  }
  s(K0, "metaProperty");
  function V0(t = "method", e, r, i, n = !1, a = !1, o = !1, l = !1) {
    let u = {
      type: "ClassMethod",
      kind: t,
      key: e,
      params: r,
      body: i,
      computed: n,
      static: a,
      generator: o,
      async: l
    }, p = E.ClassMethod;
    return c(p.kind, u, "kind", t), c(p.key, u, "key", e, 1), c(p.params, u, "params", r, 1), c(p.body, u, "body", i, 1), c(p.computed, u, "\
computed", n), c(p.static, u, "static", a), c(p.generator, u, "generator", o), c(p.async, u, "async", l), u;
  }
  s(V0, "classMethod");
  function Y0(t) {
    let e = {
      type: "ObjectPattern",
      properties: t
    }, r = E.ObjectPattern;
    return c(r.properties, e, "properties", t, 1), e;
  }
  s(Y0, "objectPattern");
  function kl(t) {
    let e = {
      type: "SpreadElement",
      argument: t
    }, r = E.SpreadElement;
    return c(r.argument, e, "argument", t, 1), e;
  }
  s(kl, "spreadElement");
  function J0() {
    return {
      type: "Super"
    };
  }
  s(J0, "_super");
  function X0(t, e) {
    let r = {
      type: "TaggedTemplateExpression",
      tag: t,
      quasi: e
    }, i = E.TaggedTemplateExpression;
    return c(i.tag, r, "tag", t, 1), c(i.quasi, r, "quasi", e, 1), r;
  }
  s(X0, "taggedTemplateExpression");
  function W0(t, e = !1) {
    let r = {
      type: "TemplateElement",
      value: t,
      tail: e
    }, i = E.TemplateElement;
    return c(i.value, r, "value", t), c(i.tail, r, "tail", e), r;
  }
  s(W0, "templateElement");
  function z0(t, e) {
    let r = {
      type: "TemplateLiteral",
      quasis: t,
      expressions: e
    }, i = E.TemplateLiteral;
    return c(i.quasis, r, "quasis", t, 1), c(i.expressions, r, "expressions", e, 1), r;
  }
  s(z0, "templateLiteral");
  function $0(t = null, e = !1) {
    let r = {
      type: "YieldExpression",
      argument: t,
      delegate: e
    }, i = E.YieldExpression;
    return c(i.argument, r, "argument", t, 1), c(i.delegate, r, "delegate", e), r;
  }
  s($0, "yieldExpression");
  function H0(t) {
    let e = {
      type: "AwaitExpression",
      argument: t
    }, r = E.AwaitExpression;
    return c(r.argument, e, "argument", t, 1), e;
  }
  s(H0, "awaitExpression");
  function G0() {
    return {
      type: "Import"
    };
  }
  s(G0, "_import");
  function Q0(t) {
    let e = {
      type: "BigIntLiteral",
      value: t
    }, r = E.BigIntLiteral;
    return c(r.value, e, "value", t), e;
  }
  s(Q0, "bigIntLiteral");
  function Z0(t) {
    let e = {
      type: "ExportNamespaceSpecifier",
      exported: t
    }, r = E.ExportNamespaceSpecifier;
    return c(r.exported, e, "exported", t, 1), e;
  }
  s(Z0, "exportNamespaceSpecifier");
  function eb(t, e, r = !1, i) {
    let n = {
      type: "OptionalMemberExpression",
      object: t,
      property: e,
      computed: r,
      optional: i
    }, a = E.OptionalMemberExpression;
    return c(a.object, n, "object", t, 1), c(a.property, n, "property", e, 1), c(a.computed, n, "computed", r), c(a.optional, n, "optional",
    i), n;
  }
  s(eb, "optionalMemberExpression");
  function tb(t, e, r) {
    let i = {
      type: "OptionalCallExpression",
      callee: t,
      arguments: e,
      optional: r
    }, n = E.OptionalCallExpression;
    return c(n.callee, i, "callee", t, 1), c(n.arguments, i, "arguments", e, 1), c(n.optional, i, "optional", r), i;
  }
  s(tb, "optionalCallExpression");
  function rb(t, e = null, r = null, i = null, n = !1, a = !1) {
    let o = {
      type: "ClassProperty",
      key: t,
      value: e,
      typeAnnotation: r,
      decorators: i,
      computed: n,
      static: a
    }, l = E.ClassProperty;
    return c(l.key, o, "key", t, 1), c(l.value, o, "value", e, 1), c(l.typeAnnotation, o, "typeAnnotation", r, 1), c(l.decorators, o, "decor\
ators", i, 1), c(l.computed, o, "computed", n), c(l.static, o, "static", a), o;
  }
  s(rb, "classProperty");
  function ib(t, e = null, r = null, i = null, n = !1, a = !1) {
    let o = {
      type: "ClassAccessorProperty",
      key: t,
      value: e,
      typeAnnotation: r,
      decorators: i,
      computed: n,
      static: a
    }, l = E.ClassAccessorProperty;
    return c(l.key, o, "key", t, 1), c(l.value, o, "value", e, 1), c(l.typeAnnotation, o, "typeAnnotation", r, 1), c(l.decorators, o, "decor\
ators", i, 1), c(l.computed, o, "computed", n), c(l.static, o, "static", a), o;
  }
  s(ib, "classAccessorProperty");
  function sb(t, e = null, r = null, i = !1) {
    let n = {
      type: "ClassPrivateProperty",
      key: t,
      value: e,
      decorators: r,
      static: i
    }, a = E.ClassPrivateProperty;
    return c(a.key, n, "key", t, 1), c(a.value, n, "value", e, 1), c(a.decorators, n, "decorators", r, 1), c(a.static, n, "static", i), n;
  }
  s(sb, "classPrivateProperty");
  function nb(t = "method", e, r, i, n = !1) {
    let a = {
      type: "ClassPrivateMethod",
      kind: t,
      key: e,
      params: r,
      body: i,
      static: n
    }, o = E.ClassPrivateMethod;
    return c(o.kind, a, "kind", t), c(o.key, a, "key", e, 1), c(o.params, a, "params", r, 1), c(o.body, a, "body", i, 1), c(o.static, a, "st\
atic", n), a;
  }
  s(nb, "classPrivateMethod");
  function ab(t) {
    let e = {
      type: "PrivateName",
      id: t
    }, r = E.PrivateName;
    return c(r.id, e, "id", t, 1), e;
  }
  s(ab, "privateName");
  function ob(t) {
    let e = {
      type: "StaticBlock",
      body: t
    }, r = E.StaticBlock;
    return c(r.body, e, "body", t, 1), e;
  }
  s(ob, "staticBlock");
  function lb(t, e) {
    let r = {
      type: "ImportAttribute",
      key: t,
      value: e
    }, i = E.ImportAttribute;
    return c(i.key, r, "key", t, 1), c(i.value, r, "value", e, 1), r;
  }
  s(lb, "importAttribute");
  function ub() {
    return {
      type: "AnyTypeAnnotation"
    };
  }
  s(ub, "anyTypeAnnotation");
  function cb(t) {
    let e = {
      type: "ArrayTypeAnnotation",
      elementType: t
    }, r = E.ArrayTypeAnnotation;
    return c(r.elementType, e, "elementType", t, 1), e;
  }
  s(cb, "arrayTypeAnnotation");
  function pb() {
    return {
      type: "BooleanTypeAnnotation"
    };
  }
  s(pb, "booleanTypeAnnotation");
  function fb(t) {
    let e = {
      type: "BooleanLiteralTypeAnnotation",
      value: t
    }, r = E.BooleanLiteralTypeAnnotation;
    return c(r.value, e, "value", t), e;
  }
  s(fb, "booleanLiteralTypeAnnotation");
  function hb() {
    return {
      type: "NullLiteralTypeAnnotation"
    };
  }
  s(hb, "nullLiteralTypeAnnotation");
  function db(t, e = null) {
    let r = {
      type: "ClassImplements",
      id: t,
      typeParameters: e
    }, i = E.ClassImplements;
    return c(i.id, r, "id", t, 1), c(i.typeParameters, r, "typeParameters", e, 1), r;
  }
  s(db, "classImplements");
  function mb(t, e = null, r = null, i) {
    let n = {
      type: "DeclareClass",
      id: t,
      typeParameters: e,
      extends: r,
      body: i
    }, a = E.DeclareClass;
    return c(a.id, n, "id", t, 1), c(a.typeParameters, n, "typeParameters", e, 1), c(a.extends, n, "extends", r, 1), c(a.body, n, "body", i,
    1), n;
  }
  s(mb, "declareClass");
  function yb(t) {
    let e = {
      type: "DeclareFunction",
      id: t
    }, r = E.DeclareFunction;
    return c(r.id, e, "id", t, 1), e;
  }
  s(yb, "declareFunction");
  function Tb(t, e = null, r = null, i) {
    let n = {
      type: "DeclareInterface",
      id: t,
      typeParameters: e,
      extends: r,
      body: i
    }, a = E.DeclareInterface;
    return c(a.id, n, "id", t, 1), c(a.typeParameters, n, "typeParameters", e, 1), c(a.extends, n, "extends", r, 1), c(a.body, n, "body", i,
    1), n;
  }
  s(Tb, "declareInterface");
  function Sb(t, e, r = null) {
    let i = {
      type: "DeclareModule",
      id: t,
      body: e,
      kind: r
    }, n = E.DeclareModule;
    return c(n.id, i, "id", t, 1), c(n.body, i, "body", e, 1), c(n.kind, i, "kind", r), i;
  }
  s(Sb, "declareModule");
  function bb(t) {
    let e = {
      type: "DeclareModuleExports",
      typeAnnotation: t
    }, r = E.DeclareModuleExports;
    return c(r.typeAnnotation, e, "typeAnnotation", t, 1), e;
  }
  s(bb, "declareModuleExports");
  function xb(t, e = null, r) {
    let i = {
      type: "DeclareTypeAlias",
      id: t,
      typeParameters: e,
      right: r
    }, n = E.DeclareTypeAlias;
    return c(n.id, i, "id", t, 1), c(n.typeParameters, i, "typeParameters", e, 1), c(n.right, i, "right", r, 1), i;
  }
  s(xb, "declareTypeAlias");
  function Pb(t, e = null, r = null) {
    let i = {
      type: "DeclareOpaqueType",
      id: t,
      typeParameters: e,
      supertype: r
    }, n = E.DeclareOpaqueType;
    return c(n.id, i, "id", t, 1), c(n.typeParameters, i, "typeParameters", e, 1), c(n.supertype, i, "supertype", r, 1), i;
  }
  s(Pb, "declareOpaqueType");
  function Eb(t) {
    let e = {
      type: "DeclareVariable",
      id: t
    }, r = E.DeclareVariable;
    return c(r.id, e, "id", t, 1), e;
  }
  s(Eb, "declareVariable");
  function gb(t = null, e = null, r = null, i = null) {
    let n = {
      type: "DeclareExportDeclaration",
      declaration: t,
      specifiers: e,
      source: r,
      attributes: i
    }, a = E.DeclareExportDeclaration;
    return c(a.declaration, n, "declaration", t, 1), c(a.specifiers, n, "specifiers", e, 1), c(a.source, n, "source", r, 1), c(a.attributes,
    n, "attributes", i, 1), n;
  }
  s(gb, "declareExportDeclaration");
  function Ab(t, e = null) {
    let r = {
      type: "DeclareExportAllDeclaration",
      source: t,
      attributes: e
    }, i = E.DeclareExportAllDeclaration;
    return c(i.source, r, "source", t, 1), c(i.attributes, r, "attributes", e, 1), r;
  }
  s(Ab, "declareExportAllDeclaration");
  function Ib(t) {
    let e = {
      type: "DeclaredPredicate",
      value: t
    }, r = E.DeclaredPredicate;
    return c(r.value, e, "value", t, 1), e;
  }
  s(Ib, "declaredPredicate");
  function vb() {
    return {
      type: "ExistsTypeAnnotation"
    };
  }
  s(vb, "existsTypeAnnotation");
  function Cb(t = null, e, r = null, i) {
    let n = {
      type: "FunctionTypeAnnotation",
      typeParameters: t,
      params: e,
      rest: r,
      returnType: i
    }, a = E.FunctionTypeAnnotation;
    return c(a.typeParameters, n, "typeParameters", t, 1), c(a.params, n, "params", e, 1), c(a.rest, n, "rest", r, 1), c(a.returnType, n, "r\
eturnType", i, 1), n;
  }
  s(Cb, "functionTypeAnnotation");
  function wb(t = null, e) {
    let r = {
      type: "FunctionTypeParam",
      name: t,
      typeAnnotation: e
    }, i = E.FunctionTypeParam;
    return c(i.name, r, "name", t, 1), c(i.typeAnnotation, r, "typeAnnotation", e, 1), r;
  }
  s(wb, "functionTypeParam");
  function Nb(t, e = null) {
    let r = {
      type: "GenericTypeAnnotation",
      id: t,
      typeParameters: e
    }, i = E.GenericTypeAnnotation;
    return c(i.id, r, "id", t, 1), c(i.typeParameters, r, "typeParameters", e, 1), r;
  }
  s(Nb, "genericTypeAnnotation");
  function Ob() {
    return {
      type: "InferredPredicate"
    };
  }
  s(Ob, "inferredPredicate");
  function _b(t, e = null) {
    let r = {
      type: "InterfaceExtends",
      id: t,
      typeParameters: e
    }, i = E.InterfaceExtends;
    return c(i.id, r, "id", t, 1), c(i.typeParameters, r, "typeParameters", e, 1), r;
  }
  s(_b, "interfaceExtends");
  function Db(t, e = null, r = null, i) {
    let n = {
      type: "InterfaceDeclaration",
      id: t,
      typeParameters: e,
      extends: r,
      body: i
    }, a = E.InterfaceDeclaration;
    return c(a.id, n, "id", t, 1), c(a.typeParameters, n, "typeParameters", e, 1), c(a.extends, n, "extends", r, 1), c(a.body, n, "body", i,
    1), n;
  }
  s(Db, "interfaceDeclaration");
  function kb(t = null, e) {
    let r = {
      type: "InterfaceTypeAnnotation",
      extends: t,
      body: e
    }, i = E.InterfaceTypeAnnotation;
    return c(i.extends, r, "extends", t, 1), c(i.body, r, "body", e, 1), r;
  }
  s(kb, "interfaceTypeAnnotation");
  function Lb(t) {
    let e = {
      type: "IntersectionTypeAnnotation",
      types: t
    }, r = E.IntersectionTypeAnnotation;
    return c(r.types, e, "types", t, 1), e;
  }
  s(Lb, "intersectionTypeAnnotation");
  function Mb() {
    return {
      type: "MixedTypeAnnotation"
    };
  }
  s(Mb, "mixedTypeAnnotation");
  function Bb() {
    return {
      type: "EmptyTypeAnnotation"
    };
  }
  s(Bb, "emptyTypeAnnotation");
  function jb(t) {
    let e = {
      type: "NullableTypeAnnotation",
      typeAnnotation: t
    }, r = E.NullableTypeAnnotation;
    return c(r.typeAnnotation, e, "typeAnnotation", t, 1), e;
  }
  s(jb, "nullableTypeAnnotation");
  function Fb(t) {
    let e = {
      type: "NumberLiteralTypeAnnotation",
      value: t
    }, r = E.NumberLiteralTypeAnnotation;
    return c(r.value, e, "value", t), e;
  }
  s(Fb, "numberLiteralTypeAnnotation");
  function Rb() {
    return {
      type: "NumberTypeAnnotation"
    };
  }
  s(Rb, "numberTypeAnnotation");
  function qb(t, e = [], r = [], i = [], n = !1) {
    let a = {
      type: "ObjectTypeAnnotation",
      properties: t,
      indexers: e,
      callProperties: r,
      internalSlots: i,
      exact: n
    }, o = E.ObjectTypeAnnotation;
    return c(o.properties, a, "properties", t, 1), c(o.indexers, a, "indexers", e, 1), c(o.callProperties, a, "callProperties", r, 1), c(o.internalSlots,
    a, "internalSlots", i, 1), c(o.exact, a, "exact", n), a;
  }
  s(qb, "objectTypeAnnotation");
  function Ub(t, e, r, i, n) {
    let a = {
      type: "ObjectTypeInternalSlot",
      id: t,
      value: e,
      optional: r,
      static: i,
      method: n
    }, o = E.ObjectTypeInternalSlot;
    return c(o.id, a, "id", t, 1), c(o.value, a, "value", e, 1), c(o.optional, a, "optional", r), c(o.static, a, "static", i), c(o.method, a,
    "method", n), a;
  }
  s(Ub, "objectTypeInternalSlot");
  function Kb(t) {
    let e = {
      type: "ObjectTypeCallProperty",
      value: t,
      static: null
    }, r = E.ObjectTypeCallProperty;
    return c(r.value, e, "value", t, 1), e;
  }
  s(Kb, "objectTypeCallProperty");
  function Vb(t = null, e, r, i = null) {
    let n = {
      type: "ObjectTypeIndexer",
      id: t,
      key: e,
      value: r,
      variance: i,
      static: null
    }, a = E.ObjectTypeIndexer;
    return c(a.id, n, "id", t, 1), c(a.key, n, "key", e, 1), c(a.value, n, "value", r, 1), c(a.variance, n, "variance", i, 1), n;
  }
  s(Vb, "objectTypeIndexer");
  function Yb(t, e, r = null) {
    let i = {
      type: "ObjectTypeProperty",
      key: t,
      value: e,
      variance: r,
      kind: null,
      method: null,
      optional: null,
      proto: null,
      static: null
    }, n = E.ObjectTypeProperty;
    return c(n.key, i, "key", t, 1), c(n.value, i, "value", e, 1), c(n.variance, i, "variance", r, 1), i;
  }
  s(Yb, "objectTypeProperty");
  function Jb(t) {
    let e = {
      type: "ObjectTypeSpreadProperty",
      argument: t
    }, r = E.ObjectTypeSpreadProperty;
    return c(r.argument, e, "argument", t, 1), e;
  }
  s(Jb, "objectTypeSpreadProperty");
  function Xb(t, e = null, r = null, i) {
    let n = {
      type: "OpaqueType",
      id: t,
      typeParameters: e,
      supertype: r,
      impltype: i
    }, a = E.OpaqueType;
    return c(a.id, n, "id", t, 1), c(a.typeParameters, n, "typeParameters", e, 1), c(a.supertype, n, "supertype", r, 1), c(a.impltype, n, "i\
mpltype", i, 1), n;
  }
  s(Xb, "opaqueType");
  function Wb(t, e) {
    let r = {
      type: "QualifiedTypeIdentifier",
      id: t,
      qualification: e
    }, i = E.QualifiedTypeIdentifier;
    return c(i.id, r, "id", t, 1), c(i.qualification, r, "qualification", e, 1), r;
  }
  s(Wb, "qualifiedTypeIdentifier");
  function zb(t) {
    let e = {
      type: "StringLiteralTypeAnnotation",
      value: t
    }, r = E.StringLiteralTypeAnnotation;
    return c(r.value, e, "value", t), e;
  }
  s(zb, "stringLiteralTypeAnnotation");
  function $b() {
    return {
      type: "StringTypeAnnotation"
    };
  }
  s($b, "stringTypeAnnotation");
  function Hb() {
    return {
      type: "SymbolTypeAnnotation"
    };
  }
  s(Hb, "symbolTypeAnnotation");
  function Gb() {
    return {
      type: "ThisTypeAnnotation"
    };
  }
  s(Gb, "thisTypeAnnotation");
  function Qb(t) {
    let e = {
      type: "TupleTypeAnnotation",
      types: t
    }, r = E.TupleTypeAnnotation;
    return c(r.types, e, "types", t, 1), e;
  }
  s(Qb, "tupleTypeAnnotation");
  function Zb(t) {
    let e = {
      type: "TypeofTypeAnnotation",
      argument: t
    }, r = E.TypeofTypeAnnotation;
    return c(r.argument, e, "argument", t, 1), e;
  }
  s(Zb, "typeofTypeAnnotation");
  function ex(t, e = null, r) {
    let i = {
      type: "TypeAlias",
      id: t,
      typeParameters: e,
      right: r
    }, n = E.TypeAlias;
    return c(n.id, i, "id", t, 1), c(n.typeParameters, i, "typeParameters", e, 1), c(n.right, i, "right", r, 1), i;
  }
  s(ex, "typeAlias");
  function tx(t) {
    let e = {
      type: "TypeAnnotation",
      typeAnnotation: t
    }, r = E.TypeAnnotation;
    return c(r.typeAnnotation, e, "typeAnnotation", t, 1), e;
  }
  s(tx, "typeAnnotation");
  function rx(t, e) {
    let r = {
      type: "TypeCastExpression",
      expression: t,
      typeAnnotation: e
    }, i = E.TypeCastExpression;
    return c(i.expression, r, "expression", t, 1), c(i.typeAnnotation, r, "typeAnnotation", e, 1), r;
  }
  s(rx, "typeCastExpression");
  function ix(t = null, e = null, r = null) {
    let i = {
      type: "TypeParameter",
      bound: t,
      default: e,
      variance: r,
      name: null
    }, n = E.TypeParameter;
    return c(n.bound, i, "bound", t, 1), c(n.default, i, "default", e, 1), c(n.variance, i, "variance", r, 1), i;
  }
  s(ix, "typeParameter");
  function sx(t) {
    let e = {
      type: "TypeParameterDeclaration",
      params: t
    }, r = E.TypeParameterDeclaration;
    return c(r.params, e, "params", t, 1), e;
  }
  s(sx, "typeParameterDeclaration");
  function nx(t) {
    let e = {
      type: "TypeParameterInstantiation",
      params: t
    }, r = E.TypeParameterInstantiation;
    return c(r.params, e, "params", t, 1), e;
  }
  s(nx, "typeParameterInstantiation");
  function ax(t) {
    let e = {
      type: "UnionTypeAnnotation",
      types: t
    }, r = E.UnionTypeAnnotation;
    return c(r.types, e, "types", t, 1), e;
  }
  s(ax, "unionTypeAnnotation");
  function ox(t) {
    let e = {
      type: "Variance",
      kind: t
    }, r = E.Variance;
    return c(r.kind, e, "kind", t), e;
  }
  s(ox, "variance");
  function lx() {
    return {
      type: "VoidTypeAnnotation"
    };
  }
  s(lx, "voidTypeAnnotation");
  function ux(t, e) {
    let r = {
      type: "EnumDeclaration",
      id: t,
      body: e
    }, i = E.EnumDeclaration;
    return c(i.id, r, "id", t, 1), c(i.body, r, "body", e, 1), r;
  }
  s(ux, "enumDeclaration");
  function cx(t) {
    let e = {
      type: "EnumBooleanBody",
      members: t,
      explicitType: null,
      hasUnknownMembers: null
    }, r = E.EnumBooleanBody;
    return c(r.members, e, "members", t, 1), e;
  }
  s(cx, "enumBooleanBody");
  function px(t) {
    let e = {
      type: "EnumNumberBody",
      members: t,
      explicitType: null,
      hasUnknownMembers: null
    }, r = E.EnumNumberBody;
    return c(r.members, e, "members", t, 1), e;
  }
  s(px, "enumNumberBody");
  function fx(t) {
    let e = {
      type: "EnumStringBody",
      members: t,
      explicitType: null,
      hasUnknownMembers: null
    }, r = E.EnumStringBody;
    return c(r.members, e, "members", t, 1), e;
  }
  s(fx, "enumStringBody");
  function hx(t) {
    let e = {
      type: "EnumSymbolBody",
      members: t,
      hasUnknownMembers: null
    }, r = E.EnumSymbolBody;
    return c(r.members, e, "members", t, 1), e;
  }
  s(hx, "enumSymbolBody");
  function dx(t) {
    let e = {
      type: "EnumBooleanMember",
      id: t,
      init: null
    }, r = E.EnumBooleanMember;
    return c(r.id, e, "id", t, 1), e;
  }
  s(dx, "enumBooleanMember");
  function mx(t, e) {
    let r = {
      type: "EnumNumberMember",
      id: t,
      init: e
    }, i = E.EnumNumberMember;
    return c(i.id, r, "id", t, 1), c(i.init, r, "init", e, 1), r;
  }
  s(mx, "enumNumberMember");
  function yx(t, e) {
    let r = {
      type: "EnumStringMember",
      id: t,
      init: e
    }, i = E.EnumStringMember;
    return c(i.id, r, "id", t, 1), c(i.init, r, "init", e, 1), r;
  }
  s(yx, "enumStringMember");
  function Tx(t) {
    let e = {
      type: "EnumDefaultedMember",
      id: t
    }, r = E.EnumDefaultedMember;
    return c(r.id, e, "id", t, 1), e;
  }
  s(Tx, "enumDefaultedMember");
  function Sx(t, e) {
    let r = {
      type: "IndexedAccessType",
      objectType: t,
      indexType: e
    }, i = E.IndexedAccessType;
    return c(i.objectType, r, "objectType", t, 1), c(i.indexType, r, "indexType", e, 1), r;
  }
  s(Sx, "indexedAccessType");
  function bx(t, e) {
    let r = {
      type: "OptionalIndexedAccessType",
      objectType: t,
      indexType: e,
      optional: null
    }, i = E.OptionalIndexedAccessType;
    return c(i.objectType, r, "objectType", t, 1), c(i.indexType, r, "indexType", e, 1), r;
  }
  s(bx, "optionalIndexedAccessType");
  function xx(t, e = null) {
    let r = {
      type: "JSXAttribute",
      name: t,
      value: e
    }, i = E.JSXAttribute;
    return c(i.name, r, "name", t, 1), c(i.value, r, "value", e, 1), r;
  }
  s(xx, "jsxAttribute");
  function Px(t) {
    let e = {
      type: "JSXClosingElement",
      name: t
    }, r = E.JSXClosingElement;
    return c(r.name, e, "name", t, 1), e;
  }
  s(Px, "jsxClosingElement");
  function Ex(t, e = null, r, i = null) {
    let n = {
      type: "JSXElement",
      openingElement: t,
      closingElement: e,
      children: r,
      selfClosing: i
    }, a = E.JSXElement;
    return c(a.openingElement, n, "openingElement", t, 1), c(a.closingElement, n, "closingElement", e, 1), c(a.children, n, "children", r, 1),
    c(a.selfClosing, n, "selfClosing", i), n;
  }
  s(Ex, "jsxElement");
  function gx() {
    return {
      type: "JSXEmptyExpression"
    };
  }
  s(gx, "jsxEmptyExpression");
  function Ax(t) {
    let e = {
      type: "JSXExpressionContainer",
      expression: t
    }, r = E.JSXExpressionContainer;
    return c(r.expression, e, "expression", t, 1), e;
  }
  s(Ax, "jsxExpressionContainer");
  function Ix(t) {
    let e = {
      type: "JSXSpreadChild",
      expression: t
    }, r = E.JSXSpreadChild;
    return c(r.expression, e, "expression", t, 1), e;
  }
  s(Ix, "jsxSpreadChild");
  function vx(t) {
    let e = {
      type: "JSXIdentifier",
      name: t
    }, r = E.JSXIdentifier;
    return c(r.name, e, "name", t), e;
  }
  s(vx, "jsxIdentifier");
  function Cx(t, e) {
    let r = {
      type: "JSXMemberExpression",
      object: t,
      property: e
    }, i = E.JSXMemberExpression;
    return c(i.object, r, "object", t, 1), c(i.property, r, "property", e, 1), r;
  }
  s(Cx, "jsxMemberExpression");
  function wx(t, e) {
    let r = {
      type: "JSXNamespacedName",
      namespace: t,
      name: e
    }, i = E.JSXNamespacedName;
    return c(i.namespace, r, "namespace", t, 1), c(i.name, r, "name", e, 1), r;
  }
  s(wx, "jsxNamespacedName");
  function Nx(t, e, r = !1) {
    let i = {
      type: "JSXOpeningElement",
      name: t,
      attributes: e,
      selfClosing: r
    }, n = E.JSXOpeningElement;
    return c(n.name, i, "name", t, 1), c(n.attributes, i, "attributes", e, 1), c(n.selfClosing, i, "selfClosing", r), i;
  }
  s(Nx, "jsxOpeningElement");
  function Ox(t) {
    let e = {
      type: "JSXSpreadAttribute",
      argument: t
    }, r = E.JSXSpreadAttribute;
    return c(r.argument, e, "argument", t, 1), e;
  }
  s(Ox, "jsxSpreadAttribute");
  function _x(t) {
    let e = {
      type: "JSXText",
      value: t
    }, r = E.JSXText;
    return c(r.value, e, "value", t), e;
  }
  s(_x, "jsxText");
  function Dx(t, e, r) {
    let i = {
      type: "JSXFragment",
      openingFragment: t,
      closingFragment: e,
      children: r
    }, n = E.JSXFragment;
    return c(n.openingFragment, i, "openingFragment", t, 1), c(n.closingFragment, i, "closingFragment", e, 1), c(n.children, i, "children", r,
    1), i;
  }
  s(Dx, "jsxFragment");
  function kx() {
    return {
      type: "JSXOpeningFragment"
    };
  }
  s(kx, "jsxOpeningFragment");
  function Lx() {
    return {
      type: "JSXClosingFragment"
    };
  }
  s(Lx, "jsxClosingFragment");
  function Mx() {
    return {
      type: "Noop"
    };
  }
  s(Mx, "noop");
  function Bx(t, e) {
    let r = {
      type: "Placeholder",
      expectedNode: t,
      name: e
    }, i = E.Placeholder;
    return c(i.expectedNode, r, "expectedNode", t), c(i.name, r, "name", e, 1), r;
  }
  s(Bx, "placeholder");
  function jx(t) {
    let e = {
      type: "V8IntrinsicIdentifier",
      name: t
    }, r = E.V8IntrinsicIdentifier;
    return c(r.name, e, "name", t), e;
  }
  s(jx, "v8IntrinsicIdentifier");
  function Fx() {
    return {
      type: "ArgumentPlaceholder"
    };
  }
  s(Fx, "argumentPlaceholder");
  function Rx(t, e) {
    let r = {
      type: "BindExpression",
      object: t,
      callee: e
    }, i = E.BindExpression;
    return c(i.object, r, "object", t, 1), c(i.callee, r, "callee", e, 1), r;
  }
  s(Rx, "bindExpression");
  function qx(t) {
    let e = {
      type: "Decorator",
      expression: t
    }, r = E.Decorator;
    return c(r.expression, e, "expression", t, 1), e;
  }
  s(qx, "decorator");
  function Ux(t, e = !1) {
    let r = {
      type: "DoExpression",
      body: t,
      async: e
    }, i = E.DoExpression;
    return c(i.body, r, "body", t, 1), c(i.async, r, "async", e), r;
  }
  s(Ux, "doExpression");
  function Kx(t) {
    let e = {
      type: "ExportDefaultSpecifier",
      exported: t
    }, r = E.ExportDefaultSpecifier;
    return c(r.exported, e, "exported", t, 1), e;
  }
  s(Kx, "exportDefaultSpecifier");
  function Vx(t) {
    let e = {
      type: "RecordExpression",
      properties: t
    }, r = E.RecordExpression;
    return c(r.properties, e, "properties", t, 1), e;
  }
  s(Vx, "recordExpression");
  function Yx(t = []) {
    let e = {
      type: "TupleExpression",
      elements: t
    }, r = E.TupleExpression;
    return c(r.elements, e, "elements", t, 1), e;
  }
  s(Yx, "tupleExpression");
  function Jx(t) {
    let e = {
      type: "DecimalLiteral",
      value: t
    }, r = E.DecimalLiteral;
    return c(r.value, e, "value", t), e;
  }
  s(Jx, "decimalLiteral");
  function Xx(t) {
    let e = {
      type: "ModuleExpression",
      body: t
    }, r = E.ModuleExpression;
    return c(r.body, e, "body", t, 1), e;
  }
  s(Xx, "moduleExpression");
  function Wx() {
    return {
      type: "TopicReference"
    };
  }
  s(Wx, "topicReference");
  function zx(t) {
    let e = {
      type: "PipelineTopicExpression",
      expression: t
    }, r = E.PipelineTopicExpression;
    return c(r.expression, e, "expression", t, 1), e;
  }
  s(zx, "pipelineTopicExpression");
  function $x(t) {
    let e = {
      type: "PipelineBareFunction",
      callee: t
    }, r = E.PipelineBareFunction;
    return c(r.callee, e, "callee", t, 1), e;
  }
  s($x, "pipelineBareFunction");
  function Hx() {
    return {
      type: "PipelinePrimaryTopicReference"
    };
  }
  s(Hx, "pipelinePrimaryTopicReference");
  function Gx(t) {
    let e = {
      type: "TSParameterProperty",
      parameter: t
    }, r = E.TSParameterProperty;
    return c(r.parameter, e, "parameter", t, 1), e;
  }
  s(Gx, "tsParameterProperty");
  function Qx(t = null, e = null, r, i = null) {
    let n = {
      type: "TSDeclareFunction",
      id: t,
      typeParameters: e,
      params: r,
      returnType: i
    }, a = E.TSDeclareFunction;
    return c(a.id, n, "id", t, 1), c(a.typeParameters, n, "typeParameters", e, 1), c(a.params, n, "params", r, 1), c(a.returnType, n, "retur\
nType", i, 1), n;
  }
  s(Qx, "tsDeclareFunction");
  function Zx(t = null, e, r = null, i, n = null) {
    let a = {
      type: "TSDeclareMethod",
      decorators: t,
      key: e,
      typeParameters: r,
      params: i,
      returnType: n
    }, o = E.TSDeclareMethod;
    return c(o.decorators, a, "decorators", t, 1), c(o.key, a, "key", e, 1), c(o.typeParameters, a, "typeParameters", r, 1), c(o.params, a, "\
params", i, 1), c(o.returnType, a, "returnType", n, 1), a;
  }
  s(Zx, "tsDeclareMethod");
  function eP(t, e) {
    let r = {
      type: "TSQualifiedName",
      left: t,
      right: e
    }, i = E.TSQualifiedName;
    return c(i.left, r, "left", t, 1), c(i.right, r, "right", e, 1), r;
  }
  s(eP, "tsQualifiedName");
  function tP(t = null, e, r = null) {
    let i = {
      type: "TSCallSignatureDeclaration",
      typeParameters: t,
      parameters: e,
      typeAnnotation: r
    }, n = E.TSCallSignatureDeclaration;
    return c(n.typeParameters, i, "typeParameters", t, 1), c(n.parameters, i, "parameters", e, 1), c(n.typeAnnotation, i, "typeAnnotation", r,
    1), i;
  }
  s(tP, "tsCallSignatureDeclaration");
  function rP(t = null, e, r = null) {
    let i = {
      type: "TSConstructSignatureDeclaration",
      typeParameters: t,
      parameters: e,
      typeAnnotation: r
    }, n = E.TSConstructSignatureDeclaration;
    return c(n.typeParameters, i, "typeParameters", t, 1), c(n.parameters, i, "parameters", e, 1), c(n.typeAnnotation, i, "typeAnnotation", r,
    1), i;
  }
  s(rP, "tsConstructSignatureDeclaration");
  function iP(t, e = null) {
    let r = {
      type: "TSPropertySignature",
      key: t,
      typeAnnotation: e
    }, i = E.TSPropertySignature;
    return c(i.key, r, "key", t, 1), c(i.typeAnnotation, r, "typeAnnotation", e, 1), r;
  }
  s(iP, "tsPropertySignature");
  function sP(t, e = null, r, i = null) {
    let n = {
      type: "TSMethodSignature",
      key: t,
      typeParameters: e,
      parameters: r,
      typeAnnotation: i,
      kind: null
    }, a = E.TSMethodSignature;
    return c(a.key, n, "key", t, 1), c(a.typeParameters, n, "typeParameters", e, 1), c(a.parameters, n, "parameters", r, 1), c(a.typeAnnotation,
    n, "typeAnnotation", i, 1), n;
  }
  s(sP, "tsMethodSignature");
  function nP(t, e = null) {
    let r = {
      type: "TSIndexSignature",
      parameters: t,
      typeAnnotation: e
    }, i = E.TSIndexSignature;
    return c(i.parameters, r, "parameters", t, 1), c(i.typeAnnotation, r, "typeAnnotation", e, 1), r;
  }
  s(nP, "tsIndexSignature");
  function aP() {
    return {
      type: "TSAnyKeyword"
    };
  }
  s(aP, "tsAnyKeyword");
  function oP() {
    return {
      type: "TSBooleanKeyword"
    };
  }
  s(oP, "tsBooleanKeyword");
  function lP() {
    return {
      type: "TSBigIntKeyword"
    };
  }
  s(lP, "tsBigIntKeyword");
  function uP() {
    return {
      type: "TSIntrinsicKeyword"
    };
  }
  s(uP, "tsIntrinsicKeyword");
  function cP() {
    return {
      type: "TSNeverKeyword"
    };
  }
  s(cP, "tsNeverKeyword");
  function pP() {
    return {
      type: "TSNullKeyword"
    };
  }
  s(pP, "tsNullKeyword");
  function fP() {
    return {
      type: "TSNumberKeyword"
    };
  }
  s(fP, "tsNumberKeyword");
  function hP() {
    return {
      type: "TSObjectKeyword"
    };
  }
  s(hP, "tsObjectKeyword");
  function dP() {
    return {
      type: "TSStringKeyword"
    };
  }
  s(dP, "tsStringKeyword");
  function mP() {
    return {
      type: "TSSymbolKeyword"
    };
  }
  s(mP, "tsSymbolKeyword");
  function yP() {
    return {
      type: "TSUndefinedKeyword"
    };
  }
  s(yP, "tsUndefinedKeyword");
  function TP() {
    return {
      type: "TSUnknownKeyword"
    };
  }
  s(TP, "tsUnknownKeyword");
  function SP() {
    return {
      type: "TSVoidKeyword"
    };
  }
  s(SP, "tsVoidKeyword");
  function bP() {
    return {
      type: "TSThisType"
    };
  }
  s(bP, "tsThisType");
  function xP(t = null, e, r = null) {
    let i = {
      type: "TSFunctionType",
      typeParameters: t,
      parameters: e,
      typeAnnotation: r
    }, n = E.TSFunctionType;
    return c(n.typeParameters, i, "typeParameters", t, 1), c(n.parameters, i, "parameters", e, 1), c(n.typeAnnotation, i, "typeAnnotation", r,
    1), i;
  }
  s(xP, "tsFunctionType");
  function PP(t = null, e, r = null) {
    let i = {
      type: "TSConstructorType",
      typeParameters: t,
      parameters: e,
      typeAnnotation: r
    }, n = E.TSConstructorType;
    return c(n.typeParameters, i, "typeParameters", t, 1), c(n.parameters, i, "parameters", e, 1), c(n.typeAnnotation, i, "typeAnnotation", r,
    1), i;
  }
  s(PP, "tsConstructorType");
  function EP(t, e = null) {
    let r = {
      type: "TSTypeReference",
      typeName: t,
      typeParameters: e
    }, i = E.TSTypeReference;
    return c(i.typeName, r, "typeName", t, 1), c(i.typeParameters, r, "typeParameters", e, 1), r;
  }
  s(EP, "tsTypeReference");
  function gP(t, e = null, r = null) {
    let i = {
      type: "TSTypePredicate",
      parameterName: t,
      typeAnnotation: e,
      asserts: r
    }, n = E.TSTypePredicate;
    return c(n.parameterName, i, "parameterName", t, 1), c(n.typeAnnotation, i, "typeAnnotation", e, 1), c(n.asserts, i, "asserts", r), i;
  }
  s(gP, "tsTypePredicate");
  function AP(t, e = null) {
    let r = {
      type: "TSTypeQuery",
      exprName: t,
      typeParameters: e
    }, i = E.TSTypeQuery;
    return c(i.exprName, r, "exprName", t, 1), c(i.typeParameters, r, "typeParameters", e, 1), r;
  }
  s(AP, "tsTypeQuery");
  function IP(t) {
    let e = {
      type: "TSTypeLiteral",
      members: t
    }, r = E.TSTypeLiteral;
    return c(r.members, e, "members", t, 1), e;
  }
  s(IP, "tsTypeLiteral");
  function vP(t) {
    let e = {
      type: "TSArrayType",
      elementType: t
    }, r = E.TSArrayType;
    return c(r.elementType, e, "elementType", t, 1), e;
  }
  s(vP, "tsArrayType");
  function CP(t) {
    let e = {
      type: "TSTupleType",
      elementTypes: t
    }, r = E.TSTupleType;
    return c(r.elementTypes, e, "elementTypes", t, 1), e;
  }
  s(CP, "tsTupleType");
  function wP(t) {
    let e = {
      type: "TSOptionalType",
      typeAnnotation: t
    }, r = E.TSOptionalType;
    return c(r.typeAnnotation, e, "typeAnnotation", t, 1), e;
  }
  s(wP, "tsOptionalType");
  function NP(t) {
    let e = {
      type: "TSRestType",
      typeAnnotation: t
    }, r = E.TSRestType;
    return c(r.typeAnnotation, e, "typeAnnotation", t, 1), e;
  }
  s(NP, "tsRestType");
  function OP(t, e, r = !1) {
    let i = {
      type: "TSNamedTupleMember",
      label: t,
      elementType: e,
      optional: r
    }, n = E.TSNamedTupleMember;
    return c(n.label, i, "label", t, 1), c(n.elementType, i, "elementType", e, 1), c(n.optional, i, "optional", r), i;
  }
  s(OP, "tsNamedTupleMember");
  function _P(t) {
    let e = {
      type: "TSUnionType",
      types: t
    }, r = E.TSUnionType;
    return c(r.types, e, "types", t, 1), e;
  }
  s(_P, "tsUnionType");
  function DP(t) {
    let e = {
      type: "TSIntersectionType",
      types: t
    }, r = E.TSIntersectionType;
    return c(r.types, e, "types", t, 1), e;
  }
  s(DP, "tsIntersectionType");
  function kP(t, e, r, i) {
    let n = {
      type: "TSConditionalType",
      checkType: t,
      extendsType: e,
      trueType: r,
      falseType: i
    }, a = E.TSConditionalType;
    return c(a.checkType, n, "checkType", t, 1), c(a.extendsType, n, "extendsType", e, 1), c(a.trueType, n, "trueType", r, 1), c(a.falseType,
    n, "falseType", i, 1), n;
  }
  s(kP, "tsConditionalType");
  function LP(t) {
    let e = {
      type: "TSInferType",
      typeParameter: t
    }, r = E.TSInferType;
    return c(r.typeParameter, e, "typeParameter", t, 1), e;
  }
  s(LP, "tsInferType");
  function MP(t) {
    let e = {
      type: "TSParenthesizedType",
      typeAnnotation: t
    }, r = E.TSParenthesizedType;
    return c(r.typeAnnotation, e, "typeAnnotation", t, 1), e;
  }
  s(MP, "tsParenthesizedType");
  function BP(t) {
    let e = {
      type: "TSTypeOperator",
      typeAnnotation: t,
      operator: null
    }, r = E.TSTypeOperator;
    return c(r.typeAnnotation, e, "typeAnnotation", t, 1), e;
  }
  s(BP, "tsTypeOperator");
  function jP(t, e) {
    let r = {
      type: "TSIndexedAccessType",
      objectType: t,
      indexType: e
    }, i = E.TSIndexedAccessType;
    return c(i.objectType, r, "objectType", t, 1), c(i.indexType, r, "indexType", e, 1), r;
  }
  s(jP, "tsIndexedAccessType");
  function FP(t, e = null, r = null) {
    let i = {
      type: "TSMappedType",
      typeParameter: t,
      typeAnnotation: e,
      nameType: r
    }, n = E.TSMappedType;
    return c(n.typeParameter, i, "typeParameter", t, 1), c(n.typeAnnotation, i, "typeAnnotation", e, 1), c(n.nameType, i, "nameType", r, 1),
    i;
  }
  s(FP, "tsMappedType");
  function RP(t, e) {
    let r = {
      type: "TSTemplateLiteralType",
      quasis: t,
      types: e
    }, i = E.TSTemplateLiteralType;
    return c(i.quasis, r, "quasis", t, 1), c(i.types, r, "types", e, 1), r;
  }
  s(RP, "tsTemplateLiteralType");
  function qP(t) {
    let e = {
      type: "TSLiteralType",
      literal: t
    }, r = E.TSLiteralType;
    return c(r.literal, e, "literal", t, 1), e;
  }
  s(qP, "tsLiteralType");
  function UP(t, e = null) {
    let r = {
      type: "TSExpressionWithTypeArguments",
      expression: t,
      typeParameters: e
    }, i = E.TSExpressionWithTypeArguments;
    return c(i.expression, r, "expression", t, 1), c(i.typeParameters, r, "typeParameters", e, 1), r;
  }
  s(UP, "tsExpressionWithTypeArguments");
  function KP(t, e = null, r = null, i) {
    let n = {
      type: "TSInterfaceDeclaration",
      id: t,
      typeParameters: e,
      extends: r,
      body: i
    }, a = E.TSInterfaceDeclaration;
    return c(a.id, n, "id", t, 1), c(a.typeParameters, n, "typeParameters", e, 1), c(a.extends, n, "extends", r, 1), c(a.body, n, "body", i,
    1), n;
  }
  s(KP, "tsInterfaceDeclaration");
  function VP(t) {
    let e = {
      type: "TSInterfaceBody",
      body: t
    }, r = E.TSInterfaceBody;
    return c(r.body, e, "body", t, 1), e;
  }
  s(VP, "tsInterfaceBody");
  function YP(t, e = null, r) {
    let i = {
      type: "TSTypeAliasDeclaration",
      id: t,
      typeParameters: e,
      typeAnnotation: r
    }, n = E.TSTypeAliasDeclaration;
    return c(n.id, i, "id", t, 1), c(n.typeParameters, i, "typeParameters", e, 1), c(n.typeAnnotation, i, "typeAnnotation", r, 1), i;
  }
  s(YP, "tsTypeAliasDeclaration");
  function JP(t, e = null) {
    let r = {
      type: "TSInstantiationExpression",
      expression: t,
      typeParameters: e
    }, i = E.TSInstantiationExpression;
    return c(i.expression, r, "expression", t, 1), c(i.typeParameters, r, "typeParameters", e, 1), r;
  }
  s(JP, "tsInstantiationExpression");
  function XP(t, e) {
    let r = {
      type: "TSAsExpression",
      expression: t,
      typeAnnotation: e
    }, i = E.TSAsExpression;
    return c(i.expression, r, "expression", t, 1), c(i.typeAnnotation, r, "typeAnnotation", e, 1), r;
  }
  s(XP, "tsAsExpression");
  function WP(t, e) {
    let r = {
      type: "TSSatisfiesExpression",
      expression: t,
      typeAnnotation: e
    }, i = E.TSSatisfiesExpression;
    return c(i.expression, r, "expression", t, 1), c(i.typeAnnotation, r, "typeAnnotation", e, 1), r;
  }
  s(WP, "tsSatisfiesExpression");
  function zP(t, e) {
    let r = {
      type: "TSTypeAssertion",
      typeAnnotation: t,
      expression: e
    }, i = E.TSTypeAssertion;
    return c(i.typeAnnotation, r, "typeAnnotation", t, 1), c(i.expression, r, "expression", e, 1), r;
  }
  s(zP, "tsTypeAssertion");
  function $P(t) {
    let e = {
      type: "TSEnumBody",
      members: t
    }, r = E.TSEnumBody;
    return c(r.members, e, "members", t, 1), e;
  }
  s($P, "tsEnumBody");
  function HP(t, e) {
    let r = {
      type: "TSEnumDeclaration",
      id: t,
      members: e
    }, i = E.TSEnumDeclaration;
    return c(i.id, r, "id", t, 1), c(i.members, r, "members", e, 1), r;
  }
  s(HP, "tsEnumDeclaration");
  function GP(t, e = null) {
    let r = {
      type: "TSEnumMember",
      id: t,
      initializer: e
    }, i = E.TSEnumMember;
    return c(i.id, r, "id", t, 1), c(i.initializer, r, "initializer", e, 1), r;
  }
  s(GP, "tsEnumMember");
  function QP(t, e) {
    let r = {
      type: "TSModuleDeclaration",
      id: t,
      body: e,
      kind: null
    }, i = E.TSModuleDeclaration;
    return c(i.id, r, "id", t, 1), c(i.body, r, "body", e, 1), r;
  }
  s(QP, "tsModuleDeclaration");
  function ZP(t) {
    let e = {
      type: "TSModuleBlock",
      body: t
    }, r = E.TSModuleBlock;
    return c(r.body, e, "body", t, 1), e;
  }
  s(ZP, "tsModuleBlock");
  function eE(t, e = null, r = null) {
    let i = {
      type: "TSImportType",
      argument: t,
      qualifier: e,
      typeParameters: r
    }, n = E.TSImportType;
    return c(n.argument, i, "argument", t, 1), c(n.qualifier, i, "qualifier", e, 1), c(n.typeParameters, i, "typeParameters", r, 1), i;
  }
  s(eE, "tsImportType");
  function tE(t, e) {
    let r = {
      type: "TSImportEqualsDeclaration",
      id: t,
      moduleReference: e,
      isExport: null
    }, i = E.TSImportEqualsDeclaration;
    return c(i.id, r, "id", t, 1), c(i.moduleReference, r, "moduleReference", e, 1), r;
  }
  s(tE, "tsImportEqualsDeclaration");
  function rE(t) {
    let e = {
      type: "TSExternalModuleReference",
      expression: t
    }, r = E.TSExternalModuleReference;
    return c(r.expression, e, "expression", t, 1), e;
  }
  s(rE, "tsExternalModuleReference");
  function iE(t) {
    let e = {
      type: "TSNonNullExpression",
      expression: t
    }, r = E.TSNonNullExpression;
    return c(r.expression, e, "expression", t, 1), e;
  }
  s(iE, "tsNonNullExpression");
  function sE(t) {
    let e = {
      type: "TSExportAssignment",
      expression: t
    }, r = E.TSExportAssignment;
    return c(r.expression, e, "expression", t, 1), e;
  }
  s(sE, "tsExportAssignment");
  function nE(t) {
    let e = {
      type: "TSNamespaceExportDeclaration",
      id: t
    }, r = E.TSNamespaceExportDeclaration;
    return c(r.id, e, "id", t, 1), e;
  }
  s(nE, "tsNamespaceExportDeclaration");
  function aE(t) {
    let e = {
      type: "TSTypeAnnotation",
      typeAnnotation: t
    }, r = E.TSTypeAnnotation;
    return c(r.typeAnnotation, e, "typeAnnotation", t, 1), e;
  }
  s(aE, "tsTypeAnnotation");
  function oE(t) {
    let e = {
      type: "TSTypeParameterInstantiation",
      params: t
    }, r = E.TSTypeParameterInstantiation;
    return c(r.params, e, "params", t, 1), e;
  }
  s(oE, "tsTypeParameterInstantiation");
  function lE(t) {
    let e = {
      type: "TSTypeParameterDeclaration",
      params: t
    }, r = E.TSTypeParameterDeclaration;
    return c(r.params, e, "params", t, 1), e;
  }
  s(lE, "tsTypeParameterDeclaration");
  function uE(t = null, e = null, r) {
    let i = {
      type: "TSTypeParameter",
      constraint: t,
      default: e,
      name: r
    }, n = E.TSTypeParameter;
    return c(n.constraint, i, "constraint", t, 1), c(n.default, i, "default", e, 1), c(n.name, i, "name", r), i;
  }
  s(uE, "tsTypeParameter");
  function cE(t) {
    return (0, xi.default)("NumberLiteral", "NumericLiteral", "The node type "), Ol(t);
  }
  s(cE, "NumberLiteral");
  function pE(t, e = "") {
    return (0, xi.default)("RegexLiteral", "RegExpLiteral", "The node type "), _l(t, e);
  }
  s(pE, "RegexLiteral");
  function fE(t) {
    return (0, xi.default)("RestProperty", "RestElement", "The node type "), Dl(t);
  }
  s(fE, "RestProperty");
  function hE(t) {
    return (0, xi.default)("SpreadProperty", "SpreadElement", "The node type "), kl(t);
  }
  s(hE, "SpreadProperty");
});

// ../node_modules/@babel/types/lib/builders/generated/uppercase.js
var Ll = O((b) => {
  "use strict";
  Object.defineProperty(b, "__esModule", {
    value: !0
  });
  Object.defineProperty(b, "AnyTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.anyTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "ArgumentPlaceholder", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.argumentPlaceholder;
    }, "get")
  });
  Object.defineProperty(b, "ArrayExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.arrayExpression;
    }, "get")
  });
  Object.defineProperty(b, "ArrayPattern", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.arrayPattern;
    }, "get")
  });
  Object.defineProperty(b, "ArrayTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.arrayTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "ArrowFunctionExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.arrowFunctionExpression;
    }, "get")
  });
  Object.defineProperty(b, "AssignmentExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.assignmentExpression;
    }, "get")
  });
  Object.defineProperty(b, "AssignmentPattern", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.assignmentPattern;
    }, "get")
  });
  Object.defineProperty(b, "AwaitExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.awaitExpression;
    }, "get")
  });
  Object.defineProperty(b, "BigIntLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.bigIntLiteral;
    }, "get")
  });
  Object.defineProperty(b, "BinaryExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.binaryExpression;
    }, "get")
  });
  Object.defineProperty(b, "BindExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.bindExpression;
    }, "get")
  });
  Object.defineProperty(b, "BlockStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.blockStatement;
    }, "get")
  });
  Object.defineProperty(b, "BooleanLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.booleanLiteral;
    }, "get")
  });
  Object.defineProperty(b, "BooleanLiteralTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.booleanLiteralTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "BooleanTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.booleanTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "BreakStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.breakStatement;
    }, "get")
  });
  Object.defineProperty(b, "CallExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.callExpression;
    }, "get")
  });
  Object.defineProperty(b, "CatchClause", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.catchClause;
    }, "get")
  });
  Object.defineProperty(b, "ClassAccessorProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.classAccessorProperty;
    }, "get")
  });
  Object.defineProperty(b, "ClassBody", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.classBody;
    }, "get")
  });
  Object.defineProperty(b, "ClassDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.classDeclaration;
    }, "get")
  });
  Object.defineProperty(b, "ClassExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.classExpression;
    }, "get")
  });
  Object.defineProperty(b, "ClassImplements", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.classImplements;
    }, "get")
  });
  Object.defineProperty(b, "ClassMethod", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.classMethod;
    }, "get")
  });
  Object.defineProperty(b, "ClassPrivateMethod", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.classPrivateMethod;
    }, "get")
  });
  Object.defineProperty(b, "ClassPrivateProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.classPrivateProperty;
    }, "get")
  });
  Object.defineProperty(b, "ClassProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.classProperty;
    }, "get")
  });
  Object.defineProperty(b, "ConditionalExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.conditionalExpression;
    }, "get")
  });
  Object.defineProperty(b, "ContinueStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.continueStatement;
    }, "get")
  });
  Object.defineProperty(b, "DebuggerStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.debuggerStatement;
    }, "get")
  });
  Object.defineProperty(b, "DecimalLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.decimalLiteral;
    }, "get")
  });
  Object.defineProperty(b, "DeclareClass", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.declareClass;
    }, "get")
  });
  Object.defineProperty(b, "DeclareExportAllDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.declareExportAllDeclaration;
    }, "get")
  });
  Object.defineProperty(b, "DeclareExportDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.declareExportDeclaration;
    }, "get")
  });
  Object.defineProperty(b, "DeclareFunction", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.declareFunction;
    }, "get")
  });
  Object.defineProperty(b, "DeclareInterface", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.declareInterface;
    }, "get")
  });
  Object.defineProperty(b, "DeclareModule", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.declareModule;
    }, "get")
  });
  Object.defineProperty(b, "DeclareModuleExports", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.declareModuleExports;
    }, "get")
  });
  Object.defineProperty(b, "DeclareOpaqueType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.declareOpaqueType;
    }, "get")
  });
  Object.defineProperty(b, "DeclareTypeAlias", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.declareTypeAlias;
    }, "get")
  });
  Object.defineProperty(b, "DeclareVariable", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.declareVariable;
    }, "get")
  });
  Object.defineProperty(b, "DeclaredPredicate", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.declaredPredicate;
    }, "get")
  });
  Object.defineProperty(b, "Decorator", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.decorator;
    }, "get")
  });
  Object.defineProperty(b, "Directive", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.directive;
    }, "get")
  });
  Object.defineProperty(b, "DirectiveLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.directiveLiteral;
    }, "get")
  });
  Object.defineProperty(b, "DoExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.doExpression;
    }, "get")
  });
  Object.defineProperty(b, "DoWhileStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.doWhileStatement;
    }, "get")
  });
  Object.defineProperty(b, "EmptyStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.emptyStatement;
    }, "get")
  });
  Object.defineProperty(b, "EmptyTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.emptyTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "EnumBooleanBody", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.enumBooleanBody;
    }, "get")
  });
  Object.defineProperty(b, "EnumBooleanMember", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.enumBooleanMember;
    }, "get")
  });
  Object.defineProperty(b, "EnumDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.enumDeclaration;
    }, "get")
  });
  Object.defineProperty(b, "EnumDefaultedMember", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.enumDefaultedMember;
    }, "get")
  });
  Object.defineProperty(b, "EnumNumberBody", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.enumNumberBody;
    }, "get")
  });
  Object.defineProperty(b, "EnumNumberMember", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.enumNumberMember;
    }, "get")
  });
  Object.defineProperty(b, "EnumStringBody", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.enumStringBody;
    }, "get")
  });
  Object.defineProperty(b, "EnumStringMember", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.enumStringMember;
    }, "get")
  });
  Object.defineProperty(b, "EnumSymbolBody", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.enumSymbolBody;
    }, "get")
  });
  Object.defineProperty(b, "ExistsTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.existsTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "ExportAllDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.exportAllDeclaration;
    }, "get")
  });
  Object.defineProperty(b, "ExportDefaultDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.exportDefaultDeclaration;
    }, "get")
  });
  Object.defineProperty(b, "ExportDefaultSpecifier", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.exportDefaultSpecifier;
    }, "get")
  });
  Object.defineProperty(b, "ExportNamedDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.exportNamedDeclaration;
    }, "get")
  });
  Object.defineProperty(b, "ExportNamespaceSpecifier", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.exportNamespaceSpecifier;
    }, "get")
  });
  Object.defineProperty(b, "ExportSpecifier", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.exportSpecifier;
    }, "get")
  });
  Object.defineProperty(b, "ExpressionStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.expressionStatement;
    }, "get")
  });
  Object.defineProperty(b, "File", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.file;
    }, "get")
  });
  Object.defineProperty(b, "ForInStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.forInStatement;
    }, "get")
  });
  Object.defineProperty(b, "ForOfStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.forOfStatement;
    }, "get")
  });
  Object.defineProperty(b, "ForStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.forStatement;
    }, "get")
  });
  Object.defineProperty(b, "FunctionDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.functionDeclaration;
    }, "get")
  });
  Object.defineProperty(b, "FunctionExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.functionExpression;
    }, "get")
  });
  Object.defineProperty(b, "FunctionTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.functionTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "FunctionTypeParam", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.functionTypeParam;
    }, "get")
  });
  Object.defineProperty(b, "GenericTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.genericTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "Identifier", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.identifier;
    }, "get")
  });
  Object.defineProperty(b, "IfStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.ifStatement;
    }, "get")
  });
  Object.defineProperty(b, "Import", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.import;
    }, "get")
  });
  Object.defineProperty(b, "ImportAttribute", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.importAttribute;
    }, "get")
  });
  Object.defineProperty(b, "ImportDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.importDeclaration;
    }, "get")
  });
  Object.defineProperty(b, "ImportDefaultSpecifier", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.importDefaultSpecifier;
    }, "get")
  });
  Object.defineProperty(b, "ImportExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.importExpression;
    }, "get")
  });
  Object.defineProperty(b, "ImportNamespaceSpecifier", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.importNamespaceSpecifier;
    }, "get")
  });
  Object.defineProperty(b, "ImportSpecifier", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.importSpecifier;
    }, "get")
  });
  Object.defineProperty(b, "IndexedAccessType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.indexedAccessType;
    }, "get")
  });
  Object.defineProperty(b, "InferredPredicate", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.inferredPredicate;
    }, "get")
  });
  Object.defineProperty(b, "InterfaceDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.interfaceDeclaration;
    }, "get")
  });
  Object.defineProperty(b, "InterfaceExtends", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.interfaceExtends;
    }, "get")
  });
  Object.defineProperty(b, "InterfaceTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.interfaceTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "InterpreterDirective", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.interpreterDirective;
    }, "get")
  });
  Object.defineProperty(b, "IntersectionTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.intersectionTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "JSXAttribute", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.jsxAttribute;
    }, "get")
  });
  Object.defineProperty(b, "JSXClosingElement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.jsxClosingElement;
    }, "get")
  });
  Object.defineProperty(b, "JSXClosingFragment", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.jsxClosingFragment;
    }, "get")
  });
  Object.defineProperty(b, "JSXElement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.jsxElement;
    }, "get")
  });
  Object.defineProperty(b, "JSXEmptyExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.jsxEmptyExpression;
    }, "get")
  });
  Object.defineProperty(b, "JSXExpressionContainer", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.jsxExpressionContainer;
    }, "get")
  });
  Object.defineProperty(b, "JSXFragment", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.jsxFragment;
    }, "get")
  });
  Object.defineProperty(b, "JSXIdentifier", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.jsxIdentifier;
    }, "get")
  });
  Object.defineProperty(b, "JSXMemberExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.jsxMemberExpression;
    }, "get")
  });
  Object.defineProperty(b, "JSXNamespacedName", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.jsxNamespacedName;
    }, "get")
  });
  Object.defineProperty(b, "JSXOpeningElement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.jsxOpeningElement;
    }, "get")
  });
  Object.defineProperty(b, "JSXOpeningFragment", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.jsxOpeningFragment;
    }, "get")
  });
  Object.defineProperty(b, "JSXSpreadAttribute", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.jsxSpreadAttribute;
    }, "get")
  });
  Object.defineProperty(b, "JSXSpreadChild", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.jsxSpreadChild;
    }, "get")
  });
  Object.defineProperty(b, "JSXText", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.jsxText;
    }, "get")
  });
  Object.defineProperty(b, "LabeledStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.labeledStatement;
    }, "get")
  });
  Object.defineProperty(b, "LogicalExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.logicalExpression;
    }, "get")
  });
  Object.defineProperty(b, "MemberExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.memberExpression;
    }, "get")
  });
  Object.defineProperty(b, "MetaProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.metaProperty;
    }, "get")
  });
  Object.defineProperty(b, "MixedTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.mixedTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "ModuleExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.moduleExpression;
    }, "get")
  });
  Object.defineProperty(b, "NewExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.newExpression;
    }, "get")
  });
  Object.defineProperty(b, "Noop", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.noop;
    }, "get")
  });
  Object.defineProperty(b, "NullLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.nullLiteral;
    }, "get")
  });
  Object.defineProperty(b, "NullLiteralTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.nullLiteralTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "NullableTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.nullableTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "NumberLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.numberLiteral;
    }, "get")
  });
  Object.defineProperty(b, "NumberLiteralTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.numberLiteralTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "NumberTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.numberTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "NumericLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.numericLiteral;
    }, "get")
  });
  Object.defineProperty(b, "ObjectExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.objectExpression;
    }, "get")
  });
  Object.defineProperty(b, "ObjectMethod", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.objectMethod;
    }, "get")
  });
  Object.defineProperty(b, "ObjectPattern", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.objectPattern;
    }, "get")
  });
  Object.defineProperty(b, "ObjectProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.objectProperty;
    }, "get")
  });
  Object.defineProperty(b, "ObjectTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.objectTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "ObjectTypeCallProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.objectTypeCallProperty;
    }, "get")
  });
  Object.defineProperty(b, "ObjectTypeIndexer", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.objectTypeIndexer;
    }, "get")
  });
  Object.defineProperty(b, "ObjectTypeInternalSlot", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.objectTypeInternalSlot;
    }, "get")
  });
  Object.defineProperty(b, "ObjectTypeProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.objectTypeProperty;
    }, "get")
  });
  Object.defineProperty(b, "ObjectTypeSpreadProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.objectTypeSpreadProperty;
    }, "get")
  });
  Object.defineProperty(b, "OpaqueType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.opaqueType;
    }, "get")
  });
  Object.defineProperty(b, "OptionalCallExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.optionalCallExpression;
    }, "get")
  });
  Object.defineProperty(b, "OptionalIndexedAccessType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.optionalIndexedAccessType;
    }, "get")
  });
  Object.defineProperty(b, "OptionalMemberExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.optionalMemberExpression;
    }, "get")
  });
  Object.defineProperty(b, "ParenthesizedExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.parenthesizedExpression;
    }, "get")
  });
  Object.defineProperty(b, "PipelineBareFunction", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.pipelineBareFunction;
    }, "get")
  });
  Object.defineProperty(b, "PipelinePrimaryTopicReference", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.pipelinePrimaryTopicReference;
    }, "get")
  });
  Object.defineProperty(b, "PipelineTopicExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.pipelineTopicExpression;
    }, "get")
  });
  Object.defineProperty(b, "Placeholder", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.placeholder;
    }, "get")
  });
  Object.defineProperty(b, "PrivateName", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.privateName;
    }, "get")
  });
  Object.defineProperty(b, "Program", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.program;
    }, "get")
  });
  Object.defineProperty(b, "QualifiedTypeIdentifier", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.qualifiedTypeIdentifier;
    }, "get")
  });
  Object.defineProperty(b, "RecordExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.recordExpression;
    }, "get")
  });
  Object.defineProperty(b, "RegExpLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.regExpLiteral;
    }, "get")
  });
  Object.defineProperty(b, "RegexLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.regexLiteral;
    }, "get")
  });
  Object.defineProperty(b, "RestElement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.restElement;
    }, "get")
  });
  Object.defineProperty(b, "RestProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.restProperty;
    }, "get")
  });
  Object.defineProperty(b, "ReturnStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.returnStatement;
    }, "get")
  });
  Object.defineProperty(b, "SequenceExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.sequenceExpression;
    }, "get")
  });
  Object.defineProperty(b, "SpreadElement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.spreadElement;
    }, "get")
  });
  Object.defineProperty(b, "SpreadProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.spreadProperty;
    }, "get")
  });
  Object.defineProperty(b, "StaticBlock", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.staticBlock;
    }, "get")
  });
  Object.defineProperty(b, "StringLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.stringLiteral;
    }, "get")
  });
  Object.defineProperty(b, "StringLiteralTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.stringLiteralTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "StringTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.stringTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "Super", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.super;
    }, "get")
  });
  Object.defineProperty(b, "SwitchCase", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.switchCase;
    }, "get")
  });
  Object.defineProperty(b, "SwitchStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.switchStatement;
    }, "get")
  });
  Object.defineProperty(b, "SymbolTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.symbolTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "TSAnyKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsAnyKeyword;
    }, "get")
  });
  Object.defineProperty(b, "TSArrayType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsArrayType;
    }, "get")
  });
  Object.defineProperty(b, "TSAsExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsAsExpression;
    }, "get")
  });
  Object.defineProperty(b, "TSBigIntKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsBigIntKeyword;
    }, "get")
  });
  Object.defineProperty(b, "TSBooleanKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsBooleanKeyword;
    }, "get")
  });
  Object.defineProperty(b, "TSCallSignatureDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsCallSignatureDeclaration;
    }, "get")
  });
  Object.defineProperty(b, "TSConditionalType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsConditionalType;
    }, "get")
  });
  Object.defineProperty(b, "TSConstructSignatureDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsConstructSignatureDeclaration;
    }, "get")
  });
  Object.defineProperty(b, "TSConstructorType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsConstructorType;
    }, "get")
  });
  Object.defineProperty(b, "TSDeclareFunction", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsDeclareFunction;
    }, "get")
  });
  Object.defineProperty(b, "TSDeclareMethod", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsDeclareMethod;
    }, "get")
  });
  Object.defineProperty(b, "TSEnumBody", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsEnumBody;
    }, "get")
  });
  Object.defineProperty(b, "TSEnumDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsEnumDeclaration;
    }, "get")
  });
  Object.defineProperty(b, "TSEnumMember", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsEnumMember;
    }, "get")
  });
  Object.defineProperty(b, "TSExportAssignment", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsExportAssignment;
    }, "get")
  });
  Object.defineProperty(b, "TSExpressionWithTypeArguments", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsExpressionWithTypeArguments;
    }, "get")
  });
  Object.defineProperty(b, "TSExternalModuleReference", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsExternalModuleReference;
    }, "get")
  });
  Object.defineProperty(b, "TSFunctionType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsFunctionType;
    }, "get")
  });
  Object.defineProperty(b, "TSImportEqualsDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsImportEqualsDeclaration;
    }, "get")
  });
  Object.defineProperty(b, "TSImportType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsImportType;
    }, "get")
  });
  Object.defineProperty(b, "TSIndexSignature", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsIndexSignature;
    }, "get")
  });
  Object.defineProperty(b, "TSIndexedAccessType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsIndexedAccessType;
    }, "get")
  });
  Object.defineProperty(b, "TSInferType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsInferType;
    }, "get")
  });
  Object.defineProperty(b, "TSInstantiationExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsInstantiationExpression;
    }, "get")
  });
  Object.defineProperty(b, "TSInterfaceBody", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsInterfaceBody;
    }, "get")
  });
  Object.defineProperty(b, "TSInterfaceDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsInterfaceDeclaration;
    }, "get")
  });
  Object.defineProperty(b, "TSIntersectionType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsIntersectionType;
    }, "get")
  });
  Object.defineProperty(b, "TSIntrinsicKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsIntrinsicKeyword;
    }, "get")
  });
  Object.defineProperty(b, "TSLiteralType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsLiteralType;
    }, "get")
  });
  Object.defineProperty(b, "TSMappedType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsMappedType;
    }, "get")
  });
  Object.defineProperty(b, "TSMethodSignature", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsMethodSignature;
    }, "get")
  });
  Object.defineProperty(b, "TSModuleBlock", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsModuleBlock;
    }, "get")
  });
  Object.defineProperty(b, "TSModuleDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsModuleDeclaration;
    }, "get")
  });
  Object.defineProperty(b, "TSNamedTupleMember", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsNamedTupleMember;
    }, "get")
  });
  Object.defineProperty(b, "TSNamespaceExportDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsNamespaceExportDeclaration;
    }, "get")
  });
  Object.defineProperty(b, "TSNeverKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsNeverKeyword;
    }, "get")
  });
  Object.defineProperty(b, "TSNonNullExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsNonNullExpression;
    }, "get")
  });
  Object.defineProperty(b, "TSNullKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsNullKeyword;
    }, "get")
  });
  Object.defineProperty(b, "TSNumberKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsNumberKeyword;
    }, "get")
  });
  Object.defineProperty(b, "TSObjectKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsObjectKeyword;
    }, "get")
  });
  Object.defineProperty(b, "TSOptionalType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsOptionalType;
    }, "get")
  });
  Object.defineProperty(b, "TSParameterProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsParameterProperty;
    }, "get")
  });
  Object.defineProperty(b, "TSParenthesizedType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsParenthesizedType;
    }, "get")
  });
  Object.defineProperty(b, "TSPropertySignature", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsPropertySignature;
    }, "get")
  });
  Object.defineProperty(b, "TSQualifiedName", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsQualifiedName;
    }, "get")
  });
  Object.defineProperty(b, "TSRestType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsRestType;
    }, "get")
  });
  Object.defineProperty(b, "TSSatisfiesExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsSatisfiesExpression;
    }, "get")
  });
  Object.defineProperty(b, "TSStringKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsStringKeyword;
    }, "get")
  });
  Object.defineProperty(b, "TSSymbolKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsSymbolKeyword;
    }, "get")
  });
  Object.defineProperty(b, "TSTemplateLiteralType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsTemplateLiteralType;
    }, "get")
  });
  Object.defineProperty(b, "TSThisType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsThisType;
    }, "get")
  });
  Object.defineProperty(b, "TSTupleType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsTupleType;
    }, "get")
  });
  Object.defineProperty(b, "TSTypeAliasDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsTypeAliasDeclaration;
    }, "get")
  });
  Object.defineProperty(b, "TSTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "TSTypeAssertion", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsTypeAssertion;
    }, "get")
  });
  Object.defineProperty(b, "TSTypeLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsTypeLiteral;
    }, "get")
  });
  Object.defineProperty(b, "TSTypeOperator", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsTypeOperator;
    }, "get")
  });
  Object.defineProperty(b, "TSTypeParameter", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsTypeParameter;
    }, "get")
  });
  Object.defineProperty(b, "TSTypeParameterDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsTypeParameterDeclaration;
    }, "get")
  });
  Object.defineProperty(b, "TSTypeParameterInstantiation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsTypeParameterInstantiation;
    }, "get")
  });
  Object.defineProperty(b, "TSTypePredicate", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsTypePredicate;
    }, "get")
  });
  Object.defineProperty(b, "TSTypeQuery", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsTypeQuery;
    }, "get")
  });
  Object.defineProperty(b, "TSTypeReference", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsTypeReference;
    }, "get")
  });
  Object.defineProperty(b, "TSUndefinedKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsUndefinedKeyword;
    }, "get")
  });
  Object.defineProperty(b, "TSUnionType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsUnionType;
    }, "get")
  });
  Object.defineProperty(b, "TSUnknownKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsUnknownKeyword;
    }, "get")
  });
  Object.defineProperty(b, "TSVoidKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsVoidKeyword;
    }, "get")
  });
  Object.defineProperty(b, "TaggedTemplateExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.taggedTemplateExpression;
    }, "get")
  });
  Object.defineProperty(b, "TemplateElement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.templateElement;
    }, "get")
  });
  Object.defineProperty(b, "TemplateLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.templateLiteral;
    }, "get")
  });
  Object.defineProperty(b, "ThisExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.thisExpression;
    }, "get")
  });
  Object.defineProperty(b, "ThisTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.thisTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "ThrowStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.throwStatement;
    }, "get")
  });
  Object.defineProperty(b, "TopicReference", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.topicReference;
    }, "get")
  });
  Object.defineProperty(b, "TryStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tryStatement;
    }, "get")
  });
  Object.defineProperty(b, "TupleExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tupleExpression;
    }, "get")
  });
  Object.defineProperty(b, "TupleTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tupleTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "TypeAlias", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.typeAlias;
    }, "get")
  });
  Object.defineProperty(b, "TypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.typeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "TypeCastExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.typeCastExpression;
    }, "get")
  });
  Object.defineProperty(b, "TypeParameter", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.typeParameter;
    }, "get")
  });
  Object.defineProperty(b, "TypeParameterDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.typeParameterDeclaration;
    }, "get")
  });
  Object.defineProperty(b, "TypeParameterInstantiation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.typeParameterInstantiation;
    }, "get")
  });
  Object.defineProperty(b, "TypeofTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.typeofTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "UnaryExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.unaryExpression;
    }, "get")
  });
  Object.defineProperty(b, "UnionTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.unionTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "UpdateExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.updateExpression;
    }, "get")
  });
  Object.defineProperty(b, "V8IntrinsicIdentifier", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.v8IntrinsicIdentifier;
    }, "get")
  });
  Object.defineProperty(b, "VariableDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.variableDeclaration;
    }, "get")
  });
  Object.defineProperty(b, "VariableDeclarator", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.variableDeclarator;
    }, "get")
  });
  Object.defineProperty(b, "Variance", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.variance;
    }, "get")
  });
  Object.defineProperty(b, "VoidTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.voidTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "WhileStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.whileStatement;
    }, "get")
  });
  Object.defineProperty(b, "WithStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.withStatement;
    }, "get")
  });
  Object.defineProperty(b, "YieldExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.yieldExpression;
    }, "get")
  });
  var x = Js();
});

// ../node_modules/@babel/types/lib/builders/generated/index.js
var it = O((Mt) => {
  "use strict";
  Object.defineProperty(Mt, "__esModule", {
    value: !0
  });
  var Xs = Js();
  Object.keys(Xs).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Mt && Mt[t] === Xs[t] || Object.defineProperty(Mt, t, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return Xs[t];
      }, "get")
    });
  });
  var Ws = Ll();
  Object.keys(Ws).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Mt && Mt[t] === Ws[t] || Object.defineProperty(Mt, t, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return Ws[t];
      }, "get")
    });
  });
});

// ../node_modules/@babel/types/lib/utils/react/cleanJSXElementLiteralChild.js
var Ml = O((zs) => {
  "use strict";
  Object.defineProperty(zs, "__esModule", {
    value: !0
  });
  zs.default = yE;
  var dE = it(), mE = Ye();
  function yE(t, e) {
    let r = t.value.split(/\r\n|\n|\r/), i = 0;
    for (let a = 0; a < r.length; a++)
      /[^ \t]/.exec(r[a]) && (i = a);
    let n = "";
    for (let a = 0; a < r.length; a++) {
      let o = r[a], l = a === 0, u = a === r.length - 1, p = a === i, m = o.replace(/\t/g, " ");
      l || (m = m.replace(/^ +/, "")), u || (m = m.replace(/ +$/, "")), m && (p || (m += " "), n += m);
    }
    n && e.push((0, mE.inherits)((0, dE.stringLiteral)(n), t));
  }
  s(yE, "cleanJSXElementLiteralChild");
});

// ../node_modules/@babel/types/lib/builders/react/buildChildren.js
var Bl = O((Hs) => {
  "use strict";
  Object.defineProperty(Hs, "__esModule", {
    value: !0
  });
  Hs.default = SE;
  var $s = Be(), TE = Ml();
  function SE(t) {
    let e = [];
    for (let r = 0; r < t.children.length; r++) {
      let i = t.children[r];
      if ((0, $s.isJSXText)(i)) {
        (0, TE.default)(i, e);
        continue;
      }
      (0, $s.isJSXExpressionContainer)(i) && (i = i.expression), !(0, $s.isJSXEmptyExpression)(i) && e.push(i);
    }
    return e;
  }
  s(SE, "buildChildren");
});

// ../node_modules/@babel/types/lib/validators/isNode.js
var Qs = O((Gs) => {
  "use strict";
  Object.defineProperty(Gs, "__esModule", {
    value: !0
  });
  Gs.default = xE;
  var bE = ot();
  function xE(t) {
    return !!(t && bE.VISITOR_KEYS[t.type]);
  }
  s(xE, "isNode");
});

// ../node_modules/@babel/types/lib/asserts/assertNode.js
var jl = O((Zs) => {
  "use strict";
  Object.defineProperty(Zs, "__esModule", {
    value: !0
  });
  Zs.default = EE;
  var PE = Qs();
  function EE(t) {
    if (!(0, PE.default)(t)) {
      var e;
      let r = (e = t?.type) != null ? e : JSON.stringify(t);
      throw new TypeError(`Not a valid node of type "${r}"`);
    }
  }
  s(EE, "assertNode");
});

// ../node_modules/@babel/types/lib/asserts/generated/index.js
var Fl = O((d) => {
  "use strict";
  Object.defineProperty(d, "__esModule", {
    value: !0
  });
  d.assertAccessor = qv;
  d.assertAnyTypeAnnotation = nA;
  d.assertArgumentPlaceholder = L1;
  d.assertArrayExpression = AE;
  d.assertArrayPattern = Eg;
  d.assertArrayTypeAnnotation = aA;
  d.assertArrowFunctionExpression = gg;
  d.assertAssignmentExpression = IE;
  d.assertAssignmentPattern = Pg;
  d.assertAwaitExpression = Xg;
  d.assertBigIntLiteral = zg;
  d.assertBinary = lv;
  d.assertBinaryExpression = vE;
  d.assertBindExpression = M1;
  d.assertBlock = pv;
  d.assertBlockParent = cv;
  d.assertBlockStatement = OE;
  d.assertBooleanLiteral = GE;
  d.assertBooleanLiteralTypeAnnotation = lA;
  d.assertBooleanTypeAnnotation = oA;
  d.assertBreakStatement = _E;
  d.assertCallExpression = DE;
  d.assertCatchClause = kE;
  d.assertClass = Bv;
  d.assertClassAccessorProperty = Zg;
  d.assertClassBody = Ag;
  d.assertClassDeclaration = vg;
  d.assertClassExpression = Ig;
  d.assertClassImplements = cA;
  d.assertClassMethod = Fg;
  d.assertClassPrivateMethod = tA;
  d.assertClassPrivateProperty = eA;
  d.assertClassProperty = Qg;
  d.assertCompletionStatement = dv;
  d.assertConditional = mv;
  d.assertConditionalExpression = LE;
  d.assertContinueStatement = ME;
  d.assertDebuggerStatement = BE;
  d.assertDecimalLiteral = U1;
  d.assertDeclaration = Av;
  d.assertDeclareClass = pA;
  d.assertDeclareExportAllDeclaration = xA;
  d.assertDeclareExportDeclaration = bA;
  d.assertDeclareFunction = fA;
  d.assertDeclareInterface = hA;
  d.assertDeclareModule = dA;
  d.assertDeclareModuleExports = mA;
  d.assertDeclareOpaqueType = TA;
  d.assertDeclareTypeAlias = yA;
  d.assertDeclareVariable = SA;
  d.assertDeclaredPredicate = PA;
  d.assertDecorator = B1;
  d.assertDirective = wE;
  d.assertDirectiveLiteral = NE;
  d.assertDoExpression = j1;
  d.assertDoWhileStatement = jE;
  d.assertEmptyStatement = FE;
  d.assertEmptyTypeAnnotation = DA;
  d.assertEnumBody = Wv;
  d.assertEnumBooleanBody = a1;
  d.assertEnumBooleanMember = c1;
  d.assertEnumDeclaration = n1;
  d.assertEnumDefaultedMember = h1;
  d.assertEnumMember = zv;
  d.assertEnumNumberBody = o1;
  d.assertEnumNumberMember = p1;
  d.assertEnumStringBody = l1;
  d.assertEnumStringMember = f1;
  d.assertEnumSymbolBody = u1;
  d.assertExistsTypeAnnotation = EA;
  d.assertExportAllDeclaration = Cg;
  d.assertExportDeclaration = Fv;
  d.assertExportDefaultDeclaration = wg;
  d.assertExportDefaultSpecifier = F1;
  d.assertExportNamedDeclaration = Ng;
  d.assertExportNamespaceSpecifier = $g;
  d.assertExportSpecifier = Og;
  d.assertExpression = ov;
  d.assertExpressionStatement = RE;
  d.assertExpressionWrapper = Sv;
  d.assertFile = qE;
  d.assertFlow = Kv;
  d.assertFlowBaseAnnotation = Yv;
  d.assertFlowDeclaration = Jv;
  d.assertFlowPredicate = Xv;
  d.assertFlowType = Vv;
  d.assertFor = bv;
  d.assertForInStatement = UE;
  d.assertForOfStatement = _g;
  d.assertForStatement = KE;
  d.assertForXStatement = xv;
  d.assertFunction = Pv;
  d.assertFunctionDeclaration = VE;
  d.assertFunctionExpression = YE;
  d.assertFunctionParent = Ev;
  d.assertFunctionTypeAnnotation = gA;
  d.assertFunctionTypeParam = AA;
  d.assertGenericTypeAnnotation = IA;
  d.assertIdentifier = JE;
  d.assertIfStatement = XE;
  d.assertImmutable = Nv;
  d.assertImport = Wg;
  d.assertImportAttribute = sA;
  d.assertImportDeclaration = Dg;
  d.assertImportDefaultSpecifier = kg;
  d.assertImportExpression = Bg;
  d.assertImportNamespaceSpecifier = Lg;
  d.assertImportOrExportDeclaration = jv;
  d.assertImportSpecifier = Mg;
  d.assertIndexedAccessType = d1;
  d.assertInferredPredicate = vA;
  d.assertInterfaceDeclaration = wA;
  d.assertInterfaceExtends = CA;
  d.assertInterfaceTypeAnnotation = NA;
  d.assertInterpreterDirective = CE;
  d.assertIntersectionTypeAnnotation = OA;
  d.assertJSX = $v;
  d.assertJSXAttribute = y1;
  d.assertJSXClosingElement = T1;
  d.assertJSXClosingFragment = O1;
  d.assertJSXElement = S1;
  d.assertJSXEmptyExpression = b1;
  d.assertJSXExpressionContainer = x1;
  d.assertJSXFragment = w1;
  d.assertJSXIdentifier = E1;
  d.assertJSXMemberExpression = g1;
  d.assertJSXNamespacedName = A1;
  d.assertJSXOpeningElement = I1;
  d.assertJSXOpeningFragment = N1;
  d.assertJSXSpreadAttribute = v1;
  d.assertJSXSpreadChild = P1;
  d.assertJSXText = C1;
  d.assertLVal = vv;
  d.assertLabeledStatement = WE;
  d.assertLiteral = wv;
  d.assertLogicalExpression = ZE;
  d.assertLoop = yv;
  d.assertMemberExpression = eg;
  d.assertMetaProperty = jg;
  d.assertMethod = _v;
  d.assertMiscellaneous = Hv;
  d.assertMixedTypeAnnotation = _A;
  d.assertModuleDeclaration = nC;
  d.assertModuleExpression = K1;
  d.assertModuleSpecifier = Rv;
  d.assertNewExpression = tg;
  d.assertNoop = _1;
  d.assertNullLiteral = HE;
  d.assertNullLiteralTypeAnnotation = uA;
  d.assertNullableTypeAnnotation = kA;
  d.assertNumberLiteral = tC;
  d.assertNumberLiteralTypeAnnotation = LA;
  d.assertNumberTypeAnnotation = MA;
  d.assertNumericLiteral = $E;
  d.assertObjectExpression = ig;
  d.assertObjectMember = Dv;
  d.assertObjectMethod = sg;
  d.assertObjectPattern = Rg;
  d.assertObjectProperty = ng;
  d.assertObjectTypeAnnotation = BA;
  d.assertObjectTypeCallProperty = FA;
  d.assertObjectTypeIndexer = RA;
  d.assertObjectTypeInternalSlot = jA;
  d.assertObjectTypeProperty = qA;
  d.assertObjectTypeSpreadProperty = UA;
  d.assertOpaqueType = KA;
  d.assertOptionalCallExpression = Gg;
  d.assertOptionalIndexedAccessType = m1;
  d.assertOptionalMemberExpression = Hg;
  d.assertParenthesizedExpression = ug;
  d.assertPattern = Mv;
  d.assertPatternLike = Iv;
  d.assertPipelineBareFunction = J1;
  d.assertPipelinePrimaryTopicReference = X1;
  d.assertPipelineTopicExpression = Y1;
  d.assertPlaceholder = D1;
  d.assertPrivate = Uv;
  d.assertPrivateName = rA;
  d.assertProgram = rg;
  d.assertProperty = kv;
  d.assertPureish = gv;
  d.assertQualifiedTypeIdentifier = VA;
  d.assertRecordExpression = R1;
  d.assertRegExpLiteral = QE;
  d.assertRegexLiteral = rC;
  d.assertRestElement = ag;
  d.assertRestProperty = iC;
  d.assertReturnStatement = og;
  d.assertScopable = uv;
  d.assertSequenceExpression = lg;
  d.assertSpreadElement = qg;
  d.assertSpreadProperty = sC;
  d.assertStandardized = av;
  d.assertStatement = fv;
  d.assertStaticBlock = iA;
  d.assertStringLiteral = zE;
  d.assertStringLiteralTypeAnnotation = YA;
  d.assertStringTypeAnnotation = JA;
  d.assertSuper = Ug;
  d.assertSwitchCase = cg;
  d.assertSwitchStatement = pg;
  d.assertSymbolTypeAnnotation = XA;
  d.assertTSAnyKeyword = rI;
  d.assertTSArrayType = EI;
  d.assertTSAsExpression = KI;
  d.assertTSBaseType = eC;
  d.assertTSBigIntKeyword = sI;
  d.assertTSBooleanKeyword = iI;
  d.assertTSCallSignatureDeclaration = G1;
  d.assertTSConditionalType = NI;
  d.assertTSConstructSignatureDeclaration = Q1;
  d.assertTSConstructorType = TI;
  d.assertTSDeclareFunction = z1;
  d.assertTSDeclareMethod = $1;
  d.assertTSEntityName = Cv;
  d.assertTSEnumBody = JI;
  d.assertTSEnumDeclaration = XI;
  d.assertTSEnumMember = WI;
  d.assertTSExportAssignment = ev;
  d.assertTSExpressionWithTypeArguments = jI;
  d.assertTSExternalModuleReference = QI;
  d.assertTSFunctionType = yI;
  d.assertTSImportEqualsDeclaration = GI;
  d.assertTSImportType = HI;
  d.assertTSIndexSignature = tI;
  d.assertTSIndexedAccessType = kI;
  d.assertTSInferType = OI;
  d.assertTSInstantiationExpression = UI;
  d.assertTSInterfaceBody = RI;
  d.assertTSInterfaceDeclaration = FI;
  d.assertTSIntersectionType = wI;
  d.assertTSIntrinsicKeyword = nI;
  d.assertTSLiteralType = BI;
  d.assertTSMappedType = LI;
  d.assertTSMethodSignature = eI;
  d.assertTSModuleBlock = $I;
  d.assertTSModuleDeclaration = zI;
  d.assertTSNamedTupleMember = vI;
  d.assertTSNamespaceExportDeclaration = tv;
  d.assertTSNeverKeyword = aI;
  d.assertTSNonNullExpression = ZI;
  d.assertTSNullKeyword = oI;
  d.assertTSNumberKeyword = lI;
  d.assertTSObjectKeyword = uI;
  d.assertTSOptionalType = AI;
  d.assertTSParameterProperty = W1;
  d.assertTSParenthesizedType = _I;
  d.assertTSPropertySignature = Z1;
  d.assertTSQualifiedName = H1;
  d.assertTSRestType = II;
  d.assertTSSatisfiesExpression = VI;
  d.assertTSStringKeyword = cI;
  d.assertTSSymbolKeyword = pI;
  d.assertTSTemplateLiteralType = MI;
  d.assertTSThisType = mI;
  d.assertTSTupleType = gI;
  d.assertTSType = Zv;
  d.assertTSTypeAliasDeclaration = qI;
  d.assertTSTypeAnnotation = rv;
  d.assertTSTypeAssertion = YI;
  d.assertTSTypeElement = Qv;
  d.assertTSTypeLiteral = PI;
  d.assertTSTypeOperator = DI;
  d.assertTSTypeParameter = nv;
  d.assertTSTypeParameterDeclaration = sv;
  d.assertTSTypeParameterInstantiation = iv;
  d.assertTSTypePredicate = bI;
  d.assertTSTypeQuery = xI;
  d.assertTSTypeReference = SI;
  d.assertTSUndefinedKeyword = fI;
  d.assertTSUnionType = CI;
  d.assertTSUnknownKeyword = hI;
  d.assertTSVoidKeyword = dI;
  d.assertTaggedTemplateExpression = Kg;
  d.assertTemplateElement = Vg;
  d.assertTemplateLiteral = Yg;
  d.assertTerminatorless = hv;
  d.assertThisExpression = fg;
  d.assertThisTypeAnnotation = WA;
  d.assertThrowStatement = hg;
  d.assertTopicReference = V1;
  d.assertTryStatement = dg;
  d.assertTupleExpression = q1;
  d.assertTupleTypeAnnotation = zA;
  d.assertTypeAlias = HA;
  d.assertTypeAnnotation = GA;
  d.assertTypeCastExpression = QA;
  d.assertTypeParameter = ZA;
  d.assertTypeParameterDeclaration = e1;
  d.assertTypeParameterInstantiation = t1;
  d.assertTypeScript = Gv;
  d.assertTypeofTypeAnnotation = $A;
  d.assertUnaryExpression = mg;
  d.assertUnaryLike = Lv;
  d.assertUnionTypeAnnotation = r1;
  d.assertUpdateExpression = yg;
  d.assertUserWhitespacable = Ov;
  d.assertV8IntrinsicIdentifier = k1;
  d.assertVariableDeclaration = Tg;
  d.assertVariableDeclarator = Sg;
  d.assertVariance = i1;
  d.assertVoidTypeAnnotation = s1;
  d.assertWhile = Tv;
  d.assertWhileStatement = bg;
  d.assertWithStatement = xg;
  d.assertYieldExpression = Jg;
  var gE = ir(), Dr = Er();
  function y(t, e, r) {
    if (!(0, gE.default)(t, e, r))
      throw new Error(`Expected type "${t}" with option ${JSON.stringify(r)}, but instead got "${e.type}".`);
  }
  s(y, "assert");
  function AE(t, e) {
    y("ArrayExpression", t, e);
  }
  s(AE, "assertArrayExpression");
  function IE(t, e) {
    y("AssignmentExpression", t, e);
  }
  s(IE, "assertAssignmentExpression");
  function vE(t, e) {
    y("BinaryExpression", t, e);
  }
  s(vE, "assertBinaryExpression");
  function CE(t, e) {
    y("InterpreterDirective", t, e);
  }
  s(CE, "assertInterpreterDirective");
  function wE(t, e) {
    y("Directive", t, e);
  }
  s(wE, "assertDirective");
  function NE(t, e) {
    y("DirectiveLiteral", t, e);
  }
  s(NE, "assertDirectiveLiteral");
  function OE(t, e) {
    y("BlockStatement", t, e);
  }
  s(OE, "assertBlockStatement");
  function _E(t, e) {
    y("BreakStatement", t, e);
  }
  s(_E, "assertBreakStatement");
  function DE(t, e) {
    y("CallExpression", t, e);
  }
  s(DE, "assertCallExpression");
  function kE(t, e) {
    y("CatchClause", t, e);
  }
  s(kE, "assertCatchClause");
  function LE(t, e) {
    y("ConditionalExpression", t, e);
  }
  s(LE, "assertConditionalExpression");
  function ME(t, e) {
    y("ContinueStatement", t, e);
  }
  s(ME, "assertContinueStatement");
  function BE(t, e) {
    y("DebuggerStatement", t, e);
  }
  s(BE, "assertDebuggerStatement");
  function jE(t, e) {
    y("DoWhileStatement", t, e);
  }
  s(jE, "assertDoWhileStatement");
  function FE(t, e) {
    y("EmptyStatement", t, e);
  }
  s(FE, "assertEmptyStatement");
  function RE(t, e) {
    y("ExpressionStatement", t, e);
  }
  s(RE, "assertExpressionStatement");
  function qE(t, e) {
    y("File", t, e);
  }
  s(qE, "assertFile");
  function UE(t, e) {
    y("ForInStatement", t, e);
  }
  s(UE, "assertForInStatement");
  function KE(t, e) {
    y("ForStatement", t, e);
  }
  s(KE, "assertForStatement");
  function VE(t, e) {
    y("FunctionDeclaration", t, e);
  }
  s(VE, "assertFunctionDeclaration");
  function YE(t, e) {
    y("FunctionExpression", t, e);
  }
  s(YE, "assertFunctionExpression");
  function JE(t, e) {
    y("Identifier", t, e);
  }
  s(JE, "assertIdentifier");
  function XE(t, e) {
    y("IfStatement", t, e);
  }
  s(XE, "assertIfStatement");
  function WE(t, e) {
    y("LabeledStatement", t, e);
  }
  s(WE, "assertLabeledStatement");
  function zE(t, e) {
    y("StringLiteral", t, e);
  }
  s(zE, "assertStringLiteral");
  function $E(t, e) {
    y("NumericLiteral", t, e);
  }
  s($E, "assertNumericLiteral");
  function HE(t, e) {
    y("NullLiteral", t, e);
  }
  s(HE, "assertNullLiteral");
  function GE(t, e) {
    y("BooleanLiteral", t, e);
  }
  s(GE, "assertBooleanLiteral");
  function QE(t, e) {
    y("RegExpLiteral", t, e);
  }
  s(QE, "assertRegExpLiteral");
  function ZE(t, e) {
    y("LogicalExpression", t, e);
  }
  s(ZE, "assertLogicalExpression");
  function eg(t, e) {
    y("MemberExpression", t, e);
  }
  s(eg, "assertMemberExpression");
  function tg(t, e) {
    y("NewExpression", t, e);
  }
  s(tg, "assertNewExpression");
  function rg(t, e) {
    y("Program", t, e);
  }
  s(rg, "assertProgram");
  function ig(t, e) {
    y("ObjectExpression", t, e);
  }
  s(ig, "assertObjectExpression");
  function sg(t, e) {
    y("ObjectMethod", t, e);
  }
  s(sg, "assertObjectMethod");
  function ng(t, e) {
    y("ObjectProperty", t, e);
  }
  s(ng, "assertObjectProperty");
  function ag(t, e) {
    y("RestElement", t, e);
  }
  s(ag, "assertRestElement");
  function og(t, e) {
    y("ReturnStatement", t, e);
  }
  s(og, "assertReturnStatement");
  function lg(t, e) {
    y("SequenceExpression", t, e);
  }
  s(lg, "assertSequenceExpression");
  function ug(t, e) {
    y("ParenthesizedExpression", t, e);
  }
  s(ug, "assertParenthesizedExpression");
  function cg(t, e) {
    y("SwitchCase", t, e);
  }
  s(cg, "assertSwitchCase");
  function pg(t, e) {
    y("SwitchStatement", t, e);
  }
  s(pg, "assertSwitchStatement");
  function fg(t, e) {
    y("ThisExpression", t, e);
  }
  s(fg, "assertThisExpression");
  function hg(t, e) {
    y("ThrowStatement", t, e);
  }
  s(hg, "assertThrowStatement");
  function dg(t, e) {
    y("TryStatement", t, e);
  }
  s(dg, "assertTryStatement");
  function mg(t, e) {
    y("UnaryExpression", t, e);
  }
  s(mg, "assertUnaryExpression");
  function yg(t, e) {
    y("UpdateExpression", t, e);
  }
  s(yg, "assertUpdateExpression");
  function Tg(t, e) {
    y("VariableDeclaration", t, e);
  }
  s(Tg, "assertVariableDeclaration");
  function Sg(t, e) {
    y("VariableDeclarator", t, e);
  }
  s(Sg, "assertVariableDeclarator");
  function bg(t, e) {
    y("WhileStatement", t, e);
  }
  s(bg, "assertWhileStatement");
  function xg(t, e) {
    y("WithStatement", t, e);
  }
  s(xg, "assertWithStatement");
  function Pg(t, e) {
    y("AssignmentPattern", t, e);
  }
  s(Pg, "assertAssignmentPattern");
  function Eg(t, e) {
    y("ArrayPattern", t, e);
  }
  s(Eg, "assertArrayPattern");
  function gg(t, e) {
    y("ArrowFunctionExpression", t, e);
  }
  s(gg, "assertArrowFunctionExpression");
  function Ag(t, e) {
    y("ClassBody", t, e);
  }
  s(Ag, "assertClassBody");
  function Ig(t, e) {
    y("ClassExpression", t, e);
  }
  s(Ig, "assertClassExpression");
  function vg(t, e) {
    y("ClassDeclaration", t, e);
  }
  s(vg, "assertClassDeclaration");
  function Cg(t, e) {
    y("ExportAllDeclaration", t, e);
  }
  s(Cg, "assertExportAllDeclaration");
  function wg(t, e) {
    y("ExportDefaultDeclaration", t, e);
  }
  s(wg, "assertExportDefaultDeclaration");
  function Ng(t, e) {
    y("ExportNamedDeclaration", t, e);
  }
  s(Ng, "assertExportNamedDeclaration");
  function Og(t, e) {
    y("ExportSpecifier", t, e);
  }
  s(Og, "assertExportSpecifier");
  function _g(t, e) {
    y("ForOfStatement", t, e);
  }
  s(_g, "assertForOfStatement");
  function Dg(t, e) {
    y("ImportDeclaration", t, e);
  }
  s(Dg, "assertImportDeclaration");
  function kg(t, e) {
    y("ImportDefaultSpecifier", t, e);
  }
  s(kg, "assertImportDefaultSpecifier");
  function Lg(t, e) {
    y("ImportNamespaceSpecifier", t, e);
  }
  s(Lg, "assertImportNamespaceSpecifier");
  function Mg(t, e) {
    y("ImportSpecifier", t, e);
  }
  s(Mg, "assertImportSpecifier");
  function Bg(t, e) {
    y("ImportExpression", t, e);
  }
  s(Bg, "assertImportExpression");
  function jg(t, e) {
    y("MetaProperty", t, e);
  }
  s(jg, "assertMetaProperty");
  function Fg(t, e) {
    y("ClassMethod", t, e);
  }
  s(Fg, "assertClassMethod");
  function Rg(t, e) {
    y("ObjectPattern", t, e);
  }
  s(Rg, "assertObjectPattern");
  function qg(t, e) {
    y("SpreadElement", t, e);
  }
  s(qg, "assertSpreadElement");
  function Ug(t, e) {
    y("Super", t, e);
  }
  s(Ug, "assertSuper");
  function Kg(t, e) {
    y("TaggedTemplateExpression", t, e);
  }
  s(Kg, "assertTaggedTemplateExpression");
  function Vg(t, e) {
    y("TemplateElement", t, e);
  }
  s(Vg, "assertTemplateElement");
  function Yg(t, e) {
    y("TemplateLiteral", t, e);
  }
  s(Yg, "assertTemplateLiteral");
  function Jg(t, e) {
    y("YieldExpression", t, e);
  }
  s(Jg, "assertYieldExpression");
  function Xg(t, e) {
    y("AwaitExpression", t, e);
  }
  s(Xg, "assertAwaitExpression");
  function Wg(t, e) {
    y("Import", t, e);
  }
  s(Wg, "assertImport");
  function zg(t, e) {
    y("BigIntLiteral", t, e);
  }
  s(zg, "assertBigIntLiteral");
  function $g(t, e) {
    y("ExportNamespaceSpecifier", t, e);
  }
  s($g, "assertExportNamespaceSpecifier");
  function Hg(t, e) {
    y("OptionalMemberExpression", t, e);
  }
  s(Hg, "assertOptionalMemberExpression");
  function Gg(t, e) {
    y("OptionalCallExpression", t, e);
  }
  s(Gg, "assertOptionalCallExpression");
  function Qg(t, e) {
    y("ClassProperty", t, e);
  }
  s(Qg, "assertClassProperty");
  function Zg(t, e) {
    y("ClassAccessorProperty", t, e);
  }
  s(Zg, "assertClassAccessorProperty");
  function eA(t, e) {
    y("ClassPrivateProperty", t, e);
  }
  s(eA, "assertClassPrivateProperty");
  function tA(t, e) {
    y("ClassPrivateMethod", t, e);
  }
  s(tA, "assertClassPrivateMethod");
  function rA(t, e) {
    y("PrivateName", t, e);
  }
  s(rA, "assertPrivateName");
  function iA(t, e) {
    y("StaticBlock", t, e);
  }
  s(iA, "assertStaticBlock");
  function sA(t, e) {
    y("ImportAttribute", t, e);
  }
  s(sA, "assertImportAttribute");
  function nA(t, e) {
    y("AnyTypeAnnotation", t, e);
  }
  s(nA, "assertAnyTypeAnnotation");
  function aA(t, e) {
    y("ArrayTypeAnnotation", t, e);
  }
  s(aA, "assertArrayTypeAnnotation");
  function oA(t, e) {
    y("BooleanTypeAnnotation", t, e);
  }
  s(oA, "assertBooleanTypeAnnotation");
  function lA(t, e) {
    y("BooleanLiteralTypeAnnotation", t, e);
  }
  s(lA, "assertBooleanLiteralTypeAnnotation");
  function uA(t, e) {
    y("NullLiteralTypeAnnotation", t, e);
  }
  s(uA, "assertNullLiteralTypeAnnotation");
  function cA(t, e) {
    y("ClassImplements", t, e);
  }
  s(cA, "assertClassImplements");
  function pA(t, e) {
    y("DeclareClass", t, e);
  }
  s(pA, "assertDeclareClass");
  function fA(t, e) {
    y("DeclareFunction", t, e);
  }
  s(fA, "assertDeclareFunction");
  function hA(t, e) {
    y("DeclareInterface", t, e);
  }
  s(hA, "assertDeclareInterface");
  function dA(t, e) {
    y("DeclareModule", t, e);
  }
  s(dA, "assertDeclareModule");
  function mA(t, e) {
    y("DeclareModuleExports", t, e);
  }
  s(mA, "assertDeclareModuleExports");
  function yA(t, e) {
    y("DeclareTypeAlias", t, e);
  }
  s(yA, "assertDeclareTypeAlias");
  function TA(t, e) {
    y("DeclareOpaqueType", t, e);
  }
  s(TA, "assertDeclareOpaqueType");
  function SA(t, e) {
    y("DeclareVariable", t, e);
  }
  s(SA, "assertDeclareVariable");
  function bA(t, e) {
    y("DeclareExportDeclaration", t, e);
  }
  s(bA, "assertDeclareExportDeclaration");
  function xA(t, e) {
    y("DeclareExportAllDeclaration", t, e);
  }
  s(xA, "assertDeclareExportAllDeclaration");
  function PA(t, e) {
    y("DeclaredPredicate", t, e);
  }
  s(PA, "assertDeclaredPredicate");
  function EA(t, e) {
    y("ExistsTypeAnnotation", t, e);
  }
  s(EA, "assertExistsTypeAnnotation");
  function gA(t, e) {
    y("FunctionTypeAnnotation", t, e);
  }
  s(gA, "assertFunctionTypeAnnotation");
  function AA(t, e) {
    y("FunctionTypeParam", t, e);
  }
  s(AA, "assertFunctionTypeParam");
  function IA(t, e) {
    y("GenericTypeAnnotation", t, e);
  }
  s(IA, "assertGenericTypeAnnotation");
  function vA(t, e) {
    y("InferredPredicate", t, e);
  }
  s(vA, "assertInferredPredicate");
  function CA(t, e) {
    y("InterfaceExtends", t, e);
  }
  s(CA, "assertInterfaceExtends");
  function wA(t, e) {
    y("InterfaceDeclaration", t, e);
  }
  s(wA, "assertInterfaceDeclaration");
  function NA(t, e) {
    y("InterfaceTypeAnnotation", t, e);
  }
  s(NA, "assertInterfaceTypeAnnotation");
  function OA(t, e) {
    y("IntersectionTypeAnnotation", t, e);
  }
  s(OA, "assertIntersectionTypeAnnotation");
  function _A(t, e) {
    y("MixedTypeAnnotation", t, e);
  }
  s(_A, "assertMixedTypeAnnotation");
  function DA(t, e) {
    y("EmptyTypeAnnotation", t, e);
  }
  s(DA, "assertEmptyTypeAnnotation");
  function kA(t, e) {
    y("NullableTypeAnnotation", t, e);
  }
  s(kA, "assertNullableTypeAnnotation");
  function LA(t, e) {
    y("NumberLiteralTypeAnnotation", t, e);
  }
  s(LA, "assertNumberLiteralTypeAnnotation");
  function MA(t, e) {
    y("NumberTypeAnnotation", t, e);
  }
  s(MA, "assertNumberTypeAnnotation");
  function BA(t, e) {
    y("ObjectTypeAnnotation", t, e);
  }
  s(BA, "assertObjectTypeAnnotation");
  function jA(t, e) {
    y("ObjectTypeInternalSlot", t, e);
  }
  s(jA, "assertObjectTypeInternalSlot");
  function FA(t, e) {
    y("ObjectTypeCallProperty", t, e);
  }
  s(FA, "assertObjectTypeCallProperty");
  function RA(t, e) {
    y("ObjectTypeIndexer", t, e);
  }
  s(RA, "assertObjectTypeIndexer");
  function qA(t, e) {
    y("ObjectTypeProperty", t, e);
  }
  s(qA, "assertObjectTypeProperty");
  function UA(t, e) {
    y("ObjectTypeSpreadProperty", t, e);
  }
  s(UA, "assertObjectTypeSpreadProperty");
  function KA(t, e) {
    y("OpaqueType", t, e);
  }
  s(KA, "assertOpaqueType");
  function VA(t, e) {
    y("QualifiedTypeIdentifier", t, e);
  }
  s(VA, "assertQualifiedTypeIdentifier");
  function YA(t, e) {
    y("StringLiteralTypeAnnotation", t, e);
  }
  s(YA, "assertStringLiteralTypeAnnotation");
  function JA(t, e) {
    y("StringTypeAnnotation", t, e);
  }
  s(JA, "assertStringTypeAnnotation");
  function XA(t, e) {
    y("SymbolTypeAnnotation", t, e);
  }
  s(XA, "assertSymbolTypeAnnotation");
  function WA(t, e) {
    y("ThisTypeAnnotation", t, e);
  }
  s(WA, "assertThisTypeAnnotation");
  function zA(t, e) {
    y("TupleTypeAnnotation", t, e);
  }
  s(zA, "assertTupleTypeAnnotation");
  function $A(t, e) {
    y("TypeofTypeAnnotation", t, e);
  }
  s($A, "assertTypeofTypeAnnotation");
  function HA(t, e) {
    y("TypeAlias", t, e);
  }
  s(HA, "assertTypeAlias");
  function GA(t, e) {
    y("TypeAnnotation", t, e);
  }
  s(GA, "assertTypeAnnotation");
  function QA(t, e) {
    y("TypeCastExpression", t, e);
  }
  s(QA, "assertTypeCastExpression");
  function ZA(t, e) {
    y("TypeParameter", t, e);
  }
  s(ZA, "assertTypeParameter");
  function e1(t, e) {
    y("TypeParameterDeclaration", t, e);
  }
  s(e1, "assertTypeParameterDeclaration");
  function t1(t, e) {
    y("TypeParameterInstantiation", t, e);
  }
  s(t1, "assertTypeParameterInstantiation");
  function r1(t, e) {
    y("UnionTypeAnnotation", t, e);
  }
  s(r1, "assertUnionTypeAnnotation");
  function i1(t, e) {
    y("Variance", t, e);
  }
  s(i1, "assertVariance");
  function s1(t, e) {
    y("VoidTypeAnnotation", t, e);
  }
  s(s1, "assertVoidTypeAnnotation");
  function n1(t, e) {
    y("EnumDeclaration", t, e);
  }
  s(n1, "assertEnumDeclaration");
  function a1(t, e) {
    y("EnumBooleanBody", t, e);
  }
  s(a1, "assertEnumBooleanBody");
  function o1(t, e) {
    y("EnumNumberBody", t, e);
  }
  s(o1, "assertEnumNumberBody");
  function l1(t, e) {
    y("EnumStringBody", t, e);
  }
  s(l1, "assertEnumStringBody");
  function u1(t, e) {
    y("EnumSymbolBody", t, e);
  }
  s(u1, "assertEnumSymbolBody");
  function c1(t, e) {
    y("EnumBooleanMember", t, e);
  }
  s(c1, "assertEnumBooleanMember");
  function p1(t, e) {
    y("EnumNumberMember", t, e);
  }
  s(p1, "assertEnumNumberMember");
  function f1(t, e) {
    y("EnumStringMember", t, e);
  }
  s(f1, "assertEnumStringMember");
  function h1(t, e) {
    y("EnumDefaultedMember", t, e);
  }
  s(h1, "assertEnumDefaultedMember");
  function d1(t, e) {
    y("IndexedAccessType", t, e);
  }
  s(d1, "assertIndexedAccessType");
  function m1(t, e) {
    y("OptionalIndexedAccessType", t, e);
  }
  s(m1, "assertOptionalIndexedAccessType");
  function y1(t, e) {
    y("JSXAttribute", t, e);
  }
  s(y1, "assertJSXAttribute");
  function T1(t, e) {
    y("JSXClosingElement", t, e);
  }
  s(T1, "assertJSXClosingElement");
  function S1(t, e) {
    y("JSXElement", t, e);
  }
  s(S1, "assertJSXElement");
  function b1(t, e) {
    y("JSXEmptyExpression", t, e);
  }
  s(b1, "assertJSXEmptyExpression");
  function x1(t, e) {
    y("JSXExpressionContainer", t, e);
  }
  s(x1, "assertJSXExpressionContainer");
  function P1(t, e) {
    y("JSXSpreadChild", t, e);
  }
  s(P1, "assertJSXSpreadChild");
  function E1(t, e) {
    y("JSXIdentifier", t, e);
  }
  s(E1, "assertJSXIdentifier");
  function g1(t, e) {
    y("JSXMemberExpression", t, e);
  }
  s(g1, "assertJSXMemberExpression");
  function A1(t, e) {
    y("JSXNamespacedName", t, e);
  }
  s(A1, "assertJSXNamespacedName");
  function I1(t, e) {
    y("JSXOpeningElement", t, e);
  }
  s(I1, "assertJSXOpeningElement");
  function v1(t, e) {
    y("JSXSpreadAttribute", t, e);
  }
  s(v1, "assertJSXSpreadAttribute");
  function C1(t, e) {
    y("JSXText", t, e);
  }
  s(C1, "assertJSXText");
  function w1(t, e) {
    y("JSXFragment", t, e);
  }
  s(w1, "assertJSXFragment");
  function N1(t, e) {
    y("JSXOpeningFragment", t, e);
  }
  s(N1, "assertJSXOpeningFragment");
  function O1(t, e) {
    y("JSXClosingFragment", t, e);
  }
  s(O1, "assertJSXClosingFragment");
  function _1(t, e) {
    y("Noop", t, e);
  }
  s(_1, "assertNoop");
  function D1(t, e) {
    y("Placeholder", t, e);
  }
  s(D1, "assertPlaceholder");
  function k1(t, e) {
    y("V8IntrinsicIdentifier", t, e);
  }
  s(k1, "assertV8IntrinsicIdentifier");
  function L1(t, e) {
    y("ArgumentPlaceholder", t, e);
  }
  s(L1, "assertArgumentPlaceholder");
  function M1(t, e) {
    y("BindExpression", t, e);
  }
  s(M1, "assertBindExpression");
  function B1(t, e) {
    y("Decorator", t, e);
  }
  s(B1, "assertDecorator");
  function j1(t, e) {
    y("DoExpression", t, e);
  }
  s(j1, "assertDoExpression");
  function F1(t, e) {
    y("ExportDefaultSpecifier", t, e);
  }
  s(F1, "assertExportDefaultSpecifier");
  function R1(t, e) {
    y("RecordExpression", t, e);
  }
  s(R1, "assertRecordExpression");
  function q1(t, e) {
    y("TupleExpression", t, e);
  }
  s(q1, "assertTupleExpression");
  function U1(t, e) {
    y("DecimalLiteral", t, e);
  }
  s(U1, "assertDecimalLiteral");
  function K1(t, e) {
    y("ModuleExpression", t, e);
  }
  s(K1, "assertModuleExpression");
  function V1(t, e) {
    y("TopicReference", t, e);
  }
  s(V1, "assertTopicReference");
  function Y1(t, e) {
    y("PipelineTopicExpression", t, e);
  }
  s(Y1, "assertPipelineTopicExpression");
  function J1(t, e) {
    y("PipelineBareFunction", t, e);
  }
  s(J1, "assertPipelineBareFunction");
  function X1(t, e) {
    y("PipelinePrimaryTopicReference", t, e);
  }
  s(X1, "assertPipelinePrimaryTopicReference");
  function W1(t, e) {
    y("TSParameterProperty", t, e);
  }
  s(W1, "assertTSParameterProperty");
  function z1(t, e) {
    y("TSDeclareFunction", t, e);
  }
  s(z1, "assertTSDeclareFunction");
  function $1(t, e) {
    y("TSDeclareMethod", t, e);
  }
  s($1, "assertTSDeclareMethod");
  function H1(t, e) {
    y("TSQualifiedName", t, e);
  }
  s(H1, "assertTSQualifiedName");
  function G1(t, e) {
    y("TSCallSignatureDeclaration", t, e);
  }
  s(G1, "assertTSCallSignatureDeclaration");
  function Q1(t, e) {
    y("TSConstructSignatureDeclaration", t, e);
  }
  s(Q1, "assertTSConstructSignatureDeclaration");
  function Z1(t, e) {
    y("TSPropertySignature", t, e);
  }
  s(Z1, "assertTSPropertySignature");
  function eI(t, e) {
    y("TSMethodSignature", t, e);
  }
  s(eI, "assertTSMethodSignature");
  function tI(t, e) {
    y("TSIndexSignature", t, e);
  }
  s(tI, "assertTSIndexSignature");
  function rI(t, e) {
    y("TSAnyKeyword", t, e);
  }
  s(rI, "assertTSAnyKeyword");
  function iI(t, e) {
    y("TSBooleanKeyword", t, e);
  }
  s(iI, "assertTSBooleanKeyword");
  function sI(t, e) {
    y("TSBigIntKeyword", t, e);
  }
  s(sI, "assertTSBigIntKeyword");
  function nI(t, e) {
    y("TSIntrinsicKeyword", t, e);
  }
  s(nI, "assertTSIntrinsicKeyword");
  function aI(t, e) {
    y("TSNeverKeyword", t, e);
  }
  s(aI, "assertTSNeverKeyword");
  function oI(t, e) {
    y("TSNullKeyword", t, e);
  }
  s(oI, "assertTSNullKeyword");
  function lI(t, e) {
    y("TSNumberKeyword", t, e);
  }
  s(lI, "assertTSNumberKeyword");
  function uI(t, e) {
    y("TSObjectKeyword", t, e);
  }
  s(uI, "assertTSObjectKeyword");
  function cI(t, e) {
    y("TSStringKeyword", t, e);
  }
  s(cI, "assertTSStringKeyword");
  function pI(t, e) {
    y("TSSymbolKeyword", t, e);
  }
  s(pI, "assertTSSymbolKeyword");
  function fI(t, e) {
    y("TSUndefinedKeyword", t, e);
  }
  s(fI, "assertTSUndefinedKeyword");
  function hI(t, e) {
    y("TSUnknownKeyword", t, e);
  }
  s(hI, "assertTSUnknownKeyword");
  function dI(t, e) {
    y("TSVoidKeyword", t, e);
  }
  s(dI, "assertTSVoidKeyword");
  function mI(t, e) {
    y("TSThisType", t, e);
  }
  s(mI, "assertTSThisType");
  function yI(t, e) {
    y("TSFunctionType", t, e);
  }
  s(yI, "assertTSFunctionType");
  function TI(t, e) {
    y("TSConstructorType", t, e);
  }
  s(TI, "assertTSConstructorType");
  function SI(t, e) {
    y("TSTypeReference", t, e);
  }
  s(SI, "assertTSTypeReference");
  function bI(t, e) {
    y("TSTypePredicate", t, e);
  }
  s(bI, "assertTSTypePredicate");
  function xI(t, e) {
    y("TSTypeQuery", t, e);
  }
  s(xI, "assertTSTypeQuery");
  function PI(t, e) {
    y("TSTypeLiteral", t, e);
  }
  s(PI, "assertTSTypeLiteral");
  function EI(t, e) {
    y("TSArrayType", t, e);
  }
  s(EI, "assertTSArrayType");
  function gI(t, e) {
    y("TSTupleType", t, e);
  }
  s(gI, "assertTSTupleType");
  function AI(t, e) {
    y("TSOptionalType", t, e);
  }
  s(AI, "assertTSOptionalType");
  function II(t, e) {
    y("TSRestType", t, e);
  }
  s(II, "assertTSRestType");
  function vI(t, e) {
    y("TSNamedTupleMember", t, e);
  }
  s(vI, "assertTSNamedTupleMember");
  function CI(t, e) {
    y("TSUnionType", t, e);
  }
  s(CI, "assertTSUnionType");
  function wI(t, e) {
    y("TSIntersectionType", t, e);
  }
  s(wI, "assertTSIntersectionType");
  function NI(t, e) {
    y("TSConditionalType", t, e);
  }
  s(NI, "assertTSConditionalType");
  function OI(t, e) {
    y("TSInferType", t, e);
  }
  s(OI, "assertTSInferType");
  function _I(t, e) {
    y("TSParenthesizedType", t, e);
  }
  s(_I, "assertTSParenthesizedType");
  function DI(t, e) {
    y("TSTypeOperator", t, e);
  }
  s(DI, "assertTSTypeOperator");
  function kI(t, e) {
    y("TSIndexedAccessType", t, e);
  }
  s(kI, "assertTSIndexedAccessType");
  function LI(t, e) {
    y("TSMappedType", t, e);
  }
  s(LI, "assertTSMappedType");
  function MI(t, e) {
    y("TSTemplateLiteralType", t, e);
  }
  s(MI, "assertTSTemplateLiteralType");
  function BI(t, e) {
    y("TSLiteralType", t, e);
  }
  s(BI, "assertTSLiteralType");
  function jI(t, e) {
    y("TSExpressionWithTypeArguments", t, e);
  }
  s(jI, "assertTSExpressionWithTypeArguments");
  function FI(t, e) {
    y("TSInterfaceDeclaration", t, e);
  }
  s(FI, "assertTSInterfaceDeclaration");
  function RI(t, e) {
    y("TSInterfaceBody", t, e);
  }
  s(RI, "assertTSInterfaceBody");
  function qI(t, e) {
    y("TSTypeAliasDeclaration", t, e);
  }
  s(qI, "assertTSTypeAliasDeclaration");
  function UI(t, e) {
    y("TSInstantiationExpression", t, e);
  }
  s(UI, "assertTSInstantiationExpression");
  function KI(t, e) {
    y("TSAsExpression", t, e);
  }
  s(KI, "assertTSAsExpression");
  function VI(t, e) {
    y("TSSatisfiesExpression", t, e);
  }
  s(VI, "assertTSSatisfiesExpression");
  function YI(t, e) {
    y("TSTypeAssertion", t, e);
  }
  s(YI, "assertTSTypeAssertion");
  function JI(t, e) {
    y("TSEnumBody", t, e);
  }
  s(JI, "assertTSEnumBody");
  function XI(t, e) {
    y("TSEnumDeclaration", t, e);
  }
  s(XI, "assertTSEnumDeclaration");
  function WI(t, e) {
    y("TSEnumMember", t, e);
  }
  s(WI, "assertTSEnumMember");
  function zI(t, e) {
    y("TSModuleDeclaration", t, e);
  }
  s(zI, "assertTSModuleDeclaration");
  function $I(t, e) {
    y("TSModuleBlock", t, e);
  }
  s($I, "assertTSModuleBlock");
  function HI(t, e) {
    y("TSImportType", t, e);
  }
  s(HI, "assertTSImportType");
  function GI(t, e) {
    y("TSImportEqualsDeclaration", t, e);
  }
  s(GI, "assertTSImportEqualsDeclaration");
  function QI(t, e) {
    y("TSExternalModuleReference", t, e);
  }
  s(QI, "assertTSExternalModuleReference");
  function ZI(t, e) {
    y("TSNonNullExpression", t, e);
  }
  s(ZI, "assertTSNonNullExpression");
  function ev(t, e) {
    y("TSExportAssignment", t, e);
  }
  s(ev, "assertTSExportAssignment");
  function tv(t, e) {
    y("TSNamespaceExportDeclaration", t, e);
  }
  s(tv, "assertTSNamespaceExportDeclaration");
  function rv(t, e) {
    y("TSTypeAnnotation", t, e);
  }
  s(rv, "assertTSTypeAnnotation");
  function iv(t, e) {
    y("TSTypeParameterInstantiation", t, e);
  }
  s(iv, "assertTSTypeParameterInstantiation");
  function sv(t, e) {
    y("TSTypeParameterDeclaration", t, e);
  }
  s(sv, "assertTSTypeParameterDeclaration");
  function nv(t, e) {
    y("TSTypeParameter", t, e);
  }
  s(nv, "assertTSTypeParameter");
  function av(t, e) {
    y("Standardized", t, e);
  }
  s(av, "assertStandardized");
  function ov(t, e) {
    y("Expression", t, e);
  }
  s(ov, "assertExpression");
  function lv(t, e) {
    y("Binary", t, e);
  }
  s(lv, "assertBinary");
  function uv(t, e) {
    y("Scopable", t, e);
  }
  s(uv, "assertScopable");
  function cv(t, e) {
    y("BlockParent", t, e);
  }
  s(cv, "assertBlockParent");
  function pv(t, e) {
    y("Block", t, e);
  }
  s(pv, "assertBlock");
  function fv(t, e) {
    y("Statement", t, e);
  }
  s(fv, "assertStatement");
  function hv(t, e) {
    y("Terminatorless", t, e);
  }
  s(hv, "assertTerminatorless");
  function dv(t, e) {
    y("CompletionStatement", t, e);
  }
  s(dv, "assertCompletionStatement");
  function mv(t, e) {
    y("Conditional", t, e);
  }
  s(mv, "assertConditional");
  function yv(t, e) {
    y("Loop", t, e);
  }
  s(yv, "assertLoop");
  function Tv(t, e) {
    y("While", t, e);
  }
  s(Tv, "assertWhile");
  function Sv(t, e) {
    y("ExpressionWrapper", t, e);
  }
  s(Sv, "assertExpressionWrapper");
  function bv(t, e) {
    y("For", t, e);
  }
  s(bv, "assertFor");
  function xv(t, e) {
    y("ForXStatement", t, e);
  }
  s(xv, "assertForXStatement");
  function Pv(t, e) {
    y("Function", t, e);
  }
  s(Pv, "assertFunction");
  function Ev(t, e) {
    y("FunctionParent", t, e);
  }
  s(Ev, "assertFunctionParent");
  function gv(t, e) {
    y("Pureish", t, e);
  }
  s(gv, "assertPureish");
  function Av(t, e) {
    y("Declaration", t, e);
  }
  s(Av, "assertDeclaration");
  function Iv(t, e) {
    y("PatternLike", t, e);
  }
  s(Iv, "assertPatternLike");
  function vv(t, e) {
    y("LVal", t, e);
  }
  s(vv, "assertLVal");
  function Cv(t, e) {
    y("TSEntityName", t, e);
  }
  s(Cv, "assertTSEntityName");
  function wv(t, e) {
    y("Literal", t, e);
  }
  s(wv, "assertLiteral");
  function Nv(t, e) {
    y("Immutable", t, e);
  }
  s(Nv, "assertImmutable");
  function Ov(t, e) {
    y("UserWhitespacable", t, e);
  }
  s(Ov, "assertUserWhitespacable");
  function _v(t, e) {
    y("Method", t, e);
  }
  s(_v, "assertMethod");
  function Dv(t, e) {
    y("ObjectMember", t, e);
  }
  s(Dv, "assertObjectMember");
  function kv(t, e) {
    y("Property", t, e);
  }
  s(kv, "assertProperty");
  function Lv(t, e) {
    y("UnaryLike", t, e);
  }
  s(Lv, "assertUnaryLike");
  function Mv(t, e) {
    y("Pattern", t, e);
  }
  s(Mv, "assertPattern");
  function Bv(t, e) {
    y("Class", t, e);
  }
  s(Bv, "assertClass");
  function jv(t, e) {
    y("ImportOrExportDeclaration", t, e);
  }
  s(jv, "assertImportOrExportDeclaration");
  function Fv(t, e) {
    y("ExportDeclaration", t, e);
  }
  s(Fv, "assertExportDeclaration");
  function Rv(t, e) {
    y("ModuleSpecifier", t, e);
  }
  s(Rv, "assertModuleSpecifier");
  function qv(t, e) {
    y("Accessor", t, e);
  }
  s(qv, "assertAccessor");
  function Uv(t, e) {
    y("Private", t, e);
  }
  s(Uv, "assertPrivate");
  function Kv(t, e) {
    y("Flow", t, e);
  }
  s(Kv, "assertFlow");
  function Vv(t, e) {
    y("FlowType", t, e);
  }
  s(Vv, "assertFlowType");
  function Yv(t, e) {
    y("FlowBaseAnnotation", t, e);
  }
  s(Yv, "assertFlowBaseAnnotation");
  function Jv(t, e) {
    y("FlowDeclaration", t, e);
  }
  s(Jv, "assertFlowDeclaration");
  function Xv(t, e) {
    y("FlowPredicate", t, e);
  }
  s(Xv, "assertFlowPredicate");
  function Wv(t, e) {
    y("EnumBody", t, e);
  }
  s(Wv, "assertEnumBody");
  function zv(t, e) {
    y("EnumMember", t, e);
  }
  s(zv, "assertEnumMember");
  function $v(t, e) {
    y("JSX", t, e);
  }
  s($v, "assertJSX");
  function Hv(t, e) {
    y("Miscellaneous", t, e);
  }
  s(Hv, "assertMiscellaneous");
  function Gv(t, e) {
    y("TypeScript", t, e);
  }
  s(Gv, "assertTypeScript");
  function Qv(t, e) {
    y("TSTypeElement", t, e);
  }
  s(Qv, "assertTSTypeElement");
  function Zv(t, e) {
    y("TSType", t, e);
  }
  s(Zv, "assertTSType");
  function eC(t, e) {
    y("TSBaseType", t, e);
  }
  s(eC, "assertTSBaseType");
  function tC(t, e) {
    (0, Dr.default)("assertNumberLiteral", "assertNumericLiteral"), y("NumberLiteral", t, e);
  }
  s(tC, "assertNumberLiteral");
  function rC(t, e) {
    (0, Dr.default)("assertRegexLiteral", "assertRegExpLiteral"), y("RegexLiteral", t, e);
  }
  s(rC, "assertRegexLiteral");
  function iC(t, e) {
    (0, Dr.default)("assertRestProperty", "assertRestElement"), y("RestProperty", t, e);
  }
  s(iC, "assertRestProperty");
  function sC(t, e) {
    (0, Dr.default)("assertSpreadProperty", "assertSpreadElement"), y("SpreadProperty", t, e);
  }
  s(sC, "assertSpreadProperty");
  function nC(t, e) {
    (0, Dr.default)("assertModuleDeclaration", "assertImportOrExportDeclaration"), y("ModuleDeclaration", t, e);
  }
  s(nC, "assertModuleDeclaration");
});

// ../node_modules/@babel/types/lib/builders/flow/createTypeAnnotationBasedOnTypeof.js
var Rl = O((Pi) => {
  "use strict";
  Object.defineProperty(Pi, "__esModule", {
    value: !0
  });
  Pi.default = void 0;
  var dt = it(), fF = Pi.default = aC;
  function aC(t) {
    switch (t) {
      case "string":
        return (0, dt.stringTypeAnnotation)();
      case "number":
        return (0, dt.numberTypeAnnotation)();
      case "undefined":
        return (0, dt.voidTypeAnnotation)();
      case "boolean":
        return (0, dt.booleanTypeAnnotation)();
      case "function":
        return (0, dt.genericTypeAnnotation)((0, dt.identifier)("Function"));
      case "object":
        return (0, dt.genericTypeAnnotation)((0, dt.identifier)("Object"));
      case "symbol":
        return (0, dt.genericTypeAnnotation)((0, dt.identifier)("Symbol"));
      case "bigint":
        return (0, dt.anyTypeAnnotation)();
    }
    throw new Error("Invalid typeof value: " + t);
  }
  s(aC, "createTypeAnnotationBasedOnTypeof");
});

// ../node_modules/@babel/types/lib/modifications/flow/removeTypeDuplicates.js
var tn = O((en) => {
  "use strict";
  Object.defineProperty(en, "__esModule", {
    value: !0
  });
  en.default = Ul;
  var kr = Be();
  function ql(t) {
    return (0, kr.isIdentifier)(t) ? t.name : `${t.id.name}.${ql(t.qualification)}`;
  }
  s(ql, "getQualifiedName");
  function Ul(t) {
    let e = Array.from(t), r = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Set(), a = [];
    for (let o = 0; o < e.length; o++) {
      let l = e[o];
      if (l && !a.includes(l)) {
        if ((0, kr.isAnyTypeAnnotation)(l))
          return [l];
        if ((0, kr.isFlowBaseAnnotation)(l)) {
          i.set(l.type, l);
          continue;
        }
        if ((0, kr.isUnionTypeAnnotation)(l)) {
          n.has(l.types) || (e.push(...l.types), n.add(l.types));
          continue;
        }
        if ((0, kr.isGenericTypeAnnotation)(l)) {
          let u = ql(l.id);
          if (r.has(u)) {
            let p = r.get(u);
            p.typeParameters ? l.typeParameters && (p.typeParameters.params.push(...l.typeParameters.params), p.typeParameters.params = Ul(p.
            typeParameters.params)) : p = l.typeParameters;
          } else
            r.set(u, l);
          continue;
        }
        a.push(l);
      }
    }
    for (let [, o] of i)
      a.push(o);
    for (let [, o] of r)
      a.push(o);
    return a;
  }
  s(Ul, "removeTypeDuplicates");
});

// ../node_modules/@babel/types/lib/builders/flow/createFlowUnionType.js
var Kl = O((rn) => {
  "use strict";
  Object.defineProperty(rn, "__esModule", {
    value: !0
  });
  rn.default = uC;
  var oC = it(), lC = tn();
  function uC(t) {
    let e = (0, lC.default)(t);
    return e.length === 1 ? e[0] : (0, oC.unionTypeAnnotation)(e);
  }
  s(uC, "createFlowUnionType");
});

// ../node_modules/@babel/types/lib/modifications/typescript/removeTypeDuplicates.js
var Jl = O((sn) => {
  "use strict";
  Object.defineProperty(sn, "__esModule", {
    value: !0
  });
  sn.default = Yl;
  var ur = Be();
  function Vl(t) {
    return (0, ur.isIdentifier)(t) ? t.name : (0, ur.isThisExpression)(t) ? "this" : `${t.right.name}.${Vl(t.left)}`;
  }
  s(Vl, "getQualifiedName");
  function Yl(t) {
    let e = Array.from(t), r = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Set(), a = [];
    for (let o = 0; o < e.length; o++) {
      let l = e[o];
      if (!l || a.includes(l))
        continue;
      if ((0, ur.isTSAnyKeyword)(l))
        return [l];
      if ((0, ur.isTSBaseType)(l)) {
        i.set(l.type, l);
        continue;
      }
      if ((0, ur.isTSUnionType)(l)) {
        n.has(l.types) || (e.push(...l.types), n.add(l.types));
        continue;
      }
      let u = "typeParameters";
      if ((0, ur.isTSTypeReference)(l) && l[u]) {
        let p = l[u], m = Vl(l.typeName);
        if (r.has(m)) {
          let g = r.get(m), I = g[u];
          I ? (I.params.push(...p.params), I.params = Yl(I.params)) : g = p;
        } else
          r.set(m, l);
        continue;
      }
      a.push(l);
    }
    for (let [, o] of i)
      a.push(o);
    for (let [, o] of r)
      a.push(o);
    return a;
  }
  s(Yl, "removeTypeDuplicates");
});

// ../node_modules/@babel/types/lib/builders/typescript/createTSUnionType.js
var Xl = O((nn) => {
  "use strict";
  Object.defineProperty(nn, "__esModule", {
    value: !0
  });
  nn.default = hC;
  var cC = it(), pC = Jl(), fC = Be();
  function hC(t) {
    let e = t.map((i) => (0, fC.isTSTypeAnnotation)(i) ? i.typeAnnotation : i), r = (0, pC.default)(e);
    return r.length === 1 ? r[0] : (0, cC.tsUnionType)(r);
  }
  s(hC, "createTSUnionType");
});

// ../node_modules/@babel/types/lib/builders/productions.js
var on = O((an) => {
  "use strict";
  Object.defineProperty(an, "__esModule", {
    value: !0
  });
  an.buildUndefinedNode = dC;
  var Wl = it();
  function dC() {
    return (0, Wl.unaryExpression)("void", (0, Wl.numericLiteral)(0), !0);
  }
  s(dC, "buildUndefinedNode");
});

// ../node_modules/@babel/types/lib/clone/cloneNode.js
var Bt = O((un) => {
  "use strict";
  Object.defineProperty(un, "__esModule", {
    value: !0
  });
  un.default = mC;
  var zl = ot(), $l = Be(), {
    hasOwn: xt
  } = {
    hasOwn: Function.call.bind(Object.prototype.hasOwnProperty)
  };
  function Hl(t, e, r, i) {
    return t && typeof t.type == "string" ? Gl(t, e, r, i) : t;
  }
  s(Hl, "cloneIfNode");
  function ln(t, e, r, i) {
    return Array.isArray(t) ? t.map((n) => Hl(n, e, r, i)) : Hl(t, e, r, i);
  }
  s(ln, "cloneIfNodeOrArray");
  function mC(t, e = !0, r = !1) {
    return Gl(t, e, r, /* @__PURE__ */ new Map());
  }
  s(mC, "cloneNode");
  function Gl(t, e = !0, r = !1, i) {
    if (!t) return t;
    let {
      type: n
    } = t, a = {
      type: t.type
    };
    if ((0, $l.isIdentifier)(t))
      a.name = t.name, xt(t, "optional") && typeof t.optional == "boolean" && (a.optional = t.optional), xt(t, "typeAnnotation") && (a.typeAnnotation =
      e ? ln(t.typeAnnotation, !0, r, i) : t.typeAnnotation), xt(t, "decorators") && (a.decorators = e ? ln(t.decorators, !0, r, i) : t.decorators);
    else if (xt(zl.NODE_FIELDS, n))
      for (let o of Object.keys(zl.NODE_FIELDS[n]))
        xt(t, o) && (e ? a[o] = (0, $l.isFile)(t) && o === "comments" ? Ei(t.comments, e, r, i) : ln(t[o], !0, r, i) : a[o] = t[o]);
    else
      throw new Error(`Unknown node type: "${n}"`);
    return xt(t, "loc") && (r ? a.loc = null : a.loc = t.loc), xt(t, "leadingComments") && (a.leadingComments = Ei(t.leadingComments, e, r, i)),
    xt(t, "innerComments") && (a.innerComments = Ei(t.innerComments, e, r, i)), xt(t, "trailingComments") && (a.trailingComments = Ei(t.trailingComments,
    e, r, i)), xt(t, "extra") && (a.extra = Object.assign({}, t.extra)), a;
  }
  s(Gl, "cloneNodeInternal");
  function Ei(t, e, r, i) {
    return !t || !e ? t : t.map((n) => {
      let a = i.get(n);
      if (a) return a;
      let {
        type: o,
        value: l,
        loc: u
      } = n, p = {
        type: o,
        value: l,
        loc: u
      };
      return r && (p.loc = null), i.set(n, p), p;
    });
  }
  s(Ei, "maybeCloneComments");
});

// ../node_modules/@babel/types/lib/clone/clone.js
var Ql = O((cn) => {
  "use strict";
  Object.defineProperty(cn, "__esModule", {
    value: !0
  });
  cn.default = TC;
  var yC = Bt();
  function TC(t) {
    return (0, yC.default)(t, !1);
  }
  s(TC, "clone");
});

// ../node_modules/@babel/types/lib/clone/cloneDeep.js
var Zl = O((pn) => {
  "use strict";
  Object.defineProperty(pn, "__esModule", {
    value: !0
  });
  pn.default = bC;
  var SC = Bt();
  function bC(t) {
    return (0, SC.default)(t);
  }
  s(bC, "cloneDeep");
});

// ../node_modules/@babel/types/lib/clone/cloneDeepWithoutLoc.js
var eu = O((fn) => {
  "use strict";
  Object.defineProperty(fn, "__esModule", {
    value: !0
  });
  fn.default = PC;
  var xC = Bt();
  function PC(t) {
    return (0, xC.default)(t, !0, !0);
  }
  s(PC, "cloneDeepWithoutLoc");
});

// ../node_modules/@babel/types/lib/clone/cloneWithoutLoc.js
var tu = O((hn) => {
  "use strict";
  Object.defineProperty(hn, "__esModule", {
    value: !0
  });
  hn.default = gC;
  var EC = Bt();
  function gC(t) {
    return (0, EC.default)(t, !1, !0);
  }
  s(gC, "cloneWithoutLoc");
});

// ../node_modules/@babel/types/lib/comments/addComments.js
var mn = O((dn) => {
  "use strict";
  Object.defineProperty(dn, "__esModule", {
    value: !0
  });
  dn.default = AC;
  function AC(t, e, r) {
    if (!r || !t) return t;
    let i = `${e}Comments`;
    return t[i] ? e === "leading" ? t[i] = r.concat(t[i]) : t[i].push(...r) : t[i] = r, t;
  }
  s(AC, "addComments");
});

// ../node_modules/@babel/types/lib/comments/addComment.js
var ru = O((yn) => {
  "use strict";
  Object.defineProperty(yn, "__esModule", {
    value: !0
  });
  yn.default = vC;
  var IC = mn();
  function vC(t, e, r, i) {
    return (0, IC.default)(t, e, [{
      type: i ? "CommentLine" : "CommentBlock",
      value: r
    }]);
  }
  s(vC, "addComment");
});

// ../node_modules/@babel/types/lib/utils/inherit.js
var gi = O((Tn) => {
  "use strict";
  Object.defineProperty(Tn, "__esModule", {
    value: !0
  });
  Tn.default = CC;
  function CC(t, e, r) {
    e && r && (e[t] = Array.from(new Set([].concat(e[t], r[t]).filter(Boolean))));
  }
  s(CC, "inherit");
});

// ../node_modules/@babel/types/lib/comments/inheritInnerComments.js
var bn = O((Sn) => {
  "use strict";
  Object.defineProperty(Sn, "__esModule", {
    value: !0
  });
  Sn.default = NC;
  var wC = gi();
  function NC(t, e) {
    (0, wC.default)("innerComments", t, e);
  }
  s(NC, "inheritInnerComments");
});

// ../node_modules/@babel/types/lib/comments/inheritLeadingComments.js
var Pn = O((xn) => {
  "use strict";
  Object.defineProperty(xn, "__esModule", {
    value: !0
  });
  xn.default = _C;
  var OC = gi();
  function _C(t, e) {
    (0, OC.default)("leadingComments", t, e);
  }
  s(_C, "inheritLeadingComments");
});

// ../node_modules/@babel/types/lib/comments/inheritTrailingComments.js
var gn = O((En) => {
  "use strict";
  Object.defineProperty(En, "__esModule", {
    value: !0
  });
  En.default = kC;
  var DC = gi();
  function kC(t, e) {
    (0, DC.default)("trailingComments", t, e);
  }
  s(kC, "inheritTrailingComments");
});

// ../node_modules/@babel/types/lib/comments/inheritsComments.js
var In = O((An) => {
  "use strict";
  Object.defineProperty(An, "__esModule", {
    value: !0
  });
  An.default = jC;
  var LC = gn(), MC = Pn(), BC = bn();
  function jC(t, e) {
    return (0, LC.default)(t, e), (0, MC.default)(t, e), (0, BC.default)(t, e), t;
  }
  s(jC, "inheritsComments");
});

// ../node_modules/@babel/types/lib/comments/removeComments.js
var iu = O((vn) => {
  "use strict";
  Object.defineProperty(vn, "__esModule", {
    value: !0
  });
  vn.default = RC;
  var FC = nr();
  function RC(t) {
    return FC.COMMENT_KEYS.forEach((e) => {
      t[e] = null;
    }), t;
  }
  s(RC, "removeComments");
});

// ../node_modules/@babel/types/lib/constants/generated/index.js
var su = O((k) => {
  "use strict";
  Object.defineProperty(k, "__esModule", {
    value: !0
  });
  k.WHILE_TYPES = k.USERWHITESPACABLE_TYPES = k.UNARYLIKE_TYPES = k.TYPESCRIPT_TYPES = k.TSTYPE_TYPES = k.TSTYPEELEMENT_TYPES = k.TSENTITYNAME_TYPES =
  k.TSBASETYPE_TYPES = k.TERMINATORLESS_TYPES = k.STATEMENT_TYPES = k.STANDARDIZED_TYPES = k.SCOPABLE_TYPES = k.PUREISH_TYPES = k.PROPERTY_TYPES =
  k.PRIVATE_TYPES = k.PATTERN_TYPES = k.PATTERNLIKE_TYPES = k.OBJECTMEMBER_TYPES = k.MODULESPECIFIER_TYPES = k.MODULEDECLARATION_TYPES = k.MISCELLANEOUS_TYPES =
  k.METHOD_TYPES = k.LVAL_TYPES = k.LOOP_TYPES = k.LITERAL_TYPES = k.JSX_TYPES = k.IMPORTOREXPORTDECLARATION_TYPES = k.IMMUTABLE_TYPES = k.FUNCTION_TYPES =
  k.FUNCTIONPARENT_TYPES = k.FOR_TYPES = k.FORXSTATEMENT_TYPES = k.FLOW_TYPES = k.FLOWTYPE_TYPES = k.FLOWPREDICATE_TYPES = k.FLOWDECLARATION_TYPES =
  k.FLOWBASEANNOTATION_TYPES = k.EXPRESSION_TYPES = k.EXPRESSIONWRAPPER_TYPES = k.EXPORTDECLARATION_TYPES = k.ENUMMEMBER_TYPES = k.ENUMBODY_TYPES =
  k.DECLARATION_TYPES = k.CONDITIONAL_TYPES = k.COMPLETIONSTATEMENT_TYPES = k.CLASS_TYPES = k.BLOCK_TYPES = k.BLOCKPARENT_TYPES = k.BINARY_TYPES =
  k.ACCESSOR_TYPES = void 0;
  var ae = ot(), GF = k.STANDARDIZED_TYPES = ae.FLIPPED_ALIAS_KEYS.Standardized, QF = k.EXPRESSION_TYPES = ae.FLIPPED_ALIAS_KEYS.Expression,
  ZF = k.BINARY_TYPES = ae.FLIPPED_ALIAS_KEYS.Binary, e4 = k.SCOPABLE_TYPES = ae.FLIPPED_ALIAS_KEYS.Scopable, t4 = k.BLOCKPARENT_TYPES = ae.
  FLIPPED_ALIAS_KEYS.BlockParent, r4 = k.BLOCK_TYPES = ae.FLIPPED_ALIAS_KEYS.Block, i4 = k.STATEMENT_TYPES = ae.FLIPPED_ALIAS_KEYS.Statement,
  s4 = k.TERMINATORLESS_TYPES = ae.FLIPPED_ALIAS_KEYS.Terminatorless, n4 = k.COMPLETIONSTATEMENT_TYPES = ae.FLIPPED_ALIAS_KEYS.CompletionStatement,
  a4 = k.CONDITIONAL_TYPES = ae.FLIPPED_ALIAS_KEYS.Conditional, o4 = k.LOOP_TYPES = ae.FLIPPED_ALIAS_KEYS.Loop, l4 = k.WHILE_TYPES = ae.FLIPPED_ALIAS_KEYS.
  While, u4 = k.EXPRESSIONWRAPPER_TYPES = ae.FLIPPED_ALIAS_KEYS.ExpressionWrapper, c4 = k.FOR_TYPES = ae.FLIPPED_ALIAS_KEYS.For, p4 = k.FORXSTATEMENT_TYPES =
  ae.FLIPPED_ALIAS_KEYS.ForXStatement, f4 = k.FUNCTION_TYPES = ae.FLIPPED_ALIAS_KEYS.Function, h4 = k.FUNCTIONPARENT_TYPES = ae.FLIPPED_ALIAS_KEYS.
  FunctionParent, d4 = k.PUREISH_TYPES = ae.FLIPPED_ALIAS_KEYS.Pureish, m4 = k.DECLARATION_TYPES = ae.FLIPPED_ALIAS_KEYS.Declaration, y4 = k.
  PATTERNLIKE_TYPES = ae.FLIPPED_ALIAS_KEYS.PatternLike, T4 = k.LVAL_TYPES = ae.FLIPPED_ALIAS_KEYS.LVal, S4 = k.TSENTITYNAME_TYPES = ae.FLIPPED_ALIAS_KEYS.
  TSEntityName, b4 = k.LITERAL_TYPES = ae.FLIPPED_ALIAS_KEYS.Literal, x4 = k.IMMUTABLE_TYPES = ae.FLIPPED_ALIAS_KEYS.Immutable, P4 = k.USERWHITESPACABLE_TYPES =
  ae.FLIPPED_ALIAS_KEYS.UserWhitespacable, E4 = k.METHOD_TYPES = ae.FLIPPED_ALIAS_KEYS.Method, g4 = k.OBJECTMEMBER_TYPES = ae.FLIPPED_ALIAS_KEYS.
  ObjectMember, A4 = k.PROPERTY_TYPES = ae.FLIPPED_ALIAS_KEYS.Property, I4 = k.UNARYLIKE_TYPES = ae.FLIPPED_ALIAS_KEYS.UnaryLike, v4 = k.PATTERN_TYPES =
  ae.FLIPPED_ALIAS_KEYS.Pattern, C4 = k.CLASS_TYPES = ae.FLIPPED_ALIAS_KEYS.Class, qC = k.IMPORTOREXPORTDECLARATION_TYPES = ae.FLIPPED_ALIAS_KEYS.
  ImportOrExportDeclaration, w4 = k.EXPORTDECLARATION_TYPES = ae.FLIPPED_ALIAS_KEYS.ExportDeclaration, N4 = k.MODULESPECIFIER_TYPES = ae.FLIPPED_ALIAS_KEYS.
  ModuleSpecifier, O4 = k.ACCESSOR_TYPES = ae.FLIPPED_ALIAS_KEYS.Accessor, _4 = k.PRIVATE_TYPES = ae.FLIPPED_ALIAS_KEYS.Private, D4 = k.FLOW_TYPES =
  ae.FLIPPED_ALIAS_KEYS.Flow, k4 = k.FLOWTYPE_TYPES = ae.FLIPPED_ALIAS_KEYS.FlowType, L4 = k.FLOWBASEANNOTATION_TYPES = ae.FLIPPED_ALIAS_KEYS.
  FlowBaseAnnotation, M4 = k.FLOWDECLARATION_TYPES = ae.FLIPPED_ALIAS_KEYS.FlowDeclaration, B4 = k.FLOWPREDICATE_TYPES = ae.FLIPPED_ALIAS_KEYS.
  FlowPredicate, j4 = k.ENUMBODY_TYPES = ae.FLIPPED_ALIAS_KEYS.EnumBody, F4 = k.ENUMMEMBER_TYPES = ae.FLIPPED_ALIAS_KEYS.EnumMember, R4 = k.
  JSX_TYPES = ae.FLIPPED_ALIAS_KEYS.JSX, q4 = k.MISCELLANEOUS_TYPES = ae.FLIPPED_ALIAS_KEYS.Miscellaneous, U4 = k.TYPESCRIPT_TYPES = ae.FLIPPED_ALIAS_KEYS.
  TypeScript, K4 = k.TSTYPEELEMENT_TYPES = ae.FLIPPED_ALIAS_KEYS.TSTypeElement, V4 = k.TSTYPE_TYPES = ae.FLIPPED_ALIAS_KEYS.TSType, Y4 = k.TSBASETYPE_TYPES =
  ae.FLIPPED_ALIAS_KEYS.TSBaseType, J4 = k.MODULEDECLARATION_TYPES = qC;
});

// ../node_modules/@babel/types/lib/converters/toBlock.js
var Nn = O((wn) => {
  "use strict";
  Object.defineProperty(wn, "__esModule", {
    value: !0
  });
  wn.default = UC;
  var Ai = Be(), Cn = it();
  function UC(t, e) {
    if ((0, Ai.isBlockStatement)(t))
      return t;
    let r = [];
    return (0, Ai.isEmptyStatement)(t) ? r = [] : ((0, Ai.isStatement)(t) || ((0, Ai.isFunction)(e) ? t = (0, Cn.returnStatement)(t) : t = (0, Cn.
    expressionStatement)(t)), r = [t]), (0, Cn.blockStatement)(r);
  }
  s(UC, "toBlock");
});

// ../node_modules/@babel/types/lib/converters/ensureBlock.js
var nu = O((On) => {
  "use strict";
  Object.defineProperty(On, "__esModule", {
    value: !0
  });
  On.default = VC;
  var KC = Nn();
  function VC(t, e = "body") {
    let r = (0, KC.default)(t[e], t);
    return t[e] = r, r;
  }
  s(VC, "ensureBlock");
});

// ../node_modules/@babel/types/lib/converters/toIdentifier.js
var Dn = O((_n) => {
  "use strict";
  Object.defineProperty(_n, "__esModule", {
    value: !0
  });
  _n.default = XC;
  var YC = sr(), JC = pi();
  function XC(t) {
    t = t + "";
    let e = "";
    for (let r of t)
      e += (0, JC.isIdentifierChar)(r.codePointAt(0)) ? r : "-";
    return e = e.replace(/^[-0-9]+/, ""), e = e.replace(/[-\s]+(.)?/g, function(r, i) {
      return i ? i.toUpperCase() : "";
    }), (0, YC.default)(e) || (e = `_${e}`), e || "_";
  }
  s(XC, "toIdentifier");
});

// ../node_modules/@babel/types/lib/converters/toBindingIdentifierName.js
var au = O((kn) => {
  "use strict";
  Object.defineProperty(kn, "__esModule", {
    value: !0
  });
  kn.default = zC;
  var WC = Dn();
  function zC(t) {
    return t = (0, WC.default)(t), (t === "eval" || t === "arguments") && (t = "_" + t), t;
  }
  s(zC, "toBindingIdentifierName");
});

// ../node_modules/@babel/types/lib/converters/toComputedKey.js
var ou = O((Ln) => {
  "use strict";
  Object.defineProperty(Ln, "__esModule", {
    value: !0
  });
  Ln.default = GC;
  var $C = Be(), HC = it();
  function GC(t, e = t.key || t.property) {
    return !t.computed && (0, $C.isIdentifier)(e) && (e = (0, HC.stringLiteral)(e.name)), e;
  }
  s(GC, "toComputedKey");
});

// ../node_modules/@babel/types/lib/converters/toExpression.js
var lu = O((Ii) => {
  "use strict";
  Object.defineProperty(Ii, "__esModule", {
    value: !0
  });
  Ii.default = void 0;
  var Lr = Be(), i8 = Ii.default = QC;
  function QC(t) {
    if ((0, Lr.isExpressionStatement)(t) && (t = t.expression), (0, Lr.isExpression)(t))
      return t;
    if ((0, Lr.isClass)(t) ? t.type = "ClassExpression" : (0, Lr.isFunction)(t) && (t.type = "FunctionExpression"), !(0, Lr.isExpression)(t))
      throw new Error(`cannot turn ${t.type} to an expression`);
    return t;
  }
  s(QC, "toExpression");
});

// ../node_modules/@babel/types/lib/traverse/traverseFast.js
var Bn = O((Mn) => {
  "use strict";
  Object.defineProperty(Mn, "__esModule", {
    value: !0
  });
  Mn.default = Mr;
  var ZC = ot(), uu = Symbol(), cu = Symbol();
  function Mr(t, e, r) {
    if (!t) return !1;
    let i = ZC.VISITOR_KEYS[t.type];
    if (!i) return !1;
    r = r || {};
    let n = e(t, r);
    if (n !== void 0)
      switch (n) {
        case uu:
          return !1;
        case cu:
          return !0;
      }
    for (let a of i) {
      let o = t[a];
      if (o) {
        if (Array.isArray(o)) {
          for (let l of o)
            if (Mr(l, e, r)) return !0;
        } else if (Mr(o, e, r)) return !0;
      }
    }
    return !1;
  }
  s(Mr, "traverseFast");
  Mr.skip = uu;
  Mr.stop = cu;
});

// ../node_modules/@babel/types/lib/modifications/removeProperties.js
var Fn = O((jn) => {
  "use strict";
  Object.defineProperty(jn, "__esModule", {
    value: !0
  });
  jn.default = rw;
  var ew = nr(), pu = ["tokens", "start", "end", "loc", "raw", "rawValue"], tw = [...ew.COMMENT_KEYS, "comments", ...pu];
  function rw(t, e = {}) {
    let r = e.preserveComments ? pu : tw;
    for (let n of r)
      t[n] != null && (t[n] = void 0);
    for (let n of Object.keys(t))
      n[0] === "_" && t[n] != null && (t[n] = void 0);
    let i = Object.getOwnPropertySymbols(t);
    for (let n of i)
      t[n] = null;
  }
  s(rw, "removeProperties");
});

// ../node_modules/@babel/types/lib/modifications/removePropertiesDeep.js
var qn = O((Rn) => {
  "use strict";
  Object.defineProperty(Rn, "__esModule", {
    value: !0
  });
  Rn.default = nw;
  var iw = Bn(), sw = Fn();
  function nw(t, e) {
    return (0, iw.default)(t, sw.default, e), t;
  }
  s(nw, "removePropertiesDeep");
});

// ../node_modules/@babel/types/lib/converters/toKeyAlias.js
var hu = O((Un) => {
  "use strict";
  Object.defineProperty(Un, "__esModule", {
    value: !0
  });
  Un.default = zt;
  var fu = Be(), aw = Bt(), ow = qn();
  function zt(t, e = t.key) {
    let r;
    return t.kind === "method" ? zt.increment() + "" : ((0, fu.isIdentifier)(e) ? r = e.name : (0, fu.isStringLiteral)(e) ? r = JSON.stringify(
    e.value) : r = JSON.stringify((0, ow.default)((0, aw.default)(e))), t.computed && (r = `[${r}]`), t.static && (r = `static:${r}`), r);
  }
  s(zt, "toKeyAlias");
  zt.uid = 0;
  zt.increment = function() {
    return zt.uid >= Number.MAX_SAFE_INTEGER ? zt.uid = 0 : zt.uid++;
  };
});

// ../node_modules/@babel/types/lib/converters/toStatement.js
var du = O((Ci) => {
  "use strict";
  Object.defineProperty(Ci, "__esModule", {
    value: !0
  });
  Ci.default = void 0;
  var vi = Be(), lw = it(), d8 = Ci.default = uw;
  function uw(t, e) {
    if ((0, vi.isStatement)(t))
      return t;
    let r = !1, i;
    if ((0, vi.isClass)(t))
      r = !0, i = "ClassDeclaration";
    else if ((0, vi.isFunction)(t))
      r = !0, i = "FunctionDeclaration";
    else if ((0, vi.isAssignmentExpression)(t))
      return (0, lw.expressionStatement)(t);
    if (r && !t.id && (i = !1), !i) {
      if (e)
        return !1;
      throw new Error(`cannot turn ${t.type} to a statement`);
    }
    return t.type = i, t;
  }
  s(uw, "toStatement");
});

// ../node_modules/@babel/types/lib/converters/valueToNode.js
var mu = O((wi) => {
  "use strict";
  Object.defineProperty(wi, "__esModule", {
    value: !0
  });
  wi.default = void 0;
  var cw = sr(), Fe = it(), T8 = wi.default = Kn, pw = Function.call.bind(Object.prototype.toString);
  function fw(t) {
    return pw(t) === "[object RegExp]";
  }
  s(fw, "isRegExp");
  function hw(t) {
    if (typeof t != "object" || t === null || Object.prototype.toString.call(t) !== "[object Object]")
      return !1;
    let e = Object.getPrototypeOf(t);
    return e === null || Object.getPrototypeOf(e) === null;
  }
  s(hw, "isPlainObject");
  function Kn(t) {
    if (t === void 0)
      return (0, Fe.identifier)("undefined");
    if (t === !0 || t === !1)
      return (0, Fe.booleanLiteral)(t);
    if (t === null)
      return (0, Fe.nullLiteral)();
    if (typeof t == "string")
      return (0, Fe.stringLiteral)(t);
    if (typeof t == "number") {
      let e;
      if (Number.isFinite(t))
        e = (0, Fe.numericLiteral)(Math.abs(t));
      else {
        let r;
        Number.isNaN(t) ? r = (0, Fe.numericLiteral)(0) : r = (0, Fe.numericLiteral)(1), e = (0, Fe.binaryExpression)("/", r, (0, Fe.numericLiteral)(
        0));
      }
      return (t < 0 || Object.is(t, -0)) && (e = (0, Fe.unaryExpression)("-", e)), e;
    }
    if (typeof t == "bigint")
      return (0, Fe.bigIntLiteral)(t.toString());
    if (fw(t)) {
      let e = t.source, r = /\/([a-z]*)$/.exec(t.toString())[1];
      return (0, Fe.regExpLiteral)(e, r);
    }
    if (Array.isArray(t))
      return (0, Fe.arrayExpression)(t.map(Kn));
    if (hw(t)) {
      let e = [];
      for (let r of Object.keys(t)) {
        let i, n = !1;
        (0, cw.default)(r) ? r === "__proto__" ? (n = !0, i = (0, Fe.stringLiteral)(r)) : i = (0, Fe.identifier)(r) : i = (0, Fe.stringLiteral)(
        r), e.push((0, Fe.objectProperty)(i, Kn(t[r]), n));
      }
      return (0, Fe.objectExpression)(e);
    }
    throw new Error("don't know how to turn this value into a node");
  }
  s(Kn, "valueToNode");
});

// ../node_modules/@babel/types/lib/modifications/appendToMemberExpression.js
var yu = O((Vn) => {
  "use strict";
  Object.defineProperty(Vn, "__esModule", {
    value: !0
  });
  Vn.default = mw;
  var dw = it();
  function mw(t, e, r = !1) {
    return t.object = (0, dw.memberExpression)(t.object, t.property, t.computed), t.property = e, t.computed = !!r, t;
  }
  s(mw, "appendToMemberExpression");
});

// ../node_modules/@babel/types/lib/modifications/inherits.js
var Su = O((Yn) => {
  "use strict";
  Object.defineProperty(Yn, "__esModule", {
    value: !0
  });
  Yn.default = Tw;
  var Tu = nr(), yw = In();
  function Tw(t, e) {
    if (!t || !e) return t;
    for (let r of Tu.INHERIT_KEYS.optional)
      t[r] == null && (t[r] = e[r]);
    for (let r of Object.keys(e))
      r[0] === "_" && r !== "__clone" && (t[r] = e[r]);
    for (let r of Tu.INHERIT_KEYS.force)
      t[r] = e[r];
    return (0, yw.default)(t, e), t;
  }
  s(Tw, "inherits");
});

// ../node_modules/@babel/types/lib/modifications/prependToMemberExpression.js
var bu = O((Jn) => {
  "use strict";
  Object.defineProperty(Jn, "__esModule", {
    value: !0
  });
  Jn.default = xw;
  var Sw = it(), bw = Ye();
  function xw(t, e) {
    if ((0, bw.isSuper)(t.object))
      throw new Error("Cannot prepend node to super property access (`super.foo`).");
    return t.object = (0, Sw.memberExpression)(e, t.object), t;
  }
  s(xw, "prependToMemberExpression");
});

// ../node_modules/@babel/types/lib/retrievers/getAssignmentIdentifiers.js
var xu = O((Xn) => {
  "use strict";
  Object.defineProperty(Xn, "__esModule", {
    value: !0
  });
  Xn.default = Pw;
  function Pw(t) {
    let e = [].concat(t), r = /* @__PURE__ */ Object.create(null);
    for (; e.length; ) {
      let i = e.pop();
      if (i)
        switch (i.type) {
          case "ArrayPattern":
            e.push(...i.elements);
            break;
          case "AssignmentExpression":
          case "AssignmentPattern":
          case "ForInStatement":
          case "ForOfStatement":
            e.push(i.left);
            break;
          case "ObjectPattern":
            e.push(...i.properties);
            break;
          case "ObjectProperty":
            e.push(i.value);
            break;
          case "RestElement":
          case "UpdateExpression":
            e.push(i.argument);
            break;
          case "UnaryExpression":
            i.operator === "delete" && e.push(i.argument);
            break;
          case "Identifier":
            r[i.name] = i;
            break;
          default:
            break;
        }
    }
    return r;
  }
  s(Pw, "getAssignmentIdentifiers");
});

// ../node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js
var Br = O((zn) => {
  "use strict";
  Object.defineProperty(zn, "__esModule", {
    value: !0
  });
  zn.default = Wn;
  var At = Be();
  function Wn(t, e, r, i) {
    let n = [].concat(t), a = /* @__PURE__ */ Object.create(null);
    for (; n.length; ) {
      let o = n.shift();
      if (!o || i && ((0, At.isAssignmentExpression)(o) || (0, At.isUnaryExpression)(o) || (0, At.isUpdateExpression)(o)))
        continue;
      if ((0, At.isIdentifier)(o)) {
        e ? (a[o.name] = a[o.name] || []).push(o) : a[o.name] = o;
        continue;
      }
      if ((0, At.isExportDeclaration)(o) && !(0, At.isExportAllDeclaration)(o)) {
        (0, At.isDeclaration)(o.declaration) && n.push(o.declaration);
        continue;
      }
      if (r) {
        if ((0, At.isFunctionDeclaration)(o)) {
          n.push(o.id);
          continue;
        }
        if ((0, At.isFunctionExpression)(o))
          continue;
      }
      let l = Wn.keys[o.type];
      if (l)
        for (let u = 0; u < l.length; u++) {
          let p = l[u], m = o[p];
          m && (Array.isArray(m) ? n.push(...m) : n.push(m));
        }
    }
    return a;
  }
  s(Wn, "getBindingIdentifiers");
  var Ew = {
    DeclareClass: ["id"],
    DeclareFunction: ["id"],
    DeclareModule: ["id"],
    DeclareVariable: ["id"],
    DeclareInterface: ["id"],
    DeclareTypeAlias: ["id"],
    DeclareOpaqueType: ["id"],
    InterfaceDeclaration: ["id"],
    TypeAlias: ["id"],
    OpaqueType: ["id"],
    CatchClause: ["param"],
    LabeledStatement: ["label"],
    UnaryExpression: ["argument"],
    AssignmentExpression: ["left"],
    ImportSpecifier: ["local"],
    ImportNamespaceSpecifier: ["local"],
    ImportDefaultSpecifier: ["local"],
    ImportDeclaration: ["specifiers"],
    TSImportEqualsDeclaration: ["id"],
    ExportSpecifier: ["exported"],
    ExportNamespaceSpecifier: ["exported"],
    ExportDefaultSpecifier: ["exported"],
    FunctionDeclaration: ["id", "params"],
    FunctionExpression: ["id", "params"],
    ArrowFunctionExpression: ["params"],
    ObjectMethod: ["params"],
    ClassMethod: ["params"],
    ClassPrivateMethod: ["params"],
    ForInStatement: ["left"],
    ForOfStatement: ["left"],
    ClassDeclaration: ["id"],
    ClassExpression: ["id"],
    RestElement: ["argument"],
    UpdateExpression: ["argument"],
    ObjectProperty: ["value"],
    AssignmentPattern: ["left"],
    ArrayPattern: ["elements"],
    ObjectPattern: ["properties"],
    VariableDeclaration: ["declarations"],
    VariableDeclarator: ["id"]
  };
  Wn.keys = Ew;
});

// ../node_modules/@babel/types/lib/retrievers/getOuterBindingIdentifiers.js
var Pu = O((Ni) => {
  "use strict";
  Object.defineProperty(Ni, "__esModule", {
    value: !0
  });
  Ni.default = void 0;
  var gw = Br(), O8 = Ni.default = Aw;
  function Aw(t, e) {
    return (0, gw.default)(t, e, !0);
  }
  s(Aw, "getOuterBindingIdentifiers");
});

// ../node_modules/@babel/types/lib/retrievers/getFunctionName.js
var gu = O(($n) => {
  "use strict";
  Object.defineProperty($n, "__esModule", {
    value: !0
  });
  $n.default = vw;
  var lt = Be();
  function Iw(t) {
    return (0, lt.isNullLiteral)(t) ? "null" : (0, lt.isRegExpLiteral)(t) ? `/${t.pattern}/${t.flags}` : (0, lt.isTemplateLiteral)(t) ? t.quasis.
    map((e) => e.value.raw).join("") : t.value !== void 0 ? String(t.value) : null;
  }
  s(Iw, "getNameFromLiteralId");
  function Eu(t) {
    if (!t.computed || (0, lt.isLiteral)(t.key))
      return t.key;
  }
  s(Eu, "getObjectMemberKey");
  function vw(t, e) {
    if ("id" in t && t.id)
      return {
        name: t.id.name,
        originalNode: t.id
      };
    let r = "", i;
    if ((0, lt.isObjectProperty)(e, {
      value: t
    }) ? i = Eu(e) : (0, lt.isObjectMethod)(t) || (0, lt.isClassMethod)(t) ? (i = Eu(t), t.kind === "get" ? r = "get " : t.kind === "set" &&
    (r = "set ")) : (0, lt.isVariableDeclarator)(e, {
      init: t
    }) ? i = e.id : (0, lt.isAssignmentExpression)(e, {
      operator: "=",
      right: t
    }) && (i = e.left), !i) return null;
    let n = (0, lt.isLiteral)(i) ? Iw(i) : (0, lt.isIdentifier)(i) ? i.name : (0, lt.isPrivateName)(i) ? i.id.name : null;
    return n == null ? null : {
      name: r + n,
      originalNode: i
    };
  }
  s(vw, "getFunctionName");
});

// ../node_modules/@babel/types/lib/traverse/traverse.js
var Au = O((Gn) => {
  "use strict";
  Object.defineProperty(Gn, "__esModule", {
    value: !0
  });
  Gn.default = ww;
  var Cw = ot();
  function ww(t, e, r) {
    typeof e == "function" && (e = {
      enter: e
    });
    let {
      enter: i,
      exit: n
    } = e;
    Hn(t, i, n, r, []);
  }
  s(ww, "traverse");
  function Hn(t, e, r, i, n) {
    let a = Cw.VISITOR_KEYS[t.type];
    if (a) {
      e && e(t, n, i);
      for (let o of a) {
        let l = t[o];
        if (Array.isArray(l))
          for (let u = 0; u < l.length; u++) {
            let p = l[u];
            p && (n.push({
              node: t,
              key: o,
              index: u
            }), Hn(p, e, r, i, n), n.pop());
          }
        else l && (n.push({
          node: t,
          key: o
        }), Hn(l, e, r, i, n), n.pop());
      }
      r && r(t, n, i);
    }
  }
  s(Hn, "traverseSimpleImpl");
});

// ../node_modules/@babel/types/lib/validators/isBinding.js
var Iu = O((Qn) => {
  "use strict";
  Object.defineProperty(Qn, "__esModule", {
    value: !0
  });
  Qn.default = Ow;
  var Nw = Br();
  function Ow(t, e, r) {
    if (r && t.type === "Identifier" && e.type === "ObjectProperty" && r.type === "ObjectExpression")
      return !1;
    let i = Nw.default.keys[e.type];
    if (i)
      for (let n = 0; n < i.length; n++) {
        let a = i[n], o = e[a];
        if (Array.isArray(o)) {
          if (o.includes(t)) return !0;
        } else if (o === t) return !0;
      }
    return !1;
  }
  s(Ow, "isBinding");
});

// ../node_modules/@babel/types/lib/validators/isLet.js
var ea = O((Zn) => {
  "use strict";
  Object.defineProperty(Zn, "__esModule", {
    value: !0
  });
  Zn.default = Dw;
  var _w = Be();
  vu = Symbol.for("var used to be block scoped");
  var vu;
  function Dw(t) {
    return (0, _w.isVariableDeclaration)(t) && (t.kind !== "var" || t[vu]);
  }
  s(Dw, "isLet");
});

// ../node_modules/@babel/types/lib/validators/isBlockScoped.js
var wu = O((ta) => {
  "use strict";
  Object.defineProperty(ta, "__esModule", {
    value: !0
  });
  ta.default = Lw;
  var Cu = Be(), kw = ea();
  function Lw(t) {
    return (0, Cu.isFunctionDeclaration)(t) || (0, Cu.isClassDeclaration)(t) || (0, kw.default)(t);
  }
  s(Lw, "isBlockScoped");
});

// ../node_modules/@babel/types/lib/validators/isImmutable.js
var Nu = O((ra) => {
  "use strict";
  Object.defineProperty(ra, "__esModule", {
    value: !0
  });
  ra.default = jw;
  var Mw = ci(), Bw = Be();
  function jw(t) {
    return (0, Mw.default)(t.type, "Immutable") ? !0 : (0, Bw.isIdentifier)(t) ? t.name === "undefined" : !1;
  }
  s(jw, "isImmutable");
});

// ../node_modules/@babel/types/lib/validators/isNodesEquivalent.js
var _u = O((sa) => {
  "use strict";
  Object.defineProperty(sa, "__esModule", {
    value: !0
  });
  sa.default = ia;
  var Ou = ot();
  function ia(t, e) {
    if (typeof t != "object" || typeof e != "object" || t == null || e == null)
      return t === e;
    if (t.type !== e.type)
      return !1;
    let r = Object.keys(Ou.NODE_FIELDS[t.type] || t.type), i = Ou.VISITOR_KEYS[t.type];
    for (let n of r) {
      let a = t[n], o = e[n];
      if (typeof a != typeof o)
        return !1;
      if (!(a == null && o == null)) {
        if (a == null || o == null)
          return !1;
        if (Array.isArray(a)) {
          if (!Array.isArray(o) || a.length !== o.length)
            return !1;
          for (let l = 0; l < a.length; l++)
            if (!ia(a[l], o[l]))
              return !1;
          continue;
        }
        if (typeof a == "object" && !(i != null && i.includes(n))) {
          for (let l of Object.keys(a))
            if (a[l] !== o[l])
              return !1;
          continue;
        }
        if (!ia(a, o))
          return !1;
      }
    }
    return !0;
  }
  s(ia, "isNodesEquivalent");
});

// ../node_modules/@babel/types/lib/validators/isReferenced.js
var Du = O((na) => {
  "use strict";
  Object.defineProperty(na, "__esModule", {
    value: !0
  });
  na.default = Fw;
  function Fw(t, e, r) {
    switch (e.type) {
      case "MemberExpression":
      case "OptionalMemberExpression":
        return e.property === t ? !!e.computed : e.object === t;
      case "JSXMemberExpression":
        return e.object === t;
      case "VariableDeclarator":
        return e.init === t;
      case "ArrowFunctionExpression":
        return e.body === t;
      case "PrivateName":
        return !1;
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "ObjectMethod":
        return e.key === t ? !!e.computed : !1;
      case "ObjectProperty":
        return e.key === t ? !!e.computed : !r || r.type !== "ObjectPattern";
      case "ClassProperty":
      case "ClassAccessorProperty":
        return e.key === t ? !!e.computed : !0;
      case "ClassPrivateProperty":
        return e.key !== t;
      case "ClassDeclaration":
      case "ClassExpression":
        return e.superClass === t;
      case "AssignmentExpression":
        return e.right === t;
      case "AssignmentPattern":
        return e.right === t;
      case "LabeledStatement":
        return !1;
      case "CatchClause":
        return !1;
      case "RestElement":
        return !1;
      case "BreakStatement":
      case "ContinueStatement":
        return !1;
      case "FunctionDeclaration":
      case "FunctionExpression":
        return !1;
      case "ExportNamespaceSpecifier":
      case "ExportDefaultSpecifier":
        return !1;
      case "ExportSpecifier":
        return r != null && r.source ? !1 : e.local === t;
      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "ImportSpecifier":
        return !1;
      case "ImportAttribute":
        return !1;
      case "JSXAttribute":
        return !1;
      case "ObjectPattern":
      case "ArrayPattern":
        return !1;
      case "MetaProperty":
        return !1;
      case "ObjectTypeProperty":
        return e.key !== t;
      case "TSEnumMember":
        return e.id !== t;
      case "TSPropertySignature":
        return e.key === t ? !!e.computed : !0;
    }
    return !0;
  }
  s(Fw, "isReferenced");
});

// ../node_modules/@babel/types/lib/validators/isScope.js
var ku = O((aa) => {
  "use strict";
  Object.defineProperty(aa, "__esModule", {
    value: !0
  });
  aa.default = Rw;
  var $t = Be();
  function Rw(t, e) {
    return (0, $t.isBlockStatement)(t) && ((0, $t.isFunction)(e) || (0, $t.isCatchClause)(e)) ? !1 : (0, $t.isPattern)(t) && ((0, $t.isFunction)(
    e) || (0, $t.isCatchClause)(e)) ? !0 : (0, $t.isScopable)(t);
  }
  s(Rw, "isScope");
});

// ../node_modules/@babel/types/lib/validators/isSpecifierDefault.js
var Mu = O((oa) => {
  "use strict";
  Object.defineProperty(oa, "__esModule", {
    value: !0
  });
  oa.default = qw;
  var Lu = Be();
  function qw(t) {
    return (0, Lu.isImportDefaultSpecifier)(t) || (0, Lu.isIdentifier)(t.imported || t.exported, {
      name: "default"
    });
  }
  s(qw, "isSpecifierDefault");
});

// ../node_modules/@babel/types/lib/validators/isValidES3Identifier.js
var Bu = O((la) => {
  "use strict";
  Object.defineProperty(la, "__esModule", {
    value: !0
  });
  la.default = Vw;
  var Uw = sr(), Kw = /* @__PURE__ */ new Set(["abstract", "boolean", "byte", "char", "double", "enum", "final", "float", "goto", "implement\
s", "int", "interface", "long", "native", "package", "private", "protected", "public", "short", "static", "synchronized", "throws", "transie\
nt", "volatile"]);
  function Vw(t) {
    return (0, Uw.default)(t) && !Kw.has(t);
  }
  s(Vw, "isValidES3Identifier");
});

// ../node_modules/@babel/types/lib/validators/isVar.js
var Fu = O((ua) => {
  "use strict";
  Object.defineProperty(ua, "__esModule", {
    value: !0
  });
  ua.default = Jw;
  var Yw = Be();
  ju = Symbol.for("var used to be block scoped");
  var ju;
  function Jw(t) {
    return (0, Yw.isVariableDeclaration)(t, {
      kind: "var"
    }) && !t[ju];
  }
  s(Jw, "isVar");
});

// ../node_modules/@babel/types/lib/converters/gatherSequenceExpressions.js
var Ru = O((fa) => {
  "use strict";
  Object.defineProperty(fa, "__esModule", {
    value: !0
  });
  fa.default = Oi;
  var Xw = Br(), Ht = Be(), ca = it(), pa = on(), Ww = Bt();
  function Oi(t, e) {
    let r = [], i = !0;
    for (let n of t)
      if ((0, Ht.isEmptyStatement)(n) || (i = !1), (0, Ht.isExpression)(n))
        r.push(n);
      else if ((0, Ht.isExpressionStatement)(n))
        r.push(n.expression);
      else if ((0, Ht.isVariableDeclaration)(n)) {
        if (n.kind !== "var") return;
        for (let a of n.declarations) {
          let o = (0, Xw.default)(a);
          for (let l of Object.keys(o))
            e.push({
              kind: n.kind,
              id: (0, Ww.default)(o[l])
            });
          a.init && r.push((0, ca.assignmentExpression)("=", a.id, a.init));
        }
        i = !0;
      } else if ((0, Ht.isIfStatement)(n)) {
        let a = n.consequent ? Oi([n.consequent], e) : (0, pa.buildUndefinedNode)(), o = n.alternate ? Oi([n.alternate], e) : (0, pa.buildUndefinedNode)();
        if (!a || !o) return;
        r.push((0, ca.conditionalExpression)(n.test, a, o));
      } else if ((0, Ht.isBlockStatement)(n)) {
        let a = Oi(n.body, e);
        if (!a) return;
        r.push(a);
      } else if ((0, Ht.isEmptyStatement)(n))
        t.indexOf(n) === 0 && (i = !0);
      else
        return;
    return i && r.push((0, pa.buildUndefinedNode)()), r.length === 1 ? r[0] : (0, ca.sequenceExpression)(r);
  }
  s(Oi, "gatherSequenceExpressions");
});

// ../node_modules/@babel/types/lib/converters/toSequenceExpression.js
var qu = O((ha) => {
  "use strict";
  Object.defineProperty(ha, "__esModule", {
    value: !0
  });
  ha.default = $w;
  var zw = Ru();
  function $w(t, e) {
    if (!(t != null && t.length)) return;
    let r = [], i = (0, zw.default)(t, r);
    if (i) {
      for (let n of r)
        e.push(n);
      return i;
    }
  }
  s($w, "toSequenceExpression");
});

// ../node_modules/@babel/types/lib/index.js
var Ye = O((R) => {
  "use strict";
  Object.defineProperty(R, "__esModule", {
    value: !0
  });
  var jt = {
    react: !0,
    assertNode: !0,
    createTypeAnnotationBasedOnTypeof: !0,
    createUnionTypeAnnotation: !0,
    createFlowUnionType: !0,
    createTSUnionType: !0,
    cloneNode: !0,
    clone: !0,
    cloneDeep: !0,
    cloneDeepWithoutLoc: !0,
    cloneWithoutLoc: !0,
    addComment: !0,
    addComments: !0,
    inheritInnerComments: !0,
    inheritLeadingComments: !0,
    inheritsComments: !0,
    inheritTrailingComments: !0,
    removeComments: !0,
    ensureBlock: !0,
    toBindingIdentifierName: !0,
    toBlock: !0,
    toComputedKey: !0,
    toExpression: !0,
    toIdentifier: !0,
    toKeyAlias: !0,
    toStatement: !0,
    valueToNode: !0,
    appendToMemberExpression: !0,
    inherits: !0,
    prependToMemberExpression: !0,
    removeProperties: !0,
    removePropertiesDeep: !0,
    removeTypeDuplicates: !0,
    getAssignmentIdentifiers: !0,
    getBindingIdentifiers: !0,
    getOuterBindingIdentifiers: !0,
    getFunctionName: !0,
    traverse: !0,
    traverseFast: !0,
    shallowEqual: !0,
    is: !0,
    isBinding: !0,
    isBlockScoped: !0,
    isImmutable: !0,
    isLet: !0,
    isNode: !0,
    isNodesEquivalent: !0,
    isPlaceholderType: !0,
    isReferenced: !0,
    isScope: !0,
    isSpecifierDefault: !0,
    isType: !0,
    isValidES3Identifier: !0,
    isValidIdentifier: !0,
    isVar: !0,
    matchesPattern: !0,
    validate: !0,
    buildMatchMemberExpression: !0,
    __internal__deprecationWarning: !0
  };
  Object.defineProperty(R, "__internal__deprecationWarning", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return ZN.default;
    }, "get")
  });
  Object.defineProperty(R, "addComment", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return oN.default;
    }, "get")
  });
  Object.defineProperty(R, "addComments", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return lN.default;
    }, "get")
  });
  Object.defineProperty(R, "appendToMemberExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return gN.default;
    }, "get")
  });
  Object.defineProperty(R, "assertNode", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Zw.default;
    }, "get")
  });
  Object.defineProperty(R, "buildMatchMemberExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return QN.default;
    }, "get")
  });
  Object.defineProperty(R, "clone", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return iN.default;
    }, "get")
  });
  Object.defineProperty(R, "cloneDeep", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return sN.default;
    }, "get")
  });
  Object.defineProperty(R, "cloneDeepWithoutLoc", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return nN.default;
    }, "get")
  });
  Object.defineProperty(R, "cloneNode", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return rN.default;
    }, "get")
  });
  Object.defineProperty(R, "cloneWithoutLoc", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return aN.default;
    }, "get")
  });
  Object.defineProperty(R, "createFlowUnionType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Uu.default;
    }, "get")
  });
  Object.defineProperty(R, "createTSUnionType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return tN.default;
    }, "get")
  });
  Object.defineProperty(R, "createTypeAnnotationBasedOnTypeof", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return eN.default;
    }, "get")
  });
  Object.defineProperty(R, "createUnionTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Uu.default;
    }, "get")
  });
  Object.defineProperty(R, "ensureBlock", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return dN.default;
    }, "get")
  });
  Object.defineProperty(R, "getAssignmentIdentifiers", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return NN.default;
    }, "get")
  });
  Object.defineProperty(R, "getBindingIdentifiers", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return ON.default;
    }, "get")
  });
  Object.defineProperty(R, "getFunctionName", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return DN.default;
    }, "get")
  });
  Object.defineProperty(R, "getOuterBindingIdentifiers", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return _N.default;
    }, "get")
  });
  Object.defineProperty(R, "inheritInnerComments", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return uN.default;
    }, "get")
  });
  Object.defineProperty(R, "inheritLeadingComments", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return cN.default;
    }, "get")
  });
  Object.defineProperty(R, "inheritTrailingComments", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return fN.default;
    }, "get")
  });
  Object.defineProperty(R, "inherits", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return AN.default;
    }, "get")
  });
  Object.defineProperty(R, "inheritsComments", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return pN.default;
    }, "get")
  });
  Object.defineProperty(R, "is", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return MN.default;
    }, "get")
  });
  Object.defineProperty(R, "isBinding", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return BN.default;
    }, "get")
  });
  Object.defineProperty(R, "isBlockScoped", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return jN.default;
    }, "get")
  });
  Object.defineProperty(R, "isImmutable", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return FN.default;
    }, "get")
  });
  Object.defineProperty(R, "isLet", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return RN.default;
    }, "get")
  });
  Object.defineProperty(R, "isNode", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return qN.default;
    }, "get")
  });
  Object.defineProperty(R, "isNodesEquivalent", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return UN.default;
    }, "get")
  });
  Object.defineProperty(R, "isPlaceholderType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return KN.default;
    }, "get")
  });
  Object.defineProperty(R, "isReferenced", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return VN.default;
    }, "get")
  });
  Object.defineProperty(R, "isScope", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return YN.default;
    }, "get")
  });
  Object.defineProperty(R, "isSpecifierDefault", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return JN.default;
    }, "get")
  });
  Object.defineProperty(R, "isType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return XN.default;
    }, "get")
  });
  Object.defineProperty(R, "isValidES3Identifier", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return WN.default;
    }, "get")
  });
  Object.defineProperty(R, "isValidIdentifier", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return zN.default;
    }, "get")
  });
  Object.defineProperty(R, "isVar", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $N.default;
    }, "get")
  });
  Object.defineProperty(R, "matchesPattern", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return HN.default;
    }, "get")
  });
  Object.defineProperty(R, "prependToMemberExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return IN.default;
    }, "get")
  });
  R.react = void 0;
  Object.defineProperty(R, "removeComments", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return hN.default;
    }, "get")
  });
  Object.defineProperty(R, "removeProperties", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return vN.default;
    }, "get")
  });
  Object.defineProperty(R, "removePropertiesDeep", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return CN.default;
    }, "get")
  });
  Object.defineProperty(R, "removeTypeDuplicates", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return wN.default;
    }, "get")
  });
  Object.defineProperty(R, "shallowEqual", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return LN.default;
    }, "get")
  });
  Object.defineProperty(R, "toBindingIdentifierName", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return mN.default;
    }, "get")
  });
  Object.defineProperty(R, "toBlock", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return yN.default;
    }, "get")
  });
  Object.defineProperty(R, "toComputedKey", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return TN.default;
    }, "get")
  });
  Object.defineProperty(R, "toExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return SN.default;
    }, "get")
  });
  Object.defineProperty(R, "toIdentifier", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return bN.default;
    }, "get")
  });
  Object.defineProperty(R, "toKeyAlias", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return xN.default;
    }, "get")
  });
  Object.defineProperty(R, "toStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return PN.default;
    }, "get")
  });
  Object.defineProperty(R, "traverse", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return _i.default;
    }, "get")
  });
  Object.defineProperty(R, "traverseFast", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return kN.default;
    }, "get")
  });
  Object.defineProperty(R, "validate", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return GN.default;
    }, "get")
  });
  Object.defineProperty(R, "valueToNode", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return EN.default;
    }, "get")
  });
  var Hw = Vo(), Gw = Yo(), Qw = Bl(), Zw = jl(), da = Fl();
  Object.keys(da).forEach(function(t) {
    t === "default" || t === "__esModule" || Object.prototype.hasOwnProperty.call(jt, t) || t in R && R[t] === da[t] || Object.defineProperty(
    R, t, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return da[t];
      }, "get")
    });
  });
  var eN = Rl(), Uu = Kl(), tN = Xl(), ma = on();
  Object.keys(ma).forEach(function(t) {
    t === "default" || t === "__esModule" || Object.prototype.hasOwnProperty.call(jt, t) || t in R && R[t] === ma[t] || Object.defineProperty(
    R, t, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return ma[t];
      }, "get")
    });
  });
  var ya = it();
  Object.keys(ya).forEach(function(t) {
    t === "default" || t === "__esModule" || Object.prototype.hasOwnProperty.call(jt, t) || t in R && R[t] === ya[t] || Object.defineProperty(
    R, t, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return ya[t];
      }, "get")
    });
  });
  var rN = Bt(), iN = Ql(), sN = Zl(), nN = eu(), aN = tu(), oN = ru(), lN = mn(), uN = bn(), cN = Pn(), pN = In(), fN = gn(), hN = iu(), Ta = su();
  Object.keys(Ta).forEach(function(t) {
    t === "default" || t === "__esModule" || Object.prototype.hasOwnProperty.call(jt, t) || t in R && R[t] === Ta[t] || Object.defineProperty(
    R, t, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return Ta[t];
      }, "get")
    });
  });
  var Sa = nr();
  Object.keys(Sa).forEach(function(t) {
    t === "default" || t === "__esModule" || Object.prototype.hasOwnProperty.call(jt, t) || t in R && R[t] === Sa[t] || Object.defineProperty(
    R, t, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return Sa[t];
      }, "get")
    });
  });
  var dN = nu(), mN = au(), yN = Nn(), TN = ou(), SN = lu(), bN = Dn(), xN = hu(), PN = du(), EN = mu(), ba = ot();
  Object.keys(ba).forEach(function(t) {
    t === "default" || t === "__esModule" || Object.prototype.hasOwnProperty.call(jt, t) || t in R && R[t] === ba[t] || Object.defineProperty(
    R, t, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return ba[t];
      }, "get")
    });
  });
  var gN = yu(), AN = Su(), IN = bu(), vN = Fn(), CN = qn(), wN = tn(), NN = xu(), ON = Br(), _N = Pu(), DN = gu(), _i = Au();
  Object.keys(_i).forEach(function(t) {
    t === "default" || t === "__esModule" || Object.prototype.hasOwnProperty.call(jt, t) || t in R && R[t] === _i[t] || Object.defineProperty(
    R, t, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return _i[t];
      }, "get")
    });
  });
  var kN = Bn(), LN = li(), MN = ir(), BN = Iu(), jN = wu(), FN = Nu(), RN = ea(), qN = Qs(), UN = _u(), KN = gs(), VN = Du(), YN = ku(), JN = Mu(),
  XN = ci(), WN = Bu(), zN = sr(), $N = Fu(), HN = Ts(), GN = mi(), QN = bs(), xa = Be();
  Object.keys(xa).forEach(function(t) {
    t === "default" || t === "__esModule" || Object.prototype.hasOwnProperty.call(jt, t) || t in R && R[t] === xa[t] || Object.defineProperty(
    R, t, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return xa[t];
      }, "get")
    });
  });
  var ZN = Er(), eO = qu(), oR = R.react = {
    isReactComponent: Hw.default,
    isCompatTag: Gw.default,
    buildChildren: Qw.default
  };
  R.toSequenceExpression = eO.default;
  process.env.BABEL_TYPES_8_BREAKING && console.warn("BABEL_TYPES_8_BREAKING is not supported anymore. Use the latest Babel 8.0.0 pre-releas\
e instead!");
});

// ../node_modules/@babel/generator/lib/node/whitespace.js
var Xu = O((ki) => {
  "use strict";
  Object.defineProperty(ki, "__esModule", {
    value: !0
  });
  ki.nodes = void 0;
  var tO = Ye(), {
    FLIPPED_ALIAS_KEYS: rO,
    isArrayExpression: iO,
    isAssignmentExpression: Vu,
    isBinary: Yu,
    isBlockStatement: sO,
    isCallExpression: Ju,
    isFunction: jr,
    isIdentifier: Di,
    isLiteral: nO,
    isMemberExpression: Pa,
    isObjectExpression: aO,
    isOptionalCallExpression: oO,
    isOptionalMemberExpression: lO,
    isStringLiteral: uO
  } = tO;
  function cr(t, e) {
    return t && (Pa(t) || lO(t) ? (cr(t.object, e), t.computed && cr(t.property, e)) : Yu(t) || Vu(t) ? (cr(t.left, e), cr(t.right, e)) : Ju(
    t) || oO(t) ? (e.hasCall = !0, cr(t.callee, e)) : jr(t) ? e.hasFunction = !0 : Di(t) && (e.hasHelper = e.hasHelper || t.callee && It(t.callee))),
    e;
  }
  s(cr, "crawlInternal");
  function Ku(t) {
    return cr(t, {
      hasCall: !1,
      hasFunction: !1,
      hasHelper: !1
    });
  }
  s(Ku, "crawl");
  function It(t) {
    return t ? Pa(t) ? It(t.object) || It(t.property) : Di(t) ? t.name === "require" || t.name.charCodeAt(0) === 95 : Ju(t) ? It(t.callee) :
    Yu(t) || Vu(t) ? Di(t.left) && It(t.left) || It(t.right) : !1 : !1;
  }
  s(It, "isHelper");
  function cO(t) {
    return nO(t) || aO(t) || iO(t) || Di(t) || Pa(t);
  }
  s(cO, "isType");
  var Gt = ki.nodes = {
    AssignmentExpression(t) {
      let e = Ku(t.right);
      if (e.hasCall && e.hasHelper || e.hasFunction)
        return e.hasFunction ? 3 : 2;
    },
    SwitchCase(t, e) {
      return (t.consequent.length || e.cases[0] === t ? 1 : 0) | (!t.consequent.length && e.cases[e.cases.length - 1] === t ? 2 : 0);
    },
    LogicalExpression(t) {
      if (jr(t.left) || jr(t.right))
        return 2;
    },
    Literal(t) {
      if (uO(t) && t.value === "use strict")
        return 2;
    },
    CallExpression(t) {
      if (jr(t.callee) || It(t))
        return 3;
    },
    OptionalCallExpression(t) {
      if (jr(t.callee))
        return 3;
    },
    VariableDeclaration(t) {
      for (let e = 0; e < t.declarations.length; e++) {
        let r = t.declarations[e], i = It(r.id) && !cO(r.init);
        if (!i && r.init) {
          let n = Ku(r.init);
          i = It(r.init) && n.hasCall || n.hasFunction;
        }
        if (i)
          return 3;
      }
    },
    IfStatement(t) {
      if (sO(t.consequent))
        return 3;
    }
  };
  Gt.ObjectProperty = Gt.ObjectTypeProperty = Gt.ObjectMethod = function(t, e) {
    if (e.properties[0] === t)
      return 1;
  };
  Gt.ObjectTypeCallProperty = function(t, e) {
    var r;
    if (e.callProperties[0] === t && !((r = e.properties) != null && r.length))
      return 1;
  };
  Gt.ObjectTypeIndexer = function(t, e) {
    var r, i;
    if (e.indexers[0] === t && !((r = e.properties) != null && r.length) && !((i = e.callProperties) != null && i.length))
      return 1;
  };
  Gt.ObjectTypeInternalSlot = function(t, e) {
    var r, i, n;
    if (e.internalSlots[0] === t && !((r = e.properties) != null && r.length) && !((i = e.callProperties) != null && i.length) && !((n = e.indexers) !=
    null && n.length))
      return 1;
  };
  [["Function", !0], ["Class", !0], ["Loop", !0], ["LabeledStatement", !0], ["SwitchStatement", !0], ["TryStatement", !0]].forEach(function([
  t, e]) {
    [t].concat(rO[t] || []).forEach(function(r) {
      let i = e ? 3 : 0;
      Gt[r] = () => i;
    });
  });
});

// ../node_modules/@babel/generator/lib/node/parentheses.js
var ec = O((xe) => {
  "use strict";
  Object.defineProperty(xe, "__esModule", {
    value: !0
  });
  xe.AssignmentExpression = KO;
  xe.Binary = Gu;
  xe.BinaryExpression = BO;
  xe.ClassExpression = RO;
  xe.ArrowFunctionExpression = xe.ConditionalExpression = Zu;
  xe.DoExpression = IO;
  xe.FunctionExpression = qO;
  xe.FunctionTypeAnnotation = EO;
  xe.Identifier = YO;
  xe.LogicalExpression = VO;
  xe.NullableTypeAnnotation = PO;
  xe.ObjectExpression = AO;
  xe.OptionalIndexedAccessType = CO;
  xe.OptionalCallExpression = xe.OptionalMemberExpression = UO;
  xe.SequenceExpression = jO;
  xe.TSSatisfiesExpression = xe.TSAsExpression = wO;
  xe.TSConditionalType = NO;
  xe.TSConstructorType = xe.TSFunctionType = MO;
  xe.TSInferType = DO;
  xe.TSInstantiationExpression = LO;
  xe.TSIntersectionType = _O;
  xe.UnaryLike = xe.TSTypeAssertion = Qu;
  xe.TSTypeOperator = kO;
  xe.TSUnionType = OO;
  xe.IntersectionTypeAnnotation = xe.UnionTypeAnnotation = vO;
  xe.UpdateExpression = gO;
  xe.AwaitExpression = xe.YieldExpression = FO;
  var pO = Ye(), ut = Ft(), {
    isArrayTypeAnnotation: fO,
    isBinaryExpression: hO,
    isCallExpression: dO,
    isForOfStatement: mO,
    isIndexedAccessType: yO,
    isMemberExpression: $u,
    isObjectPattern: TO,
    isOptionalMemberExpression: SO,
    isYieldExpression: bO,
    isStatement: xO
  } = pO, Wu = /* @__PURE__ */ new Map([["||", 0], ["??", 0], ["|>", 0], ["&&", 1], ["|", 2], ["^", 3], ["&", 4], ["==", 5], ["===", 5], ["!\
=", 5], ["!==", 5], ["<", 6], [">", 6], ["<=", 6], [">=", 6], ["in", 6], ["instanceof", 6], [">>", 7], ["<<", 7], [">>>", 7], ["+", 8], ["-",
  8], ["*", 9], ["/", 9], ["%", 9], ["**", 10]]);
  function zu(t, e) {
    if (e === "BinaryExpression" || e === "LogicalExpression")
      return Wu.get(t.operator);
    if (e === "TSAsExpression" || e === "TSSatisfiesExpression")
      return Wu.get("in");
  }
  s(zu, "getBinaryPrecedence");
  function Ea(t) {
    return t === "TSAsExpression" || t === "TSSatisfiesExpression" || t === "TSTypeAssertion";
  }
  s(Ea, "isTSTypeExpression");
  var Li = /* @__PURE__ */ s((t, e) => {
    let r = e.type;
    return (r === "ClassDeclaration" || r === "ClassExpression") && e.superClass === t;
  }, "isClassExtendsClause"), Mi = /* @__PURE__ */ s((t, e) => {
    let r = e.type;
    return (r === "MemberExpression" || r === "OptionalMemberExpression") && e.object === t || (r === "CallExpression" || r === "OptionalCal\
lExpression" || r === "NewExpression") && e.callee === t || r === "TaggedTemplateExpression" && e.tag === t || r === "TSNonNullExpression";
  }, "hasPostfixPart");
  function PO(t, e) {
    return fO(e);
  }
  s(PO, "NullableTypeAnnotation");
  function EO(t, e, r) {
    let i = e.type;
    return i === "UnionTypeAnnotation" || i === "IntersectionTypeAnnotation" || i === "ArrayTypeAnnotation" || !!(r & ut.TokenContext.arrowFlowReturnType);
  }
  s(EO, "FunctionTypeAnnotation");
  function gO(t, e) {
    return Mi(t, e) || Li(t, e);
  }
  s(gO, "UpdateExpression");
  function Hu(t) {
    return !!(t & (ut.TokenContext.expressionStatement | ut.TokenContext.arrowBody));
  }
  s(Hu, "needsParenBeforeExpressionBrace");
  function AO(t, e, r) {
    return Hu(r);
  }
  s(AO, "ObjectExpression");
  function IO(t, e, r) {
    return !t.async && !!(r & ut.TokenContext.expressionStatement);
  }
  s(IO, "DoExpression");
  function Gu(t, e) {
    let r = e.type;
    if (t.type === "BinaryExpression" && t.operator === "**" && r === "BinaryExpression" && e.operator === "**")
      return e.left === t;
    if (Li(t, e) || Mi(t, e) || r === "UnaryExpression" || r === "SpreadElement" || r === "AwaitExpression")
      return !0;
    let i = zu(e, r);
    if (i != null) {
      let n = zu(t, t.type);
      if (i === n && r === "BinaryExpression" && e.right === t || i > n)
        return !0;
    }
  }
  s(Gu, "Binary");
  function vO(t, e) {
    let r = e.type;
    return r === "ArrayTypeAnnotation" || r === "NullableTypeAnnotation" || r === "IntersectionTypeAnnotation" || r === "UnionTypeAnnotation";
  }
  s(vO, "UnionTypeAnnotation");
  function CO(t, e) {
    return yO(e) && e.objectType === t;
  }
  s(CO, "OptionalIndexedAccessType");
  function wO(t, e) {
    return (e.type === "AssignmentExpression" || e.type === "AssignmentPattern") && e.left === t || e.type === "BinaryExpression" && (e.operator ===
    "|" || e.operator === "&") && t === e.left ? !0 : Gu(t, e);
  }
  s(wO, "TSAsExpression");
  function NO(t, e) {
    let r = e.type;
    return r === "TSArrayType" || r === "TSIndexedAccessType" && e.objectType === t || r === "TSOptionalType" || r === "TSTypeOperator" || r ===
    "TSTypeParameter" || (r === "TSIntersectionType" || r === "TSUnionType") && e.types[0] === t || r === "TSConditionalType" && (e.checkType ===
    t || e.extendsType === t);
  }
  s(NO, "TSConditionalType");
  function OO(t, e) {
    let r = e.type;
    return r === "TSIntersectionType" || r === "TSTypeOperator" || r === "TSArrayType" || r === "TSIndexedAccessType" && e.objectType === t ||
    r === "TSOptionalType";
  }
  s(OO, "TSUnionType");
  function _O(t, e) {
    let r = e.type;
    return r === "TSTypeOperator" || r === "TSArrayType" || r === "TSIndexedAccessType" && e.objectType === t || r === "TSOptionalType";
  }
  s(_O, "TSIntersectionType");
  function DO(t, e) {
    let r = e.type;
    return !!(r === "TSArrayType" || r === "TSIndexedAccessType" && e.objectType === t || r === "TSOptionalType" || t.typeParameter.constraint &&
    (r === "TSIntersectionType" || r === "TSUnionType") && e.types[0] === t);
  }
  s(DO, "TSInferType");
  function kO(t, e) {
    let r = e.type;
    return r === "TSArrayType" || r === "TSIndexedAccessType" && e.objectType === t || r === "TSOptionalType";
  }
  s(kO, "TSTypeOperator");
  function LO(t, e) {
    let r = e.type;
    return (r === "CallExpression" || r === "OptionalCallExpression" || r === "NewExpression" || r === "TSInstantiationExpression") && !!e.typeParameters;
  }
  s(LO, "TSInstantiationExpression");
  function MO(t, e) {
    let r = e.type;
    return r === "TSIntersectionType" || r === "TSUnionType" || r === "TSTypeOperator" || r === "TSOptionalType" || r === "TSArrayType" || r ===
    "TSIndexedAccessType" && e.objectType === t || r === "TSConditionalType" && (e.checkType === t || e.extendsType === t);
  }
  s(MO, "TSFunctionType");
  function BO(t, e, r, i) {
    return t.operator === "in" && i;
  }
  s(BO, "BinaryExpression");
  function jO(t, e) {
    let r = e.type;
    return r === "SequenceExpression" || r === "ParenthesizedExpression" || r === "MemberExpression" && e.property === t || r === "OptionalM\
emberExpression" && e.property === t || r === "TemplateLiteral" ? !1 : r === "ClassDeclaration" ? !0 : r === "ForOfStatement" ? e.right === t :
    r === "ExportDefaultDeclaration" ? !0 : !xO(e);
  }
  s(jO, "SequenceExpression");
  function FO(t, e) {
    let r = e.type;
    return r === "BinaryExpression" || r === "LogicalExpression" || r === "UnaryExpression" || r === "SpreadElement" || Mi(t, e) || r === "A\
waitExpression" && bO(t) || r === "ConditionalExpression" && t === e.test || Li(t, e) || Ea(r);
  }
  s(FO, "YieldExpression");
  function RO(t, e, r) {
    return !!(r & (ut.TokenContext.expressionStatement | ut.TokenContext.exportDefault));
  }
  s(RO, "ClassExpression");
  function Qu(t, e) {
    return Mi(t, e) || hO(e) && e.operator === "**" && e.left === t || Li(t, e);
  }
  s(Qu, "UnaryLike");
  function qO(t, e, r) {
    return !!(r & (ut.TokenContext.expressionStatement | ut.TokenContext.exportDefault));
  }
  s(qO, "FunctionExpression");
  function Zu(t, e) {
    let r = e.type;
    return r === "UnaryExpression" || r === "SpreadElement" || r === "BinaryExpression" || r === "LogicalExpression" || r === "ConditionalEx\
pression" && e.test === t || r === "AwaitExpression" || Ea(r) ? !0 : Qu(t, e);
  }
  s(Zu, "ConditionalExpression");
  function UO(t, e) {
    return dO(e) && e.callee === t || $u(e) && e.object === t;
  }
  s(UO, "OptionalMemberExpression");
  function KO(t, e, r) {
    return Hu(r) && TO(t.left) ? !0 : Zu(t, e);
  }
  s(KO, "AssignmentExpression");
  function VO(t, e) {
    let r = e.type;
    if (Ea(r)) return !0;
    if (r !== "LogicalExpression") return !1;
    switch (t.operator) {
      case "||":
        return e.operator === "??" || e.operator === "&&";
      case "&&":
        return e.operator === "??";
      case "??":
        return e.operator !== "??";
    }
  }
  s(VO, "LogicalExpression");
  function YO(t, e, r, i, n) {
    var a;
    let o = e.type;
    if ((a = t.extra) != null && a.parenthesized && o === "AssignmentExpression" && e.left === t) {
      let l = e.right.type;
      if ((l === "FunctionExpression" || l === "ClassExpression") && e.right.id == null)
        return !0;
    }
    return n && n(t) !== t.name ? !1 : t.name === "let" ? ($u(e, {
      object: t,
      computed: !0
    }) || SO(e, {
      object: t,
      computed: !0,
      optional: !1
    })) && r & (ut.TokenContext.expressionStatement | ut.TokenContext.forHead | ut.TokenContext.forInHead) ? !0 : !!(r & ut.TokenContext.forOfHead) :
    t.name === "async" && mO(e, {
      left: t,
      await: !1
    });
  }
  s(YO, "Identifier");
});

// ../node_modules/@babel/generator/lib/node/index.js
var Ft = O((vt) => {
  "use strict";
  Object.defineProperty(vt, "__esModule", {
    value: !0
  });
  vt.TokenContext = void 0;
  vt.isLastChild = a_;
  vt.needsParens = n_;
  vt.needsWhitespace = Aa;
  vt.needsWhitespaceAfter = s_;
  vt.needsWhitespaceBefore = i_;
  var JO = Xu(), XO = ec(), WO = Ye(), {
    FLIPPED_ALIAS_KEYS: zO,
    VISITOR_KEYS: $O,
    isCallExpression: tc,
    isDecorator: HO,
    isExpressionStatement: GO,
    isMemberExpression: QO,
    isNewExpression: ZO,
    isParenthesizedExpression: e_
  } = WO, dR = vt.TokenContext = {
    expressionStatement: 1,
    arrowBody: 2,
    exportDefault: 4,
    forHead: 8,
    forInHead: 16,
    forOfHead: 32,
    arrowFlowReturnType: 64
  };
  function rc(t) {
    let e = /* @__PURE__ */ new Map();
    function r(i, n) {
      let a = e.get(i);
      e.set(i, a ? function(o, l, u, p, m) {
        var g;
        return (g = a(o, l, u, p, m)) != null ? g : n(o, l, u, p, m);
      } : n);
    }
    s(r, "add");
    for (let i of Object.keys(t)) {
      let n = zO[i];
      if (n)
        for (let a of n)
          r(a, t[i]);
      else
        r(i, t[i]);
    }
    return e;
  }
  s(rc, "expandAliases");
  var t_ = rc(XO), r_ = rc(JO.nodes);
  function ic(t) {
    return tc(t) ? !0 : QO(t) && ic(t.object);
  }
  s(ic, "isOrHasCallExpression");
  function Aa(t, e, r) {
    var i;
    if (!t) return !1;
    GO(t) && (t = t.expression);
    let n = (i = r_.get(t.type)) == null ? void 0 : i(t, e);
    return typeof n == "number" ? (n & r) !== 0 : !1;
  }
  s(Aa, "needsWhitespace");
  function i_(t, e) {
    return Aa(t, e, 1);
  }
  s(i_, "needsWhitespaceBefore");
  function s_(t, e) {
    return Aa(t, e, 2);
  }
  s(s_, "needsWhitespaceAfter");
  function n_(t, e, r, i, n) {
    var a;
    return e ? ZO(e) && e.callee === t && ic(t) ? !0 : HO(e) ? !ga(t) && !(tc(t) && ga(t.callee)) && !e_(t) : (a = t_.get(t.type)) == null ?
    void 0 : a(t, e, r, i, n) : !1;
  }
  s(n_, "needsParens");
  function ga(t) {
    switch (t.type) {
      case "Identifier":
        return !0;
      case "MemberExpression":
        return !t.computed && t.property.type === "Identifier" && ga(t.object);
      default:
        return !1;
    }
  }
  s(ga, "isDecoratorMemberExpression");
  function a_(t, e) {
    let r = $O[t.type];
    for (let i = r.length - 1; i >= 0; i--) {
      let n = t[r[i]];
      if (n === e)
        return !0;
      if (Array.isArray(n)) {
        let a = n.length - 1;
        for (; a >= 0 && n[a] === null; ) a--;
        return a >= 0 && n[a] === e;
      } else if (n)
        return !1;
    }
    return !1;
  }
  s(a_, "isLastChild");
});

// ../node_modules/@babel/generator/lib/token-map.js
var sc = O((Bi) => {
  "use strict";
  Object.defineProperty(Bi, "__esModule", {
    value: !0
  });
  Bi.TokenMap = void 0;
  var o_ = Ye(), {
    traverseFast: l_,
    VISITOR_KEYS: u_
  } = o_, Ia = class {
    static {
      s(this, "TokenMap");
    }
    constructor(e, r, i) {
      this._tokens = void 0, this._source = void 0, this._nodesToTokenIndexes = /* @__PURE__ */ new Map(), this._nodesOccurrencesCountCache =
      /* @__PURE__ */ new Map(), this._tokensCache = /* @__PURE__ */ new Map(), this._tokens = r, this._source = i, l_(e, (n) => {
        let a = this._getTokensIndexesOfNode(n);
        a.length > 0 && this._nodesToTokenIndexes.set(n, a);
      }), this._tokensCache = null;
    }
    has(e) {
      return this._nodesToTokenIndexes.has(e);
    }
    getIndexes(e) {
      return this._nodesToTokenIndexes.get(e);
    }
    find(e, r) {
      let i = this._nodesToTokenIndexes.get(e);
      if (i)
        for (let n = 0; n < i.length; n++) {
          let a = i[n], o = this._tokens[a];
          if (r(o, a)) return o;
        }
      return null;
    }
    findLastIndex(e, r) {
      let i = this._nodesToTokenIndexes.get(e);
      if (i)
        for (let n = i.length - 1; n >= 0; n--) {
          let a = i[n], o = this._tokens[a];
          if (r(o, a)) return a;
        }
      return -1;
    }
    findMatching(e, r, i = 0) {
      let n = this._nodesToTokenIndexes.get(e);
      if (n) {
        let a = 0, o = i;
        if (o > 1) {
          let l = this._nodesOccurrencesCountCache.get(e);
          l && l.test === r && l.count < o && (a = l.i + 1, i -= l.count + 1);
        }
        for (; a < n.length; a++) {
          let l = this._tokens[n[a]];
          if (this.matchesOriginal(l, r)) {
            if (i === 0)
              return o > 0 && this._nodesOccurrencesCountCache.set(e, {
                test: r,
                count: o,
                i: a
              }), l;
            i--;
          }
        }
      }
      return null;
    }
    matchesOriginal(e, r) {
      return e.end - e.start !== r.length ? !1 : e.value != null ? e.value === r : this._source.startsWith(r, e.start);
    }
    startMatches(e, r) {
      let i = this._nodesToTokenIndexes.get(e);
      if (!i) return !1;
      let n = this._tokens[i[0]];
      return n.start !== e.start ? !1 : this.matchesOriginal(n, r);
    }
    endMatches(e, r) {
      let i = this._nodesToTokenIndexes.get(e);
      if (!i) return !1;
      let n = this._tokens[i[i.length - 1]];
      return n.end !== e.end ? !1 : this.matchesOriginal(n, r);
    }
    _getTokensIndexesOfNode(e) {
      if (e.start == null || e.end == null) return [];
      let {
        first: r,
        last: i
      } = this._findTokensOfNode(e, 0, this._tokens.length - 1), n = r, a = c_(e);
      (e.type === "ExportNamedDeclaration" || e.type === "ExportDefaultDeclaration") && e.declaration && e.declaration.type === "ClassDeclar\
ation" && a.next();
      let o = [];
      for (let l of a) {
        if (l == null || l.start == null || l.end == null) continue;
        let u = this._findTokensOfNode(l, n, i), p = u.first;
        for (let m = n; m < p; m++) o.push(m);
        n = u.last + 1;
      }
      for (let l = n; l <= i; l++) o.push(l);
      return o;
    }
    _findTokensOfNode(e, r, i) {
      let n = this._tokensCache.get(e);
      if (n) return n;
      let a = this._findFirstTokenOfNode(e.start, r, i), o = this._findLastTokenOfNode(e.end, a, i);
      return this._tokensCache.set(e, {
        first: a,
        last: o
      }), {
        first: a,
        last: o
      };
    }
    _findFirstTokenOfNode(e, r, i) {
      for (; r <= i; ) {
        let n = i + r >> 1;
        if (e < this._tokens[n].start)
          i = n - 1;
        else if (e > this._tokens[n].start)
          r = n + 1;
        else
          return n;
      }
      return r;
    }
    _findLastTokenOfNode(e, r, i) {
      for (; r <= i; ) {
        let n = i + r >> 1;
        if (e < this._tokens[n].end)
          i = n - 1;
        else if (e > this._tokens[n].end)
          r = n + 1;
        else
          return n;
      }
      return i;
    }
  };
  Bi.TokenMap = Ia;
  function* c_(t) {
    if (t.type === "TemplateLiteral") {
      yield t.quasis[0];
      for (let r = 1; r < t.quasis.length; r++)
        yield t.expressions[r - 1], yield t.quasis[r];
      return;
    }
    let e = u_[t.type];
    for (let r of e) {
      let i = t[r];
      i && (Array.isArray(i) ? yield* i : yield i);
    }
  }
  s(c_, "childrenIterator");
});

// ../node_modules/@babel/generator/lib/generators/template-literals.js
var nc = O((pr) => {
  "use strict";
  Object.defineProperty(pr, "__esModule", {
    value: !0
  });
  pr.TaggedTemplateExpression = p_;
  pr.TemplateElement = f_;
  pr.TemplateLiteral = d_;
  pr._printTemplate = h_;
  function p_(t) {
    this.print(t.tag), this.print(t.typeParameters), this.print(t.quasi);
  }
  s(p_, "TaggedTemplateExpression");
  function f_() {
    throw new Error("TemplateElement printing is handled in TemplateLiteral");
  }
  s(f_, "TemplateElement");
  function h_(t, e) {
    let r = t.quasis, i = "`";
    for (let n = 0; n < r.length - 1; n++)
      if (i += r[n].value.raw, this.token(i + "${", !0), this.print(e[n]), i = "}", this.tokenMap) {
        let a = this.tokenMap.findMatching(t, "}", n);
        a && this._catchUpTo(a.loc.start);
      }
    i += r[r.length - 1].value.raw, this.token(i + "`", !0);
  }
  s(h_, "_printTemplate");
  function d_(t) {
    this._printTemplate(t, t.expressions);
  }
  s(d_, "TemplateLiteral");
});

// ../node_modules/@babel/generator/lib/generators/expressions.js
var oc = O((Ce) => {
  "use strict";
  Object.defineProperty(Ce, "__esModule", {
    value: !0
  });
  Ce.LogicalExpression = Ce.BinaryExpression = Ce.AssignmentExpression = q_;
  Ce.AssignmentPattern = R_;
  Ce.AwaitExpression = M_;
  Ce.BindExpression = U_;
  Ce.CallExpression = k_;
  Ce.ConditionalExpression = A_;
  Ce.Decorator = O_;
  Ce.DoExpression = P_;
  Ce.EmptyStatement = j_;
  Ce.ExpressionStatement = F_;
  Ce.Import = L_;
  Ce.MemberExpression = K_;
  Ce.MetaProperty = V_;
  Ce.ModuleExpression = X_;
  Ce.NewExpression = I_;
  Ce.OptionalCallExpression = D_;
  Ce.OptionalMemberExpression = __;
  Ce.ParenthesizedExpression = E_;
  Ce.PrivateName = Y_;
  Ce.SequenceExpression = v_;
  Ce.Super = w_;
  Ce.ThisExpression = C_;
  Ce.UnaryExpression = x_;
  Ce.UpdateExpression = g_;
  Ce.V8IntrinsicIdentifier = J_;
  Ce.YieldExpression = B_;
  Ce._shouldPrintDecoratorsBeforeExport = N_;
  var m_ = Ye(), y_ = Ft(), {
    isCallExpression: T_,
    isLiteral: ac,
    isMemberExpression: va,
    isNewExpression: S_,
    isPattern: b_
  } = m_;
  function x_(t) {
    let {
      operator: e
    } = t;
    e === "void" || e === "delete" || e === "typeof" || e === "throw" ? (this.word(e), this.space()) : this.token(e), this.print(t.argument);
  }
  s(x_, "UnaryExpression");
  function P_(t) {
    t.async && (this.word("async", !0), this.space()), this.word("do"), this.space(), this.print(t.body);
  }
  s(P_, "DoExpression");
  function E_(t) {
    this.tokenChar(40);
    let e = this.enterDelimited();
    this.print(t.expression), e(), this.rightParens(t);
  }
  s(E_, "ParenthesizedExpression");
  function g_(t) {
    t.prefix ? (this.token(t.operator), this.print(t.argument)) : (this.print(t.argument, !0), this.token(t.operator));
  }
  s(g_, "UpdateExpression");
  function A_(t) {
    this.print(t.test), this.space(), this.tokenChar(63), this.space(), this.print(t.consequent), this.space(), this.tokenChar(58), this.space(),
    this.print(t.alternate);
  }
  s(A_, "ConditionalExpression");
  function I_(t, e) {
    if (this.word("new"), this.space(), this.print(t.callee), this.format.minified && t.arguments.length === 0 && !t.optional && !T_(e, {
      callee: t
    }) && !va(e) && !S_(e) || (this.print(t.typeArguments), this.print(t.typeParameters), t.optional && this.token("?."), t.arguments.length ===
    0 && this.tokenMap && !this.tokenMap.endMatches(t, ")")))
      return;
    this.tokenChar(40);
    let r = this.enterDelimited();
    this.printList(t.arguments, this.shouldPrintTrailingComma(")")), r(), this.rightParens(t);
  }
  s(I_, "NewExpression");
  function v_(t) {
    this.printList(t.expressions);
  }
  s(v_, "SequenceExpression");
  function C_() {
    this.word("this");
  }
  s(C_, "ThisExpression");
  function w_() {
    this.word("super");
  }
  s(w_, "Super");
  function N_(t) {
    return typeof this.format.decoratorsBeforeExport == "boolean" ? this.format.decoratorsBeforeExport : typeof t.start == "number" && t.start ===
    t.declaration.start;
  }
  s(N_, "_shouldPrintDecoratorsBeforeExport");
  function O_(t) {
    this.tokenChar(64), this.print(t.expression), this.newline();
  }
  s(O_, "Decorator");
  function __(t) {
    let {
      computed: e
    } = t, {
      optional: r,
      property: i
    } = t;
    if (this.print(t.object), !e && va(i))
      throw new TypeError("Got a MemberExpression for MemberExpression property");
    ac(i) && typeof i.value == "number" && (e = !0), r && this.token("?."), e ? (this.tokenChar(91), this.print(i), this.tokenChar(93)) : (r ||
    this.tokenChar(46), this.print(i));
  }
  s(__, "OptionalMemberExpression");
  function D_(t) {
    this.print(t.callee), this.print(t.typeParameters), t.optional && this.token("?."), this.print(t.typeArguments), this.tokenChar(40);
    let e = this.enterDelimited();
    this.printList(t.arguments), e(), this.rightParens(t);
  }
  s(D_, "OptionalCallExpression");
  function k_(t) {
    this.print(t.callee), this.print(t.typeArguments), this.print(t.typeParameters), this.tokenChar(40);
    let e = this.enterDelimited();
    this.printList(t.arguments, this.shouldPrintTrailingComma(")")), e(), this.rightParens(t);
  }
  s(k_, "CallExpression");
  function L_() {
    this.word("import");
  }
  s(L_, "Import");
  function M_(t) {
    this.word("await"), t.argument && (this.space(), this.printTerminatorless(t.argument));
  }
  s(M_, "AwaitExpression");
  function B_(t) {
    this.word("yield", !0), t.delegate ? (this.tokenChar(42), t.argument && (this.space(), this.print(t.argument))) : t.argument && (this.space(),
    this.printTerminatorless(t.argument));
  }
  s(B_, "YieldExpression");
  function j_() {
    this.semicolon(!0);
  }
  s(j_, "EmptyStatement");
  function F_(t) {
    this.tokenContext |= y_.TokenContext.expressionStatement, this.print(t.expression), this.semicolon();
  }
  s(F_, "ExpressionStatement");
  function R_(t) {
    this.print(t.left), (t.left.type === "Identifier" || b_(t.left)) && (t.left.optional && this.tokenChar(63), this.print(t.left.typeAnnotation)),
    this.space(), this.tokenChar(61), this.space(), this.print(t.right);
  }
  s(R_, "AssignmentPattern");
  function q_(t) {
    this.print(t.left), this.space(), t.operator === "in" || t.operator === "instanceof" ? this.word(t.operator) : (this.token(t.operator), this.
    _endsWithDiv = t.operator === "/"), this.space(), this.print(t.right);
  }
  s(q_, "AssignmentExpression");
  function U_(t) {
    this.print(t.object), this.token("::"), this.print(t.callee);
  }
  s(U_, "BindExpression");
  function K_(t) {
    if (this.print(t.object), !t.computed && va(t.property))
      throw new TypeError("Got a MemberExpression for MemberExpression property");
    let e = t.computed;
    if (ac(t.property) && typeof t.property.value == "number" && (e = !0), e) {
      let r = this.enterDelimited();
      this.tokenChar(91), this.print(t.property), this.tokenChar(93), r();
    } else
      this.tokenChar(46), this.print(t.property);
  }
  s(K_, "MemberExpression");
  function V_(t) {
    this.print(t.meta), this.tokenChar(46), this.print(t.property);
  }
  s(V_, "MetaProperty");
  function Y_(t) {
    this.tokenChar(35), this.print(t.id);
  }
  s(Y_, "PrivateName");
  function J_(t) {
    this.tokenChar(37), this.word(t.name);
  }
  s(J_, "V8IntrinsicIdentifier");
  function X_(t) {
    this.word("module", !0), this.space(), this.tokenChar(123), this.indent();
    let {
      body: e
    } = t;
    (e.body.length || e.directives.length) && this.newline(), this.print(e), this.dedent(), this.rightBrace(t);
  }
  s(X_, "ModuleExpression");
});

// ../node_modules/@babel/generator/lib/generators/statements.js
var pc = O((ke) => {
  "use strict";
  Object.defineProperty(ke, "__esModule", {
    value: !0
  });
  ke.BreakStatement = rD;
  ke.CatchClause = lD;
  ke.ContinueStatement = iD;
  ke.DebuggerStatement = pD;
  ke.DoWhileStatement = tD;
  ke.ForOfStatement = ke.ForInStatement = void 0;
  ke.ForStatement = Z_;
  ke.IfStatement = Q_;
  ke.LabeledStatement = aD;
  ke.ReturnStatement = sD;
  ke.SwitchCase = cD;
  ke.SwitchStatement = uD;
  ke.ThrowStatement = nD;
  ke.TryStatement = oD;
  ke.VariableDeclaration = fD;
  ke.VariableDeclarator = hD;
  ke.WhileStatement = eD;
  ke.WithStatement = G_;
  var W_ = Ye(), Ca = Ft(), {
    isFor: lc,
    isForStatement: z_,
    isIfStatement: $_,
    isStatement: H_
  } = W_;
  function G_(t) {
    this.word("with"), this.space(), this.tokenChar(40), this.print(t.object), this.tokenChar(41), this.printBlock(t);
  }
  s(G_, "WithStatement");
  function Q_(t) {
    this.word("if"), this.space(), this.tokenChar(40), this.print(t.test), this.tokenChar(41), this.space();
    let e = t.alternate && $_(uc(t.consequent));
    e && (this.tokenChar(123), this.newline(), this.indent()), this.printAndIndentOnComments(t.consequent), e && (this.dedent(), this.newline(),
    this.tokenChar(125)), t.alternate && (this.endsWith(125) && this.space(), this.word("else"), this.space(), this.printAndIndentOnComments(
    t.alternate));
  }
  s(Q_, "IfStatement");
  function uc(t) {
    let {
      body: e
    } = t;
    return H_(e) === !1 ? t : uc(e);
  }
  s(uc, "getLastStatement");
  function Z_(t) {
    this.word("for"), this.space(), this.tokenChar(40);
    {
      let e = this.enterForStatementInit();
      this.tokenContext |= Ca.TokenContext.forHead, this.print(t.init), e();
    }
    this.tokenChar(59), t.test && (this.space(), this.print(t.test)), this.token(";", !1, 1), t.update && (this.space(), this.print(t.update)),
    this.tokenChar(41), this.printBlock(t);
  }
  s(Z_, "ForStatement");
  function eD(t) {
    this.word("while"), this.space(), this.tokenChar(40), this.print(t.test), this.tokenChar(41), this.printBlock(t);
  }
  s(eD, "WhileStatement");
  function cc(t) {
    this.word("for"), this.space();
    let e = t.type === "ForOfStatement";
    e && t.await && (this.word("await"), this.space()), this.noIndentInnerCommentsHere(), this.tokenChar(40);
    {
      let r = e ? null : this.enterForStatementInit();
      this.tokenContext |= e ? Ca.TokenContext.forOfHead : Ca.TokenContext.forInHead, this.print(t.left), r?.();
    }
    this.space(), this.word(e ? "of" : "in"), this.space(), this.print(t.right), this.tokenChar(41), this.printBlock(t);
  }
  s(cc, "ForXStatement");
  var gR = ke.ForInStatement = cc, AR = ke.ForOfStatement = cc;
  function tD(t) {
    this.word("do"), this.space(), this.print(t.body), this.space(), this.word("while"), this.space(), this.tokenChar(40), this.print(t.test),
    this.tokenChar(41), this.semicolon();
  }
  s(tD, "DoWhileStatement");
  function ji(t, e) {
    e && (t.space(), t.printTerminatorless(e)), t.semicolon();
  }
  s(ji, "printStatementAfterKeyword");
  function rD(t) {
    this.word("break"), ji(this, t.label);
  }
  s(rD, "BreakStatement");
  function iD(t) {
    this.word("continue"), ji(this, t.label);
  }
  s(iD, "ContinueStatement");
  function sD(t) {
    this.word("return"), ji(this, t.argument);
  }
  s(sD, "ReturnStatement");
  function nD(t) {
    this.word("throw"), ji(this, t.argument);
  }
  s(nD, "ThrowStatement");
  function aD(t) {
    this.print(t.label), this.tokenChar(58), this.space(), this.print(t.body);
  }
  s(aD, "LabeledStatement");
  function oD(t) {
    this.word("try"), this.space(), this.print(t.block), this.space(), t.handlers ? this.print(t.handlers[0]) : this.print(t.handler), t.finalizer &&
    (this.space(), this.word("finally"), this.space(), this.print(t.finalizer));
  }
  s(oD, "TryStatement");
  function lD(t) {
    this.word("catch"), this.space(), t.param && (this.tokenChar(40), this.print(t.param), this.print(t.param.typeAnnotation), this.tokenChar(
    41), this.space()), this.print(t.body);
  }
  s(lD, "CatchClause");
  function uD(t) {
    this.word("switch"), this.space(), this.tokenChar(40), this.print(t.discriminant), this.tokenChar(41), this.space(), this.tokenChar(123),
    this.printSequence(t.cases, !0, void 0, /* @__PURE__ */ s(function(r, i) {
      if (!r && t.cases[t.cases.length - 1] === i) return -1;
    }, "addNewlines")), this.rightBrace(t);
  }
  s(uD, "SwitchStatement");
  function cD(t) {
    t.test ? (this.word("case"), this.space(), this.print(t.test), this.tokenChar(58)) : (this.word("default"), this.tokenChar(58)), t.consequent.
    length && (this.newline(), this.printSequence(t.consequent, !0));
  }
  s(cD, "SwitchCase");
  function pD() {
    this.word("debugger"), this.semicolon();
  }
  s(pD, "DebuggerStatement");
  function fD(t, e) {
    t.declare && (this.word("declare"), this.space());
    let {
      kind: r
    } = t;
    r === "await using" ? (this.word("await"), this.space(), this.word("using", !0)) : this.word(r, r === "using"), this.space();
    let i = !1;
    if (!lc(e))
      for (let n of t.declarations)
        n.init && (i = !0);
    if (this.printList(t.declarations, void 0, void 0, t.declarations.length > 1, i ? function(n) {
      this.token(",", !1, n), this.newline();
    } : void 0), lc(e)) {
      if (z_(e)) {
        if (e.init === t) return;
      } else if (e.left === t) return;
    }
    this.semicolon();
  }
  s(fD, "VariableDeclaration");
  function hD(t) {
    this.print(t.id), t.definite && this.tokenChar(33), this.print(t.id.typeAnnotation), t.init && (this.space(), this.tokenChar(61), this.space(),
    this.print(t.init));
  }
  s(hD, "VariableDeclarator");
});

// ../node_modules/@babel/generator/lib/generators/classes.js
var fc = O((ct) => {
  "use strict";
  Object.defineProperty(ct, "__esModule", {
    value: !0
  });
  ct.ClassAccessorProperty = PD;
  ct.ClassBody = SD;
  ct.ClassExpression = ct.ClassDeclaration = TD;
  ct.ClassMethod = gD;
  ct.ClassPrivateMethod = AD;
  ct.ClassPrivateProperty = ED;
  ct.ClassProperty = xD;
  ct.StaticBlock = vD;
  ct._classMethodHead = ID;
  var dD = Ye(), {
    isExportDefaultDeclaration: mD,
    isExportNamedDeclaration: yD
  } = dD;
  function TD(t, e) {
    (!(mD(e) || yD(e)) || !this._shouldPrintDecoratorsBeforeExport(e)) && this.printJoin(t.decorators), t.declare && (this.word("declare"), this.
    space()), t.abstract && (this.word("abstract"), this.space()), this.word("class"), t.id && (this.space(), this.print(t.id)), this.print(
    t.typeParameters), t.superClass && (this.space(), this.word("extends"), this.space(), this.print(t.superClass), this.print(t.superTypeParameters)),
    t.implements && (this.space(), this.word("implements"), this.space(), this.printList(t.implements)), this.space(), this.print(t.body);
  }
  s(TD, "ClassDeclaration");
  function SD(t) {
    if (this.tokenChar(123), t.body.length === 0)
      this.tokenChar(125);
    else {
      this.newline();
      let e = bD(this, t);
      e?.(-1);
      let r = this.enterDelimited();
      this.printJoin(t.body, !0, !0, e, !0), r(), this.endsWith(10) || this.newline(), this.rightBrace(t);
    }
  }
  s(SD, "ClassBody");
  function bD(t, e) {
    if (!t.tokenMap || e.start == null || e.end == null)
      return null;
    let r = t.tokenMap.getIndexes(e);
    if (!r) return null;
    let i = 1, n = 0, a = 0, o = /* @__PURE__ */ s(() => {
      for (; a < e.body.length && e.body[a].start == null; )
        a++;
    }, "advanceNextLocIndex");
    return o(), (l) => {
      a <= l && (a = l + 1, o());
      let u = a === e.body.length ? e.end : e.body[a].start, p;
      for (; i < r.length && t.tokenMap.matchesOriginal(p = t._tokens[r[i]], ";") && p.start < u; )
        t.token(";", void 0, n++), i++;
    };
  }
  s(bD, "classBodyEmptySemicolonsPrinter");
  function xD(t) {
    if (this.printJoin(t.decorators), !t.static && !this.format.preserveFormat) {
      var e;
      let r = (e = t.key.loc) == null || (e = e.end) == null ? void 0 : e.line;
      r && this.catchUp(r);
    }
    this.tsPrintClassMemberModifiers(t), t.computed ? (this.tokenChar(91), this.print(t.key), this.tokenChar(93)) : (this._variance(t), this.
    print(t.key)), t.optional && this.tokenChar(63), t.definite && this.tokenChar(33), this.print(t.typeAnnotation), t.value && (this.space(),
    this.tokenChar(61), this.space(), this.print(t.value)), this.semicolon();
  }
  s(xD, "ClassProperty");
  function PD(t) {
    var e;
    this.printJoin(t.decorators);
    let r = (e = t.key.loc) == null || (e = e.end) == null ? void 0 : e.line;
    r && this.catchUp(r), this.tsPrintClassMemberModifiers(t), this.word("accessor", !0), this.space(), t.computed ? (this.tokenChar(91), this.
    print(t.key), this.tokenChar(93)) : (this._variance(t), this.print(t.key)), t.optional && this.tokenChar(63), t.definite && this.tokenChar(
    33), this.print(t.typeAnnotation), t.value && (this.space(), this.tokenChar(61), this.space(), this.print(t.value)), this.semicolon();
  }
  s(PD, "ClassAccessorProperty");
  function ED(t) {
    this.printJoin(t.decorators), this.tsPrintClassMemberModifiers(t), this.print(t.key), t.optional && this.tokenChar(63), t.definite && this.
    tokenChar(33), this.print(t.typeAnnotation), t.value && (this.space(), this.tokenChar(61), this.space(), this.print(t.value)), this.semicolon();
  }
  s(ED, "ClassPrivateProperty");
  function gD(t) {
    this._classMethodHead(t), this.space(), this.print(t.body);
  }
  s(gD, "ClassMethod");
  function AD(t) {
    this._classMethodHead(t), this.space(), this.print(t.body);
  }
  s(AD, "ClassPrivateMethod");
  function ID(t) {
    if (this.printJoin(t.decorators), !this.format.preserveFormat) {
      var e;
      let r = (e = t.key.loc) == null || (e = e.end) == null ? void 0 : e.line;
      r && this.catchUp(r);
    }
    this.tsPrintClassMemberModifiers(t), this._methodHead(t);
  }
  s(ID, "_classMethodHead");
  function vD(t) {
    this.word("static"), this.space(), this.tokenChar(123), t.body.length === 0 ? this.tokenChar(125) : (this.newline(), this.printSequence(
    t.body, !0), this.rightBrace(t));
  }
  s(vD, "StaticBlock");
});

// ../node_modules/@babel/generator/lib/generators/methods.js
var hc = O((pt) => {
  "use strict";
  Object.defineProperty(pt, "__esModule", {
    value: !0
  });
  pt.ArrowFunctionExpression = jD;
  pt.FunctionDeclaration = pt.FunctionExpression = BD;
  pt._functionHead = MD;
  pt._methodHead = kD;
  pt._param = DD;
  pt._parameters = _D;
  pt._params = OD;
  pt._predicate = LD;
  pt._shouldPrintArrowParamsParens = FD;
  var CD = Ye(), wD = Ft(), {
    isIdentifier: ND
  } = CD;
  function OD(t, e, r) {
    this.print(t.typeParameters);
    let i = RD.call(this, e, r);
    i && this.sourceIdentifierName(i.name, i.pos), this.tokenChar(40), this._parameters(t.params, ")");
    let n = t.type === "ArrowFunctionExpression";
    this.print(t.returnType, n), this._noLineTerminator = n;
  }
  s(OD, "_params");
  function _D(t, e) {
    let r = this.enterDelimited(), i = this.shouldPrintTrailingComma(e), n = t.length;
    for (let a = 0; a < n; a++)
      this._param(t[a]), (i || a < n - 1) && (this.token(",", null, a), this.space());
    this.token(e), r();
  }
  s(_D, "_parameters");
  function DD(t) {
    this.printJoin(t.decorators), this.print(t), t.optional && this.tokenChar(63), this.print(t.typeAnnotation);
  }
  s(DD, "_param");
  function kD(t) {
    let e = t.kind, r = t.key;
    (e === "get" || e === "set") && (this.word(e), this.space()), t.async && (this.word("async", !0), this.space()), (e === "method" || e ===
    "init") && t.generator && this.tokenChar(42), t.computed ? (this.tokenChar(91), this.print(r), this.tokenChar(93)) : this.print(r), t.optional &&
    this.tokenChar(63), this._params(t, t.computed && t.key.type !== "StringLiteral" ? void 0 : t.key, void 0);
  }
  s(kD, "_methodHead");
  function LD(t, e) {
    t.predicate && (t.returnType || this.tokenChar(58), this.space(), this.print(t.predicate, e));
  }
  s(LD, "_predicate");
  function MD(t, e) {
    t.async && (this.word("async"), this.format.preserveFormat || (this._endsWithInnerRaw = !1), this.space()), this.word("function"), t.generator &&
    (this.format.preserveFormat || (this._endsWithInnerRaw = !1), this.tokenChar(42)), this.space(), t.id && this.print(t.id), this._params(
    t, t.id, e), t.type !== "TSDeclareFunction" && this._predicate(t);
  }
  s(MD, "_functionHead");
  function BD(t, e) {
    this._functionHead(t, e), this.space(), this.print(t.body);
  }
  s(BD, "FunctionExpression");
  function jD(t, e) {
    t.async && (this.word("async", !0), this.space()), this._shouldPrintArrowParamsParens(t) ? this._params(t, void 0, e) : this.print(t.params[0],
    !0), this._predicate(t, !0), this.space(), this.printInnerComments(), this.token("=>"), this.space(), this.tokenContext |= wD.TokenContext.
    arrowBody, this.print(t.body);
  }
  s(jD, "ArrowFunctionExpression");
  function FD(t) {
    var e, r;
    if (t.params.length !== 1 || t.typeParameters || t.returnType || t.predicate)
      return !0;
    let i = t.params[0];
    if (!ND(i) || i.typeAnnotation || i.optional || (e = i.leadingComments) != null && e.length || (r = i.trailingComments) != null && r.length)
      return !0;
    if (this.tokenMap) {
      if (t.loc == null || this.tokenMap.findMatching(t, "(") !== null) return !0;
      let n = this.tokenMap.findMatching(t, "=>");
      return n?.loc == null ? !0 : n.loc.start.line !== t.loc.start.line;
    }
    return !!this.format.retainLines;
  }
  s(FD, "_shouldPrintArrowParamsParens");
  function RD(t, e) {
    let r = t;
    if (!r && e) {
      let u = e.type;
      u === "VariableDeclarator" ? r = e.id : u === "AssignmentExpression" || u === "AssignmentPattern" ? r = e.left : u === "ObjectProperty" ||
      u === "ClassProperty" ? (!e.computed || e.key.type === "StringLiteral") && (r = e.key) : (u === "ClassPrivateProperty" || u === "Class\
AccessorProperty") && (r = e.key);
    }
    if (!r) return;
    let i;
    if (r.type === "Identifier") {
      var n, a;
      i = {
        pos: (n = r.loc) == null ? void 0 : n.start,
        name: ((a = r.loc) == null ? void 0 : a.identifierName) || r.name
      };
    } else if (r.type === "PrivateName") {
      var o;
      i = {
        pos: (o = r.loc) == null ? void 0 : o.start,
        name: "#" + r.id.name
      };
    } else if (r.type === "StringLiteral") {
      var l;
      i = {
        pos: (l = r.loc) == null ? void 0 : l.start,
        name: r.value
      };
    }
    return i;
  }
  s(RD, "_getFuncIdName");
});

// ../node_modules/@babel/generator/lib/generators/modules.js
var wa = O((Ge) => {
  "use strict";
  Object.defineProperty(Ge, "__esModule", {
    value: !0
  });
  Ge.ExportAllDeclaration = ZD;
  Ge.ExportDefaultDeclaration = tk;
  Ge.ExportDefaultSpecifier = $D;
  Ge.ExportNamedDeclaration = ek;
  Ge.ExportNamespaceSpecifier = GD;
  Ge.ExportSpecifier = HD;
  Ge.ImportAttribute = ik;
  Ge.ImportDeclaration = rk;
  Ge.ImportDefaultSpecifier = zD;
  Ge.ImportExpression = nk;
  Ge.ImportNamespaceSpecifier = sk;
  Ge.ImportSpecifier = WD;
  Ge._printAttributes = QD;
  var qD = Ye(), UD = Ft(), {
    isClassDeclaration: KD,
    isExportDefaultSpecifier: VD,
    isExportNamespaceSpecifier: YD,
    isImportDefaultSpecifier: JD,
    isImportNamespaceSpecifier: XD,
    isStatement: mc
  } = qD;
  function WD(t) {
    (t.importKind === "type" || t.importKind === "typeof") && (this.word(t.importKind), this.space()), this.print(t.imported), t.local && t.
    local.name !== t.imported.name && (this.space(), this.word("as"), this.space(), this.print(t.local));
  }
  s(WD, "ImportSpecifier");
  function zD(t) {
    this.print(t.local);
  }
  s(zD, "ImportDefaultSpecifier");
  function $D(t) {
    this.print(t.exported);
  }
  s($D, "ExportDefaultSpecifier");
  function HD(t) {
    t.exportKind === "type" && (this.word("type"), this.space()), this.print(t.local), t.exported && t.local.name !== t.exported.name && (this.
    space(), this.word("as"), this.space(), this.print(t.exported));
  }
  s(HD, "ExportSpecifier");
  function GD(t) {
    this.tokenChar(42), this.space(), this.word("as"), this.space(), this.print(t.exported);
  }
  s(GD, "ExportNamespaceSpecifier");
  var dc = !1;
  function QD(t, e) {
    var r;
    let {
      importAttributesKeyword: i
    } = this.format, {
      attributes: n,
      assertions: a
    } = t;
    n && !i && t.extra && (t.extra.deprecatedAssertSyntax || t.extra.deprecatedWithLegacySyntax) && !dc && (dc = !0, console.warn('You are u\
sing import attributes, without specifying the desired output syntax.\nPlease specify the "importAttributesKeyword" generator option, whose v\
alue can be one of:\n - "with"        : `import { a } from "b" with { type: "json" };`\n - "assert"      : `import { a } from "b" assert { typ\
e: "json" };`\n - "with-legacy" : `import { a } from "b" with type: "json";`\n'));
    let o = i === "assert" || !i && a;
    if (this.word(o ? "assert" : "with"), this.space(), !o && (i === "with-legacy" || !i && (r = t.extra) != null && r.deprecatedWithLegacySyntax)) {
      this.printList(n || a);
      return;
    }
    let l = e ? 1 : 0;
    this.token("{", null, l), this.space(), this.printList(n || a, this.shouldPrintTrailingComma("}")), this.space(), this.token("}", null, l);
  }
  s(QD, "_printAttributes");
  function ZD(t) {
    var e, r;
    this.word("export"), this.space(), t.exportKind === "type" && (this.word("type"), this.space()), this.tokenChar(42), this.space(), this.
    word("from"), this.space(), (e = t.attributes) != null && e.length || (r = t.assertions) != null && r.length ? (this.print(t.source, !0),
    this.space(), this._printAttributes(t, !1)) : this.print(t.source), this.semicolon();
  }
  s(ZD, "ExportAllDeclaration");
  function yc(t, e) {
    KD(e.declaration) && t._shouldPrintDecoratorsBeforeExport(e) && t.printJoin(e.declaration.decorators);
  }
  s(yc, "maybePrintDecoratorsBeforeExport");
  function ek(t) {
    if (yc(this, t), this.word("export"), this.space(), t.declaration) {
      let i = t.declaration;
      this.print(i), mc(i) || this.semicolon();
    } else {
      t.exportKind === "type" && (this.word("type"), this.space());
      let i = t.specifiers.slice(0), n = !1;
      for (; ; ) {
        let o = i[0];
        if (VD(o) || YD(o))
          n = !0, this.print(i.shift()), i.length && (this.tokenChar(44), this.space());
        else
          break;
      }
      let a = !1;
      if ((i.length || !i.length && !n) && (a = !0, this.tokenChar(123), i.length && (this.space(), this.printList(i, this.shouldPrintTrailingComma(
      "}")), this.space()), this.tokenChar(125)), t.source) {
        var e, r;
        this.space(), this.word("from"), this.space(), (e = t.attributes) != null && e.length || (r = t.assertions) != null && r.length ? (this.
        print(t.source, !0), this.space(), this._printAttributes(t, a)) : this.print(t.source);
      }
      this.semicolon();
    }
  }
  s(ek, "ExportNamedDeclaration");
  function tk(t) {
    yc(this, t), this.word("export"), this.noIndentInnerCommentsHere(), this.space(), this.word("default"), this.space(), this.tokenContext |=
    UD.TokenContext.exportDefault;
    let e = t.declaration;
    this.print(e), mc(e) || this.semicolon();
  }
  s(tk, "ExportDefaultDeclaration");
  function rk(t) {
    var e, r;
    this.word("import"), this.space();
    let i = t.importKind === "type" || t.importKind === "typeof";
    i ? (this.noIndentInnerCommentsHere(), this.word(t.importKind), this.space()) : t.module ? (this.noIndentInnerCommentsHere(), this.word(
    "module"), this.space()) : t.phase && (this.noIndentInnerCommentsHere(), this.word(t.phase), this.space());
    let n = t.specifiers.slice(0), a = !!n.length;
    for (; a; ) {
      let l = n[0];
      if (JD(l) || XD(l))
        this.print(n.shift()), n.length && (this.tokenChar(44), this.space());
      else
        break;
    }
    let o = !1;
    n.length ? (o = !0, this.tokenChar(123), this.space(), this.printList(n, this.shouldPrintTrailingComma("}")), this.space(), this.tokenChar(
    125)) : i && !a && (o = !0, this.tokenChar(123), this.tokenChar(125)), (a || i) && (this.space(), this.word("from"), this.space()), (e =
    t.attributes) != null && e.length || (r = t.assertions) != null && r.length ? (this.print(t.source, !0), this.space(), this._printAttributes(
    t, o)) : this.print(t.source), this.semicolon();
  }
  s(rk, "ImportDeclaration");
  function ik(t) {
    this.print(t.key), this.tokenChar(58), this.space(), this.print(t.value);
  }
  s(ik, "ImportAttribute");
  function sk(t) {
    this.tokenChar(42), this.space(), this.word("as"), this.space(), this.print(t.local);
  }
  s(sk, "ImportNamespaceSpecifier");
  function nk(t) {
    this.word("import"), t.phase && (this.tokenChar(46), this.word(t.phase)), this.tokenChar(40), this.print(t.source), t.options != null &&
    (this.tokenChar(44), this.space(), this.print(t.options)), this.tokenChar(41);
  }
  s(nk, "ImportExpression");
});

// ../node_modules/jsesc/jsesc.js
var xc = O((kR, bc) => {
  "use strict";
  var Tc = {}, ak = Tc.hasOwnProperty, Sc = /* @__PURE__ */ s((t, e) => {
    for (let r in t)
      ak.call(t, r) && e(r, t[r]);
  }, "forOwn"), ok = /* @__PURE__ */ s((t, e) => (e && Sc(e, (r, i) => {
    t[r] = i;
  }), t), "extend"), lk = /* @__PURE__ */ s((t, e) => {
    let r = t.length, i = -1;
    for (; ++i < r; )
      e(t[i]);
  }, "forEach"), Fi = /* @__PURE__ */ s((t) => "\\u" + ("0000" + t).slice(-4), "fourHexEscape"), Fr = /* @__PURE__ */ s((t, e) => {
    let r = t.toString(16);
    return e ? r : r.toUpperCase();
  }, "hexadecimal"), Rr = Tc.toString, uk = Array.isArray, ck = /* @__PURE__ */ s((t) => typeof Buffer == "function" && Buffer.isBuffer(t), "\
isBuffer"), pk = /* @__PURE__ */ s((t) => Rr.call(t) == "[object Object]", "isObject"), fk = /* @__PURE__ */ s((t) => typeof t == "string" ||
  Rr.call(t) == "[object String]", "isString"), hk = /* @__PURE__ */ s((t) => typeof t == "number" || Rr.call(t) == "[object Number]", "isNu\
mber"), Na = /* @__PURE__ */ s((t) => typeof t == "bigint", "isBigInt"), dk = /* @__PURE__ */ s((t) => typeof t == "function", "isFunction"),
  mk = /* @__PURE__ */ s((t) => Rr.call(t) == "[object Map]", "isMap"), yk = /* @__PURE__ */ s((t) => Rr.call(t) == "[object Set]", "isSet"),
  Tk = {
    "\\": "\\\\",
    "\b": "\\b",
    "\f": "\\f",
    "\n": "\\n",
    "\r": "\\r",
    "	": "\\t"
    // `\v` is omitted intentionally, because in IE < 9, '\v' == 'v'.
    // '\v': '\\x0B'
  }, Sk = /[\\\b\f\n\r\t]/, bk = /[0-9]/, xk = /[\xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/, Pk = /([\uD800-\uDBFF][\uDC00-\uDFFF])|([\uD800-\uDFFF])|(['"`])|[^]/g,
  Ek = /([\uD800-\uDBFF][\uDC00-\uDFFF])|([\uD800-\uDFFF])|(['"`])|[^ !#-&\(-\[\]-_a-~]/g, Rt = /* @__PURE__ */ s((t, e) => {
    let r = /* @__PURE__ */ s(() => {
      p = u, ++e.indentLevel, u = e.indent.repeat(e.indentLevel);
    }, "increaseIndentation"), i = {
      escapeEverything: !1,
      minimal: !1,
      isScriptContext: !1,
      quotes: "single",
      wrap: !1,
      es6: !1,
      json: !1,
      compact: !0,
      lowercaseHex: !1,
      numbers: "decimal",
      indent: "	",
      indentLevel: 0,
      __inline1__: !1,
      __inline2__: !1
    }, n = e && e.json;
    n && (i.quotes = "double", i.wrap = !0), e = ok(i, e), e.quotes != "single" && e.quotes != "double" && e.quotes != "backtick" && (e.quotes =
    "single");
    let a = e.quotes == "double" ? '"' : e.quotes == "backtick" ? "`" : "'", o = e.compact, l = e.lowercaseHex, u = e.indent.repeat(e.indentLevel),
    p = "", m = e.__inline1__, g = e.__inline2__, I = o ? "" : `
`, v, _ = !0, V = e.numbers == "binary", D = e.numbers == "octal", L = e.numbers == "decimal", B = e.numbers == "hexadecimal";
    if (n && t && dk(t.toJSON) && (t = t.toJSON()), !fk(t)) {
      if (mk(t))
        return t.size == 0 ? "new Map()" : (o || (e.__inline1__ = !0, e.__inline2__ = !1), "new Map(" + Rt(Array.from(t), e) + ")");
      if (yk(t))
        return t.size == 0 ? "new Set()" : "new Set(" + Rt(Array.from(t), e) + ")";
      if (ck(t))
        return t.length == 0 ? "Buffer.from([])" : "Buffer.from(" + Rt(Array.from(t), e) + ")";
      if (uk(t))
        return v = [], e.wrap = !0, m && (e.__inline1__ = !1, e.__inline2__ = !0), g || r(), lk(t, (ee) => {
          _ = !1, g && (e.__inline2__ = !1), v.push(
            (o || g ? "" : u) + Rt(ee, e)
          );
        }), _ ? "[]" : g ? "[" + v.join(", ") + "]" : "[" + I + v.join("," + I) + I + (o ? "" : p) + "]";
      if (hk(t) || Na(t)) {
        if (n)
          return JSON.stringify(Number(t));
        let ee;
        if (L)
          ee = String(t);
        else if (B) {
          let Te = t.toString(16);
          l || (Te = Te.toUpperCase()), ee = "0x" + Te;
        } else V ? ee = "0b" + t.toString(2) : D && (ee = "0o" + t.toString(8));
        return Na(t) ? ee + "n" : ee;
      } else return Na(t) ? n ? JSON.stringify(Number(t)) : t + "n" : pk(t) ? (v = [], e.wrap = !0, r(), Sc(t, (ee, Te) => {
        _ = !1, v.push(
          (o ? "" : u) + Rt(ee, e) + ":" + (o ? "" : " ") + Rt(Te, e)
        );
      }), _ ? "{}" : "{" + I + v.join("," + I) + I + (o ? "" : p) + "}") : n ? JSON.stringify(t) || "null" : String(t);
    }
    let fe = e.escapeEverything ? Pk : Ek;
    return v = t.replace(fe, (ee, Te, Le, Ue, Je, $) => {
      if (Te) {
        if (e.minimal) return Te;
        let w = Te.charCodeAt(0), W = Te.charCodeAt(1);
        if (e.es6) {
          let le = (w - 55296) * 1024 + W - 56320 + 65536;
          return "\\u{" + Fr(le, l) + "}";
        }
        return Fi(Fr(w, l)) + Fi(Fr(W, l));
      }
      if (Le)
        return Fi(Fr(Le.charCodeAt(0), l));
      if (ee == "\0" && !n && !bk.test($.charAt(Je + 1)))
        return "\\0";
      if (Ue)
        return Ue == a || e.escapeEverything ? "\\" + Ue : Ue;
      if (Sk.test(ee))
        return Tk[ee];
      if (e.minimal && !xk.test(ee))
        return ee;
      let Y = Fr(ee.charCodeAt(0), l);
      return n || Y.length > 2 ? Fi(Y) : "\\x" + ("00" + Y).slice(-2);
    }), a == "`" && (v = v.replace(/\$\{/g, "\\${")), e.isScriptContext && (v = v.replace(/<\/(script|style)/gi, "<\\/$1").replace(/<!--/g, n ?
    "\\u003C!--" : "\\x3C!--")), e.wrap && (v = a + v + a), v;
  }, "jsesc");
  Rt.version = "3.0.2";
  bc.exports = Rt;
});

// ../node_modules/@babel/generator/lib/generators/types.js
var _a = O((_e) => {
  "use strict";
  Object.defineProperty(_e, "__esModule", {
    value: !0
  });
  _e.ArgumentPlaceholder = Ck;
  _e.ArrayPattern = _e.ArrayExpression = Dk;
  _e.BigIntLiteral = qk;
  _e.BooleanLiteral = Bk;
  _e.Identifier = vk;
  _e.NullLiteral = jk;
  _e.NumericLiteral = Fk;
  _e.ObjectPattern = _e.ObjectExpression = Nk;
  _e.ObjectMethod = Ok;
  _e.ObjectProperty = _k;
  _e.PipelineBareFunction = Vk;
  _e.PipelinePrimaryTopicReference = Yk;
  _e.PipelineTopicExpression = Kk;
  _e.RecordExpression = kk;
  _e.RegExpLiteral = Mk;
  _e.SpreadElement = _e.RestElement = wk;
  _e.StringLiteral = Rk;
  _e.TopicReference = Uk;
  _e.TupleExpression = Lk;
  _e._getRawIdentifier = Ik;
  var gk = Ye(), gc = xc(), {
    isAssignmentPattern: Ak,
    isIdentifier: Oa
  } = gk, Pc = null, Ri = "";
  function Ik(t) {
    if (t === Pc) return Ri;
    Pc = t;
    let {
      name: e
    } = t, r = this.tokenMap.find(t, (i) => i.value === e);
    return r ? (Ri = this._originalCode.slice(r.start, r.end), Ri) : Ri = t.name;
  }
  s(Ik, "_getRawIdentifier");
  function vk(t) {
    var e;
    this.sourceIdentifierName(((e = t.loc) == null ? void 0 : e.identifierName) || t.name), this.word(this.tokenMap ? this._getRawIdentifier(
    t) : t.name);
  }
  s(vk, "Identifier");
  function Ck() {
    this.tokenChar(63);
  }
  s(Ck, "ArgumentPlaceholder");
  function wk(t) {
    this.token("..."), this.print(t.argument);
  }
  s(wk, "RestElement");
  function Nk(t) {
    let e = t.properties;
    if (this.tokenChar(123), e.length) {
      let r = this.enterDelimited();
      this.space(), this.printList(e, this.shouldPrintTrailingComma("}"), !0, !0), this.space(), r();
    }
    this.sourceWithOffset("end", t.loc, -1), this.tokenChar(125);
  }
  s(Nk, "ObjectExpression");
  function Ok(t) {
    this.printJoin(t.decorators), this._methodHead(t), this.space(), this.print(t.body);
  }
  s(Ok, "ObjectMethod");
  function _k(t) {
    if (this.printJoin(t.decorators), t.computed)
      this.tokenChar(91), this.print(t.key), this.tokenChar(93);
    else {
      if (Ak(t.value) && Oa(t.key) && t.key.name === t.value.left.name) {
        this.print(t.value);
        return;
      }
      if (this.print(t.key), t.shorthand && Oa(t.key) && Oa(t.value) && t.key.name === t.value.name)
        return;
    }
    this.tokenChar(58), this.space(), this.print(t.value);
  }
  s(_k, "ObjectProperty");
  function Dk(t) {
    let e = t.elements, r = e.length;
    this.tokenChar(91);
    let i = this.enterDelimited();
    for (let n = 0; n < e.length; n++) {
      let a = e[n];
      a ? (n > 0 && this.space(), this.print(a), (n < r - 1 || this.shouldPrintTrailingComma("]")) && this.token(",", !1, n)) : this.token("\
,", !1, n);
    }
    i(), this.tokenChar(93);
  }
  s(Dk, "ArrayExpression");
  function kk(t) {
    let e = t.properties, r, i;
    if (this.format.recordAndTupleSyntaxType === "bar")
      r = "{|", i = "|}";
    else {
      if (this.format.recordAndTupleSyntaxType !== "hash" && this.format.recordAndTupleSyntaxType != null)
        throw new Error(`The "recordAndTupleSyntaxType" generator option must be "bar" or "hash" (${JSON.stringify(this.format.recordAndTupleSyntaxType)}\
 received).`);
      r = "#{", i = "}";
    }
    this.token(r), e.length && (this.space(), this.printList(e, this.shouldPrintTrailingComma(i), !0, !0), this.space()), this.token(i);
  }
  s(kk, "RecordExpression");
  function Lk(t) {
    let e = t.elements, r = e.length, i, n;
    if (this.format.recordAndTupleSyntaxType === "bar")
      i = "[|", n = "|]";
    else if (this.format.recordAndTupleSyntaxType === "hash")
      i = "#[", n = "]";
    else
      throw new Error(`${this.format.recordAndTupleSyntaxType} is not a valid recordAndTuple syntax type`);
    this.token(i);
    for (let a = 0; a < e.length; a++) {
      let o = e[a];
      o && (a > 0 && this.space(), this.print(o), (a < r - 1 || this.shouldPrintTrailingComma(n)) && this.token(",", !1, a));
    }
    this.token(n);
  }
  s(Lk, "TupleExpression");
  function Mk(t) {
    this.word(`/${t.pattern}/${t.flags}`);
  }
  s(Mk, "RegExpLiteral");
  function Bk(t) {
    this.word(t.value ? "true" : "false");
  }
  s(Bk, "BooleanLiteral");
  function jk() {
    this.word("null");
  }
  s(jk, "NullLiteral");
  function Fk(t) {
    let e = this.getPossibleRaw(t), r = this.format.jsescOption, i = t.value, n = i + "";
    r.numbers ? this.number(gc(i, r), i) : e == null ? this.number(n, i) : this.format.minified ? this.number(e.length < n.length ? e : n, i) :
    this.number(e, i);
  }
  s(Fk, "NumericLiteral");
  function Rk(t) {
    let e = this.getPossibleRaw(t);
    if (!this.format.minified && e !== void 0) {
      this.token(e);
      return;
    }
    let r = gc(t.value, this.format.jsescOption);
    this.token(r);
  }
  s(Rk, "StringLiteral");
  function qk(t) {
    let e = this.getPossibleRaw(t);
    if (!this.format.minified && e !== void 0) {
      this.word(e);
      return;
    }
    this.word(t.value + "n");
  }
  s(qk, "BigIntLiteral");
  var Ec = /* @__PURE__ */ new Set(["^^", "@@", "^", "%", "#"]);
  function Uk() {
    let {
      topicToken: t
    } = this.format;
    if (Ec.has(t))
      this.token(t);
    else {
      let e = JSON.stringify(t), r = Array.from(Ec, (i) => JSON.stringify(i));
      throw new Error(`The "topicToken" generator option must be one of ${r.join(", ")} (${e} received instead).`);
    }
  }
  s(Uk, "TopicReference");
  function Kk(t) {
    this.print(t.expression);
  }
  s(Kk, "PipelineTopicExpression");
  function Vk(t) {
    this.print(t.callee);
  }
  s(Vk, "PipelineBareFunction");
  function Yk() {
    this.tokenChar(35);
  }
  s(Yk, "PipelinePrimaryTopicReference");
});

// ../node_modules/@babel/generator/lib/generators/flow.js
var Ic = O((H) => {
  "use strict";
  Object.defineProperty(H, "__esModule", {
    value: !0
  });
  H.AnyTypeAnnotation = $k;
  H.ArrayTypeAnnotation = Hk;
  H.BooleanLiteralTypeAnnotation = Qk;
  H.BooleanTypeAnnotation = Gk;
  H.DeclareClass = e2;
  H.DeclareExportAllDeclaration = p2;
  H.DeclareExportDeclaration = c2;
  H.DeclareFunction = t2;
  H.DeclareInterface = s2;
  H.DeclareModule = n2;
  H.DeclareModuleExports = a2;
  H.DeclareOpaqueType = l2;
  H.DeclareTypeAlias = o2;
  H.DeclareVariable = u2;
  H.DeclaredPredicate = i2;
  H.EmptyTypeAnnotation = k2;
  H.EnumBooleanBody = h2;
  H.EnumBooleanMember = S2;
  H.EnumDeclaration = f2;
  H.EnumDefaultedMember = T2;
  H.EnumNumberBody = d2;
  H.EnumNumberMember = b2;
  H.EnumStringBody = m2;
  H.EnumStringMember = x2;
  H.EnumSymbolBody = y2;
  H.ExistsTypeAnnotation = E2;
  H.FunctionTypeAnnotation = g2;
  H.FunctionTypeParam = A2;
  H.IndexedAccessType = sL;
  H.InferredPredicate = r2;
  H.InterfaceDeclaration = w2;
  H.GenericTypeAnnotation = H.ClassImplements = H.InterfaceExtends = I2;
  H.InterfaceTypeAnnotation = O2;
  H.IntersectionTypeAnnotation = _2;
  H.MixedTypeAnnotation = D2;
  H.NullLiteralTypeAnnotation = Zk;
  H.NullableTypeAnnotation = L2;
  Object.defineProperty(H, "NumberLiteralTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Ac.NumericLiteral;
    }, "get")
  });
  H.NumberTypeAnnotation = M2;
  H.ObjectTypeAnnotation = J2;
  H.ObjectTypeCallProperty = W2;
  H.ObjectTypeIndexer = z2;
  H.ObjectTypeInternalSlot = X2;
  H.ObjectTypeProperty = $2;
  H.ObjectTypeSpreadProperty = H2;
  H.OpaqueType = Y2;
  H.OptionalIndexedAccessType = nL;
  H.QualifiedTypeIdentifier = G2;
  Object.defineProperty(H, "StringLiteralTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Ac.StringLiteral;
    }, "get")
  });
  H.StringTypeAnnotation = B2;
  H.SymbolTypeAnnotation = Q2;
  H.ThisTypeAnnotation = j2;
  H.TupleTypeAnnotation = F2;
  H.TypeAlias = q2;
  H.TypeAnnotation = U2;
  H.TypeCastExpression = tL;
  H.TypeParameter = V2;
  H.TypeParameterDeclaration = H.TypeParameterInstantiation = K2;
  H.TypeofTypeAnnotation = R2;
  H.UnionTypeAnnotation = eL;
  H.Variance = rL;
  H.VoidTypeAnnotation = iL;
  H._interfaceish = v2;
  H._variance = C2;
  var Jk = Ye(), Xk = wa(), Wk = Ft(), Ac = _a(), {
    isDeclareExportDeclaration: qi,
    isStatement: zk
  } = Jk;
  function $k() {
    this.word("any");
  }
  s($k, "AnyTypeAnnotation");
  function Hk(t) {
    this.print(t.elementType, !0), this.tokenChar(91), this.tokenChar(93);
  }
  s(Hk, "ArrayTypeAnnotation");
  function Gk() {
    this.word("boolean");
  }
  s(Gk, "BooleanTypeAnnotation");
  function Qk(t) {
    this.word(t.value ? "true" : "false");
  }
  s(Qk, "BooleanLiteralTypeAnnotation");
  function Zk() {
    this.word("null");
  }
  s(Zk, "NullLiteralTypeAnnotation");
  function e2(t, e) {
    qi(e) || (this.word("declare"), this.space()), this.word("class"), this.space(), this._interfaceish(t);
  }
  s(e2, "DeclareClass");
  function t2(t, e) {
    qi(e) || (this.word("declare"), this.space()), this.word("function"), this.space(), this.print(t.id), this.print(t.id.typeAnnotation.typeAnnotation),
    t.predicate && (this.space(), this.print(t.predicate)), this.semicolon();
  }
  s(t2, "DeclareFunction");
  function r2() {
    this.tokenChar(37), this.word("checks");
  }
  s(r2, "InferredPredicate");
  function i2(t) {
    this.tokenChar(37), this.word("checks"), this.tokenChar(40), this.print(t.value), this.tokenChar(41);
  }
  s(i2, "DeclaredPredicate");
  function s2(t) {
    this.word("declare"), this.space(), this.InterfaceDeclaration(t);
  }
  s(s2, "DeclareInterface");
  function n2(t) {
    this.word("declare"), this.space(), this.word("module"), this.space(), this.print(t.id), this.space(), this.print(t.body);
  }
  s(n2, "DeclareModule");
  function a2(t) {
    this.word("declare"), this.space(), this.word("module"), this.tokenChar(46), this.word("exports"), this.print(t.typeAnnotation);
  }
  s(a2, "DeclareModuleExports");
  function o2(t) {
    this.word("declare"), this.space(), this.TypeAlias(t);
  }
  s(o2, "DeclareTypeAlias");
  function l2(t, e) {
    qi(e) || (this.word("declare"), this.space()), this.OpaqueType(t);
  }
  s(l2, "DeclareOpaqueType");
  function u2(t, e) {
    qi(e) || (this.word("declare"), this.space()), this.word("var"), this.space(), this.print(t.id), this.print(t.id.typeAnnotation), this.semicolon();
  }
  s(u2, "DeclareVariable");
  function c2(t) {
    this.word("declare"), this.space(), this.word("export"), this.space(), t.default && (this.word("default"), this.space()), P2.call(this, t);
  }
  s(c2, "DeclareExportDeclaration");
  function p2(t) {
    this.word("declare"), this.space(), Xk.ExportAllDeclaration.call(this, t);
  }
  s(p2, "DeclareExportAllDeclaration");
  function f2(t) {
    let {
      id: e,
      body: r
    } = t;
    this.word("enum"), this.space(), this.print(e), this.print(r);
  }
  s(f2, "EnumDeclaration");
  function Ui(t, e, r) {
    r && (t.space(), t.word("of"), t.space(), t.word(e)), t.space();
  }
  s(Ui, "enumExplicitType");
  function Ki(t, e) {
    let {
      members: r
    } = e;
    t.token("{"), t.indent(), t.newline();
    for (let i of r)
      t.print(i), t.newline();
    e.hasUnknownMembers && (t.token("..."), t.newline()), t.dedent(), t.token("}");
  }
  s(Ki, "enumBody");
  function h2(t) {
    let {
      explicitType: e
    } = t;
    Ui(this, "boolean", e), Ki(this, t);
  }
  s(h2, "EnumBooleanBody");
  function d2(t) {
    let {
      explicitType: e
    } = t;
    Ui(this, "number", e), Ki(this, t);
  }
  s(d2, "EnumNumberBody");
  function m2(t) {
    let {
      explicitType: e
    } = t;
    Ui(this, "string", e), Ki(this, t);
  }
  s(m2, "EnumStringBody");
  function y2(t) {
    Ui(this, "symbol", !0), Ki(this, t);
  }
  s(y2, "EnumSymbolBody");
  function T2(t) {
    let {
      id: e
    } = t;
    this.print(e), this.tokenChar(44);
  }
  s(T2, "EnumDefaultedMember");
  function Da(t, e) {
    t.print(e.id), t.space(), t.token("="), t.space(), t.print(e.init), t.token(",");
  }
  s(Da, "enumInitializedMember");
  function S2(t) {
    Da(this, t);
  }
  s(S2, "EnumBooleanMember");
  function b2(t) {
    Da(this, t);
  }
  s(b2, "EnumNumberMember");
  function x2(t) {
    Da(this, t);
  }
  s(x2, "EnumStringMember");
  function P2(t) {
    if (t.declaration) {
      let e = t.declaration;
      this.print(e), zk(e) || this.semicolon();
    } else
      this.tokenChar(123), t.specifiers.length && (this.space(), this.printList(t.specifiers), this.space()), this.tokenChar(125), t.source &&
      (this.space(), this.word("from"), this.space(), this.print(t.source)), this.semicolon();
  }
  s(P2, "FlowExportDeclaration");
  function E2() {
    this.tokenChar(42);
  }
  s(E2, "ExistsTypeAnnotation");
  function g2(t, e) {
    this.print(t.typeParameters), this.tokenChar(40), t.this && (this.word("this"), this.tokenChar(58), this.space(), this.print(t.this.typeAnnotation),
    (t.params.length || t.rest) && (this.tokenChar(44), this.space())), this.printList(t.params), t.rest && (t.params.length && (this.tokenChar(
    44), this.space()), this.token("..."), this.print(t.rest)), this.tokenChar(41);
    let r = e?.type;
    r != null && (r === "ObjectTypeCallProperty" || r === "ObjectTypeInternalSlot" || r === "DeclareFunction" || r === "ObjectTypeProperty" &&
    e.method) ? this.tokenChar(58) : (this.space(), this.token("=>")), this.space(), this.print(t.returnType);
  }
  s(g2, "FunctionTypeAnnotation");
  function A2(t) {
    this.print(t.name), t.optional && this.tokenChar(63), t.name && (this.tokenChar(58), this.space()), this.print(t.typeAnnotation);
  }
  s(A2, "FunctionTypeParam");
  function I2(t) {
    this.print(t.id), this.print(t.typeParameters, !0);
  }
  s(I2, "InterfaceExtends");
  function v2(t) {
    var e;
    if (this.print(t.id), this.print(t.typeParameters), (e = t.extends) != null && e.length && (this.space(), this.word("extends"), this.space(),
    this.printList(t.extends)), t.type === "DeclareClass") {
      var r, i;
      (r = t.mixins) != null && r.length && (this.space(), this.word("mixins"), this.space(), this.printList(t.mixins)), (i = t.implements) !=
      null && i.length && (this.space(), this.word("implements"), this.space(), this.printList(t.implements));
    }
    this.space(), this.print(t.body);
  }
  s(v2, "_interfaceish");
  function C2(t) {
    var e;
    let r = (e = t.variance) == null ? void 0 : e.kind;
    r != null && (r === "plus" ? this.tokenChar(43) : r === "minus" && this.tokenChar(45));
  }
  s(C2, "_variance");
  function w2(t) {
    this.word("interface"), this.space(), this._interfaceish(t);
  }
  s(w2, "InterfaceDeclaration");
  function N2(t) {
    this.space(), this.token("&", !1, t), this.space();
  }
  s(N2, "andSeparator");
  function O2(t) {
    var e;
    this.word("interface"), (e = t.extends) != null && e.length && (this.space(), this.word("extends"), this.space(), this.printList(t.extends)),
    this.space(), this.print(t.body);
  }
  s(O2, "InterfaceTypeAnnotation");
  function _2(t) {
    this.printJoin(t.types, void 0, void 0, N2);
  }
  s(_2, "IntersectionTypeAnnotation");
  function D2() {
    this.word("mixed");
  }
  s(D2, "MixedTypeAnnotation");
  function k2() {
    this.word("empty");
  }
  s(k2, "EmptyTypeAnnotation");
  function L2(t) {
    this.tokenChar(63), this.print(t.typeAnnotation);
  }
  s(L2, "NullableTypeAnnotation");
  function M2() {
    this.word("number");
  }
  s(M2, "NumberTypeAnnotation");
  function B2() {
    this.word("string");
  }
  s(B2, "StringTypeAnnotation");
  function j2() {
    this.word("this");
  }
  s(j2, "ThisTypeAnnotation");
  function F2(t) {
    this.tokenChar(91), this.printList(t.types), this.tokenChar(93);
  }
  s(F2, "TupleTypeAnnotation");
  function R2(t) {
    this.word("typeof"), this.space(), this.print(t.argument);
  }
  s(R2, "TypeofTypeAnnotation");
  function q2(t) {
    this.word("type"), this.space(), this.print(t.id), this.print(t.typeParameters), this.space(), this.tokenChar(61), this.space(), this.print(
    t.right), this.semicolon();
  }
  s(q2, "TypeAlias");
  function U2(t, e) {
    this.tokenChar(58), this.space(), e.type === "ArrowFunctionExpression" ? this.tokenContext |= Wk.TokenContext.arrowFlowReturnType : t.optional &&
    this.tokenChar(63), this.print(t.typeAnnotation);
  }
  s(U2, "TypeAnnotation");
  function K2(t) {
    this.tokenChar(60), this.printList(t.params), this.tokenChar(62);
  }
  s(K2, "TypeParameterInstantiation");
  function V2(t) {
    this._variance(t), this.word(t.name), t.bound && this.print(t.bound), t.default && (this.space(), this.tokenChar(61), this.space(), this.
    print(t.default));
  }
  s(V2, "TypeParameter");
  function Y2(t) {
    this.word("opaque"), this.space(), this.word("type"), this.space(), this.print(t.id), this.print(t.typeParameters), t.supertype && (this.
    tokenChar(58), this.space(), this.print(t.supertype)), t.impltype && (this.space(), this.tokenChar(61), this.space(), this.print(t.impltype)),
    this.semicolon();
  }
  s(Y2, "OpaqueType");
  function J2(t) {
    t.exact ? this.token("{|") : this.tokenChar(123);
    let e = [...t.properties, ...t.callProperties || [], ...t.indexers || [], ...t.internalSlots || []];
    e.length && (this.newline(), this.space(), this.printJoin(e, !0, !0, void 0, void 0, /* @__PURE__ */ s(function(i) {
      if (i && !e[0]) return 1;
    }, "addNewlines"), () => {
      (e.length !== 1 || t.inexact) && (this.tokenChar(44), this.space());
    }), this.space()), t.inexact && (this.indent(), this.token("..."), e.length && this.newline(), this.dedent()), t.exact ? this.token("|}") :
    this.tokenChar(125);
  }
  s(J2, "ObjectTypeAnnotation");
  function X2(t) {
    t.static && (this.word("static"), this.space()), this.tokenChar(91), this.tokenChar(91), this.print(t.id), this.tokenChar(93), this.tokenChar(
    93), t.optional && this.tokenChar(63), t.method || (this.tokenChar(58), this.space()), this.print(t.value);
  }
  s(X2, "ObjectTypeInternalSlot");
  function W2(t) {
    t.static && (this.word("static"), this.space()), this.print(t.value);
  }
  s(W2, "ObjectTypeCallProperty");
  function z2(t) {
    t.static && (this.word("static"), this.space()), this._variance(t), this.tokenChar(91), t.id && (this.print(t.id), this.tokenChar(58), this.
    space()), this.print(t.key), this.tokenChar(93), this.tokenChar(58), this.space(), this.print(t.value);
  }
  s(z2, "ObjectTypeIndexer");
  function $2(t) {
    t.proto && (this.word("proto"), this.space()), t.static && (this.word("static"), this.space()), (t.kind === "get" || t.kind === "set") &&
    (this.word(t.kind), this.space()), this._variance(t), this.print(t.key), t.optional && this.tokenChar(63), t.method || (this.tokenChar(58),
    this.space()), this.print(t.value);
  }
  s($2, "ObjectTypeProperty");
  function H2(t) {
    this.token("..."), this.print(t.argument);
  }
  s(H2, "ObjectTypeSpreadProperty");
  function G2(t) {
    this.print(t.qualification), this.tokenChar(46), this.print(t.id);
  }
  s(G2, "QualifiedTypeIdentifier");
  function Q2() {
    this.word("symbol");
  }
  s(Q2, "SymbolTypeAnnotation");
  function Z2(t) {
    this.space(), this.token("|", !1, t), this.space();
  }
  s(Z2, "orSeparator");
  function eL(t) {
    this.printJoin(t.types, void 0, void 0, Z2);
  }
  s(eL, "UnionTypeAnnotation");
  function tL(t) {
    this.tokenChar(40), this.print(t.expression), this.print(t.typeAnnotation), this.tokenChar(41);
  }
  s(tL, "TypeCastExpression");
  function rL(t) {
    t.kind === "plus" ? this.tokenChar(43) : this.tokenChar(45);
  }
  s(rL, "Variance");
  function iL() {
    this.word("void");
  }
  s(iL, "VoidTypeAnnotation");
  function sL(t) {
    this.print(t.objectType, !0), this.tokenChar(91), this.print(t.indexType), this.tokenChar(93);
  }
  s(sL, "IndexedAccessType");
  function nL(t) {
    this.print(t.objectType), t.optional && this.token("?."), this.tokenChar(91), this.print(t.indexType), this.tokenChar(93);
  }
  s(nL, "OptionalIndexedAccessType");
});

// ../node_modules/@babel/generator/lib/generators/base.js
var vc = O((Ct) => {
  "use strict";
  Object.defineProperty(Ct, "__esModule", {
    value: !0
  });
  Ct.BlockStatement = lL;
  Ct.Directive = uL;
  Ct.DirectiveLiteral = fL;
  Ct.File = aL;
  Ct.InterpreterDirective = hL;
  Ct.Placeholder = dL;
  Ct.Program = oL;
  function aL(t) {
    t.program && this.print(t.program.interpreter), this.print(t.program);
  }
  s(aL, "File");
  function oL(t) {
    var e;
    this.noIndentInnerCommentsHere(), this.printInnerComments();
    let r = (e = t.directives) == null ? void 0 : e.length;
    if (r) {
      var i;
      let n = t.body.length ? 2 : 1;
      this.printSequence(t.directives, void 0, n), (i = t.directives[r - 1].trailingComments) != null && i.length || this.newline(n);
    }
    this.printSequence(t.body);
  }
  s(oL, "Program");
  function lL(t) {
    var e;
    this.tokenChar(123);
    let r = this.enterDelimited(), i = (e = t.directives) == null ? void 0 : e.length;
    if (i) {
      var n;
      let a = t.body.length ? 2 : 1;
      this.printSequence(t.directives, !0, a), (n = t.directives[i - 1].trailingComments) != null && n.length || this.newline(a);
    }
    this.printSequence(t.body, !0), r(), this.rightBrace(t);
  }
  s(lL, "BlockStatement");
  function uL(t) {
    this.print(t.value), this.semicolon();
  }
  s(uL, "Directive");
  var cL = /(?:^|[^\\])(?:\\\\)*'/, pL = /(?:^|[^\\])(?:\\\\)*"/;
  function fL(t) {
    let e = this.getPossibleRaw(t);
    if (!this.format.minified && e !== void 0) {
      this.token(e);
      return;
    }
    let {
      value: r
    } = t;
    if (!pL.test(r))
      this.token(`"${r}"`);
    else if (!cL.test(r))
      this.token(`'${r}'`);
    else
      throw new Error("Malformed AST: it is not possible to print a directive containing both unescaped single and double quotes.");
  }
  s(fL, "DirectiveLiteral");
  function hL(t) {
    this.token(`#!${t.value}`), this.newline(1, !0);
  }
  s(hL, "InterpreterDirective");
  function dL(t) {
    this.token("%%"), this.print(t.name), this.token("%%"), t.expectedNode === "Statement" && this.semicolon();
  }
  s(dL, "Placeholder");
});

// ../node_modules/@babel/generator/lib/generators/jsx.js
var Cc = O((qe) => {
  "use strict";
  Object.defineProperty(qe, "__esModule", {
    value: !0
  });
  qe.JSXAttribute = mL;
  qe.JSXClosingElement = vL;
  qe.JSXClosingFragment = OL;
  qe.JSXElement = gL;
  qe.JSXEmptyExpression = CL;
  qe.JSXExpressionContainer = xL;
  qe.JSXFragment = wL;
  qe.JSXIdentifier = yL;
  qe.JSXMemberExpression = SL;
  qe.JSXNamespacedName = TL;
  qe.JSXOpeningElement = IL;
  qe.JSXOpeningFragment = NL;
  qe.JSXSpreadAttribute = bL;
  qe.JSXSpreadChild = PL;
  qe.JSXText = EL;
  function mL(t) {
    this.print(t.name), t.value && (this.tokenChar(61), this.print(t.value));
  }
  s(mL, "JSXAttribute");
  function yL(t) {
    this.word(t.name);
  }
  s(yL, "JSXIdentifier");
  function TL(t) {
    this.print(t.namespace), this.tokenChar(58), this.print(t.name);
  }
  s(TL, "JSXNamespacedName");
  function SL(t) {
    this.print(t.object), this.tokenChar(46), this.print(t.property);
  }
  s(SL, "JSXMemberExpression");
  function bL(t) {
    this.tokenChar(123), this.token("..."), this.print(t.argument), this.rightBrace(t);
  }
  s(bL, "JSXSpreadAttribute");
  function xL(t) {
    this.tokenChar(123), this.print(t.expression), this.rightBrace(t);
  }
  s(xL, "JSXExpressionContainer");
  function PL(t) {
    this.tokenChar(123), this.token("..."), this.print(t.expression), this.rightBrace(t);
  }
  s(PL, "JSXSpreadChild");
  function EL(t) {
    let e = this.getPossibleRaw(t);
    e !== void 0 ? this.token(e, !0) : this.token(t.value, !0);
  }
  s(EL, "JSXText");
  function gL(t) {
    let e = t.openingElement;
    if (this.print(e), !e.selfClosing) {
      this.indent();
      for (let r of t.children)
        this.print(r);
      this.dedent(), this.print(t.closingElement);
    }
  }
  s(gL, "JSXElement");
  function AL() {
    this.space();
  }
  s(AL, "spaceSeparator");
  function IL(t) {
    this.tokenChar(60), this.print(t.name), t.typeArguments && this.print(t.typeArguments), this.print(t.typeParameters), t.attributes.length >
    0 && (this.space(), this.printJoin(t.attributes, void 0, void 0, AL)), t.selfClosing && (this.space(), this.tokenChar(47)), this.tokenChar(
    62);
  }
  s(IL, "JSXOpeningElement");
  function vL(t) {
    this.tokenChar(60), this.tokenChar(47), this.print(t.name), this.tokenChar(62);
  }
  s(vL, "JSXClosingElement");
  function CL() {
    this.printInnerComments();
  }
  s(CL, "JSXEmptyExpression");
  function wL(t) {
    this.print(t.openingFragment), this.indent();
    for (let e of t.children)
      this.print(e);
    this.dedent(), this.print(t.closingFragment);
  }
  s(wL, "JSXFragment");
  function NL() {
    this.tokenChar(60), this.tokenChar(62);
  }
  s(NL, "JSXOpeningFragment");
  function OL() {
    this.token("</"), this.tokenChar(62);
  }
  s(OL, "JSXClosingFragment");
});

// ../node_modules/@babel/generator/lib/generators/typescript.js
var Dc = O((X) => {
  "use strict";
  Object.defineProperty(X, "__esModule", {
    value: !0
  });
  X.TSAnyKeyword = YL;
  X.TSArrayType = pM;
  X.TSSatisfiesExpression = X.TSAsExpression = OM;
  X.TSBigIntKeyword = JL;
  X.TSBooleanKeyword = $L;
  X.TSCallSignatureDeclaration = FL;
  X.TSInterfaceHeritage = X.TSClassImplements = vM;
  X.TSConditionalType = SM;
  X.TSConstructSignatureDeclaration = RL;
  X.TSConstructorType = nM;
  X.TSDeclareFunction = ML;
  X.TSDeclareMethod = BL;
  X.TSEnumBody = _c;
  X.TSEnumDeclaration = kM;
  X.TSEnumMember = LM;
  X.TSExportAssignment = UM;
  X.TSExternalModuleReference = RM;
  X.TSFunctionType = sM;
  X.TSImportEqualsDeclaration = FM;
  X.TSImportType = jM;
  X.TSIndexSignature = VL;
  X.TSIndexedAccessType = EM;
  X.TSInferType = bM;
  X.TSInstantiationExpression = DM;
  X.TSInterfaceBody = wM;
  X.TSInterfaceDeclaration = CM;
  X.TSIntersectionType = TM;
  X.TSIntrinsicKeyword = rM;
  X.TSLiteralType = IM;
  X.TSMappedType = gM;
  X.TSMethodSignature = KL;
  X.TSModuleBlock = BM;
  X.TSModuleDeclaration = MM;
  X.TSNamedTupleMember = mM;
  X.TSNamespaceExportDeclaration = KM;
  X.TSNeverKeyword = tM;
  X.TSNonNullExpression = qM;
  X.TSNullKeyword = eM;
  X.TSNumberKeyword = WL;
  X.TSObjectKeyword = zL;
  X.TSOptionalType = hM;
  X.TSParameterProperty = LL;
  X.TSParenthesizedType = xM;
  X.TSPropertySignature = qL;
  X.TSQualifiedName = jL;
  X.TSRestType = dM;
  X.TSStringKeyword = HL;
  X.TSSymbolKeyword = GL;
  X.TSTemplateLiteralType = AM;
  X.TSThisType = iM;
  X.TSTupleType = fM;
  X.TSTypeAliasDeclaration = NM;
  X.TSTypeAnnotation = _L;
  X.TSTypeAssertion = _M;
  X.TSTypeLiteral = cM;
  X.TSTypeOperator = PM;
  X.TSTypeParameter = kL;
  X.TSTypeParameterDeclaration = X.TSTypeParameterInstantiation = DL;
  X.TSTypePredicate = lM;
  X.TSTypeQuery = uM;
  X.TSTypeReference = oM;
  X.TSUndefinedKeyword = ZL;
  X.TSUnionType = yM;
  X.TSUnknownKeyword = XL;
  X.TSVoidKeyword = QL;
  X.tsPrintClassMemberModifiers = YM;
  X.tsPrintFunctionOrConstructorType = aM;
  X.tsPrintPropertyOrMethodName = UL;
  X.tsPrintSignatureDeclarationBase = VM;
  function _L(t, e) {
    this.token((e.type === "TSFunctionType" || e.type === "TSConstructorType") && e.typeAnnotation === t ? "=>" : ":"), this.space(), t.optional &&
    this.tokenChar(63), this.print(t.typeAnnotation);
  }
  s(_L, "TSTypeAnnotation");
  function DL(t, e) {
    this.tokenChar(60);
    let r = e.type === "ArrowFunctionExpression" && t.params.length === 1;
    this.tokenMap && t.start != null && t.end != null && (r && (r = !!this.tokenMap.find(t, (i) => this.tokenMap.matchesOriginal(i, ","))), r ||
    (r = this.shouldPrintTrailingComma(">"))), this.printList(t.params, r), this.tokenChar(62);
  }
  s(DL, "TSTypeParameterInstantiation");
  function kL(t) {
    t.in && (this.word("in"), this.space()), t.out && (this.word("out"), this.space()), this.word(t.name), t.constraint && (this.space(), this.
    word("extends"), this.space(), this.print(t.constraint)), t.default && (this.space(), this.tokenChar(61), this.space(), this.print(t.default));
  }
  s(kL, "TSTypeParameter");
  function LL(t) {
    t.accessibility && (this.word(t.accessibility), this.space()), t.readonly && (this.word("readonly"), this.space()), this._param(t.parameter);
  }
  s(LL, "TSParameterProperty");
  function ML(t, e) {
    t.declare && (this.word("declare"), this.space()), this._functionHead(t, e), this.semicolon();
  }
  s(ML, "TSDeclareFunction");
  function BL(t) {
    this._classMethodHead(t), this.semicolon();
  }
  s(BL, "TSDeclareMethod");
  function jL(t) {
    this.print(t.left), this.tokenChar(46), this.print(t.right);
  }
  s(jL, "TSQualifiedName");
  function FL(t) {
    this.tsPrintSignatureDeclarationBase(t), qr(this, t);
  }
  s(FL, "TSCallSignatureDeclaration");
  function qr(t, e) {
    if (!t.tokenMap || !e.start || !e.end) {
      t.semicolon();
      return;
    }
    t.tokenMap.endMatches(e, ",") ? t.token(",") : t.tokenMap.endMatches(e, ";") && t.semicolon();
  }
  s(qr, "maybePrintTrailingCommaOrSemicolon");
  function RL(t) {
    this.word("new"), this.space(), this.tsPrintSignatureDeclarationBase(t), qr(this, t);
  }
  s(RL, "TSConstructSignatureDeclaration");
  function qL(t) {
    let {
      readonly: e
    } = t;
    e && (this.word("readonly"), this.space()), this.tsPrintPropertyOrMethodName(t), this.print(t.typeAnnotation), qr(this, t);
  }
  s(qL, "TSPropertySignature");
  function UL(t) {
    t.computed && this.tokenChar(91), this.print(t.key), t.computed && this.tokenChar(93), t.optional && this.tokenChar(63);
  }
  s(UL, "tsPrintPropertyOrMethodName");
  function KL(t) {
    let {
      kind: e
    } = t;
    (e === "set" || e === "get") && (this.word(e), this.space()), this.tsPrintPropertyOrMethodName(t), this.tsPrintSignatureDeclarationBase(
    t), qr(this, t);
  }
  s(KL, "TSMethodSignature");
  function VL(t) {
    let {
      readonly: e,
      static: r
    } = t;
    r && (this.word("static"), this.space()), e && (this.word("readonly"), this.space()), this.tokenChar(91), this._parameters(t.parameters,
    "]"), this.print(t.typeAnnotation), qr(this, t);
  }
  s(VL, "TSIndexSignature");
  function YL() {
    this.word("any");
  }
  s(YL, "TSAnyKeyword");
  function JL() {
    this.word("bigint");
  }
  s(JL, "TSBigIntKeyword");
  function XL() {
    this.word("unknown");
  }
  s(XL, "TSUnknownKeyword");
  function WL() {
    this.word("number");
  }
  s(WL, "TSNumberKeyword");
  function zL() {
    this.word("object");
  }
  s(zL, "TSObjectKeyword");
  function $L() {
    this.word("boolean");
  }
  s($L, "TSBooleanKeyword");
  function HL() {
    this.word("string");
  }
  s(HL, "TSStringKeyword");
  function GL() {
    this.word("symbol");
  }
  s(GL, "TSSymbolKeyword");
  function QL() {
    this.word("void");
  }
  s(QL, "TSVoidKeyword");
  function ZL() {
    this.word("undefined");
  }
  s(ZL, "TSUndefinedKeyword");
  function eM() {
    this.word("null");
  }
  s(eM, "TSNullKeyword");
  function tM() {
    this.word("never");
  }
  s(tM, "TSNeverKeyword");
  function rM() {
    this.word("intrinsic");
  }
  s(rM, "TSIntrinsicKeyword");
  function iM() {
    this.word("this");
  }
  s(iM, "TSThisType");
  function sM(t) {
    this.tsPrintFunctionOrConstructorType(t);
  }
  s(sM, "TSFunctionType");
  function nM(t) {
    t.abstract && (this.word("abstract"), this.space()), this.word("new"), this.space(), this.tsPrintFunctionOrConstructorType(t);
  }
  s(nM, "TSConstructorType");
  function aM(t) {
    let {
      typeParameters: e
    } = t, r = t.parameters;
    this.print(e), this.tokenChar(40), this._parameters(r, ")"), this.space();
    let i = t.typeAnnotation;
    this.print(i);
  }
  s(aM, "tsPrintFunctionOrConstructorType");
  function oM(t) {
    let e = t.typeParameters;
    this.print(t.typeName, !!e), this.print(e);
  }
  s(oM, "TSTypeReference");
  function lM(t) {
    t.asserts && (this.word("asserts"), this.space()), this.print(t.parameterName), t.typeAnnotation && (this.space(), this.word("is"), this.
    space(), this.print(t.typeAnnotation.typeAnnotation));
  }
  s(lM, "TSTypePredicate");
  function uM(t) {
    this.word("typeof"), this.space(), this.print(t.exprName);
    let e = t.typeParameters;
    e && this.print(e);
  }
  s(uM, "TSTypeQuery");
  function cM(t) {
    Vi(this, t, () => this.printJoin(t.members, !0, !0));
  }
  s(cM, "TSTypeLiteral");
  function pM(t) {
    this.print(t.elementType, !0), this.tokenChar(91), this.tokenChar(93);
  }
  s(pM, "TSArrayType");
  function fM(t) {
    this.tokenChar(91), this.printList(t.elementTypes, this.shouldPrintTrailingComma("]")), this.tokenChar(93);
  }
  s(fM, "TSTupleType");
  function hM(t) {
    this.print(t.typeAnnotation), this.tokenChar(63);
  }
  s(hM, "TSOptionalType");
  function dM(t) {
    this.token("..."), this.print(t.typeAnnotation);
  }
  s(dM, "TSRestType");
  function mM(t) {
    this.print(t.label), t.optional && this.tokenChar(63), this.tokenChar(58), this.space(), this.print(t.elementType);
  }
  s(mM, "TSNamedTupleMember");
  function yM(t) {
    Oc(this, t, "|");
  }
  s(yM, "TSUnionType");
  function TM(t) {
    Oc(this, t, "&");
  }
  s(TM, "TSIntersectionType");
  function Oc(t, e, r) {
    var i;
    let n = 0;
    (i = t.tokenMap) != null && i.startMatches(e, r) && (n = 1, t.token(r)), t.printJoin(e.types, void 0, void 0, function(a) {
      this.space(), this.token(r, null, a + n), this.space();
    });
  }
  s(Oc, "tsPrintUnionOrIntersectionType");
  function SM(t) {
    this.print(t.checkType), this.space(), this.word("extends"), this.space(), this.print(t.extendsType), this.space(), this.tokenChar(63), this.
    space(), this.print(t.trueType), this.space(), this.tokenChar(58), this.space(), this.print(t.falseType);
  }
  s(SM, "TSConditionalType");
  function bM(t) {
    this.word("infer"), this.print(t.typeParameter);
  }
  s(bM, "TSInferType");
  function xM(t) {
    this.tokenChar(40), this.print(t.typeAnnotation), this.tokenChar(41);
  }
  s(xM, "TSParenthesizedType");
  function PM(t) {
    this.word(t.operator), this.space(), this.print(t.typeAnnotation);
  }
  s(PM, "TSTypeOperator");
  function EM(t) {
    this.print(t.objectType, !0), this.tokenChar(91), this.print(t.indexType), this.tokenChar(93);
  }
  s(EM, "TSIndexedAccessType");
  function gM(t) {
    let {
      nameType: e,
      optional: r,
      readonly: i,
      typeAnnotation: n
    } = t;
    this.tokenChar(123);
    let a = this.enterDelimited();
    this.space(), i && (wc(this, i), this.word("readonly"), this.space()), this.tokenChar(91), this.word(t.typeParameter.name), this.space(),
    this.word("in"), this.space(), this.print(t.typeParameter.constraint), e && (this.space(), this.word("as"), this.space(), this.print(e)),
    this.tokenChar(93), r && (wc(this, r), this.tokenChar(63)), n && (this.tokenChar(58), this.space(), this.print(n)), this.space(), a(), this.
    tokenChar(125);
  }
  s(gM, "TSMappedType");
  function wc(t, e) {
    e !== !0 && t.token(e);
  }
  s(wc, "tokenIfPlusMinus");
  function AM(t) {
    this._printTemplate(t, t.types);
  }
  s(AM, "TSTemplateLiteralType");
  function IM(t) {
    this.print(t.literal);
  }
  s(IM, "TSLiteralType");
  function vM(t) {
    this.print(t.expression), this.print(t.typeArguments);
  }
  s(vM, "TSClassImplements");
  function CM(t) {
    let {
      declare: e,
      id: r,
      typeParameters: i,
      extends: n,
      body: a
    } = t;
    e && (this.word("declare"), this.space()), this.word("interface"), this.space(), this.print(r), this.print(i), n != null && n.length && (this.
    space(), this.word("extends"), this.space(), this.printList(n)), this.space(), this.print(a);
  }
  s(CM, "TSInterfaceDeclaration");
  function wM(t) {
    Vi(this, t, () => this.printJoin(t.body, !0, !0));
  }
  s(wM, "TSInterfaceBody");
  function NM(t) {
    let {
      declare: e,
      id: r,
      typeParameters: i,
      typeAnnotation: n
    } = t;
    e && (this.word("declare"), this.space()), this.word("type"), this.space(), this.print(r), this.print(i), this.space(), this.tokenChar(61),
    this.space(), this.print(n), this.semicolon();
  }
  s(NM, "TSTypeAliasDeclaration");
  function OM(t) {
    let {
      type: e,
      expression: r,
      typeAnnotation: i
    } = t;
    this.print(r, !0), this.space(), this.word(e === "TSAsExpression" ? "as" : "satisfies"), this.space(), this.print(i);
  }
  s(OM, "TSTypeExpression");
  function _M(t) {
    let {
      typeAnnotation: e,
      expression: r
    } = t;
    this.tokenChar(60), this.print(e), this.tokenChar(62), this.space(), this.print(r);
  }
  s(_M, "TSTypeAssertion");
  function DM(t) {
    this.print(t.expression), this.print(t.typeParameters);
  }
  s(DM, "TSInstantiationExpression");
  function kM(t) {
    let {
      declare: e,
      const: r,
      id: i
    } = t;
    e && (this.word("declare"), this.space()), r && (this.word("const"), this.space()), this.word("enum"), this.space(), this.print(i), this.
    space(), _c.call(this, t);
  }
  s(kM, "TSEnumDeclaration");
  function _c(t) {
    Vi(this, t, () => {
      var e;
      return this.printList(t.members, (e = this.shouldPrintTrailingComma("}")) != null ? e : !0, !0, !0);
    });
  }
  s(_c, "TSEnumBody");
  function LM(t) {
    let {
      id: e,
      initializer: r
    } = t;
    this.print(e), r && (this.space(), this.tokenChar(61), this.space(), this.print(r));
  }
  s(LM, "TSEnumMember");
  function MM(t) {
    let {
      declare: e,
      id: r,
      kind: i
    } = t;
    e && (this.word("declare"), this.space());
    {
      if (t.global || (this.word(i ?? (r.type === "Identifier" ? "namespace" : "module")), this.space()), this.print(r), !t.body) {
        this.semicolon();
        return;
      }
      let n = t.body;
      for (; n.type === "TSModuleDeclaration"; )
        this.tokenChar(46), this.print(n.id), n = n.body;
      this.space(), this.print(n);
    }
  }
  s(MM, "TSModuleDeclaration");
  function BM(t) {
    Vi(this, t, () => this.printSequence(t.body, !0));
  }
  s(BM, "TSModuleBlock");
  function jM(t) {
    let {
      argument: e,
      qualifier: r,
      options: i
    } = t;
    this.word("import"), this.tokenChar(40), this.print(e), i && (this.tokenChar(44), this.print(i)), this.tokenChar(41), r && (this.tokenChar(
    46), this.print(r));
    let n = t.typeParameters;
    n && this.print(n);
  }
  s(jM, "TSImportType");
  function FM(t) {
    let {
      id: e,
      moduleReference: r
    } = t;
    t.isExport && (this.word("export"), this.space()), this.word("import"), this.space(), this.print(e), this.space(), this.tokenChar(61), this.
    space(), this.print(r), this.semicolon();
  }
  s(FM, "TSImportEqualsDeclaration");
  function RM(t) {
    this.token("require("), this.print(t.expression), this.tokenChar(41);
  }
  s(RM, "TSExternalModuleReference");
  function qM(t) {
    this.print(t.expression), this.tokenChar(33);
  }
  s(qM, "TSNonNullExpression");
  function UM(t) {
    this.word("export"), this.space(), this.tokenChar(61), this.space(), this.print(t.expression), this.semicolon();
  }
  s(UM, "TSExportAssignment");
  function KM(t) {
    this.word("export"), this.space(), this.word("as"), this.space(), this.word("namespace"), this.space(), this.print(t.id), this.semicolon();
  }
  s(KM, "TSNamespaceExportDeclaration");
  function VM(t) {
    let {
      typeParameters: e
    } = t, r = t.parameters;
    this.print(e), this.tokenChar(40), this._parameters(r, ")");
    let i = t.typeAnnotation;
    this.print(i);
  }
  s(VM, "tsPrintSignatureDeclarationBase");
  function YM(t) {
    let e = t.type === "ClassPrivateProperty", r = t.type === "ClassAccessorProperty" || t.type === "ClassProperty";
    Nc(this, t, [r && t.declare && "declare", !e && t.accessibility]), t.static && (this.word("static"), this.space()), Nc(this, t, [!e && t.
    abstract && "abstract", !e && t.override && "override", (r || e) && t.readonly && "readonly"]);
  }
  s(YM, "tsPrintClassMemberModifiers");
  function Vi(t, e, r) {
    t.token("{");
    let i = t.enterDelimited();
    r(), i(), t.rightBrace(e);
  }
  s(Vi, "printBraced");
  function Nc(t, e, r) {
    var i;
    let n = /* @__PURE__ */ new Set();
    for (let a of r)
      a && n.add(a);
    (i = t.tokenMap) == null || i.find(e, (a) => {
      if (n.has(a.value))
        return t.token(a.value), t.space(), n.delete(a.value), n.size === 0;
    });
    for (let a of n)
      t.word(a), t.space();
  }
  s(Nc, "printModifiersList");
});

// ../node_modules/@babel/generator/lib/generators/index.js
var kc = O((Ee) => {
  "use strict";
  Object.defineProperty(Ee, "__esModule", {
    value: !0
  });
  var ka = nc();
  Object.keys(ka).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Ee && Ee[t] === ka[t] || Object.defineProperty(Ee, t, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return ka[t];
      }, "get")
    });
  });
  var La = oc();
  Object.keys(La).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Ee && Ee[t] === La[t] || Object.defineProperty(Ee, t, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return La[t];
      }, "get")
    });
  });
  var Ma = pc();
  Object.keys(Ma).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Ee && Ee[t] === Ma[t] || Object.defineProperty(Ee, t, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return Ma[t];
      }, "get")
    });
  });
  var Ba = fc();
  Object.keys(Ba).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Ee && Ee[t] === Ba[t] || Object.defineProperty(Ee, t, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return Ba[t];
      }, "get")
    });
  });
  var ja = hc();
  Object.keys(ja).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Ee && Ee[t] === ja[t] || Object.defineProperty(Ee, t, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return ja[t];
      }, "get")
    });
  });
  var Fa = wa();
  Object.keys(Fa).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Ee && Ee[t] === Fa[t] || Object.defineProperty(Ee, t, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return Fa[t];
      }, "get")
    });
  });
  var Ra = _a();
  Object.keys(Ra).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Ee && Ee[t] === Ra[t] || Object.defineProperty(Ee, t, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return Ra[t];
      }, "get")
    });
  });
  var qa = Ic();
  Object.keys(qa).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Ee && Ee[t] === qa[t] || Object.defineProperty(Ee, t, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return qa[t];
      }, "get")
    });
  });
  var Ua = vc();
  Object.keys(Ua).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Ee && Ee[t] === Ua[t] || Object.defineProperty(Ee, t, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return Ua[t];
      }, "get")
    });
  });
  var Ka = Cc();
  Object.keys(Ka).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Ee && Ee[t] === Ka[t] || Object.defineProperty(Ee, t, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return Ka[t];
      }, "get")
    });
  });
  var Va = Dc();
  Object.keys(Va).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Ee && Ee[t] === Va[t] || Object.defineProperty(Ee, t, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return Va[t];
      }, "get")
    });
  });
});

// ../node_modules/@babel/generator/lib/generators/deprecated.js
var Lc = O((Ya) => {
  "use strict";
  Object.defineProperty(Ya, "__esModule", {
    value: !0
  });
  Ya.addDeprecatedGenerators = JM;
  function JM(t) {
    {
      let e = {
        Noop() {
        },
        TSExpressionWithTypeArguments(r) {
          this.print(r.expression), this.print(r.typeParameters);
        },
        DecimalLiteral(r) {
          let i = this.getPossibleRaw(r);
          if (!this.format.minified && i !== void 0) {
            this.word(i);
            return;
          }
          this.word(r.value + "m");
        }
      };
      Object.assign(t.prototype, e);
    }
  }
  s(JM, "addDeprecatedGenerators");
});

// ../node_modules/@babel/generator/lib/printer.js
var Fc = O((Yi) => {
  "use strict";
  Object.defineProperty(Yi, "__esModule", {
    value: !0
  });
  Yi.default = void 0;
  var XM = qo(), Bc = Ft(), WM = Ye(), zM = sc(), $M = kc(), HM = Lc(), {
    isExpression: GM,
    isFunction: QM,
    isStatement: ZM,
    isClassBody: e3,
    isTSInterfaceBody: t3,
    isTSEnumMember: r3
  } = WM, i3 = /e/i, s3 = /\.0+$/, jc = /[\n\r\u2028\u2029]/, n3 = /[\n\r\u2028\u2029]|\*\//;
  function Mc(t) {
    return t.type === "CommentLine" || jc.test(t.value);
  }
  s(Mc, "commentIsNewline");
  var {
    needsParens: a3
  } = Bc, Ur = class {
    static {
      s(this, "Printer");
    }
    constructor(e, r, i, n) {
      this.inForStatementInit = !1, this.tokenContext = 0, this._tokens = null, this._originalCode = null, this._currentNode = null, this._indent =
      0, this._indentRepeat = 0, this._insideAux = !1, this._noLineTerminator = !1, this._noLineTerminatorAfterNode = null, this._printAuxAfterOnNextUserNode =
      !1, this._printedComments = /* @__PURE__ */ new Set(), this._endsWithInteger = !1, this._endsWithWord = !1, this._endsWithDiv = !1, this.
      _lastCommentLine = 0, this._endsWithInnerRaw = !1, this._indentInnerComments = !0, this.tokenMap = null, this._boundGetRawIdentifier =
      this._getRawIdentifier.bind(this), this._printSemicolonBeforeNextNode = -1, this._printSemicolonBeforeNextToken = -1, this.format = e,
      this._tokens = i, this._originalCode = n, this._indentRepeat = e.indent.style.length, this._inputMap = r?._inputMap, this._buf = new XM.
      default(r, e.indent.style[0]);
    }
    enterForStatementInit() {
      return this.inForStatementInit ? () => {
      } : (this.inForStatementInit = !0, () => {
        this.inForStatementInit = !1;
      });
    }
    enterDelimited() {
      let e = this.inForStatementInit, r = this._noLineTerminatorAfterNode;
      return e === !1 && r === null ? () => {
      } : (this.inForStatementInit = !1, this._noLineTerminatorAfterNode = null, () => {
        this.inForStatementInit = e, this._noLineTerminatorAfterNode = r;
      });
    }
    generate(e) {
      return this.format.preserveFormat && (this.tokenMap = new zM.TokenMap(e, this._tokens, this._originalCode)), this.print(e), this._maybeAddAuxComment(),
      this._buf.get();
    }
    indent() {
      let {
        format: e
      } = this;
      e.preserveFormat || e.compact || e.concise || this._indent++;
    }
    dedent() {
      let {
        format: e
      } = this;
      e.preserveFormat || e.compact || e.concise || this._indent--;
    }
    semicolon(e = !1) {
      if (this._maybeAddAuxComment(), e) {
        this._appendChar(59), this._noLineTerminator = !1;
        return;
      }
      if (this.tokenMap) {
        let r = this._currentNode;
        if (r.start != null && r.end != null) {
          if (!this.tokenMap.endMatches(r, ";")) {
            this._printSemicolonBeforeNextNode = this._buf.getCurrentLine();
            return;
          }
          let i = this.tokenMap.getIndexes(this._currentNode);
          this._catchUpTo(this._tokens[i[i.length - 1]].loc.start);
        }
      }
      this._queue(59), this._noLineTerminator = !1;
    }
    rightBrace(e) {
      this.format.minified && this._buf.removeLastSemicolon(), this.sourceWithOffset("end", e.loc, -1), this.tokenChar(125);
    }
    rightParens(e) {
      this.sourceWithOffset("end", e.loc, -1), this.tokenChar(41);
    }
    space(e = !1) {
      let {
        format: r
      } = this;
      if (!(r.compact || r.preserveFormat)) {
        if (e)
          this._space();
        else if (this._buf.hasContent()) {
          let i = this.getLastChar();
          i !== 32 && i !== 10 && this._space();
        }
      }
    }
    word(e, r = !1) {
      this.tokenContext = 0, this._maybePrintInnerComments(e), this._maybeAddAuxComment(), this.tokenMap && this._catchUpToCurrentToken(e), (this.
      _endsWithWord || this._endsWithDiv && e.charCodeAt(0) === 47) && this._space(), this._append(e, !1), this._endsWithWord = !0, this._noLineTerminator =
      r;
    }
    number(e, r) {
      function i(n) {
        if (n.length > 2 && n.charCodeAt(0) === 48) {
          let a = n.charCodeAt(1);
          return a === 98 || a === 111 || a === 120;
        }
        return !1;
      }
      s(i, "isNonDecimalLiteral"), this.word(e), this._endsWithInteger = Number.isInteger(r) && !i(e) && !i3.test(e) && !s3.test(e) && e.charCodeAt(
      e.length - 1) !== 46;
    }
    token(e, r = !1, i = 0) {
      this.tokenContext = 0, this._maybePrintInnerComments(e, i), this._maybeAddAuxComment(), this.tokenMap && this._catchUpToCurrentToken(e,
      i);
      let n = this.getLastChar(), a = e.charCodeAt(0);
      (n === 33 && (e === "--" || a === 61) || a === 43 && n === 43 || a === 45 && n === 45 || a === 46 && this._endsWithInteger) && this._space(),
      this._append(e, r), this._noLineTerminator = !1;
    }
    tokenChar(e) {
      this.tokenContext = 0;
      let r = String.fromCharCode(e);
      this._maybePrintInnerComments(r), this._maybeAddAuxComment(), this.tokenMap && this._catchUpToCurrentToken(r);
      let i = this.getLastChar();
      (e === 43 && i === 43 || e === 45 && i === 45 || e === 46 && this._endsWithInteger) && this._space(), this._appendChar(e), this._noLineTerminator =
      !1;
    }
    newline(e = 1, r) {
      if (!(e <= 0)) {
        if (!r) {
          if (this.format.retainLines || this.format.compact) return;
          if (this.format.concise) {
            this.space();
            return;
          }
        }
        e > 2 && (e = 2), e -= this._buf.getNewlineCount();
        for (let i = 0; i < e; i++)
          this._newline();
      }
    }
    endsWith(e) {
      return this.getLastChar() === e;
    }
    getLastChar() {
      return this._buf.getLastChar();
    }
    endsWithCharAndNewline() {
      return this._buf.endsWithCharAndNewline();
    }
    removeTrailingNewline() {
      this._buf.removeTrailingNewline();
    }
    exactSource(e, r) {
      if (!e) {
        r();
        return;
      }
      this._catchUp("start", e), this._buf.exactSource(e, r);
    }
    source(e, r) {
      r && (this._catchUp(e, r), this._buf.source(e, r));
    }
    sourceWithOffset(e, r, i) {
      !r || this.format.preserveFormat || (this._catchUp(e, r), this._buf.sourceWithOffset(e, r, i));
    }
    sourceIdentifierName(e, r) {
      if (!this._buf._canMarkIdName) return;
      let i = this._buf._sourcePosition;
      i.identifierNamePos = r, i.identifierName = e;
    }
    _space() {
      this._queue(32);
    }
    _newline() {
      this._queue(10);
    }
    _catchUpToCurrentToken(e, r = 0) {
      let i = this.tokenMap.findMatching(this._currentNode, e, r);
      i && this._catchUpTo(i.loc.start), this._printSemicolonBeforeNextToken !== -1 && this._printSemicolonBeforeNextToken === this._buf.getCurrentLine() &&
      (this._buf.appendChar(59), this._endsWithWord = !1, this._endsWithInteger = !1, this._endsWithDiv = !1), this._printSemicolonBeforeNextToken =
      -1, this._printSemicolonBeforeNextNode = -1;
    }
    _append(e, r) {
      this._maybeIndent(e.charCodeAt(0)), this._buf.append(e, r), this._endsWithWord = !1, this._endsWithInteger = !1, this._endsWithDiv = !1;
    }
    _appendChar(e) {
      this._maybeIndent(e), this._buf.appendChar(e), this._endsWithWord = !1, this._endsWithInteger = !1, this._endsWithDiv = !1;
    }
    _queue(e) {
      this._maybeIndent(e), this._buf.queue(e), this._endsWithWord = !1, this._endsWithInteger = !1;
    }
    _maybeIndent(e) {
      this._indent && e !== 10 && this.endsWith(10) && this._buf.queueIndentation(this._getIndent());
    }
    _shouldIndent(e) {
      if (this._indent && e !== 10 && this.endsWith(10))
        return !0;
    }
    catchUp(e) {
      if (!this.format.retainLines) return;
      let r = e - this._buf.getCurrentLine();
      for (let i = 0; i < r; i++)
        this._newline();
    }
    _catchUp(e, r) {
      let {
        format: i
      } = this;
      if (!i.preserveFormat) {
        i.retainLines && r != null && r[e] && this.catchUp(r[e].line);
        return;
      }
      let n = r?.[e];
      n != null && this._catchUpTo(n);
    }
    _catchUpTo({
      line: e,
      column: r,
      index: i
    }) {
      let n = e - this._buf.getCurrentLine();
      if (n > 0 && this._noLineTerminator)
        return;
      for (let o = 0; o < n; o++)
        this._newline();
      let a = n > 0 ? r : r - this._buf.getCurrentColumn();
      if (a > 0) {
        let o = this._originalCode ? this._originalCode.slice(i - a, i).replace(/[^\t\x0B\f \xA0\u1680\u2000-\u200A\u202F\u205F\u3000\uFEFF]/gu,
        " ") : " ".repeat(a);
        this._append(o, !1);
      }
    }
    _getIndent() {
      return this._indentRepeat * this._indent;
    }
    printTerminatorless(e) {
      this._noLineTerminator = !0, this.print(e);
    }
    print(e, r, i) {
      var n, a, o;
      if (!e) return;
      this._endsWithInnerRaw = !1;
      let l = e.type, u = this.format, p = u.concise;
      e._compact && (u.concise = !0);
      let m = this[l];
      if (m === void 0)
        throw new ReferenceError(`unknown node of type ${JSON.stringify(l)} with constructor ${JSON.stringify(e.constructor.name)}`);
      let g = this._currentNode;
      this._currentNode = e, this.tokenMap && (this._printSemicolonBeforeNextToken = this._printSemicolonBeforeNextNode);
      let I = this._insideAux;
      this._insideAux = e.loc == null, this._maybeAddAuxComment(this._insideAux && !I);
      let v = (n = e.extra) == null ? void 0 : n.parenthesized, _ = v && u.preserveFormat || v && u.retainFunctionParens && l === "FunctionE\
xpression" || a3(e, g, this.tokenContext, this.inForStatementInit, u.preserveFormat ? this._boundGetRawIdentifier : void 0);
      if (!_ && v && (a = e.leadingComments) != null && a.length && e.leadingComments[0].type === "CommentBlock")
        switch (g?.type) {
          case "ExpressionStatement":
          case "VariableDeclarator":
          case "AssignmentExpression":
          case "ReturnStatement":
            break;
          case "CallExpression":
          case "OptionalCallExpression":
          case "NewExpression":
            if (g.callee !== e) break;
          default:
            _ = !0;
        }
      let V = !1;
      !_ && this._noLineTerminator && ((o = e.leadingComments) != null && o.some(Mc) || this.format.retainLines && e.loc && e.loc.start.line >
      this._buf.getCurrentLine()) && (_ = !0, V = !0);
      let D, L;
      if (!_ && (r || (r = g && this._noLineTerminatorAfterNode === g && Bc.isLastChild(g, e)), r)) {
        var B;
        (B = e.trailingComments) != null && B.some(Mc) ? GM(e) && (_ = !0) : (D = this._noLineTerminatorAfterNode, this._noLineTerminatorAfterNode =
        e);
      }
      _ && (this.tokenChar(40), V && this.indent(), this._endsWithInnerRaw = !1, this.inForStatementInit && (L = !0, this.inForStatementInit =
      !1), D = this._noLineTerminatorAfterNode, this._noLineTerminatorAfterNode = null), this._lastCommentLine = 0, this._printLeadingComments(
      e, g);
      let fe = l === "Program" || l === "File" ? null : e.loc;
      this.exactSource(fe, m.bind(this, e, g)), _ ? (this._printTrailingComments(e, g), V && (this.dedent(), this.newline()), this.tokenChar(
      41), this._noLineTerminator = r, L && (this.inForStatementInit = !0)) : r && !this._noLineTerminator ? (this._noLineTerminator = !0, this.
      _printTrailingComments(e, g)) : this._printTrailingComments(e, g, i), this._currentNode = g, u.concise = p, this._insideAux = I, D !==
      void 0 && (this._noLineTerminatorAfterNode = D), this._endsWithInnerRaw = !1;
    }
    _maybeAddAuxComment(e) {
      e && this._printAuxBeforeComment(), this._insideAux || this._printAuxAfterComment();
    }
    _printAuxBeforeComment() {
      if (this._printAuxAfterOnNextUserNode) return;
      this._printAuxAfterOnNextUserNode = !0;
      let e = this.format.auxiliaryCommentBefore;
      e && this._printComment({
        type: "CommentBlock",
        value: e
      }, 0);
    }
    _printAuxAfterComment() {
      if (!this._printAuxAfterOnNextUserNode) return;
      this._printAuxAfterOnNextUserNode = !1;
      let e = this.format.auxiliaryCommentAfter;
      e && this._printComment({
        type: "CommentBlock",
        value: e
      }, 0);
    }
    getPossibleRaw(e) {
      let r = e.extra;
      if (r?.raw != null && r.rawValue != null && e.value === r.rawValue)
        return r.raw;
    }
    printJoin(e, r, i, n, a, o, l, u) {
      if (!(e != null && e.length)) return;
      if (i == null && this.format.retainLines) {
        var p;
        let V = (p = e[0].loc) == null ? void 0 : p.start.line;
        V != null && V !== this._buf.getCurrentLine() && (i = !0);
      }
      i && this.indent();
      let m = {
        addNewlines: o,
        nextNodeStartLine: 0
      }, g = n?.bind(this), I = e.length;
      for (let V = 0; V < I; V++) {
        let D = e[V];
        if (D && (r && this._printNewline(V === 0, m), this.print(D, void 0, u || 0), l?.(D, V), g != null && (V < I - 1 ? g(V, !1) : a && g(
        V, !0)), r)) {
          var v;
          if ((v = D.trailingComments) != null && v.length || (this._lastCommentLine = 0), V + 1 === I)
            this.newline(1);
          else {
            var _;
            let L = e[V + 1];
            m.nextNodeStartLine = ((_ = L.loc) == null ? void 0 : _.start.line) || 0, this._printNewline(!0, m);
          }
        }
      }
      i && this.dedent();
    }
    printAndIndentOnComments(e) {
      let r = e.leadingComments && e.leadingComments.length > 0;
      r && this.indent(), this.print(e), r && this.dedent();
    }
    printBlock(e) {
      let r = e.body;
      r.type !== "EmptyStatement" && this.space(), this.print(r);
    }
    _printTrailingComments(e, r, i) {
      let {
        innerComments: n,
        trailingComments: a
      } = e;
      n != null && n.length && this._printComments(2, n, e, r, i), a != null && a.length && this._printComments(2, a, e, r, i);
    }
    _printLeadingComments(e, r) {
      let i = e.leadingComments;
      i != null && i.length && this._printComments(0, i, e, r);
    }
    _maybePrintInnerComments(e, r) {
      if (this._endsWithInnerRaw) {
        var i;
        this.printInnerComments((i = this.tokenMap) == null ? void 0 : i.findMatching(this._currentNode, e, r));
      }
      this._endsWithInnerRaw = !0, this._indentInnerComments = !0;
    }
    printInnerComments(e) {
      let r = this._currentNode, i = r.innerComments;
      if (!(i != null && i.length)) return;
      let n = this.endsWith(32), a = this._indentInnerComments, o = this._printedComments.size;
      a && this.indent(), this._printComments(1, i, r, void 0, void 0, e), n && o !== this._printedComments.size && this.space(), a && this.
      dedent();
    }
    noIndentInnerCommentsHere() {
      this._indentInnerComments = !1;
    }
    printSequence(e, r, i, n) {
      this.printJoin(e, !0, r ?? !1, void 0, void 0, n, void 0, i);
    }
    printList(e, r, i, n, a, o) {
      this.printJoin(e, i, n, a ?? o3, r, void 0, o);
    }
    shouldPrintTrailingComma(e) {
      if (!this.tokenMap) return null;
      let r = this.tokenMap.findLastIndex(this._currentNode, (i) => this.tokenMap.matchesOriginal(i, e));
      return r <= 0 ? null : this.tokenMap.matchesOriginal(this._tokens[r - 1], ",");
    }
    _printNewline(e, r) {
      let i = this.format;
      if (i.retainLines || i.compact) return;
      if (i.concise) {
        this.space();
        return;
      }
      if (!e)
        return;
      let n = r.nextNodeStartLine, a = this._lastCommentLine;
      if (n > 0 && a > 0) {
        let o = n - a;
        if (o >= 0) {
          this.newline(o || 1);
          return;
        }
      }
      this._buf.hasContent() && this.newline(1);
    }
    _shouldPrintComment(e, r) {
      if (e.ignore || this._printedComments.has(e)) return 0;
      if (this._noLineTerminator && n3.test(e.value))
        return 2;
      if (r && this.tokenMap) {
        let i = this.tokenMap.find(this._currentNode, (n) => n.value === e.value);
        if (i && i.start > r.start)
          return 2;
      }
      return this._printedComments.add(e), this.format.shouldPrintComment(e.value) ? 1 : 0;
    }
    _printComment(e, r) {
      let i = this._noLineTerminator, n = e.type === "CommentBlock", a = n && r !== 1 && !this._noLineTerminator;
      a && this._buf.hasContent() && r !== 2 && this.newline(1);
      let o = this.getLastChar();
      o !== 91 && o !== 123 && o !== 40 && this.space();
      let l;
      if (n) {
        if (l = `/*${e.value}*/`, this.format.indent.adjustMultilineComment) {
          var u;
          let p = (u = e.loc) == null ? void 0 : u.start.column;
          if (p) {
            let m = new RegExp("\\n\\s{1," + p + "}", "g");
            l = l.replace(m, `
`);
          }
          if (this.format.concise)
            l = l.replace(/\n(?!$)/g, `
`);
          else {
            let m = this.format.retainLines ? 0 : this._buf.getCurrentColumn();
            (this._shouldIndent(47) || this.format.retainLines) && (m += this._getIndent()), l = l.replace(/\n(?!$)/g, `
${" ".repeat(m)}`);
          }
        }
      } else i ? l = `/*${e.value}*/` : l = `//${e.value}`;
      if (this._endsWithDiv && this._space(), this.tokenMap) {
        let {
          _printSemicolonBeforeNextToken: p,
          _printSemicolonBeforeNextNode: m
        } = this;
        this._printSemicolonBeforeNextToken = -1, this._printSemicolonBeforeNextNode = -1, this.source("start", e.loc), this._append(l, n), this.
        _printSemicolonBeforeNextNode = m, this._printSemicolonBeforeNextToken = p;
      } else
        this.source("start", e.loc), this._append(l, n);
      !n && !i && this.newline(1, !0), a && r !== 3 && this.newline(1);
    }
    _printComments(e, r, i, n, a = 0, o) {
      let l = i.loc, u = r.length, p = !!l, m = p ? l.start.line : 0, g = p ? l.end.line : 0, I = 0, v = 0, _ = this._noLineTerminator ? function() {
      } : this.newline.bind(this);
      for (let V = 0; V < u; V++) {
        let D = r[V], L = this._shouldPrintComment(D, o);
        if (L === 2) {
          p = !1;
          break;
        }
        if (p && D.loc && L === 1) {
          let B = D.loc.start.line, fe = D.loc.end.line;
          if (e === 0) {
            let ee = 0;
            V === 0 ? this._buf.hasContent() && (D.type === "CommentLine" || B !== fe) && (ee = v = 1) : ee = B - I, I = fe, _(ee), this._printComment(
            D, 1), V + 1 === u && (_(Math.max(m - I, v)), I = m);
          } else if (e === 1) {
            let ee = B - (V === 0 ? m : I);
            I = fe, _(ee), this._printComment(D, 1), V + 1 === u && (_(Math.min(1, g - I)), I = g);
          } else {
            let ee = B - (V === 0 ? g - a : I);
            I = fe, _(ee), this._printComment(D, 1);
          }
        } else {
          if (p = !1, L !== 1)
            continue;
          if (u === 1) {
            let B = D.loc ? D.loc.start.line === D.loc.end.line : !jc.test(D.value), fe = B && !ZM(i) && !e3(n) && !t3(n) && !r3(i);
            e === 0 ? this._printComment(D, fe && i.type !== "ObjectExpression" || B && QM(n, {
              body: i
            }) ? 1 : 0) : fe && e === 2 ? this._printComment(D, 1) : this._printComment(D, 0);
          } else e === 1 && !(i.type === "ObjectExpression" && i.properties.length > 1) && i.type !== "ClassBody" && i.type !== "TSInterface\
Body" ? this._printComment(D, V === 0 ? 2 : V === u - 1 ? 3 : 0) : this._printComment(D, 0);
        }
      }
      e === 2 && p && I && (this._lastCommentLine = I);
    }
  };
  Object.assign(Ur.prototype, $M);
  (0, HM.addDeprecatedGenerators)(Ur);
  var $R = Yi.default = Ur;
  function o3(t, e) {
    this.token(",", !1, t), e || this.space();
  }
  s(o3, "commaSeparator");
});

// ../node_modules/@babel/generator/lib/index.js
var Vc = O((fr) => {
  "use strict";
  Object.defineProperty(fr, "__esModule", {
    value: !0
  });
  fr.default = void 0;
  fr.generate = Kc;
  var Rc = Ro(), qc = Fc();
  function Uc(t, e, r) {
    if (e.experimental_preserveFormat) {
      if (typeof t != "string")
        throw new Error("`experimental_preserveFormat` requires the original `code` to be passed to @babel/generator as a string");
      if (!e.retainLines)
        throw new Error("`experimental_preserveFormat` requires `retainLines` to be set to `true`");
      if (e.compact && e.compact !== "auto")
        throw new Error("`experimental_preserveFormat` is not compatible with the `compact` option");
      if (e.minified)
        throw new Error("`experimental_preserveFormat` is not compatible with the `minified` option");
      if (e.jsescOption)
        throw new Error("`experimental_preserveFormat` is not compatible with the `jsescOption` option");
      if (!Array.isArray(r.tokens))
        throw new Error("`experimental_preserveFormat` requires the AST to have attatched the token of the input code. Make sure to enable t\
he `tokens: true` parser option.");
    }
    let i = {
      auxiliaryCommentBefore: e.auxiliaryCommentBefore,
      auxiliaryCommentAfter: e.auxiliaryCommentAfter,
      shouldPrintComment: e.shouldPrintComment,
      preserveFormat: e.experimental_preserveFormat,
      retainLines: e.retainLines,
      retainFunctionParens: e.retainFunctionParens,
      comments: e.comments == null || e.comments,
      compact: e.compact,
      minified: e.minified,
      concise: e.concise,
      indent: {
        adjustMultilineComment: !0,
        style: "  "
      },
      jsescOption: Object.assign({
        quotes: "double",
        wrap: !0,
        minimal: !1
      }, e.jsescOption),
      topicToken: e.topicToken,
      importAttributesKeyword: e.importAttributesKeyword
    };
    {
      var n;
      i.decoratorsBeforeExport = e.decoratorsBeforeExport, i.jsescOption.json = e.jsonCompatibleStrings, i.recordAndTupleSyntaxType = (n = e.
      recordAndTupleSyntaxType) != null ? n : "hash";
    }
    i.minified ? (i.compact = !0, i.shouldPrintComment = i.shouldPrintComment || (() => i.comments)) : i.shouldPrintComment = i.shouldPrintComment ||
    ((u) => i.comments || u.includes("@license") || u.includes("@preserve")), i.compact === "auto" && (i.compact = typeof t == "string" && t.
    length > 5e5, i.compact && console.error(`[BABEL] Note: The code generator has deoptimised the styling of ${e.filename} as it exceeds th\
e max of 500KB.`)), (i.compact || i.preserveFormat) && (i.indent.adjustMultilineComment = !1);
    let {
      auxiliaryCommentBefore: a,
      auxiliaryCommentAfter: o,
      shouldPrintComment: l
    } = i;
    return a && !l(a) && (i.auxiliaryCommentBefore = void 0), o && !l(o) && (i.auxiliaryCommentAfter = void 0), i;
  }
  s(Uc, "normalizeOptions");
  fr.CodeGenerator = class {
    static {
      s(this, "CodeGenerator");
    }
    constructor(e, r = {}, i) {
      this._ast = void 0, this._format = void 0, this._map = void 0, this._ast = e, this._format = Uc(i, r, e), this._map = r.sourceMaps ? new Rc.
      default(r, i) : null;
    }
    generate() {
      return new qc.default(this._format, this._map).generate(this._ast);
    }
  };
  function Kc(t, e = {}, r) {
    let i = Uc(r, e, t), n = e.sourceMaps ? new Rc.default(e, r) : null;
    return new qc.default(i, n, t.tokens, typeof r == "string" ? r : null).generate(t);
  }
  s(Kc, "generate");
  var ZR = fr.default = Kc;
});

// ../node_modules/@babel/parser/lib/index.js
var xp = O((Gr) => {
  "use strict";
  Object.defineProperty(Gr, "__esModule", {
    value: !0
  });
  function l3(t, e) {
    if (t == null) return {};
    var r = {};
    for (var i in t) if ({}.hasOwnProperty.call(t, i)) {
      if (e.indexOf(i) !== -1) continue;
      r[i] = t[i];
    }
    return r;
  }
  s(l3, "_objectWithoutPropertiesLoose");
  var Et = class {
    static {
      s(this, "Position");
    }
    constructor(e, r, i) {
      this.line = void 0, this.column = void 0, this.index = void 0, this.line = e, this.column = r, this.index = i;
    }
  }, Tr = class {
    static {
      s(this, "SourceLocation");
    }
    constructor(e, r) {
      this.start = void 0, this.end = void 0, this.filename = void 0, this.identifierName = void 0, this.start = e, this.end = r;
    }
  };
  function Ze(t, e) {
    let {
      line: r,
      column: i,
      index: n
    } = t;
    return new Et(r, i + e, n + e);
  }
  s(Ze, "createPositionWithColumnOffset");
  var Yc = "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED", u3 = {
    ImportMetaOutsideModule: {
      message: `import.meta may appear only with 'sourceType: "module"'`,
      code: Yc
    },
    ImportOutsideModule: {
      message: `'import' and 'export' may appear only with 'sourceType: "module"'`,
      code: Yc
    }
  }, Jc = {
    ArrayPattern: "array destructuring pattern",
    AssignmentExpression: "assignment expression",
    AssignmentPattern: "assignment expression",
    ArrowFunctionExpression: "arrow function expression",
    ConditionalExpression: "conditional expression",
    CatchClause: "catch clause",
    ForOfStatement: "for-of statement",
    ForInStatement: "for-in statement",
    ForStatement: "for-loop",
    FormalParameters: "function parameter list",
    Identifier: "identifier",
    ImportSpecifier: "import specifier",
    ImportDefaultSpecifier: "import default specifier",
    ImportNamespaceSpecifier: "import namespace specifier",
    ObjectPattern: "object destructuring pattern",
    ParenthesizedExpression: "parenthesized expression",
    RestElement: "rest element",
    UpdateExpression: {
      true: "prefix operation",
      false: "postfix operation"
    },
    VariableDeclarator: "variable declaration",
    YieldExpression: "yield expression"
  }, Wi = /* @__PURE__ */ s((t) => t.type === "UpdateExpression" ? Jc.UpdateExpression[`${t.prefix}`] : Jc[t.type], "toNodeDescription"), c3 = {
    AccessorIsGenerator: /* @__PURE__ */ s(({
      kind: t
    }) => `A ${t}ter cannot be a generator.`, "AccessorIsGenerator"),
    ArgumentsInClass: "'arguments' is only allowed in functions and class methods.",
    AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.",
    AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.",
    AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.",
    AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.",
    AwaitUsingNotInAsyncContext: "'await using' is only allowed within async functions and at the top levels of modules.",
    AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.",
    BadGetterArity: "A 'get' accessor must not have any formal parameters.",
    BadSetterArity: "A 'set' accessor must have exactly one formal parameter.",
    BadSetterRestParameter: "A 'set' accessor function argument must not be a rest parameter.",
    ConstructorClassField: "Classes may not have a field named 'constructor'.",
    ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.",
    ConstructorIsAccessor: "Class constructor may not be an accessor.",
    ConstructorIsAsync: "Constructor can't be an async function.",
    ConstructorIsGenerator: "Constructor can't be a generator.",
    DeclarationMissingInitializer: /* @__PURE__ */ s(({
      kind: t
    }) => `Missing initializer in ${t} declaration.`, "DeclarationMissingInitializer"),
    DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(deco\
rator)(args)'.",
    DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use\
 the 'export @decorator class {}' syntax.",
    DecoratorsBeforeAfterExport: "Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the s\
ame time.",
    DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
    DecoratorExportClass: "Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use \
the '@decorator export class {}' syntax.",
    DecoratorSemicolon: "Decorators must not be followed by a semicolon.",
    DecoratorStaticBlock: "Decorators can't be used with a static block.",
    DeferImportRequiresNamespace: 'Only `import defer * as x from "./module"` is valid.',
    DeletePrivateField: "Deleting a private field is not allowed.",
    DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",
    DuplicateConstructor: "Duplicate constructor in the same class.",
    DuplicateDefaultExport: "Only one default export allowed per module.",
    DuplicateExport: /* @__PURE__ */ s(({
      exportName: t
    }) => `\`${t}\` has already been exported. Exported identifiers must be unique.`, "DuplicateExport"),
    DuplicateProto: "Redefinition of __proto__ property.",
    DuplicateRegExpFlags: "Duplicate regular expression flag.",
    DynamicImportPhaseRequiresImportExpressions: /* @__PURE__ */ s(({
      phase: t
    }) => `'import.${t}(...)' can only be parsed when using the 'createImportExpressions' option.`, "DynamicImportPhaseRequiresImportExpress\
ions"),
    ElementAfterRest: "Rest element must be last element.",
    EscapedCharNotAnIdentifier: "Invalid Unicode escape.",
    ExportBindingIsString: /* @__PURE__ */ s(({
      localName: t,
      exportName: e
    }) => `A string literal cannot be used as an exported binding without \`from\`.
- Did you mean \`export { '${t}' as '${e}' } from 'some-module'\`?`, "ExportBindingIsString"),
    ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.",
    ForInOfLoopInitializer: /* @__PURE__ */ s(({
      type: t
    }) => `'${t === "ForInStatement" ? "for-in" : "for-of"}' loop variable declaration may not have an initializer.`, "ForInOfLoopInitialize\
r"),
    ForInUsing: "For-in loop may not start with 'using' declaration.",
    ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.",
    ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.",
    GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.",
    IllegalBreakContinue: /* @__PURE__ */ s(({
      type: t
    }) => `Unsyntactic ${t === "BreakStatement" ? "break" : "continue"}.`, "IllegalBreakContinue"),
    IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.",
    IllegalReturn: "'return' outside of function.",
    ImportAttributesUseAssert: "The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You \
can enable the `deprecatedImportAssert` parser plugin to suppress this error.",
    ImportBindingIsString: /* @__PURE__ */ s(({
      importName: t
    }) => `A string literal cannot be used as an imported binding.
- Did you mean \`import { "${t}" as foo }\`?`, "ImportBindingIsString"),
    ImportCallArity: "`import()` requires exactly one or two arguments.",
    ImportCallNotNewExpression: "Cannot use new with import(...).",
    ImportCallSpreadArgument: "`...` is not allowed in `import()`.",
    ImportJSONBindingNotDefault: "A JSON module can only be imported with `default`.",
    ImportReflectionHasAssertion: "`import module x` cannot have assertions.",
    ImportReflectionNotBinding: 'Only `import module x from "./module"` is valid.',
    IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.",
    InvalidBigIntLiteral: "Invalid BigIntLiteral.",
    InvalidCodePoint: "Code point out of bounds.",
    InvalidCoverInitializedName: "Invalid shorthand property initializer.",
    InvalidDecimal: "Invalid decimal.",
    InvalidDigit: /* @__PURE__ */ s(({
      radix: t
    }) => `Expected number in radix ${t}.`, "InvalidDigit"),
    InvalidEscapeSequence: "Bad character escape sequence.",
    InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.",
    InvalidEscapedReservedWord: /* @__PURE__ */ s(({
      reservedWord: t
    }) => `Escape sequence in keyword ${t}.`, "InvalidEscapedReservedWord"),
    InvalidIdentifier: /* @__PURE__ */ s(({
      identifierName: t
    }) => `Invalid identifier ${t}.`, "InvalidIdentifier"),
    InvalidLhs: /* @__PURE__ */ s(({
      ancestor: t
    }) => `Invalid left-hand side in ${Wi(t)}.`, "InvalidLhs"),
    InvalidLhsBinding: /* @__PURE__ */ s(({
      ancestor: t
    }) => `Binding invalid left-hand side in ${Wi(t)}.`, "InvalidLhsBinding"),
    InvalidLhsOptionalChaining: /* @__PURE__ */ s(({
      ancestor: t
    }) => `Invalid optional chaining in the left-hand side of ${Wi(t)}.`, "InvalidLhsOptionalChaining"),
    InvalidNumber: "Invalid number.",
    InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.",
    InvalidOrUnexpectedToken: /* @__PURE__ */ s(({
      unexpected: t
    }) => `Unexpected character '${t}'.`, "InvalidOrUnexpectedToken"),
    InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.",
    InvalidPrivateFieldResolution: /* @__PURE__ */ s(({
      identifierName: t
    }) => `Private name #${t} is not defined.`, "InvalidPrivateFieldResolution"),
    InvalidPropertyBindingPattern: "Binding member expression.",
    InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.",
    InvalidRestAssignmentPattern: "Invalid rest operator's argument.",
    LabelRedeclaration: /* @__PURE__ */ s(({
      labelName: t
    }) => `Label '${t}' is already declared.`, "LabelRedeclaration"),
    LetInLexicalBinding: "'let' is disallowed as a lexically bound name.",
    LineTerminatorBeforeArrow: "No line break is allowed before '=>'.",
    MalformedRegExpFlags: "Invalid regular expression flag.",
    MissingClassName: "A class name is required.",
    MissingEqInAssignment: "Only '=' operator can be used for specifying default value.",
    MissingSemicolon: "Missing semicolon.",
    MissingPlugin: /* @__PURE__ */ s(({
      missingPlugin: t
    }) => `This experimental syntax requires enabling the parser plugin: ${t.map((e) => JSON.stringify(e)).join(", ")}.`, "MissingPlugin"),
    MissingOneOfPlugins: /* @__PURE__ */ s(({
      missingPlugin: t
    }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${t.map((e) => JSON.stringify(e)).join(", ")}.`,
    "MissingOneOfPlugins"),
    MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.",
    MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.",
    ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.",
    ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.",
    ModuleAttributesWithDuplicateKeys: /* @__PURE__ */ s(({
      key: t
    }) => `Duplicate key "${t}" is not allowed in module attributes.`, "ModuleAttributesWithDuplicateKeys"),
    ModuleExportNameHasLoneSurrogate: /* @__PURE__ */ s(({
      surrogateCharCode: t
    }) => `An export name cannot include a lone surrogate, found '\\u${t.toString(16)}'.`, "ModuleExportNameHasLoneSurrogate"),
    ModuleExportUndefined: /* @__PURE__ */ s(({
      localName: t
    }) => `Export '${t}' is not defined.`, "ModuleExportUndefined"),
    MultipleDefaultsInSwitch: "Multiple default clauses.",
    NewlineAfterThrow: "Illegal newline after throw.",
    NoCatchOrFinally: "Missing catch or finally clause.",
    NumberIdentifier: "Identifier directly after number.",
    NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.",
    ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.",
    OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.",
    OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.",
    OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.",
    ParamDupe: "Argument name clash.",
    PatternHasAccessor: "Object pattern can't contain getter or setter.",
    PatternHasMethod: "Object pattern can't contain methods.",
    PrivateInExpectedIn: /* @__PURE__ */ s(({
      identifierName: t
    }) => `Private names are only allowed in property accesses (\`obj.#${t}\`) or in \`in\` expressions (\`#${t} in obj\`).`, "PrivateInExpe\
ctedIn"),
    PrivateNameRedeclaration: /* @__PURE__ */ s(({
      identifierName: t
    }) => `Duplicate private name #${t}.`, "PrivateNameRedeclaration"),
    RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 're\
cordAndTuple' plugin is set to 'bar'.",
    RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the\
 'recordAndTuple' plugin is set to 'bar'.",
    RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of th\
e 'recordAndTuple' plugin is set to 'hash'.",
    RecordNoProto: "'__proto__' is not allowed in Record expressions.",
    RestTrailingComma: "Unexpected trailing comma after rest element.",
    SloppyFunction: "In non-strict mode code, functions can only be declared at top level or inside a block.",
    SloppyFunctionAnnexB: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if sta\
tement.",
    SourcePhaseImportRequiresDefault: 'Only `import source x from "./module"` is valid.',
    StaticPrototype: "Classes may not have static property named prototype.",
    SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or n\
ot extending another class?",
    SuperPrivateField: "Private fields can't be accessed on super.",
    TrailingDecorator: "Decorators must be attached to a class element.",
    TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'reco\
rdAndTuple' plugin is set to 'bar'.",
    TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the '\
recordAndTuple' plugin is set to 'bar'.",
    TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the \
'recordAndTuple' plugin is set to 'hash'.",
    UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.",
    UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.',
    UnexpectedDigitAfterHash: "Unexpected digit after hash token.",
    UnexpectedImportExport: "'import' and 'export' may only appear at the top level.",
    UnexpectedKeyword: /* @__PURE__ */ s(({
      keyword: t
    }) => `Unexpected keyword '${t}'.`, "UnexpectedKeyword"),
    UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.",
    UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.",
    UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.",
    UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.",
    UnexpectedPrivateField: "Unexpected private name.",
    UnexpectedReservedWord: /* @__PURE__ */ s(({
      reservedWord: t
    }) => `Unexpected reserved word '${t}'.`, "UnexpectedReservedWord"),
    UnexpectedSuper: "'super' is only allowed in object methods and classes.",
    UnexpectedToken: /* @__PURE__ */ s(({
      expected: t,
      unexpected: e
    }) => `Unexpected token${e ? ` '${e}'.` : ""}${t ? `, expected "${t}"` : ""}`, "UnexpectedToken"),
    UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",
    UnexpectedUsingDeclaration: "Using declaration cannot appear in the top level when source type is `script`.",
    UnsupportedBind: "Binding should be performed on object property.",
    UnsupportedDecoratorExport: "A decorated export must export a class declaration.",
    UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.",
    UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.",
    UnsupportedMetaProperty: /* @__PURE__ */ s(({
      target: t,
      onlyValidPropertyName: e
    }) => `The only valid meta property for ${t} is ${t}.${e}.`, "UnsupportedMetaProperty"),
    UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.",
    UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.",
    UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).",
    UnterminatedComment: "Unterminated comment.",
    UnterminatedRegExp: "Unterminated regular expression.",
    UnterminatedString: "Unterminated string constant.",
    UnterminatedTemplate: "Unterminated template.",
    UsingDeclarationExport: "Using declaration cannot be exported.",
    UsingDeclarationHasBindingPattern: "Using declaration cannot have destructuring patterns.",
    VarRedeclaration: /* @__PURE__ */ s(({
      identifierName: t
    }) => `Identifier '${t}' has already been declared.`, "VarRedeclaration"),
    YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.",
    YieldInParameter: "Yield expression is not allowed in formal parameters.",
    YieldNotInGeneratorFunction: "'yield' is only allowed within generator functions.",
    ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0."
  }, p3 = {
    StrictDelete: "Deleting local variable in strict mode.",
    StrictEvalArguments: /* @__PURE__ */ s(({
      referenceName: t
    }) => `Assigning to '${t}' in strict mode.`, "StrictEvalArguments"),
    StrictEvalArgumentsBinding: /* @__PURE__ */ s(({
      bindingName: t
    }) => `Binding '${t}' in strict mode.`, "StrictEvalArgumentsBinding"),
    StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.",
    StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.",
    StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.",
    StrictWith: "'with' in strict mode."
  }, f3 = /* @__PURE__ */ new Set(["ArrowFunctionExpression", "AssignmentExpression", "ConditionalExpression", "YieldExpression"]), h3 = Object.
  assign({
    PipeBodyIsTighter: "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due \
to its loose operator precedence.",
    PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" opt\
ion.',
    PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.",
    PipeTopicUnconfiguredToken: /* @__PURE__ */ s(({
      token: t
    }) => `Invalid topic token ${t}. In order to use ${t} as a topic reference, the pipelineOperator plugin must be configured with { "propo\
sal": "hack", "topicToken": "${t}" }.`, "PipeTopicUnconfiguredToken"),
    PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.",
    PipeUnparenthesizedBody: /* @__PURE__ */ s(({
      type: t
    }) => `Hack-style pipe body cannot be an unparenthesized ${Wi({
      type: t
    })}; please wrap it in parentheses.`, "PipeUnparenthesizedBody")
  }, {
    PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.',
    PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.",
    PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.",
    PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.",
    PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.",
    PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "sma\
rt" option.'
  }), d3 = ["message"];
  function Xc(t, e, r) {
    Object.defineProperty(t, e, {
      enumerable: !1,
      configurable: !0,
      value: r
    });
  }
  s(Xc, "defineHidden");
  function m3({
    toMessage: t,
    code: e,
    reasonCode: r,
    syntaxPlugin: i
  }) {
    let n = r === "MissingPlugin" || r === "MissingOneOfPlugins";
    {
      let a = {
        AccessorCannotDeclareThisParameter: "AccesorCannotDeclareThisParameter",
        AccessorCannotHaveTypeParameters: "AccesorCannotHaveTypeParameters",
        ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference: "ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumRefer\
ence",
        SetAccessorCannotHaveOptionalParameter: "SetAccesorCannotHaveOptionalParameter",
        SetAccessorCannotHaveRestParameter: "SetAccesorCannotHaveRestParameter",
        SetAccessorCannotHaveReturnType: "SetAccesorCannotHaveReturnType"
      };
      a[r] && (r = a[r]);
    }
    return /* @__PURE__ */ s(function a(o, l) {
      let u = new SyntaxError();
      return u.code = e, u.reasonCode = r, u.loc = o, u.pos = o.index, u.syntaxPlugin = i, n && (u.missingPlugin = l.missingPlugin), Xc(u, "\
clone", /* @__PURE__ */ s(function(m = {}) {
        var g;
        let {
          line: I,
          column: v,
          index: _
        } = (g = m.loc) != null ? g : o;
        return a(new Et(I, v, _), Object.assign({}, l, m.details));
      }, "clone")), Xc(u, "details", l), Object.defineProperty(u, "message", {
        configurable: !0,
        get() {
          let p = `${t(l)} (${o.line}:${o.column})`;
          return this.message = p, p;
        },
        set(p) {
          Object.defineProperty(this, "message", {
            value: p,
            writable: !0
          });
        }
      }), u;
    }, "constructor");
  }
  s(m3, "toParseErrorConstructor");
  function _t(t, e) {
    if (Array.isArray(t))
      return (i) => _t(i, t[0]);
    let r = {};
    for (let i of Object.keys(t)) {
      let n = t[i], a = typeof n == "string" ? {
        message: /* @__PURE__ */ s(() => n, "message")
      } : typeof n == "function" ? {
        message: n
      } : n, {
        message: o
      } = a, l = l3(a, d3), u = typeof o == "string" ? () => o : o;
      r[i] = m3(Object.assign({
        code: "BABEL_PARSER_SYNTAX_ERROR",
        reasonCode: i,
        toMessage: u
      }, e ? {
        syntaxPlugin: e
      } : {}, l));
    }
    return r;
  }
  s(_t, "ParseErrorEnum");
  var P = Object.assign({}, _t(u3), _t(c3), _t(p3), _t`pipelineOperator`(h3));
  function y3() {
    return {
      sourceType: "script",
      sourceFilename: void 0,
      startIndex: 0,
      startColumn: 0,
      startLine: 1,
      allowAwaitOutsideFunction: !1,
      allowReturnOutsideFunction: !1,
      allowNewTargetOutsideFunction: !1,
      allowImportExportEverywhere: !1,
      allowSuperOutsideMethod: !1,
      allowUndeclaredExports: !1,
      allowYieldOutsideFunction: !1,
      plugins: [],
      strictMode: null,
      ranges: !1,
      tokens: !1,
      createImportExpressions: !1,
      createParenthesizedExpressions: !1,
      errorRecovery: !1,
      attachComment: !0,
      annexB: !0
    };
  }
  s(y3, "createDefaultOptions");
  function T3(t) {
    let e = y3();
    if (t == null)
      return e;
    if (t.annexB != null && t.annexB !== !1)
      throw new Error("The `annexB` option can only be set to `false`.");
    for (let r of Object.keys(e))
      t[r] != null && (e[r] = t[r]);
    if (e.startLine === 1)
      t.startIndex == null && e.startColumn > 0 ? e.startIndex = e.startColumn : t.startColumn == null && e.startIndex > 0 && (e.startColumn =
      e.startIndex);
    else if ((t.startColumn == null || t.startIndex == null) && t.startIndex != null)
      throw new Error("With a `startLine > 1` you must also specify `startIndex` and `startColumn`.");
    return e;
  }
  s(T3, "getOptions");
  var {
    defineProperty: S3
  } = Object, Wc = /* @__PURE__ */ s((t, e) => {
    t && S3(t, e, {
      enumerable: !1,
      value: t[e]
    });
  }, "toUnenumerable");
  function Kr(t) {
    return Wc(t.loc.start, "index"), Wc(t.loc.end, "index"), t;
  }
  s(Kr, "toESTreeLocation");
  var b3 = /* @__PURE__ */ s((t) => class extends t {
    static {
      s(this, "ESTreeParserMixin");
    }
    parse() {
      let r = Kr(super.parse());
      return this.optionFlags & 256 && (r.tokens = r.tokens.map(Kr)), r;
    }
    parseRegExpLiteral({
      pattern: r,
      flags: i
    }) {
      let n = null;
      try {
        n = new RegExp(r, i);
      } catch {
      }
      let a = this.estreeParseLiteral(n);
      return a.regex = {
        pattern: r,
        flags: i
      }, a;
    }
    parseBigIntLiteral(r) {
      let i;
      try {
        i = BigInt(r);
      } catch {
        i = null;
      }
      let n = this.estreeParseLiteral(i);
      return n.bigint = String(n.value || r), n;
    }
    parseDecimalLiteral(r) {
      let n = this.estreeParseLiteral(null);
      return n.decimal = String(n.value || r), n;
    }
    estreeParseLiteral(r) {
      return this.parseLiteral(r, "Literal");
    }
    parseStringLiteral(r) {
      return this.estreeParseLiteral(r);
    }
    parseNumericLiteral(r) {
      return this.estreeParseLiteral(r);
    }
    parseNullLiteral() {
      return this.estreeParseLiteral(null);
    }
    parseBooleanLiteral(r) {
      return this.estreeParseLiteral(r);
    }
    directiveToStmt(r) {
      let i = r.value;
      delete r.value, i.type = "Literal", i.raw = i.extra.raw, i.value = i.extra.expressionValue;
      let n = r;
      return n.type = "ExpressionStatement", n.expression = i, n.directive = i.extra.rawValue, delete i.extra, n;
    }
    initFunction(r, i) {
      super.initFunction(r, i), r.expression = !1;
    }
    checkDeclaration(r) {
      r != null && this.isObjectProperty(r) ? this.checkDeclaration(r.value) : super.checkDeclaration(r);
    }
    getObjectOrClassMethodParams(r) {
      return r.value.params;
    }
    isValidDirective(r) {
      var i;
      return r.type === "ExpressionStatement" && r.expression.type === "Literal" && typeof r.expression.value == "string" && !((i = r.expression.
      extra) != null && i.parenthesized);
    }
    parseBlockBody(r, i, n, a, o) {
      super.parseBlockBody(r, i, n, a, o);
      let l = r.directives.map((u) => this.directiveToStmt(u));
      r.body = l.concat(r.body), delete r.directives;
    }
    parsePrivateName() {
      let r = super.parsePrivateName();
      return this.getPluginOption("estree", "classFeatures") ? this.convertPrivateNameToPrivateIdentifier(r) : r;
    }
    convertPrivateNameToPrivateIdentifier(r) {
      let i = super.getPrivateNameSV(r);
      return r = r, delete r.id, r.name = i, r.type = "PrivateIdentifier", r;
    }
    isPrivateName(r) {
      return this.getPluginOption("estree", "classFeatures") ? r.type === "PrivateIdentifier" : super.isPrivateName(r);
    }
    getPrivateNameSV(r) {
      return this.getPluginOption("estree", "classFeatures") ? r.name : super.getPrivateNameSV(r);
    }
    parseLiteral(r, i) {
      let n = super.parseLiteral(r, i);
      return n.raw = n.extra.raw, delete n.extra, n;
    }
    parseFunctionBody(r, i, n = !1) {
      super.parseFunctionBody(r, i, n), r.expression = r.body.type !== "BlockStatement";
    }
    parseMethod(r, i, n, a, o, l, u = !1) {
      let p = this.startNode();
      p.kind = r.kind, p = super.parseMethod(p, i, n, a, o, l, u), p.type = "FunctionExpression", delete p.kind, r.value = p;
      let {
        typeParameters: m
      } = r;
      return m && (delete r.typeParameters, p.typeParameters = m, this.resetStartLocationFromNode(p, m)), l === "ClassPrivateMethod" && (r.computed =
      !1), this.finishNode(r, "MethodDefinition");
    }
    nameIsConstructor(r) {
      return r.type === "Literal" ? r.value === "constructor" : super.nameIsConstructor(r);
    }
    parseClassProperty(...r) {
      let i = super.parseClassProperty(...r);
      return this.getPluginOption("estree", "classFeatures") && (i.type = "PropertyDefinition"), i;
    }
    parseClassPrivateProperty(...r) {
      let i = super.parseClassPrivateProperty(...r);
      return this.getPluginOption("estree", "classFeatures") && (i.type = "PropertyDefinition", i.computed = !1), i;
    }
    parseClassAccessorProperty(r) {
      let i = super.parseClassAccessorProperty(r);
      return this.getPluginOption("estree", "classFeatures") && (i.type = "AccessorProperty"), i;
    }
    parseObjectMethod(r, i, n, a, o) {
      let l = super.parseObjectMethod(r, i, n, a, o);
      return l && (l.type = "Property", l.kind === "method" && (l.kind = "init"), l.shorthand = !1), l;
    }
    parseObjectProperty(r, i, n, a) {
      let o = super.parseObjectProperty(r, i, n, a);
      return o && (o.kind = "init", o.type = "Property"), o;
    }
    isValidLVal(r, i, n) {
      return r === "Property" ? "value" : super.isValidLVal(r, i, n);
    }
    isAssignable(r, i) {
      return r != null && this.isObjectProperty(r) ? this.isAssignable(r.value, i) : super.isAssignable(r, i);
    }
    toAssignable(r, i = !1) {
      if (r != null && this.isObjectProperty(r)) {
        let {
          key: n,
          value: a
        } = r;
        this.isPrivateName(n) && this.classScope.usePrivateName(this.getPrivateNameSV(n), n.loc.start), this.toAssignable(a, i);
      } else
        super.toAssignable(r, i);
    }
    toAssignableObjectExpressionProp(r, i, n) {
      r.type === "Property" && (r.kind === "get" || r.kind === "set") ? this.raise(P.PatternHasAccessor, r.key) : r.type === "Property" && r.
      method ? this.raise(P.PatternHasMethod, r.key) : super.toAssignableObjectExpressionProp(r, i, n);
    }
    finishCallExpression(r, i) {
      let n = super.finishCallExpression(r, i);
      if (n.callee.type === "Import") {
        var a, o;
        n.type = "ImportExpression", n.source = n.arguments[0], n.options = (a = n.arguments[1]) != null ? a : null, n.attributes = (o = n.arguments[1]) !=
        null ? o : null, delete n.arguments, delete n.callee;
      }
      return n;
    }
    toReferencedArguments(r) {
      r.type !== "ImportExpression" && super.toReferencedArguments(r);
    }
    parseExport(r, i) {
      let n = this.state.lastTokStartLoc, a = super.parseExport(r, i);
      switch (a.type) {
        case "ExportAllDeclaration":
          a.exported = null;
          break;
        case "ExportNamedDeclaration":
          a.specifiers.length === 1 && a.specifiers[0].type === "ExportNamespaceSpecifier" && (a.type = "ExportAllDeclaration", a.exported =
          a.specifiers[0].exported, delete a.specifiers);
        case "ExportDefaultDeclaration":
          {
            var o;
            let {
              declaration: l
            } = a;
            l?.type === "ClassDeclaration" && ((o = l.decorators) == null ? void 0 : o.length) > 0 && l.start === a.start && this.resetStartLocation(
            a, n);
          }
          break;
      }
      return a;
    }
    parseSubscript(r, i, n, a) {
      let o = super.parseSubscript(r, i, n, a);
      if (a.optionalChainMember) {
        if ((o.type === "OptionalMemberExpression" || o.type === "OptionalCallExpression") && (o.type = o.type.substring(8)), a.stop) {
          let l = this.startNodeAtNode(o);
          return l.expression = o, this.finishNode(l, "ChainExpression");
        }
      } else (o.type === "MemberExpression" || o.type === "CallExpression") && (o.optional = !1);
      return o;
    }
    isOptionalMemberExpression(r) {
      return r.type === "ChainExpression" ? r.expression.type === "MemberExpression" : super.isOptionalMemberExpression(r);
    }
    hasPropertyAsPrivateName(r) {
      return r.type === "ChainExpression" && (r = r.expression), super.hasPropertyAsPrivateName(r);
    }
    isObjectProperty(r) {
      return r.type === "Property" && r.kind === "init" && !r.method;
    }
    isObjectMethod(r) {
      return r.type === "Property" && (r.method || r.kind === "get" || r.kind === "set");
    }
    finishNodeAt(r, i, n) {
      return Kr(super.finishNodeAt(r, i, n));
    }
    resetStartLocation(r, i) {
      super.resetStartLocation(r, i), Kr(r);
    }
    resetEndLocation(r, i = this.state.lastTokEndLoc) {
      super.resetEndLocation(r, i), Kr(r);
    }
  }, "estree"), er = class {
    static {
      s(this, "TokContext");
    }
    constructor(e, r) {
      this.token = void 0, this.preserveSpace = void 0, this.token = e, this.preserveSpace = !!r;
    }
  }, Ie = {
    brace: new er("{"),
    j_oTag: new er("<tag"),
    j_cTag: new er("</tag"),
    j_expr: new er("<tag>...</tag>", !0)
  };
  Ie.template = new er("`", !0);
  var me = !0, K = !0, Ja = !0, Vr = !0, qt = !0, x3 = !0, Hi = class {
    static {
      s(this, "ExportedTokenType");
    }
    constructor(e, r = {}) {
      this.label = void 0, this.keyword = void 0, this.beforeExpr = void 0, this.startsExpr = void 0, this.rightAssociative = void 0, this.isLoop =
      void 0, this.isAssign = void 0, this.prefix = void 0, this.postfix = void 0, this.binop = void 0, this.label = e, this.keyword = r.keyword,
      this.beforeExpr = !!r.beforeExpr, this.startsExpr = !!r.startsExpr, this.rightAssociative = !!r.rightAssociative, this.isLoop = !!r.isLoop,
      this.isAssign = !!r.isAssign, this.prefix = !!r.prefix, this.postfix = !!r.postfix, this.binop = r.binop != null ? r.binop : null, this.
      updateContext = null;
    }
  }, yo = /* @__PURE__ */ new Map();
  function ge(t, e = {}) {
    e.keyword = t;
    let r = te(t, e);
    return yo.set(t, r), r;
  }
  s(ge, "createKeyword");
  function Qe(t, e) {
    return te(t, {
      beforeExpr: me,
      binop: e
    });
  }
  s(Qe, "createBinop");
  var Wr = -1, Nt = [], To = [], So = [], bo = [], xo = [], Po = [];
  function te(t, e = {}) {
    var r, i, n, a;
    return ++Wr, To.push(t), So.push((r = e.binop) != null ? r : -1), bo.push((i = e.beforeExpr) != null ? i : !1), xo.push((n = e.startsExpr) !=
    null ? n : !1), Po.push((a = e.prefix) != null ? a : !1), Nt.push(new Hi(t, e)), Wr;
  }
  s(te, "createToken");
  function de(t, e = {}) {
    var r, i, n, a;
    return ++Wr, yo.set(t, Wr), To.push(t), So.push((r = e.binop) != null ? r : -1), bo.push((i = e.beforeExpr) != null ? i : !1), xo.push((n =
    e.startsExpr) != null ? n : !1), Po.push((a = e.prefix) != null ? a : !1), Nt.push(new Hi("name", e)), Wr;
  }
  s(de, "createKeywordLike");
  var P3 = {
    bracketL: te("[", {
      beforeExpr: me,
      startsExpr: K
    }),
    bracketHashL: te("#[", {
      beforeExpr: me,
      startsExpr: K
    }),
    bracketBarL: te("[|", {
      beforeExpr: me,
      startsExpr: K
    }),
    bracketR: te("]"),
    bracketBarR: te("|]"),
    braceL: te("{", {
      beforeExpr: me,
      startsExpr: K
    }),
    braceBarL: te("{|", {
      beforeExpr: me,
      startsExpr: K
    }),
    braceHashL: te("#{", {
      beforeExpr: me,
      startsExpr: K
    }),
    braceR: te("}"),
    braceBarR: te("|}"),
    parenL: te("(", {
      beforeExpr: me,
      startsExpr: K
    }),
    parenR: te(")"),
    comma: te(",", {
      beforeExpr: me
    }),
    semi: te(";", {
      beforeExpr: me
    }),
    colon: te(":", {
      beforeExpr: me
    }),
    doubleColon: te("::", {
      beforeExpr: me
    }),
    dot: te("."),
    question: te("?", {
      beforeExpr: me
    }),
    questionDot: te("?."),
    arrow: te("=>", {
      beforeExpr: me
    }),
    template: te("template"),
    ellipsis: te("...", {
      beforeExpr: me
    }),
    backQuote: te("`", {
      startsExpr: K
    }),
    dollarBraceL: te("${", {
      beforeExpr: me,
      startsExpr: K
    }),
    templateTail: te("...`", {
      startsExpr: K
    }),
    templateNonTail: te("...${", {
      beforeExpr: me,
      startsExpr: K
    }),
    at: te("@"),
    hash: te("#", {
      startsExpr: K
    }),
    interpreterDirective: te("#!..."),
    eq: te("=", {
      beforeExpr: me,
      isAssign: Vr
    }),
    assign: te("_=", {
      beforeExpr: me,
      isAssign: Vr
    }),
    slashAssign: te("_=", {
      beforeExpr: me,
      isAssign: Vr
    }),
    xorAssign: te("_=", {
      beforeExpr: me,
      isAssign: Vr
    }),
    moduloAssign: te("_=", {
      beforeExpr: me,
      isAssign: Vr
    }),
    incDec: te("++/--", {
      prefix: qt,
      postfix: x3,
      startsExpr: K
    }),
    bang: te("!", {
      beforeExpr: me,
      prefix: qt,
      startsExpr: K
    }),
    tilde: te("~", {
      beforeExpr: me,
      prefix: qt,
      startsExpr: K
    }),
    doubleCaret: te("^^", {
      startsExpr: K
    }),
    doubleAt: te("@@", {
      startsExpr: K
    }),
    pipeline: Qe("|>", 0),
    nullishCoalescing: Qe("??", 1),
    logicalOR: Qe("||", 1),
    logicalAND: Qe("&&", 2),
    bitwiseOR: Qe("|", 3),
    bitwiseXOR: Qe("^", 4),
    bitwiseAND: Qe("&", 5),
    equality: Qe("==/!=/===/!==", 6),
    lt: Qe("</>/<=/>=", 7),
    gt: Qe("</>/<=/>=", 7),
    relational: Qe("</>/<=/>=", 7),
    bitShift: Qe("<</>>/>>>", 8),
    bitShiftL: Qe("<</>>/>>>", 8),
    bitShiftR: Qe("<</>>/>>>", 8),
    plusMin: te("+/-", {
      beforeExpr: me,
      binop: 9,
      prefix: qt,
      startsExpr: K
    }),
    modulo: te("%", {
      binop: 10,
      startsExpr: K
    }),
    star: te("*", {
      binop: 10
    }),
    slash: Qe("/", 10),
    exponent: te("**", {
      beforeExpr: me,
      binop: 11,
      rightAssociative: !0
    }),
    _in: ge("in", {
      beforeExpr: me,
      binop: 7
    }),
    _instanceof: ge("instanceof", {
      beforeExpr: me,
      binop: 7
    }),
    _break: ge("break"),
    _case: ge("case", {
      beforeExpr: me
    }),
    _catch: ge("catch"),
    _continue: ge("continue"),
    _debugger: ge("debugger"),
    _default: ge("default", {
      beforeExpr: me
    }),
    _else: ge("else", {
      beforeExpr: me
    }),
    _finally: ge("finally"),
    _function: ge("function", {
      startsExpr: K
    }),
    _if: ge("if"),
    _return: ge("return", {
      beforeExpr: me
    }),
    _switch: ge("switch"),
    _throw: ge("throw", {
      beforeExpr: me,
      prefix: qt,
      startsExpr: K
    }),
    _try: ge("try"),
    _var: ge("var"),
    _const: ge("const"),
    _with: ge("with"),
    _new: ge("new", {
      beforeExpr: me,
      startsExpr: K
    }),
    _this: ge("this", {
      startsExpr: K
    }),
    _super: ge("super", {
      startsExpr: K
    }),
    _class: ge("class", {
      startsExpr: K
    }),
    _extends: ge("extends", {
      beforeExpr: me
    }),
    _export: ge("export"),
    _import: ge("import", {
      startsExpr: K
    }),
    _null: ge("null", {
      startsExpr: K
    }),
    _true: ge("true", {
      startsExpr: K
    }),
    _false: ge("false", {
      startsExpr: K
    }),
    _typeof: ge("typeof", {
      beforeExpr: me,
      prefix: qt,
      startsExpr: K
    }),
    _void: ge("void", {
      beforeExpr: me,
      prefix: qt,
      startsExpr: K
    }),
    _delete: ge("delete", {
      beforeExpr: me,
      prefix: qt,
      startsExpr: K
    }),
    _do: ge("do", {
      isLoop: Ja,
      beforeExpr: me
    }),
    _for: ge("for", {
      isLoop: Ja
    }),
    _while: ge("while", {
      isLoop: Ja
    }),
    _as: de("as", {
      startsExpr: K
    }),
    _assert: de("assert", {
      startsExpr: K
    }),
    _async: de("async", {
      startsExpr: K
    }),
    _await: de("await", {
      startsExpr: K
    }),
    _defer: de("defer", {
      startsExpr: K
    }),
    _from: de("from", {
      startsExpr: K
    }),
    _get: de("get", {
      startsExpr: K
    }),
    _let: de("let", {
      startsExpr: K
    }),
    _meta: de("meta", {
      startsExpr: K
    }),
    _of: de("of", {
      startsExpr: K
    }),
    _sent: de("sent", {
      startsExpr: K
    }),
    _set: de("set", {
      startsExpr: K
    }),
    _source: de("source", {
      startsExpr: K
    }),
    _static: de("static", {
      startsExpr: K
    }),
    _using: de("using", {
      startsExpr: K
    }),
    _yield: de("yield", {
      startsExpr: K
    }),
    _asserts: de("asserts", {
      startsExpr: K
    }),
    _checks: de("checks", {
      startsExpr: K
    }),
    _exports: de("exports", {
      startsExpr: K
    }),
    _global: de("global", {
      startsExpr: K
    }),
    _implements: de("implements", {
      startsExpr: K
    }),
    _intrinsic: de("intrinsic", {
      startsExpr: K
    }),
    _infer: de("infer", {
      startsExpr: K
    }),
    _is: de("is", {
      startsExpr: K
    }),
    _mixins: de("mixins", {
      startsExpr: K
    }),
    _proto: de("proto", {
      startsExpr: K
    }),
    _require: de("require", {
      startsExpr: K
    }),
    _satisfies: de("satisfies", {
      startsExpr: K
    }),
    _keyof: de("keyof", {
      startsExpr: K
    }),
    _readonly: de("readonly", {
      startsExpr: K
    }),
    _unique: de("unique", {
      startsExpr: K
    }),
    _abstract: de("abstract", {
      startsExpr: K
    }),
    _declare: de("declare", {
      startsExpr: K
    }),
    _enum: de("enum", {
      startsExpr: K
    }),
    _module: de("module", {
      startsExpr: K
    }),
    _namespace: de("namespace", {
      startsExpr: K
    }),
    _interface: de("interface", {
      startsExpr: K
    }),
    _type: de("type", {
      startsExpr: K
    }),
    _opaque: de("opaque", {
      startsExpr: K
    }),
    name: te("name", {
      startsExpr: K
    }),
    placeholder: te("%%", {
      startsExpr: !0
    }),
    string: te("string", {
      startsExpr: K
    }),
    num: te("num", {
      startsExpr: K
    }),
    bigint: te("bigint", {
      startsExpr: K
    }),
    decimal: te("decimal", {
      startsExpr: K
    }),
    regexp: te("regexp", {
      startsExpr: K
    }),
    privateName: te("#name", {
      startsExpr: K
    }),
    eof: te("eof"),
    jsxName: te("jsxName"),
    jsxText: te("jsxText", {
      beforeExpr: !0
    }),
    jsxTagStart: te("jsxTagStart", {
      startsExpr: !0
    }),
    jsxTagEnd: te("jsxTagEnd")
  };
  function ve(t) {
    return t >= 93 && t <= 133;
  }
  s(ve, "tokenIsIdentifier");
  function E3(t) {
    return t <= 92;
  }
  s(E3, "tokenKeywordOrIdentifierIsKeyword");
  function mt(t) {
    return t >= 58 && t <= 133;
  }
  s(mt, "tokenIsKeywordOrIdentifier");
  function np(t) {
    return t >= 58 && t <= 137;
  }
  s(np, "tokenIsLiteralPropertyName");
  function g3(t) {
    return bo[t];
  }
  s(g3, "tokenComesBeforeExpression");
  function Jr(t) {
    return xo[t];
  }
  s(Jr, "tokenCanStartExpression");
  function A3(t) {
    return t >= 29 && t <= 33;
  }
  s(A3, "tokenIsAssignment");
  function zc(t) {
    return t >= 129 && t <= 131;
  }
  s(zc, "tokenIsFlowInterfaceOrTypeOrOpaque");
  function I3(t) {
    return t >= 90 && t <= 92;
  }
  s(I3, "tokenIsLoop");
  function Eo(t) {
    return t >= 58 && t <= 92;
  }
  s(Eo, "tokenIsKeyword");
  function v3(t) {
    return t >= 39 && t <= 59;
  }
  s(v3, "tokenIsOperator");
  function C3(t) {
    return t === 34;
  }
  s(C3, "tokenIsPostfix");
  function w3(t) {
    return Po[t];
  }
  s(w3, "tokenIsPrefix");
  function N3(t) {
    return t >= 121 && t <= 123;
  }
  s(N3, "tokenIsTSTypeOperator");
  function O3(t) {
    return t >= 124 && t <= 130;
  }
  s(O3, "tokenIsTSDeclarationStart");
  function Kt(t) {
    return To[t];
  }
  s(Kt, "tokenLabelName");
  function zi(t) {
    return So[t];
  }
  s(zi, "tokenOperatorPrecedence");
  function _3(t) {
    return t === 57;
  }
  s(_3, "tokenIsRightAssociative");
  function Gi(t) {
    return t >= 24 && t <= 25;
  }
  s(Gi, "tokenIsTemplate");
  function wt(t) {
    return Nt[t];
  }
  s(wt, "getExportedToken");
  Nt[8].updateContext = (t) => {
    t.pop();
  }, Nt[5].updateContext = Nt[7].updateContext = Nt[23].updateContext = (t) => {
    t.push(Ie.brace);
  }, Nt[22].updateContext = (t) => {
    t[t.length - 1] === Ie.template ? t.pop() : t.push(Ie.template);
  }, Nt[143].updateContext = (t) => {
    t.push(Ie.j_expr, Ie.j_oTag);
  };
  var go = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993\
-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\
\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\
\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\
\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\
\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CD\uA7D0\uA7D1\uA7D3\uA7D5-\uA7DC\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01\
-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC",
  ap = "\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\
\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\
\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6\
-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20\
-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65", D3 = new RegExp("[" + go + "]"), k3 = new RegExp("[" + go + ap + "]");
  go = ap = null;
  var op = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157,
  19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5,
  3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7,
  2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 2, 60, 28, 11, 0, 9, 21, 43, 17,
  47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64,
  6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45,
  52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2,
  1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29,
  113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071,
  18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 129, 74, 6, 0, 67, 12,
  65, 1, 2, 0, 29, 6135, 9, 1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991,
  84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30,
  2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3,
  0, 496, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2,
  2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153,
  7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191], L3 = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0,
  166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2,
  9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68,
  8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14,
  5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 343, 9, 54, 7, 2,
  7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0,
  7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4,
  4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10,
  9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 726, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
  function Ha(t, e) {
    let r = 65536;
    for (let i = 0, n = e.length; i < n; i += 2) {
      if (r += e[i], r > t) return !1;
      if (r += e[i + 1], r >= t) return !0;
    }
    return !1;
  }
  s(Ha, "isInAstralSet");
  function Ot(t) {
    return t < 65 ? t === 36 : t <= 90 ? !0 : t < 97 ? t === 95 : t <= 122 ? !0 : t <= 65535 ? t >= 170 && D3.test(String.fromCharCode(t)) :
    Ha(t, op);
  }
  s(Ot, "isIdentifierStart");
  function dr(t) {
    return t < 48 ? t === 36 : t < 58 ? !0 : t < 65 ? !1 : t <= 90 ? !0 : t < 97 ? t === 95 : t <= 122 ? !0 : t <= 65535 ? t >= 170 && k3.test(
    String.fromCharCode(t)) : Ha(t, op) || Ha(t, L3);
  }
  s(dr, "isIdentifierChar");
  var Ao = {
    keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "swit\
ch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false",
    "in", "instanceof", "typeof", "void", "delete"],
    strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
    strictBind: ["eval", "arguments"]
  }, M3 = new Set(Ao.keyword), B3 = new Set(Ao.strict), j3 = new Set(Ao.strictBind);
  function lp(t, e) {
    return e && t === "await" || t === "enum";
  }
  s(lp, "isReservedWord");
  function up(t, e) {
    return lp(t, e) || B3.has(t);
  }
  s(up, "isStrictReservedWord");
  function cp(t) {
    return j3.has(t);
  }
  s(cp, "isStrictBindOnlyReservedWord");
  function pp(t, e) {
    return up(t, e) || cp(t);
  }
  s(pp, "isStrictBindReservedWord");
  function F3(t) {
    return M3.has(t);
  }
  s(F3, "isKeyword");
  function R3(t, e, r) {
    return t === 64 && e === 64 && Ot(r);
  }
  s(R3, "isIteratorStart");
  var q3 = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function",
  "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import",
  "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protecte\
d", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
  function U3(t) {
    return q3.has(t);
  }
  s(U3, "canBeReservedWord");
  var zr = class {
    static {
      s(this, "Scope");
    }
    constructor(e) {
      this.flags = 0, this.names = /* @__PURE__ */ new Map(), this.firstLexicalName = "", this.flags = e;
    }
  }, $r = class {
    static {
      s(this, "ScopeHandler");
    }
    constructor(e, r) {
      this.parser = void 0, this.scopeStack = [], this.inModule = void 0, this.undefinedExports = /* @__PURE__ */ new Map(), this.parser = e,
      this.inModule = r;
    }
    get inTopLevel() {
      return (this.currentScope().flags & 1) > 0;
    }
    get inFunction() {
      return (this.currentVarScopeFlags() & 2) > 0;
    }
    get allowSuper() {
      return (this.currentThisScopeFlags() & 16) > 0;
    }
    get allowDirectSuper() {
      return (this.currentThisScopeFlags() & 32) > 0;
    }
    get inClass() {
      return (this.currentThisScopeFlags() & 64) > 0;
    }
    get inClassAndNotInNonArrowFunction() {
      let e = this.currentThisScopeFlags();
      return (e & 64) > 0 && (e & 2) === 0;
    }
    get inStaticBlock() {
      for (let e = this.scopeStack.length - 1; ; e--) {
        let {
          flags: r
        } = this.scopeStack[e];
        if (r & 128)
          return !0;
        if (r & 451)
          return !1;
      }
    }
    get inNonArrowFunction() {
      return (this.currentThisScopeFlags() & 2) > 0;
    }
    get treatFunctionsAsVar() {
      return this.treatFunctionsAsVarInScope(this.currentScope());
    }
    createScope(e) {
      return new zr(e);
    }
    enter(e) {
      this.scopeStack.push(this.createScope(e));
    }
    exit() {
      return this.scopeStack.pop().flags;
    }
    treatFunctionsAsVarInScope(e) {
      return !!(e.flags & 130 || !this.parser.inModule && e.flags & 1);
    }
    declareName(e, r, i) {
      let n = this.currentScope();
      if (r & 8 || r & 16) {
        this.checkRedeclarationInScope(n, e, r, i);
        let a = n.names.get(e) || 0;
        r & 16 ? a = a | 4 : (n.firstLexicalName || (n.firstLexicalName = e), a = a | 2), n.names.set(e, a), r & 8 && this.maybeExportDefined(
        n, e);
      } else if (r & 4)
        for (let a = this.scopeStack.length - 1; a >= 0 && (n = this.scopeStack[a], this.checkRedeclarationInScope(n, e, r, i), n.names.set(
        e, (n.names.get(e) || 0) | 1), this.maybeExportDefined(n, e), !(n.flags & 387)); --a)
          ;
      this.parser.inModule && n.flags & 1 && this.undefinedExports.delete(e);
    }
    maybeExportDefined(e, r) {
      this.parser.inModule && e.flags & 1 && this.undefinedExports.delete(r);
    }
    checkRedeclarationInScope(e, r, i, n) {
      this.isRedeclaredInScope(e, r, i) && this.parser.raise(P.VarRedeclaration, n, {
        identifierName: r
      });
    }
    isRedeclaredInScope(e, r, i) {
      if (!(i & 1)) return !1;
      if (i & 8)
        return e.names.has(r);
      let n = e.names.get(r);
      return i & 16 ? (n & 2) > 0 || !this.treatFunctionsAsVarInScope(e) && (n & 1) > 0 : (n & 2) > 0 && !(e.flags & 8 && e.firstLexicalName ===
      r) || !this.treatFunctionsAsVarInScope(e) && (n & 4) > 0;
    }
    checkLocalExport(e) {
      let {
        name: r
      } = e;
      this.scopeStack[0].names.has(r) || this.undefinedExports.set(r, e.loc.start);
    }
    currentScope() {
      return this.scopeStack[this.scopeStack.length - 1];
    }
    currentVarScopeFlags() {
      for (let e = this.scopeStack.length - 1; ; e--) {
        let {
          flags: r
        } = this.scopeStack[e];
        if (r & 387)
          return r;
      }
    }
    currentThisScopeFlags() {
      for (let e = this.scopeStack.length - 1; ; e--) {
        let {
          flags: r
        } = this.scopeStack[e];
        if (r & 451 && !(r & 4))
          return r;
      }
    }
  }, Ga = class extends zr {
    static {
      s(this, "FlowScope");
    }
    constructor(...e) {
      super(...e), this.declareFunctions = /* @__PURE__ */ new Set();
    }
  }, Qa = class extends $r {
    static {
      s(this, "FlowScopeHandler");
    }
    createScope(e) {
      return new Ga(e);
    }
    declareName(e, r, i) {
      let n = this.currentScope();
      if (r & 2048) {
        this.checkRedeclarationInScope(n, e, r, i), this.maybeExportDefined(n, e), n.declareFunctions.add(e);
        return;
      }
      super.declareName(e, r, i);
    }
    isRedeclaredInScope(e, r, i) {
      if (super.isRedeclaredInScope(e, r, i)) return !0;
      if (i & 2048 && !e.declareFunctions.has(r)) {
        let n = e.names.get(r);
        return (n & 4) > 0 || (n & 2) > 0;
      }
      return !1;
    }
    checkLocalExport(e) {
      this.scopeStack[0].declareFunctions.has(e.name) || super.checkLocalExport(e);
    }
  }, Za = class {
    static {
      s(this, "BaseParser");
    }
    constructor() {
      this.sawUnambiguousESM = !1, this.ambiguousScriptDifferentAst = !1;
    }
    sourceToOffsetPos(e) {
      return e + this.startIndex;
    }
    offsetToSourcePos(e) {
      return e - this.startIndex;
    }
    hasPlugin(e) {
      if (typeof e == "string")
        return this.plugins.has(e);
      {
        let [r, i] = e;
        if (!this.hasPlugin(r))
          return !1;
        let n = this.plugins.get(r);
        for (let a of Object.keys(i))
          if (n?.[a] !== i[a])
            return !1;
        return !0;
      }
    }
    getPluginOption(e, r) {
      var i;
      return (i = this.plugins.get(e)) == null ? void 0 : i[r];
    }
  };
  function fp(t, e) {
    t.trailingComments === void 0 ? t.trailingComments = e : t.trailingComments.unshift(...e);
  }
  s(fp, "setTrailingComments");
  function K3(t, e) {
    t.leadingComments === void 0 ? t.leadingComments = e : t.leadingComments.unshift(...e);
  }
  s(K3, "setLeadingComments");
  function Hr(t, e) {
    t.innerComments === void 0 ? t.innerComments = e : t.innerComments.unshift(...e);
  }
  s(Hr, "setInnerComments");
  function Qt(t, e, r) {
    let i = null, n = e.length;
    for (; i === null && n > 0; )
      i = e[--n];
    i === null || i.start > r.start ? Hr(t, r.comments) : fp(i, r.comments);
  }
  s(Qt, "adjustInnerComments");
  var eo = class extends Za {
    static {
      s(this, "CommentsParser");
    }
    addComment(e) {
      this.filename && (e.loc.filename = this.filename);
      let {
        commentsLen: r
      } = this.state;
      this.comments.length !== r && (this.comments.length = r), this.comments.push(e), this.state.commentsLen++;
    }
    processComment(e) {
      let {
        commentStack: r
      } = this.state, i = r.length;
      if (i === 0) return;
      let n = i - 1, a = r[n];
      a.start === e.end && (a.leadingNode = e, n--);
      let {
        start: o
      } = e;
      for (; n >= 0; n--) {
        let l = r[n], u = l.end;
        if (u > o)
          l.containingNode = e, this.finalizeComment(l), r.splice(n, 1);
        else {
          u === o && (l.trailingNode = e);
          break;
        }
      }
    }
    finalizeComment(e) {
      let {
        comments: r
      } = e;
      if (e.leadingNode !== null || e.trailingNode !== null)
        e.leadingNode !== null && fp(e.leadingNode, r), e.trailingNode !== null && K3(e.trailingNode, r);
      else {
        let {
          containingNode: i,
          start: n
        } = e;
        if (this.input.charCodeAt(this.offsetToSourcePos(n) - 1) === 44)
          switch (i.type) {
            case "ObjectExpression":
            case "ObjectPattern":
            case "RecordExpression":
              Qt(i, i.properties, e);
              break;
            case "CallExpression":
            case "OptionalCallExpression":
              Qt(i, i.arguments, e);
              break;
            case "FunctionDeclaration":
            case "FunctionExpression":
            case "ArrowFunctionExpression":
            case "ObjectMethod":
            case "ClassMethod":
            case "ClassPrivateMethod":
              Qt(i, i.params, e);
              break;
            case "ArrayExpression":
            case "ArrayPattern":
            case "TupleExpression":
              Qt(i, i.elements, e);
              break;
            case "ExportNamedDeclaration":
            case "ImportDeclaration":
              Qt(i, i.specifiers, e);
              break;
            case "TSEnumDeclaration":
              Qt(i, i.members, e);
              break;
            case "TSEnumBody":
              Qt(i, i.members, e);
              break;
            default:
              Hr(i, r);
          }
        else
          Hr(i, r);
      }
    }
    finalizeRemainingComments() {
      let {
        commentStack: e
      } = this.state;
      for (let r = e.length - 1; r >= 0; r--)
        this.finalizeComment(e[r]);
      this.state.commentStack = [];
    }
    resetPreviousNodeTrailingComments(e) {
      let {
        commentStack: r
      } = this.state, {
        length: i
      } = r;
      if (i === 0) return;
      let n = r[i - 1];
      n.leadingNode === e && (n.leadingNode = null);
    }
    resetPreviousIdentifierLeadingComments(e) {
      let {
        commentStack: r
      } = this.state, {
        length: i
      } = r;
      i !== 0 && (r[i - 1].trailingNode === e ? r[i - 1].trailingNode = null : i >= 2 && r[i - 2].trailingNode === e && (r[i - 2].trailingNode =
      null));
    }
    takeSurroundingComments(e, r, i) {
      let {
        commentStack: n
      } = this.state, a = n.length;
      if (a === 0) return;
      let o = a - 1;
      for (; o >= 0; o--) {
        let l = n[o], u = l.end;
        if (l.start === i)
          l.leadingNode = e;
        else if (u === r)
          l.trailingNode = e;
        else if (u < r)
          break;
      }
    }
  }, V3 = /\r\n|[\r\n\u2028\u2029]/, Ji = new RegExp(V3.source, "g");
  function mr(t) {
    switch (t) {
      case 10:
      case 13:
      case 8232:
      case 8233:
        return !0;
      default:
        return !1;
    }
  }
  s(mr, "isNewLine");
  function $c(t, e, r) {
    for (let i = e; i < r; i++)
      if (mr(t.charCodeAt(i)))
        return !0;
    return !1;
  }
  s($c, "hasNewLine");
  var Xa = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, Wa = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g;
  function Y3(t) {
    switch (t) {
      case 9:
      case 11:
      case 12:
      case 32:
      case 160:
      case 5760:
      case 8192:
      case 8193:
      case 8194:
      case 8195:
      case 8196:
      case 8197:
      case 8198:
      case 8199:
      case 8200:
      case 8201:
      case 8202:
      case 8239:
      case 8287:
      case 12288:
      case 65279:
        return !0;
      default:
        return !1;
    }
  }
  s(Y3, "isWhitespace");
  var to = class t {
    static {
      s(this, "State");
    }
    constructor() {
      this.flags = 1024, this.startIndex = void 0, this.curLine = void 0, this.lineStart = void 0, this.startLoc = void 0, this.endLoc = void 0,
      this.errors = [], this.potentialArrowAt = -1, this.noArrowAt = [], this.noArrowParamsConversionAt = [], this.topicContext = {
        maxNumOfResolvableTopics: 0,
        maxTopicIndex: null
      }, this.labels = [], this.commentsLen = 0, this.commentStack = [], this.pos = 0, this.type = 140, this.value = null, this.start = 0, this.
      end = 0, this.lastTokEndLoc = null, this.lastTokStartLoc = null, this.context = [Ie.brace], this.firstInvalidTemplateEscapePos = null,
      this.strictErrors = /* @__PURE__ */ new Map(), this.tokensLength = 0;
    }
    get strict() {
      return (this.flags & 1) > 0;
    }
    set strict(e) {
      e ? this.flags |= 1 : this.flags &= -2;
    }
    init({
      strictMode: e,
      sourceType: r,
      startIndex: i,
      startLine: n,
      startColumn: a
    }) {
      this.strict = e === !1 ? !1 : e === !0 ? !0 : r === "module", this.startIndex = i, this.curLine = n, this.lineStart = -a, this.startLoc =
      this.endLoc = new Et(n, a, i);
    }
    get maybeInArrowParameters() {
      return (this.flags & 2) > 0;
    }
    set maybeInArrowParameters(e) {
      e ? this.flags |= 2 : this.flags &= -3;
    }
    get inType() {
      return (this.flags & 4) > 0;
    }
    set inType(e) {
      e ? this.flags |= 4 : this.flags &= -5;
    }
    get noAnonFunctionType() {
      return (this.flags & 8) > 0;
    }
    set noAnonFunctionType(e) {
      e ? this.flags |= 8 : this.flags &= -9;
    }
    get hasFlowComment() {
      return (this.flags & 16) > 0;
    }
    set hasFlowComment(e) {
      e ? this.flags |= 16 : this.flags &= -17;
    }
    get isAmbientContext() {
      return (this.flags & 32) > 0;
    }
    set isAmbientContext(e) {
      e ? this.flags |= 32 : this.flags &= -33;
    }
    get inAbstractClass() {
      return (this.flags & 64) > 0;
    }
    set inAbstractClass(e) {
      e ? this.flags |= 64 : this.flags &= -65;
    }
    get inDisallowConditionalTypesContext() {
      return (this.flags & 128) > 0;
    }
    set inDisallowConditionalTypesContext(e) {
      e ? this.flags |= 128 : this.flags &= -129;
    }
    get soloAwait() {
      return (this.flags & 256) > 0;
    }
    set soloAwait(e) {
      e ? this.flags |= 256 : this.flags &= -257;
    }
    get inFSharpPipelineDirectBody() {
      return (this.flags & 512) > 0;
    }
    set inFSharpPipelineDirectBody(e) {
      e ? this.flags |= 512 : this.flags &= -513;
    }
    get canStartJSXElement() {
      return (this.flags & 1024) > 0;
    }
    set canStartJSXElement(e) {
      e ? this.flags |= 1024 : this.flags &= -1025;
    }
    get containsEsc() {
      return (this.flags & 2048) > 0;
    }
    set containsEsc(e) {
      e ? this.flags |= 2048 : this.flags &= -2049;
    }
    get hasTopLevelAwait() {
      return (this.flags & 4096) > 0;
    }
    set hasTopLevelAwait(e) {
      e ? this.flags |= 4096 : this.flags &= -4097;
    }
    curPosition() {
      return new Et(this.curLine, this.pos - this.lineStart, this.pos + this.startIndex);
    }
    clone() {
      let e = new t();
      return e.flags = this.flags, e.startIndex = this.startIndex, e.curLine = this.curLine, e.lineStart = this.lineStart, e.startLoc = this.
      startLoc, e.endLoc = this.endLoc, e.errors = this.errors.slice(), e.potentialArrowAt = this.potentialArrowAt, e.noArrowAt = this.noArrowAt.
      slice(), e.noArrowParamsConversionAt = this.noArrowParamsConversionAt.slice(), e.topicContext = this.topicContext, e.labels = this.labels.
      slice(), e.commentsLen = this.commentsLen, e.commentStack = this.commentStack.slice(), e.pos = this.pos, e.type = this.type, e.value =
      this.value, e.start = this.start, e.end = this.end, e.lastTokEndLoc = this.lastTokEndLoc, e.lastTokStartLoc = this.lastTokStartLoc, e.
      context = this.context.slice(), e.firstInvalidTemplateEscapePos = this.firstInvalidTemplateEscapePos, e.strictErrors = this.strictErrors,
      e.tokensLength = this.tokensLength, e;
    }
  }, J3 = /* @__PURE__ */ s(function(e) {
    return e >= 48 && e <= 57;
  }, "isDigit"), Hc = {
    decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]),
    hex: /* @__PURE__ */ new Set([46, 88, 95, 120])
  }, Xi = {
    bin: /* @__PURE__ */ s((t) => t === 48 || t === 49, "bin"),
    oct: /* @__PURE__ */ s((t) => t >= 48 && t <= 55, "oct"),
    dec: /* @__PURE__ */ s((t) => t >= 48 && t <= 57, "dec"),
    hex: /* @__PURE__ */ s((t) => t >= 48 && t <= 57 || t >= 65 && t <= 70 || t >= 97 && t <= 102, "hex")
  };
  function Gc(t, e, r, i, n, a) {
    let o = r, l = i, u = n, p = "", m = null, g = r, {
      length: I
    } = e;
    for (; ; ) {
      if (r >= I) {
        a.unterminated(o, l, u), p += e.slice(g, r);
        break;
      }
      let v = e.charCodeAt(r);
      if (X3(t, v, e, r)) {
        p += e.slice(g, r);
        break;
      }
      if (v === 92) {
        p += e.slice(g, r);
        let _ = W3(e, r, i, n, t === "template", a);
        _.ch === null && !m ? m = {
          pos: r,
          lineStart: i,
          curLine: n
        } : p += _.ch, {
          pos: r,
          lineStart: i,
          curLine: n
        } = _, g = r;
      } else v === 8232 || v === 8233 ? (++r, ++n, i = r) : v === 10 || v === 13 ? t === "template" ? (p += e.slice(g, r) + `
`, ++r, v === 13 && e.charCodeAt(r) === 10 && ++r, ++n, g = i = r) : a.unterminated(o, l, u) : ++r;
    }
    return {
      pos: r,
      str: p,
      firstInvalidLoc: m,
      lineStart: i,
      curLine: n,
      containsInvalid: !!m
    };
  }
  s(Gc, "readStringContents");
  function X3(t, e, r, i) {
    return t === "template" ? e === 96 || e === 36 && r.charCodeAt(i + 1) === 123 : e === (t === "double" ? 34 : 39);
  }
  s(X3, "isStringEnd");
  function W3(t, e, r, i, n, a) {
    let o = !n;
    e++;
    let l = /* @__PURE__ */ s((p) => ({
      pos: e,
      ch: p,
      lineStart: r,
      curLine: i
    }), "res"), u = t.charCodeAt(e++);
    switch (u) {
      case 110:
        return l(`
`);
      case 114:
        return l("\r");
      case 120: {
        let p;
        return {
          code: p,
          pos: e
        } = ro(t, e, r, i, 2, !1, o, a), l(p === null ? null : String.fromCharCode(p));
      }
      case 117: {
        let p;
        return {
          code: p,
          pos: e
        } = dp(t, e, r, i, o, a), l(p === null ? null : String.fromCodePoint(p));
      }
      case 116:
        return l("	");
      case 98:
        return l("\b");
      case 118:
        return l("\v");
      case 102:
        return l("\f");
      case 13:
        t.charCodeAt(e) === 10 && ++e;
      case 10:
        r = e, ++i;
      case 8232:
      case 8233:
        return l("");
      case 56:
      case 57:
        if (n)
          return l(null);
        a.strictNumericEscape(e - 1, r, i);
      default:
        if (u >= 48 && u <= 55) {
          let p = e - 1, g = /^[0-7]+/.exec(t.slice(p, e + 2))[0], I = parseInt(g, 8);
          I > 255 && (g = g.slice(0, -1), I = parseInt(g, 8)), e += g.length - 1;
          let v = t.charCodeAt(e);
          if (g !== "0" || v === 56 || v === 57) {
            if (n)
              return l(null);
            a.strictNumericEscape(p, r, i);
          }
          return l(String.fromCharCode(I));
        }
        return l(String.fromCharCode(u));
    }
  }
  s(W3, "readEscapedChar");
  function ro(t, e, r, i, n, a, o, l) {
    let u = e, p;
    return {
      n: p,
      pos: e
    } = hp(t, e, r, i, 16, n, a, !1, l, !o), p === null && (o ? l.invalidEscapeSequence(u, r, i) : e = u - 1), {
      code: p,
      pos: e
    };
  }
  s(ro, "readHexChar");
  function hp(t, e, r, i, n, a, o, l, u, p) {
    let m = e, g = n === 16 ? Hc.hex : Hc.decBinOct, I = n === 16 ? Xi.hex : n === 10 ? Xi.dec : n === 8 ? Xi.oct : Xi.bin, v = !1, _ = 0;
    for (let V = 0, D = a ?? 1 / 0; V < D; ++V) {
      let L = t.charCodeAt(e), B;
      if (L === 95 && l !== "bail") {
        let fe = t.charCodeAt(e - 1), ee = t.charCodeAt(e + 1);
        if (l) {
          if (Number.isNaN(ee) || !I(ee) || g.has(fe) || g.has(ee)) {
            if (p) return {
              n: null,
              pos: e
            };
            u.unexpectedNumericSeparator(e, r, i);
          }
        } else {
          if (p) return {
            n: null,
            pos: e
          };
          u.numericSeparatorInEscapeSequence(e, r, i);
        }
        ++e;
        continue;
      }
      if (L >= 97 ? B = L - 97 + 10 : L >= 65 ? B = L - 65 + 10 : J3(L) ? B = L - 48 : B = 1 / 0, B >= n) {
        if (B <= 9 && p)
          return {
            n: null,
            pos: e
          };
        if (B <= 9 && u.invalidDigit(e, r, i, n))
          B = 0;
        else if (o)
          B = 0, v = !0;
        else
          break;
      }
      ++e, _ = _ * n + B;
    }
    return e === m || a != null && e - m !== a || v ? {
      n: null,
      pos: e
    } : {
      n: _,
      pos: e
    };
  }
  s(hp, "readInt");
  function dp(t, e, r, i, n, a) {
    let o = t.charCodeAt(e), l;
    if (o === 123) {
      if (++e, {
        code: l,
        pos: e
      } = ro(t, e, r, i, t.indexOf("}", e) - e, !0, n, a), ++e, l !== null && l > 1114111)
        if (n)
          a.invalidCodePoint(e, r, i);
        else
          return {
            code: null,
            pos: e
          };
    } else
      ({
        code: l,
        pos: e
      } = ro(t, e, r, i, 4, !1, n, a));
    return {
      code: l,
      pos: e
    };
  }
  s(dp, "readCodePoint");
  function Yr(t, e, r) {
    return new Et(r, t - e, t);
  }
  s(Yr, "buildPosition");
  var z3 = /* @__PURE__ */ new Set([103, 109, 115, 105, 121, 117, 100, 118]), Pt = class {
    static {
      s(this, "Token");
    }
    constructor(e) {
      let r = e.startIndex || 0;
      this.type = e.type, this.value = e.value, this.start = r + e.start, this.end = r + e.end, this.loc = new Tr(e.startLoc, e.endLoc);
    }
  }, io = class extends eo {
    static {
      s(this, "Tokenizer");
    }
    constructor(e, r) {
      super(), this.isLookahead = void 0, this.tokens = [], this.errorHandlers_readInt = {
        invalidDigit: /* @__PURE__ */ s((i, n, a, o) => this.optionFlags & 2048 ? (this.raise(P.InvalidDigit, Yr(i, n, a), {
          radix: o
        }), !0) : !1, "invalidDigit"),
        numericSeparatorInEscapeSequence: this.errorBuilder(P.NumericSeparatorInEscapeSequence),
        unexpectedNumericSeparator: this.errorBuilder(P.UnexpectedNumericSeparator)
      }, this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, {
        invalidEscapeSequence: this.errorBuilder(P.InvalidEscapeSequence),
        invalidCodePoint: this.errorBuilder(P.InvalidCodePoint)
      }), this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, {
        strictNumericEscape: /* @__PURE__ */ s((i, n, a) => {
          this.recordStrictModeErrors(P.StrictNumericEscape, Yr(i, n, a));
        }, "strictNumericEscape"),
        unterminated: /* @__PURE__ */ s((i, n, a) => {
          throw this.raise(P.UnterminatedString, Yr(i - 1, n, a));
        }, "unterminated")
      }), this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, {
        strictNumericEscape: this.errorBuilder(P.StrictNumericEscape),
        unterminated: /* @__PURE__ */ s((i, n, a) => {
          throw this.raise(P.UnterminatedTemplate, Yr(i, n, a));
        }, "unterminated")
      }), this.state = new to(), this.state.init(e), this.input = r, this.length = r.length, this.comments = [], this.isLookahead = !1;
    }
    pushToken(e) {
      this.tokens.length = this.state.tokensLength, this.tokens.push(e), ++this.state.tokensLength;
    }
    next() {
      this.checkKeywordEscapes(), this.optionFlags & 256 && this.pushToken(new Pt(this.state)), this.state.lastTokEndLoc = this.state.endLoc,
      this.state.lastTokStartLoc = this.state.startLoc, this.nextToken();
    }
    eat(e) {
      return this.match(e) ? (this.next(), !0) : !1;
    }
    match(e) {
      return this.state.type === e;
    }
    createLookaheadState(e) {
      return {
        pos: e.pos,
        value: null,
        type: e.type,
        start: e.start,
        end: e.end,
        context: [this.curContext()],
        inType: e.inType,
        startLoc: e.startLoc,
        lastTokEndLoc: e.lastTokEndLoc,
        curLine: e.curLine,
        lineStart: e.lineStart,
        curPosition: e.curPosition
      };
    }
    lookahead() {
      let e = this.state;
      this.state = this.createLookaheadState(e), this.isLookahead = !0, this.nextToken(), this.isLookahead = !1;
      let r = this.state;
      return this.state = e, r;
    }
    nextTokenStart() {
      return this.nextTokenStartSince(this.state.pos);
    }
    nextTokenStartSince(e) {
      return Xa.lastIndex = e, Xa.test(this.input) ? Xa.lastIndex : e;
    }
    lookaheadCharCode() {
      return this.input.charCodeAt(this.nextTokenStart());
    }
    nextTokenInLineStart() {
      return this.nextTokenInLineStartSince(this.state.pos);
    }
    nextTokenInLineStartSince(e) {
      return Wa.lastIndex = e, Wa.test(this.input) ? Wa.lastIndex : e;
    }
    lookaheadInLineCharCode() {
      return this.input.charCodeAt(this.nextTokenInLineStart());
    }
    codePointAtPos(e) {
      let r = this.input.charCodeAt(e);
      if ((r & 64512) === 55296 && ++e < this.input.length) {
        let i = this.input.charCodeAt(e);
        (i & 64512) === 56320 && (r = 65536 + ((r & 1023) << 10) + (i & 1023));
      }
      return r;
    }
    setStrict(e) {
      this.state.strict = e, e && (this.state.strictErrors.forEach(([r, i]) => this.raise(r, i)), this.state.strictErrors.clear());
    }
    curContext() {
      return this.state.context[this.state.context.length - 1];
    }
    nextToken() {
      if (this.skipSpace(), this.state.start = this.state.pos, this.isLookahead || (this.state.startLoc = this.state.curPosition()), this.state.
      pos >= this.length) {
        this.finishToken(140);
        return;
      }
      this.getTokenFromCode(this.codePointAtPos(this.state.pos));
    }
    skipBlockComment(e) {
      let r;
      this.isLookahead || (r = this.state.curPosition());
      let i = this.state.pos, n = this.input.indexOf(e, i + 2);
      if (n === -1)
        throw this.raise(P.UnterminatedComment, this.state.curPosition());
      for (this.state.pos = n + e.length, Ji.lastIndex = i + 2; Ji.test(this.input) && Ji.lastIndex <= n; )
        ++this.state.curLine, this.state.lineStart = Ji.lastIndex;
      if (this.isLookahead) return;
      let a = {
        type: "CommentBlock",
        value: this.input.slice(i + 2, n),
        start: this.sourceToOffsetPos(i),
        end: this.sourceToOffsetPos(n + e.length),
        loc: new Tr(r, this.state.curPosition())
      };
      return this.optionFlags & 256 && this.pushToken(a), a;
    }
    skipLineComment(e) {
      let r = this.state.pos, i;
      this.isLookahead || (i = this.state.curPosition());
      let n = this.input.charCodeAt(this.state.pos += e);
      if (this.state.pos < this.length)
        for (; !mr(n) && ++this.state.pos < this.length; )
          n = this.input.charCodeAt(this.state.pos);
      if (this.isLookahead) return;
      let a = this.state.pos, l = {
        type: "CommentLine",
        value: this.input.slice(r + e, a),
        start: this.sourceToOffsetPos(r),
        end: this.sourceToOffsetPos(a),
        loc: new Tr(i, this.state.curPosition())
      };
      return this.optionFlags & 256 && this.pushToken(l), l;
    }
    skipSpace() {
      let e = this.state.pos, r = this.optionFlags & 4096 ? [] : null;
      e: for (; this.state.pos < this.length; ) {
        let i = this.input.charCodeAt(this.state.pos);
        switch (i) {
          case 32:
          case 160:
          case 9:
            ++this.state.pos;
            break;
          case 13:
            this.input.charCodeAt(this.state.pos + 1) === 10 && ++this.state.pos;
          case 10:
          case 8232:
          case 8233:
            ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
            break;
          case 47:
            switch (this.input.charCodeAt(this.state.pos + 1)) {
              case 42: {
                let n = this.skipBlockComment("*/");
                n !== void 0 && (this.addComment(n), r?.push(n));
                break;
              }
              case 47: {
                let n = this.skipLineComment(2);
                n !== void 0 && (this.addComment(n), r?.push(n));
                break;
              }
              default:
                break e;
            }
            break;
          default:
            if (Y3(i))
              ++this.state.pos;
            else if (i === 45 && !this.inModule && this.optionFlags & 8192) {
              let n = this.state.pos;
              if (this.input.charCodeAt(n + 1) === 45 && this.input.charCodeAt(n + 2) === 62 && (e === 0 || this.state.lineStart > e)) {
                let a = this.skipLineComment(3);
                a !== void 0 && (this.addComment(a), r?.push(a));
              } else
                break e;
            } else if (i === 60 && !this.inModule && this.optionFlags & 8192) {
              let n = this.state.pos;
              if (this.input.charCodeAt(n + 1) === 33 && this.input.charCodeAt(n + 2) === 45 && this.input.charCodeAt(n + 3) === 45) {
                let a = this.skipLineComment(4);
                a !== void 0 && (this.addComment(a), r?.push(a));
              } else
                break e;
            } else
              break e;
        }
      }
      if (r?.length > 0) {
        let i = this.state.pos, n = {
          start: this.sourceToOffsetPos(e),
          end: this.sourceToOffsetPos(i),
          comments: r,
          leadingNode: null,
          trailingNode: null,
          containingNode: null
        };
        this.state.commentStack.push(n);
      }
    }
    finishToken(e, r) {
      this.state.end = this.state.pos, this.state.endLoc = this.state.curPosition();
      let i = this.state.type;
      this.state.type = e, this.state.value = r, this.isLookahead || this.updateContext(i);
    }
    replaceToken(e) {
      this.state.type = e, this.updateContext();
    }
    readToken_numberSign() {
      if (this.state.pos === 0 && this.readToken_interpreter())
        return;
      let e = this.state.pos + 1, r = this.codePointAtPos(e);
      if (r >= 48 && r <= 57)
        throw this.raise(P.UnexpectedDigitAfterHash, this.state.curPosition());
      if (r === 123 || r === 91 && this.hasPlugin("recordAndTuple")) {
        if (this.expectPlugin("recordAndTuple"), this.getPluginOption("recordAndTuple", "syntaxType") === "bar")
          throw this.raise(r === 123 ? P.RecordExpressionHashIncorrectStartSyntaxType : P.TupleExpressionHashIncorrectStartSyntaxType, this.
          state.curPosition());
        this.state.pos += 2, r === 123 ? this.finishToken(7) : this.finishToken(1);
      } else Ot(r) ? (++this.state.pos, this.finishToken(139, this.readWord1(r))) : r === 92 ? (++this.state.pos, this.finishToken(139, this.
      readWord1())) : this.finishOp(27, 1);
    }
    readToken_dot() {
      let e = this.input.charCodeAt(this.state.pos + 1);
      if (e >= 48 && e <= 57) {
        this.readNumber(!0);
        return;
      }
      e === 46 && this.input.charCodeAt(this.state.pos + 2) === 46 ? (this.state.pos += 3, this.finishToken(21)) : (++this.state.pos, this.finishToken(
      16));
    }
    readToken_slash() {
      this.input.charCodeAt(this.state.pos + 1) === 61 ? this.finishOp(31, 2) : this.finishOp(56, 1);
    }
    readToken_interpreter() {
      if (this.state.pos !== 0 || this.length < 2) return !1;
      let e = this.input.charCodeAt(this.state.pos + 1);
      if (e !== 33) return !1;
      let r = this.state.pos;
      for (this.state.pos += 1; !mr(e) && ++this.state.pos < this.length; )
        e = this.input.charCodeAt(this.state.pos);
      let i = this.input.slice(r + 2, this.state.pos);
      return this.finishToken(28, i), !0;
    }
    readToken_mult_modulo(e) {
      let r = e === 42 ? 55 : 54, i = 1, n = this.input.charCodeAt(this.state.pos + 1);
      e === 42 && n === 42 && (i++, n = this.input.charCodeAt(this.state.pos + 2), r = 57), n === 61 && !this.state.inType && (i++, r = e ===
      37 ? 33 : 30), this.finishOp(r, i);
    }
    readToken_pipe_amp(e) {
      let r = this.input.charCodeAt(this.state.pos + 1);
      if (r === e) {
        this.input.charCodeAt(this.state.pos + 2) === 61 ? this.finishOp(30, 3) : this.finishOp(e === 124 ? 41 : 42, 2);
        return;
      }
      if (e === 124) {
        if (r === 62) {
          this.finishOp(39, 2);
          return;
        }
        if (this.hasPlugin("recordAndTuple") && r === 125) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
            throw this.raise(P.RecordExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
          this.state.pos += 2, this.finishToken(9);
          return;
        }
        if (this.hasPlugin("recordAndTuple") && r === 93) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
            throw this.raise(P.TupleExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
          this.state.pos += 2, this.finishToken(4);
          return;
        }
      }
      if (r === 61) {
        this.finishOp(30, 2);
        return;
      }
      this.finishOp(e === 124 ? 43 : 45, 1);
    }
    readToken_caret() {
      let e = this.input.charCodeAt(this.state.pos + 1);
      e === 61 && !this.state.inType ? this.finishOp(32, 2) : e === 94 && this.hasPlugin(["pipelineOperator", {
        proposal: "hack",
        topicToken: "^^"
      }]) ? (this.finishOp(37, 2), this.input.codePointAt(this.state.pos) === 94 && this.unexpected()) : this.finishOp(44, 1);
    }
    readToken_atSign() {
      this.input.charCodeAt(this.state.pos + 1) === 64 && this.hasPlugin(["pipelineOperator", {
        proposal: "hack",
        topicToken: "@@"
      }]) ? this.finishOp(38, 2) : this.finishOp(26, 1);
    }
    readToken_plus_min(e) {
      let r = this.input.charCodeAt(this.state.pos + 1);
      if (r === e) {
        this.finishOp(34, 2);
        return;
      }
      r === 61 ? this.finishOp(30, 2) : this.finishOp(53, 1);
    }
    readToken_lt() {
      let {
        pos: e
      } = this.state, r = this.input.charCodeAt(e + 1);
      if (r === 60) {
        if (this.input.charCodeAt(e + 2) === 61) {
          this.finishOp(30, 3);
          return;
        }
        this.finishOp(51, 2);
        return;
      }
      if (r === 61) {
        this.finishOp(49, 2);
        return;
      }
      this.finishOp(47, 1);
    }
    readToken_gt() {
      let {
        pos: e
      } = this.state, r = this.input.charCodeAt(e + 1);
      if (r === 62) {
        let i = this.input.charCodeAt(e + 2) === 62 ? 3 : 2;
        if (this.input.charCodeAt(e + i) === 61) {
          this.finishOp(30, i + 1);
          return;
        }
        this.finishOp(52, i);
        return;
      }
      if (r === 61) {
        this.finishOp(49, 2);
        return;
      }
      this.finishOp(48, 1);
    }
    readToken_eq_excl(e) {
      let r = this.input.charCodeAt(this.state.pos + 1);
      if (r === 61) {
        this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
        return;
      }
      if (e === 61 && r === 62) {
        this.state.pos += 2, this.finishToken(19);
        return;
      }
      this.finishOp(e === 61 ? 29 : 35, 1);
    }
    readToken_question() {
      let e = this.input.charCodeAt(this.state.pos + 1), r = this.input.charCodeAt(this.state.pos + 2);
      e === 63 ? r === 61 ? this.finishOp(30, 3) : this.finishOp(40, 2) : e === 46 && !(r >= 48 && r <= 57) ? (this.state.pos += 2, this.finishToken(
      18)) : (++this.state.pos, this.finishToken(17));
    }
    getTokenFromCode(e) {
      switch (e) {
        case 46:
          this.readToken_dot();
          return;
        case 40:
          ++this.state.pos, this.finishToken(10);
          return;
        case 41:
          ++this.state.pos, this.finishToken(11);
          return;
        case 59:
          ++this.state.pos, this.finishToken(13);
          return;
        case 44:
          ++this.state.pos, this.finishToken(12);
          return;
        case 91:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
              throw this.raise(P.TupleExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
            this.state.pos += 2, this.finishToken(2);
          } else
            ++this.state.pos, this.finishToken(0);
          return;
        case 93:
          ++this.state.pos, this.finishToken(3);
          return;
        case 123:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
              throw this.raise(P.RecordExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
            this.state.pos += 2, this.finishToken(6);
          } else
            ++this.state.pos, this.finishToken(5);
          return;
        case 125:
          ++this.state.pos, this.finishToken(8);
          return;
        case 58:
          this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58 ? this.finishOp(15, 2) : (++this.state.pos, this.
          finishToken(14));
          return;
        case 63:
          this.readToken_question();
          return;
        case 96:
          this.readTemplateToken();
          return;
        case 48: {
          let r = this.input.charCodeAt(this.state.pos + 1);
          if (r === 120 || r === 88) {
            this.readRadixNumber(16);
            return;
          }
          if (r === 111 || r === 79) {
            this.readRadixNumber(8);
            return;
          }
          if (r === 98 || r === 66) {
            this.readRadixNumber(2);
            return;
          }
        }
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          this.readNumber(!1);
          return;
        case 34:
        case 39:
          this.readString(e);
          return;
        case 47:
          this.readToken_slash();
          return;
        case 37:
        case 42:
          this.readToken_mult_modulo(e);
          return;
        case 124:
        case 38:
          this.readToken_pipe_amp(e);
          return;
        case 94:
          this.readToken_caret();
          return;
        case 43:
        case 45:
          this.readToken_plus_min(e);
          return;
        case 60:
          this.readToken_lt();
          return;
        case 62:
          this.readToken_gt();
          return;
        case 61:
        case 33:
          this.readToken_eq_excl(e);
          return;
        case 126:
          this.finishOp(36, 1);
          return;
        case 64:
          this.readToken_atSign();
          return;
        case 35:
          this.readToken_numberSign();
          return;
        case 92:
          this.readWord();
          return;
        default:
          if (Ot(e)) {
            this.readWord(e);
            return;
          }
      }
      throw this.raise(P.InvalidOrUnexpectedToken, this.state.curPosition(), {
        unexpected: String.fromCodePoint(e)
      });
    }
    finishOp(e, r) {
      let i = this.input.slice(this.state.pos, this.state.pos + r);
      this.state.pos += r, this.finishToken(e, i);
    }
    readRegexp() {
      let e = this.state.startLoc, r = this.state.start + 1, i, n, {
        pos: a
      } = this.state;
      for (; ; ++a) {
        if (a >= this.length)
          throw this.raise(P.UnterminatedRegExp, Ze(e, 1));
        let p = this.input.charCodeAt(a);
        if (mr(p))
          throw this.raise(P.UnterminatedRegExp, Ze(e, 1));
        if (i)
          i = !1;
        else {
          if (p === 91)
            n = !0;
          else if (p === 93 && n)
            n = !1;
          else if (p === 47 && !n)
            break;
          i = p === 92;
        }
      }
      let o = this.input.slice(r, a);
      ++a;
      let l = "", u = /* @__PURE__ */ s(() => Ze(e, a + 2 - r), "nextPos");
      for (; a < this.length; ) {
        let p = this.codePointAtPos(a), m = String.fromCharCode(p);
        if (z3.has(p))
          p === 118 ? l.includes("u") && this.raise(P.IncompatibleRegExpUVFlags, u()) : p === 117 && l.includes("v") && this.raise(P.IncompatibleRegExpUVFlags,
          u()), l.includes(m) && this.raise(P.DuplicateRegExpFlags, u());
        else if (dr(p) || p === 92)
          this.raise(P.MalformedRegExpFlags, u());
        else
          break;
        ++a, l += m;
      }
      this.state.pos = a, this.finishToken(138, {
        pattern: o,
        flags: l
      });
    }
    readInt(e, r, i = !1, n = !0) {
      let {
        n: a,
        pos: o
      } = hp(this.input, this.state.pos, this.state.lineStart, this.state.curLine, e, r, i, n, this.errorHandlers_readInt, !1);
      return this.state.pos = o, a;
    }
    readRadixNumber(e) {
      let r = this.state.pos, i = this.state.curPosition(), n = !1;
      this.state.pos += 2;
      let a = this.readInt(e);
      a == null && this.raise(P.InvalidDigit, Ze(i, 2), {
        radix: e
      });
      let o = this.input.charCodeAt(this.state.pos);
      if (o === 110)
        ++this.state.pos, n = !0;
      else if (o === 109)
        throw this.raise(P.InvalidDecimal, i);
      if (Ot(this.codePointAtPos(this.state.pos)))
        throw this.raise(P.NumberIdentifier, this.state.curPosition());
      if (n) {
        let l = this.input.slice(r, this.state.pos).replace(/[_n]/g, "");
        this.finishToken(136, l);
        return;
      }
      this.finishToken(135, a);
    }
    readNumber(e) {
      let r = this.state.pos, i = this.state.curPosition(), n = !1, a = !1, o = !1, l = !1;
      !e && this.readInt(10) === null && this.raise(P.InvalidNumber, this.state.curPosition());
      let u = this.state.pos - r >= 2 && this.input.charCodeAt(r) === 48;
      if (u) {
        let v = this.input.slice(r, this.state.pos);
        if (this.recordStrictModeErrors(P.StrictOctalLiteral, i), !this.state.strict) {
          let _ = v.indexOf("_");
          _ > 0 && this.raise(P.ZeroDigitNumericSeparator, Ze(i, _));
        }
        l = u && !/[89]/.test(v);
      }
      let p = this.input.charCodeAt(this.state.pos);
      if (p === 46 && !l && (++this.state.pos, this.readInt(10), n = !0, p = this.input.charCodeAt(this.state.pos)), (p === 69 || p === 101) &&
      !l && (p = this.input.charCodeAt(++this.state.pos), (p === 43 || p === 45) && ++this.state.pos, this.readInt(10) === null && this.raise(
      P.InvalidOrMissingExponent, i), n = !0, o = !0, p = this.input.charCodeAt(this.state.pos)), p === 110 && ((n || u) && this.raise(P.InvalidBigIntLiteral,
      i), ++this.state.pos, a = !0), p === 109) {
        this.expectPlugin("decimal", this.state.curPosition()), (o || u) && this.raise(P.InvalidDecimal, i), ++this.state.pos;
        var m = !0;
      }
      if (Ot(this.codePointAtPos(this.state.pos)))
        throw this.raise(P.NumberIdentifier, this.state.curPosition());
      let g = this.input.slice(r, this.state.pos).replace(/[_mn]/g, "");
      if (a) {
        this.finishToken(136, g);
        return;
      }
      if (m) {
        this.finishToken(137, g);
        return;
      }
      let I = l ? parseInt(g, 8) : parseFloat(g);
      this.finishToken(135, I);
    }
    readCodePoint(e) {
      let {
        code: r,
        pos: i
      } = dp(this.input, this.state.pos, this.state.lineStart, this.state.curLine, e, this.errorHandlers_readCodePoint);
      return this.state.pos = i, r;
    }
    readString(e) {
      let {
        str: r,
        pos: i,
        curLine: n,
        lineStart: a
      } = Gc(e === 34 ? "double" : "single", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);
      this.state.pos = i + 1, this.state.lineStart = a, this.state.curLine = n, this.finishToken(134, r);
    }
    readTemplateContinuation() {
      this.match(8) || this.unexpected(null, 8), this.state.pos--, this.readTemplateToken();
    }
    readTemplateToken() {
      let e = this.input[this.state.pos], {
        str: r,
        firstInvalidLoc: i,
        pos: n,
        curLine: a,
        lineStart: o
      } = Gc("template", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);
      this.state.pos = n + 1, this.state.lineStart = o, this.state.curLine = a, i && (this.state.firstInvalidTemplateEscapePos = new Et(i.curLine,
      i.pos - i.lineStart, this.sourceToOffsetPos(i.pos))), this.input.codePointAt(n) === 96 ? this.finishToken(24, i ? null : e + r + "`") :
      (this.state.pos++, this.finishToken(25, i ? null : e + r + "${"));
    }
    recordStrictModeErrors(e, r) {
      let i = r.index;
      this.state.strict && !this.state.strictErrors.has(i) ? this.raise(e, r) : this.state.strictErrors.set(i, [e, r]);
    }
    readWord1(e) {
      this.state.containsEsc = !1;
      let r = "", i = this.state.pos, n = this.state.pos;
      for (e !== void 0 && (this.state.pos += e <= 65535 ? 1 : 2); this.state.pos < this.length; ) {
        let a = this.codePointAtPos(this.state.pos);
        if (dr(a))
          this.state.pos += a <= 65535 ? 1 : 2;
        else if (a === 92) {
          this.state.containsEsc = !0, r += this.input.slice(n, this.state.pos);
          let o = this.state.curPosition(), l = this.state.pos === i ? Ot : dr;
          if (this.input.charCodeAt(++this.state.pos) !== 117) {
            this.raise(P.MissingUnicodeEscape, this.state.curPosition()), n = this.state.pos - 1;
            continue;
          }
          ++this.state.pos;
          let u = this.readCodePoint(!0);
          u !== null && (l(u) || this.raise(P.EscapedCharNotAnIdentifier, o), r += String.fromCodePoint(u)), n = this.state.pos;
        } else
          break;
      }
      return r + this.input.slice(n, this.state.pos);
    }
    readWord(e) {
      let r = this.readWord1(e), i = yo.get(r);
      i !== void 0 ? this.finishToken(i, Kt(i)) : this.finishToken(132, r);
    }
    checkKeywordEscapes() {
      let {
        type: e
      } = this.state;
      Eo(e) && this.state.containsEsc && this.raise(P.InvalidEscapedReservedWord, this.state.startLoc, {
        reservedWord: Kt(e)
      });
    }
    raise(e, r, i = {}) {
      let n = r instanceof Et ? r : r.loc.start, a = e(n, i);
      if (!(this.optionFlags & 2048)) throw a;
      return this.isLookahead || this.state.errors.push(a), a;
    }
    raiseOverwrite(e, r, i = {}) {
      let n = r instanceof Et ? r : r.loc.start, a = n.index, o = this.state.errors;
      for (let l = o.length - 1; l >= 0; l--) {
        let u = o[l];
        if (u.loc.index === a)
          return o[l] = e(n, i);
        if (u.loc.index < a) break;
      }
      return this.raise(e, r, i);
    }
    updateContext(e) {
    }
    unexpected(e, r) {
      throw this.raise(P.UnexpectedToken, e ?? this.state.startLoc, {
        expected: r ? Kt(r) : null
      });
    }
    expectPlugin(e, r) {
      if (this.hasPlugin(e))
        return !0;
      throw this.raise(P.MissingPlugin, r ?? this.state.startLoc, {
        missingPlugin: [e]
      });
    }
    expectOnePlugin(e) {
      if (!e.some((r) => this.hasPlugin(r)))
        throw this.raise(P.MissingOneOfPlugins, this.state.startLoc, {
          missingPlugin: e
        });
    }
    errorBuilder(e) {
      return (r, i, n) => {
        this.raise(e, Yr(r, i, n));
      };
    }
  }, so = class {
    static {
      s(this, "ClassScope");
    }
    constructor() {
      this.privateNames = /* @__PURE__ */ new Set(), this.loneAccessors = /* @__PURE__ */ new Map(), this.undefinedPrivateNames = /* @__PURE__ */ new Map();
    }
  }, no = class {
    static {
      s(this, "ClassScopeHandler");
    }
    constructor(e) {
      this.parser = void 0, this.stack = [], this.undefinedPrivateNames = /* @__PURE__ */ new Map(), this.parser = e;
    }
    current() {
      return this.stack[this.stack.length - 1];
    }
    enter() {
      this.stack.push(new so());
    }
    exit() {
      let e = this.stack.pop(), r = this.current();
      for (let [i, n] of Array.from(e.undefinedPrivateNames))
        r ? r.undefinedPrivateNames.has(i) || r.undefinedPrivateNames.set(i, n) : this.parser.raise(P.InvalidPrivateFieldResolution, n, {
          identifierName: i
        });
    }
    declarePrivateName(e, r, i) {
      let {
        privateNames: n,
        loneAccessors: a,
        undefinedPrivateNames: o
      } = this.current(), l = n.has(e);
      if (r & 3) {
        let u = l && a.get(e);
        if (u) {
          let p = u & 4, m = r & 4, g = u & 3, I = r & 3;
          l = g === I || p !== m, l || a.delete(e);
        } else l || a.set(e, r);
      }
      l && this.parser.raise(P.PrivateNameRedeclaration, i, {
        identifierName: e
      }), n.add(e), o.delete(e);
    }
    usePrivateName(e, r) {
      let i;
      for (i of this.stack)
        if (i.privateNames.has(e)) return;
      i ? i.undefinedPrivateNames.set(e, r) : this.parser.raise(P.InvalidPrivateFieldResolution, r, {
        identifierName: e
      });
    }
  }, Sr = class {
    static {
      s(this, "ExpressionScope");
    }
    constructor(e = 0) {
      this.type = e;
    }
    canBeArrowParameterDeclaration() {
      return this.type === 2 || this.type === 1;
    }
    isCertainlyParameterDeclaration() {
      return this.type === 3;
    }
  }, Qi = class extends Sr {
    static {
      s(this, "ArrowHeadParsingScope");
    }
    constructor(e) {
      super(e), this.declarationErrors = /* @__PURE__ */ new Map();
    }
    recordDeclarationError(e, r) {
      let i = r.index;
      this.declarationErrors.set(i, [e, r]);
    }
    clearDeclarationError(e) {
      this.declarationErrors.delete(e);
    }
    iterateErrors(e) {
      this.declarationErrors.forEach(e);
    }
  }, ao = class {
    static {
      s(this, "ExpressionScopeHandler");
    }
    constructor(e) {
      this.parser = void 0, this.stack = [new Sr()], this.parser = e;
    }
    enter(e) {
      this.stack.push(e);
    }
    exit() {
      this.stack.pop();
    }
    recordParameterInitializerError(e, r) {
      let i = r.loc.start, {
        stack: n
      } = this, a = n.length - 1, o = n[a];
      for (; !o.isCertainlyParameterDeclaration(); ) {
        if (o.canBeArrowParameterDeclaration())
          o.recordDeclarationError(e, i);
        else
          return;
        o = n[--a];
      }
      this.parser.raise(e, i);
    }
    recordArrowParameterBindingError(e, r) {
      let {
        stack: i
      } = this, n = i[i.length - 1], a = r.loc.start;
      if (n.isCertainlyParameterDeclaration())
        this.parser.raise(e, a);
      else if (n.canBeArrowParameterDeclaration())
        n.recordDeclarationError(e, a);
      else
        return;
    }
    recordAsyncArrowParametersError(e) {
      let {
        stack: r
      } = this, i = r.length - 1, n = r[i];
      for (; n.canBeArrowParameterDeclaration(); )
        n.type === 2 && n.recordDeclarationError(P.AwaitBindingIdentifier, e), n = r[--i];
    }
    validateAsPattern() {
      let {
        stack: e
      } = this, r = e[e.length - 1];
      r.canBeArrowParameterDeclaration() && r.iterateErrors(([i, n]) => {
        this.parser.raise(i, n);
        let a = e.length - 2, o = e[a];
        for (; o.canBeArrowParameterDeclaration(); )
          o.clearDeclarationError(n.index), o = e[--a];
      });
    }
  };
  function $3() {
    return new Sr(3);
  }
  s($3, "newParameterDeclarationScope");
  function H3() {
    return new Qi(1);
  }
  s(H3, "newArrowHeadScope");
  function G3() {
    return new Qi(2);
  }
  s(G3, "newAsyncArrowScope");
  function mp() {
    return new Sr();
  }
  s(mp, "newExpressionScope");
  var oo = class {
    static {
      s(this, "ProductionParameterHandler");
    }
    constructor() {
      this.stacks = [];
    }
    enter(e) {
      this.stacks.push(e);
    }
    exit() {
      this.stacks.pop();
    }
    currentFlags() {
      return this.stacks[this.stacks.length - 1];
    }
    get hasAwait() {
      return (this.currentFlags() & 2) > 0;
    }
    get hasYield() {
      return (this.currentFlags() & 1) > 0;
    }
    get hasReturn() {
      return (this.currentFlags() & 4) > 0;
    }
    get hasIn() {
      return (this.currentFlags() & 8) > 0;
    }
  };
  function $i(t, e) {
    return (t ? 2 : 0) | (e ? 1 : 0);
  }
  s($i, "functionFlags");
  var lo = class extends io {
    static {
      s(this, "UtilParser");
    }
    addExtra(e, r, i, n = !0) {
      if (!e) return;
      let {
        extra: a
      } = e;
      a == null && (a = {}, e.extra = a), n ? a[r] = i : Object.defineProperty(a, r, {
        enumerable: n,
        value: i
      });
    }
    isContextual(e) {
      return this.state.type === e && !this.state.containsEsc;
    }
    isUnparsedContextual(e, r) {
      let i = e + r.length;
      if (this.input.slice(e, i) === r) {
        let n = this.input.charCodeAt(i);
        return !(dr(n) || (n & 64512) === 55296);
      }
      return !1;
    }
    isLookaheadContextual(e) {
      let r = this.nextTokenStart();
      return this.isUnparsedContextual(r, e);
    }
    eatContextual(e) {
      return this.isContextual(e) ? (this.next(), !0) : !1;
    }
    expectContextual(e, r) {
      if (!this.eatContextual(e)) {
        if (r != null)
          throw this.raise(r, this.state.startLoc);
        this.unexpected(null, e);
      }
    }
    canInsertSemicolon() {
      return this.match(140) || this.match(8) || this.hasPrecedingLineBreak();
    }
    hasPrecedingLineBreak() {
      return $c(this.input, this.offsetToSourcePos(this.state.lastTokEndLoc.index), this.state.start);
    }
    hasFollowingLineBreak() {
      return $c(this.input, this.state.end, this.nextTokenStart());
    }
    isLineTerminator() {
      return this.eat(13) || this.canInsertSemicolon();
    }
    semicolon(e = !0) {
      (e ? this.isLineTerminator() : this.eat(13)) || this.raise(P.MissingSemicolon, this.state.lastTokEndLoc);
    }
    expect(e, r) {
      this.eat(e) || this.unexpected(r, e);
    }
    tryParse(e, r = this.state.clone()) {
      let i = {
        node: null
      };
      try {
        let n = e((a = null) => {
          throw i.node = a, i;
        });
        if (this.state.errors.length > r.errors.length) {
          let a = this.state;
          return this.state = r, this.state.tokensLength = a.tokensLength, {
            node: n,
            error: a.errors[r.errors.length],
            thrown: !1,
            aborted: !1,
            failState: a
          };
        }
        return {
          node: n,
          error: null,
          thrown: !1,
          aborted: !1,
          failState: null
        };
      } catch (n) {
        let a = this.state;
        if (this.state = r, n instanceof SyntaxError)
          return {
            node: null,
            error: n,
            thrown: !0,
            aborted: !1,
            failState: a
          };
        if (n === i)
          return {
            node: i.node,
            error: null,
            thrown: !1,
            aborted: !0,
            failState: a
          };
        throw n;
      }
    }
    checkExpressionErrors(e, r) {
      if (!e) return !1;
      let {
        shorthandAssignLoc: i,
        doubleProtoLoc: n,
        privateKeyLoc: a,
        optionalParametersLoc: o
      } = e, l = !!i || !!n || !!o || !!a;
      if (!r)
        return l;
      i != null && this.raise(P.InvalidCoverInitializedName, i), n != null && this.raise(P.DuplicateProto, n), a != null && this.raise(P.UnexpectedPrivateField,
      a), o != null && this.unexpected(o);
    }
    isLiteralPropertyName() {
      return np(this.state.type);
    }
    isPrivateName(e) {
      return e.type === "PrivateName";
    }
    getPrivateNameSV(e) {
      return e.id.name;
    }
    hasPropertyAsPrivateName(e) {
      return (e.type === "MemberExpression" || e.type === "OptionalMemberExpression") && this.isPrivateName(e.property);
    }
    isObjectProperty(e) {
      return e.type === "ObjectProperty";
    }
    isObjectMethod(e) {
      return e.type === "ObjectMethod";
    }
    initializeScopes(e = this.options.sourceType === "module") {
      let r = this.state.labels;
      this.state.labels = [];
      let i = this.exportedIdentifiers;
      this.exportedIdentifiers = /* @__PURE__ */ new Set();
      let n = this.inModule;
      this.inModule = e;
      let a = this.scope, o = this.getScopeHandler();
      this.scope = new o(this, e);
      let l = this.prodParam;
      this.prodParam = new oo();
      let u = this.classScope;
      this.classScope = new no(this);
      let p = this.expressionScope;
      return this.expressionScope = new ao(this), () => {
        this.state.labels = r, this.exportedIdentifiers = i, this.inModule = n, this.scope = a, this.prodParam = l, this.classScope = u, this.
        expressionScope = p;
      };
    }
    enterInitialScopes() {
      let e = 0;
      this.inModule && (e |= 2), this.optionFlags & 32 && (e |= 1), this.scope.enter(1), this.prodParam.enter(e);
    }
    checkDestructuringPrivate(e) {
      let {
        privateKeyLoc: r
      } = e;
      r !== null && this.expectPlugin("destructuringPrivate", r);
    }
  }, yr = class {
    static {
      s(this, "ExpressionErrors");
    }
    constructor() {
      this.shorthandAssignLoc = null, this.doubleProtoLoc = null, this.privateKeyLoc = null, this.optionalParametersLoc = null;
    }
  }, br = class {
    static {
      s(this, "Node");
    }
    constructor(e, r, i) {
      this.type = "", this.start = r, this.end = 0, this.loc = new Tr(i), e?.optionFlags & 128 && (this.range = [r, 0]), e != null && e.filename &&
      (this.loc.filename = e.filename);
    }
  }, Io = br.prototype;
  Io.__clone = function() {
    let t = new br(void 0, this.start, this.loc.start), e = Object.keys(this);
    for (let r = 0, i = e.length; r < i; r++) {
      let n = e[r];
      n !== "leadingComments" && n !== "trailingComments" && n !== "innerComments" && (t[n] = this[n]);
    }
    return t;
  };
  function Q3(t) {
    return Dt(t);
  }
  s(Q3, "clonePlaceholder");
  function Dt(t) {
    let {
      type: e,
      start: r,
      end: i,
      loc: n,
      range: a,
      extra: o,
      name: l
    } = t, u = Object.create(Io);
    return u.type = e, u.start = r, u.end = i, u.loc = n, u.range = a, u.extra = o, u.name = l, e === "Placeholder" && (u.expectedNode = t.expectedNode),
    u;
  }
  s(Dt, "cloneIdentifier");
  function Z3(t) {
    let {
      type: e,
      start: r,
      end: i,
      loc: n,
      range: a,
      extra: o
    } = t;
    if (e === "Placeholder")
      return Q3(t);
    let l = Object.create(Io);
    return l.type = e, l.start = r, l.end = i, l.loc = n, l.range = a, t.raw !== void 0 ? l.raw = t.raw : l.extra = o, l.value = t.value, l;
  }
  s(Z3, "cloneStringLiteral");
  var uo = class extends lo {
    static {
      s(this, "NodeUtils");
    }
    startNode() {
      let e = this.state.startLoc;
      return new br(this, e.index, e);
    }
    startNodeAt(e) {
      return new br(this, e.index, e);
    }
    startNodeAtNode(e) {
      return this.startNodeAt(e.loc.start);
    }
    finishNode(e, r) {
      return this.finishNodeAt(e, r, this.state.lastTokEndLoc);
    }
    finishNodeAt(e, r, i) {
      return e.type = r, e.end = i.index, e.loc.end = i, this.optionFlags & 128 && (e.range[1] = i.index), this.optionFlags & 4096 && this.processComment(
      e), e;
    }
    resetStartLocation(e, r) {
      e.start = r.index, e.loc.start = r, this.optionFlags & 128 && (e.range[0] = r.index);
    }
    resetEndLocation(e, r = this.state.lastTokEndLoc) {
      e.end = r.index, e.loc.end = r, this.optionFlags & 128 && (e.range[1] = r.index);
    }
    resetStartLocationFromNode(e, r) {
      this.resetStartLocation(e, r.loc.start);
    }
  }, eB = /* @__PURE__ */ new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "stat\
ic", "string", "true", "typeof", "void"]), se = _t`flow`({
    AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",
    AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since \
they are either an ES module or they are a CommonJS module.",
    AssignReservedType: /* @__PURE__ */ s(({
      reservedType: t
    }) => `Cannot overwrite reserved type ${t}.`, "AssignReservedType"),
    DeclareClassElement: "The `declare` modifier can only appear on class fields.",
    DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.",
    DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.",
    EnumBooleanMemberNotInitialized: /* @__PURE__ */ s(({
      memberName: t,
      enumName: e
    }) => `Boolean enum members need to be initialized. Use either \`${t} = true,\` or \`${t} = false,\` in enum \`${e}\`.`, "EnumBooleanMem\
berNotInitialized"),
    EnumDuplicateMemberName: /* @__PURE__ */ s(({
      memberName: t,
      enumName: e
    }) => `Enum member names need to be unique, but the name \`${t}\` has already been used before in enum \`${e}\`.`, "EnumDuplicateMemberN\
ame"),
    EnumInconsistentMemberValues: /* @__PURE__ */ s(({
      enumName: t
    }) => `Enum \`${t}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, num\
bers, or strings) for all member initializers.`, "EnumInconsistentMemberValues"),
    EnumInvalidExplicitType: /* @__PURE__ */ s(({
      invalidEnumType: t,
      enumName: e
    }) => `Enum type \`${t}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${e}\`.`, "EnumInvalidEx\
plicitType"),
    EnumInvalidExplicitTypeUnknownSupplied: /* @__PURE__ */ s(({
      enumName: t
    }) => `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${t}\`.`, "EnumInvalidEx\
plicitTypeUnknownSupplied"),
    EnumInvalidMemberInitializerPrimaryType: /* @__PURE__ */ s(({
      enumName: t,
      memberName: e,
      explicitType: r
    }) => `Enum \`${t}\` has type \`${r}\`, so the initializer of \`${e}\` needs to be a ${r} literal.`, "EnumInvalidMemberInitializerPrimar\
yType"),
    EnumInvalidMemberInitializerSymbolType: /* @__PURE__ */ s(({
      enumName: t,
      memberName: e
    }) => `Symbol enum members cannot be initialized. Use \`${e},\` in enum \`${t}\`.`, "EnumInvalidMemberInitializerSymbolType"),
    EnumInvalidMemberInitializerUnknownType: /* @__PURE__ */ s(({
      enumName: t,
      memberName: e
    }) => `The enum member initializer for \`${e}\` needs to be a literal (either a boolean, number, or string) in enum \`${t}\`.`, "EnumInv\
alidMemberInitializerUnknownType"),
    EnumInvalidMemberName: /* @__PURE__ */ s(({
      enumName: t,
      memberName: e,
      suggestion: r
    }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${e}\`, consider using \`${r}\`, in enum \`${t}\
\`.`, "EnumInvalidMemberName"),
    EnumNumberMemberNotInitialized: /* @__PURE__ */ s(({
      enumName: t,
      memberName: e
    }) => `Number enum members need to be initialized, e.g. \`${e} = 1\` in enum \`${t}\`.`, "EnumNumberMemberNotInitialized"),
    EnumStringMemberInconsistentlyInitialized: /* @__PURE__ */ s(({
      enumName: t
    }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${t}\`.`, "EnumStringMemb\
erInconsistentlyInitialized"),
    GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.",
    ImportReflectionHasImportType: "An `import module` declaration can not use `type` or `typeof` keyword.",
    ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements.\
 It cannot be used with `import type` or `import typeof` statements.",
    InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.",
    InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.",
    InexactVariance: "Explicit inexact syntax cannot have variance.",
    InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.",
    MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",
    NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.",
    NestedFlowComment: "Cannot have a flow comment inside another flow comment.",
    PatternIsOptional: Object.assign({
      message: "A binding pattern parameter cannot be optional in an implementation signature."
    }, {
      reasonCode: "OptionalBindingPattern"
    }),
    SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.",
    SpreadVariance: "Spread properties cannot have variance.",
    ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.",
    ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.",
    ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.",
    ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.",
    ThisParamNoDefault: "The `this` parameter may not have a default value.",
    TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`\
.",
    TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.",
    UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.",
    UnexpectedReservedType: /* @__PURE__ */ s(({
      reservedType: t
    }) => `Unexpected reserved type ${t}.`, "UnexpectedReservedType"),
    UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.",
    UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.",
    UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.",
    UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".',
    UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.",
    UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}\
`, use `async <T>() => {}`.",
    UnsupportedDeclareExportKind: /* @__PURE__ */ s(({
      unsupportedExportKind: t,
      suggestion: e
    }) => `\`declare export ${t}\` is not supported. Use \`${e}\` instead.`, "UnsupportedDeclareExportKind"),
    UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.",
    UnterminatedFlowComment: "Unterminated flow-comment."
  });
  function tB(t) {
    return t.type === "DeclareExportAllDeclaration" || t.type === "DeclareExportDeclaration" && (!t.declaration || t.declaration.type !== "T\
ypeAlias" && t.declaration.type !== "InterfaceDeclaration");
  }
  s(tB, "isEsModuleType");
  function Qc(t) {
    return t.importKind === "type" || t.importKind === "typeof";
  }
  s(Qc, "hasTypeImportKind");
  var rB = {
    const: "declare export var",
    let: "declare export var",
    type: "export type",
    interface: "export interface"
  };
  function iB(t, e) {
    let r = [], i = [];
    for (let n = 0; n < t.length; n++)
      (e(t[n], n, t) ? r : i).push(t[n]);
    return [r, i];
  }
  s(iB, "partition");
  var sB = /\*?\s*@((?:no)?flow)\b/, nB = /* @__PURE__ */ s((t) => class extends t {
    static {
      s(this, "FlowParserMixin");
    }
    constructor(...r) {
      super(...r), this.flowPragma = void 0;
    }
    getScopeHandler() {
      return Qa;
    }
    shouldParseTypes() {
      return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
    }
    finishToken(r, i) {
      r !== 134 && r !== 13 && r !== 28 && this.flowPragma === void 0 && (this.flowPragma = null), super.finishToken(r, i);
    }
    addComment(r) {
      if (this.flowPragma === void 0) {
        let i = sB.exec(r.value);
        if (i) if (i[1] === "flow")
          this.flowPragma = "flow";
        else if (i[1] === "noflow")
          this.flowPragma = "noflow";
        else
          throw new Error("Unexpected flow pragma");
      }
      super.addComment(r);
    }
    flowParseTypeInitialiser(r) {
      let i = this.state.inType;
      this.state.inType = !0, this.expect(r || 14);
      let n = this.flowParseType();
      return this.state.inType = i, n;
    }
    flowParsePredicate() {
      let r = this.startNode(), i = this.state.startLoc;
      return this.next(), this.expectContextual(110), this.state.lastTokStartLoc.index > i.index + 1 && this.raise(se.UnexpectedSpaceBetweenModuloChecks,
      i), this.eat(10) ? (r.value = super.parseExpression(), this.expect(11), this.finishNode(r, "DeclaredPredicate")) : this.finishNode(r, "\
InferredPredicate");
    }
    flowParseTypeAndPredicateInitialiser() {
      let r = this.state.inType;
      this.state.inType = !0, this.expect(14);
      let i = null, n = null;
      return this.match(54) ? (this.state.inType = r, n = this.flowParsePredicate()) : (i = this.flowParseType(), this.state.inType = r, this.
      match(54) && (n = this.flowParsePredicate())), [i, n];
    }
    flowParseDeclareClass(r) {
      return this.next(), this.flowParseInterfaceish(r, !0), this.finishNode(r, "DeclareClass");
    }
    flowParseDeclareFunction(r) {
      this.next();
      let i = r.id = this.parseIdentifier(), n = this.startNode(), a = this.startNode();
      this.match(47) ? n.typeParameters = this.flowParseTypeParameterDeclaration() : n.typeParameters = null, this.expect(10);
      let o = this.flowParseFunctionTypeParams();
      return n.params = o.params, n.rest = o.rest, n.this = o._this, this.expect(11), [n.returnType, r.predicate] = this.flowParseTypeAndPredicateInitialiser(),
      a.typeAnnotation = this.finishNode(n, "FunctionTypeAnnotation"), i.typeAnnotation = this.finishNode(a, "TypeAnnotation"), this.resetEndLocation(
      i), this.semicolon(), this.scope.declareName(r.id.name, 2048, r.id.loc.start), this.finishNode(r, "DeclareFunction");
    }
    flowParseDeclare(r, i) {
      if (this.match(80))
        return this.flowParseDeclareClass(r);
      if (this.match(68))
        return this.flowParseDeclareFunction(r);
      if (this.match(74))
        return this.flowParseDeclareVariable(r);
      if (this.eatContextual(127))
        return this.match(16) ? this.flowParseDeclareModuleExports(r) : (i && this.raise(se.NestedDeclareModule, this.state.lastTokStartLoc),
        this.flowParseDeclareModule(r));
      if (this.isContextual(130))
        return this.flowParseDeclareTypeAlias(r);
      if (this.isContextual(131))
        return this.flowParseDeclareOpaqueType(r);
      if (this.isContextual(129))
        return this.flowParseDeclareInterface(r);
      if (this.match(82))
        return this.flowParseDeclareExportDeclaration(r, i);
      this.unexpected();
    }
    flowParseDeclareVariable(r) {
      return this.next(), r.id = this.flowParseTypeAnnotatableIdentifier(!0), this.scope.declareName(r.id.name, 5, r.id.loc.start), this.semicolon(),
      this.finishNode(r, "DeclareVariable");
    }
    flowParseDeclareModule(r) {
      this.scope.enter(0), this.match(134) ? r.id = super.parseExprAtom() : r.id = this.parseIdentifier();
      let i = r.body = this.startNode(), n = i.body = [];
      for (this.expect(5); !this.match(8); ) {
        let l = this.startNode();
        this.match(83) ? (this.next(), !this.isContextual(130) && !this.match(87) && this.raise(se.InvalidNonTypeImportInDeclareModule, this.
        state.lastTokStartLoc), super.parseImport(l)) : (this.expectContextual(125, se.UnsupportedStatementInDeclareModule), l = this.flowParseDeclare(
        l, !0)), n.push(l);
      }
      this.scope.exit(), this.expect(8), this.finishNode(i, "BlockStatement");
      let a = null, o = !1;
      return n.forEach((l) => {
        tB(l) ? (a === "CommonJS" && this.raise(se.AmbiguousDeclareModuleKind, l), a = "ES") : l.type === "DeclareModuleExports" && (o && this.
        raise(se.DuplicateDeclareModuleExports, l), a === "ES" && this.raise(se.AmbiguousDeclareModuleKind, l), a = "CommonJS", o = !0);
      }), r.kind = a || "CommonJS", this.finishNode(r, "DeclareModule");
    }
    flowParseDeclareExportDeclaration(r, i) {
      if (this.expect(82), this.eat(65))
        return this.match(68) || this.match(80) ? r.declaration = this.flowParseDeclare(this.startNode()) : (r.declaration = this.flowParseType(),
        this.semicolon()), r.default = !0, this.finishNode(r, "DeclareExportDeclaration");
      if (this.match(75) || this.isLet() || (this.isContextual(130) || this.isContextual(129)) && !i) {
        let n = this.state.value;
        throw this.raise(se.UnsupportedDeclareExportKind, this.state.startLoc, {
          unsupportedExportKind: n,
          suggestion: rB[n]
        });
      }
      if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(131))
        return r.declaration = this.flowParseDeclare(this.startNode()), r.default = !1, this.finishNode(r, "DeclareExportDeclaration");
      if (this.match(55) || this.match(5) || this.isContextual(129) || this.isContextual(130) || this.isContextual(131))
        return r = this.parseExport(r, null), r.type === "ExportNamedDeclaration" && (r.type = "ExportDeclaration", r.default = !1, delete r.
        exportKind), r.type = "Declare" + r.type, r;
      this.unexpected();
    }
    flowParseDeclareModuleExports(r) {
      return this.next(), this.expectContextual(111), r.typeAnnotation = this.flowParseTypeAnnotation(), this.semicolon(), this.finishNode(r,
      "DeclareModuleExports");
    }
    flowParseDeclareTypeAlias(r) {
      this.next();
      let i = this.flowParseTypeAlias(r);
      return i.type = "DeclareTypeAlias", i;
    }
    flowParseDeclareOpaqueType(r) {
      this.next();
      let i = this.flowParseOpaqueType(r, !0);
      return i.type = "DeclareOpaqueType", i;
    }
    flowParseDeclareInterface(r) {
      return this.next(), this.flowParseInterfaceish(r, !1), this.finishNode(r, "DeclareInterface");
    }
    flowParseInterfaceish(r, i) {
      if (r.id = this.flowParseRestrictedIdentifier(!i, !0), this.scope.declareName(r.id.name, i ? 17 : 8201, r.id.loc.start), this.match(47) ?
      r.typeParameters = this.flowParseTypeParameterDeclaration() : r.typeParameters = null, r.extends = [], this.eat(81))
        do
          r.extends.push(this.flowParseInterfaceExtends());
        while (!i && this.eat(12));
      if (i) {
        if (r.implements = [], r.mixins = [], this.eatContextual(117))
          do
            r.mixins.push(this.flowParseInterfaceExtends());
          while (this.eat(12));
        if (this.eatContextual(113))
          do
            r.implements.push(this.flowParseInterfaceExtends());
          while (this.eat(12));
      }
      r.body = this.flowParseObjectType({
        allowStatic: i,
        allowExact: !1,
        allowSpread: !1,
        allowProto: i,
        allowInexact: !1
      });
    }
    flowParseInterfaceExtends() {
      let r = this.startNode();
      return r.id = this.flowParseQualifiedTypeIdentifier(), this.match(47) ? r.typeParameters = this.flowParseTypeParameterInstantiation() :
      r.typeParameters = null, this.finishNode(r, "InterfaceExtends");
    }
    flowParseInterface(r) {
      return this.flowParseInterfaceish(r, !1), this.finishNode(r, "InterfaceDeclaration");
    }
    checkNotUnderscore(r) {
      r === "_" && this.raise(se.UnexpectedReservedUnderscore, this.state.startLoc);
    }
    checkReservedType(r, i, n) {
      eB.has(r) && this.raise(n ? se.AssignReservedType : se.UnexpectedReservedType, i, {
        reservedType: r
      });
    }
    flowParseRestrictedIdentifier(r, i) {
      return this.checkReservedType(this.state.value, this.state.startLoc, i), this.parseIdentifier(r);
    }
    flowParseTypeAlias(r) {
      return r.id = this.flowParseRestrictedIdentifier(!1, !0), this.scope.declareName(r.id.name, 8201, r.id.loc.start), this.match(47) ? r.
      typeParameters = this.flowParseTypeParameterDeclaration() : r.typeParameters = null, r.right = this.flowParseTypeInitialiser(29), this.
      semicolon(), this.finishNode(r, "TypeAlias");
    }
    flowParseOpaqueType(r, i) {
      return this.expectContextual(130), r.id = this.flowParseRestrictedIdentifier(!0, !0), this.scope.declareName(r.id.name, 8201, r.id.loc.
      start), this.match(47) ? r.typeParameters = this.flowParseTypeParameterDeclaration() : r.typeParameters = null, r.supertype = null, this.
      match(14) && (r.supertype = this.flowParseTypeInitialiser(14)), r.impltype = null, i || (r.impltype = this.flowParseTypeInitialiser(29)),
      this.semicolon(), this.finishNode(r, "OpaqueType");
    }
    flowParseTypeParameter(r = !1) {
      let i = this.state.startLoc, n = this.startNode(), a = this.flowParseVariance(), o = this.flowParseTypeAnnotatableIdentifier();
      return n.name = o.name, n.variance = a, n.bound = o.typeAnnotation, this.match(29) ? (this.eat(29), n.default = this.flowParseType()) :
      r && this.raise(se.MissingTypeParamDefault, i), this.finishNode(n, "TypeParameter");
    }
    flowParseTypeParameterDeclaration() {
      let r = this.state.inType, i = this.startNode();
      i.params = [], this.state.inType = !0, this.match(47) || this.match(143) ? this.next() : this.unexpected();
      let n = !1;
      do {
        let a = this.flowParseTypeParameter(n);
        i.params.push(a), a.default && (n = !0), this.match(48) || this.expect(12);
      } while (!this.match(48));
      return this.expect(48), this.state.inType = r, this.finishNode(i, "TypeParameterDeclaration");
    }
    flowInTopLevelContext(r) {
      if (this.curContext() !== Ie.brace) {
        let i = this.state.context;
        this.state.context = [i[0]];
        try {
          return r();
        } finally {
          this.state.context = i;
        }
      } else
        return r();
    }
    flowParseTypeParameterInstantiationInExpression() {
      if (this.reScan_lt() === 47)
        return this.flowParseTypeParameterInstantiation();
    }
    flowParseTypeParameterInstantiation() {
      let r = this.startNode(), i = this.state.inType;
      return this.state.inType = !0, r.params = [], this.flowInTopLevelContext(() => {
        this.expect(47);
        let n = this.state.noAnonFunctionType;
        for (this.state.noAnonFunctionType = !1; !this.match(48); )
          r.params.push(this.flowParseType()), this.match(48) || this.expect(12);
        this.state.noAnonFunctionType = n;
      }), this.state.inType = i, !this.state.inType && this.curContext() === Ie.brace && this.reScan_lt_gt(), this.expect(48), this.finishNode(
      r, "TypeParameterInstantiation");
    }
    flowParseTypeParameterInstantiationCallOrNew() {
      if (this.reScan_lt() !== 47) return;
      let r = this.startNode(), i = this.state.inType;
      for (r.params = [], this.state.inType = !0, this.expect(47); !this.match(48); )
        r.params.push(this.flowParseTypeOrImplicitInstantiation()), this.match(48) || this.expect(12);
      return this.expect(48), this.state.inType = i, this.finishNode(r, "TypeParameterInstantiation");
    }
    flowParseInterfaceType() {
      let r = this.startNode();
      if (this.expectContextual(129), r.extends = [], this.eat(81))
        do
          r.extends.push(this.flowParseInterfaceExtends());
        while (this.eat(12));
      return r.body = this.flowParseObjectType({
        allowStatic: !1,
        allowExact: !1,
        allowSpread: !1,
        allowProto: !1,
        allowInexact: !1
      }), this.finishNode(r, "InterfaceTypeAnnotation");
    }
    flowParseObjectPropertyKey() {
      return this.match(135) || this.match(134) ? super.parseExprAtom() : this.parseIdentifier(!0);
    }
    flowParseObjectTypeIndexer(r, i, n) {
      return r.static = i, this.lookahead().type === 14 ? (r.id = this.flowParseObjectPropertyKey(), r.key = this.flowParseTypeInitialiser()) :
      (r.id = null, r.key = this.flowParseType()), this.expect(3), r.value = this.flowParseTypeInitialiser(), r.variance = n, this.finishNode(
      r, "ObjectTypeIndexer");
    }
    flowParseObjectTypeInternalSlot(r, i) {
      return r.static = i, r.id = this.flowParseObjectPropertyKey(), this.expect(3), this.expect(3), this.match(47) || this.match(10) ? (r.method =
      !0, r.optional = !1, r.value = this.flowParseObjectTypeMethodish(this.startNodeAt(r.loc.start))) : (r.method = !1, this.eat(17) && (r.
      optional = !0), r.value = this.flowParseTypeInitialiser()), this.finishNode(r, "ObjectTypeInternalSlot");
    }
    flowParseObjectTypeMethodish(r) {
      for (r.params = [], r.rest = null, r.typeParameters = null, r.this = null, this.match(47) && (r.typeParameters = this.flowParseTypeParameterDeclaration()),
      this.expect(10), this.match(78) && (r.this = this.flowParseFunctionTypeParam(!0), r.this.name = null, this.match(11) || this.expect(12)); !this.
      match(11) && !this.match(21); )
        r.params.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
      return this.eat(21) && (r.rest = this.flowParseFunctionTypeParam(!1)), this.expect(11), r.returnType = this.flowParseTypeInitialiser(),
      this.finishNode(r, "FunctionTypeAnnotation");
    }
    flowParseObjectTypeCallProperty(r, i) {
      let n = this.startNode();
      return r.static = i, r.value = this.flowParseObjectTypeMethodish(n), this.finishNode(r, "ObjectTypeCallProperty");
    }
    flowParseObjectType({
      allowStatic: r,
      allowExact: i,
      allowSpread: n,
      allowProto: a,
      allowInexact: o
    }) {
      let l = this.state.inType;
      this.state.inType = !0;
      let u = this.startNode();
      u.callProperties = [], u.properties = [], u.indexers = [], u.internalSlots = [];
      let p, m, g = !1;
      for (i && this.match(6) ? (this.expect(6), p = 9, m = !0) : (this.expect(5), p = 8, m = !1), u.exact = m; !this.match(p); ) {
        let v = !1, _ = null, V = null, D = this.startNode();
        if (a && this.isContextual(118)) {
          let B = this.lookahead();
          B.type !== 14 && B.type !== 17 && (this.next(), _ = this.state.startLoc, r = !1);
        }
        if (r && this.isContextual(106)) {
          let B = this.lookahead();
          B.type !== 14 && B.type !== 17 && (this.next(), v = !0);
        }
        let L = this.flowParseVariance();
        if (this.eat(0))
          _ != null && this.unexpected(_), this.eat(0) ? (L && this.unexpected(L.loc.start), u.internalSlots.push(this.flowParseObjectTypeInternalSlot(
          D, v))) : u.indexers.push(this.flowParseObjectTypeIndexer(D, v, L));
        else if (this.match(10) || this.match(47))
          _ != null && this.unexpected(_), L && this.unexpected(L.loc.start), u.callProperties.push(this.flowParseObjectTypeCallProperty(D, v));
        else {
          let B = "init";
          if (this.isContextual(99) || this.isContextual(104)) {
            let ee = this.lookahead();
            np(ee.type) && (B = this.state.value, this.next());
          }
          let fe = this.flowParseObjectTypeProperty(D, v, _, L, B, n, o ?? !m);
          fe === null ? (g = !0, V = this.state.lastTokStartLoc) : u.properties.push(fe);
        }
        this.flowObjectTypeSemicolon(), V && !this.match(8) && !this.match(9) && this.raise(se.UnexpectedExplicitInexactInObject, V);
      }
      this.expect(p), n && (u.inexact = g);
      let I = this.finishNode(u, "ObjectTypeAnnotation");
      return this.state.inType = l, I;
    }
    flowParseObjectTypeProperty(r, i, n, a, o, l, u) {
      if (this.eat(21))
        return this.match(12) || this.match(13) || this.match(8) || this.match(9) ? (l ? u || this.raise(se.InexactInsideExact, this.state.lastTokStartLoc) :
        this.raise(se.InexactInsideNonObject, this.state.lastTokStartLoc), a && this.raise(se.InexactVariance, a), null) : (l || this.raise(
        se.UnexpectedSpreadType, this.state.lastTokStartLoc), n != null && this.unexpected(n), a && this.raise(se.SpreadVariance, a), r.argument =
        this.flowParseType(), this.finishNode(r, "ObjectTypeSpreadProperty"));
      {
        r.key = this.flowParseObjectPropertyKey(), r.static = i, r.proto = n != null, r.kind = o;
        let p = !1;
        return this.match(47) || this.match(10) ? (r.method = !0, n != null && this.unexpected(n), a && this.unexpected(a.loc.start), r.value =
        this.flowParseObjectTypeMethodish(this.startNodeAt(r.loc.start)), (o === "get" || o === "set") && this.flowCheckGetterSetterParams(r),
        !l && r.key.name === "constructor" && r.value.this && this.raise(se.ThisParamBannedInConstructor, r.value.this)) : (o !== "init" && this.
        unexpected(), r.method = !1, this.eat(17) && (p = !0), r.value = this.flowParseTypeInitialiser(), r.variance = a), r.optional = p, this.
        finishNode(r, "ObjectTypeProperty");
      }
    }
    flowCheckGetterSetterParams(r) {
      let i = r.kind === "get" ? 0 : 1, n = r.value.params.length + (r.value.rest ? 1 : 0);
      r.value.this && this.raise(r.kind === "get" ? se.GetterMayNotHaveThisParam : se.SetterMayNotHaveThisParam, r.value.this), n !== i && this.
      raise(r.kind === "get" ? P.BadGetterArity : P.BadSetterArity, r), r.kind === "set" && r.value.rest && this.raise(P.BadSetterRestParameter,
      r);
    }
    flowObjectTypeSemicolon() {
      !this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9) && this.unexpected();
    }
    flowParseQualifiedTypeIdentifier(r, i) {
      r ?? (r = this.state.startLoc);
      let n = i || this.flowParseRestrictedIdentifier(!0);
      for (; this.eat(16); ) {
        let a = this.startNodeAt(r);
        a.qualification = n, a.id = this.flowParseRestrictedIdentifier(!0), n = this.finishNode(a, "QualifiedTypeIdentifier");
      }
      return n;
    }
    flowParseGenericType(r, i) {
      let n = this.startNodeAt(r);
      return n.typeParameters = null, n.id = this.flowParseQualifiedTypeIdentifier(r, i), this.match(47) && (n.typeParameters = this.flowParseTypeParameterInstantiation()),
      this.finishNode(n, "GenericTypeAnnotation");
    }
    flowParseTypeofType() {
      let r = this.startNode();
      return this.expect(87), r.argument = this.flowParsePrimaryType(), this.finishNode(r, "TypeofTypeAnnotation");
    }
    flowParseTupleType() {
      let r = this.startNode();
      for (r.types = [], this.expect(0); this.state.pos < this.length && !this.match(3) && (r.types.push(this.flowParseType()), !this.match(
      3)); )
        this.expect(12);
      return this.expect(3), this.finishNode(r, "TupleTypeAnnotation");
    }
    flowParseFunctionTypeParam(r) {
      let i = null, n = !1, a = null, o = this.startNode(), l = this.lookahead(), u = this.state.type === 78;
      return l.type === 14 || l.type === 17 ? (u && !r && this.raise(se.ThisParamMustBeFirst, o), i = this.parseIdentifier(u), this.eat(17) &&
      (n = !0, u && this.raise(se.ThisParamMayNotBeOptional, o)), a = this.flowParseTypeInitialiser()) : a = this.flowParseType(), o.name = i,
      o.optional = n, o.typeAnnotation = a, this.finishNode(o, "FunctionTypeParam");
    }
    reinterpretTypeAsFunctionTypeParam(r) {
      let i = this.startNodeAt(r.loc.start);
      return i.name = null, i.optional = !1, i.typeAnnotation = r, this.finishNode(i, "FunctionTypeParam");
    }
    flowParseFunctionTypeParams(r = []) {
      let i = null, n = null;
      for (this.match(78) && (n = this.flowParseFunctionTypeParam(!0), n.name = null, this.match(11) || this.expect(12)); !this.match(11) &&
      !this.match(21); )
        r.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
      return this.eat(21) && (i = this.flowParseFunctionTypeParam(!1)), {
        params: r,
        rest: i,
        _this: n
      };
    }
    flowIdentToTypeAnnotation(r, i, n) {
      switch (n.name) {
        case "any":
          return this.finishNode(i, "AnyTypeAnnotation");
        case "bool":
        case "boolean":
          return this.finishNode(i, "BooleanTypeAnnotation");
        case "mixed":
          return this.finishNode(i, "MixedTypeAnnotation");
        case "empty":
          return this.finishNode(i, "EmptyTypeAnnotation");
        case "number":
          return this.finishNode(i, "NumberTypeAnnotation");
        case "string":
          return this.finishNode(i, "StringTypeAnnotation");
        case "symbol":
          return this.finishNode(i, "SymbolTypeAnnotation");
        default:
          return this.checkNotUnderscore(n.name), this.flowParseGenericType(r, n);
      }
    }
    flowParsePrimaryType() {
      let r = this.state.startLoc, i = this.startNode(), n, a, o = !1, l = this.state.noAnonFunctionType;
      switch (this.state.type) {
        case 5:
          return this.flowParseObjectType({
            allowStatic: !1,
            allowExact: !1,
            allowSpread: !0,
            allowProto: !1,
            allowInexact: !0
          });
        case 6:
          return this.flowParseObjectType({
            allowStatic: !1,
            allowExact: !0,
            allowSpread: !0,
            allowProto: !1,
            allowInexact: !1
          });
        case 0:
          return this.state.noAnonFunctionType = !1, a = this.flowParseTupleType(), this.state.noAnonFunctionType = l, a;
        case 47: {
          let u = this.startNode();
          return u.typeParameters = this.flowParseTypeParameterDeclaration(), this.expect(10), n = this.flowParseFunctionTypeParams(), u.params =
          n.params, u.rest = n.rest, u.this = n._this, this.expect(11), this.expect(19), u.returnType = this.flowParseType(), this.finishNode(
          u, "FunctionTypeAnnotation");
        }
        case 10: {
          let u = this.startNode();
          if (this.next(), !this.match(11) && !this.match(21))
            if (ve(this.state.type) || this.match(78)) {
              let p = this.lookahead().type;
              o = p !== 17 && p !== 14;
            } else
              o = !0;
          if (o) {
            if (this.state.noAnonFunctionType = !1, a = this.flowParseType(), this.state.noAnonFunctionType = l, this.state.noAnonFunctionType ||
            !(this.match(12) || this.match(11) && this.lookahead().type === 19))
              return this.expect(11), a;
            this.eat(12);
          }
          return a ? n = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(a)]) : n = this.flowParseFunctionTypeParams(),
          u.params = n.params, u.rest = n.rest, u.this = n._this, this.expect(11), this.expect(19), u.returnType = this.flowParseType(), u.typeParameters =
          null, this.finishNode(u, "FunctionTypeAnnotation");
        }
        case 134:
          return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
        case 85:
        case 86:
          return i.value = this.match(85), this.next(), this.finishNode(i, "BooleanLiteralTypeAnnotation");
        case 53:
          if (this.state.value === "-") {
            if (this.next(), this.match(135))
              return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", i);
            if (this.match(136))
              return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", i);
            throw this.raise(se.UnexpectedSubtractionOperand, this.state.startLoc);
          }
          this.unexpected();
          return;
        case 135:
          return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
        case 136:
          return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
        case 88:
          return this.next(), this.finishNode(i, "VoidTypeAnnotation");
        case 84:
          return this.next(), this.finishNode(i, "NullLiteralTypeAnnotation");
        case 78:
          return this.next(), this.finishNode(i, "ThisTypeAnnotation");
        case 55:
          return this.next(), this.finishNode(i, "ExistsTypeAnnotation");
        case 87:
          return this.flowParseTypeofType();
        default:
          if (Eo(this.state.type)) {
            let u = Kt(this.state.type);
            return this.next(), super.createIdentifier(i, u);
          } else if (ve(this.state.type))
            return this.isContextual(129) ? this.flowParseInterfaceType() : this.flowIdentToTypeAnnotation(r, i, this.parseIdentifier());
      }
      this.unexpected();
    }
    flowParsePostfixType() {
      let r = this.state.startLoc, i = this.flowParsePrimaryType(), n = !1;
      for (; (this.match(0) || this.match(18)) && !this.canInsertSemicolon(); ) {
        let a = this.startNodeAt(r), o = this.eat(18);
        n = n || o, this.expect(0), !o && this.match(3) ? (a.elementType = i, this.next(), i = this.finishNode(a, "ArrayTypeAnnotation")) : (a.
        objectType = i, a.indexType = this.flowParseType(), this.expect(3), n ? (a.optional = o, i = this.finishNode(a, "OptionalIndexedAcce\
ssType")) : i = this.finishNode(a, "IndexedAccessType"));
      }
      return i;
    }
    flowParsePrefixType() {
      let r = this.startNode();
      return this.eat(17) ? (r.typeAnnotation = this.flowParsePrefixType(), this.finishNode(r, "NullableTypeAnnotation")) : this.flowParsePostfixType();
    }
    flowParseAnonFunctionWithoutParens() {
      let r = this.flowParsePrefixType();
      if (!this.state.noAnonFunctionType && this.eat(19)) {
        let i = this.startNodeAt(r.loc.start);
        return i.params = [this.reinterpretTypeAsFunctionTypeParam(r)], i.rest = null, i.this = null, i.returnType = this.flowParseType(), i.
        typeParameters = null, this.finishNode(i, "FunctionTypeAnnotation");
      }
      return r;
    }
    flowParseIntersectionType() {
      let r = this.startNode();
      this.eat(45);
      let i = this.flowParseAnonFunctionWithoutParens();
      for (r.types = [i]; this.eat(45); )
        r.types.push(this.flowParseAnonFunctionWithoutParens());
      return r.types.length === 1 ? i : this.finishNode(r, "IntersectionTypeAnnotation");
    }
    flowParseUnionType() {
      let r = this.startNode();
      this.eat(43);
      let i = this.flowParseIntersectionType();
      for (r.types = [i]; this.eat(43); )
        r.types.push(this.flowParseIntersectionType());
      return r.types.length === 1 ? i : this.finishNode(r, "UnionTypeAnnotation");
    }
    flowParseType() {
      let r = this.state.inType;
      this.state.inType = !0;
      let i = this.flowParseUnionType();
      return this.state.inType = r, i;
    }
    flowParseTypeOrImplicitInstantiation() {
      if (this.state.type === 132 && this.state.value === "_") {
        let r = this.state.startLoc, i = this.parseIdentifier();
        return this.flowParseGenericType(r, i);
      } else
        return this.flowParseType();
    }
    flowParseTypeAnnotation() {
      let r = this.startNode();
      return r.typeAnnotation = this.flowParseTypeInitialiser(), this.finishNode(r, "TypeAnnotation");
    }
    flowParseTypeAnnotatableIdentifier(r) {
      let i = r ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
      return this.match(14) && (i.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(i)), i;
    }
    typeCastToParameter(r) {
      return r.expression.typeAnnotation = r.typeAnnotation, this.resetEndLocation(r.expression, r.typeAnnotation.loc.end), r.expression;
    }
    flowParseVariance() {
      let r = null;
      return this.match(53) ? (r = this.startNode(), this.state.value === "+" ? r.kind = "plus" : r.kind = "minus", this.next(), this.finishNode(
      r, "Variance")) : r;
    }
    parseFunctionBody(r, i, n = !1) {
      if (i) {
        this.forwardNoArrowParamsConversionAt(r, () => super.parseFunctionBody(r, !0, n));
        return;
      }
      super.parseFunctionBody(r, !1, n);
    }
    parseFunctionBodyAndFinish(r, i, n = !1) {
      if (this.match(14)) {
        let a = this.startNode();
        [a.typeAnnotation, r.predicate] = this.flowParseTypeAndPredicateInitialiser(), r.returnType = a.typeAnnotation ? this.finishNode(a, "\
TypeAnnotation") : null;
      }
      return super.parseFunctionBodyAndFinish(r, i, n);
    }
    parseStatementLike(r) {
      if (this.state.strict && this.isContextual(129)) {
        let n = this.lookahead();
        if (mt(n.type)) {
          let a = this.startNode();
          return this.next(), this.flowParseInterface(a);
        }
      } else if (this.isContextual(126)) {
        let n = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(n);
      }
      let i = super.parseStatementLike(r);
      return this.flowPragma === void 0 && !this.isValidDirective(i) && (this.flowPragma = null), i;
    }
    parseExpressionStatement(r, i, n) {
      if (i.type === "Identifier") {
        if (i.name === "declare") {
          if (this.match(80) || ve(this.state.type) || this.match(68) || this.match(74) || this.match(82))
            return this.flowParseDeclare(r);
        } else if (ve(this.state.type)) {
          if (i.name === "interface")
            return this.flowParseInterface(r);
          if (i.name === "type")
            return this.flowParseTypeAlias(r);
          if (i.name === "opaque")
            return this.flowParseOpaqueType(r, !1);
        }
      }
      return super.parseExpressionStatement(r, i, n);
    }
    shouldParseExportDeclaration() {
      let {
        type: r
      } = this.state;
      return r === 126 || zc(r) ? !this.state.containsEsc : super.shouldParseExportDeclaration();
    }
    isExportDefaultSpecifier() {
      let {
        type: r
      } = this.state;
      return r === 126 || zc(r) ? this.state.containsEsc : super.isExportDefaultSpecifier();
    }
    parseExportDefaultExpression() {
      if (this.isContextual(126)) {
        let r = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(r);
      }
      return super.parseExportDefaultExpression();
    }
    parseConditional(r, i, n) {
      if (!this.match(17)) return r;
      if (this.state.maybeInArrowParameters) {
        let I = this.lookaheadCharCode();
        if (I === 44 || I === 61 || I === 58 || I === 41)
          return this.setOptionalParametersError(n), r;
      }
      this.expect(17);
      let a = this.state.clone(), o = this.state.noArrowAt, l = this.startNodeAt(i), {
        consequent: u,
        failed: p
      } = this.tryParseConditionalConsequent(), [m, g] = this.getArrowLikeExpressions(u);
      if (p || g.length > 0) {
        let I = [...o];
        if (g.length > 0) {
          this.state = a, this.state.noArrowAt = I;
          for (let v = 0; v < g.length; v++)
            I.push(g[v].start);
          ({
            consequent: u,
            failed: p
          } = this.tryParseConditionalConsequent()), [m, g] = this.getArrowLikeExpressions(u);
        }
        p && m.length > 1 && this.raise(se.AmbiguousConditionalArrow, a.startLoc), p && m.length === 1 && (this.state = a, I.push(m[0].start),
        this.state.noArrowAt = I, {
          consequent: u,
          failed: p
        } = this.tryParseConditionalConsequent());
      }
      return this.getArrowLikeExpressions(u, !0), this.state.noArrowAt = o, this.expect(14), l.test = r, l.consequent = u, l.alternate = this.
      forwardNoArrowParamsConversionAt(l, () => this.parseMaybeAssign(void 0, void 0)), this.finishNode(l, "ConditionalExpression");
    }
    tryParseConditionalConsequent() {
      this.state.noArrowParamsConversionAt.push(this.state.start);
      let r = this.parseMaybeAssignAllowIn(), i = !this.match(14);
      return this.state.noArrowParamsConversionAt.pop(), {
        consequent: r,
        failed: i
      };
    }
    getArrowLikeExpressions(r, i) {
      let n = [r], a = [];
      for (; n.length !== 0; ) {
        let o = n.pop();
        o.type === "ArrowFunctionExpression" && o.body.type !== "BlockStatement" ? (o.typeParameters || !o.returnType ? this.finishArrowValidation(
        o) : a.push(o), n.push(o.body)) : o.type === "ConditionalExpression" && (n.push(o.consequent), n.push(o.alternate));
      }
      return i ? (a.forEach((o) => this.finishArrowValidation(o)), [a, []]) : iB(a, (o) => o.params.every((l) => this.isAssignable(l, !0)));
    }
    finishArrowValidation(r) {
      var i;
      this.toAssignableList(r.params, (i = r.extra) == null ? void 0 : i.trailingCommaLoc, !1), this.scope.enter(6), super.checkParams(r, !1,
      !0), this.scope.exit();
    }
    forwardNoArrowParamsConversionAt(r, i) {
      let n;
      return this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(r.start)) ? (this.state.noArrowParamsConversionAt.push(this.
      state.start), n = i(), this.state.noArrowParamsConversionAt.pop()) : n = i(), n;
    }
    parseParenItem(r, i) {
      let n = super.parseParenItem(r, i);
      if (this.eat(17) && (n.optional = !0, this.resetEndLocation(r)), this.match(14)) {
        let a = this.startNodeAt(i);
        return a.expression = n, a.typeAnnotation = this.flowParseTypeAnnotation(), this.finishNode(a, "TypeCastExpression");
      }
      return n;
    }
    assertModuleNodeAllowed(r) {
      r.type === "ImportDeclaration" && (r.importKind === "type" || r.importKind === "typeof") || r.type === "ExportNamedDeclaration" && r.exportKind ===
      "type" || r.type === "ExportAllDeclaration" && r.exportKind === "type" || super.assertModuleNodeAllowed(r);
    }
    parseExportDeclaration(r) {
      if (this.isContextual(130)) {
        r.exportKind = "type";
        let i = this.startNode();
        return this.next(), this.match(5) ? (r.specifiers = this.parseExportSpecifiers(!0), super.parseExportFrom(r), null) : this.flowParseTypeAlias(
        i);
      } else if (this.isContextual(131)) {
        r.exportKind = "type";
        let i = this.startNode();
        return this.next(), this.flowParseOpaqueType(i, !1);
      } else if (this.isContextual(129)) {
        r.exportKind = "type";
        let i = this.startNode();
        return this.next(), this.flowParseInterface(i);
      } else if (this.isContextual(126)) {
        r.exportKind = "value";
        let i = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(i);
      } else
        return super.parseExportDeclaration(r);
    }
    eatExportStar(r) {
      return super.eatExportStar(r) ? !0 : this.isContextual(130) && this.lookahead().type === 55 ? (r.exportKind = "type", this.next(), this.
      next(), !0) : !1;
    }
    maybeParseExportNamespaceSpecifier(r) {
      let {
        startLoc: i
      } = this.state, n = super.maybeParseExportNamespaceSpecifier(r);
      return n && r.exportKind === "type" && this.unexpected(i), n;
    }
    parseClassId(r, i, n) {
      super.parseClassId(r, i, n), this.match(47) && (r.typeParameters = this.flowParseTypeParameterDeclaration());
    }
    parseClassMember(r, i, n) {
      let {
        startLoc: a
      } = this.state;
      if (this.isContextual(125)) {
        if (super.parseClassMemberFromModifier(r, i))
          return;
        i.declare = !0;
      }
      super.parseClassMember(r, i, n), i.declare && (i.type !== "ClassProperty" && i.type !== "ClassPrivateProperty" && i.type !== "Property\
Definition" ? this.raise(se.DeclareClassElement, a) : i.value && this.raise(se.DeclareClassFieldInitializer, i.value));
    }
    isIterator(r) {
      return r === "iterator" || r === "asyncIterator";
    }
    readIterator() {
      let r = super.readWord1(), i = "@@" + r;
      (!this.isIterator(r) || !this.state.inType) && this.raise(P.InvalidIdentifier, this.state.curPosition(), {
        identifierName: i
      }), this.finishToken(132, i);
    }
    getTokenFromCode(r) {
      let i = this.input.charCodeAt(this.state.pos + 1);
      r === 123 && i === 124 ? this.finishOp(6, 2) : this.state.inType && (r === 62 || r === 60) ? this.finishOp(r === 62 ? 48 : 47, 1) : this.
      state.inType && r === 63 ? i === 46 ? this.finishOp(18, 2) : this.finishOp(17, 1) : R3(r, i, this.input.charCodeAt(this.state.pos + 2)) ?
      (this.state.pos += 2, this.readIterator()) : super.getTokenFromCode(r);
    }
    isAssignable(r, i) {
      return r.type === "TypeCastExpression" ? this.isAssignable(r.expression, i) : super.isAssignable(r, i);
    }
    toAssignable(r, i = !1) {
      !i && r.type === "AssignmentExpression" && r.left.type === "TypeCastExpression" && (r.left = this.typeCastToParameter(r.left)), super.
      toAssignable(r, i);
    }
    toAssignableList(r, i, n) {
      for (let a = 0; a < r.length; a++) {
        let o = r[a];
        o?.type === "TypeCastExpression" && (r[a] = this.typeCastToParameter(o));
      }
      super.toAssignableList(r, i, n);
    }
    toReferencedList(r, i) {
      for (let a = 0; a < r.length; a++) {
        var n;
        let o = r[a];
        o && o.type === "TypeCastExpression" && !((n = o.extra) != null && n.parenthesized) && (r.length > 1 || !i) && this.raise(se.TypeCastInPattern,
        o.typeAnnotation);
      }
      return r;
    }
    parseArrayLike(r, i, n, a) {
      let o = super.parseArrayLike(r, i, n, a);
      return i && !this.state.maybeInArrowParameters && this.toReferencedList(o.elements), o;
    }
    isValidLVal(r, i, n) {
      return r === "TypeCastExpression" || super.isValidLVal(r, i, n);
    }
    parseClassProperty(r) {
      return this.match(14) && (r.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassProperty(r);
    }
    parseClassPrivateProperty(r) {
      return this.match(14) && (r.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassPrivateProperty(r);
    }
    isClassMethod() {
      return this.match(47) || super.isClassMethod();
    }
    isClassProperty() {
      return this.match(14) || super.isClassProperty();
    }
    isNonstaticConstructor(r) {
      return !this.match(14) && super.isNonstaticConstructor(r);
    }
    pushClassMethod(r, i, n, a, o, l) {
      if (i.variance && this.unexpected(i.variance.loc.start), delete i.variance, this.match(47) && (i.typeParameters = this.flowParseTypeParameterDeclaration()),
      super.pushClassMethod(r, i, n, a, o, l), i.params && o) {
        let u = i.params;
        u.length > 0 && this.isThisParam(u[0]) && this.raise(se.ThisParamBannedInConstructor, i);
      } else if (i.type === "MethodDefinition" && o && i.value.params) {
        let u = i.value.params;
        u.length > 0 && this.isThisParam(u[0]) && this.raise(se.ThisParamBannedInConstructor, i);
      }
    }
    pushClassPrivateMethod(r, i, n, a) {
      i.variance && this.unexpected(i.variance.loc.start), delete i.variance, this.match(47) && (i.typeParameters = this.flowParseTypeParameterDeclaration()),
      super.pushClassPrivateMethod(r, i, n, a);
    }
    parseClassSuper(r) {
      if (super.parseClassSuper(r), r.superClass && (this.match(47) || this.match(51)) && (r.superTypeParameters = this.flowParseTypeParameterInstantiationInExpression()),
      this.isContextual(113)) {
        this.next();
        let i = r.implements = [];
        do {
          let n = this.startNode();
          n.id = this.flowParseRestrictedIdentifier(!0), this.match(47) ? n.typeParameters = this.flowParseTypeParameterInstantiation() : n.
          typeParameters = null, i.push(this.finishNode(n, "ClassImplements"));
        } while (this.eat(12));
      }
    }
    checkGetterSetterParams(r) {
      super.checkGetterSetterParams(r);
      let i = this.getObjectOrClassMethodParams(r);
      if (i.length > 0) {
        let n = i[0];
        this.isThisParam(n) && r.kind === "get" ? this.raise(se.GetterMayNotHaveThisParam, n) : this.isThisParam(n) && this.raise(se.SetterMayNotHaveThisParam,
        n);
      }
    }
    parsePropertyNamePrefixOperator(r) {
      r.variance = this.flowParseVariance();
    }
    parseObjPropValue(r, i, n, a, o, l, u) {
      r.variance && this.unexpected(r.variance.loc.start), delete r.variance;
      let p;
      this.match(47) && !l && (p = this.flowParseTypeParameterDeclaration(), this.match(10) || this.unexpected());
      let m = super.parseObjPropValue(r, i, n, a, o, l, u);
      return p && ((m.value || m).typeParameters = p), m;
    }
    parseFunctionParamType(r) {
      return this.eat(17) && (r.type !== "Identifier" && this.raise(se.PatternIsOptional, r), this.isThisParam(r) && this.raise(se.ThisParamMayNotBeOptional,
      r), r.optional = !0), this.match(14) ? r.typeAnnotation = this.flowParseTypeAnnotation() : this.isThisParam(r) && this.raise(se.ThisParamAnnotationRequired,
      r), this.match(29) && this.isThisParam(r) && this.raise(se.ThisParamNoDefault, r), this.resetEndLocation(r), r;
    }
    parseMaybeDefault(r, i) {
      let n = super.parseMaybeDefault(r, i);
      return n.type === "AssignmentPattern" && n.typeAnnotation && n.right.start < n.typeAnnotation.start && this.raise(se.TypeBeforeInitializer,
      n.typeAnnotation), n;
    }
    checkImportReflection(r) {
      super.checkImportReflection(r), r.module && r.importKind !== "value" && this.raise(se.ImportReflectionHasImportType, r.specifiers[0].loc.
      start);
    }
    parseImportSpecifierLocal(r, i, n) {
      i.local = Qc(r) ? this.flowParseRestrictedIdentifier(!0, !0) : this.parseIdentifier(), r.specifiers.push(this.finishImportSpecifier(i,
      n));
    }
    isPotentialImportPhase(r) {
      if (super.isPotentialImportPhase(r)) return !0;
      if (this.isContextual(130)) {
        if (!r) return !0;
        let i = this.lookaheadCharCode();
        return i === 123 || i === 42;
      }
      return !r && this.isContextual(87);
    }
    applyImportPhase(r, i, n, a) {
      if (super.applyImportPhase(r, i, n, a), i) {
        if (!n && this.match(65))
          return;
        r.exportKind = n === "type" ? n : "value";
      } else
        n === "type" && this.match(55) && this.unexpected(), r.importKind = n === "type" || n === "typeof" ? n : "value";
    }
    parseImportSpecifier(r, i, n, a, o) {
      let l = r.imported, u = null;
      l.type === "Identifier" && (l.name === "type" ? u = "type" : l.name === "typeof" && (u = "typeof"));
      let p = !1;
      if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
        let g = this.parseIdentifier(!0);
        u !== null && !mt(this.state.type) ? (r.imported = g, r.importKind = u, r.local = Dt(g)) : (r.imported = l, r.importKind = null, r.local =
        this.parseIdentifier());
      } else {
        if (u !== null && mt(this.state.type))
          r.imported = this.parseIdentifier(!0), r.importKind = u;
        else {
          if (i)
            throw this.raise(P.ImportBindingIsString, r, {
              importName: l.value
            });
          r.imported = l, r.importKind = null;
        }
        this.eatContextual(93) ? r.local = this.parseIdentifier() : (p = !0, r.local = Dt(r.imported));
      }
      let m = Qc(r);
      return n && m && this.raise(se.ImportTypeShorthandOnlyInPureImport, r), (n || m) && this.checkReservedType(r.local.name, r.local.loc.start,
      !0), p && !n && !m && this.checkReservedWord(r.local.name, r.loc.start, !0, !0), this.finishImportSpecifier(r, "ImportSpecifier");
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case 78:
          return this.parseIdentifier(!0);
        default:
          return super.parseBindingAtom();
      }
    }
    parseFunctionParams(r, i) {
      let n = r.kind;
      n !== "get" && n !== "set" && this.match(47) && (r.typeParameters = this.flowParseTypeParameterDeclaration()), super.parseFunctionParams(
      r, i);
    }
    parseVarId(r, i) {
      super.parseVarId(r, i), this.match(14) && (r.id.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(r.id));
    }
    parseAsyncArrowFromCallExpression(r, i) {
      if (this.match(14)) {
        let n = this.state.noAnonFunctionType;
        this.state.noAnonFunctionType = !0, r.returnType = this.flowParseTypeAnnotation(), this.state.noAnonFunctionType = n;
      }
      return super.parseAsyncArrowFromCallExpression(r, i);
    }
    shouldParseAsyncArrow() {
      return this.match(14) || super.shouldParseAsyncArrow();
    }
    parseMaybeAssign(r, i) {
      var n;
      let a = null, o;
      if (this.hasPlugin("jsx") && (this.match(143) || this.match(47))) {
        if (a = this.state.clone(), o = this.tryParse(() => super.parseMaybeAssign(r, i), a), !o.error) return o.node;
        let {
          context: p
        } = this.state, m = p[p.length - 1];
        (m === Ie.j_oTag || m === Ie.j_expr) && p.pop();
      }
      if ((n = o) != null && n.error || this.match(47)) {
        var l, u;
        a = a || this.state.clone();
        let p, m = this.tryParse((I) => {
          var v;
          p = this.flowParseTypeParameterDeclaration();
          let _ = this.forwardNoArrowParamsConversionAt(p, () => {
            let D = super.parseMaybeAssign(r, i);
            return this.resetStartLocationFromNode(D, p), D;
          });
          (v = _.extra) != null && v.parenthesized && I();
          let V = this.maybeUnwrapTypeCastExpression(_);
          return V.type !== "ArrowFunctionExpression" && I(), V.typeParameters = p, this.resetStartLocationFromNode(V, p), _;
        }, a), g = null;
        if (m.node && this.maybeUnwrapTypeCastExpression(m.node).type === "ArrowFunctionExpression") {
          if (!m.error && !m.aborted)
            return m.node.async && this.raise(se.UnexpectedTypeParameterBeforeAsyncArrowFunction, p), m.node;
          g = m.node;
        }
        if ((l = o) != null && l.node)
          return this.state = o.failState, o.node;
        if (g)
          return this.state = m.failState, g;
        throw (u = o) != null && u.thrown ? o.error : m.thrown ? m.error : this.raise(se.UnexpectedTokenAfterTypeParameter, p);
      }
      return super.parseMaybeAssign(r, i);
    }
    parseArrow(r) {
      if (this.match(14)) {
        let i = this.tryParse(() => {
          let n = this.state.noAnonFunctionType;
          this.state.noAnonFunctionType = !0;
          let a = this.startNode();
          return [a.typeAnnotation, r.predicate] = this.flowParseTypeAndPredicateInitialiser(), this.state.noAnonFunctionType = n, this.canInsertSemicolon() &&
          this.unexpected(), this.match(19) || this.unexpected(), a;
        });
        if (i.thrown) return null;
        i.error && (this.state = i.failState), r.returnType = i.node.typeAnnotation ? this.finishNode(i.node, "TypeAnnotation") : null;
      }
      return super.parseArrow(r);
    }
    shouldParseArrow(r) {
      return this.match(14) || super.shouldParseArrow(r);
    }
    setArrowFunctionParameters(r, i) {
      this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(r.start)) ? r.params = i : super.setArrowFunctionParameters(r, i);
    }
    checkParams(r, i, n, a = !0) {
      if (!(n && this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(r.start)))) {
        for (let o = 0; o < r.params.length; o++)
          this.isThisParam(r.params[o]) && o > 0 && this.raise(se.ThisParamMustBeFirst, r.params[o]);
        super.checkParams(r, i, n, a);
      }
    }
    parseParenAndDistinguishExpression(r) {
      return super.parseParenAndDistinguishExpression(r && !this.state.noArrowAt.includes(this.sourceToOffsetPos(this.state.start)));
    }
    parseSubscripts(r, i, n) {
      if (r.type === "Identifier" && r.name === "async" && this.state.noArrowAt.includes(i.index)) {
        this.next();
        let a = this.startNodeAt(i);
        a.callee = r, a.arguments = super.parseCallExpressionArguments(11), r = this.finishNode(a, "CallExpression");
      } else if (r.type === "Identifier" && r.name === "async" && this.match(47)) {
        let a = this.state.clone(), o = this.tryParse((u) => this.parseAsyncArrowWithTypeParameters(i) || u(), a);
        if (!o.error && !o.aborted) return o.node;
        let l = this.tryParse(() => super.parseSubscripts(r, i, n), a);
        if (l.node && !l.error) return l.node;
        if (o.node)
          return this.state = o.failState, o.node;
        if (l.node)
          return this.state = l.failState, l.node;
        throw o.error || l.error;
      }
      return super.parseSubscripts(r, i, n);
    }
    parseSubscript(r, i, n, a) {
      if (this.match(18) && this.isLookaheadToken_lt()) {
        if (a.optionalChainMember = !0, n)
          return a.stop = !0, r;
        this.next();
        let o = this.startNodeAt(i);
        return o.callee = r, o.typeArguments = this.flowParseTypeParameterInstantiationInExpression(), this.expect(10), o.arguments = this.parseCallExpressionArguments(
        11), o.optional = !0, this.finishCallExpression(o, !0);
      } else if (!n && this.shouldParseTypes() && (this.match(47) || this.match(51))) {
        let o = this.startNodeAt(i);
        o.callee = r;
        let l = this.tryParse(() => (o.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew(), this.expect(10), o.arguments = super.
        parseCallExpressionArguments(11), a.optionalChainMember && (o.optional = !1), this.finishCallExpression(o, a.optionalChainMember)));
        if (l.node)
          return l.error && (this.state = l.failState), l.node;
      }
      return super.parseSubscript(r, i, n, a);
    }
    parseNewCallee(r) {
      super.parseNewCallee(r);
      let i = null;
      this.shouldParseTypes() && this.match(47) && (i = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node), r.typeArguments =
      i;
    }
    parseAsyncArrowWithTypeParameters(r) {
      let i = this.startNodeAt(r);
      if (this.parseFunctionParams(i, !1), !!this.parseArrow(i))
        return super.parseArrowExpression(i, void 0, !0);
    }
    readToken_mult_modulo(r) {
      let i = this.input.charCodeAt(this.state.pos + 1);
      if (r === 42 && i === 47 && this.state.hasFlowComment) {
        this.state.hasFlowComment = !1, this.state.pos += 2, this.nextToken();
        return;
      }
      super.readToken_mult_modulo(r);
    }
    readToken_pipe_amp(r) {
      let i = this.input.charCodeAt(this.state.pos + 1);
      if (r === 124 && i === 125) {
        this.finishOp(9, 2);
        return;
      }
      super.readToken_pipe_amp(r);
    }
    parseTopLevel(r, i) {
      let n = super.parseTopLevel(r, i);
      return this.state.hasFlowComment && this.raise(se.UnterminatedFlowComment, this.state.curPosition()), n;
    }
    skipBlockComment() {
      if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
        if (this.state.hasFlowComment)
          throw this.raise(se.NestedFlowComment, this.state.startLoc);
        this.hasFlowCommentCompletion();
        let r = this.skipFlowComment();
        r && (this.state.pos += r, this.state.hasFlowComment = !0);
        return;
      }
      return super.skipBlockComment(this.state.hasFlowComment ? "*-/" : "*/");
    }
    skipFlowComment() {
      let {
        pos: r
      } = this.state, i = 2;
      for (; [32, 9].includes(this.input.charCodeAt(r + i)); )
        i++;
      let n = this.input.charCodeAt(i + r), a = this.input.charCodeAt(i + r + 1);
      return n === 58 && a === 58 ? i + 2 : this.input.slice(i + r, i + r + 12) === "flow-include" ? i + 12 : n === 58 && a !== 58 ? i : !1;
    }
    hasFlowCommentCompletion() {
      if (this.input.indexOf("*/", this.state.pos) === -1)
        throw this.raise(P.UnterminatedComment, this.state.curPosition());
    }
    flowEnumErrorBooleanMemberNotInitialized(r, {
      enumName: i,
      memberName: n
    }) {
      this.raise(se.EnumBooleanMemberNotInitialized, r, {
        memberName: n,
        enumName: i
      });
    }
    flowEnumErrorInvalidMemberInitializer(r, i) {
      return this.raise(i.explicitType ? i.explicitType === "symbol" ? se.EnumInvalidMemberInitializerSymbolType : se.EnumInvalidMemberInitializerPrimaryType :
      se.EnumInvalidMemberInitializerUnknownType, r, i);
    }
    flowEnumErrorNumberMemberNotInitialized(r, i) {
      this.raise(se.EnumNumberMemberNotInitialized, r, i);
    }
    flowEnumErrorStringMemberInconsistentlyInitialized(r, i) {
      this.raise(se.EnumStringMemberInconsistentlyInitialized, r, i);
    }
    flowEnumMemberInit() {
      let r = this.state.startLoc, i = /* @__PURE__ */ s(() => this.match(12) || this.match(8), "endOfInit");
      switch (this.state.type) {
        case 135: {
          let n = this.parseNumericLiteral(this.state.value);
          return i() ? {
            type: "number",
            loc: n.loc.start,
            value: n
          } : {
            type: "invalid",
            loc: r
          };
        }
        case 134: {
          let n = this.parseStringLiteral(this.state.value);
          return i() ? {
            type: "string",
            loc: n.loc.start,
            value: n
          } : {
            type: "invalid",
            loc: r
          };
        }
        case 85:
        case 86: {
          let n = this.parseBooleanLiteral(this.match(85));
          return i() ? {
            type: "boolean",
            loc: n.loc.start,
            value: n
          } : {
            type: "invalid",
            loc: r
          };
        }
        default:
          return {
            type: "invalid",
            loc: r
          };
      }
    }
    flowEnumMemberRaw() {
      let r = this.state.startLoc, i = this.parseIdentifier(!0), n = this.eat(29) ? this.flowEnumMemberInit() : {
        type: "none",
        loc: r
      };
      return {
        id: i,
        init: n
      };
    }
    flowEnumCheckExplicitTypeMismatch(r, i, n) {
      let {
        explicitType: a
      } = i;
      a !== null && a !== n && this.flowEnumErrorInvalidMemberInitializer(r, i);
    }
    flowEnumMembers({
      enumName: r,
      explicitType: i
    }) {
      let n = /* @__PURE__ */ new Set(), a = {
        booleanMembers: [],
        numberMembers: [],
        stringMembers: [],
        defaultedMembers: []
      }, o = !1;
      for (; !this.match(8); ) {
        if (this.eat(21)) {
          o = !0;
          break;
        }
        let l = this.startNode(), {
          id: u,
          init: p
        } = this.flowEnumMemberRaw(), m = u.name;
        if (m === "")
          continue;
        /^[a-z]/.test(m) && this.raise(se.EnumInvalidMemberName, u, {
          memberName: m,
          suggestion: m[0].toUpperCase() + m.slice(1),
          enumName: r
        }), n.has(m) && this.raise(se.EnumDuplicateMemberName, u, {
          memberName: m,
          enumName: r
        }), n.add(m);
        let g = {
          enumName: r,
          explicitType: i,
          memberName: m
        };
        switch (l.id = u, p.type) {
          case "boolean": {
            this.flowEnumCheckExplicitTypeMismatch(p.loc, g, "boolean"), l.init = p.value, a.booleanMembers.push(this.finishNode(l, "EnumBoo\
leanMember"));
            break;
          }
          case "number": {
            this.flowEnumCheckExplicitTypeMismatch(p.loc, g, "number"), l.init = p.value, a.numberMembers.push(this.finishNode(l, "EnumNumbe\
rMember"));
            break;
          }
          case "string": {
            this.flowEnumCheckExplicitTypeMismatch(p.loc, g, "string"), l.init = p.value, a.stringMembers.push(this.finishNode(l, "EnumStrin\
gMember"));
            break;
          }
          case "invalid":
            throw this.flowEnumErrorInvalidMemberInitializer(p.loc, g);
          case "none":
            switch (i) {
              case "boolean":
                this.flowEnumErrorBooleanMemberNotInitialized(p.loc, g);
                break;
              case "number":
                this.flowEnumErrorNumberMemberNotInitialized(p.loc, g);
                break;
              default:
                a.defaultedMembers.push(this.finishNode(l, "EnumDefaultedMember"));
            }
        }
        this.match(8) || this.expect(12);
      }
      return {
        members: a,
        hasUnknownMembers: o
      };
    }
    flowEnumStringMembers(r, i, {
      enumName: n
    }) {
      if (r.length === 0)
        return i;
      if (i.length === 0)
        return r;
      if (i.length > r.length) {
        for (let a of r)
          this.flowEnumErrorStringMemberInconsistentlyInitialized(a, {
            enumName: n
          });
        return i;
      } else {
        for (let a of i)
          this.flowEnumErrorStringMemberInconsistentlyInitialized(a, {
            enumName: n
          });
        return r;
      }
    }
    flowEnumParseExplicitType({
      enumName: r
    }) {
      if (!this.eatContextual(102)) return null;
      if (!ve(this.state.type))
        throw this.raise(se.EnumInvalidExplicitTypeUnknownSupplied, this.state.startLoc, {
          enumName: r
        });
      let {
        value: i
      } = this.state;
      return this.next(), i !== "boolean" && i !== "number" && i !== "string" && i !== "symbol" && this.raise(se.EnumInvalidExplicitType, this.
      state.startLoc, {
        enumName: r,
        invalidEnumType: i
      }), i;
    }
    flowEnumBody(r, i) {
      let n = i.name, a = i.loc.start, o = this.flowEnumParseExplicitType({
        enumName: n
      });
      this.expect(5);
      let {
        members: l,
        hasUnknownMembers: u
      } = this.flowEnumMembers({
        enumName: n,
        explicitType: o
      });
      switch (r.hasUnknownMembers = u, o) {
        case "boolean":
          return r.explicitType = !0, r.members = l.booleanMembers, this.expect(8), this.finishNode(r, "EnumBooleanBody");
        case "number":
          return r.explicitType = !0, r.members = l.numberMembers, this.expect(8), this.finishNode(r, "EnumNumberBody");
        case "string":
          return r.explicitType = !0, r.members = this.flowEnumStringMembers(l.stringMembers, l.defaultedMembers, {
            enumName: n
          }), this.expect(8), this.finishNode(r, "EnumStringBody");
        case "symbol":
          return r.members = l.defaultedMembers, this.expect(8), this.finishNode(r, "EnumSymbolBody");
        default: {
          let p = /* @__PURE__ */ s(() => (r.members = [], this.expect(8), this.finishNode(r, "EnumStringBody")), "empty");
          r.explicitType = !1;
          let m = l.booleanMembers.length, g = l.numberMembers.length, I = l.stringMembers.length, v = l.defaultedMembers.length;
          if (!m && !g && !I && !v)
            return p();
          if (!m && !g)
            return r.members = this.flowEnumStringMembers(l.stringMembers, l.defaultedMembers, {
              enumName: n
            }), this.expect(8), this.finishNode(r, "EnumStringBody");
          if (!g && !I && m >= v) {
            for (let _ of l.defaultedMembers)
              this.flowEnumErrorBooleanMemberNotInitialized(_.loc.start, {
                enumName: n,
                memberName: _.id.name
              });
            return r.members = l.booleanMembers, this.expect(8), this.finishNode(r, "EnumBooleanBody");
          } else if (!m && !I && g >= v) {
            for (let _ of l.defaultedMembers)
              this.flowEnumErrorNumberMemberNotInitialized(_.loc.start, {
                enumName: n,
                memberName: _.id.name
              });
            return r.members = l.numberMembers, this.expect(8), this.finishNode(r, "EnumNumberBody");
          } else
            return this.raise(se.EnumInconsistentMemberValues, a, {
              enumName: n
            }), p();
        }
      }
    }
    flowParseEnumDeclaration(r) {
      let i = this.parseIdentifier();
      return r.id = i, r.body = this.flowEnumBody(this.startNode(), i), this.finishNode(r, "EnumDeclaration");
    }
    jsxParseOpeningElementAfterName(r) {
      return this.shouldParseTypes() && (this.match(47) || this.match(51)) && (r.typeArguments = this.flowParseTypeParameterInstantiationInExpression()),
      super.jsxParseOpeningElementAfterName(r);
    }
    isLookaheadToken_lt() {
      let r = this.nextTokenStart();
      if (this.input.charCodeAt(r) === 60) {
        let i = this.input.charCodeAt(r + 1);
        return i !== 60 && i !== 61;
      }
      return !1;
    }
    reScan_lt_gt() {
      let {
        type: r
      } = this.state;
      r === 47 ? (this.state.pos -= 1, this.readToken_lt()) : r === 48 && (this.state.pos -= 1, this.readToken_gt());
    }
    reScan_lt() {
      let {
        type: r
      } = this.state;
      return r === 51 ? (this.state.pos -= 2, this.finishOp(47, 1), 47) : r;
    }
    maybeUnwrapTypeCastExpression(r) {
      return r.type === "TypeCastExpression" ? r.expression : r;
    }
  }, "flow"), aB = {
    __proto__: null,
    quot: '"',
    amp: "&",
    apos: "'",
    lt: "<",
    gt: ">",
    nbsp: "\xA0",
    iexcl: "\xA1",
    cent: "\xA2",
    pound: "\xA3",
    curren: "\xA4",
    yen: "\xA5",
    brvbar: "\xA6",
    sect: "\xA7",
    uml: "\xA8",
    copy: "\xA9",
    ordf: "\xAA",
    laquo: "\xAB",
    not: "\xAC",
    shy: "\xAD",
    reg: "\xAE",
    macr: "\xAF",
    deg: "\xB0",
    plusmn: "\xB1",
    sup2: "\xB2",
    sup3: "\xB3",
    acute: "\xB4",
    micro: "\xB5",
    para: "\xB6",
    middot: "\xB7",
    cedil: "\xB8",
    sup1: "\xB9",
    ordm: "\xBA",
    raquo: "\xBB",
    frac14: "\xBC",
    frac12: "\xBD",
    frac34: "\xBE",
    iquest: "\xBF",
    Agrave: "\xC0",
    Aacute: "\xC1",
    Acirc: "\xC2",
    Atilde: "\xC3",
    Auml: "\xC4",
    Aring: "\xC5",
    AElig: "\xC6",
    Ccedil: "\xC7",
    Egrave: "\xC8",
    Eacute: "\xC9",
    Ecirc: "\xCA",
    Euml: "\xCB",
    Igrave: "\xCC",
    Iacute: "\xCD",
    Icirc: "\xCE",
    Iuml: "\xCF",
    ETH: "\xD0",
    Ntilde: "\xD1",
    Ograve: "\xD2",
    Oacute: "\xD3",
    Ocirc: "\xD4",
    Otilde: "\xD5",
    Ouml: "\xD6",
    times: "\xD7",
    Oslash: "\xD8",
    Ugrave: "\xD9",
    Uacute: "\xDA",
    Ucirc: "\xDB",
    Uuml: "\xDC",
    Yacute: "\xDD",
    THORN: "\xDE",
    szlig: "\xDF",
    agrave: "\xE0",
    aacute: "\xE1",
    acirc: "\xE2",
    atilde: "\xE3",
    auml: "\xE4",
    aring: "\xE5",
    aelig: "\xE6",
    ccedil: "\xE7",
    egrave: "\xE8",
    eacute: "\xE9",
    ecirc: "\xEA",
    euml: "\xEB",
    igrave: "\xEC",
    iacute: "\xED",
    icirc: "\xEE",
    iuml: "\xEF",
    eth: "\xF0",
    ntilde: "\xF1",
    ograve: "\xF2",
    oacute: "\xF3",
    ocirc: "\xF4",
    otilde: "\xF5",
    ouml: "\xF6",
    divide: "\xF7",
    oslash: "\xF8",
    ugrave: "\xF9",
    uacute: "\xFA",
    ucirc: "\xFB",
    uuml: "\xFC",
    yacute: "\xFD",
    thorn: "\xFE",
    yuml: "\xFF",
    OElig: "\u0152",
    oelig: "\u0153",
    Scaron: "\u0160",
    scaron: "\u0161",
    Yuml: "\u0178",
    fnof: "\u0192",
    circ: "\u02C6",
    tilde: "\u02DC",
    Alpha: "\u0391",
    Beta: "\u0392",
    Gamma: "\u0393",
    Delta: "\u0394",
    Epsilon: "\u0395",
    Zeta: "\u0396",
    Eta: "\u0397",
    Theta: "\u0398",
    Iota: "\u0399",
    Kappa: "\u039A",
    Lambda: "\u039B",
    Mu: "\u039C",
    Nu: "\u039D",
    Xi: "\u039E",
    Omicron: "\u039F",
    Pi: "\u03A0",
    Rho: "\u03A1",
    Sigma: "\u03A3",
    Tau: "\u03A4",
    Upsilon: "\u03A5",
    Phi: "\u03A6",
    Chi: "\u03A7",
    Psi: "\u03A8",
    Omega: "\u03A9",
    alpha: "\u03B1",
    beta: "\u03B2",
    gamma: "\u03B3",
    delta: "\u03B4",
    epsilon: "\u03B5",
    zeta: "\u03B6",
    eta: "\u03B7",
    theta: "\u03B8",
    iota: "\u03B9",
    kappa: "\u03BA",
    lambda: "\u03BB",
    mu: "\u03BC",
    nu: "\u03BD",
    xi: "\u03BE",
    omicron: "\u03BF",
    pi: "\u03C0",
    rho: "\u03C1",
    sigmaf: "\u03C2",
    sigma: "\u03C3",
    tau: "\u03C4",
    upsilon: "\u03C5",
    phi: "\u03C6",
    chi: "\u03C7",
    psi: "\u03C8",
    omega: "\u03C9",
    thetasym: "\u03D1",
    upsih: "\u03D2",
    piv: "\u03D6",
    ensp: "\u2002",
    emsp: "\u2003",
    thinsp: "\u2009",
    zwnj: "\u200C",
    zwj: "\u200D",
    lrm: "\u200E",
    rlm: "\u200F",
    ndash: "\u2013",
    mdash: "\u2014",
    lsquo: "\u2018",
    rsquo: "\u2019",
    sbquo: "\u201A",
    ldquo: "\u201C",
    rdquo: "\u201D",
    bdquo: "\u201E",
    dagger: "\u2020",
    Dagger: "\u2021",
    bull: "\u2022",
    hellip: "\u2026",
    permil: "\u2030",
    prime: "\u2032",
    Prime: "\u2033",
    lsaquo: "\u2039",
    rsaquo: "\u203A",
    oline: "\u203E",
    frasl: "\u2044",
    euro: "\u20AC",
    image: "\u2111",
    weierp: "\u2118",
    real: "\u211C",
    trade: "\u2122",
    alefsym: "\u2135",
    larr: "\u2190",
    uarr: "\u2191",
    rarr: "\u2192",
    darr: "\u2193",
    harr: "\u2194",
    crarr: "\u21B5",
    lArr: "\u21D0",
    uArr: "\u21D1",
    rArr: "\u21D2",
    dArr: "\u21D3",
    hArr: "\u21D4",
    forall: "\u2200",
    part: "\u2202",
    exist: "\u2203",
    empty: "\u2205",
    nabla: "\u2207",
    isin: "\u2208",
    notin: "\u2209",
    ni: "\u220B",
    prod: "\u220F",
    sum: "\u2211",
    minus: "\u2212",
    lowast: "\u2217",
    radic: "\u221A",
    prop: "\u221D",
    infin: "\u221E",
    ang: "\u2220",
    and: "\u2227",
    or: "\u2228",
    cap: "\u2229",
    cup: "\u222A",
    int: "\u222B",
    there4: "\u2234",
    sim: "\u223C",
    cong: "\u2245",
    asymp: "\u2248",
    ne: "\u2260",
    equiv: "\u2261",
    le: "\u2264",
    ge: "\u2265",
    sub: "\u2282",
    sup: "\u2283",
    nsub: "\u2284",
    sube: "\u2286",
    supe: "\u2287",
    oplus: "\u2295",
    otimes: "\u2297",
    perp: "\u22A5",
    sdot: "\u22C5",
    lceil: "\u2308",
    rceil: "\u2309",
    lfloor: "\u230A",
    rfloor: "\u230B",
    lang: "\u2329",
    rang: "\u232A",
    loz: "\u25CA",
    spades: "\u2660",
    clubs: "\u2663",
    hearts: "\u2665",
    diams: "\u2666"
  }, Zt = _t`jsx`({
    AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.",
    MissingClosingTagElement: /* @__PURE__ */ s(({
      openingTagName: t
    }) => `Expected corresponding JSX closing tag for <${t}>.`, "MissingClosingTagElement"),
    MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.",
    UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?",
    UnexpectedToken: /* @__PURE__ */ s(({
      unexpected: t,
      HTMLEntity: e
    }) => `Unexpected token \`${t}\`. Did you mean \`${e}\` or \`{'${t}'}\`?`, "UnexpectedToken"),
    UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.",
    UnterminatedJsxContent: "Unterminated JSX contents.",
    UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"
  });
  function Ut(t) {
    return t ? t.type === "JSXOpeningFragment" || t.type === "JSXClosingFragment" : !1;
  }
  s(Ut, "isFragment");
  function hr(t) {
    if (t.type === "JSXIdentifier")
      return t.name;
    if (t.type === "JSXNamespacedName")
      return t.namespace.name + ":" + t.name.name;
    if (t.type === "JSXMemberExpression")
      return hr(t.object) + "." + hr(t.property);
    throw new Error("Node had unexpected type: " + t.type);
  }
  s(hr, "getQualifiedJSXName");
  var oB = /* @__PURE__ */ s((t) => class extends t {
    static {
      s(this, "JSXParserMixin");
    }
    jsxReadToken() {
      let r = "", i = this.state.pos;
      for (; ; ) {
        if (this.state.pos >= this.length)
          throw this.raise(Zt.UnterminatedJsxContent, this.state.startLoc);
        let n = this.input.charCodeAt(this.state.pos);
        switch (n) {
          case 60:
          case 123:
            if (this.state.pos === this.state.start) {
              n === 60 && this.state.canStartJSXElement ? (++this.state.pos, this.finishToken(143)) : super.getTokenFromCode(n);
              return;
            }
            r += this.input.slice(i, this.state.pos), this.finishToken(142, r);
            return;
          case 38:
            r += this.input.slice(i, this.state.pos), r += this.jsxReadEntity(), i = this.state.pos;
            break;
          case 62:
          case 125:
          default:
            mr(n) ? (r += this.input.slice(i, this.state.pos), r += this.jsxReadNewLine(!0), i = this.state.pos) : ++this.state.pos;
        }
      }
    }
    jsxReadNewLine(r) {
      let i = this.input.charCodeAt(this.state.pos), n;
      return ++this.state.pos, i === 13 && this.input.charCodeAt(this.state.pos) === 10 ? (++this.state.pos, n = r ? `
` : `\r
`) : n = String.fromCharCode(i), ++this.state.curLine, this.state.lineStart = this.state.pos, n;
    }
    jsxReadString(r) {
      let i = "", n = ++this.state.pos;
      for (; ; ) {
        if (this.state.pos >= this.length)
          throw this.raise(P.UnterminatedString, this.state.startLoc);
        let a = this.input.charCodeAt(this.state.pos);
        if (a === r) break;
        a === 38 ? (i += this.input.slice(n, this.state.pos), i += this.jsxReadEntity(), n = this.state.pos) : mr(a) ? (i += this.input.slice(
        n, this.state.pos), i += this.jsxReadNewLine(!1), n = this.state.pos) : ++this.state.pos;
      }
      i += this.input.slice(n, this.state.pos++), this.finishToken(134, i);
    }
    jsxReadEntity() {
      let r = ++this.state.pos;
      if (this.codePointAtPos(this.state.pos) === 35) {
        ++this.state.pos;
        let i = 10;
        this.codePointAtPos(this.state.pos) === 120 && (i = 16, ++this.state.pos);
        let n = this.readInt(i, void 0, !1, "bail");
        if (n !== null && this.codePointAtPos(this.state.pos) === 59)
          return ++this.state.pos, String.fromCodePoint(n);
      } else {
        let i = 0, n = !1;
        for (; i++ < 10 && this.state.pos < this.length && !(n = this.codePointAtPos(this.state.pos) === 59); )
          ++this.state.pos;
        if (n) {
          let a = this.input.slice(r, this.state.pos), o = aB[a];
          if (++this.state.pos, o)
            return o;
        }
      }
      return this.state.pos = r, "&";
    }
    jsxReadWord() {
      let r, i = this.state.pos;
      do
        r = this.input.charCodeAt(++this.state.pos);
      while (dr(r) || r === 45);
      this.finishToken(141, this.input.slice(i, this.state.pos));
    }
    jsxParseIdentifier() {
      let r = this.startNode();
      return this.match(141) ? r.name = this.state.value : Eo(this.state.type) ? r.name = Kt(this.state.type) : this.unexpected(), this.next(),
      this.finishNode(r, "JSXIdentifier");
    }
    jsxParseNamespacedName() {
      let r = this.state.startLoc, i = this.jsxParseIdentifier();
      if (!this.eat(14)) return i;
      let n = this.startNodeAt(r);
      return n.namespace = i, n.name = this.jsxParseIdentifier(), this.finishNode(n, "JSXNamespacedName");
    }
    jsxParseElementName() {
      let r = this.state.startLoc, i = this.jsxParseNamespacedName();
      if (i.type === "JSXNamespacedName")
        return i;
      for (; this.eat(16); ) {
        let n = this.startNodeAt(r);
        n.object = i, n.property = this.jsxParseIdentifier(), i = this.finishNode(n, "JSXMemberExpression");
      }
      return i;
    }
    jsxParseAttributeValue() {
      let r;
      switch (this.state.type) {
        case 5:
          return r = this.startNode(), this.setContext(Ie.brace), this.next(), r = this.jsxParseExpressionContainer(r, Ie.j_oTag), r.expression.
          type === "JSXEmptyExpression" && this.raise(Zt.AttributeIsEmpty, r), r;
        case 143:
        case 134:
          return this.parseExprAtom();
        default:
          throw this.raise(Zt.UnsupportedJsxValue, this.state.startLoc);
      }
    }
    jsxParseEmptyExpression() {
      let r = this.startNodeAt(this.state.lastTokEndLoc);
      return this.finishNodeAt(r, "JSXEmptyExpression", this.state.startLoc);
    }
    jsxParseSpreadChild(r) {
      return this.next(), r.expression = this.parseExpression(), this.setContext(Ie.j_expr), this.state.canStartJSXElement = !0, this.expect(
      8), this.finishNode(r, "JSXSpreadChild");
    }
    jsxParseExpressionContainer(r, i) {
      if (this.match(8))
        r.expression = this.jsxParseEmptyExpression();
      else {
        let n = this.parseExpression();
        r.expression = n;
      }
      return this.setContext(i), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(r, "JSXExpressionContainer");
    }
    jsxParseAttribute() {
      let r = this.startNode();
      return this.match(5) ? (this.setContext(Ie.brace), this.next(), this.expect(21), r.argument = this.parseMaybeAssignAllowIn(), this.setContext(
      Ie.j_oTag), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(r, "JSXSpreadAttribute")) : (r.name = this.jsxParseNamespacedName(),
      r.value = this.eat(29) ? this.jsxParseAttributeValue() : null, this.finishNode(r, "JSXAttribute"));
    }
    jsxParseOpeningElementAt(r) {
      let i = this.startNodeAt(r);
      return this.eat(144) ? this.finishNode(i, "JSXOpeningFragment") : (i.name = this.jsxParseElementName(), this.jsxParseOpeningElementAfterName(
      i));
    }
    jsxParseOpeningElementAfterName(r) {
      let i = [];
      for (; !this.match(56) && !this.match(144); )
        i.push(this.jsxParseAttribute());
      return r.attributes = i, r.selfClosing = this.eat(56), this.expect(144), this.finishNode(r, "JSXOpeningElement");
    }
    jsxParseClosingElementAt(r) {
      let i = this.startNodeAt(r);
      return this.eat(144) ? this.finishNode(i, "JSXClosingFragment") : (i.name = this.jsxParseElementName(), this.expect(144), this.finishNode(
      i, "JSXClosingElement"));
    }
    jsxParseElementAt(r) {
      let i = this.startNodeAt(r), n = [], a = this.jsxParseOpeningElementAt(r), o = null;
      if (!a.selfClosing) {
        e: for (; ; )
          switch (this.state.type) {
            case 143:
              if (r = this.state.startLoc, this.next(), this.eat(56)) {
                o = this.jsxParseClosingElementAt(r);
                break e;
              }
              n.push(this.jsxParseElementAt(r));
              break;
            case 142:
              n.push(this.parseLiteral(this.state.value, "JSXText"));
              break;
            case 5: {
              let l = this.startNode();
              this.setContext(Ie.brace), this.next(), this.match(21) ? n.push(this.jsxParseSpreadChild(l)) : n.push(this.jsxParseExpressionContainer(
              l, Ie.j_expr));
              break;
            }
            default:
              this.unexpected();
          }
        Ut(a) && !Ut(o) && o !== null ? this.raise(Zt.MissingClosingTagFragment, o) : !Ut(a) && Ut(o) ? this.raise(Zt.MissingClosingTagElement,
        o, {
          openingTagName: hr(a.name)
        }) : !Ut(a) && !Ut(o) && hr(o.name) !== hr(a.name) && this.raise(Zt.MissingClosingTagElement, o, {
          openingTagName: hr(a.name)
        });
      }
      if (Ut(a) ? (i.openingFragment = a, i.closingFragment = o) : (i.openingElement = a, i.closingElement = o), i.children = n, this.match(
      47))
        throw this.raise(Zt.UnwrappedAdjacentJSXElements, this.state.startLoc);
      return Ut(a) ? this.finishNode(i, "JSXFragment") : this.finishNode(i, "JSXElement");
    }
    jsxParseElement() {
      let r = this.state.startLoc;
      return this.next(), this.jsxParseElementAt(r);
    }
    setContext(r) {
      let {
        context: i
      } = this.state;
      i[i.length - 1] = r;
    }
    parseExprAtom(r) {
      return this.match(143) ? this.jsxParseElement() : this.match(47) && this.input.charCodeAt(this.state.pos) !== 33 ? (this.replaceToken(
      143), this.jsxParseElement()) : super.parseExprAtom(r);
    }
    skipSpace() {
      this.curContext().preserveSpace || super.skipSpace();
    }
    getTokenFromCode(r) {
      let i = this.curContext();
      if (i === Ie.j_expr) {
        this.jsxReadToken();
        return;
      }
      if (i === Ie.j_oTag || i === Ie.j_cTag) {
        if (Ot(r)) {
          this.jsxReadWord();
          return;
        }
        if (r === 62) {
          ++this.state.pos, this.finishToken(144);
          return;
        }
        if ((r === 34 || r === 39) && i === Ie.j_oTag) {
          this.jsxReadString(r);
          return;
        }
      }
      if (r === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {
        ++this.state.pos, this.finishToken(143);
        return;
      }
      super.getTokenFromCode(r);
    }
    updateContext(r) {
      let {
        context: i,
        type: n
      } = this.state;
      if (n === 56 && r === 143)
        i.splice(-2, 2, Ie.j_cTag), this.state.canStartJSXElement = !1;
      else if (n === 143)
        i.push(Ie.j_oTag);
      else if (n === 144) {
        let a = i[i.length - 1];
        a === Ie.j_oTag && r === 56 || a === Ie.j_cTag ? (i.pop(), this.state.canStartJSXElement = i[i.length - 1] === Ie.j_expr) : (this.setContext(
        Ie.j_expr), this.state.canStartJSXElement = !0);
      } else
        this.state.canStartJSXElement = g3(n);
    }
  }, "jsx"), co = class extends zr {
    static {
      s(this, "TypeScriptScope");
    }
    constructor(...e) {
      super(...e), this.tsNames = /* @__PURE__ */ new Map();
    }
  }, po = class extends $r {
    static {
      s(this, "TypeScriptScopeHandler");
    }
    constructor(...e) {
      super(...e), this.importsStack = [];
    }
    createScope(e) {
      return this.importsStack.push(/* @__PURE__ */ new Set()), new co(e);
    }
    enter(e) {
      e === 256 && this.importsStack.push(/* @__PURE__ */ new Set()), super.enter(e);
    }
    exit() {
      let e = super.exit();
      return e === 256 && this.importsStack.pop(), e;
    }
    hasImport(e, r) {
      let i = this.importsStack.length;
      if (this.importsStack[i - 1].has(e))
        return !0;
      if (!r && i > 1) {
        for (let n = 0; n < i - 1; n++)
          if (this.importsStack[n].has(e)) return !0;
      }
      return !1;
    }
    declareName(e, r, i) {
      if (r & 4096) {
        this.hasImport(e, !0) && this.parser.raise(P.VarRedeclaration, i, {
          identifierName: e
        }), this.importsStack[this.importsStack.length - 1].add(e);
        return;
      }
      let n = this.currentScope(), a = n.tsNames.get(e) || 0;
      if (r & 1024) {
        this.maybeExportDefined(n, e), n.tsNames.set(e, a | 16);
        return;
      }
      super.declareName(e, r, i), r & 2 && (r & 1 || (this.checkRedeclarationInScope(n, e, r, i), this.maybeExportDefined(n, e)), a = a | 1),
      r & 256 && (a = a | 2), r & 512 && (a = a | 4), r & 128 && (a = a | 8), a && n.tsNames.set(e, a);
    }
    isRedeclaredInScope(e, r, i) {
      let n = e.tsNames.get(r);
      if ((n & 2) > 0) {
        if (i & 256) {
          let a = !!(i & 512), o = (n & 4) > 0;
          return a !== o;
        }
        return !0;
      }
      return i & 128 && (n & 8) > 0 ? e.names.get(r) & 2 ? !!(i & 1) : !1 : i & 2 && (n & 1) > 0 ? !0 : super.isRedeclaredInScope(e, r, i);
    }
    checkLocalExport(e) {
      let {
        name: r
      } = e;
      if (this.hasImport(r)) return;
      let i = this.scopeStack.length;
      for (let n = i - 1; n >= 0; n--) {
        let o = this.scopeStack[n].tsNames.get(r);
        if ((o & 1) > 0 || (o & 16) > 0)
          return;
      }
      super.checkLocalExport(e);
    }
  }, yp = /* @__PURE__ */ s((t) => t.type === "ParenthesizedExpression" ? yp(t.expression) : t, "unwrapParenthesizedExpression"), fo = class extends uo {
    static {
      s(this, "LValParser");
    }
    toAssignable(e, r = !1) {
      var i, n;
      let a;
      switch ((e.type === "ParenthesizedExpression" || (i = e.extra) != null && i.parenthesized) && (a = yp(e), r ? a.type === "Identifier" ?
      this.expressionScope.recordArrowParameterBindingError(P.InvalidParenthesizedAssignment, e) : a.type !== "MemberExpression" && !this.isOptionalMemberExpression(
      a) && this.raise(P.InvalidParenthesizedAssignment, e) : this.raise(P.InvalidParenthesizedAssignment, e)), e.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
          break;
        case "ObjectExpression":
          e.type = "ObjectPattern";
          for (let l = 0, u = e.properties.length, p = u - 1; l < u; l++) {
            var o;
            let m = e.properties[l], g = l === p;
            this.toAssignableObjectExpressionProp(m, g, r), g && m.type === "RestElement" && (o = e.extra) != null && o.trailingCommaLoc && this.
            raise(P.RestTrailingComma, e.extra.trailingCommaLoc);
          }
          break;
        case "ObjectProperty": {
          let {
            key: l,
            value: u
          } = e;
          this.isPrivateName(l) && this.classScope.usePrivateName(this.getPrivateNameSV(l), l.loc.start), this.toAssignable(u, r);
          break;
        }
        case "SpreadElement":
          throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignabl\
e's caller.");
        case "ArrayExpression":
          e.type = "ArrayPattern", this.toAssignableList(e.elements, (n = e.extra) == null ? void 0 : n.trailingCommaLoc, r);
          break;
        case "AssignmentExpression":
          e.operator !== "=" && this.raise(P.MissingEqInAssignment, e.left.loc.end), e.type = "AssignmentPattern", delete e.operator, this.toAssignable(
          e.left, r);
          break;
        case "ParenthesizedExpression":
          this.toAssignable(a, r);
          break;
      }
    }
    toAssignableObjectExpressionProp(e, r, i) {
      if (e.type === "ObjectMethod")
        this.raise(e.kind === "get" || e.kind === "set" ? P.PatternHasAccessor : P.PatternHasMethod, e.key);
      else if (e.type === "SpreadElement") {
        e.type = "RestElement";
        let n = e.argument;
        this.checkToRestConversion(n, !1), this.toAssignable(n, i), r || this.raise(P.RestTrailingComma, e);
      } else
        this.toAssignable(e, i);
    }
    toAssignableList(e, r, i) {
      let n = e.length - 1;
      for (let a = 0; a <= n; a++) {
        let o = e[a];
        o && (this.toAssignableListItem(e, a, i), o.type === "RestElement" && (a < n ? this.raise(P.RestTrailingComma, o) : r && this.raise(
        P.RestTrailingComma, r)));
      }
    }
    toAssignableListItem(e, r, i) {
      let n = e[r];
      if (n.type === "SpreadElement") {
        n.type = "RestElement";
        let a = n.argument;
        this.checkToRestConversion(a, !0), this.toAssignable(a, i);
      } else
        this.toAssignable(n, i);
    }
    isAssignable(e, r) {
      switch (e.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
          return !0;
        case "ObjectExpression": {
          let i = e.properties.length - 1;
          return e.properties.every((n, a) => n.type !== "ObjectMethod" && (a === i || n.type !== "SpreadElement") && this.isAssignable(n));
        }
        case "ObjectProperty":
          return this.isAssignable(e.value);
        case "SpreadElement":
          return this.isAssignable(e.argument);
        case "ArrayExpression":
          return e.elements.every((i) => i === null || this.isAssignable(i));
        case "AssignmentExpression":
          return e.operator === "=";
        case "ParenthesizedExpression":
          return this.isAssignable(e.expression);
        case "MemberExpression":
        case "OptionalMemberExpression":
          return !r;
        default:
          return !1;
      }
    }
    toReferencedList(e, r) {
      return e;
    }
    toReferencedListDeep(e, r) {
      this.toReferencedList(e, r);
      for (let i of e)
        i?.type === "ArrayExpression" && this.toReferencedListDeep(i.elements);
    }
    parseSpread(e) {
      let r = this.startNode();
      return this.next(), r.argument = this.parseMaybeAssignAllowIn(e, void 0), this.finishNode(r, "SpreadElement");
    }
    parseRestBinding() {
      let e = this.startNode();
      return this.next(), e.argument = this.parseBindingAtom(), this.finishNode(e, "RestElement");
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case 0: {
          let e = this.startNode();
          return this.next(), e.elements = this.parseBindingList(3, 93, 1), this.finishNode(e, "ArrayPattern");
        }
        case 5:
          return this.parseObjectLike(8, !0);
      }
      return this.parseIdentifier();
    }
    parseBindingList(e, r, i) {
      let n = i & 1, a = [], o = !0;
      for (; !this.eat(e); )
        if (o ? o = !1 : this.expect(12), n && this.match(12))
          a.push(null);
        else {
          if (this.eat(e))
            break;
          if (this.match(21)) {
            let l = this.parseRestBinding();
            if ((this.hasPlugin("flow") || i & 2) && (l = this.parseFunctionParamType(l)), a.push(l), !this.checkCommaAfterRest(r)) {
              this.expect(e);
              break;
            }
          } else {
            let l = [];
            if (i & 2)
              for (this.match(26) && this.hasPlugin("decorators") && this.raise(P.UnsupportedParameterDecorator, this.state.startLoc); this.
              match(26); )
                l.push(this.parseDecorator());
            a.push(this.parseBindingElement(i, l));
          }
        }
      return a;
    }
    parseBindingRestProperty(e) {
      return this.next(), e.argument = this.parseIdentifier(), this.checkCommaAfterRest(125), this.finishNode(e, "RestElement");
    }
    parseBindingProperty() {
      let {
        type: e,
        startLoc: r
      } = this.state;
      if (e === 21)
        return this.parseBindingRestProperty(this.startNode());
      let i = this.startNode();
      return e === 139 ? (this.expectPlugin("destructuringPrivate", r), this.classScope.usePrivateName(this.state.value, r), i.key = this.parsePrivateName()) :
      this.parsePropertyName(i), i.method = !1, this.parseObjPropValue(i, r, !1, !1, !0, !1);
    }
    parseBindingElement(e, r) {
      let i = this.parseMaybeDefault();
      (this.hasPlugin("flow") || e & 2) && this.parseFunctionParamType(i);
      let n = this.parseMaybeDefault(i.loc.start, i);
      return r.length && (i.decorators = r), n;
    }
    parseFunctionParamType(e) {
      return e;
    }
    parseMaybeDefault(e, r) {
      if (e ?? (e = this.state.startLoc), r = r ?? this.parseBindingAtom(), !this.eat(29)) return r;
      let i = this.startNodeAt(e);
      return i.left = r, i.right = this.parseMaybeAssignAllowIn(), this.finishNode(i, "AssignmentPattern");
    }
    isValidLVal(e, r, i) {
      switch (e) {
        case "AssignmentPattern":
          return "left";
        case "RestElement":
          return "argument";
        case "ObjectProperty":
          return "value";
        case "ParenthesizedExpression":
          return "expression";
        case "ArrayPattern":
          return "elements";
        case "ObjectPattern":
          return "properties";
      }
      return !1;
    }
    isOptionalMemberExpression(e) {
      return e.type === "OptionalMemberExpression";
    }
    checkLVal(e, r, i = 64, n = !1, a = !1, o = !1) {
      var l;
      let u = e.type;
      if (this.isObjectMethod(e)) return;
      let p = this.isOptionalMemberExpression(e);
      if (p || u === "MemberExpression") {
        p && (this.expectPlugin("optionalChainingAssign", e.loc.start), r.type !== "AssignmentExpression" && this.raise(P.InvalidLhsOptionalChaining,
        e, {
          ancestor: r
        })), i !== 64 && this.raise(P.InvalidPropertyBindingPattern, e);
        return;
      }
      if (u === "Identifier") {
        this.checkIdentifier(e, i, a);
        let {
          name: V
        } = e;
        n && (n.has(V) ? this.raise(P.ParamDupe, e) : n.add(V));
        return;
      }
      let m = this.isValidLVal(u, !(o || (l = e.extra) != null && l.parenthesized) && r.type === "AssignmentExpression", i);
      if (m === !0) return;
      if (m === !1) {
        let V = i === 64 ? P.InvalidLhs : P.InvalidLhsBinding;
        this.raise(V, e, {
          ancestor: r
        });
        return;
      }
      let g, I;
      typeof m == "string" ? (g = m, I = u === "ParenthesizedExpression") : [g, I] = m;
      let v = u === "ArrayPattern" || u === "ObjectPattern" ? {
        type: u
      } : r, _ = e[g];
      if (Array.isArray(_))
        for (let V of _)
          V && this.checkLVal(V, v, i, n, a, I);
      else _ && this.checkLVal(_, v, i, n, a, I);
    }
    checkIdentifier(e, r, i = !1) {
      this.state.strict && (i ? pp(e.name, this.inModule) : cp(e.name)) && (r === 64 ? this.raise(P.StrictEvalArguments, e, {
        referenceName: e.name
      }) : this.raise(P.StrictEvalArgumentsBinding, e, {
        bindingName: e.name
      })), r & 8192 && e.name === "let" && this.raise(P.LetInLexicalBinding, e), r & 64 || this.declareNameFromIdentifier(e, r);
    }
    declareNameFromIdentifier(e, r) {
      this.scope.declareName(e.name, r, e.loc.start);
    }
    checkToRestConversion(e, r) {
      switch (e.type) {
        case "ParenthesizedExpression":
          this.checkToRestConversion(e.expression, r);
          break;
        case "Identifier":
        case "MemberExpression":
          break;
        case "ArrayExpression":
        case "ObjectExpression":
          if (r) break;
        default:
          this.raise(P.InvalidRestAssignmentPattern, e);
      }
    }
    checkCommaAfterRest(e) {
      return this.match(12) ? (this.raise(this.lookaheadCharCode() === e ? P.RestTrailingComma : P.ElementAfterRest, this.state.startLoc), !0) :
      !1;
    }
  };
  function lB(t) {
    if (t == null)
      throw new Error(`Unexpected ${t} value.`);
    return t;
  }
  s(lB, "nonNull");
  function Zc(t) {
    if (!t)
      throw new Error("Assert fail");
  }
  s(Zc, "assert");
  var Q = _t`typescript`({
    AbstractMethodHasImplementation: /* @__PURE__ */ s(({
      methodName: t
    }) => `Method '${t}' cannot have an implementation because it is marked abstract.`, "AbstractMethodHasImplementation"),
    AbstractPropertyHasInitializer: /* @__PURE__ */ s(({
      propertyName: t
    }) => `Property '${t}' cannot have an initializer because it is marked abstract.`, "AbstractPropertyHasInitializer"),
    AccessorCannotBeOptional: "An 'accessor' property cannot be declared optional.",
    AccessorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.",
    AccessorCannotHaveTypeParameters: "An accessor cannot have type parameters.",
    ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.",
    ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.",
    ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or num\
eric literal or literal enum reference.",
    ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.",
    DeclareAccessor: /* @__PURE__ */ s(({
      kind: t
    }) => `'declare' is not allowed in ${t}ters.`, "DeclareAccessor"),
    DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.",
    DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.",
    DuplicateAccessibilityModifier: /* @__PURE__ */ s(({
      modifier: t
    }) => "Accessibility modifier already seen.", "DuplicateAccessibilityModifier"),
    DuplicateModifier: /* @__PURE__ */ s(({
      modifier: t
    }) => `Duplicate modifier: '${t}'.`, "DuplicateModifier"),
    EmptyHeritageClauseType: /* @__PURE__ */ s(({
      token: t
    }) => `'${t}' list cannot be empty.`, "EmptyHeritageClauseType"),
    EmptyTypeArguments: "Type argument list cannot be empty.",
    EmptyTypeParameters: "Type parameter list cannot be empty.",
    ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.",
    ImportAliasHasImportType: "An import alias can not use 'import type'.",
    ImportReflectionHasImportType: "An `import module` declaration can not use `type` modifier",
    IncompatibleModifiers: /* @__PURE__ */ s(({
      modifiers: t
    }) => `'${t[0]}' modifier cannot be used with '${t[1]}' modifier.`, "IncompatibleModifiers"),
    IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.",
    IndexSignatureHasAccessibility: /* @__PURE__ */ s(({
      modifier: t
    }) => `Index signatures cannot have an accessibility modifier ('${t}').`, "IndexSignatureHasAccessibility"),
    IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.",
    IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.",
    IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.",
    InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.",
    InvalidHeritageClauseType: /* @__PURE__ */ s(({
      token: t
    }) => `'${t}' list can only include identifiers or qualified-names with optional type arguments.`, "InvalidHeritageClauseType"),
    InvalidModifierOnTypeMember: /* @__PURE__ */ s(({
      modifier: t
    }) => `'${t}' modifier cannot appear on a type member.`, "InvalidModifierOnTypeMember"),
    InvalidModifierOnTypeParameter: /* @__PURE__ */ s(({
      modifier: t
    }) => `'${t}' modifier cannot appear on a type parameter.`, "InvalidModifierOnTypeParameter"),
    InvalidModifierOnTypeParameterPositions: /* @__PURE__ */ s(({
      modifier: t
    }) => `'${t}' modifier can only appear on a type parameter of a class, interface or type alias.`, "InvalidModifierOnTypeParameterPositio\
ns"),
    InvalidModifiersOrder: /* @__PURE__ */ s(({
      orderedModifiers: t
    }) => `'${t[0]}' modifier must precede '${t[1]}' modifier.`, "InvalidModifiersOrder"),
    InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. You can either wrap the i\
nstantiation expression in parentheses, or delete the type arguments.",
    InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.",
    MissingInterfaceName: "'interface' declarations must be followed by an identifier.",
    NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.",
    NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.",
    OptionalTypeBeforeRequired: "A required element cannot follow an optional element.",
    OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.",
    PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
    PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
    PrivateElementHasAccessibility: /* @__PURE__ */ s(({
      modifier: t
    }) => `Private elements cannot have an accessibility modifier ('${t}').`, "PrivateElementHasAccessibility"),
    ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.",
    ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.",
    ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.",
    SetAccessorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.",
    SetAccessorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.",
    SetAccessorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.",
    SingleTypeParameterWithoutTrailingComma: /* @__PURE__ */ s(({
      typeParameterName: t
    }) => `Single type parameter ${t} should have a trailing comma. Example usage: <${t},>.`, "SingleTypeParameterWithoutTrailingComma"),
    StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.",
    TupleOptionalAfterType: "A labeled tuple optional element must be declared using a question mark after the name and before the colon (`n\
ame?: type`), rather than after the type (`name: type?`).",
    TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number =\
 25`.",
    TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.",
    TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statemen\
t.",
    TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statemen\
t.",
    UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.",
    UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
    UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
    UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",
    UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.",
    UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.",
    UnsupportedSignatureParameterKind: /* @__PURE__ */ s(({
      type: t
    }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${t}.`, "UnsupportedSignatureParameterKind")
  });
  function uB(t) {
    switch (t) {
      case "any":
        return "TSAnyKeyword";
      case "boolean":
        return "TSBooleanKeyword";
      case "bigint":
        return "TSBigIntKeyword";
      case "never":
        return "TSNeverKeyword";
      case "number":
        return "TSNumberKeyword";
      case "object":
        return "TSObjectKeyword";
      case "string":
        return "TSStringKeyword";
      case "symbol":
        return "TSSymbolKeyword";
      case "undefined":
        return "TSUndefinedKeyword";
      case "unknown":
        return "TSUnknownKeyword";
      default:
        return;
    }
  }
  s(uB, "keywordTypeFromName");
  function ep(t) {
    return t === "private" || t === "public" || t === "protected";
  }
  s(ep, "tsIsAccessModifier");
  function cB(t) {
    return t === "in" || t === "out";
  }
  s(cB, "tsIsVarianceAnnotations");
  var pB = /* @__PURE__ */ s((t) => class extends t {
    static {
      s(this, "TypeScriptParserMixin");
    }
    constructor(...r) {
      super(...r), this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, {
        allowedModifiers: ["in", "out"],
        disallowedModifiers: ["const", "public", "private", "protected", "readonly", "declare", "abstract", "override"],
        errorTemplate: Q.InvalidModifierOnTypeParameter
      }), this.tsParseConstModifier = this.tsParseModifiers.bind(this, {
        allowedModifiers: ["const"],
        disallowedModifiers: ["in", "out"],
        errorTemplate: Q.InvalidModifierOnTypeParameterPositions
      }), this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, {
        allowedModifiers: ["in", "out", "const"],
        disallowedModifiers: ["public", "private", "protected", "readonly", "declare", "abstract", "override"],
        errorTemplate: Q.InvalidModifierOnTypeParameter
      });
    }
    getScopeHandler() {
      return po;
    }
    tsIsIdentifier() {
      return ve(this.state.type);
    }
    tsTokenCanFollowModifier() {
      return this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(139) || this.isLiteralPropertyName();
    }
    tsNextTokenOnSameLineAndCanFollowModifier() {
      return this.next(), this.hasPrecedingLineBreak() ? !1 : this.tsTokenCanFollowModifier();
    }
    tsNextTokenCanFollowModifier() {
      return this.match(106) ? (this.next(), this.tsTokenCanFollowModifier()) : this.tsNextTokenOnSameLineAndCanFollowModifier();
    }
    tsParseModifier(r, i) {
      if (!ve(this.state.type) && this.state.type !== 58 && this.state.type !== 75)
        return;
      let n = this.state.value;
      if (r.includes(n)) {
        if (i && this.tsIsStartOfStaticBlocks())
          return;
        if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this)))
          return n;
      }
    }
    tsParseModifiers({
      allowedModifiers: r,
      disallowedModifiers: i,
      stopOnStartOfClassStaticBlock: n,
      errorTemplate: a = Q.InvalidModifierOnTypeMember
    }, o) {
      let l = /* @__PURE__ */ s((p, m, g, I) => {
        m === g && o[I] && this.raise(Q.InvalidModifiersOrder, p, {
          orderedModifiers: [g, I]
        });
      }, "enforceOrder"), u = /* @__PURE__ */ s((p, m, g, I) => {
        (o[g] && m === I || o[I] && m === g) && this.raise(Q.IncompatibleModifiers, p, {
          modifiers: [g, I]
        });
      }, "incompatible");
      for (; ; ) {
        let {
          startLoc: p
        } = this.state, m = this.tsParseModifier(r.concat(i ?? []), n);
        if (!m) break;
        ep(m) ? o.accessibility ? this.raise(Q.DuplicateAccessibilityModifier, p, {
          modifier: m
        }) : (l(p, m, m, "override"), l(p, m, m, "static"), l(p, m, m, "readonly"), o.accessibility = m) : cB(m) ? (o[m] && this.raise(Q.DuplicateModifier,
        p, {
          modifier: m
        }), o[m] = !0, l(p, m, "in", "out")) : (hasOwnProperty.call(o, m) ? this.raise(Q.DuplicateModifier, p, {
          modifier: m
        }) : (l(p, m, "static", "readonly"), l(p, m, "static", "override"), l(p, m, "override", "readonly"), l(p, m, "abstract", "override"),
        u(p, m, "declare", "override"), u(p, m, "static", "abstract")), o[m] = !0), i != null && i.includes(m) && this.raise(a, p, {
          modifier: m
        });
      }
    }
    tsIsListTerminator(r) {
      switch (r) {
        case "EnumMembers":
        case "TypeMembers":
          return this.match(8);
        case "HeritageClauseElement":
          return this.match(5);
        case "TupleElementTypes":
          return this.match(3);
        case "TypeParametersOrArguments":
          return this.match(48);
      }
    }
    tsParseList(r, i) {
      let n = [];
      for (; !this.tsIsListTerminator(r); )
        n.push(i());
      return n;
    }
    tsParseDelimitedList(r, i, n) {
      return lB(this.tsParseDelimitedListWorker(r, i, !0, n));
    }
    tsParseDelimitedListWorker(r, i, n, a) {
      let o = [], l = -1;
      for (; !this.tsIsListTerminator(r); ) {
        l = -1;
        let u = i();
        if (u == null)
          return;
        if (o.push(u), this.eat(12)) {
          l = this.state.lastTokStartLoc.index;
          continue;
        }
        if (this.tsIsListTerminator(r))
          break;
        n && this.expect(12);
        return;
      }
      return a && (a.value = l), o;
    }
    tsParseBracketedList(r, i, n, a, o) {
      a || (n ? this.expect(0) : this.expect(47));
      let l = this.tsParseDelimitedList(r, i, o);
      return n ? this.expect(3) : this.expect(48), l;
    }
    tsParseImportType() {
      let r = this.startNode();
      return this.expect(83), this.expect(10), this.match(134) ? r.argument = this.parseStringLiteral(this.state.value) : (this.raise(Q.UnsupportedImportTypeArgument,
      this.state.startLoc), r.argument = super.parseExprAtom()), this.eat(12) && !this.match(11) ? (r.options = super.parseMaybeAssignAllowIn(),
      this.eat(12)) : r.options = null, this.expect(11), this.eat(16) && (r.qualifier = this.tsParseEntityName(3)), this.match(47) && (r.typeParameters =
      this.tsParseTypeArguments()), this.finishNode(r, "TSImportType");
    }
    tsParseEntityName(r) {
      let i;
      if (r & 1 && this.match(78))
        if (r & 2)
          i = this.parseIdentifier(!0);
        else {
          let n = this.startNode();
          this.next(), i = this.finishNode(n, "ThisExpression");
        }
      else
        i = this.parseIdentifier(!!(r & 1));
      for (; this.eat(16); ) {
        let n = this.startNodeAtNode(i);
        n.left = i, n.right = this.parseIdentifier(!!(r & 1)), i = this.finishNode(n, "TSQualifiedName");
      }
      return i;
    }
    tsParseTypeReference() {
      let r = this.startNode();
      return r.typeName = this.tsParseEntityName(1), !this.hasPrecedingLineBreak() && this.match(47) && (r.typeParameters = this.tsParseTypeArguments()),
      this.finishNode(r, "TSTypeReference");
    }
    tsParseThisTypePredicate(r) {
      this.next();
      let i = this.startNodeAtNode(r);
      return i.parameterName = r, i.typeAnnotation = this.tsParseTypeAnnotation(!1), i.asserts = !1, this.finishNode(i, "TSTypePredicate");
    }
    tsParseThisTypeNode() {
      let r = this.startNode();
      return this.next(), this.finishNode(r, "TSThisType");
    }
    tsParseTypeQuery() {
      let r = this.startNode();
      return this.expect(87), this.match(83) ? r.exprName = this.tsParseImportType() : r.exprName = this.tsParseEntityName(3), !this.hasPrecedingLineBreak() &&
      this.match(47) && (r.typeParameters = this.tsParseTypeArguments()), this.finishNode(r, "TSTypeQuery");
    }
    tsParseTypeParameter(r) {
      let i = this.startNode();
      return r(i), i.name = this.tsParseTypeParameterName(), i.constraint = this.tsEatThenParseType(81), i.default = this.tsEatThenParseType(
      29), this.finishNode(i, "TSTypeParameter");
    }
    tsTryParseTypeParameters(r) {
      if (this.match(47))
        return this.tsParseTypeParameters(r);
    }
    tsParseTypeParameters(r) {
      let i = this.startNode();
      this.match(47) || this.match(143) ? this.next() : this.unexpected();
      let n = {
        value: -1
      };
      return i.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, r), !1, !0, n), i.params.
      length === 0 && this.raise(Q.EmptyTypeParameters, i), n.value !== -1 && this.addExtra(i, "trailingComma", n.value), this.finishNode(i,
      "TSTypeParameterDeclaration");
    }
    tsFillSignature(r, i) {
      let n = r === 19, a = "parameters", o = "typeAnnotation";
      i.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier), this.expect(10), i[a] = this.tsParseBindingListForSignature(),
      n ? i[o] = this.tsParseTypeOrTypePredicateAnnotation(r) : this.match(r) && (i[o] = this.tsParseTypeOrTypePredicateAnnotation(r));
    }
    tsParseBindingListForSignature() {
      let r = super.parseBindingList(11, 41, 2);
      for (let i of r) {
        let {
          type: n
        } = i;
        (n === "AssignmentPattern" || n === "TSParameterProperty") && this.raise(Q.UnsupportedSignatureParameterKind, i, {
          type: n
        });
      }
      return r;
    }
    tsParseTypeMemberSemicolon() {
      !this.eat(12) && !this.isLineTerminator() && this.expect(13);
    }
    tsParseSignatureMember(r, i) {
      return this.tsFillSignature(14, i), this.tsParseTypeMemberSemicolon(), this.finishNode(i, r);
    }
    tsIsUnambiguouslyIndexSignature() {
      return this.next(), ve(this.state.type) ? (this.next(), this.match(14)) : !1;
    }
    tsTryParseIndexSignature(r) {
      if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this))))
        return;
      this.expect(0);
      let i = this.parseIdentifier();
      i.typeAnnotation = this.tsParseTypeAnnotation(), this.resetEndLocation(i), this.expect(3), r.parameters = [i];
      let n = this.tsTryParseTypeAnnotation();
      return n && (r.typeAnnotation = n), this.tsParseTypeMemberSemicolon(), this.finishNode(r, "TSIndexSignature");
    }
    tsParsePropertyOrMethodSignature(r, i) {
      this.eat(17) && (r.optional = !0);
      let n = r;
      if (this.match(10) || this.match(47)) {
        i && this.raise(Q.ReadonlyForMethodSignature, r);
        let a = n;
        a.kind && this.match(47) && this.raise(Q.AccessorCannotHaveTypeParameters, this.state.curPosition()), this.tsFillSignature(14, a), this.
        tsParseTypeMemberSemicolon();
        let o = "parameters", l = "typeAnnotation";
        if (a.kind === "get")
          a[o].length > 0 && (this.raise(P.BadGetterArity, this.state.curPosition()), this.isThisParam(a[o][0]) && this.raise(Q.AccessorCannotDeclareThisParameter,
          this.state.curPosition()));
        else if (a.kind === "set") {
          if (a[o].length !== 1)
            this.raise(P.BadSetterArity, this.state.curPosition());
          else {
            let u = a[o][0];
            this.isThisParam(u) && this.raise(Q.AccessorCannotDeclareThisParameter, this.state.curPosition()), u.type === "Identifier" && u.
            optional && this.raise(Q.SetAccessorCannotHaveOptionalParameter, this.state.curPosition()), u.type === "RestElement" && this.raise(
            Q.SetAccessorCannotHaveRestParameter, this.state.curPosition());
          }
          a[l] && this.raise(Q.SetAccessorCannotHaveReturnType, a[l]);
        } else
          a.kind = "method";
        return this.finishNode(a, "TSMethodSignature");
      } else {
        let a = n;
        i && (a.readonly = !0);
        let o = this.tsTryParseTypeAnnotation();
        return o && (a.typeAnnotation = o), this.tsParseTypeMemberSemicolon(), this.finishNode(a, "TSPropertySignature");
      }
    }
    tsParseTypeMember() {
      let r = this.startNode();
      if (this.match(10) || this.match(47))
        return this.tsParseSignatureMember("TSCallSignatureDeclaration", r);
      if (this.match(77)) {
        let n = this.startNode();
        return this.next(), this.match(10) || this.match(47) ? this.tsParseSignatureMember("TSConstructSignatureDeclaration", r) : (r.key = this.
        createIdentifier(n, "new"), this.tsParsePropertyOrMethodSignature(r, !1));
      }
      this.tsParseModifiers({
        allowedModifiers: ["readonly"],
        disallowedModifiers: ["declare", "abstract", "private", "protected", "public", "static", "override"]
      }, r);
      let i = this.tsTryParseIndexSignature(r);
      return i || (super.parsePropertyName(r), !r.computed && r.key.type === "Identifier" && (r.key.name === "get" || r.key.name === "set") &&
      this.tsTokenCanFollowModifier() && (r.kind = r.key.name, super.parsePropertyName(r)), this.tsParsePropertyOrMethodSignature(r, !!r.readonly));
    }
    tsParseTypeLiteral() {
      let r = this.startNode();
      return r.members = this.tsParseObjectTypeMembers(), this.finishNode(r, "TSTypeLiteral");
    }
    tsParseObjectTypeMembers() {
      this.expect(5);
      let r = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
      return this.expect(8), r;
    }
    tsIsStartOfMappedType() {
      return this.next(), this.eat(53) ? this.isContextual(122) : (this.isContextual(122) && this.next(), !this.match(0) || (this.next(), !this.
      tsIsIdentifier()) ? !1 : (this.next(), this.match(58)));
    }
    tsParseMappedType() {
      let r = this.startNode();
      this.expect(5), this.match(53) ? (r.readonly = this.state.value, this.next(), this.expectContextual(122)) : this.eatContextual(122) &&
      (r.readonly = !0), this.expect(0);
      {
        let i = this.startNode();
        i.name = this.tsParseTypeParameterName(), i.constraint = this.tsExpectThenParseType(58), r.typeParameter = this.finishNode(i, "TSTyp\
eParameter");
      }
      return r.nameType = this.eatContextual(93) ? this.tsParseType() : null, this.expect(3), this.match(53) ? (r.optional = this.state.value,
      this.next(), this.expect(17)) : this.eat(17) && (r.optional = !0), r.typeAnnotation = this.tsTryParseType(), this.semicolon(), this.expect(
      8), this.finishNode(r, "TSMappedType");
    }
    tsParseTupleType() {
      let r = this.startNode();
      r.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), !0, !1);
      let i = !1;
      return r.elementTypes.forEach((n) => {
        let {
          type: a
        } = n;
        i && a !== "TSRestType" && a !== "TSOptionalType" && !(a === "TSNamedTupleMember" && n.optional) && this.raise(Q.OptionalTypeBeforeRequired,
        n), i || (i = a === "TSNamedTupleMember" && n.optional || a === "TSOptionalType");
      }), this.finishNode(r, "TSTupleType");
    }
    tsParseTupleElementType() {
      let r = this.state.startLoc, i = this.eat(21), {
        startLoc: n
      } = this.state, a, o, l, u, m = mt(this.state.type) ? this.lookaheadCharCode() : null;
      if (m === 58)
        a = !0, l = !1, o = this.parseIdentifier(!0), this.expect(14), u = this.tsParseType();
      else if (m === 63) {
        l = !0;
        let g = this.state.value, I = this.tsParseNonArrayType();
        this.lookaheadCharCode() === 58 ? (a = !0, o = this.createIdentifier(this.startNodeAt(n), g), this.expect(17), this.expect(14), u = this.
        tsParseType()) : (a = !1, u = I, this.expect(17));
      } else
        u = this.tsParseType(), l = this.eat(17), a = this.eat(14);
      if (a) {
        let g;
        o ? (g = this.startNodeAt(n), g.optional = l, g.label = o, g.elementType = u, this.eat(17) && (g.optional = !0, this.raise(Q.TupleOptionalAfterType,
        this.state.lastTokStartLoc))) : (g = this.startNodeAt(n), g.optional = l, this.raise(Q.InvalidTupleMemberLabel, u), g.label = u, g.elementType =
        this.tsParseType()), u = this.finishNode(g, "TSNamedTupleMember");
      } else if (l) {
        let g = this.startNodeAt(n);
        g.typeAnnotation = u, u = this.finishNode(g, "TSOptionalType");
      }
      if (i) {
        let g = this.startNodeAt(r);
        g.typeAnnotation = u, u = this.finishNode(g, "TSRestType");
      }
      return u;
    }
    tsParseParenthesizedType() {
      let r = this.startNode();
      return this.expect(10), r.typeAnnotation = this.tsParseType(), this.expect(11), this.finishNode(r, "TSParenthesizedType");
    }
    tsParseFunctionOrConstructorType(r, i) {
      let n = this.startNode();
      return r === "TSConstructorType" && (n.abstract = !!i, i && this.next(), this.next()), this.tsInAllowConditionalTypesContext(() => this.
      tsFillSignature(19, n)), this.finishNode(n, r);
    }
    tsParseLiteralTypeNode() {
      let r = this.startNode();
      switch (this.state.type) {
        case 135:
        case 136:
        case 134:
        case 85:
        case 86:
          r.literal = super.parseExprAtom();
          break;
        default:
          this.unexpected();
      }
      return this.finishNode(r, "TSLiteralType");
    }
    tsParseTemplateLiteralType() {
      {
        let r = this.startNode();
        return r.literal = super.parseTemplate(!1), this.finishNode(r, "TSLiteralType");
      }
    }
    parseTemplateSubstitution() {
      return this.state.inType ? this.tsParseType() : super.parseTemplateSubstitution();
    }
    tsParseThisTypeOrThisTypePredicate() {
      let r = this.tsParseThisTypeNode();
      return this.isContextual(116) && !this.hasPrecedingLineBreak() ? this.tsParseThisTypePredicate(r) : r;
    }
    tsParseNonArrayType() {
      switch (this.state.type) {
        case 134:
        case 135:
        case 136:
        case 85:
        case 86:
          return this.tsParseLiteralTypeNode();
        case 53:
          if (this.state.value === "-") {
            let r = this.startNode(), i = this.lookahead();
            return i.type !== 135 && i.type !== 136 && this.unexpected(), r.literal = this.parseMaybeUnary(), this.finishNode(r, "TSLiteralT\
ype");
          }
          break;
        case 78:
          return this.tsParseThisTypeOrThisTypePredicate();
        case 87:
          return this.tsParseTypeQuery();
        case 83:
          return this.tsParseImportType();
        case 5:
          return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
        case 0:
          return this.tsParseTupleType();
        case 10:
          return this.tsParseParenthesizedType();
        case 25:
        case 24:
          return this.tsParseTemplateLiteralType();
        default: {
          let {
            type: r
          } = this.state;
          if (ve(r) || r === 88 || r === 84) {
            let i = r === 88 ? "TSVoidKeyword" : r === 84 ? "TSNullKeyword" : uB(this.state.value);
            if (i !== void 0 && this.lookaheadCharCode() !== 46) {
              let n = this.startNode();
              return this.next(), this.finishNode(n, i);
            }
            return this.tsParseTypeReference();
          }
        }
      }
      this.unexpected();
    }
    tsParseArrayTypeOrHigher() {
      let {
        startLoc: r
      } = this.state, i = this.tsParseNonArrayType();
      for (; !this.hasPrecedingLineBreak() && this.eat(0); )
        if (this.match(3)) {
          let n = this.startNodeAt(r);
          n.elementType = i, this.expect(3), i = this.finishNode(n, "TSArrayType");
        } else {
          let n = this.startNodeAt(r);
          n.objectType = i, n.indexType = this.tsParseType(), this.expect(3), i = this.finishNode(n, "TSIndexedAccessType");
        }
      return i;
    }
    tsParseTypeOperator() {
      let r = this.startNode(), i = this.state.value;
      return this.next(), r.operator = i, r.typeAnnotation = this.tsParseTypeOperatorOrHigher(), i === "readonly" && this.tsCheckTypeAnnotationForReadOnly(
      r), this.finishNode(r, "TSTypeOperator");
    }
    tsCheckTypeAnnotationForReadOnly(r) {
      switch (r.typeAnnotation.type) {
        case "TSTupleType":
        case "TSArrayType":
          return;
        default:
          this.raise(Q.UnexpectedReadonly, r);
      }
    }
    tsParseInferType() {
      let r = this.startNode();
      this.expectContextual(115);
      let i = this.startNode();
      return i.name = this.tsParseTypeParameterName(), i.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType()), r.typeParameter =
      this.finishNode(i, "TSTypeParameter"), this.finishNode(r, "TSInferType");
    }
    tsParseConstraintForInferType() {
      if (this.eat(81)) {
        let r = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
        if (this.state.inDisallowConditionalTypesContext || !this.match(17))
          return r;
      }
    }
    tsParseTypeOperatorOrHigher() {
      return N3(this.state.type) && !this.state.containsEsc ? this.tsParseTypeOperator() : this.isContextual(115) ? this.tsParseInferType() :
      this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
    }
    tsParseUnionOrIntersectionType(r, i, n) {
      let a = this.startNode(), o = this.eat(n), l = [];
      do
        l.push(i());
      while (this.eat(n));
      return l.length === 1 && !o ? l[0] : (a.types = l, this.finishNode(a, r));
    }
    tsParseIntersectionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
    }
    tsParseUnionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
    }
    tsIsStartOfFunctionType() {
      return this.match(47) ? !0 : this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
    }
    tsSkipParameterStart() {
      if (ve(this.state.type) || this.match(78))
        return this.next(), !0;
      if (this.match(5)) {
        let {
          errors: r
        } = this.state, i = r.length;
        try {
          return this.parseObjectLike(8, !0), r.length === i;
        } catch {
          return !1;
        }
      }
      if (this.match(0)) {
        this.next();
        let {
          errors: r
        } = this.state, i = r.length;
        try {
          return super.parseBindingList(3, 93, 1), r.length === i;
        } catch {
          return !1;
        }
      }
      return !1;
    }
    tsIsUnambiguouslyStartOfFunctionType() {
      return this.next(), !!(this.match(11) || this.match(21) || this.tsSkipParameterStart() && (this.match(14) || this.match(12) || this.match(
      17) || this.match(29) || this.match(11) && (this.next(), this.match(19))));
    }
    tsParseTypeOrTypePredicateAnnotation(r) {
      return this.tsInType(() => {
        let i = this.startNode();
        this.expect(r);
        let n = this.startNode(), a = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
        if (a && this.match(78)) {
          let u = this.tsParseThisTypeOrThisTypePredicate();
          return u.type === "TSThisType" ? (n.parameterName = u, n.asserts = !0, n.typeAnnotation = null, u = this.finishNode(n, "TSTypePred\
icate")) : (this.resetStartLocationFromNode(u, n), u.asserts = !0), i.typeAnnotation = u, this.finishNode(i, "TSTypeAnnotation");
        }
        let o = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
        if (!o)
          return a ? (n.parameterName = this.parseIdentifier(), n.asserts = a, n.typeAnnotation = null, i.typeAnnotation = this.finishNode(n,
          "TSTypePredicate"), this.finishNode(i, "TSTypeAnnotation")) : this.tsParseTypeAnnotation(!1, i);
        let l = this.tsParseTypeAnnotation(!1);
        return n.parameterName = o, n.typeAnnotation = l, n.asserts = a, i.typeAnnotation = this.finishNode(n, "TSTypePredicate"), this.finishNode(
        i, "TSTypeAnnotation");
      });
    }
    tsTryParseTypeOrTypePredicateAnnotation() {
      if (this.match(14))
        return this.tsParseTypeOrTypePredicateAnnotation(14);
    }
    tsTryParseTypeAnnotation() {
      if (this.match(14))
        return this.tsParseTypeAnnotation();
    }
    tsTryParseType() {
      return this.tsEatThenParseType(14);
    }
    tsParseTypePredicatePrefix() {
      let r = this.parseIdentifier();
      if (this.isContextual(116) && !this.hasPrecedingLineBreak())
        return this.next(), r;
    }
    tsParseTypePredicateAsserts() {
      if (this.state.type !== 109)
        return !1;
      let r = this.state.containsEsc;
      return this.next(), !ve(this.state.type) && !this.match(78) ? !1 : (r && this.raise(P.InvalidEscapedReservedWord, this.state.lastTokStartLoc,
      {
        reservedWord: "asserts"
      }), !0);
    }
    tsParseTypeAnnotation(r = !0, i = this.startNode()) {
      return this.tsInType(() => {
        r && this.expect(14), i.typeAnnotation = this.tsParseType();
      }), this.finishNode(i, "TSTypeAnnotation");
    }
    tsParseType() {
      Zc(this.state.inType);
      let r = this.tsParseNonConditionalType();
      if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81))
        return r;
      let i = this.startNodeAtNode(r);
      return i.checkType = r, i.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType()), this.expect(
      17), i.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.expect(14), i.falseType = this.tsInAllowConditionalTypesContext(
      () => this.tsParseType()), this.finishNode(i, "TSConditionalType");
    }
    isAbstractConstructorSignature() {
      return this.isContextual(124) && this.lookahead().type === 77;
    }
    tsParseNonConditionalType() {
      return this.tsIsStartOfFunctionType() ? this.tsParseFunctionOrConstructorType("TSFunctionType") : this.match(77) ? this.tsParseFunctionOrConstructorType(
      "TSConstructorType") : this.isAbstractConstructorSignature() ? this.tsParseFunctionOrConstructorType("TSConstructorType", !0) : this.tsParseUnionTypeOrHigher();
    }
    tsParseTypeAssertion() {
      this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(Q.ReservedTypeAssertion, this.state.startLoc);
      let r = this.startNode();
      return r.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? this.tsParseTypeReference() : this.tsParseType())), this.
      expect(48), r.expression = this.parseMaybeUnary(), this.finishNode(r, "TSTypeAssertion");
    }
    tsParseHeritageClause(r) {
      let i = this.state.startLoc, n = this.tsParseDelimitedList("HeritageClauseElement", () => {
        {
          let a = this.startNode();
          return a.expression = this.tsParseEntityName(3), this.match(47) && (a.typeParameters = this.tsParseTypeArguments()), this.finishNode(
          a, "TSExpressionWithTypeArguments");
        }
      });
      return n.length || this.raise(Q.EmptyHeritageClauseType, i, {
        token: r
      }), n;
    }
    tsParseInterfaceDeclaration(r, i = {}) {
      if (this.hasFollowingLineBreak()) return null;
      this.expectContextual(129), i.declare && (r.declare = !0), ve(this.state.type) ? (r.id = this.parseIdentifier(), this.checkIdentifier(
      r.id, 130)) : (r.id = null, this.raise(Q.MissingInterfaceName, this.state.startLoc)), r.typeParameters = this.tsTryParseTypeParameters(
      this.tsParseInOutConstModifiers), this.eat(81) && (r.extends = this.tsParseHeritageClause("extends"));
      let n = this.startNode();
      return n.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this)), r.body = this.finishNode(n, "TSInterfaceBody"), this.finishNode(
      r, "TSInterfaceDeclaration");
    }
    tsParseTypeAliasDeclaration(r) {
      return r.id = this.parseIdentifier(), this.checkIdentifier(r.id, 2), r.typeAnnotation = this.tsInType(() => {
        if (r.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers), this.expect(29), this.isContextual(114) && this.lookahead().
        type !== 16) {
          let i = this.startNode();
          return this.next(), this.finishNode(i, "TSIntrinsicKeyword");
        }
        return this.tsParseType();
      }), this.semicolon(), this.finishNode(r, "TSTypeAliasDeclaration");
    }
    tsInTopLevelContext(r) {
      if (this.curContext() !== Ie.brace) {
        let i = this.state.context;
        this.state.context = [i[0]];
        try {
          return r();
        } finally {
          this.state.context = i;
        }
      } else
        return r();
    }
    tsInType(r) {
      let i = this.state.inType;
      this.state.inType = !0;
      try {
        return r();
      } finally {
        this.state.inType = i;
      }
    }
    tsInDisallowConditionalTypesContext(r) {
      let i = this.state.inDisallowConditionalTypesContext;
      this.state.inDisallowConditionalTypesContext = !0;
      try {
        return r();
      } finally {
        this.state.inDisallowConditionalTypesContext = i;
      }
    }
    tsInAllowConditionalTypesContext(r) {
      let i = this.state.inDisallowConditionalTypesContext;
      this.state.inDisallowConditionalTypesContext = !1;
      try {
        return r();
      } finally {
        this.state.inDisallowConditionalTypesContext = i;
      }
    }
    tsEatThenParseType(r) {
      if (this.match(r))
        return this.tsNextThenParseType();
    }
    tsExpectThenParseType(r) {
      return this.tsInType(() => (this.expect(r), this.tsParseType()));
    }
    tsNextThenParseType() {
      return this.tsInType(() => (this.next(), this.tsParseType()));
    }
    tsParseEnumMember() {
      let r = this.startNode();
      return r.id = this.match(134) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(!0), this.eat(29) && (r.initializer =
      super.parseMaybeAssignAllowIn()), this.finishNode(r, "TSEnumMember");
    }
    tsParseEnumDeclaration(r, i = {}) {
      return i.const && (r.const = !0), i.declare && (r.declare = !0), this.expectContextual(126), r.id = this.parseIdentifier(), this.checkIdentifier(
      r.id, r.const ? 8971 : 8459), this.expect(5), r.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)),
      this.expect(8), this.finishNode(r, "TSEnumDeclaration");
    }
    tsParseEnumBody() {
      let r = this.startNode();
      return this.expect(5), r.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)), this.expect(8), this.finishNode(
      r, "TSEnumBody");
    }
    tsParseModuleBlock() {
      let r = this.startNode();
      return this.scope.enter(0), this.expect(5), super.parseBlockOrModuleBlockBody(r.body = [], void 0, !0, 8), this.scope.exit(), this.finishNode(
      r, "TSModuleBlock");
    }
    tsParseModuleOrNamespaceDeclaration(r, i = !1) {
      if (r.id = this.parseIdentifier(), i || this.checkIdentifier(r.id, 1024), this.eat(16)) {
        let n = this.startNode();
        this.tsParseModuleOrNamespaceDeclaration(n, !0), r.body = n;
      } else
        this.scope.enter(256), this.prodParam.enter(0), r.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit();
      return this.finishNode(r, "TSModuleDeclaration");
    }
    tsParseAmbientExternalModuleDeclaration(r) {
      return this.isContextual(112) ? (r.kind = "global", r.global = !0, r.id = this.parseIdentifier()) : this.match(134) ? (r.kind = "modul\
e", r.id = super.parseStringLiteral(this.state.value)) : this.unexpected(), this.match(5) ? (this.scope.enter(256), this.prodParam.enter(0),
      r.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit()) : this.semicolon(), this.finishNode(r, "TSModuleDeclarat\
ion");
    }
    tsParseImportEqualsDeclaration(r, i, n) {
      r.isExport = n || !1, r.id = i || this.parseIdentifier(), this.checkIdentifier(r.id, 4096), this.expect(29);
      let a = this.tsParseModuleReference();
      return r.importKind === "type" && a.type !== "TSExternalModuleReference" && this.raise(Q.ImportAliasHasImportType, a), r.moduleReference =
      a, this.semicolon(), this.finishNode(r, "TSImportEqualsDeclaration");
    }
    tsIsExternalModuleReference() {
      return this.isContextual(119) && this.lookaheadCharCode() === 40;
    }
    tsParseModuleReference() {
      return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(0);
    }
    tsParseExternalModuleReference() {
      let r = this.startNode();
      return this.expectContextual(119), this.expect(10), this.match(134) || this.unexpected(), r.expression = super.parseExprAtom(), this.expect(
      11), this.sawUnambiguousESM = !0, this.finishNode(r, "TSExternalModuleReference");
    }
    tsLookAhead(r) {
      let i = this.state.clone(), n = r();
      return this.state = i, n;
    }
    tsTryParseAndCatch(r) {
      let i = this.tryParse((n) => r() || n());
      if (!(i.aborted || !i.node))
        return i.error && (this.state = i.failState), i.node;
    }
    tsTryParse(r) {
      let i = this.state.clone(), n = r();
      if (n !== void 0 && n !== !1)
        return n;
      this.state = i;
    }
    tsTryParseDeclare(r) {
      if (this.isLineTerminator())
        return;
      let i = this.state.type, n;
      return this.isContextual(100) && (i = 74, n = "let"), this.tsInAmbientContext(() => {
        switch (i) {
          case 68:
            return r.declare = !0, super.parseFunctionStatement(r, !1, !1);
          case 80:
            return r.declare = !0, this.parseClass(r, !0, !1);
          case 126:
            return this.tsParseEnumDeclaration(r, {
              declare: !0
            });
          case 112:
            return this.tsParseAmbientExternalModuleDeclaration(r);
          case 75:
          case 74:
            return !this.match(75) || !this.isLookaheadContextual("enum") ? (r.declare = !0, this.parseVarStatement(r, n || this.state.value,
            !0)) : (this.expect(75), this.tsParseEnumDeclaration(r, {
              const: !0,
              declare: !0
            }));
          case 129: {
            let a = this.tsParseInterfaceDeclaration(r, {
              declare: !0
            });
            if (a) return a;
          }
          default:
            if (ve(i))
              return this.tsParseDeclaration(r, this.state.value, !0, null);
        }
      });
    }
    tsTryParseExportDeclaration() {
      return this.tsParseDeclaration(this.startNode(), this.state.value, !0, null);
    }
    tsParseExpressionStatement(r, i, n) {
      switch (i.name) {
        case "declare": {
          let a = this.tsTryParseDeclare(r);
          return a && (a.declare = !0), a;
        }
        case "global":
          if (this.match(5)) {
            this.scope.enter(256), this.prodParam.enter(0);
            let a = r;
            return a.kind = "global", r.global = !0, a.id = i, a.body = this.tsParseModuleBlock(), this.scope.exit(), this.prodParam.exit(),
            this.finishNode(a, "TSModuleDeclaration");
          }
          break;
        default:
          return this.tsParseDeclaration(r, i.name, !1, n);
      }
    }
    tsParseDeclaration(r, i, n, a) {
      switch (i) {
        case "abstract":
          if (this.tsCheckLineTerminator(n) && (this.match(80) || ve(this.state.type)))
            return this.tsParseAbstractDeclaration(r, a);
          break;
        case "module":
          if (this.tsCheckLineTerminator(n)) {
            if (this.match(134))
              return this.tsParseAmbientExternalModuleDeclaration(r);
            if (ve(this.state.type))
              return r.kind = "module", this.tsParseModuleOrNamespaceDeclaration(r);
          }
          break;
        case "namespace":
          if (this.tsCheckLineTerminator(n) && ve(this.state.type))
            return r.kind = "namespace", this.tsParseModuleOrNamespaceDeclaration(r);
          break;
        case "type":
          if (this.tsCheckLineTerminator(n) && ve(this.state.type))
            return this.tsParseTypeAliasDeclaration(r);
          break;
      }
    }
    tsCheckLineTerminator(r) {
      return r ? this.hasFollowingLineBreak() ? !1 : (this.next(), !0) : !this.isLineTerminator();
    }
    tsTryParseGenericAsyncArrowFunction(r) {
      if (!this.match(47)) return;
      let i = this.state.maybeInArrowParameters;
      this.state.maybeInArrowParameters = !0;
      let n = this.tsTryParseAndCatch(() => {
        let a = this.startNodeAt(r);
        return a.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier), super.parseFunctionParams(a), a.returnType = this.tsTryParseTypeOrTypePredicateAnnotation(),
        this.expect(19), a;
      });
      if (this.state.maybeInArrowParameters = i, !!n)
        return super.parseArrowExpression(n, null, !0);
    }
    tsParseTypeArgumentsInExpression() {
      if (this.reScan_lt() === 47)
        return this.tsParseTypeArguments();
    }
    tsParseTypeArguments() {
      let r = this.startNode();
      return r.params = this.tsInType(() => this.tsInTopLevelContext(() => (this.expect(47), this.tsParseDelimitedList("TypeParametersOrArgu\
ments", this.tsParseType.bind(this))))), r.params.length === 0 ? this.raise(Q.EmptyTypeArguments, r) : !this.state.inType && this.curContext() ===
      Ie.brace && this.reScan_lt_gt(), this.expect(48), this.finishNode(r, "TSTypeParameterInstantiation");
    }
    tsIsDeclarationStart() {
      return O3(this.state.type);
    }
    isExportDefaultSpecifier() {
      return this.tsIsDeclarationStart() ? !1 : super.isExportDefaultSpecifier();
    }
    parseBindingElement(r, i) {
      let n = this.state.startLoc, a = {};
      this.tsParseModifiers({
        allowedModifiers: ["public", "private", "protected", "override", "readonly"]
      }, a);
      let o = a.accessibility, l = a.override, u = a.readonly;
      !(r & 4) && (o || u || l) && this.raise(Q.UnexpectedParameterModifier, n);
      let p = this.parseMaybeDefault();
      r & 2 && this.parseFunctionParamType(p);
      let m = this.parseMaybeDefault(p.loc.start, p);
      if (o || u || l) {
        let g = this.startNodeAt(n);
        return i.length && (g.decorators = i), o && (g.accessibility = o), u && (g.readonly = u), l && (g.override = l), m.type !== "Identif\
ier" && m.type !== "AssignmentPattern" && this.raise(Q.UnsupportedParameterPropertyKind, g), g.parameter = m, this.finishNode(g, "TSParamete\
rProperty");
      }
      return i.length && (p.decorators = i), m;
    }
    isSimpleParameter(r) {
      return r.type === "TSParameterProperty" && super.isSimpleParameter(r.parameter) || super.isSimpleParameter(r);
    }
    tsDisallowOptionalPattern(r) {
      for (let i of r.params)
        i.type !== "Identifier" && i.optional && !this.state.isAmbientContext && this.raise(Q.PatternIsOptional, i);
    }
    setArrowFunctionParameters(r, i, n) {
      super.setArrowFunctionParameters(r, i, n), this.tsDisallowOptionalPattern(r);
    }
    parseFunctionBodyAndFinish(r, i, n = !1) {
      this.match(14) && (r.returnType = this.tsParseTypeOrTypePredicateAnnotation(14));
      let a = i === "FunctionDeclaration" ? "TSDeclareFunction" : i === "ClassMethod" || i === "ClassPrivateMethod" ? "TSDeclareMethod" : void 0;
      return a && !this.match(5) && this.isLineTerminator() ? this.finishNode(r, a) : a === "TSDeclareFunction" && this.state.isAmbientContext &&
      (this.raise(Q.DeclareFunctionHasImplementation, r), r.declare) ? super.parseFunctionBodyAndFinish(r, a, n) : (this.tsDisallowOptionalPattern(
      r), super.parseFunctionBodyAndFinish(r, i, n));
    }
    registerFunctionStatementId(r) {
      !r.body && r.id ? this.checkIdentifier(r.id, 1024) : super.registerFunctionStatementId(r);
    }
    tsCheckForInvalidTypeCasts(r) {
      r.forEach((i) => {
        i?.type === "TSTypeCastExpression" && this.raise(Q.UnexpectedTypeAnnotation, i.typeAnnotation);
      });
    }
    toReferencedList(r, i) {
      return this.tsCheckForInvalidTypeCasts(r), r;
    }
    parseArrayLike(r, i, n, a) {
      let o = super.parseArrayLike(r, i, n, a);
      return o.type === "ArrayExpression" && this.tsCheckForInvalidTypeCasts(o.elements), o;
    }
    parseSubscript(r, i, n, a) {
      if (!this.hasPrecedingLineBreak() && this.match(35)) {
        this.state.canStartJSXElement = !1, this.next();
        let l = this.startNodeAt(i);
        return l.expression = r, this.finishNode(l, "TSNonNullExpression");
      }
      let o = !1;
      if (this.match(18) && this.lookaheadCharCode() === 60) {
        if (n)
          return a.stop = !0, r;
        a.optionalChainMember = o = !0, this.next();
      }
      if (this.match(47) || this.match(51)) {
        let l, u = this.tsTryParseAndCatch(() => {
          if (!n && this.atPossibleAsyncArrow(r)) {
            let I = this.tsTryParseGenericAsyncArrowFunction(i);
            if (I)
              return I;
          }
          let p = this.tsParseTypeArgumentsInExpression();
          if (!p) return;
          if (o && !this.match(10)) {
            l = this.state.curPosition();
            return;
          }
          if (Gi(this.state.type)) {
            let I = super.parseTaggedTemplateExpression(r, i, a);
            return I.typeParameters = p, I;
          }
          if (!n && this.eat(10)) {
            let I = this.startNodeAt(i);
            return I.callee = r, I.arguments = this.parseCallExpressionArguments(11), this.tsCheckForInvalidTypeCasts(I.arguments), I.typeParameters =
            p, a.optionalChainMember && (I.optional = o), this.finishCallExpression(I, a.optionalChainMember);
          }
          let m = this.state.type;
          if (m === 48 || m === 52 || m !== 10 && Jr(m) && !this.hasPrecedingLineBreak())
            return;
          let g = this.startNodeAt(i);
          return g.expression = r, g.typeParameters = p, this.finishNode(g, "TSInstantiationExpression");
        });
        if (l && this.unexpected(l, 10), u)
          return u.type === "TSInstantiationExpression" && (this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40) && this.raise(
          Q.InvalidPropertyAccessAfterInstantiationExpression, this.state.startLoc), u;
      }
      return super.parseSubscript(r, i, n, a);
    }
    parseNewCallee(r) {
      var i;
      super.parseNewCallee(r);
      let {
        callee: n
      } = r;
      n.type === "TSInstantiationExpression" && !((i = n.extra) != null && i.parenthesized) && (r.typeParameters = n.typeParameters, r.callee =
      n.expression);
    }
    parseExprOp(r, i, n) {
      let a;
      if (zi(58) > n && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (a = this.isContextual(120)))) {
        let o = this.startNodeAt(i);
        return o.expression = r, o.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? (a && this.raise(P.UnexpectedKeyword,
        this.state.startLoc, {
          keyword: "const"
        }), this.tsParseTypeReference()) : this.tsParseType())), this.finishNode(o, a ? "TSSatisfiesExpression" : "TSAsExpression"), this.reScan_lt_gt(),
        this.parseExprOp(o, i, n);
      }
      return super.parseExprOp(r, i, n);
    }
    checkReservedWord(r, i, n, a) {
      this.state.isAmbientContext || super.checkReservedWord(r, i, n, a);
    }
    checkImportReflection(r) {
      super.checkImportReflection(r), r.module && r.importKind !== "value" && this.raise(Q.ImportReflectionHasImportType, r.specifiers[0].loc.
      start);
    }
    checkDuplicateExports() {
    }
    isPotentialImportPhase(r) {
      if (super.isPotentialImportPhase(r)) return !0;
      if (this.isContextual(130)) {
        let i = this.lookaheadCharCode();
        return r ? i === 123 || i === 42 : i !== 61;
      }
      return !r && this.isContextual(87);
    }
    applyImportPhase(r, i, n, a) {
      super.applyImportPhase(r, i, n, a), i ? r.exportKind = n === "type" ? "type" : "value" : r.importKind = n === "type" || n === "typeof" ?
      n : "value";
    }
    parseImport(r) {
      if (this.match(134))
        return r.importKind = "value", super.parseImport(r);
      let i;
      if (ve(this.state.type) && this.lookaheadCharCode() === 61)
        return r.importKind = "value", this.tsParseImportEqualsDeclaration(r);
      if (this.isContextual(130)) {
        let n = this.parseMaybeImportPhase(r, !1);
        if (this.lookaheadCharCode() === 61)
          return this.tsParseImportEqualsDeclaration(r, n);
        i = super.parseImportSpecifiersAndAfter(r, n);
      } else
        i = super.parseImport(r);
      return i.importKind === "type" && i.specifiers.length > 1 && i.specifiers[0].type === "ImportDefaultSpecifier" && this.raise(Q.TypeImportCannotSpecifyDefaultAndNamed,
      i), i;
    }
    parseExport(r, i) {
      if (this.match(83)) {
        let n = r;
        this.next();
        let a = null;
        return this.isContextual(130) && this.isPotentialImportPhase(!1) ? a = this.parseMaybeImportPhase(n, !1) : n.importKind = "value", this.
        tsParseImportEqualsDeclaration(n, a, !0);
      } else if (this.eat(29)) {
        let n = r;
        return n.expression = super.parseExpression(), this.semicolon(), this.sawUnambiguousESM = !0, this.finishNode(n, "TSExportAssignment");
      } else if (this.eatContextual(93)) {
        let n = r;
        return this.expectContextual(128), n.id = this.parseIdentifier(), this.semicolon(), this.finishNode(n, "TSNamespaceExportDeclaration");
      } else
        return super.parseExport(r, i);
    }
    isAbstractClass() {
      return this.isContextual(124) && this.lookahead().type === 80;
    }
    parseExportDefaultExpression() {
      if (this.isAbstractClass()) {
        let r = this.startNode();
        return this.next(), r.abstract = !0, this.parseClass(r, !0, !0);
      }
      if (this.match(129)) {
        let r = this.tsParseInterfaceDeclaration(this.startNode());
        if (r) return r;
      }
      return super.parseExportDefaultExpression();
    }
    parseVarStatement(r, i, n = !1) {
      let {
        isAmbientContext: a
      } = this.state, o = super.parseVarStatement(r, i, n || a);
      if (!a) return o;
      for (let {
        id: l,
        init: u
      } of o.declarations)
        u && (i !== "const" || l.typeAnnotation ? this.raise(Q.InitializerNotAllowedInAmbientContext, u) : hB(u, this.hasPlugin("estree")) ||
        this.raise(Q.ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference, u));
      return o;
    }
    parseStatementContent(r, i) {
      if (this.match(75) && this.isLookaheadContextual("enum")) {
        let n = this.startNode();
        return this.expect(75), this.tsParseEnumDeclaration(n, {
          const: !0
        });
      }
      if (this.isContextual(126))
        return this.tsParseEnumDeclaration(this.startNode());
      if (this.isContextual(129)) {
        let n = this.tsParseInterfaceDeclaration(this.startNode());
        if (n) return n;
      }
      return super.parseStatementContent(r, i);
    }
    parseAccessModifier() {
      return this.tsParseModifier(["public", "protected", "private"]);
    }
    tsHasSomeModifiers(r, i) {
      return i.some((n) => ep(n) ? r.accessibility === n : !!r[n]);
    }
    tsIsStartOfStaticBlocks() {
      return this.isContextual(106) && this.lookaheadCharCode() === 123;
    }
    parseClassMember(r, i, n) {
      let a = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
      this.tsParseModifiers({
        allowedModifiers: a,
        disallowedModifiers: ["in", "out"],
        stopOnStartOfClassStaticBlock: !0,
        errorTemplate: Q.InvalidModifierOnTypeParameterPositions
      }, i);
      let o = /* @__PURE__ */ s(() => {
        this.tsIsStartOfStaticBlocks() ? (this.next(), this.next(), this.tsHasSomeModifiers(i, a) && this.raise(Q.StaticBlockCannotHaveModifier,
        this.state.curPosition()), super.parseClassStaticBlock(r, i)) : this.parseClassMemberWithIsStatic(r, i, n, !!i.static);
      }, "callParseClassMemberWithIsStatic");
      i.declare ? this.tsInAmbientContext(o) : o();
    }
    parseClassMemberWithIsStatic(r, i, n, a) {
      let o = this.tsTryParseIndexSignature(i);
      if (o) {
        r.body.push(o), i.abstract && this.raise(Q.IndexSignatureHasAbstract, i), i.accessibility && this.raise(Q.IndexSignatureHasAccessibility,
        i, {
          modifier: i.accessibility
        }), i.declare && this.raise(Q.IndexSignatureHasDeclare, i), i.override && this.raise(Q.IndexSignatureHasOverride, i);
        return;
      }
      !this.state.inAbstractClass && i.abstract && this.raise(Q.NonAbstractClassHasAbstractMethod, i), i.override && (n.hadSuperClass || this.
      raise(Q.OverrideNotInSubClass, i)), super.parseClassMemberWithIsStatic(r, i, n, a);
    }
    parsePostMemberNameModifiers(r) {
      this.eat(17) && (r.optional = !0), r.readonly && this.match(10) && this.raise(Q.ClassMethodHasReadonly, r), r.declare && this.match(10) &&
      this.raise(Q.ClassMethodHasDeclare, r);
    }
    parseExpressionStatement(r, i, n) {
      return (i.type === "Identifier" ? this.tsParseExpressionStatement(r, i, n) : void 0) || super.parseExpressionStatement(r, i, n);
    }
    shouldParseExportDeclaration() {
      return this.tsIsDeclarationStart() ? !0 : super.shouldParseExportDeclaration();
    }
    parseConditional(r, i, n) {
      if (!this.match(17)) return r;
      if (this.state.maybeInArrowParameters) {
        let a = this.lookaheadCharCode();
        if (a === 44 || a === 61 || a === 58 || a === 41)
          return this.setOptionalParametersError(n), r;
      }
      return super.parseConditional(r, i, n);
    }
    parseParenItem(r, i) {
      let n = super.parseParenItem(r, i);
      if (this.eat(17) && (n.optional = !0, this.resetEndLocation(r)), this.match(14)) {
        let a = this.startNodeAt(i);
        return a.expression = r, a.typeAnnotation = this.tsParseTypeAnnotation(), this.finishNode(a, "TSTypeCastExpression");
      }
      return r;
    }
    parseExportDeclaration(r) {
      if (!this.state.isAmbientContext && this.isContextual(125))
        return this.tsInAmbientContext(() => this.parseExportDeclaration(r));
      let i = this.state.startLoc, n = this.eatContextual(125);
      if (n && (this.isContextual(125) || !this.shouldParseExportDeclaration()))
        throw this.raise(Q.ExpectedAmbientAfterExportDeclare, this.state.startLoc);
      let o = ve(this.state.type) && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(r);
      return o ? ((o.type === "TSInterfaceDeclaration" || o.type === "TSTypeAliasDeclaration" || n) && (r.exportKind = "type"), n && o.type !==
      "TSImportEqualsDeclaration" && (this.resetStartLocation(o, i), o.declare = !0), o) : null;
    }
    parseClassId(r, i, n, a) {
      if ((!i || n) && this.isContextual(113))
        return;
      super.parseClassId(r, i, n, r.declare ? 1024 : 8331);
      let o = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
      o && (r.typeParameters = o);
    }
    parseClassPropertyAnnotation(r) {
      r.optional || (this.eat(35) ? r.definite = !0 : this.eat(17) && (r.optional = !0));
      let i = this.tsTryParseTypeAnnotation();
      i && (r.typeAnnotation = i);
    }
    parseClassProperty(r) {
      if (this.parseClassPropertyAnnotation(r), this.state.isAmbientContext && !(r.readonly && !r.typeAnnotation) && this.match(29) && this.
      raise(Q.DeclareClassFieldHasInitializer, this.state.startLoc), r.abstract && this.match(29)) {
        let {
          key: i
        } = r;
        this.raise(Q.AbstractPropertyHasInitializer, this.state.startLoc, {
          propertyName: i.type === "Identifier" && !r.computed ? i.name : `[${this.input.slice(this.offsetToSourcePos(i.start), this.offsetToSourcePos(
          i.end))}]`
        });
      }
      return super.parseClassProperty(r);
    }
    parseClassPrivateProperty(r) {
      return r.abstract && this.raise(Q.PrivateElementHasAbstract, r), r.accessibility && this.raise(Q.PrivateElementHasAccessibility, r, {
        modifier: r.accessibility
      }), this.parseClassPropertyAnnotation(r), super.parseClassPrivateProperty(r);
    }
    parseClassAccessorProperty(r) {
      return this.parseClassPropertyAnnotation(r), r.optional && this.raise(Q.AccessorCannotBeOptional, r), super.parseClassAccessorProperty(
      r);
    }
    pushClassMethod(r, i, n, a, o, l) {
      let u = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      u && o && this.raise(Q.ConstructorHasTypeParameters, u);
      let {
        declare: p = !1,
        kind: m
      } = i;
      p && (m === "get" || m === "set") && this.raise(Q.DeclareAccessor, i, {
        kind: m
      }), u && (i.typeParameters = u), super.pushClassMethod(r, i, n, a, o, l);
    }
    pushClassPrivateMethod(r, i, n, a) {
      let o = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      o && (i.typeParameters = o), super.pushClassPrivateMethod(r, i, n, a);
    }
    declareClassPrivateMethodInScope(r, i) {
      r.type !== "TSDeclareMethod" && (r.type === "MethodDefinition" && !hasOwnProperty.call(r.value, "body") || super.declareClassPrivateMethodInScope(
      r, i));
    }
    parseClassSuper(r) {
      super.parseClassSuper(r), r.superClass && (this.match(47) || this.match(51)) && (r.superTypeParameters = this.tsParseTypeArgumentsInExpression()),
      this.eatContextual(113) && (r.implements = this.tsParseHeritageClause("implements"));
    }
    parseObjPropValue(r, i, n, a, o, l, u) {
      let p = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      return p && (r.typeParameters = p), super.parseObjPropValue(r, i, n, a, o, l, u);
    }
    parseFunctionParams(r, i) {
      let n = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      n && (r.typeParameters = n), super.parseFunctionParams(r, i);
    }
    parseVarId(r, i) {
      super.parseVarId(r, i), r.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.eat(35) && (r.definite = !0);
      let n = this.tsTryParseTypeAnnotation();
      n && (r.id.typeAnnotation = n, this.resetEndLocation(r.id));
    }
    parseAsyncArrowFromCallExpression(r, i) {
      return this.match(14) && (r.returnType = this.tsParseTypeAnnotation()), super.parseAsyncArrowFromCallExpression(r, i);
    }
    parseMaybeAssign(r, i) {
      var n, a, o, l, u;
      let p, m, g;
      if (this.hasPlugin("jsx") && (this.match(143) || this.match(47))) {
        if (p = this.state.clone(), m = this.tryParse(() => super.parseMaybeAssign(r, i), p), !m.error) return m.node;
        let {
          context: _
        } = this.state, V = _[_.length - 1];
        (V === Ie.j_oTag || V === Ie.j_expr) && _.pop();
      }
      if (!((n = m) != null && n.error) && !this.match(47))
        return super.parseMaybeAssign(r, i);
      (!p || p === this.state) && (p = this.state.clone());
      let I, v = this.tryParse((_) => {
        var V, D;
        I = this.tsParseTypeParameters(this.tsParseConstModifier);
        let L = super.parseMaybeAssign(r, i);
        return (L.type !== "ArrowFunctionExpression" || (V = L.extra) != null && V.parenthesized) && _(), ((D = I) == null ? void 0 : D.params.
        length) !== 0 && this.resetStartLocationFromNode(L, I), L.typeParameters = I, L;
      }, p);
      if (!v.error && !v.aborted)
        return I && this.reportReservedArrowTypeParam(I), v.node;
      if (!m && (Zc(!this.hasPlugin("jsx")), g = this.tryParse(() => super.parseMaybeAssign(r, i), p), !g.error))
        return g.node;
      if ((a = m) != null && a.node)
        return this.state = m.failState, m.node;
      if (v.node)
        return this.state = v.failState, I && this.reportReservedArrowTypeParam(I), v.node;
      if ((o = g) != null && o.node)
        return this.state = g.failState, g.node;
      throw ((l = m) == null ? void 0 : l.error) || v.error || ((u = g) == null ? void 0 : u.error);
    }
    reportReservedArrowTypeParam(r) {
      var i;
      r.params.length === 1 && !r.params[0].constraint && !((i = r.extra) != null && i.trailingComma) && this.getPluginOption("typescript", "\
disallowAmbiguousJSXLike") && this.raise(Q.ReservedArrowTypeParam, r);
    }
    parseMaybeUnary(r, i) {
      return !this.hasPlugin("jsx") && this.match(47) ? this.tsParseTypeAssertion() : super.parseMaybeUnary(r, i);
    }
    parseArrow(r) {
      if (this.match(14)) {
        let i = this.tryParse((n) => {
          let a = this.tsParseTypeOrTypePredicateAnnotation(14);
          return (this.canInsertSemicolon() || !this.match(19)) && n(), a;
        });
        if (i.aborted) return;
        i.thrown || (i.error && (this.state = i.failState), r.returnType = i.node);
      }
      return super.parseArrow(r);
    }
    parseFunctionParamType(r) {
      this.eat(17) && (r.optional = !0);
      let i = this.tsTryParseTypeAnnotation();
      return i && (r.typeAnnotation = i), this.resetEndLocation(r), r;
    }
    isAssignable(r, i) {
      switch (r.type) {
        case "TSTypeCastExpression":
          return this.isAssignable(r.expression, i);
        case "TSParameterProperty":
          return !0;
        default:
          return super.isAssignable(r, i);
      }
    }
    toAssignable(r, i = !1) {
      switch (r.type) {
        case "ParenthesizedExpression":
          this.toAssignableParenthesizedExpression(r, i);
          break;
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
          i ? this.expressionScope.recordArrowParameterBindingError(Q.UnexpectedTypeCastInParameter, r) : this.raise(Q.UnexpectedTypeCastInParameter,
          r), this.toAssignable(r.expression, i);
          break;
        case "AssignmentExpression":
          !i && r.left.type === "TSTypeCastExpression" && (r.left = this.typeCastToParameter(r.left));
        default:
          super.toAssignable(r, i);
      }
    }
    toAssignableParenthesizedExpression(r, i) {
      switch (r.expression.type) {
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
        case "ParenthesizedExpression":
          this.toAssignable(r.expression, i);
          break;
        default:
          super.toAssignable(r, i);
      }
    }
    checkToRestConversion(r, i) {
      switch (r.type) {
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
        case "TSNonNullExpression":
          this.checkToRestConversion(r.expression, !1);
          break;
        default:
          super.checkToRestConversion(r, i);
      }
    }
    isValidLVal(r, i, n) {
      switch (r) {
        case "TSTypeCastExpression":
          return !0;
        case "TSParameterProperty":
          return "parameter";
        case "TSNonNullExpression":
          return "expression";
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
          return (n !== 64 || !i) && ["expression", !0];
        default:
          return super.isValidLVal(r, i, n);
      }
    }
    parseBindingAtom() {
      return this.state.type === 78 ? this.parseIdentifier(!0) : super.parseBindingAtom();
    }
    parseMaybeDecoratorArguments(r, i) {
      if (this.match(47) || this.match(51)) {
        let n = this.tsParseTypeArgumentsInExpression();
        if (this.match(10)) {
          let a = super.parseMaybeDecoratorArguments(r, i);
          return a.typeParameters = n, a;
        }
        this.unexpected(null, 10);
      }
      return super.parseMaybeDecoratorArguments(r, i);
    }
    checkCommaAfterRest(r) {
      return this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === r ? (this.next(), !1) : super.checkCommaAfterRest(
      r);
    }
    isClassMethod() {
      return this.match(47) || super.isClassMethod();
    }
    isClassProperty() {
      return this.match(35) || this.match(14) || super.isClassProperty();
    }
    parseMaybeDefault(r, i) {
      let n = super.parseMaybeDefault(r, i);
      return n.type === "AssignmentPattern" && n.typeAnnotation && n.right.start < n.typeAnnotation.start && this.raise(Q.TypeAnnotationAfterAssign,
      n.typeAnnotation), n;
    }
    getTokenFromCode(r) {
      if (this.state.inType) {
        if (r === 62) {
          this.finishOp(48, 1);
          return;
        }
        if (r === 60) {
          this.finishOp(47, 1);
          return;
        }
      }
      super.getTokenFromCode(r);
    }
    reScan_lt_gt() {
      let {
        type: r
      } = this.state;
      r === 47 ? (this.state.pos -= 1, this.readToken_lt()) : r === 48 && (this.state.pos -= 1, this.readToken_gt());
    }
    reScan_lt() {
      let {
        type: r
      } = this.state;
      return r === 51 ? (this.state.pos -= 2, this.finishOp(47, 1), 47) : r;
    }
    toAssignableListItem(r, i, n) {
      let a = r[i];
      a.type === "TSTypeCastExpression" && (r[i] = this.typeCastToParameter(a)), super.toAssignableListItem(r, i, n);
    }
    typeCastToParameter(r) {
      return r.expression.typeAnnotation = r.typeAnnotation, this.resetEndLocation(r.expression, r.typeAnnotation.loc.end), r.expression;
    }
    shouldParseArrow(r) {
      return this.match(14) ? r.every((i) => this.isAssignable(i, !0)) : super.shouldParseArrow(r);
    }
    shouldParseAsyncArrow() {
      return this.match(14) || super.shouldParseAsyncArrow();
    }
    canHaveLeadingDecorator() {
      return super.canHaveLeadingDecorator() || this.isAbstractClass();
    }
    jsxParseOpeningElementAfterName(r) {
      if (this.match(47) || this.match(51)) {
        let i = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
        i && (r.typeParameters = i);
      }
      return super.jsxParseOpeningElementAfterName(r);
    }
    getGetterSetterExpectedParamCount(r) {
      let i = super.getGetterSetterExpectedParamCount(r), a = this.getObjectOrClassMethodParams(r)[0];
      return a && this.isThisParam(a) ? i + 1 : i;
    }
    parseCatchClauseParam() {
      let r = super.parseCatchClauseParam(), i = this.tsTryParseTypeAnnotation();
      return i && (r.typeAnnotation = i, this.resetEndLocation(r)), r;
    }
    tsInAmbientContext(r) {
      let {
        isAmbientContext: i,
        strict: n
      } = this.state;
      this.state.isAmbientContext = !0, this.state.strict = !1;
      try {
        return r();
      } finally {
        this.state.isAmbientContext = i, this.state.strict = n;
      }
    }
    parseClass(r, i, n) {
      let a = this.state.inAbstractClass;
      this.state.inAbstractClass = !!r.abstract;
      try {
        return super.parseClass(r, i, n);
      } finally {
        this.state.inAbstractClass = a;
      }
    }
    tsParseAbstractDeclaration(r, i) {
      if (this.match(80))
        return r.abstract = !0, this.maybeTakeDecorators(i, this.parseClass(r, !0, !1));
      if (this.isContextual(129)) {
        if (!this.hasFollowingLineBreak())
          return r.abstract = !0, this.raise(Q.NonClassMethodPropertyHasAbstractModifer, r), this.tsParseInterfaceDeclaration(r);
      } else
        this.unexpected(null, 80);
    }
    parseMethod(r, i, n, a, o, l, u) {
      let p = super.parseMethod(r, i, n, a, o, l, u);
      if (p.abstract && (this.hasPlugin("estree") ? p.value : p).body) {
        let {
          key: I
        } = p;
        this.raise(Q.AbstractMethodHasImplementation, p, {
          methodName: I.type === "Identifier" && !p.computed ? I.name : `[${this.input.slice(this.offsetToSourcePos(I.start), this.offsetToSourcePos(
          I.end))}]`
        });
      }
      return p;
    }
    tsParseTypeParameterName() {
      return this.parseIdentifier().name;
    }
    shouldParseAsAmbientContext() {
      return !!this.getPluginOption("typescript", "dts");
    }
    parse() {
      return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.parse();
    }
    getExpression() {
      return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.getExpression();
    }
    parseExportSpecifier(r, i, n, a) {
      return !i && a ? (this.parseTypeOnlyImportExportSpecifier(r, !1, n), this.finishNode(r, "ExportSpecifier")) : (r.exportKind = "value",
      super.parseExportSpecifier(r, i, n, a));
    }
    parseImportSpecifier(r, i, n, a, o) {
      return !i && a ? (this.parseTypeOnlyImportExportSpecifier(r, !0, n), this.finishNode(r, "ImportSpecifier")) : (r.importKind = "value",
      super.parseImportSpecifier(r, i, n, a, n ? 4098 : 4096));
    }
    parseTypeOnlyImportExportSpecifier(r, i, n) {
      let a = i ? "imported" : "local", o = i ? "local" : "exported", l = r[a], u, p = !1, m = !0, g = l.loc.start;
      if (this.isContextual(93)) {
        let v = this.parseIdentifier();
        if (this.isContextual(93)) {
          let _ = this.parseIdentifier();
          mt(this.state.type) ? (p = !0, l = v, u = i ? this.parseIdentifier() : this.parseModuleExportName(), m = !1) : (u = _, m = !1);
        } else mt(this.state.type) ? (m = !1, u = i ? this.parseIdentifier() : this.parseModuleExportName()) : (p = !0, l = v);
      } else mt(this.state.type) && (p = !0, i ? (l = this.parseIdentifier(!0), this.isContextual(93) || this.checkReservedWord(l.name, l.loc.
      start, !0, !0)) : l = this.parseModuleExportName());
      p && n && this.raise(i ? Q.TypeModifierIsUsedInTypeImports : Q.TypeModifierIsUsedInTypeExports, g), r[a] = l, r[o] = u;
      let I = i ? "importKind" : "exportKind";
      r[I] = p ? "type" : "value", m && this.eatContextual(93) && (r[o] = i ? this.parseIdentifier() : this.parseModuleExportName()), r[o] ||
      (r[o] = Dt(r[a])), i && this.checkIdentifier(r[o], p ? 4098 : 4096);
    }
  }, "typescript");
  function fB(t) {
    if (t.type !== "MemberExpression") return !1;
    let {
      computed: e,
      property: r
    } = t;
    return e && r.type !== "StringLiteral" && (r.type !== "TemplateLiteral" || r.expressions.length > 0) ? !1 : Sp(t.object);
  }
  s(fB, "isPossiblyLiteralEnum");
  function hB(t, e) {
    var r;
    let {
      type: i
    } = t;
    if ((r = t.extra) != null && r.parenthesized)
      return !1;
    if (e) {
      if (i === "Literal") {
        let {
          value: n
        } = t;
        if (typeof n == "string" || typeof n == "boolean")
          return !0;
      }
    } else if (i === "StringLiteral" || i === "BooleanLiteral")
      return !0;
    return !!(Tp(t, e) || dB(t, e) || i === "TemplateLiteral" && t.expressions.length === 0 || fB(t));
  }
  s(hB, "isValidAmbientConstInitializer");
  function Tp(t, e) {
    return e ? t.type === "Literal" && (typeof t.value == "number" || "bigint" in t) : t.type === "NumericLiteral" || t.type === "BigIntLite\
ral";
  }
  s(Tp, "isNumber");
  function dB(t, e) {
    if (t.type === "UnaryExpression") {
      let {
        operator: r,
        argument: i
      } = t;
      if (r === "-" && Tp(i, e))
        return !0;
    }
    return !1;
  }
  s(dB, "isNegativeNumber");
  function Sp(t) {
    return t.type === "Identifier" ? !0 : t.type !== "MemberExpression" || t.computed ? !1 : Sp(t.object);
  }
  s(Sp, "isUncomputedMemberExpressionChain");
  var tp = _t`placeholders`({
    ClassNameIsRequired: "A class name is required.",
    UnexpectedSpace: "Unexpected space in placeholder."
  }), mB = /* @__PURE__ */ s((t) => class extends t {
    static {
      s(this, "PlaceholdersParserMixin");
    }
    parsePlaceholder(r) {
      if (this.match(133)) {
        let i = this.startNode();
        return this.next(), this.assertNoSpace(), i.name = super.parseIdentifier(!0), this.assertNoSpace(), this.expect(133), this.finishPlaceholder(
        i, r);
      }
    }
    finishPlaceholder(r, i) {
      let n = r;
      return (!n.expectedNode || !n.type) && (n = this.finishNode(n, "Placeholder")), n.expectedNode = i, n;
    }
    getTokenFromCode(r) {
      r === 37 && this.input.charCodeAt(this.state.pos + 1) === 37 ? this.finishOp(133, 2) : super.getTokenFromCode(r);
    }
    parseExprAtom(r) {
      return this.parsePlaceholder("Expression") || super.parseExprAtom(r);
    }
    parseIdentifier(r) {
      return this.parsePlaceholder("Identifier") || super.parseIdentifier(r);
    }
    checkReservedWord(r, i, n, a) {
      r !== void 0 && super.checkReservedWord(r, i, n, a);
    }
    parseBindingAtom() {
      return this.parsePlaceholder("Pattern") || super.parseBindingAtom();
    }
    isValidLVal(r, i, n) {
      return r === "Placeholder" || super.isValidLVal(r, i, n);
    }
    toAssignable(r, i) {
      r && r.type === "Placeholder" && r.expectedNode === "Expression" ? r.expectedNode = "Pattern" : super.toAssignable(r, i);
    }
    chStartsBindingIdentifier(r, i) {
      return !!(super.chStartsBindingIdentifier(r, i) || this.lookahead().type === 133);
    }
    verifyBreakContinue(r, i) {
      r.label && r.label.type === "Placeholder" || super.verifyBreakContinue(r, i);
    }
    parseExpressionStatement(r, i) {
      var n;
      if (i.type !== "Placeholder" || (n = i.extra) != null && n.parenthesized)
        return super.parseExpressionStatement(r, i);
      if (this.match(14)) {
        let o = r;
        return o.label = this.finishPlaceholder(i, "Identifier"), this.next(), o.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration(),
        this.finishNode(o, "LabeledStatement");
      }
      this.semicolon();
      let a = r;
      return a.name = i.name, this.finishPlaceholder(a, "Statement");
    }
    parseBlock(r, i, n) {
      return this.parsePlaceholder("BlockStatement") || super.parseBlock(r, i, n);
    }
    parseFunctionId(r) {
      return this.parsePlaceholder("Identifier") || super.parseFunctionId(r);
    }
    parseClass(r, i, n) {
      let a = i ? "ClassDeclaration" : "ClassExpression";
      this.next();
      let o = this.state.strict, l = this.parsePlaceholder("Identifier");
      if (l)
        if (this.match(81) || this.match(133) || this.match(5))
          r.id = l;
        else {
          if (n || !i)
            return r.id = null, r.body = this.finishPlaceholder(l, "ClassBody"), this.finishNode(r, a);
          throw this.raise(tp.ClassNameIsRequired, this.state.startLoc);
        }
      else
        this.parseClassId(r, i, n);
      return super.parseClassSuper(r), r.body = this.parsePlaceholder("ClassBody") || super.parseClassBody(!!r.superClass, o), this.finishNode(
      r, a);
    }
    parseExport(r, i) {
      let n = this.parsePlaceholder("Identifier");
      if (!n) return super.parseExport(r, i);
      let a = r;
      if (!this.isContextual(98) && !this.match(12))
        return a.specifiers = [], a.source = null, a.declaration = this.finishPlaceholder(n, "Declaration"), this.finishNode(a, "ExportNamed\
Declaration");
      this.expectPlugin("exportDefaultFrom");
      let o = this.startNode();
      return o.exported = n, a.specifiers = [this.finishNode(o, "ExportDefaultSpecifier")], super.parseExport(a, i);
    }
    isExportDefaultSpecifier() {
      if (this.match(65)) {
        let r = this.nextTokenStart();
        if (this.isUnparsedContextual(r, "from") && this.input.startsWith(Kt(133), this.nextTokenStartSince(r + 4)))
          return !0;
      }
      return super.isExportDefaultSpecifier();
    }
    maybeParseExportDefaultSpecifier(r, i) {
      var n;
      return (n = r.specifiers) != null && n.length ? !0 : super.maybeParseExportDefaultSpecifier(r, i);
    }
    checkExport(r) {
      let {
        specifiers: i
      } = r;
      i != null && i.length && (r.specifiers = i.filter((n) => n.exported.type === "Placeholder")), super.checkExport(r), r.specifiers = i;
    }
    parseImport(r) {
      let i = this.parsePlaceholder("Identifier");
      if (!i) return super.parseImport(r);
      if (r.specifiers = [], !this.isContextual(98) && !this.match(12))
        return r.source = this.finishPlaceholder(i, "StringLiteral"), this.semicolon(), this.finishNode(r, "ImportDeclaration");
      let n = this.startNodeAtNode(i);
      return n.local = i, r.specifiers.push(this.finishNode(n, "ImportDefaultSpecifier")), this.eat(12) && (this.maybeParseStarImportSpecifier(
      r) || this.parseNamedImportSpecifiers(r)), this.expectContextual(98), r.source = this.parseImportSource(), this.semicolon(), this.finishNode(
      r, "ImportDeclaration");
    }
    parseImportSource() {
      return this.parsePlaceholder("StringLiteral") || super.parseImportSource();
    }
    assertNoSpace() {
      this.state.start > this.offsetToSourcePos(this.state.lastTokEndLoc.index) && this.raise(tp.UnexpectedSpace, this.state.lastTokEndLoc);
    }
  }, "placeholders"), yB = /* @__PURE__ */ s((t) => class extends t {
    static {
      s(this, "V8IntrinsicMixin");
    }
    parseV8Intrinsic() {
      if (this.match(54)) {
        let r = this.state.startLoc, i = this.startNode();
        if (this.next(), ve(this.state.type)) {
          let n = this.parseIdentifierName(), a = this.createIdentifier(i, n);
          if (a.type = "V8IntrinsicIdentifier", this.match(10))
            return a;
        }
        this.unexpected(r);
      }
    }
    parseExprAtom(r) {
      return this.parseV8Intrinsic() || super.parseExprAtom(r);
    }
  }, "v8intrinsic"), rp = ["minimal", "fsharp", "hack", "smart"], ip = ["^^", "@@", "^", "%", "#"];
  function TB(t) {
    if (t.has("decorators")) {
      if (t.has("decorators-legacy"))
        throw new Error("Cannot use the decorators and decorators-legacy plugin together");
      let r = t.get("decorators").decoratorsBeforeExport;
      if (r != null && typeof r != "boolean")
        throw new Error("'decoratorsBeforeExport' must be a boolean, if specified.");
      let i = t.get("decorators").allowCallParenthesized;
      if (i != null && typeof i != "boolean")
        throw new Error("'allowCallParenthesized' must be a boolean.");
    }
    if (t.has("flow") && t.has("typescript"))
      throw new Error("Cannot combine flow and typescript plugins.");
    if (t.has("placeholders") && t.has("v8intrinsic"))
      throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
    if (t.has("pipelineOperator")) {
      var e;
      let r = t.get("pipelineOperator").proposal;
      if (!rp.includes(r)) {
        let n = rp.map((a) => `"${a}"`).join(", ");
        throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${n}.`);
      }
      let i = ((e = t.get("recordAndTuple")) == null ? void 0 : e.syntaxType) === "hash";
      if (r === "hack") {
        if (t.has("placeholders"))
          throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
        if (t.has("v8intrinsic"))
          throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
        let n = t.get("pipelineOperator").topicToken;
        if (!ip.includes(n)) {
          let a = ip.map((o) => `"${o}"`).join(", ");
          throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${a}\
.`);
        }
        if (n === "#" && i)
          throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "hack", topicToken: "#" }]\` and \`${JSON.stringify(["\
recordAndTuple", t.get("recordAndTuple")])}\`.`);
      } else if (r === "smart" && i)
        throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "smart" }]\` and \`${JSON.stringify(["recordAndTuple", t.
        get("recordAndTuple")])}\`.`);
    }
    if (t.has("moduleAttributes")) {
      if (t.has("deprecatedImportAssert") || t.has("importAssertions"))
        throw new Error("Cannot combine importAssertions, deprecatedImportAssert and moduleAttributes plugins.");
      if (t.get("moduleAttributes").version !== "may-2020")
        throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the on\
ly supported value is 'may-2020'.");
    }
    if (t.has("importAssertions") && t.has("deprecatedImportAssert"))
      throw new Error("Cannot combine importAssertions and deprecatedImportAssert plugins.");
    if (!t.has("deprecatedImportAssert") && t.has("importAttributes") && t.get("importAttributes").deprecatedAssertSyntax && t.set("deprecat\
edImportAssert", {}), t.has("recordAndTuple")) {
      let r = t.get("recordAndTuple").syntaxType;
      if (r != null) {
        let i = ["hash", "bar"];
        if (!i.includes(r))
          throw new Error("The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " + i.map((n) => `'${n}'`).join(", "));
      }
    }
    if (t.has("asyncDoExpressions") && !t.has("doExpressions")) {
      let r = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
      throw r.missingPlugins = "doExpressions", r;
    }
    if (t.has("optionalChainingAssign") && t.get("optionalChainingAssign").version !== "2023-07")
      throw new Error("The 'optionalChainingAssign' plugin requires a 'version' option, representing the last proposal update. Currently, th\
e only supported value is '2023-07'.");
  }
  s(TB, "validatePlugins");
  var bp = {
    estree: b3,
    jsx: oB,
    flow: nB,
    typescript: pB,
    v8intrinsic: yB,
    placeholders: mB
  }, SB = Object.keys(bp), ho = class extends fo {
    static {
      s(this, "ExpressionParser");
    }
    checkProto(e, r, i, n) {
      if (e.type === "SpreadElement" || this.isObjectMethod(e) || e.computed || e.shorthand)
        return i;
      let a = e.key;
      return (a.type === "Identifier" ? a.name : a.value) === "__proto__" ? r ? (this.raise(P.RecordNoProto, a), !0) : (i && (n ? n.doubleProtoLoc ===
      null && (n.doubleProtoLoc = a.loc.start) : this.raise(P.DuplicateProto, a)), !0) : i;
    }
    shouldExitDescending(e, r) {
      return e.type === "ArrowFunctionExpression" && this.offsetToSourcePos(e.start) === r;
    }
    getExpression() {
      this.enterInitialScopes(), this.nextToken();
      let e = this.parseExpression();
      return this.match(140) || this.unexpected(), this.finalizeRemainingComments(), e.comments = this.comments, e.errors = this.state.errors,
      this.optionFlags & 256 && (e.tokens = this.tokens), e;
    }
    parseExpression(e, r) {
      return e ? this.disallowInAnd(() => this.parseExpressionBase(r)) : this.allowInAnd(() => this.parseExpressionBase(r));
    }
    parseExpressionBase(e) {
      let r = this.state.startLoc, i = this.parseMaybeAssign(e);
      if (this.match(12)) {
        let n = this.startNodeAt(r);
        for (n.expressions = [i]; this.eat(12); )
          n.expressions.push(this.parseMaybeAssign(e));
        return this.toReferencedList(n.expressions), this.finishNode(n, "SequenceExpression");
      }
      return i;
    }
    parseMaybeAssignDisallowIn(e, r) {
      return this.disallowInAnd(() => this.parseMaybeAssign(e, r));
    }
    parseMaybeAssignAllowIn(e, r) {
      return this.allowInAnd(() => this.parseMaybeAssign(e, r));
    }
    setOptionalParametersError(e) {
      e.optionalParametersLoc = this.state.startLoc;
    }
    parseMaybeAssign(e, r) {
      let i = this.state.startLoc, n = this.isContextual(108);
      if (n && this.prodParam.hasYield) {
        this.next();
        let u = this.parseYield(i);
        return r && (u = r.call(this, u, i)), u;
      }
      let a;
      e ? a = !1 : (e = new yr(), a = !0);
      let {
        type: o
      } = this.state;
      (o === 10 || ve(o)) && (this.state.potentialArrowAt = this.state.start);
      let l = this.parseMaybeConditional(e);
      if (r && (l = r.call(this, l, i)), A3(this.state.type)) {
        let u = this.startNodeAt(i), p = this.state.value;
        if (u.operator = p, this.match(29)) {
          this.toAssignable(l, !0), u.left = l;
          let m = i.index;
          e.doubleProtoLoc != null && e.doubleProtoLoc.index >= m && (e.doubleProtoLoc = null), e.shorthandAssignLoc != null && e.shorthandAssignLoc.
          index >= m && (e.shorthandAssignLoc = null), e.privateKeyLoc != null && e.privateKeyLoc.index >= m && (this.checkDestructuringPrivate(
          e), e.privateKeyLoc = null);
        } else
          u.left = l;
        return this.next(), u.right = this.parseMaybeAssign(), this.checkLVal(l, this.finishNode(u, "AssignmentExpression")), u;
      } else a && this.checkExpressionErrors(e, !0);
      if (n) {
        let {
          type: u
        } = this.state;
        if ((this.hasPlugin("v8intrinsic") ? Jr(u) : Jr(u) && !this.match(54)) && !this.isAmbiguousPrefixOrIdentifier())
          return this.raiseOverwrite(P.YieldNotInGeneratorFunction, i), this.parseYield(i);
      }
      return l;
    }
    parseMaybeConditional(e) {
      let r = this.state.startLoc, i = this.state.potentialArrowAt, n = this.parseExprOps(e);
      return this.shouldExitDescending(n, i) ? n : this.parseConditional(n, r, e);
    }
    parseConditional(e, r, i) {
      if (this.eat(17)) {
        let n = this.startNodeAt(r);
        return n.test = e, n.consequent = this.parseMaybeAssignAllowIn(), this.expect(14), n.alternate = this.parseMaybeAssign(), this.finishNode(
        n, "ConditionalExpression");
      }
      return e;
    }
    parseMaybeUnaryOrPrivate(e) {
      return this.match(139) ? this.parsePrivateName() : this.parseMaybeUnary(e);
    }
    parseExprOps(e) {
      let r = this.state.startLoc, i = this.state.potentialArrowAt, n = this.parseMaybeUnaryOrPrivate(e);
      return this.shouldExitDescending(n, i) ? n : this.parseExprOp(n, r, -1);
    }
    parseExprOp(e, r, i) {
      if (this.isPrivateName(e)) {
        let a = this.getPrivateNameSV(e);
        (i >= zi(58) || !this.prodParam.hasIn || !this.match(58)) && this.raise(P.PrivateInExpectedIn, e, {
          identifierName: a
        }), this.classScope.usePrivateName(a, e.loc.start);
      }
      let n = this.state.type;
      if (v3(n) && (this.prodParam.hasIn || !this.match(58))) {
        let a = zi(n);
        if (a > i) {
          if (n === 39) {
            if (this.expectPlugin("pipelineOperator"), this.state.inFSharpPipelineDirectBody)
              return e;
            this.checkPipelineAtInfixOperator(e, r);
          }
          let o = this.startNodeAt(r);
          o.left = e, o.operator = this.state.value;
          let l = n === 41 || n === 42, u = n === 40;
          if (u && (a = zi(42)), this.next(), n === 39 && this.hasPlugin(["pipelineOperator", {
            proposal: "minimal"
          }]) && this.state.type === 96 && this.prodParam.hasAwait)
            throw this.raise(P.UnexpectedAwaitAfterPipelineBody, this.state.startLoc);
          o.right = this.parseExprOpRightExpr(n, a);
          let p = this.finishNode(o, l || u ? "LogicalExpression" : "BinaryExpression"), m = this.state.type;
          if (u && (m === 41 || m === 42) || l && m === 40)
            throw this.raise(P.MixingCoalesceWithLogical, this.state.startLoc);
          return this.parseExprOp(p, r, i);
        }
      }
      return e;
    }
    parseExprOpRightExpr(e, r) {
      let i = this.state.startLoc;
      switch (e) {
        case 39:
          switch (this.getPluginOption("pipelineOperator", "proposal")) {
            case "hack":
              return this.withTopicBindingContext(() => this.parseHackPipeBody());
            case "fsharp":
              return this.withSoloAwaitPermittingContext(() => this.parseFSharpPipelineBody(r));
          }
          if (this.getPluginOption("pipelineOperator", "proposal") === "smart")
            return this.withTopicBindingContext(() => {
              if (this.prodParam.hasYield && this.isContextual(108))
                throw this.raise(P.PipeBodyIsTighter, this.state.startLoc);
              return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(e, r), i);
            });
        default:
          return this.parseExprOpBaseRightExpr(e, r);
      }
    }
    parseExprOpBaseRightExpr(e, r) {
      let i = this.state.startLoc;
      return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), i, _3(e) ? r - 1 : r);
    }
    parseHackPipeBody() {
      var e;
      let {
        startLoc: r
      } = this.state, i = this.parseMaybeAssign();
      return f3.has(i.type) && !((e = i.extra) != null && e.parenthesized) && this.raise(P.PipeUnparenthesizedBody, r, {
        type: i.type
      }), this.topicReferenceWasUsedInCurrentContext() || this.raise(P.PipeTopicUnused, r), i;
    }
    checkExponentialAfterUnary(e) {
      this.match(57) && this.raise(P.UnexpectedTokenUnaryExponentiation, e.argument);
    }
    parseMaybeUnary(e, r) {
      let i = this.state.startLoc, n = this.isContextual(96);
      if (n && this.recordAwaitIfAllowed()) {
        this.next();
        let u = this.parseAwait(i);
        return r || this.checkExponentialAfterUnary(u), u;
      }
      let a = this.match(34), o = this.startNode();
      if (w3(this.state.type)) {
        o.operator = this.state.value, o.prefix = !0, this.match(72) && this.expectPlugin("throwExpressions");
        let u = this.match(89);
        if (this.next(), o.argument = this.parseMaybeUnary(null, !0), this.checkExpressionErrors(e, !0), this.state.strict && u) {
          let p = o.argument;
          p.type === "Identifier" ? this.raise(P.StrictDelete, o) : this.hasPropertyAsPrivateName(p) && this.raise(P.DeletePrivateField, o);
        }
        if (!a)
          return r || this.checkExponentialAfterUnary(o), this.finishNode(o, "UnaryExpression");
      }
      let l = this.parseUpdate(o, a, e);
      if (n) {
        let {
          type: u
        } = this.state;
        if ((this.hasPlugin("v8intrinsic") ? Jr(u) : Jr(u) && !this.match(54)) && !this.isAmbiguousPrefixOrIdentifier())
          return this.raiseOverwrite(P.AwaitNotInAsyncContext, i), this.parseAwait(i);
      }
      return l;
    }
    parseUpdate(e, r, i) {
      if (r) {
        let o = e;
        return this.checkLVal(o.argument, this.finishNode(o, "UpdateExpression")), e;
      }
      let n = this.state.startLoc, a = this.parseExprSubscripts(i);
      if (this.checkExpressionErrors(i, !1)) return a;
      for (; C3(this.state.type) && !this.canInsertSemicolon(); ) {
        let o = this.startNodeAt(n);
        o.operator = this.state.value, o.prefix = !1, o.argument = a, this.next(), this.checkLVal(a, a = this.finishNode(o, "UpdateExpressio\
n"));
      }
      return a;
    }
    parseExprSubscripts(e) {
      let r = this.state.startLoc, i = this.state.potentialArrowAt, n = this.parseExprAtom(e);
      return this.shouldExitDescending(n, i) ? n : this.parseSubscripts(n, r);
    }
    parseSubscripts(e, r, i) {
      let n = {
        optionalChainMember: !1,
        maybeAsyncArrow: this.atPossibleAsyncArrow(e),
        stop: !1
      };
      do
        e = this.parseSubscript(e, r, i, n), n.maybeAsyncArrow = !1;
      while (!n.stop);
      return e;
    }
    parseSubscript(e, r, i, n) {
      let {
        type: a
      } = this.state;
      if (!i && a === 15)
        return this.parseBind(e, r, i, n);
      if (Gi(a))
        return this.parseTaggedTemplateExpression(e, r, n);
      let o = !1;
      if (a === 18) {
        if (i && (this.raise(P.OptionalChainingNoNew, this.state.startLoc), this.lookaheadCharCode() === 40))
          return n.stop = !0, e;
        n.optionalChainMember = o = !0, this.next();
      }
      if (!i && this.match(10))
        return this.parseCoverCallAndAsyncArrowHead(e, r, n, o);
      {
        let l = this.eat(0);
        return l || o || this.eat(16) ? this.parseMember(e, r, n, l, o) : (n.stop = !0, e);
      }
    }
    parseMember(e, r, i, n, a) {
      let o = this.startNodeAt(r);
      return o.object = e, o.computed = n, n ? (o.property = this.parseExpression(), this.expect(3)) : this.match(139) ? (e.type === "Super" &&
      this.raise(P.SuperPrivateField, r), this.classScope.usePrivateName(this.state.value, this.state.startLoc), o.property = this.parsePrivateName()) :
      o.property = this.parseIdentifier(!0), i.optionalChainMember ? (o.optional = a, this.finishNode(o, "OptionalMemberExpression")) : this.
      finishNode(o, "MemberExpression");
    }
    parseBind(e, r, i, n) {
      let a = this.startNodeAt(r);
      return a.object = e, this.next(), a.callee = this.parseNoCallExpr(), n.stop = !0, this.parseSubscripts(this.finishNode(a, "BindExpress\
ion"), r, i);
    }
    parseCoverCallAndAsyncArrowHead(e, r, i, n) {
      let a = this.state.maybeInArrowParameters, o = null;
      this.state.maybeInArrowParameters = !0, this.next();
      let l = this.startNodeAt(r);
      l.callee = e;
      let {
        maybeAsyncArrow: u,
        optionalChainMember: p
      } = i;
      u && (this.expressionScope.enter(G3()), o = new yr()), p && (l.optional = n), n ? l.arguments = this.parseCallExpressionArguments(11) :
      l.arguments = this.parseCallExpressionArguments(11, e.type !== "Super", l, o);
      let m = this.finishCallExpression(l, p);
      return u && this.shouldParseAsyncArrow() && !n ? (i.stop = !0, this.checkDestructuringPrivate(o), this.expressionScope.validateAsPattern(),
      this.expressionScope.exit(), m = this.parseAsyncArrowFromCallExpression(this.startNodeAt(r), m)) : (u && (this.checkExpressionErrors(o,
      !0), this.expressionScope.exit()), this.toReferencedArguments(m)), this.state.maybeInArrowParameters = a, m;
    }
    toReferencedArguments(e, r) {
      this.toReferencedListDeep(e.arguments, r);
    }
    parseTaggedTemplateExpression(e, r, i) {
      let n = this.startNodeAt(r);
      return n.tag = e, n.quasi = this.parseTemplate(!0), i.optionalChainMember && this.raise(P.OptionalChainingNoTemplate, r), this.finishNode(
      n, "TaggedTemplateExpression");
    }
    atPossibleAsyncArrow(e) {
      return e.type === "Identifier" && e.name === "async" && this.state.lastTokEndLoc.index === e.end && !this.canInsertSemicolon() && e.end -
      e.start === 5 && this.offsetToSourcePos(e.start) === this.state.potentialArrowAt;
    }
    finishCallExpression(e, r) {
      if (e.callee.type === "Import")
        if (e.arguments.length === 0 || e.arguments.length > 2)
          this.raise(P.ImportCallArity, e);
        else
          for (let i of e.arguments)
            i.type === "SpreadElement" && this.raise(P.ImportCallSpreadArgument, i);
      return this.finishNode(e, r ? "OptionalCallExpression" : "CallExpression");
    }
    parseCallExpressionArguments(e, r, i, n) {
      let a = [], o = !0, l = this.state.inFSharpPipelineDirectBody;
      for (this.state.inFSharpPipelineDirectBody = !1; !this.eat(e); ) {
        if (o)
          o = !1;
        else if (this.expect(12), this.match(e)) {
          i && this.addTrailingCommaExtraToNode(i), this.next();
          break;
        }
        a.push(this.parseExprListItem(!1, n, r));
      }
      return this.state.inFSharpPipelineDirectBody = l, a;
    }
    shouldParseAsyncArrow() {
      return this.match(19) && !this.canInsertSemicolon();
    }
    parseAsyncArrowFromCallExpression(e, r) {
      var i;
      return this.resetPreviousNodeTrailingComments(r), this.expect(19), this.parseArrowExpression(e, r.arguments, !0, (i = r.extra) == null ?
      void 0 : i.trailingCommaLoc), r.innerComments && Hr(e, r.innerComments), r.callee.trailingComments && Hr(e, r.callee.trailingComments),
      e;
    }
    parseNoCallExpr() {
      let e = this.state.startLoc;
      return this.parseSubscripts(this.parseExprAtom(), e, !0);
    }
    parseExprAtom(e) {
      let r, i = null, {
        type: n
      } = this.state;
      switch (n) {
        case 79:
          return this.parseSuper();
        case 83:
          return r = this.startNode(), this.next(), this.match(16) ? this.parseImportMetaProperty(r) : this.match(10) ? this.optionFlags & 512 ?
          this.parseImportCall(r) : this.finishNode(r, "Import") : (this.raise(P.UnsupportedImport, this.state.lastTokStartLoc), this.finishNode(
          r, "Import"));
        case 78:
          return r = this.startNode(), this.next(), this.finishNode(r, "ThisExpression");
        case 90:
          return this.parseDo(this.startNode(), !1);
        case 56:
        case 31:
          return this.readRegexp(), this.parseRegExpLiteral(this.state.value);
        case 135:
          return this.parseNumericLiteral(this.state.value);
        case 136:
          return this.parseBigIntLiteral(this.state.value);
        case 134:
          return this.parseStringLiteral(this.state.value);
        case 84:
          return this.parseNullLiteral();
        case 85:
          return this.parseBooleanLiteral(!0);
        case 86:
          return this.parseBooleanLiteral(!1);
        case 10: {
          let a = this.state.potentialArrowAt === this.state.start;
          return this.parseParenAndDistinguishExpression(a);
        }
        case 2:
        case 1:
          return this.parseArrayLike(this.state.type === 2 ? 4 : 3, !1, !0);
        case 0:
          return this.parseArrayLike(3, !0, !1, e);
        case 6:
        case 7:
          return this.parseObjectLike(this.state.type === 6 ? 9 : 8, !1, !0);
        case 5:
          return this.parseObjectLike(8, !1, !1, e);
        case 68:
          return this.parseFunctionOrFunctionSent();
        case 26:
          i = this.parseDecorators();
        case 80:
          return this.parseClass(this.maybeTakeDecorators(i, this.startNode()), !1);
        case 77:
          return this.parseNewOrNewTarget();
        case 25:
        case 24:
          return this.parseTemplate(!1);
        case 15: {
          r = this.startNode(), this.next(), r.object = null;
          let a = r.callee = this.parseNoCallExpr();
          if (a.type === "MemberExpression")
            return this.finishNode(r, "BindExpression");
          throw this.raise(P.UnsupportedBind, a);
        }
        case 139:
          return this.raise(P.PrivateInExpectedIn, this.state.startLoc, {
            identifierName: this.state.value
          }), this.parsePrivateName();
        case 33:
          return this.parseTopicReferenceThenEqualsSign(54, "%");
        case 32:
          return this.parseTopicReferenceThenEqualsSign(44, "^");
        case 37:
        case 38:
          return this.parseTopicReference("hack");
        case 44:
        case 54:
        case 27: {
          let a = this.getPluginOption("pipelineOperator", "proposal");
          if (a)
            return this.parseTopicReference(a);
          this.unexpected();
          break;
        }
        case 47: {
          let a = this.input.codePointAt(this.nextTokenStart());
          Ot(a) || a === 62 ? this.expectOnePlugin(["jsx", "flow", "typescript"]) : this.unexpected();
          break;
        }
        default:
          if (n === 137)
            return this.parseDecimalLiteral(this.state.value);
          if (ve(n)) {
            if (this.isContextual(127) && this.lookaheadInLineCharCode() === 123)
              return this.parseModuleExpression();
            let a = this.state.potentialArrowAt === this.state.start, o = this.state.containsEsc, l = this.parseIdentifier();
            if (!o && l.name === "async" && !this.canInsertSemicolon()) {
              let {
                type: u
              } = this.state;
              if (u === 68)
                return this.resetPreviousNodeTrailingComments(l), this.next(), this.parseAsyncFunctionExpression(this.startNodeAtNode(l));
              if (ve(u))
                return this.lookaheadCharCode() === 61 ? this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(l)) : l;
              if (u === 90)
                return this.resetPreviousNodeTrailingComments(l), this.parseDo(this.startNodeAtNode(l), !0);
            }
            return a && this.match(19) && !this.canInsertSemicolon() ? (this.next(), this.parseArrowExpression(this.startNodeAtNode(l), [l],
            !1)) : l;
          } else
            this.unexpected();
      }
    }
    parseTopicReferenceThenEqualsSign(e, r) {
      let i = this.getPluginOption("pipelineOperator", "proposal");
      if (i)
        return this.state.type = e, this.state.value = r, this.state.pos--, this.state.end--, this.state.endLoc = Ze(this.state.endLoc, -1),
        this.parseTopicReference(i);
      this.unexpected();
    }
    parseTopicReference(e) {
      let r = this.startNode(), i = this.state.startLoc, n = this.state.type;
      return this.next(), this.finishTopicReference(r, i, e, n);
    }
    finishTopicReference(e, r, i, n) {
      if (this.testTopicReferenceConfiguration(i, r, n))
        return i === "hack" ? (this.topicReferenceIsAllowedInCurrentContext() || this.raise(P.PipeTopicUnbound, r), this.registerTopicReference(),
        this.finishNode(e, "TopicReference")) : (this.topicReferenceIsAllowedInCurrentContext() || this.raise(P.PrimaryTopicNotAllowed, r), this.
        registerTopicReference(), this.finishNode(e, "PipelinePrimaryTopicReference"));
      throw this.raise(P.PipeTopicUnconfiguredToken, r, {
        token: Kt(n)
      });
    }
    testTopicReferenceConfiguration(e, r, i) {
      switch (e) {
        case "hack":
          return this.hasPlugin(["pipelineOperator", {
            topicToken: Kt(i)
          }]);
        case "smart":
          return i === 27;
        default:
          throw this.raise(P.PipeTopicRequiresHackPipes, r);
      }
    }
    parseAsyncArrowUnaryFunction(e) {
      this.prodParam.enter($i(!0, this.prodParam.hasYield));
      let r = [this.parseIdentifier()];
      return this.prodParam.exit(), this.hasPrecedingLineBreak() && this.raise(P.LineTerminatorBeforeArrow, this.state.curPosition()), this.
      expect(19), this.parseArrowExpression(e, r, !0);
    }
    parseDo(e, r) {
      this.expectPlugin("doExpressions"), r && this.expectPlugin("asyncDoExpressions"), e.async = r, this.next();
      let i = this.state.labels;
      return this.state.labels = [], r ? (this.prodParam.enter(2), e.body = this.parseBlock(), this.prodParam.exit()) : e.body = this.parseBlock(),
      this.state.labels = i, this.finishNode(e, "DoExpression");
    }
    parseSuper() {
      let e = this.startNode();
      return this.next(), this.match(10) && !this.scope.allowDirectSuper && !(this.optionFlags & 16) ? this.raise(P.SuperNotAllowed, e) : !this.
      scope.allowSuper && !(this.optionFlags & 16) && this.raise(P.UnexpectedSuper, e), !this.match(10) && !this.match(0) && !this.match(16) &&
      this.raise(P.UnsupportedSuper, e), this.finishNode(e, "Super");
    }
    parsePrivateName() {
      let e = this.startNode(), r = this.startNodeAt(Ze(this.state.startLoc, 1)), i = this.state.value;
      return this.next(), e.id = this.createIdentifier(r, i), this.finishNode(e, "PrivateName");
    }
    parseFunctionOrFunctionSent() {
      let e = this.startNode();
      if (this.next(), this.prodParam.hasYield && this.match(16)) {
        let r = this.createIdentifier(this.startNodeAtNode(e), "function");
        return this.next(), this.match(103) ? this.expectPlugin("functionSent") : this.hasPlugin("functionSent") || this.unexpected(), this.
        parseMetaProperty(e, r, "sent");
      }
      return this.parseFunction(e);
    }
    parseMetaProperty(e, r, i) {
      e.meta = r;
      let n = this.state.containsEsc;
      return e.property = this.parseIdentifier(!0), (e.property.name !== i || n) && this.raise(P.UnsupportedMetaProperty, e.property, {
        target: r.name,
        onlyValidPropertyName: i
      }), this.finishNode(e, "MetaProperty");
    }
    parseImportMetaProperty(e) {
      let r = this.createIdentifier(this.startNodeAtNode(e), "import");
      if (this.next(), this.isContextual(101))
        this.inModule || this.raise(P.ImportMetaOutsideModule, r), this.sawUnambiguousESM = !0;
      else if (this.isContextual(105) || this.isContextual(97)) {
        let i = this.isContextual(105);
        if (this.expectPlugin(i ? "sourcePhaseImports" : "deferredImportEvaluation"), !(this.optionFlags & 512))
          throw this.raise(P.DynamicImportPhaseRequiresImportExpressions, this.state.startLoc, {
            phase: this.state.value
          });
        return this.next(), e.phase = i ? "source" : "defer", this.parseImportCall(e);
      }
      return this.parseMetaProperty(e, r, "meta");
    }
    parseLiteralAtNode(e, r, i) {
      return this.addExtra(i, "rawValue", e), this.addExtra(i, "raw", this.input.slice(this.offsetToSourcePos(i.start), this.state.end)), i.
      value = e, this.next(), this.finishNode(i, r);
    }
    parseLiteral(e, r) {
      let i = this.startNode();
      return this.parseLiteralAtNode(e, r, i);
    }
    parseStringLiteral(e) {
      return this.parseLiteral(e, "StringLiteral");
    }
    parseNumericLiteral(e) {
      return this.parseLiteral(e, "NumericLiteral");
    }
    parseBigIntLiteral(e) {
      return this.parseLiteral(e, "BigIntLiteral");
    }
    parseDecimalLiteral(e) {
      return this.parseLiteral(e, "DecimalLiteral");
    }
    parseRegExpLiteral(e) {
      let r = this.startNode();
      return this.addExtra(r, "raw", this.input.slice(this.offsetToSourcePos(r.start), this.state.end)), r.pattern = e.pattern, r.flags = e.
      flags, this.next(), this.finishNode(r, "RegExpLiteral");
    }
    parseBooleanLiteral(e) {
      let r = this.startNode();
      return r.value = e, this.next(), this.finishNode(r, "BooleanLiteral");
    }
    parseNullLiteral() {
      let e = this.startNode();
      return this.next(), this.finishNode(e, "NullLiteral");
    }
    parseParenAndDistinguishExpression(e) {
      let r = this.state.startLoc, i;
      this.next(), this.expressionScope.enter(H3());
      let n = this.state.maybeInArrowParameters, a = this.state.inFSharpPipelineDirectBody;
      this.state.maybeInArrowParameters = !0, this.state.inFSharpPipelineDirectBody = !1;
      let o = this.state.startLoc, l = [], u = new yr(), p = !0, m, g;
      for (; !this.match(11); ) {
        if (p)
          p = !1;
        else if (this.expect(12, u.optionalParametersLoc === null ? null : u.optionalParametersLoc), this.match(11)) {
          g = this.state.startLoc;
          break;
        }
        if (this.match(21)) {
          let _ = this.state.startLoc;
          if (m = this.state.startLoc, l.push(this.parseParenItem(this.parseRestBinding(), _)), !this.checkCommaAfterRest(41))
            break;
        } else
          l.push(this.parseMaybeAssignAllowIn(u, this.parseParenItem));
      }
      let I = this.state.lastTokEndLoc;
      this.expect(11), this.state.maybeInArrowParameters = n, this.state.inFSharpPipelineDirectBody = a;
      let v = this.startNodeAt(r);
      return e && this.shouldParseArrow(l) && (v = this.parseArrow(v)) ? (this.checkDestructuringPrivate(u), this.expressionScope.validateAsPattern(),
      this.expressionScope.exit(), this.parseArrowExpression(v, l, !1), v) : (this.expressionScope.exit(), l.length || this.unexpected(this.
      state.lastTokStartLoc), g && this.unexpected(g), m && this.unexpected(m), this.checkExpressionErrors(u, !0), this.toReferencedListDeep(
      l, !0), l.length > 1 ? (i = this.startNodeAt(o), i.expressions = l, this.finishNode(i, "SequenceExpression"), this.resetEndLocation(i,
      I)) : i = l[0], this.wrapParenthesis(r, i));
    }
    wrapParenthesis(e, r) {
      if (!(this.optionFlags & 1024))
        return this.addExtra(r, "parenthesized", !0), this.addExtra(r, "parenStart", e.index), this.takeSurroundingComments(r, e.index, this.
        state.lastTokEndLoc.index), r;
      let i = this.startNodeAt(e);
      return i.expression = r, this.finishNode(i, "ParenthesizedExpression");
    }
    shouldParseArrow(e) {
      return !this.canInsertSemicolon();
    }
    parseArrow(e) {
      if (this.eat(19))
        return e;
    }
    parseParenItem(e, r) {
      return e;
    }
    parseNewOrNewTarget() {
      let e = this.startNode();
      if (this.next(), this.match(16)) {
        let r = this.createIdentifier(this.startNodeAtNode(e), "new");
        this.next();
        let i = this.parseMetaProperty(e, r, "target");
        return !this.scope.inNonArrowFunction && !this.scope.inClass && !(this.optionFlags & 4) && this.raise(P.UnexpectedNewTarget, i), i;
      }
      return this.parseNew(e);
    }
    parseNew(e) {
      if (this.parseNewCallee(e), this.eat(10)) {
        let r = this.parseExprList(11);
        this.toReferencedList(r), e.arguments = r;
      } else
        e.arguments = [];
      return this.finishNode(e, "NewExpression");
    }
    parseNewCallee(e) {
      let r = this.match(83), i = this.parseNoCallExpr();
      e.callee = i, r && (i.type === "Import" || i.type === "ImportExpression") && this.raise(P.ImportCallNotNewExpression, i);
    }
    parseTemplateElement(e) {
      let {
        start: r,
        startLoc: i,
        end: n,
        value: a
      } = this.state, o = r + 1, l = this.startNodeAt(Ze(i, 1));
      a === null && (e || this.raise(P.InvalidEscapeSequenceTemplate, Ze(this.state.firstInvalidTemplateEscapePos, 1)));
      let u = this.match(24), p = u ? -1 : -2, m = n + p;
      l.value = {
        raw: this.input.slice(o, m).replace(/\r\n?/g, `
`),
        cooked: a === null ? null : a.slice(1, p)
      }, l.tail = u, this.next();
      let g = this.finishNode(l, "TemplateElement");
      return this.resetEndLocation(g, Ze(this.state.lastTokEndLoc, p)), g;
    }
    parseTemplate(e) {
      let r = this.startNode(), i = this.parseTemplateElement(e), n = [i], a = [];
      for (; !i.tail; )
        a.push(this.parseTemplateSubstitution()), this.readTemplateContinuation(), n.push(i = this.parseTemplateElement(e));
      return r.expressions = a, r.quasis = n, this.finishNode(r, "TemplateLiteral");
    }
    parseTemplateSubstitution() {
      return this.parseExpression();
    }
    parseObjectLike(e, r, i, n) {
      i && this.expectPlugin("recordAndTuple");
      let a = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !1;
      let o = !1, l = !0, u = this.startNode();
      for (u.properties = [], this.next(); !this.match(e); ) {
        if (l)
          l = !1;
        else if (this.expect(12), this.match(e)) {
          this.addTrailingCommaExtraToNode(u);
          break;
        }
        let m;
        r ? m = this.parseBindingProperty() : (m = this.parsePropertyDefinition(n), o = this.checkProto(m, i, o, n)), i && !this.isObjectProperty(
        m) && m.type !== "SpreadElement" && this.raise(P.InvalidRecordProperty, m), m.shorthand && this.addExtra(m, "shorthand", !0), u.properties.
        push(m);
      }
      this.next(), this.state.inFSharpPipelineDirectBody = a;
      let p = "ObjectExpression";
      return r ? p = "ObjectPattern" : i && (p = "RecordExpression"), this.finishNode(u, p);
    }
    addTrailingCommaExtraToNode(e) {
      this.addExtra(e, "trailingComma", this.state.lastTokStartLoc.index), this.addExtra(e, "trailingCommaLoc", this.state.lastTokStartLoc, !1);
    }
    maybeAsyncOrAccessorProp(e) {
      return !e.computed && e.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
    }
    parsePropertyDefinition(e) {
      let r = [];
      if (this.match(26))
        for (this.hasPlugin("decorators") && this.raise(P.UnsupportedPropertyDecorator, this.state.startLoc); this.match(26); )
          r.push(this.parseDecorator());
      let i = this.startNode(), n = !1, a = !1, o;
      if (this.match(21))
        return r.length && this.unexpected(), this.parseSpread();
      r.length && (i.decorators = r, r = []), i.method = !1, e && (o = this.state.startLoc);
      let l = this.eat(55);
      this.parsePropertyNamePrefixOperator(i);
      let u = this.state.containsEsc;
      if (this.parsePropertyName(i, e), !l && !u && this.maybeAsyncOrAccessorProp(i)) {
        let {
          key: p
        } = i, m = p.name;
        m === "async" && !this.hasPrecedingLineBreak() && (n = !0, this.resetPreviousNodeTrailingComments(p), l = this.eat(55), this.parsePropertyName(
        i)), (m === "get" || m === "set") && (a = !0, this.resetPreviousNodeTrailingComments(p), i.kind = m, this.match(55) && (l = !0, this.
        raise(P.AccessorIsGenerator, this.state.curPosition(), {
          kind: m
        }), this.next()), this.parsePropertyName(i));
      }
      return this.parseObjPropValue(i, o, l, n, !1, a, e);
    }
    getGetterSetterExpectedParamCount(e) {
      return e.kind === "get" ? 0 : 1;
    }
    getObjectOrClassMethodParams(e) {
      return e.params;
    }
    checkGetterSetterParams(e) {
      var r;
      let i = this.getGetterSetterExpectedParamCount(e), n = this.getObjectOrClassMethodParams(e);
      n.length !== i && this.raise(e.kind === "get" ? P.BadGetterArity : P.BadSetterArity, e), e.kind === "set" && ((r = n[n.length - 1]) ==
      null ? void 0 : r.type) === "RestElement" && this.raise(P.BadSetterRestParameter, e);
    }
    parseObjectMethod(e, r, i, n, a) {
      if (a) {
        let o = this.parseMethod(e, r, !1, !1, !1, "ObjectMethod");
        return this.checkGetterSetterParams(o), o;
      }
      if (i || r || this.match(10))
        return n && this.unexpected(), e.kind = "method", e.method = !0, this.parseMethod(e, r, i, !1, !1, "ObjectMethod");
    }
    parseObjectProperty(e, r, i, n) {
      if (e.shorthand = !1, this.eat(14))
        return e.value = i ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowIn(n), this.finishNode(e, "ObjectProper\
ty");
      if (!e.computed && e.key.type === "Identifier") {
        if (this.checkReservedWord(e.key.name, e.key.loc.start, !0, !1), i)
          e.value = this.parseMaybeDefault(r, Dt(e.key));
        else if (this.match(29)) {
          let a = this.state.startLoc;
          n != null ? n.shorthandAssignLoc === null && (n.shorthandAssignLoc = a) : this.raise(P.InvalidCoverInitializedName, a), e.value = this.
          parseMaybeDefault(r, Dt(e.key));
        } else
          e.value = Dt(e.key);
        return e.shorthand = !0, this.finishNode(e, "ObjectProperty");
      }
    }
    parseObjPropValue(e, r, i, n, a, o, l) {
      let u = this.parseObjectMethod(e, i, n, a, o) || this.parseObjectProperty(e, r, a, l);
      return u || this.unexpected(), u;
    }
    parsePropertyName(e, r) {
      if (this.eat(0))
        e.computed = !0, e.key = this.parseMaybeAssignAllowIn(), this.expect(3);
      else {
        let {
          type: i,
          value: n
        } = this.state, a;
        if (mt(i))
          a = this.parseIdentifier(!0);
        else
          switch (i) {
            case 135:
              a = this.parseNumericLiteral(n);
              break;
            case 134:
              a = this.parseStringLiteral(n);
              break;
            case 136:
              a = this.parseBigIntLiteral(n);
              break;
            case 139: {
              let o = this.state.startLoc;
              r != null ? r.privateKeyLoc === null && (r.privateKeyLoc = o) : this.raise(P.UnexpectedPrivateField, o), a = this.parsePrivateName();
              break;
            }
            default:
              if (i === 137) {
                a = this.parseDecimalLiteral(n);
                break;
              }
              this.unexpected();
          }
        e.key = a, i !== 139 && (e.computed = !1);
      }
    }
    initFunction(e, r) {
      e.id = null, e.generator = !1, e.async = r;
    }
    parseMethod(e, r, i, n, a, o, l = !1) {
      this.initFunction(e, i), e.generator = r, this.scope.enter(18 | (l ? 64 : 0) | (a ? 32 : 0)), this.prodParam.enter($i(i, e.generator)),
      this.parseFunctionParams(e, n);
      let u = this.parseFunctionBodyAndFinish(e, o, !0);
      return this.prodParam.exit(), this.scope.exit(), u;
    }
    parseArrayLike(e, r, i, n) {
      i && this.expectPlugin("recordAndTuple");
      let a = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !1;
      let o = this.startNode();
      return this.next(), o.elements = this.parseExprList(e, !i, n, o), this.state.inFSharpPipelineDirectBody = a, this.finishNode(o, i ? "T\
upleExpression" : "ArrayExpression");
    }
    parseArrowExpression(e, r, i, n) {
      this.scope.enter(6);
      let a = $i(i, !1);
      !this.match(5) && this.prodParam.hasIn && (a |= 8), this.prodParam.enter(a), this.initFunction(e, i);
      let o = this.state.maybeInArrowParameters;
      return r && (this.state.maybeInArrowParameters = !0, this.setArrowFunctionParameters(e, r, n)), this.state.maybeInArrowParameters = !1,
      this.parseFunctionBody(e, !0), this.prodParam.exit(), this.scope.exit(), this.state.maybeInArrowParameters = o, this.finishNode(e, "Ar\
rowFunctionExpression");
    }
    setArrowFunctionParameters(e, r, i) {
      this.toAssignableList(r, i, !1), e.params = r;
    }
    parseFunctionBodyAndFinish(e, r, i = !1) {
      return this.parseFunctionBody(e, !1, i), this.finishNode(e, r);
    }
    parseFunctionBody(e, r, i = !1) {
      let n = r && !this.match(5);
      if (this.expressionScope.enter(mp()), n)
        e.body = this.parseMaybeAssign(), this.checkParams(e, !1, r, !1);
      else {
        let a = this.state.strict, o = this.state.labels;
        this.state.labels = [], this.prodParam.enter(this.prodParam.currentFlags() | 4), e.body = this.parseBlock(!0, !1, (l) => {
          let u = !this.isSimpleParamList(e.params);
          l && u && this.raise(P.IllegalLanguageModeDirective, (e.kind === "method" || e.kind === "constructor") && e.key ? e.key.loc.end : e);
          let p = !a && this.state.strict;
          this.checkParams(e, !this.state.strict && !r && !i && !u, r, p), this.state.strict && e.id && this.checkIdentifier(e.id, 65, p);
        }), this.prodParam.exit(), this.state.labels = o;
      }
      this.expressionScope.exit();
    }
    isSimpleParameter(e) {
      return e.type === "Identifier";
    }
    isSimpleParamList(e) {
      for (let r = 0, i = e.length; r < i; r++)
        if (!this.isSimpleParameter(e[r])) return !1;
      return !0;
    }
    checkParams(e, r, i, n = !0) {
      let a = !r && /* @__PURE__ */ new Set(), o = {
        type: "FormalParameters"
      };
      for (let l of e.params)
        this.checkLVal(l, o, 5, a, n);
    }
    parseExprList(e, r, i, n) {
      let a = [], o = !0;
      for (; !this.eat(e); ) {
        if (o)
          o = !1;
        else if (this.expect(12), this.match(e)) {
          n && this.addTrailingCommaExtraToNode(n), this.next();
          break;
        }
        a.push(this.parseExprListItem(r, i));
      }
      return a;
    }
    parseExprListItem(e, r, i) {
      let n;
      if (this.match(12))
        e || this.raise(P.UnexpectedToken, this.state.curPosition(), {
          unexpected: ","
        }), n = null;
      else if (this.match(21)) {
        let a = this.state.startLoc;
        n = this.parseParenItem(this.parseSpread(r), a);
      } else if (this.match(17)) {
        this.expectPlugin("partialApplication"), i || this.raise(P.UnexpectedArgumentPlaceholder, this.state.startLoc);
        let a = this.startNode();
        this.next(), n = this.finishNode(a, "ArgumentPlaceholder");
      } else
        n = this.parseMaybeAssignAllowIn(r, this.parseParenItem);
      return n;
    }
    parseIdentifier(e) {
      let r = this.startNode(), i = this.parseIdentifierName(e);
      return this.createIdentifier(r, i);
    }
    createIdentifier(e, r) {
      return e.name = r, e.loc.identifierName = r, this.finishNode(e, "Identifier");
    }
    parseIdentifierName(e) {
      let r, {
        startLoc: i,
        type: n
      } = this.state;
      mt(n) ? r = this.state.value : this.unexpected();
      let a = E3(n);
      return e ? a && this.replaceToken(132) : this.checkReservedWord(r, i, a, !1), this.next(), r;
    }
    checkReservedWord(e, r, i, n) {
      if (e.length > 10 || !U3(e))
        return;
      if (i && F3(e)) {
        this.raise(P.UnexpectedKeyword, r, {
          keyword: e
        });
        return;
      }
      if ((this.state.strict ? n ? pp : up : lp)(e, this.inModule)) {
        this.raise(P.UnexpectedReservedWord, r, {
          reservedWord: e
        });
        return;
      } else if (e === "yield") {
        if (this.prodParam.hasYield) {
          this.raise(P.YieldBindingIdentifier, r);
          return;
        }
      } else if (e === "await") {
        if (this.prodParam.hasAwait) {
          this.raise(P.AwaitBindingIdentifier, r);
          return;
        }
        if (this.scope.inStaticBlock) {
          this.raise(P.AwaitBindingIdentifierInStaticBlock, r);
          return;
        }
        this.expressionScope.recordAsyncArrowParametersError(r);
      } else if (e === "arguments" && this.scope.inClassAndNotInNonArrowFunction) {
        this.raise(P.ArgumentsInClass, r);
        return;
      }
    }
    recordAwaitIfAllowed() {
      let e = this.prodParam.hasAwait || this.optionFlags & 1 && !this.scope.inFunction;
      return e && !this.scope.inFunction && (this.state.hasTopLevelAwait = !0), e;
    }
    parseAwait(e) {
      let r = this.startNodeAt(e);
      return this.expressionScope.recordParameterInitializerError(P.AwaitExpressionFormalParameter, r), this.eat(55) && this.raise(P.ObsoleteAwaitStar,
      r), !this.scope.inFunction && !(this.optionFlags & 1) && (this.isAmbiguousPrefixOrIdentifier() ? this.ambiguousScriptDifferentAst = !0 :
      this.sawUnambiguousESM = !0), this.state.soloAwait || (r.argument = this.parseMaybeUnary(null, !0)), this.finishNode(r, "AwaitExpressi\
on");
    }
    isAmbiguousPrefixOrIdentifier() {
      if (this.hasPrecedingLineBreak()) return !0;
      let {
        type: e
      } = this.state;
      return e === 53 || e === 10 || e === 0 || Gi(e) || e === 102 && !this.state.containsEsc || e === 138 || e === 56 || this.hasPlugin("v8\
intrinsic") && e === 54;
    }
    parseYield(e) {
      let r = this.startNodeAt(e);
      this.expressionScope.recordParameterInitializerError(P.YieldInParameter, r);
      let i = !1, n = null;
      if (!this.hasPrecedingLineBreak())
        switch (i = this.eat(55), this.state.type) {
          case 13:
          case 140:
          case 8:
          case 11:
          case 3:
          case 9:
          case 14:
          case 12:
            if (!i) break;
          default:
            n = this.parseMaybeAssign();
        }
      return r.delegate = i, r.argument = n, this.finishNode(r, "YieldExpression");
    }
    parseImportCall(e) {
      if (this.next(), e.source = this.parseMaybeAssignAllowIn(), e.options = null, this.eat(12) && !this.match(11) && (e.options = this.parseMaybeAssignAllowIn(),
      this.eat(12) && !this.match(11))) {
        do
          this.parseMaybeAssignAllowIn();
        while (this.eat(12) && !this.match(11));
        this.raise(P.ImportCallArity, e);
      }
      return this.expect(11), this.finishNode(e, "ImportExpression");
    }
    checkPipelineAtInfixOperator(e, r) {
      this.hasPlugin(["pipelineOperator", {
        proposal: "smart"
      }]) && e.type === "SequenceExpression" && this.raise(P.PipelineHeadSequenceExpression, r);
    }
    parseSmartPipelineBodyInStyle(e, r) {
      if (this.isSimpleReference(e)) {
        let i = this.startNodeAt(r);
        return i.callee = e, this.finishNode(i, "PipelineBareFunction");
      } else {
        let i = this.startNodeAt(r);
        return this.checkSmartPipeTopicBodyEarlyErrors(r), i.expression = e, this.finishNode(i, "PipelineTopicExpression");
      }
    }
    isSimpleReference(e) {
      switch (e.type) {
        case "MemberExpression":
          return !e.computed && this.isSimpleReference(e.object);
        case "Identifier":
          return !0;
        default:
          return !1;
      }
    }
    checkSmartPipeTopicBodyEarlyErrors(e) {
      if (this.match(19))
        throw this.raise(P.PipelineBodyNoArrow, this.state.startLoc);
      this.topicReferenceWasUsedInCurrentContext() || this.raise(P.PipelineTopicUnused, e);
    }
    withTopicBindingContext(e) {
      let r = this.state.topicContext;
      this.state.topicContext = {
        maxNumOfResolvableTopics: 1,
        maxTopicIndex: null
      };
      try {
        return e();
      } finally {
        this.state.topicContext = r;
      }
    }
    withSmartMixTopicForbiddingContext(e) {
      if (this.hasPlugin(["pipelineOperator", {
        proposal: "smart"
      }])) {
        let r = this.state.topicContext;
        this.state.topicContext = {
          maxNumOfResolvableTopics: 0,
          maxTopicIndex: null
        };
        try {
          return e();
        } finally {
          this.state.topicContext = r;
        }
      } else
        return e();
    }
    withSoloAwaitPermittingContext(e) {
      let r = this.state.soloAwait;
      this.state.soloAwait = !0;
      try {
        return e();
      } finally {
        this.state.soloAwait = r;
      }
    }
    allowInAnd(e) {
      let r = this.prodParam.currentFlags();
      if (8 & ~r) {
        this.prodParam.enter(r | 8);
        try {
          return e();
        } finally {
          this.prodParam.exit();
        }
      }
      return e();
    }
    disallowInAnd(e) {
      let r = this.prodParam.currentFlags();
      if (8 & r) {
        this.prodParam.enter(r & -9);
        try {
          return e();
        } finally {
          this.prodParam.exit();
        }
      }
      return e();
    }
    registerTopicReference() {
      this.state.topicContext.maxTopicIndex = 0;
    }
    topicReferenceIsAllowedInCurrentContext() {
      return this.state.topicContext.maxNumOfResolvableTopics >= 1;
    }
    topicReferenceWasUsedInCurrentContext() {
      return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
    }
    parseFSharpPipelineBody(e) {
      let r = this.state.startLoc;
      this.state.potentialArrowAt = this.state.start;
      let i = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !0;
      let n = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), r, e);
      return this.state.inFSharpPipelineDirectBody = i, n;
    }
    parseModuleExpression() {
      this.expectPlugin("moduleBlocks");
      let e = this.startNode();
      this.next(), this.match(5) || this.unexpected(null, 5);
      let r = this.startNodeAt(this.state.endLoc);
      this.next();
      let i = this.initializeScopes(!0);
      this.enterInitialScopes();
      try {
        e.body = this.parseProgram(r, 8, "module");
      } finally {
        i();
      }
      return this.finishNode(e, "ModuleExpression");
    }
    parsePropertyNamePrefixOperator(e) {
    }
  }, za = {
    kind: 1
  }, bB = {
    kind: 2
  }, xB = /[\uD800-\uDFFF]/u, $a = /in(?:stanceof)?/y;
  function PB(t, e, r) {
    for (let i = 0; i < t.length; i++) {
      let n = t[i], {
        type: a
      } = n;
      if (typeof a == "number") {
        {
          if (a === 139) {
            let {
              loc: o,
              start: l,
              value: u,
              end: p
            } = n, m = l + 1, g = Ze(o.start, 1);
            t.splice(i, 1, new Pt({
              type: wt(27),
              value: "#",
              start: l,
              end: m,
              startLoc: o.start,
              endLoc: g
            }), new Pt({
              type: wt(132),
              value: u,
              start: m,
              end: p,
              startLoc: g,
              endLoc: o.end
            })), i++;
            continue;
          }
          if (Gi(a)) {
            let {
              loc: o,
              start: l,
              value: u,
              end: p
            } = n, m = l + 1, g = Ze(o.start, 1), I;
            e.charCodeAt(l - r) === 96 ? I = new Pt({
              type: wt(22),
              value: "`",
              start: l,
              end: m,
              startLoc: o.start,
              endLoc: g
            }) : I = new Pt({
              type: wt(8),
              value: "}",
              start: l,
              end: m,
              startLoc: o.start,
              endLoc: g
            });
            let v, _, V, D;
            a === 24 ? (_ = p - 1, V = Ze(o.end, -1), v = u === null ? null : u.slice(1, -1), D = new Pt({
              type: wt(22),
              value: "`",
              start: _,
              end: p,
              startLoc: V,
              endLoc: o.end
            })) : (_ = p - 2, V = Ze(o.end, -2), v = u === null ? null : u.slice(1, -2), D = new Pt({
              type: wt(23),
              value: "${",
              start: _,
              end: p,
              startLoc: V,
              endLoc: o.end
            })), t.splice(i, 1, I, new Pt({
              type: wt(20),
              value: v,
              start: m,
              end: _,
              startLoc: g,
              endLoc: V
            }), D), i += 2;
            continue;
          }
        }
        n.type = wt(a);
      }
    }
    return t;
  }
  s(PB, "babel7CompatTokens");
  var mo = class extends ho {
    static {
      s(this, "StatementParser");
    }
    parseTopLevel(e, r) {
      return e.program = this.parseProgram(r), e.comments = this.comments, this.optionFlags & 256 && (e.tokens = PB(this.tokens, this.input,
      this.startIndex)), this.finishNode(e, "File");
    }
    parseProgram(e, r = 140, i = this.options.sourceType) {
      if (e.sourceType = i, e.interpreter = this.parseInterpreterDirective(), this.parseBlockBody(e, !0, !0, r), this.inModule) {
        if (!(this.optionFlags & 64) && this.scope.undefinedExports.size > 0)
          for (let [a, o] of Array.from(this.scope.undefinedExports))
            this.raise(P.ModuleExportUndefined, o, {
              localName: a
            });
        this.addExtra(e, "topLevelAwait", this.state.hasTopLevelAwait);
      }
      let n;
      return r === 140 ? n = this.finishNode(e, "Program") : n = this.finishNodeAt(e, "Program", Ze(this.state.startLoc, -1)), n;
    }
    stmtToDirective(e) {
      let r = e;
      r.type = "Directive", r.value = r.expression, delete r.expression;
      let i = r.value, n = i.value, a = this.input.slice(this.offsetToSourcePos(i.start), this.offsetToSourcePos(i.end)), o = i.value = a.slice(
      1, -1);
      return this.addExtra(i, "raw", a), this.addExtra(i, "rawValue", o), this.addExtra(i, "expressionValue", n), i.type = "DirectiveLiteral",
      r;
    }
    parseInterpreterDirective() {
      if (!this.match(28))
        return null;
      let e = this.startNode();
      return e.value = this.state.value, this.next(), this.finishNode(e, "InterpreterDirective");
    }
    isLet() {
      return this.isContextual(100) ? this.hasFollowingBindingAtom() : !1;
    }
    chStartsBindingIdentifier(e, r) {
      if (Ot(e)) {
        if ($a.lastIndex = r, $a.test(this.input)) {
          let i = this.codePointAtPos($a.lastIndex);
          if (!dr(i) && i !== 92)
            return !1;
        }
        return !0;
      } else return e === 92;
    }
    chStartsBindingPattern(e) {
      return e === 91 || e === 123;
    }
    hasFollowingBindingAtom() {
      let e = this.nextTokenStart(), r = this.codePointAtPos(e);
      return this.chStartsBindingPattern(r) || this.chStartsBindingIdentifier(r, e);
    }
    hasInLineFollowingBindingIdentifierOrBrace() {
      let e = this.nextTokenInLineStart(), r = this.codePointAtPos(e);
      return r === 123 || this.chStartsBindingIdentifier(r, e);
    }
    startsUsingForOf() {
      let {
        type: e,
        containsEsc: r
      } = this.lookahead();
      if (e === 102 && !r)
        return !1;
      if (ve(e) && !this.hasFollowingLineBreak())
        return this.expectPlugin("explicitResourceManagement"), !0;
    }
    startsAwaitUsing() {
      let e = this.nextTokenInLineStart();
      if (this.isUnparsedContextual(e, "using")) {
        e = this.nextTokenInLineStartSince(e + 5);
        let r = this.codePointAtPos(e);
        if (this.chStartsBindingIdentifier(r, e))
          return this.expectPlugin("explicitResourceManagement"), !0;
      }
      return !1;
    }
    parseModuleItem() {
      return this.parseStatementLike(15);
    }
    parseStatementListItem() {
      return this.parseStatementLike(6 | (!this.options.annexB || this.state.strict ? 0 : 8));
    }
    parseStatementOrSloppyAnnexBFunctionDeclaration(e = !1) {
      let r = 0;
      return this.options.annexB && !this.state.strict && (r |= 4, e && (r |= 8)), this.parseStatementLike(r);
    }
    parseStatement() {
      return this.parseStatementLike(0);
    }
    parseStatementLike(e) {
      let r = null;
      return this.match(26) && (r = this.parseDecorators(!0)), this.parseStatementContent(e, r);
    }
    parseStatementContent(e, r) {
      let i = this.state.type, n = this.startNode(), a = !!(e & 2), o = !!(e & 4), l = e & 1;
      switch (i) {
        case 60:
          return this.parseBreakContinueStatement(n, !0);
        case 63:
          return this.parseBreakContinueStatement(n, !1);
        case 64:
          return this.parseDebuggerStatement(n);
        case 90:
          return this.parseDoWhileStatement(n);
        case 91:
          return this.parseForStatement(n);
        case 68:
          if (this.lookaheadCharCode() === 46) break;
          return o || this.raise(this.state.strict ? P.StrictFunction : this.options.annexB ? P.SloppyFunctionAnnexB : P.SloppyFunction, this.
          state.startLoc), this.parseFunctionStatement(n, !1, !a && o);
        case 80:
          return a || this.unexpected(), this.parseClass(this.maybeTakeDecorators(r, n), !0);
        case 69:
          return this.parseIfStatement(n);
        case 70:
          return this.parseReturnStatement(n);
        case 71:
          return this.parseSwitchStatement(n);
        case 72:
          return this.parseThrowStatement(n);
        case 73:
          return this.parseTryStatement(n);
        case 96:
          if (!this.state.containsEsc && this.startsAwaitUsing())
            return this.recordAwaitIfAllowed() ? a || this.raise(P.UnexpectedLexicalDeclaration, n) : this.raise(P.AwaitUsingNotInAsyncContext,
            n), this.next(), this.parseVarStatement(n, "await using");
          break;
        case 107:
          if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifierOrBrace())
            break;
          return this.expectPlugin("explicitResourceManagement"), !this.scope.inModule && this.scope.inTopLevel ? this.raise(P.UnexpectedUsingDeclaration,
          this.state.startLoc) : a || this.raise(P.UnexpectedLexicalDeclaration, this.state.startLoc), this.parseVarStatement(n, "using");
        case 100: {
          if (this.state.containsEsc)
            break;
          let m = this.nextTokenStart(), g = this.codePointAtPos(m);
          if (g !== 91 && (!a && this.hasFollowingLineBreak() || !this.chStartsBindingIdentifier(g, m) && g !== 123))
            break;
        }
        case 75:
          a || this.raise(P.UnexpectedLexicalDeclaration, this.state.startLoc);
        case 74: {
          let m = this.state.value;
          return this.parseVarStatement(n, m);
        }
        case 92:
          return this.parseWhileStatement(n);
        case 76:
          return this.parseWithStatement(n);
        case 5:
          return this.parseBlock();
        case 13:
          return this.parseEmptyStatement(n);
        case 83: {
          let m = this.lookaheadCharCode();
          if (m === 40 || m === 46)
            break;
        }
        case 82: {
          !(this.optionFlags & 8) && !l && this.raise(P.UnexpectedImportExport, this.state.startLoc), this.next();
          let m;
          return i === 83 ? m = this.parseImport(n) : m = this.parseExport(n, r), this.assertModuleNodeAllowed(m), m;
        }
        default:
          if (this.isAsyncFunction())
            return a || this.raise(P.AsyncFunctionInSingleStatementContext, this.state.startLoc), this.next(), this.parseFunctionStatement(n,
            !0, !a && o);
      }
      let u = this.state.value, p = this.parseExpression();
      return ve(i) && p.type === "Identifier" && this.eat(14) ? this.parseLabeledStatement(n, u, p, e) : this.parseExpressionStatement(n, p,
      r);
    }
    assertModuleNodeAllowed(e) {
      !(this.optionFlags & 8) && !this.inModule && this.raise(P.ImportOutsideModule, e);
    }
    decoratorsEnabledBeforeExport() {
      return this.hasPlugin("decorators-legacy") ? !0 : this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBefore\
Export") !== !1;
    }
    maybeTakeDecorators(e, r, i) {
      if (e) {
        var n;
        (n = r.decorators) != null && n.length ? (typeof this.getPluginOption("decorators", "decoratorsBeforeExport") != "boolean" && this.raise(
        P.DecoratorsBeforeAfterExport, r.decorators[0]), r.decorators.unshift(...e)) : r.decorators = e, this.resetStartLocationFromNode(r, e[0]),
        i && this.resetStartLocationFromNode(i, r);
      }
      return r;
    }
    canHaveLeadingDecorator() {
      return this.match(80);
    }
    parseDecorators(e) {
      let r = [];
      do
        r.push(this.parseDecorator());
      while (this.match(26));
      if (this.match(82))
        e || this.unexpected(), this.decoratorsEnabledBeforeExport() || this.raise(P.DecoratorExportClass, this.state.startLoc);
      else if (!this.canHaveLeadingDecorator())
        throw this.raise(P.UnexpectedLeadingDecorator, this.state.startLoc);
      return r;
    }
    parseDecorator() {
      this.expectOnePlugin(["decorators", "decorators-legacy"]);
      let e = this.startNode();
      if (this.next(), this.hasPlugin("decorators")) {
        let r = this.state.startLoc, i;
        if (this.match(10)) {
          let n = this.state.startLoc;
          this.next(), i = this.parseExpression(), this.expect(11), i = this.wrapParenthesis(n, i);
          let a = this.state.startLoc;
          e.expression = this.parseMaybeDecoratorArguments(i, n), this.getPluginOption("decorators", "allowCallParenthesized") === !1 && e.expression !==
          i && this.raise(P.DecoratorArgumentsOutsideParentheses, a);
        } else {
          for (i = this.parseIdentifier(!1); this.eat(16); ) {
            let n = this.startNodeAt(r);
            n.object = i, this.match(139) ? (this.classScope.usePrivateName(this.state.value, this.state.startLoc), n.property = this.parsePrivateName()) :
            n.property = this.parseIdentifier(!0), n.computed = !1, i = this.finishNode(n, "MemberExpression");
          }
          e.expression = this.parseMaybeDecoratorArguments(i, r);
        }
      } else
        e.expression = this.parseExprSubscripts();
      return this.finishNode(e, "Decorator");
    }
    parseMaybeDecoratorArguments(e, r) {
      if (this.eat(10)) {
        let i = this.startNodeAt(r);
        return i.callee = e, i.arguments = this.parseCallExpressionArguments(11), this.toReferencedList(i.arguments), this.finishNode(i, "Ca\
llExpression");
      }
      return e;
    }
    parseBreakContinueStatement(e, r) {
      return this.next(), this.isLineTerminator() ? e.label = null : (e.label = this.parseIdentifier(), this.semicolon()), this.verifyBreakContinue(
      e, r), this.finishNode(e, r ? "BreakStatement" : "ContinueStatement");
    }
    verifyBreakContinue(e, r) {
      let i;
      for (i = 0; i < this.state.labels.length; ++i) {
        let n = this.state.labels[i];
        if ((e.label == null || n.name === e.label.name) && (n.kind != null && (r || n.kind === 1) || e.label && r))
          break;
      }
      if (i === this.state.labels.length) {
        let n = r ? "BreakStatement" : "ContinueStatement";
        this.raise(P.IllegalBreakContinue, e, {
          type: n
        });
      }
    }
    parseDebuggerStatement(e) {
      return this.next(), this.semicolon(), this.finishNode(e, "DebuggerStatement");
    }
    parseHeaderExpression() {
      this.expect(10);
      let e = this.parseExpression();
      return this.expect(11), e;
    }
    parseDoWhileStatement(e) {
      return this.next(), this.state.labels.push(za), e.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.
      labels.pop(), this.expect(92), e.test = this.parseHeaderExpression(), this.eat(13), this.finishNode(e, "DoWhileStatement");
    }
    parseForStatement(e) {
      this.next(), this.state.labels.push(za);
      let r = null;
      if (this.isContextual(96) && this.recordAwaitIfAllowed() && (r = this.state.startLoc, this.next()), this.scope.enter(0), this.expect(10),
      this.match(13))
        return r !== null && this.unexpected(r), this.parseFor(e, null);
      let i = this.isContextual(100);
      {
        let u = this.isContextual(96) && this.startsAwaitUsing(), p = u || this.isContextual(107) && this.startsUsingForOf(), m = i && this.
        hasFollowingBindingAtom() || p;
        if (this.match(74) || this.match(75) || m) {
          let g = this.startNode(), I;
          u ? (I = "await using", this.recordAwaitIfAllowed() || this.raise(P.AwaitUsingNotInAsyncContext, this.state.startLoc), this.next()) :
          I = this.state.value, this.next(), this.parseVar(g, !0, I);
          let v = this.finishNode(g, "VariableDeclaration"), _ = this.match(58);
          return _ && p && this.raise(P.ForInUsing, v), (_ || this.isContextual(102)) && v.declarations.length === 1 ? this.parseForIn(e, v,
          r) : (r !== null && this.unexpected(r), this.parseFor(e, v));
        }
      }
      let n = this.isContextual(95), a = new yr(), o = this.parseExpression(!0, a), l = this.isContextual(102);
      if (l && (i && this.raise(P.ForOfLet, o), r === null && n && o.type === "Identifier" && this.raise(P.ForOfAsync, o)), l || this.match(
      58)) {
        this.checkDestructuringPrivate(a), this.toAssignable(o, !0);
        let u = l ? "ForOfStatement" : "ForInStatement";
        return this.checkLVal(o, {
          type: u
        }), this.parseForIn(e, o, r);
      } else
        this.checkExpressionErrors(a, !0);
      return r !== null && this.unexpected(r), this.parseFor(e, o);
    }
    parseFunctionStatement(e, r, i) {
      return this.next(), this.parseFunction(e, 1 | (i ? 2 : 0) | (r ? 8 : 0));
    }
    parseIfStatement(e) {
      return this.next(), e.test = this.parseHeaderExpression(), e.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration(), e.alternate =
      this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null, this.finishNode(e, "IfStatement");
    }
    parseReturnStatement(e) {
      return !this.prodParam.hasReturn && !(this.optionFlags & 2) && this.raise(P.IllegalReturn, this.state.startLoc), this.next(), this.isLineTerminator() ?
      e.argument = null : (e.argument = this.parseExpression(), this.semicolon()), this.finishNode(e, "ReturnStatement");
    }
    parseSwitchStatement(e) {
      this.next(), e.discriminant = this.parseHeaderExpression();
      let r = e.cases = [];
      this.expect(5), this.state.labels.push(bB), this.scope.enter(0);
      let i;
      for (let n; !this.match(8); )
        if (this.match(61) || this.match(65)) {
          let a = this.match(61);
          i && this.finishNode(i, "SwitchCase"), r.push(i = this.startNode()), i.consequent = [], this.next(), a ? i.test = this.parseExpression() :
          (n && this.raise(P.MultipleDefaultsInSwitch, this.state.lastTokStartLoc), n = !0, i.test = null), this.expect(14);
        } else
          i ? i.consequent.push(this.parseStatementListItem()) : this.unexpected();
      return this.scope.exit(), i && this.finishNode(i, "SwitchCase"), this.next(), this.state.labels.pop(), this.finishNode(e, "SwitchState\
ment");
    }
    parseThrowStatement(e) {
      return this.next(), this.hasPrecedingLineBreak() && this.raise(P.NewlineAfterThrow, this.state.lastTokEndLoc), e.argument = this.parseExpression(),
      this.semicolon(), this.finishNode(e, "ThrowStatement");
    }
    parseCatchClauseParam() {
      let e = this.parseBindingAtom();
      return this.scope.enter(this.options.annexB && e.type === "Identifier" ? 8 : 0), this.checkLVal(e, {
        type: "CatchClause"
      }, 9), e;
    }
    parseTryStatement(e) {
      if (this.next(), e.block = this.parseBlock(), e.handler = null, this.match(62)) {
        let r = this.startNode();
        this.next(), this.match(10) ? (this.expect(10), r.param = this.parseCatchClauseParam(), this.expect(11)) : (r.param = null, this.scope.
        enter(0)), r.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(!1, !1)), this.scope.exit(), e.handler = this.finishNode(
        r, "CatchClause");
      }
      return e.finalizer = this.eat(67) ? this.parseBlock() : null, !e.handler && !e.finalizer && this.raise(P.NoCatchOrFinally, e), this.finishNode(
      e, "TryStatement");
    }
    parseVarStatement(e, r, i = !1) {
      return this.next(), this.parseVar(e, !1, r, i), this.semicolon(), this.finishNode(e, "VariableDeclaration");
    }
    parseWhileStatement(e) {
      return this.next(), e.test = this.parseHeaderExpression(), this.state.labels.push(za), e.body = this.withSmartMixTopicForbiddingContext(
      () => this.parseStatement()), this.state.labels.pop(), this.finishNode(e, "WhileStatement");
    }
    parseWithStatement(e) {
      return this.state.strict && this.raise(P.StrictWith, this.state.startLoc), this.next(), e.object = this.parseHeaderExpression(), e.body =
      this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.finishNode(e, "WithStatement");
    }
    parseEmptyStatement(e) {
      return this.next(), this.finishNode(e, "EmptyStatement");
    }
    parseLabeledStatement(e, r, i, n) {
      for (let o of this.state.labels)
        o.name === r && this.raise(P.LabelRedeclaration, i, {
          labelName: r
        });
      let a = I3(this.state.type) ? 1 : this.match(71) ? 2 : null;
      for (let o = this.state.labels.length - 1; o >= 0; o--) {
        let l = this.state.labels[o];
        if (l.statementStart === e.start)
          l.statementStart = this.sourceToOffsetPos(this.state.start), l.kind = a;
        else
          break;
      }
      return this.state.labels.push({
        name: r,
        kind: a,
        statementStart: this.sourceToOffsetPos(this.state.start)
      }), e.body = n & 8 ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(!0) : this.parseStatement(), this.state.labels.pop(), e.label =
      i, this.finishNode(e, "LabeledStatement");
    }
    parseExpressionStatement(e, r, i) {
      return e.expression = r, this.semicolon(), this.finishNode(e, "ExpressionStatement");
    }
    parseBlock(e = !1, r = !0, i) {
      let n = this.startNode();
      return e && this.state.strictErrors.clear(), this.expect(5), r && this.scope.enter(0), this.parseBlockBody(n, e, !1, 8, i), r && this.
      scope.exit(), this.finishNode(n, "BlockStatement");
    }
    isValidDirective(e) {
      return e.type === "ExpressionStatement" && e.expression.type === "StringLiteral" && !e.expression.extra.parenthesized;
    }
    parseBlockBody(e, r, i, n, a) {
      let o = e.body = [], l = e.directives = [];
      this.parseBlockOrModuleBlockBody(o, r ? l : void 0, i, n, a);
    }
    parseBlockOrModuleBlockBody(e, r, i, n, a) {
      let o = this.state.strict, l = !1, u = !1;
      for (; !this.match(n); ) {
        let p = i ? this.parseModuleItem() : this.parseStatementListItem();
        if (r && !u) {
          if (this.isValidDirective(p)) {
            let m = this.stmtToDirective(p);
            r.push(m), !l && m.value.value === "use strict" && (l = !0, this.setStrict(!0));
            continue;
          }
          u = !0, this.state.strictErrors.clear();
        }
        e.push(p);
      }
      a?.call(this, l), o || this.setStrict(!1), this.next();
    }
    parseFor(e, r) {
      return e.init = r, this.semicolon(!1), e.test = this.match(13) ? null : this.parseExpression(), this.semicolon(!1), e.update = this.match(
      11) ? null : this.parseExpression(), this.expect(11), e.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.
      scope.exit(), this.state.labels.pop(), this.finishNode(e, "ForStatement");
    }
    parseForIn(e, r, i) {
      let n = this.match(58);
      return this.next(), n ? i !== null && this.unexpected(i) : e.await = i !== null, r.type === "VariableDeclaration" && r.declarations[0].
      init != null && (!n || !this.options.annexB || this.state.strict || r.kind !== "var" || r.declarations[0].id.type !== "Identifier") &&
      this.raise(P.ForInOfLoopInitializer, r, {
        type: n ? "ForInStatement" : "ForOfStatement"
      }), r.type === "AssignmentPattern" && this.raise(P.InvalidLhs, r, {
        ancestor: {
          type: "ForStatement"
        }
      }), e.left = r, e.right = n ? this.parseExpression() : this.parseMaybeAssignAllowIn(), this.expect(11), e.body = this.withSmartMixTopicForbiddingContext(
      () => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(e, n ? "ForInStatement" : "ForOfStatement");
    }
    parseVar(e, r, i, n = !1) {
      let a = e.declarations = [];
      for (e.kind = i; ; ) {
        let o = this.startNode();
        if (this.parseVarId(o, i), o.init = this.eat(29) ? r ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn() : null, o.
        init === null && !n && (o.id.type !== "Identifier" && !(r && (this.match(58) || this.isContextual(102))) ? this.raise(P.DeclarationMissingInitializer,
        this.state.lastTokEndLoc, {
          kind: "destructuring"
        }) : (i === "const" || i === "using" || i === "await using") && !(this.match(58) || this.isContextual(102)) && this.raise(P.DeclarationMissingInitializer,
        this.state.lastTokEndLoc, {
          kind: i
        })), a.push(this.finishNode(o, "VariableDeclarator")), !this.eat(12)) break;
      }
      return e;
    }
    parseVarId(e, r) {
      let i = this.parseBindingAtom();
      (r === "using" || r === "await using") && (i.type === "ArrayPattern" || i.type === "ObjectPattern") && this.raise(P.UsingDeclarationHasBindingPattern,
      i.loc.start), this.checkLVal(i, {
        type: "VariableDeclarator"
      }, r === "var" ? 5 : 8201), e.id = i;
    }
    parseAsyncFunctionExpression(e) {
      return this.parseFunction(e, 8);
    }
    parseFunction(e, r = 0) {
      let i = r & 2, n = !!(r & 1), a = n && !(r & 4), o = !!(r & 8);
      this.initFunction(e, o), this.match(55) && (i && this.raise(P.GeneratorInSingleStatementContext, this.state.startLoc), this.next(), e.
      generator = !0), n && (e.id = this.parseFunctionId(a));
      let l = this.state.maybeInArrowParameters;
      return this.state.maybeInArrowParameters = !1, this.scope.enter(2), this.prodParam.enter($i(o, e.generator)), n || (e.id = this.parseFunctionId()),
      this.parseFunctionParams(e, !1), this.withSmartMixTopicForbiddingContext(() => {
        this.parseFunctionBodyAndFinish(e, n ? "FunctionDeclaration" : "FunctionExpression");
      }), this.prodParam.exit(), this.scope.exit(), n && !i && this.registerFunctionStatementId(e), this.state.maybeInArrowParameters = l, e;
    }
    parseFunctionId(e) {
      return e || ve(this.state.type) ? this.parseIdentifier() : null;
    }
    parseFunctionParams(e, r) {
      this.expect(10), this.expressionScope.enter($3()), e.params = this.parseBindingList(11, 41, 2 | (r ? 4 : 0)), this.expressionScope.exit();
    }
    registerFunctionStatementId(e) {
      e.id && this.scope.declareName(e.id.name, !this.options.annexB || this.state.strict || e.generator || e.async ? this.scope.treatFunctionsAsVar ?
      5 : 8201 : 17, e.id.loc.start);
    }
    parseClass(e, r, i) {
      this.next();
      let n = this.state.strict;
      return this.state.strict = !0, this.parseClassId(e, r, i), this.parseClassSuper(e), e.body = this.parseClassBody(!!e.superClass, n), this.
      finishNode(e, r ? "ClassDeclaration" : "ClassExpression");
    }
    isClassProperty() {
      return this.match(29) || this.match(13) || this.match(8);
    }
    isClassMethod() {
      return this.match(10);
    }
    nameIsConstructor(e) {
      return e.type === "Identifier" && e.name === "constructor" || e.type === "StringLiteral" && e.value === "constructor";
    }
    isNonstaticConstructor(e) {
      return !e.computed && !e.static && this.nameIsConstructor(e.key);
    }
    parseClassBody(e, r) {
      this.classScope.enter();
      let i = {
        hadConstructor: !1,
        hadSuperClass: e
      }, n = [], a = this.startNode();
      if (a.body = [], this.expect(5), this.withSmartMixTopicForbiddingContext(() => {
        for (; !this.match(8); ) {
          if (this.eat(13)) {
            if (n.length > 0)
              throw this.raise(P.DecoratorSemicolon, this.state.lastTokEndLoc);
            continue;
          }
          if (this.match(26)) {
            n.push(this.parseDecorator());
            continue;
          }
          let o = this.startNode();
          n.length && (o.decorators = n, this.resetStartLocationFromNode(o, n[0]), n = []), this.parseClassMember(a, o, i), o.kind === "cons\
tructor" && o.decorators && o.decorators.length > 0 && this.raise(P.DecoratorConstructor, o);
        }
      }), this.state.strict = r, this.next(), n.length)
        throw this.raise(P.TrailingDecorator, this.state.startLoc);
      return this.classScope.exit(), this.finishNode(a, "ClassBody");
    }
    parseClassMemberFromModifier(e, r) {
      let i = this.parseIdentifier(!0);
      if (this.isClassMethod()) {
        let n = r;
        return n.kind = "method", n.computed = !1, n.key = i, n.static = !1, this.pushClassMethod(e, n, !1, !1, !1, !1), !0;
      } else if (this.isClassProperty()) {
        let n = r;
        return n.computed = !1, n.key = i, n.static = !1, e.body.push(this.parseClassProperty(n)), !0;
      }
      return this.resetPreviousNodeTrailingComments(i), !1;
    }
    parseClassMember(e, r, i) {
      let n = this.isContextual(106);
      if (n) {
        if (this.parseClassMemberFromModifier(e, r))
          return;
        if (this.eat(5)) {
          this.parseClassStaticBlock(e, r);
          return;
        }
      }
      this.parseClassMemberWithIsStatic(e, r, i, n);
    }
    parseClassMemberWithIsStatic(e, r, i, n) {
      let a = r, o = r, l = r, u = r, p = r, m = a, g = a;
      if (r.static = n, this.parsePropertyNamePrefixOperator(r), this.eat(55)) {
        m.kind = "method";
        let L = this.match(139);
        if (this.parseClassElementName(m), L) {
          this.pushClassPrivateMethod(e, o, !0, !1);
          return;
        }
        this.isNonstaticConstructor(a) && this.raise(P.ConstructorIsGenerator, a.key), this.pushClassMethod(e, a, !0, !1, !1, !1);
        return;
      }
      let I = !this.state.containsEsc && ve(this.state.type), v = this.parseClassElementName(r), _ = I ? v.name : null, V = this.isPrivateName(
      v), D = this.state.startLoc;
      if (this.parsePostMemberNameModifiers(g), this.isClassMethod()) {
        if (m.kind = "method", V) {
          this.pushClassPrivateMethod(e, o, !1, !1);
          return;
        }
        let L = this.isNonstaticConstructor(a), B = !1;
        L && (a.kind = "constructor", i.hadConstructor && !this.hasPlugin("typescript") && this.raise(P.DuplicateConstructor, v), L && this.
        hasPlugin("typescript") && r.override && this.raise(P.OverrideOnConstructor, v), i.hadConstructor = !0, B = i.hadSuperClass), this.pushClassMethod(
        e, a, !1, !1, L, B);
      } else if (this.isClassProperty())
        V ? this.pushClassPrivateProperty(e, u) : this.pushClassProperty(e, l);
      else if (_ === "async" && !this.isLineTerminator()) {
        this.resetPreviousNodeTrailingComments(v);
        let L = this.eat(55);
        g.optional && this.unexpected(D), m.kind = "method";
        let B = this.match(139);
        this.parseClassElementName(m), this.parsePostMemberNameModifiers(g), B ? this.pushClassPrivateMethod(e, o, L, !0) : (this.isNonstaticConstructor(
        a) && this.raise(P.ConstructorIsAsync, a.key), this.pushClassMethod(e, a, L, !0, !1, !1));
      } else if ((_ === "get" || _ === "set") && !(this.match(55) && this.isLineTerminator())) {
        this.resetPreviousNodeTrailingComments(v), m.kind = _;
        let L = this.match(139);
        this.parseClassElementName(a), L ? this.pushClassPrivateMethod(e, o, !1, !1) : (this.isNonstaticConstructor(a) && this.raise(P.ConstructorIsAccessor,
        a.key), this.pushClassMethod(e, a, !1, !1, !1, !1)), this.checkGetterSetterParams(a);
      } else if (_ === "accessor" && !this.isLineTerminator()) {
        this.expectPlugin("decoratorAutoAccessors"), this.resetPreviousNodeTrailingComments(v);
        let L = this.match(139);
        this.parseClassElementName(l), this.pushClassAccessorProperty(e, p, L);
      } else this.isLineTerminator() ? V ? this.pushClassPrivateProperty(e, u) : this.pushClassProperty(e, l) : this.unexpected();
    }
    parseClassElementName(e) {
      let {
        type: r,
        value: i
      } = this.state;
      if ((r === 132 || r === 134) && e.static && i === "prototype" && this.raise(P.StaticPrototype, this.state.startLoc), r === 139) {
        i === "constructor" && this.raise(P.ConstructorClassPrivateField, this.state.startLoc);
        let n = this.parsePrivateName();
        return e.key = n, n;
      }
      return this.parsePropertyName(e), e.key;
    }
    parseClassStaticBlock(e, r) {
      var i;
      this.scope.enter(208);
      let n = this.state.labels;
      this.state.labels = [], this.prodParam.enter(0);
      let a = r.body = [];
      this.parseBlockOrModuleBlockBody(a, void 0, !1, 8), this.prodParam.exit(), this.scope.exit(), this.state.labels = n, e.body.push(this.
      finishNode(r, "StaticBlock")), (i = r.decorators) != null && i.length && this.raise(P.DecoratorStaticBlock, r);
    }
    pushClassProperty(e, r) {
      !r.computed && this.nameIsConstructor(r.key) && this.raise(P.ConstructorClassField, r.key), e.body.push(this.parseClassProperty(r));
    }
    pushClassPrivateProperty(e, r) {
      let i = this.parseClassPrivateProperty(r);
      e.body.push(i), this.classScope.declarePrivateName(this.getPrivateNameSV(i.key), 0, i.key.loc.start);
    }
    pushClassAccessorProperty(e, r, i) {
      !i && !r.computed && this.nameIsConstructor(r.key) && this.raise(P.ConstructorClassField, r.key);
      let n = this.parseClassAccessorProperty(r);
      e.body.push(n), i && this.classScope.declarePrivateName(this.getPrivateNameSV(n.key), 0, n.key.loc.start);
    }
    pushClassMethod(e, r, i, n, a, o) {
      e.body.push(this.parseMethod(r, i, n, a, o, "ClassMethod", !0));
    }
    pushClassPrivateMethod(e, r, i, n) {
      let a = this.parseMethod(r, i, n, !1, !1, "ClassPrivateMethod", !0);
      e.body.push(a);
      let o = a.kind === "get" ? a.static ? 6 : 2 : a.kind === "set" ? a.static ? 5 : 1 : 0;
      this.declareClassPrivateMethodInScope(a, o);
    }
    declareClassPrivateMethodInScope(e, r) {
      this.classScope.declarePrivateName(this.getPrivateNameSV(e.key), r, e.key.loc.start);
    }
    parsePostMemberNameModifiers(e) {
    }
    parseClassPrivateProperty(e) {
      return this.parseInitializer(e), this.semicolon(), this.finishNode(e, "ClassPrivateProperty");
    }
    parseClassProperty(e) {
      return this.parseInitializer(e), this.semicolon(), this.finishNode(e, "ClassProperty");
    }
    parseClassAccessorProperty(e) {
      return this.parseInitializer(e), this.semicolon(), this.finishNode(e, "ClassAccessorProperty");
    }
    parseInitializer(e) {
      this.scope.enter(80), this.expressionScope.enter(mp()), this.prodParam.enter(0), e.value = this.eat(29) ? this.parseMaybeAssignAllowIn() :
      null, this.expressionScope.exit(), this.prodParam.exit(), this.scope.exit();
    }
    parseClassId(e, r, i, n = 8331) {
      if (ve(this.state.type))
        e.id = this.parseIdentifier(), r && this.declareNameFromIdentifier(e.id, n);
      else if (i || !r)
        e.id = null;
      else
        throw this.raise(P.MissingClassName, this.state.startLoc);
    }
    parseClassSuper(e) {
      e.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
    }
    parseExport(e, r) {
      let i = this.parseMaybeImportPhase(e, !0), n = this.maybeParseExportDefaultSpecifier(e, i), a = !n || this.eat(12), o = a && this.eatExportStar(
      e), l = o && this.maybeParseExportNamespaceSpecifier(e), u = a && (!l || this.eat(12)), p = n || o;
      if (o && !l) {
        if (n && this.unexpected(), r)
          throw this.raise(P.UnsupportedDecoratorExport, e);
        return this.parseExportFrom(e, !0), this.sawUnambiguousESM = !0, this.finishNode(e, "ExportAllDeclaration");
      }
      let m = this.maybeParseExportNamedSpecifiers(e);
      n && a && !o && !m && this.unexpected(null, 5), l && u && this.unexpected(null, 98);
      let g;
      if (p || m) {
        if (g = !1, r)
          throw this.raise(P.UnsupportedDecoratorExport, e);
        this.parseExportFrom(e, p);
      } else
        g = this.maybeParseExportDeclaration(e);
      if (p || m || g) {
        var I;
        let v = e;
        if (this.checkExport(v, !0, !1, !!v.source), ((I = v.declaration) == null ? void 0 : I.type) === "ClassDeclaration")
          this.maybeTakeDecorators(r, v.declaration, v);
        else if (r)
          throw this.raise(P.UnsupportedDecoratorExport, e);
        return this.sawUnambiguousESM = !0, this.finishNode(v, "ExportNamedDeclaration");
      }
      if (this.eat(65)) {
        let v = e, _ = this.parseExportDefaultExpression();
        if (v.declaration = _, _.type === "ClassDeclaration")
          this.maybeTakeDecorators(r, _, v);
        else if (r)
          throw this.raise(P.UnsupportedDecoratorExport, e);
        return this.checkExport(v, !0, !0), this.sawUnambiguousESM = !0, this.finishNode(v, "ExportDefaultDeclaration");
      }
      this.unexpected(null, 5);
    }
    eatExportStar(e) {
      return this.eat(55);
    }
    maybeParseExportDefaultSpecifier(e, r) {
      if (r || this.isExportDefaultSpecifier()) {
        this.expectPlugin("exportDefaultFrom", r?.loc.start);
        let i = r || this.parseIdentifier(!0), n = this.startNodeAtNode(i);
        return n.exported = i, e.specifiers = [this.finishNode(n, "ExportDefaultSpecifier")], !0;
      }
      return !1;
    }
    maybeParseExportNamespaceSpecifier(e) {
      if (this.isContextual(93)) {
        var r, i;
        (i = (r = e).specifiers) != null || (r.specifiers = []);
        let n = this.startNodeAt(this.state.lastTokStartLoc);
        return this.next(), n.exported = this.parseModuleExportName(), e.specifiers.push(this.finishNode(n, "ExportNamespaceSpecifier")), !0;
      }
      return !1;
    }
    maybeParseExportNamedSpecifiers(e) {
      if (this.match(5)) {
        let r = e;
        r.specifiers || (r.specifiers = []);
        let i = r.exportKind === "type";
        return r.specifiers.push(...this.parseExportSpecifiers(i)), r.source = null, this.hasPlugin("importAssertions") ? r.assertions = [] :
        r.attributes = [], r.declaration = null, !0;
      }
      return !1;
    }
    maybeParseExportDeclaration(e) {
      return this.shouldParseExportDeclaration() ? (e.specifiers = [], e.source = null, this.hasPlugin("importAssertions") ? e.assertions = [] :
      e.attributes = [], e.declaration = this.parseExportDeclaration(e), !0) : !1;
    }
    isAsyncFunction() {
      if (!this.isContextual(95)) return !1;
      let e = this.nextTokenInLineStart();
      return this.isUnparsedContextual(e, "function");
    }
    parseExportDefaultExpression() {
      let e = this.startNode();
      if (this.match(68))
        return this.next(), this.parseFunction(e, 5);
      if (this.isAsyncFunction())
        return this.next(), this.next(), this.parseFunction(e, 13);
      if (this.match(80))
        return this.parseClass(e, !0, !0);
      if (this.match(26))
        return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") === !0 && this.raise(P.DecoratorBeforeExport,
        this.state.startLoc), this.parseClass(this.maybeTakeDecorators(this.parseDecorators(!1), this.startNode()), !0, !0);
      if (this.match(75) || this.match(74) || this.isLet())
        throw this.raise(P.UnsupportedDefaultExport, this.state.startLoc);
      let r = this.parseMaybeAssignAllowIn();
      return this.semicolon(), r;
    }
    parseExportDeclaration(e) {
      return this.match(80) ? this.parseClass(this.startNode(), !0, !1) : this.parseStatementListItem();
    }
    isExportDefaultSpecifier() {
      let {
        type: e
      } = this.state;
      if (ve(e)) {
        if (e === 95 && !this.state.containsEsc || e === 100)
          return !1;
        if ((e === 130 || e === 129) && !this.state.containsEsc) {
          let {
            type: n
          } = this.lookahead();
          if (ve(n) && n !== 98 || n === 5)
            return this.expectOnePlugin(["flow", "typescript"]), !1;
        }
      } else if (!this.match(65))
        return !1;
      let r = this.nextTokenStart(), i = this.isUnparsedContextual(r, "from");
      if (this.input.charCodeAt(r) === 44 || ve(this.state.type) && i)
        return !0;
      if (this.match(65) && i) {
        let n = this.input.charCodeAt(this.nextTokenStartSince(r + 4));
        return n === 34 || n === 39;
      }
      return !1;
    }
    parseExportFrom(e, r) {
      this.eatContextual(98) ? (e.source = this.parseImportSource(), this.checkExport(e), this.maybeParseImportAttributes(e), this.checkJSONModuleImport(
      e)) : r && this.unexpected(), this.semicolon();
    }
    shouldParseExportDeclaration() {
      let {
        type: e
      } = this.state;
      return e === 26 && (this.expectOnePlugin(["decorators", "decorators-legacy"]), this.hasPlugin("decorators")) ? (this.getPluginOption("\
decorators", "decoratorsBeforeExport") === !0 && this.raise(P.DecoratorBeforeExport, this.state.startLoc), !0) : this.isContextual(107) ? (this.
      raise(P.UsingDeclarationExport, this.state.startLoc), !0) : this.isContextual(96) && this.startsAwaitUsing() ? (this.raise(P.UsingDeclarationExport,
      this.state.startLoc), !0) : e === 74 || e === 75 || e === 68 || e === 80 || this.isLet() || this.isAsyncFunction();
    }
    checkExport(e, r, i, n) {
      if (r) {
        var a;
        if (i) {
          if (this.checkDuplicateExports(e, "default"), this.hasPlugin("exportDefaultFrom")) {
            var o;
            let l = e.declaration;
            l.type === "Identifier" && l.name === "from" && l.end - l.start === 4 && !((o = l.extra) != null && o.parenthesized) && this.raise(
            P.ExportDefaultFromAsIdentifier, l);
          }
        } else if ((a = e.specifiers) != null && a.length)
          for (let l of e.specifiers) {
            let {
              exported: u
            } = l, p = u.type === "Identifier" ? u.name : u.value;
            if (this.checkDuplicateExports(l, p), !n && l.local) {
              let {
                local: m
              } = l;
              m.type !== "Identifier" ? this.raise(P.ExportBindingIsString, l, {
                localName: m.value,
                exportName: p
              }) : (this.checkReservedWord(m.name, m.loc.start, !0, !1), this.scope.checkLocalExport(m));
            }
          }
        else if (e.declaration) {
          let l = e.declaration;
          if (l.type === "FunctionDeclaration" || l.type === "ClassDeclaration") {
            let {
              id: u
            } = l;
            if (!u) throw new Error("Assertion failure");
            this.checkDuplicateExports(e, u.name);
          } else if (l.type === "VariableDeclaration")
            for (let u of l.declarations)
              this.checkDeclaration(u.id);
        }
      }
    }
    checkDeclaration(e) {
      if (e.type === "Identifier")
        this.checkDuplicateExports(e, e.name);
      else if (e.type === "ObjectPattern")
        for (let r of e.properties)
          this.checkDeclaration(r);
      else if (e.type === "ArrayPattern")
        for (let r of e.elements)
          r && this.checkDeclaration(r);
      else e.type === "ObjectProperty" ? this.checkDeclaration(e.value) : e.type === "RestElement" ? this.checkDeclaration(e.argument) : e.type ===
      "AssignmentPattern" && this.checkDeclaration(e.left);
    }
    checkDuplicateExports(e, r) {
      this.exportedIdentifiers.has(r) && (r === "default" ? this.raise(P.DuplicateDefaultExport, e) : this.raise(P.DuplicateExport, e, {
        exportName: r
      })), this.exportedIdentifiers.add(r);
    }
    parseExportSpecifiers(e) {
      let r = [], i = !0;
      for (this.expect(5); !this.eat(8); ) {
        if (i)
          i = !1;
        else if (this.expect(12), this.eat(8)) break;
        let n = this.isContextual(130), a = this.match(134), o = this.startNode();
        o.local = this.parseModuleExportName(), r.push(this.parseExportSpecifier(o, a, e, n));
      }
      return r;
    }
    parseExportSpecifier(e, r, i, n) {
      return this.eatContextual(93) ? e.exported = this.parseModuleExportName() : r ? e.exported = Z3(e.local) : e.exported || (e.exported =
      Dt(e.local)), this.finishNode(e, "ExportSpecifier");
    }
    parseModuleExportName() {
      if (this.match(134)) {
        let e = this.parseStringLiteral(this.state.value), r = xB.exec(e.value);
        return r && this.raise(P.ModuleExportNameHasLoneSurrogate, e, {
          surrogateCharCode: r[0].charCodeAt(0)
        }), e;
      }
      return this.parseIdentifier(!0);
    }
    isJSONModuleImport(e) {
      return e.assertions != null ? e.assertions.some(({
        key: r,
        value: i
      }) => i.value === "json" && (r.type === "Identifier" ? r.name === "type" : r.value === "type")) : !1;
    }
    checkImportReflection(e) {
      let {
        specifiers: r
      } = e, i = r.length === 1 ? r[0].type : null;
      if (e.phase === "source")
        i !== "ImportDefaultSpecifier" && this.raise(P.SourcePhaseImportRequiresDefault, r[0].loc.start);
      else if (e.phase === "defer")
        i !== "ImportNamespaceSpecifier" && this.raise(P.DeferImportRequiresNamespace, r[0].loc.start);
      else if (e.module) {
        var n;
        i !== "ImportDefaultSpecifier" && this.raise(P.ImportReflectionNotBinding, r[0].loc.start), ((n = e.assertions) == null ? void 0 : n.
        length) > 0 && this.raise(P.ImportReflectionHasAssertion, r[0].loc.start);
      }
    }
    checkJSONModuleImport(e) {
      if (this.isJSONModuleImport(e) && e.type !== "ExportAllDeclaration") {
        let {
          specifiers: r
        } = e;
        if (r != null) {
          let i = r.find((n) => {
            let a;
            if (n.type === "ExportSpecifier" ? a = n.local : n.type === "ImportSpecifier" && (a = n.imported), a !== void 0)
              return a.type === "Identifier" ? a.name !== "default" : a.value !== "default";
          });
          i !== void 0 && this.raise(P.ImportJSONBindingNotDefault, i.loc.start);
        }
      }
    }
    isPotentialImportPhase(e) {
      return e ? !1 : this.isContextual(105) || this.isContextual(97) || this.isContextual(127);
    }
    applyImportPhase(e, r, i, n) {
      r || (i === "module" ? (this.expectPlugin("importReflection", n), e.module = !0) : this.hasPlugin("importReflection") && (e.module = !1),
      i === "source" ? (this.expectPlugin("sourcePhaseImports", n), e.phase = "source") : i === "defer" ? (this.expectPlugin("deferredImport\
Evaluation", n), e.phase = "defer") : this.hasPlugin("sourcePhaseImports") && (e.phase = null));
    }
    parseMaybeImportPhase(e, r) {
      if (!this.isPotentialImportPhase(r))
        return this.applyImportPhase(e, r, null), null;
      let i = this.parseIdentifier(!0), {
        type: n
      } = this.state;
      return (mt(n) ? n !== 98 || this.lookaheadCharCode() === 102 : n !== 12) ? (this.resetPreviousIdentifierLeadingComments(i), this.applyImportPhase(
      e, r, i.name, i.loc.start), null) : (this.applyImportPhase(e, r, null), i);
    }
    isPrecedingIdImportPhase(e) {
      let {
        type: r
      } = this.state;
      return ve(r) ? r !== 98 || this.lookaheadCharCode() === 102 : r !== 12;
    }
    parseImport(e) {
      return this.match(134) ? this.parseImportSourceAndAttributes(e) : this.parseImportSpecifiersAndAfter(e, this.parseMaybeImportPhase(e, !1));
    }
    parseImportSpecifiersAndAfter(e, r) {
      e.specifiers = [];
      let n = !this.maybeParseDefaultImportSpecifier(e, r) || this.eat(12), a = n && this.maybeParseStarImportSpecifier(e);
      return n && !a && this.parseNamedImportSpecifiers(e), this.expectContextual(98), this.parseImportSourceAndAttributes(e);
    }
    parseImportSourceAndAttributes(e) {
      var r;
      return (r = e.specifiers) != null || (e.specifiers = []), e.source = this.parseImportSource(), this.maybeParseImportAttributes(e), this.
      checkImportReflection(e), this.checkJSONModuleImport(e), this.semicolon(), this.sawUnambiguousESM = !0, this.finishNode(e, "ImportDecl\
aration");
    }
    parseImportSource() {
      return this.match(134) || this.unexpected(), this.parseExprAtom();
    }
    parseImportSpecifierLocal(e, r, i) {
      r.local = this.parseIdentifier(), e.specifiers.push(this.finishImportSpecifier(r, i));
    }
    finishImportSpecifier(e, r, i = 8201) {
      return this.checkLVal(e.local, {
        type: r
      }, i), this.finishNode(e, r);
    }
    parseImportAttributes() {
      this.expect(5);
      let e = [], r = /* @__PURE__ */ new Set();
      do {
        if (this.match(8))
          break;
        let i = this.startNode(), n = this.state.value;
        if (r.has(n) && this.raise(P.ModuleAttributesWithDuplicateKeys, this.state.startLoc, {
          key: n
        }), r.add(n), this.match(134) ? i.key = this.parseStringLiteral(n) : i.key = this.parseIdentifier(!0), this.expect(14), !this.match(
        134))
          throw this.raise(P.ModuleAttributeInvalidValue, this.state.startLoc);
        i.value = this.parseStringLiteral(this.state.value), e.push(this.finishNode(i, "ImportAttribute"));
      } while (this.eat(12));
      return this.expect(8), e;
    }
    parseModuleAttributes() {
      let e = [], r = /* @__PURE__ */ new Set();
      do {
        let i = this.startNode();
        if (i.key = this.parseIdentifier(!0), i.key.name !== "type" && this.raise(P.ModuleAttributeDifferentFromType, i.key), r.has(i.key.name) &&
        this.raise(P.ModuleAttributesWithDuplicateKeys, i.key, {
          key: i.key.name
        }), r.add(i.key.name), this.expect(14), !this.match(134))
          throw this.raise(P.ModuleAttributeInvalidValue, this.state.startLoc);
        i.value = this.parseStringLiteral(this.state.value), e.push(this.finishNode(i, "ImportAttribute"));
      } while (this.eat(12));
      return e;
    }
    maybeParseImportAttributes(e) {
      let r;
      var i = !1;
      if (this.match(76)) {
        if (this.hasPrecedingLineBreak() && this.lookaheadCharCode() === 40)
          return;
        this.next(), this.hasPlugin("moduleAttributes") ? (r = this.parseModuleAttributes(), this.addExtra(e, "deprecatedWithLegacySyntax", !0)) :
        r = this.parseImportAttributes(), i = !0;
      } else this.isContextual(94) && !this.hasPrecedingLineBreak() ? (!this.hasPlugin("deprecatedImportAssert") && !this.hasPlugin("importA\
ssertions") && this.raise(P.ImportAttributesUseAssert, this.state.startLoc), this.hasPlugin("importAssertions") || this.addExtra(e, "depreca\
tedAssertSyntax", !0), this.next(), r = this.parseImportAttributes()) : r = [];
      !i && this.hasPlugin("importAssertions") ? e.assertions = r : e.attributes = r;
    }
    maybeParseDefaultImportSpecifier(e, r) {
      if (r) {
        let i = this.startNodeAtNode(r);
        return i.local = r, e.specifiers.push(this.finishImportSpecifier(i, "ImportDefaultSpecifier")), !0;
      } else if (mt(this.state.type))
        return this.parseImportSpecifierLocal(e, this.startNode(), "ImportDefaultSpecifier"), !0;
      return !1;
    }
    maybeParseStarImportSpecifier(e) {
      if (this.match(55)) {
        let r = this.startNode();
        return this.next(), this.expectContextual(93), this.parseImportSpecifierLocal(e, r, "ImportNamespaceSpecifier"), !0;
      }
      return !1;
    }
    parseNamedImportSpecifiers(e) {
      let r = !0;
      for (this.expect(5); !this.eat(8); ) {
        if (r)
          r = !1;
        else {
          if (this.eat(14))
            throw this.raise(P.DestructureNamedImport, this.state.startLoc);
          if (this.expect(12), this.eat(8)) break;
        }
        let i = this.startNode(), n = this.match(134), a = this.isContextual(130);
        i.imported = this.parseModuleExportName();
        let o = this.parseImportSpecifier(i, n, e.importKind === "type" || e.importKind === "typeof", a, void 0);
        e.specifiers.push(o);
      }
    }
    parseImportSpecifier(e, r, i, n, a) {
      if (this.eatContextual(93))
        e.local = this.parseIdentifier();
      else {
        let {
          imported: o
        } = e;
        if (r)
          throw this.raise(P.ImportBindingIsString, e, {
            importName: o.value
          });
        this.checkReservedWord(o.name, e.loc.start, !0, !0), e.local || (e.local = Dt(o));
      }
      return this.finishImportSpecifier(e, "ImportSpecifier", a);
    }
    isThisParam(e) {
      return e.type === "Identifier" && e.name === "this";
    }
  }, Zi = class extends mo {
    static {
      s(this, "Parser");
    }
    constructor(e, r, i) {
      e = T3(e), super(e, r), this.options = e, this.initializeScopes(), this.plugins = i, this.filename = e.sourceFilename, this.startIndex =
      e.startIndex;
      let n = 0;
      e.allowAwaitOutsideFunction && (n |= 1), e.allowReturnOutsideFunction && (n |= 2), e.allowImportExportEverywhere && (n |= 8), e.allowSuperOutsideMethod &&
      (n |= 16), e.allowUndeclaredExports && (n |= 64), e.allowNewTargetOutsideFunction && (n |= 4), e.allowYieldOutsideFunction && (n |= 32),
      e.ranges && (n |= 128), e.tokens && (n |= 256), e.createImportExpressions && (n |= 512), e.createParenthesizedExpressions && (n |= 1024),
      e.errorRecovery && (n |= 2048), e.attachComment && (n |= 4096), e.annexB && (n |= 8192), this.optionFlags = n;
    }
    getScopeHandler() {
      return $r;
    }
    parse() {
      this.enterInitialScopes();
      let e = this.startNode(), r = this.startNode();
      return this.nextToken(), e.errors = null, this.parseTopLevel(e, r), e.errors = this.state.errors, e.comments.length = this.state.commentsLen,
      e;
    }
  };
  function EB(t, e) {
    var r;
    if (((r = e) == null ? void 0 : r.sourceType) === "unambiguous") {
      e = Object.assign({}, e);
      try {
        e.sourceType = "module";
        let i = Xr(e, t), n = i.parse();
        if (i.sawUnambiguousESM)
          return n;
        if (i.ambiguousScriptDifferentAst)
          try {
            return e.sourceType = "script", Xr(e, t).parse();
          } catch {
          }
        else
          n.program.sourceType = "script";
        return n;
      } catch (i) {
        try {
          return e.sourceType = "script", Xr(e, t).parse();
        } catch {
        }
        throw i;
      }
    } else
      return Xr(e, t).parse();
  }
  s(EB, "parse");
  function gB(t, e) {
    let r = Xr(e, t);
    return r.options.strictMode && (r.state.strict = !0), r.getExpression();
  }
  s(gB, "parseExpression");
  function AB(t) {
    let e = {};
    for (let r of Object.keys(t))
      e[r] = wt(t[r]);
    return e;
  }
  s(AB, "generateExportedTokenTypes");
  var IB = AB(P3);
  function Xr(t, e) {
    let r = Zi, i = /* @__PURE__ */ new Map();
    if (t != null && t.plugins) {
      for (let n of t.plugins) {
        let a, o;
        typeof n == "string" ? a = n : [a, o] = n, i.has(a) || i.set(a, o || {});
      }
      TB(i), r = vB(i);
    }
    return new r(t, e, i);
  }
  s(Xr, "getParser");
  var sp = /* @__PURE__ */ new Map();
  function vB(t) {
    let e = [];
    for (let n of SB)
      t.has(n) && e.push(n);
    let r = e.join("|"), i = sp.get(r);
    if (!i) {
      i = Zi;
      for (let n of e)
        i = bp[n](i);
      sp.set(r, i);
    }
    return i;
  }
  s(vB, "getParserClass");
  Gr.parse = EB;
  Gr.parseExpression = gB;
  Gr.tokTypes = IB;
});

// src/core-server/presets/webpack/loaders/storybook-mock-transform-loader.ts
import { logger as wB } from "storybook/internal/node-logger";

// src/core-server/mocking-utils/extract.ts
var gp = as(Vc(), 1), Ap = as(xp(), 1), Ip = as(Ye(), 1);
import { logger as A6 } from "storybook/internal/node-logger";
import { telemetry as v6 } from "storybook/internal/telemetry";
import { transformSync as w6 } from "esbuild";

// ../node_modules/estree-walker/src/walker.js
var Qr = class {
  static {
    s(this, "WalkerBase");
  }
  constructor() {
    this.should_skip = !1, this.should_remove = !1, this.replacement = null, this.context = {
      skip: /* @__PURE__ */ s(() => this.should_skip = !0, "skip"),
      remove: /* @__PURE__ */ s(() => this.should_remove = !0, "remove"),
      replace: /* @__PURE__ */ s((e) => this.replacement = e, "replace")
    };
  }
  /**
   * @template {Node} Parent
   * @param {Parent | null | undefined} parent
   * @param {keyof Parent | null | undefined} prop
   * @param {number | null | undefined} index
   * @param {Node} node
   */
  replace(e, r, i, n) {
    e && r && (i != null ? e[r][i] = n : e[r] = n);
  }
  /**
   * @template {Node} Parent
   * @param {Parent | null | undefined} parent
   * @param {keyof Parent | null | undefined} prop
   * @param {number | null | undefined} index
   */
  remove(e, r, i) {
    e && r && (i != null ? e[r].splice(i, 1) : delete e[r]);
  }
};

// ../node_modules/estree-walker/src/sync.js
var es = class extends Qr {
  static {
    s(this, "SyncWalker");
  }
  /**
   *
   * @param {SyncHandler} [enter]
   * @param {SyncHandler} [leave]
   */
  constructor(e, r) {
    super(), this.should_skip = !1, this.should_remove = !1, this.replacement = null, this.context = {
      skip: /* @__PURE__ */ s(() => this.should_skip = !0, "skip"),
      remove: /* @__PURE__ */ s(() => this.should_remove = !0, "remove"),
      replace: /* @__PURE__ */ s((i) => this.replacement = i, "replace")
    }, this.enter = e, this.leave = r;
  }
  /**
   * @template {Node} Parent
   * @param {Node} node
   * @param {Parent | null} parent
   * @param {keyof Parent} [prop]
   * @param {number | null} [index]
   * @returns {Node | null}
   */
  visit(e, r, i, n) {
    if (e) {
      if (this.enter) {
        let o = this.should_skip, l = this.should_remove, u = this.replacement;
        this.should_skip = !1, this.should_remove = !1, this.replacement = null, this.enter.call(this.context, e, r, i, n), this.replacement &&
        (e = this.replacement, this.replace(r, i, n, e)), this.should_remove && this.remove(r, i, n);
        let p = this.should_skip, m = this.should_remove;
        if (this.should_skip = o, this.should_remove = l, this.replacement = u, p) return e;
        if (m) return null;
      }
      let a;
      for (a in e) {
        let o = e[a];
        if (o && typeof o == "object")
          if (Array.isArray(o)) {
            let l = (
              /** @type {Array<unknown>} */
              o
            );
            for (let u = 0; u < l.length; u += 1) {
              let p = l[u];
              Pp(p) && (this.visit(p, e, a, u) || u--);
            }
          } else Pp(o) && this.visit(o, e, a, null);
      }
      if (this.leave) {
        let o = this.replacement, l = this.should_remove;
        this.replacement = null, this.should_remove = !1, this.leave.call(this.context, e, r, i, n), this.replacement && (e = this.replacement,
        this.replace(r, i, n, e)), this.should_remove && this.remove(r, i, n);
        let u = this.should_remove;
        if (this.replacement = o, this.should_remove = l, u) return null;
      }
    }
    return e;
  }
};
function Pp(t) {
  return t !== null && typeof t == "object" && "type" in t && typeof t.type == "string";
}
s(Pp, "isNode");

// ../node_modules/estree-walker/src/index.js
function Ep(t, { enter: e, leave: r }) {
  return new es(e, r).visit(t, null);
}
s(Ep, "walk");

// src/core-server/mocking-utils/extract.ts
import { readFileSync as _6 } from "fs";
var CB = /* @__PURE__ */ s((t) => (0, Ap.parse)(t, {
  sourceType: "module",
  // Enable plugins to handle modern JavaScript features, including TSX.
  plugins: ["typescript", "jsx", "classProperties", "objectRestSpread"],
  errorRecovery: !0
}).program, "babelParser");
function vp(t) {
  let e = CB(t);
  return Ep(e, {
    enter(r) {
      r.type === "CallExpression" && r.callee.type === "MemberExpression" && r.callee.object.type === "Identifier" && r.callee.object.name ===
      "sb" && r.callee.property.type === "Identifier" && r.callee.property.name === "mock" && r.arguments.length > 0 && r.arguments[0].type ===
      "CallExpression" && r.arguments[0].callee.type === "Import" && r.arguments[0].arguments.length === 1 && r.arguments[0].arguments[0].type ===
      "StringLiteral" && (r.arguments[0] = Ip.stringLiteral(r.arguments[0].arguments[0].value));
    }
  }), (0, gp.generate)(e, {}, t);
}
s(vp, "rewriteSbMockImportCalls");

// src/core-server/presets/webpack/loaders/storybook-mock-transform-loader.ts
var NB = /* @__PURE__ */ s(function(e, r, i) {
  let n = this.async();
  try {
    let a = vp(e);
    n(null, a.code, a.map || void 0, i);
  } catch (a) {
    let o = this.resourcePath;
    wB.debug(`Could not transform sb.mock(import(...)) calls in ${o}: ${a}`), n(null, e, r, i);
  }
}, "mockTransformLoaderFn"), B6 = NB;
export {
  B6 as default
};
