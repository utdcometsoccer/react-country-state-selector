import ESM_COMPAT_Module from "node:module";
import { fileURLToPath as ESM_COMPAT_fileURLToPath } from 'node:url';
import { dirname as ESM_COMPAT_dirname } from 'node:path';
const __filename = ESM_COMPAT_fileURLToPath(import.meta.url);
const __dirname = ESM_COMPAT_dirname(__filename);
const require = ESM_COMPAT_Module.createRequire(import.meta.url);
var Mp = Object.create;
var ps = Object.defineProperty;
var Bp = Object.getOwnPropertyDescriptor;
var jp = Object.getOwnPropertyNames;
var Fp = Object.getPrototypeOf, Rp = Object.prototype.hasOwnProperty;
var s = (t, e) => ps(t, "name", { value: e, configurable: !0 });
var D = (t, e) => () => (e || t((e = { exports: {} }).exports, e), e.exports);
var qp = (t, e, r, i) => {
  if (e && typeof e == "object" || typeof e == "function")
    for (let n of jp(e))
      !Rp.call(t, n) && n !== r && ps(t, n, { get: () => e[n], enumerable: !(i = Bp(e, n)) || i.enumerable });
  return t;
};
var si = (t, e, r) => (r = t != null ? Mp(Fp(t)) : {}, qp(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  e || !t || !t.__esModule ? ps(r, "default", { value: t, enumerable: !0 }) : r,
  t
));

// ../node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.umd.js
var ai = D((ni, Fo) => {
  (function(t, e) {
    typeof ni == "object" && typeof Fo < "u" ? e(ni) : typeof define == "function" && define.amd ? define(["exports"], e) : (t = typeof globalThis <
    "u" ? globalThis : t || self, e(t.sourcemapCodec = {}));
  })(ni, function(t) {
    "use strict";
    let i = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", n = new Uint8Array(64), a = new Uint8Array(128);
    for (let H = 0; H < i.length; H++) {
      let J = i.charCodeAt(H);
      n[H] = J, a[J] = H;
    }
    function o(H, J) {
      let w = 0, $ = 0, ce = 0;
      do {
        let V = H.next();
        ce = a[V], w |= (ce & 31) << $, $ += 5;
      } while (ce & 32);
      let be = w & 1;
      return w >>>= 1, be && (w = -2147483648 | -w), J + w;
    }
    s(o, "decodeInteger");
    function l(H, J, w) {
      let $ = J - w;
      $ = $ < 0 ? -$ << 1 | 1 : $ << 1;
      do {
        let ce = $ & 31;
        $ >>>= 5, $ > 0 && (ce |= 32), H.write(n[ce]);
      } while ($ > 0);
      return J;
    }
    s(l, "encodeInteger");
    function u(H, J) {
      return H.pos >= J ? !1 : H.peek() !== 44;
    }
    s(u, "hasMoreVlq");
    let p = 1024 * 16, h = typeof TextDecoder < "u" ? /* @__PURE__ */ new TextDecoder() : typeof Buffer < "u" ? {
      decode(H) {
        return Buffer.from(H.buffer, H.byteOffset, H.byteLength).toString();
      }
    } : {
      decode(H) {
        let J = "";
        for (let w = 0; w < H.length; w++)
          J += String.fromCharCode(H[w]);
        return J;
      }
    };
    class E {
      static {
        s(this, "StringWriter");
      }
      constructor() {
        this.pos = 0, this.out = "", this.buffer = new Uint8Array(p);
      }
      write(J) {
        let { buffer: w } = this;
        w[this.pos++] = J, this.pos === p && (this.out += h.decode(w), this.pos = 0);
      }
      flush() {
        let { buffer: J, out: w, pos: $ } = this;
        return $ > 0 ? w + h.decode(J.subarray(0, $)) : w;
      }
    }
    class I {
      static {
        s(this, "StringReader");
      }
      constructor(J) {
        this.pos = 0, this.buffer = J;
      }
      next() {
        return this.buffer.charCodeAt(this.pos++);
      }
      peek() {
        return this.buffer.charCodeAt(this.pos);
      }
      indexOf(J) {
        let { buffer: w, pos: $ } = this, ce = w.indexOf(J, $);
        return ce === -1 ? w.length : ce;
      }
    }
    let v = [];
    function _(H) {
      let { length: J } = H, w = new I(H), $ = [], ce = [], be = 0;
      for (; w.pos < J; w.pos++) {
        be = o(w, be);
        let V = o(w, 0);
        if (!u(w, J)) {
          let fe = ce.pop();
          fe[2] = be, fe[3] = V;
          continue;
        }
        let U = o(w, 0), ne = o(w, 0) & 1 ? [be, V, 0, 0, U, o(w, 0)] : [be, V, 0, 0, U], le = v;
        if (u(w, J)) {
          le = [];
          do {
            let fe = o(w, 0);
            le.push(fe);
          } while (u(w, J));
        }
        ne.vars = le, $.push(ne), ce.push(ne);
      }
      return $;
    }
    s(_, "decodeOriginalScopes");
    function j(H) {
      let J = new E();
      for (let w = 0; w < H.length; )
        w = O(H, w, J, [0]);
      return J.flush();
    }
    s(j, "encodeOriginalScopes");
    function O(H, J, w, $) {
      let ce = H[J], { 0: be, 1: V, 2: U, 3: z, 4: Q, vars: ne } = ce;
      J > 0 && w.write(44), $[0] = l(w, be, $[0]), l(w, V, 0), l(w, Q, 0);
      let le = ce.length === 6 ? 1 : 0;
      l(w, le, 0), ce.length === 6 && l(w, ce[5], 0);
      for (let fe of ne)
        l(w, fe, 0);
      for (J++; J < H.length; ) {
        let fe = H[J], { 0: he, 1: Te } = fe;
        if (he > U || he === U && Te >= z)
          break;
        J = O(H, J, w, $);
      }
      return w.write(44), $[0] = l(w, U, $[0]), l(w, z, 0), J;
    }
    s(O, "_encodeOriginalScopes");
    function k(H) {
      let { length: J } = H, w = new I(H), $ = [], ce = [], be = 0, V = 0, U = 0, z = 0, Q = 0, ne = 0, le = 0, fe = 0;
      do {
        let he = w.indexOf(";"), Te = 0;
        for (; w.pos < he; w.pos++) {
          if (Te = o(w, Te), !u(w, he)) {
            let qe = ce.pop();
            qe[2] = be, qe[3] = Te;
            continue;
          }
          let Ke = o(w, 0), ft = Ke & 1, st = Ke & 2, nt = Ke & 4, yt = null, ht = v, Xe;
          if (ft) {
            let qe = o(w, V);
            U = o(w, V === qe ? U : 0), V = qe, Xe = [be, Te, 0, 0, qe, U];
          } else
            Xe = [be, Te, 0, 0];
          if (Xe.isScope = !!nt, st) {
            let qe = z, Pt = Q;
            z = o(w, z);
            let Vt = qe === z;
            Q = o(w, Vt ? Q : 0), ne = o(w, Vt && Pt === Q ? ne : 0), yt = [z, Q, ne];
          }
          if (Xe.callsite = yt, u(w, he)) {
            ht = [];
            do {
              le = be, fe = Te;
              let qe = o(w, 0), Pt;
              if (qe < -1) {
                Pt = [[o(w, 0)]];
                for (let Vt = -1; Vt > qe; Vt--) {
                  let os = le;
                  le = o(w, le), fe = o(w, le === os ? fe : 0);
                  let gr = o(w, 0);
                  Pt.push([gr, le, fe]);
                }
              } else
                Pt = [[qe]];
              ht.push(Pt);
            } while (u(w, he));
          }
          Xe.bindings = ht, $.push(Xe), ce.push(Xe);
        }
        be++, w.pos = he + 1;
      } while (w.pos < J);
      return $;
    }
    s(k, "decodeGeneratedRanges");
    function B(H) {
      if (H.length === 0)
        return "";
      let J = new E();
      for (let w = 0; w < H.length; )
        w = ue(H, w, J, [0, 0, 0, 0, 0, 0, 0]);
      return J.flush();
    }
    s(B, "encodeGeneratedRanges");
    function ue(H, J, w, $) {
      let ce = H[J], { 0: be, 1: V, 2: U, 3: z, isScope: Q, callsite: ne, bindings: le } = ce;
      $[0] < be ? (K(w, $[0], be), $[0] = be, $[1] = 0) : J > 0 && w.write(44), $[1] = l(w, ce[1], $[1]);
      let fe = (ce.length === 6 ? 1 : 0) | (ne ? 2 : 0) | (Q ? 4 : 0);
      if (l(w, fe, 0), ce.length === 6) {
        let { 4: he, 5: Te } = ce;
        he !== $[2] && ($[3] = 0), $[2] = l(w, he, $[2]), $[3] = l(w, Te, $[3]);
      }
      if (ne) {
        let { 0: he, 1: Te, 2: Ke } = ce.callsite;
        he !== $[4] ? ($[5] = 0, $[6] = 0) : Te !== $[5] && ($[6] = 0), $[4] = l(w, he, $[4]), $[5] = l(w, Te, $[5]), $[6] = l(w, Ke, $[6]);
      }
      if (le)
        for (let he of le) {
          he.length > 1 && l(w, -he.length, 0);
          let Te = he[0][0];
          l(w, Te, 0);
          let Ke = be, ft = V;
          for (let st = 1; st < he.length; st++) {
            let nt = he[st];
            Ke = l(w, nt[1], Ke), ft = l(w, nt[2], ft), l(w, nt[0], 0);
          }
        }
      for (J++; J < H.length; ) {
        let he = H[J], { 0: Te, 1: Ke } = he;
        if (Te > U || Te === U && Ke >= z)
          break;
        J = ue(H, J, w, $);
      }
      return $[0] < U ? (K(w, $[0], U), $[0] = U, $[1] = 0) : w.write(44), $[1] = l(w, z, $[1]), J;
    }
    s(ue, "_encodeGeneratedRanges");
    function K(H, J, w) {
      do
        H.write(59);
      while (++J < w);
    }
    s(K, "catchupLine");
    function oe(H) {
      let { length: J } = H, w = new I(H), $ = [], ce = 0, be = 0, V = 0, U = 0, z = 0;
      do {
        let Q = w.indexOf(";"), ne = [], le = !0, fe = 0;
        for (ce = 0; w.pos < Q; ) {
          let he;
          ce = o(w, ce), ce < fe && (le = !1), fe = ce, u(w, Q) ? (be = o(w, be), V = o(w, V), U = o(w, U), u(w, Q) ? (z = o(w, z), he = [ce,
          be, V, U, z]) : he = [ce, be, V, U]) : he = [ce], ne.push(he), w.pos++;
        }
        le || we(ne), $.push(ne), w.pos = Q + 1;
      } while (w.pos <= J);
      return $;
    }
    s(oe, "decode");
    function we(H) {
      H.sort(je);
    }
    s(we, "sort");
    function je(H, J) {
      return H[0] - J[0];
    }
    s(je, "sortComparator");
    function Je(H) {
      let J = new E(), w = 0, $ = 0, ce = 0, be = 0;
      for (let V = 0; V < H.length; V++) {
        let U = H[V];
        if (V > 0 && J.write(59), U.length === 0)
          continue;
        let z = 0;
        for (let Q = 0; Q < U.length; Q++) {
          let ne = U[Q];
          Q > 0 && J.write(44), z = l(J, ne[0], z), ne.length !== 1 && (w = l(J, ne[1], w), $ = l(J, ne[2], $), ce = l(J, ne[3], ce), ne.length !==
          4 && (be = l(J, ne[4], be)));
        }
      }
      return J.flush();
    }
    s(Je, "encode"), t.decode = oe, t.decodeGeneratedRanges = k, t.decodeOriginalScopes = _, t.encode = Je, t.encodeGeneratedRanges = B, t.encodeOriginalScopes =
    j, Object.defineProperty(t, "__esModule", { value: !0 });
  });
});

// ../node_modules/@jridgewell/set-array/dist/set-array.umd.js
var Yo = D((ci, Vo) => {
  (function(t, e) {
    typeof ci == "object" && typeof Vo < "u" ? e(ci) : typeof define == "function" && define.amd ? define(["exports"], e) : (t = typeof globalThis <
    "u" ? globalThis : t || self, e(t.setArray = {}));
  })(ci, function(t) {
    "use strict";
    class e {
      static {
        s(this, "SetArray");
      }
      constructor() {
        this._indexes = { __proto__: null }, this.array = [];
      }
    }
    function r(l) {
      return l;
    }
    s(r, "cast");
    function i(l, u) {
      return l._indexes[u];
    }
    s(i, "get");
    function n(l, u) {
      let p = i(l, u);
      if (p !== void 0)
        return p;
      let { array: h, _indexes: E } = l, I = h.push(u);
      return E[u] = I - 1;
    }
    s(n, "put");
    function a(l) {
      let { array: u, _indexes: p } = l;
      if (u.length === 0)
        return;
      let h = u.pop();
      p[h] = void 0;
    }
    s(a, "pop");
    function o(l, u) {
      let p = i(l, u);
      if (p === void 0)
        return;
      let { array: h, _indexes: E } = l;
      for (let I = p + 1; I < h.length; I++) {
        let v = h[I];
        h[I - 1] = v, E[v]--;
      }
      E[u] = void 0, h.pop();
    }
    s(o, "remove"), t.SetArray = e, t.get = i, t.pop = a, t.put = n, t.remove = o, Object.defineProperty(t, "__esModule", { value: !0 });
  });
});

// ../node_modules/@jridgewell/resolve-uri/dist/resolve-uri.umd.js
var Jo = D((ds, ms) => {
  (function(t, e) {
    typeof ds == "object" && typeof ms < "u" ? ms.exports = e() : typeof define == "function" && define.amd ? define(e) : (t = typeof globalThis <
    "u" ? globalThis : t || self, t.resolveURI = e());
  })(ds, function() {
    "use strict";
    let t = /^[\w+.-]+:\/\//, e = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/, r = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;
    function i(O) {
      return t.test(O);
    }
    s(i, "isAbsoluteUrl");
    function n(O) {
      return O.startsWith("//");
    }
    s(n, "isSchemeRelativeUrl");
    function a(O) {
      return O.startsWith("/");
    }
    s(a, "isAbsolutePath");
    function o(O) {
      return O.startsWith("file:");
    }
    s(o, "isFileUrl");
    function l(O) {
      return /^[.?#]/.test(O);
    }
    s(l, "isRelative");
    function u(O) {
      let k = e.exec(O);
      return h(k[1], k[2] || "", k[3], k[4] || "", k[5] || "/", k[6] || "", k[7] || "");
    }
    s(u, "parseAbsoluteUrl");
    function p(O) {
      let k = r.exec(O), B = k[2];
      return h("file:", "", k[1] || "", "", a(B) ? B : "/" + B, k[3] || "", k[4] || "");
    }
    s(p, "parseFileUrl");
    function h(O, k, B, ue, K, oe, we) {
      return {
        scheme: O,
        user: k,
        host: B,
        port: ue,
        path: K,
        query: oe,
        hash: we,
        type: 7
      };
    }
    s(h, "makeUrl");
    function E(O) {
      if (n(O)) {
        let B = u("http:" + O);
        return B.scheme = "", B.type = 6, B;
      }
      if (a(O)) {
        let B = u("http://foo.com" + O);
        return B.scheme = "", B.host = "", B.type = 5, B;
      }
      if (o(O))
        return p(O);
      if (i(O))
        return u(O);
      let k = u("http://foo.com/" + O);
      return k.scheme = "", k.host = "", k.type = O ? O.startsWith("?") ? 3 : O.startsWith("#") ? 2 : 4 : 1, k;
    }
    s(E, "parseUrl");
    function I(O) {
      if (O.endsWith("/.."))
        return O;
      let k = O.lastIndexOf("/");
      return O.slice(0, k + 1);
    }
    s(I, "stripPathFilename");
    function v(O, k) {
      _(k, k.type), O.path === "/" ? O.path = k.path : O.path = I(k.path) + O.path;
    }
    s(v, "mergePaths");
    function _(O, k) {
      let B = k <= 4, ue = O.path.split("/"), K = 1, oe = 0, we = !1;
      for (let Je = 1; Je < ue.length; Je++) {
        let H = ue[Je];
        if (!H) {
          we = !0;
          continue;
        }
        if (we = !1, H !== ".") {
          if (H === "..") {
            oe ? (we = !0, oe--, K--) : B && (ue[K++] = H);
            continue;
          }
          ue[K++] = H, oe++;
        }
      }
      let je = "";
      for (let Je = 1; Je < K; Je++)
        je += "/" + ue[Je];
      (!je || we && !je.endsWith("/..")) && (je += "/"), O.path = je;
    }
    s(_, "normalizePath");
    function j(O, k) {
      if (!O && !k)
        return "";
      let B = E(O), ue = B.type;
      if (k && ue !== 7) {
        let oe = E(k), we = oe.type;
        switch (ue) {
          case 1:
            B.hash = oe.hash;
          // fall through
          case 2:
            B.query = oe.query;
          // fall through
          case 3:
          case 4:
            v(B, oe);
          // fall through
          case 5:
            B.user = oe.user, B.host = oe.host, B.port = oe.port;
          // fall through
          case 6:
            B.scheme = oe.scheme;
        }
        we > ue && (ue = we);
      }
      _(B, ue);
      let K = B.query + B.hash;
      switch (ue) {
        // This is impossible, because of the empty checks at the start of the function.
        // case UrlType.Empty:
        case 2:
        case 3:
          return K;
        case 4: {
          let oe = B.path.slice(1);
          return oe ? l(k || O) && !l(oe) ? "./" + oe + K : oe + K : K || ".";
        }
        case 5:
          return B.path + K;
        default:
          return B.scheme + "//" + B.user + B.host + B.port + B.path + K;
      }
    }
    return s(j, "resolve"), j;
  });
});

// ../node_modules/@jridgewell/trace-mapping/dist/trace-mapping.umd.js
var ys = D((pi, Xo) => {
  (function(t, e) {
    typeof pi == "object" && typeof Xo < "u" ? e(pi, ai(), Jo()) : typeof define == "function" && define.amd ? define(["exports", "@jridgewe\
ll/sourcemap-codec", "@jridgewell/resolve-uri"], e) : (t = typeof globalThis < "u" ? globalThis : t || self, e(t.traceMapping = {}, t.sourcemapCodec,
    t.resolveURI));
  })(pi, function(t, e, r) {
    "use strict";
    function i(C, M) {
      return M && !M.endsWith("/") && (M += "/"), r(C, M);
    }
    s(i, "resolve");
    function n(C) {
      if (!C)
        return "";
      let M = C.lastIndexOf("/");
      return C.slice(0, M + 1);
    }
    s(n, "stripFilename");
    let a = 0, o = 1, l = 2, u = 3, p = 4, h = 1, E = 2;
    function I(C, M) {
      let F = v(C, 0);
      if (F === C.length)
        return C;
      M || (C = C.slice());
      for (let X = F; X < C.length; X = v(C, X + 1))
        C[X] = j(C[X], M);
      return C;
    }
    s(I, "maybeSort");
    function v(C, M) {
      for (let F = M; F < C.length; F++)
        if (!_(C[F]))
          return F;
      return C.length;
    }
    s(v, "nextUnsortedSegmentLine");
    function _(C) {
      for (let M = 1; M < C.length; M++)
        if (C[M][a] < C[M - 1][a])
          return !1;
      return !0;
    }
    s(_, "isSorted");
    function j(C, M) {
      return M || (C = C.slice()), C.sort(O);
    }
    s(j, "sortSegments");
    function O(C, M) {
      return C[a] - M[a];
    }
    s(O, "sortComparator");
    let k = !1;
    function B(C, M, F, X) {
      for (; F <= X; ) {
        let pe = F + (X - F >> 1), re = C[pe][a] - M;
        if (re === 0)
          return k = !0, pe;
        re < 0 ? F = pe + 1 : X = pe - 1;
      }
      return k = !1, F - 1;
    }
    s(B, "binarySearch");
    function ue(C, M, F) {
      for (let X = F + 1; X < C.length && C[X][a] === M; F = X++)
        ;
      return F;
    }
    s(ue, "upperBound");
    function K(C, M, F) {
      for (let X = F - 1; X >= 0 && C[X][a] === M; F = X--)
        ;
      return F;
    }
    s(K, "lowerBound");
    function oe() {
      return {
        lastKey: -1,
        lastNeedle: -1,
        lastIndex: -1
      };
    }
    s(oe, "memoizedState");
    function we(C, M, F, X) {
      let { lastKey: pe, lastNeedle: re, lastIndex: Ae } = F, Ne = 0, Se = C.length - 1;
      if (X === pe) {
        if (M === re)
          return k = Ae !== -1 && C[Ae][a] === M, Ae;
        M >= re ? Ne = Ae === -1 ? 0 : Ae : Se = Ae;
      }
      return F.lastKey = X, F.lastNeedle = M, F.lastIndex = B(C, M, Ne, Se);
    }
    s(we, "memoizedBinarySearch");
    function je(C, M) {
      let F = M.map(H);
      for (let X = 0; X < C.length; X++) {
        let pe = C[X];
        for (let re = 0; re < pe.length; re++) {
          let Ae = pe[re];
          if (Ae.length === 1)
            continue;
          let Ne = Ae[o], Se = Ae[l], Oe = Ae[u], et = F[Ne], Fe = et[Se] || (et[Se] = []), Me = M[Ne], We = ue(Fe, Oe, we(Fe, Oe, Me, Se));
          Me.lastIndex = ++We, Je(Fe, We, [Oe, X, Ae[a]]);
        }
      }
      return F;
    }
    s(je, "buildBySources");
    function Je(C, M, F) {
      for (let X = C.length; X > M; X--)
        C[X] = C[X - 1];
      C[M] = F;
    }
    s(Je, "insert");
    function H() {
      return { __proto__: null };
    }
    s(H, "buildNullArray");
    let J = /* @__PURE__ */ s(function(C, M) {
      let F = w(C);
      if (!("sections" in F))
        return new le(F, M);
      let X = [], pe = [], re = [], Ae = [], Ne = [];
      $(F, M, X, pe, re, Ae, Ne, 0, 0, 1 / 0, 1 / 0);
      let Se = {
        version: 3,
        file: F.file,
        names: Ae,
        sources: pe,
        sourcesContent: re,
        mappings: X,
        ignoreList: Ne
      };
      return Pt(Se);
    }, "AnyMap");
    function w(C) {
      return typeof C == "string" ? JSON.parse(C) : C;
    }
    s(w, "parse");
    function $(C, M, F, X, pe, re, Ae, Ne, Se, Oe, et) {
      let { sections: Fe } = C;
      for (let Me = 0; Me < Fe.length; Me++) {
        let { map: We, offset: Tt } = Fe[Me], Yt = Oe, tr = et;
        if (Me + 1 < Fe.length) {
          let rr = Fe[Me + 1].offset;
          Yt = Math.min(Oe, Ne + rr.line), Yt === Oe ? tr = Math.min(et, Se + rr.column) : Yt < Oe && (tr = Se + rr.column);
        }
        ce(We, M, F, X, pe, re, Ae, Ne + Tt.line, Se + Tt.column, Yt, tr);
      }
    }
    s($, "recurse");
    function ce(C, M, F, X, pe, re, Ae, Ne, Se, Oe, et) {
      let Fe = w(C);
      if ("sections" in Fe)
        return $(...arguments);
      let Me = new le(Fe, M), We = X.length, Tt = re.length, Yt = Te(Me), { resolvedSources: tr, sourcesContent: rr, ignoreList: ls } = Me;
      if (be(X, tr), be(re, Me.names), rr)
        be(pe, rr);
      else
        for (let at = 0; at < tr.length; at++)
          pe.push(null);
      if (ls)
        for (let at = 0; at < ls.length; at++)
          Ae.push(ls[at] + We);
      for (let at = 0; at < Yt.length; at++) {
        let us = Ne + at;
        if (us > Oe)
          return;
        let ko = V(F, us), Lp = at === 0 ? Se : 0, Lo = Yt[at];
        for (let cs = 0; cs < Lo.length; cs++) {
          let Jt = Lo[cs], ii = Lp + Jt[a];
          if (us === Oe && ii >= et)
            return;
          if (Jt.length === 1) {
            ko.push([ii]);
            continue;
          }
          let Mo = We + Jt[o], Bo = Jt[l], jo = Jt[u];
          ko.push(Jt.length === 4 ? [ii, Mo, Bo, jo] : [ii, Mo, Bo, jo, Tt + Jt[p]]);
        }
      }
    }
    s(ce, "addSection");
    function be(C, M) {
      for (let F = 0; F < M.length; F++)
        C.push(M[F]);
    }
    s(be, "append");
    function V(C, M) {
      for (let F = C.length; F <= M; F++)
        C[F] = [];
      return C[M];
    }
    s(V, "getLine");
    let U = "`line` must be greater than 0 (lines start at line 1)", z = "`column` must be greater than or equal to 0 (columns start at colu\
mn 0)", Q = -1, ne = 1;
    class le {
      static {
        s(this, "TraceMap");
      }
      constructor(M, F) {
        let X = typeof M == "string";
        if (!X && M._decodedMemo)
          return M;
        let pe = X ? JSON.parse(M) : M, { version: re, file: Ae, names: Ne, sourceRoot: Se, sources: Oe, sourcesContent: et } = pe;
        this.version = re, this.file = Ae, this.names = Ne || [], this.sourceRoot = Se, this.sources = Oe, this.sourcesContent = et, this.ignoreList =
        pe.ignoreList || pe.x_google_ignoreList || void 0;
        let Fe = i(Se || "", n(F));
        this.resolvedSources = Oe.map((We) => i(We || "", Fe));
        let { mappings: Me } = pe;
        typeof Me == "string" ? (this._encoded = Me, this._decoded = void 0) : (this._encoded = void 0, this._decoded = I(Me, X)), this._decodedMemo =
        oe(), this._bySources = void 0, this._bySourceMemos = void 0;
      }
    }
    function fe(C) {
      return C;
    }
    s(fe, "cast");
    function he(C) {
      var M, F;
      return (M = (F = C)._encoded) !== null && M !== void 0 ? M : F._encoded = e.encode(C._decoded);
    }
    s(he, "encodedMappings");
    function Te(C) {
      var M;
      return (M = C)._decoded || (M._decoded = e.decode(C._encoded));
    }
    s(Te, "decodedMappings");
    function Ke(C, M, F) {
      let X = Te(C);
      if (M >= X.length)
        return null;
      let pe = X[M], re = ri(pe, C._decodedMemo, M, F, ne);
      return re === -1 ? null : pe[re];
    }
    s(Ke, "traceSegment");
    function ft(C, M) {
      let { line: F, column: X, bias: pe } = M;
      if (F--, F < 0)
        throw new Error(U);
      if (X < 0)
        throw new Error(z);
      let re = Te(C);
      if (F >= re.length)
        return ti(null, null, null, null);
      let Ae = re[F], Ne = ri(Ae, C._decodedMemo, F, X, pe || ne);
      if (Ne === -1)
        return ti(null, null, null, null);
      let Se = Ae[Ne];
      if (Se.length === 1)
        return ti(null, null, null, null);
      let { names: Oe, resolvedSources: et } = C;
      return ti(et[Se[o]], Se[l] + 1, Se[u], Se.length === 5 ? Oe[Se[p]] : null);
    }
    s(ft, "originalPositionFor");
    function st(C, M) {
      let { source: F, line: X, column: pe, bias: re } = M;
      return Do(C, F, X, pe, re || ne, !1);
    }
    s(st, "generatedPositionFor");
    function nt(C, M) {
      let { source: F, line: X, column: pe, bias: re } = M;
      return Do(C, F, X, pe, re || Q, !0);
    }
    s(nt, "allGeneratedPositionsFor");
    function yt(C, M) {
      let F = Te(C), { names: X, resolvedSources: pe } = C;
      for (let re = 0; re < F.length; re++) {
        let Ae = F[re];
        for (let Ne = 0; Ne < Ae.length; Ne++) {
          let Se = Ae[Ne], Oe = re + 1, et = Se[0], Fe = null, Me = null, We = null, Tt = null;
          Se.length !== 1 && (Fe = pe[Se[1]], Me = Se[2] + 1, We = Se[3]), Se.length === 5 && (Tt = X[Se[4]]), M({
            generatedLine: Oe,
            generatedColumn: et,
            source: Fe,
            originalLine: Me,
            originalColumn: We,
            name: Tt
          });
        }
      }
    }
    s(yt, "eachMapping");
    function ht(C, M) {
      let { sources: F, resolvedSources: X } = C, pe = F.indexOf(M);
      return pe === -1 && (pe = X.indexOf(M)), pe;
    }
    s(ht, "sourceIndex");
    function Xe(C, M) {
      let { sourcesContent: F } = C;
      if (F == null)
        return null;
      let X = ht(C, M);
      return X === -1 ? null : F[X];
    }
    s(Xe, "sourceContentFor");
    function qe(C, M) {
      let { ignoreList: F } = C;
      if (F == null)
        return !1;
      let X = ht(C, M);
      return X === -1 ? !1 : F.includes(X);
    }
    s(qe, "isIgnored");
    function Pt(C, M) {
      let F = new le(gr(C, []), M);
      return F._decoded = C.mappings, F;
    }
    s(Pt, "presortedDecodedMap");
    function Vt(C) {
      return gr(C, Te(C));
    }
    s(Vt, "decodedMap");
    function os(C) {
      return gr(C, he(C));
    }
    s(os, "encodedMap");
    function gr(C, M) {
      return {
        version: C.version,
        file: C.file,
        names: C.names,
        sourceRoot: C.sourceRoot,
        sources: C.sources,
        sourcesContent: C.sourcesContent,
        mappings: M,
        ignoreList: C.ignoreList || C.x_google_ignoreList
      };
    }
    s(gr, "clone");
    function ti(C, M, F, X) {
      return { source: C, line: M, column: F, name: X };
    }
    s(ti, "OMapping");
    function Er(C, M) {
      return { line: C, column: M };
    }
    s(Er, "GMapping");
    function ri(C, M, F, X, pe) {
      let re = we(C, X, M, F);
      return k ? re = (pe === Q ? ue : K)(C, X, re) : pe === Q && re++, re === -1 || re === C.length ? -1 : re;
    }
    s(ri, "traceSegmentInternal");
    function kp(C, M, F, X, pe) {
      let re = ri(C, M, F, X, ne);
      if (!k && pe === Q && re++, re === -1 || re === C.length)
        return [];
      let Ae = k ? X : C[re][a];
      k || (re = K(C, Ae, re));
      let Ne = ue(C, Ae, re), Se = [];
      for (; re <= Ne; re++) {
        let Oe = C[re];
        Se.push(Er(Oe[h] + 1, Oe[E]));
      }
      return Se;
    }
    s(kp, "sliceGeneratedPositions");
    function Do(C, M, F, X, pe, re) {
      var Ae;
      if (F--, F < 0)
        throw new Error(U);
      if (X < 0)
        throw new Error(z);
      let { sources: Ne, resolvedSources: Se } = C, Oe = Ne.indexOf(M);
      if (Oe === -1 && (Oe = Se.indexOf(M)), Oe === -1)
        return re ? [] : Er(null, null);
      let Fe = ((Ae = C)._bySources || (Ae._bySources = je(Te(C), C._bySourceMemos = Ne.map(oe))))[Oe][F];
      if (Fe == null)
        return re ? [] : Er(null, null);
      let Me = C._bySourceMemos[Oe];
      if (re)
        return kp(Fe, Me, F, X, pe);
      let We = ri(Fe, Me, F, X, pe);
      if (We === -1)
        return Er(null, null);
      let Tt = Fe[We];
      return Er(Tt[h] + 1, Tt[E]);
    }
    s(Do, "generatedPosition"), t.AnyMap = J, t.GREATEST_LOWER_BOUND = ne, t.LEAST_UPPER_BOUND = Q, t.TraceMap = le, t.allGeneratedPositionsFor =
    nt, t.decodedMap = Vt, t.decodedMappings = Te, t.eachMapping = yt, t.encodedMap = os, t.encodedMappings = he, t.generatedPositionFor = st,
    t.isIgnored = qe, t.originalPositionFor = ft, t.presortedDecodedMap = Pt, t.sourceContentFor = Xe, t.traceSegment = Ke;
  });
});

// ../node_modules/@jridgewell/gen-mapping/dist/gen-mapping.umd.js
var $o = D((fi, Wo) => {
  (function(t, e) {
    typeof fi == "object" && typeof Wo < "u" ? e(fi, Yo(), ai(), ys()) : typeof define == "function" && define.amd ? define(["exports", "@jr\
idgewell/set-array", "@jridgewell/sourcemap-codec", "@jridgewell/trace-mapping"], e) : (t = typeof globalThis < "u" ? globalThis : t || self,
    e(t.genMapping = {}, t.setArray, t.sourcemapCodec, t.traceMapping));
  })(fi, function(t, e, r, i) {
    "use strict";
    class h {
      static {
        s(this, "GenMapping");
      }
      constructor({ file: U, sourceRoot: z } = {}) {
        this._names = new e.SetArray(), this._sources = new e.SetArray(), this._sourcesContent = [], this._mappings = [], this.file = U, this.
        sourceRoot = z, this._ignoreList = new e.SetArray();
      }
    }
    function E(V) {
      return V;
    }
    s(E, "cast");
    function I(V, U, z, Q, ne, le, fe, he) {
      return we(!1, V, U, z, Q, ne, le, fe, he);
    }
    s(I, "addSegment");
    function v(V, U) {
      return be(!1, V, U);
    }
    s(v, "addMapping");
    let _ = /* @__PURE__ */ s((V, U, z, Q, ne, le, fe, he) => we(!0, V, U, z, Q, ne, le, fe, he), "maybeAddSegment"), j = /* @__PURE__ */ s(
    (V, U) => be(!0, V, U), "maybeAddMapping");
    function O(V, U, z) {
      let { _sources: Q, _sourcesContent: ne } = V, le = e.put(Q, U);
      ne[le] = z;
    }
    s(O, "setSourceContent");
    function k(V, U, z = !0) {
      let { _sources: Q, _sourcesContent: ne, _ignoreList: le } = V, fe = e.put(Q, U);
      fe === ne.length && (ne[fe] = null), z ? e.put(le, fe) : e.remove(le, fe);
    }
    s(k, "setIgnore");
    function B(V) {
      let { _mappings: U, _sources: z, _sourcesContent: Q, _names: ne, _ignoreList: le } = V;
      return J(U), {
        version: 3,
        file: V.file || void 0,
        names: ne.array,
        sourceRoot: V.sourceRoot || void 0,
        sources: z.array,
        sourcesContent: Q,
        mappings: U,
        ignoreList: le.array
      };
    }
    s(B, "toDecodedMap");
    function ue(V) {
      let U = B(V);
      return Object.assign(Object.assign({}, U), { mappings: r.encode(U.mappings) });
    }
    s(ue, "toEncodedMap");
    function K(V) {
      let U = new i.TraceMap(V), z = new h({ file: U.file, sourceRoot: U.sourceRoot });
      return w(z._names, U.names), w(z._sources, U.sources), z._sourcesContent = U.sourcesContent || U.sources.map(() => null), z._mappings =
      i.decodedMappings(U), U.ignoreList && w(z._ignoreList, U.ignoreList), z;
    }
    s(K, "fromMap");
    function oe(V) {
      let U = [], { _mappings: z, _sources: Q, _names: ne } = V;
      for (let le = 0; le < z.length; le++) {
        let fe = z[le];
        for (let he = 0; he < fe.length; he++) {
          let Te = fe[he], Ke = { line: le + 1, column: Te[0] }, ft, st, nt;
          Te.length !== 1 && (ft = Q.array[Te[1]], st = { line: Te[2] + 1, column: Te[3] }, Te.length === 5 && (nt = ne.array[Te[4]])), U.push(
          { generated: Ke, source: ft, original: st, name: nt });
        }
      }
      return U;
    }
    s(oe, "allMappings");
    function we(V, U, z, Q, ne, le, fe, he, Te) {
      let { _mappings: Ke, _sources: ft, _sourcesContent: st, _names: nt } = U, yt = je(Ke, z), ht = Je(yt, Q);
      if (!ne)
        return V && $(yt, ht) ? void 0 : H(yt, ht, [Q]);
      let Xe = e.put(ft, ne), qe = he ? e.put(nt, he) : -1;
      if (Xe === st.length && (st[Xe] = Te ?? null), !(V && ce(yt, ht, Xe, le, fe, qe)))
        return H(yt, ht, he ? [Q, Xe, le, fe, qe] : [Q, Xe, le, fe]);
    }
    s(we, "addSegmentInternal");
    function je(V, U) {
      for (let z = V.length; z <= U; z++)
        V[z] = [];
      return V[U];
    }
    s(je, "getLine");
    function Je(V, U) {
      let z = V.length;
      for (let Q = z - 1; Q >= 0; z = Q--) {
        let ne = V[Q];
        if (U >= ne[0])
          break;
      }
      return z;
    }
    s(Je, "getColumnIndex");
    function H(V, U, z) {
      for (let Q = V.length; Q > U; Q--)
        V[Q] = V[Q - 1];
      V[U] = z;
    }
    s(H, "insert");
    function J(V) {
      let { length: U } = V, z = U;
      for (let Q = z - 1; Q >= 0 && !(V[Q].length > 0); z = Q, Q--)
        ;
      z < U && (V.length = z);
    }
    s(J, "removeEmptyFinalLines");
    function w(V, U) {
      for (let z = 0; z < U.length; z++)
        e.put(V, U[z]);
    }
    s(w, "putAll");
    function $(V, U) {
      return U === 0 ? !0 : V[U - 1].length === 1;
    }
    s($, "skipSourceless");
    function ce(V, U, z, Q, ne, le) {
      if (U === 0)
        return !1;
      let fe = V[U - 1];
      return fe.length === 1 ? !1 : z === fe[1] && Q === fe[2] && ne === fe[3] && le === (fe.length === 5 ? fe[4] : -1);
    }
    s(ce, "skipSource");
    function be(V, U, z) {
      let { generated: Q, source: ne, original: le, name: fe, content: he } = z;
      return ne ? we(V, U, Q.line - 1, Q.column, ne, le.line - 1, le.column, fe, he) : we(V, U, Q.line - 1, Q.column, null, null, null, null,
      null);
    }
    s(be, "addMappingInternal"), t.GenMapping = h, t.addMapping = v, t.addSegment = I, t.allMappings = oe, t.fromMap = K, t.maybeAddMapping =
    j, t.maybeAddSegment = _, t.setIgnore = k, t.setSourceContent = O, t.toDecodedMap = B, t.toEncodedMap = ue, Object.defineProperty(t, "__\
esModule", { value: !0 });
  });
});

// ../node_modules/@babel/generator/lib/source-map.js
var zo = D((hi) => {
  "use strict";
  Object.defineProperty(hi, "__esModule", {
    value: !0
  });
  hi.default = void 0;
  var kt = $o(), Ts = ys(), Ss = class {
    static {
      s(this, "SourceMap");
    }
    constructor(e, r) {
      var i;
      this._map = void 0, this._rawMappings = void 0, this._sourceFileName = void 0, this._lastGenLine = 0, this._lastSourceLine = 0, this._lastSourceColumn =
      0, this._inputMap = void 0;
      let n = this._map = new kt.GenMapping({
        sourceRoot: e.sourceRoot
      });
      if (this._sourceFileName = (i = e.sourceFileName) == null ? void 0 : i.replace(/\\/g, "/"), this._rawMappings = void 0, e.inputSourceMap) {
        this._inputMap = new Ts.TraceMap(e.inputSourceMap);
        let o = this._inputMap.resolvedSources;
        if (o.length)
          for (let l = 0; l < o.length; l++) {
            var a;
            (0, kt.setSourceContent)(n, o[l], (a = this._inputMap.sourcesContent) == null ? void 0 : a[l]);
          }
      }
      if (typeof r == "string" && !e.inputSourceMap)
        (0, kt.setSourceContent)(n, this._sourceFileName, r);
      else if (typeof r == "object")
        for (let o of Object.keys(r))
          (0, kt.setSourceContent)(n, o.replace(/\\/g, "/"), r[o]);
    }
    get() {
      return (0, kt.toEncodedMap)(this._map);
    }
    getDecoded() {
      return (0, kt.toDecodedMap)(this._map);
    }
    getRawMappings() {
      return this._rawMappings || (this._rawMappings = (0, kt.allMappings)(this._map));
    }
    mark(e, r, i, n, a, o) {
      var l;
      this._rawMappings = void 0;
      let u;
      if (r != null)
        if (this._inputMap) {
          if (u = (0, Ts.originalPositionFor)(this._inputMap, {
            line: r,
            column: i
          }), !u.name && a) {
            let p = (0, Ts.originalPositionFor)(this._inputMap, a);
            p.name && (n = p.name);
          }
        } else
          u = {
            source: o?.replace(/\\/g, "/") || this._sourceFileName,
            line: r,
            column: i
          };
      (0, kt.maybeAddMapping)(this._map, {
        name: n,
        generated: e,
        source: (l = u) == null ? void 0 : l.source,
        original: u
      });
    }
  };
  hi.default = Ss;
});

// ../node_modules/@babel/generator/lib/buffer.js
var Ho = D((di) => {
  "use strict";
  Object.defineProperty(di, "__esModule", {
    value: !0
  });
  di.default = void 0;
  var bs = class {
    static {
      s(this, "Buffer");
    }
    constructor(e, r) {
      this._map = null, this._buf = "", this._str = "", this._appendCount = 0, this._last = 0, this._queue = [], this._queueCursor = 0, this.
      _canMarkIdName = !0, this._indentChar = "", this._fastIndentations = [], this._position = {
        line: 1,
        column: 0
      }, this._sourcePosition = {
        identifierName: void 0,
        identifierNamePos: void 0,
        line: void 0,
        column: void 0,
        filename: void 0
      }, this._map = e, this._indentChar = r;
      for (let i = 0; i < 64; i++)
        this._fastIndentations.push(r.repeat(i));
      this._allocQueue();
    }
    _allocQueue() {
      let e = this._queue;
      for (let r = 0; r < 16; r++)
        e.push({
          char: 0,
          repeat: 1,
          line: void 0,
          column: void 0,
          identifierName: void 0,
          identifierNamePos: void 0,
          filename: ""
        });
    }
    _pushQueue(e, r, i, n, a) {
      let o = this._queueCursor;
      o === this._queue.length && this._allocQueue();
      let l = this._queue[o];
      l.char = e, l.repeat = r, l.line = i, l.column = n, l.filename = a, this._queueCursor++;
    }
    _popQueue() {
      if (this._queueCursor === 0)
        throw new Error("Cannot pop from empty queue");
      return this._queue[--this._queueCursor];
    }
    get() {
      this._flush();
      let e = this._map, r = {
        code: (this._buf + this._str).trimRight(),
        decodedMap: e?.getDecoded(),
        get __mergedMap() {
          return this.map;
        },
        get map() {
          let i = e ? e.get() : null;
          return r.map = i, i;
        },
        set map(i) {
          Object.defineProperty(r, "map", {
            value: i,
            writable: !0
          });
        },
        get rawMappings() {
          let i = e?.getRawMappings();
          return r.rawMappings = i, i;
        },
        set rawMappings(i) {
          Object.defineProperty(r, "rawMappings", {
            value: i,
            writable: !0
          });
        }
      };
      return r;
    }
    append(e, r) {
      this._flush(), this._append(e, this._sourcePosition, r);
    }
    appendChar(e) {
      this._flush(), this._appendChar(e, 1, this._sourcePosition);
    }
    queue(e) {
      if (e === 10)
        for (; this._queueCursor !== 0; ) {
          let i = this._queue[this._queueCursor - 1].char;
          if (i !== 32 && i !== 9)
            break;
          this._queueCursor--;
        }
      let r = this._sourcePosition;
      this._pushQueue(e, 1, r.line, r.column, r.filename);
    }
    queueIndentation(e) {
      e !== 0 && this._pushQueue(-1, e, void 0, void 0, void 0);
    }
    _flush() {
      let e = this._queueCursor, r = this._queue;
      for (let i = 0; i < e; i++) {
        let n = r[i];
        this._appendChar(n.char, n.repeat, n);
      }
      this._queueCursor = 0;
    }
    _appendChar(e, r, i) {
      if (this._last = e, e === -1) {
        let n = this._fastIndentations[r];
        n !== void 0 ? this._str += n : this._str += r > 1 ? this._indentChar.repeat(r) : this._indentChar;
      } else
        this._str += r > 1 ? String.fromCharCode(e).repeat(r) : String.fromCharCode(e);
      e !== 10 ? (this._mark(i.line, i.column, i.identifierName, i.identifierNamePos, i.filename), this._position.column += r) : (this._position.
      line++, this._position.column = 0), this._canMarkIdName && (i.identifierName = void 0, i.identifierNamePos = void 0);
    }
    _append(e, r, i) {
      let n = e.length, a = this._position;
      if (this._last = e.charCodeAt(n - 1), ++this._appendCount > 4096 ? (+this._str, this._buf += this._str, this._str = e, this._appendCount =
      0) : this._str += e, !i && !this._map) {
        a.column += n;
        return;
      }
      let {
        column: o,
        identifierName: l,
        identifierNamePos: u,
        filename: p
      } = r, h = r.line;
      (l != null || u != null) && this._canMarkIdName && (r.identifierName = void 0, r.identifierNamePos = void 0);
      let E = e.indexOf(`
`), I = 0;
      for (E !== 0 && this._mark(h, o, l, u, p); E !== -1; )
        a.line++, a.column = 0, I = E + 1, I < n && h !== void 0 && this._mark(++h, 0, null, null, p), E = e.indexOf(`
`, I);
      a.column += n - I;
    }
    _mark(e, r, i, n, a) {
      var o;
      (o = this._map) == null || o.mark(this._position, e, r, i, n, a);
    }
    removeTrailingNewline() {
      let e = this._queueCursor;
      e !== 0 && this._queue[e - 1].char === 10 && this._queueCursor--;
    }
    removeLastSemicolon() {
      let e = this._queueCursor;
      e !== 0 && this._queue[e - 1].char === 59 && this._queueCursor--;
    }
    getLastChar() {
      let e = this._queueCursor;
      return e !== 0 ? this._queue[e - 1].char : this._last;
    }
    getNewlineCount() {
      let e = this._queueCursor, r = 0;
      if (e === 0) return this._last === 10 ? 1 : 0;
      for (let i = e - 1; i >= 0 && this._queue[i].char === 10; i--)
        r++;
      return r === e && this._last === 10 ? r + 1 : r;
    }
    endsWithCharAndNewline() {
      let e = this._queue, r = this._queueCursor;
      if (r !== 0)
        return e[r - 1].char !== 10 ? void 0 : r > 1 ? e[r - 2].char : this._last;
    }
    hasContent() {
      return this._queueCursor !== 0 || !!this._last;
    }
    exactSource(e, r) {
      if (!this._map) {
        r();
        return;
      }
      this.source("start", e);
      let i = e.identifierName, n = this._sourcePosition;
      i && (this._canMarkIdName = !1, n.identifierName = i), r(), i && (this._canMarkIdName = !0, n.identifierName = void 0, n.identifierNamePos =
      void 0), this.source("end", e);
    }
    source(e, r) {
      this._map && this._normalizePosition(e, r, 0);
    }
    sourceWithOffset(e, r, i) {
      this._map && this._normalizePosition(e, r, i);
    }
    _normalizePosition(e, r, i) {
      let n = r[e], a = this._sourcePosition;
      n && (a.line = n.line, a.column = Math.max(n.column + i, 0), a.filename = r.filename);
    }
    getCurrentColumn() {
      let e = this._queue, r = this._queueCursor, i = -1, n = 0;
      for (let a = 0; a < r; a++) {
        let o = e[a];
        o.char === 10 && (i = n), n += o.repeat;
      }
      return i === -1 ? this._position.column + n : n - 1 - i;
    }
    getCurrentLine() {
      let e = 0, r = this._queue;
      for (let i = 0; i < this._queueCursor; i++)
        r[i].char === 10 && e++;
      return this._position.line + e;
    }
  };
  di.default = bs;
});

// ../node_modules/@babel/types/lib/utils/shallowEqual.js
var mi = D((xs) => {
  "use strict";
  Object.defineProperty(xs, "__esModule", {
    value: !0
  });
  xs.default = Gp;
  function Gp(t, e) {
    let r = Object.keys(e);
    for (let i of r)
      if (t[i] !== e[i])
        return !1;
    return !0;
  }
  s(Gp, "shallowEqual");
});

// ../node_modules/@babel/types/lib/utils/deprecationWarning.js
var Ir = D((gs) => {
  "use strict";
  Object.defineProperty(gs, "__esModule", {
    value: !0
  });
  gs.default = Qp;
  var Go = /* @__PURE__ */ new Set();
  function Qp(t, e, r = "") {
    if (Go.has(t)) return;
    Go.add(t);
    let {
      internal: i,
      trace: n
    } = Zp(1, 2);
    i || console.warn(`${r}\`${t}\` has been deprecated, please migrate to \`${e}\`
${n}`);
  }
  s(Qp, "deprecationWarning");
  function Zp(t, e) {
    let {
      stackTraceLimit: r,
      prepareStackTrace: i
    } = Error, n;
    if (Error.stackTraceLimit = 1 + t + e, Error.prepareStackTrace = function(o, l) {
      n = l;
    }, new Error().stack, Error.stackTraceLimit = r, Error.prepareStackTrace = i, !n) return {
      internal: !1,
      trace: ""
    };
    let a = n.slice(1 + t, 1 + t + e);
    return {
      internal: /[\\/]@babel[\\/]/.test(a[1].getFileName()),
      trace: a.map((o) => `    at ${o}`).join(`
`)
    };
  }
  s(Zp, "captureShortStackTrace");
});

// ../node_modules/@babel/types/lib/validators/generated/index.js
var Be = D((d) => {
  "use strict";
  Object.defineProperty(d, "__esModule", {
    value: !0
  });
  d.isAccessor = yT;
  d.isAnyTypeAnnotation = Bh;
  d.isArgumentPlaceholder = pm;
  d.isArrayExpression = ef;
  d.isArrayPattern = Zf;
  d.isArrayTypeAnnotation = jh;
  d.isArrowFunctionExpression = eh;
  d.isAssignmentExpression = tf;
  d.isAssignmentPattern = Qf;
  d.isAwaitExpression = Ph;
  d.isBigIntLiteral = Ih;
  d.isBinary = Ry;
  d.isBinaryExpression = rf;
  d.isBindExpression = fm;
  d.isBlock = Ky;
  d.isBlockParent = Uy;
  d.isBlockStatement = of;
  d.isBooleanLiteral = wf;
  d.isBooleanLiteralTypeAnnotation = Rh;
  d.isBooleanTypeAnnotation = Fh;
  d.isBreakStatement = lf;
  d.isCallExpression = uf;
  d.isCatchClause = cf;
  d.isClass = hT;
  d.isClassAccessorProperty = Oh;
  d.isClassBody = th;
  d.isClassDeclaration = ih;
  d.isClassExpression = rh;
  d.isClassImplements = Uh;
  d.isClassMethod = mh;
  d.isClassPrivateMethod = Dh;
  d.isClassPrivateProperty = _h;
  d.isClassProperty = Nh;
  d.isCompletionStatement = Jy;
  d.isConditional = Xy;
  d.isConditionalExpression = pf;
  d.isContinueStatement = ff;
  d.isDebuggerStatement = hf;
  d.isDecimalLiteral = Sm;
  d.isDeclaration = tT;
  d.isDeclareClass = Kh;
  d.isDeclareExportAllDeclaration = Gh;
  d.isDeclareExportDeclaration = Hh;
  d.isDeclareFunction = Vh;
  d.isDeclareInterface = Yh;
  d.isDeclareModule = Jh;
  d.isDeclareModuleExports = Xh;
  d.isDeclareOpaqueType = $h;
  d.isDeclareTypeAlias = Wh;
  d.isDeclareVariable = zh;
  d.isDeclaredPredicate = Qh;
  d.isDecorator = hm;
  d.isDirective = nf;
  d.isDirectiveLiteral = af;
  d.isDoExpression = dm;
  d.isDoWhileStatement = df;
  d.isEmptyStatement = mf;
  d.isEmptyTypeAnnotation = ud;
  d.isEnumBody = PT;
  d.isEnumBooleanBody = jd;
  d.isEnumBooleanMember = Ud;
  d.isEnumDeclaration = Bd;
  d.isEnumDefaultedMember = Yd;
  d.isEnumMember = AT;
  d.isEnumNumberBody = Fd;
  d.isEnumNumberMember = Kd;
  d.isEnumStringBody = Rd;
  d.isEnumStringMember = Vd;
  d.isEnumSymbolBody = qd;
  d.isExistsTypeAnnotation = Zh;
  d.isExportAllDeclaration = sh;
  d.isExportDeclaration = dT;
  d.isExportDefaultDeclaration = nh;
  d.isExportDefaultSpecifier = mm;
  d.isExportNamedDeclaration = ah;
  d.isExportNamespaceSpecifier = vh;
  d.isExportSpecifier = oh;
  d.isExpression = Fy;
  d.isExpressionStatement = yf;
  d.isExpressionWrapper = zy;
  d.isFile = Tf;
  d.isFlow = ST;
  d.isFlowBaseAnnotation = xT;
  d.isFlowDeclaration = gT;
  d.isFlowPredicate = ET;
  d.isFlowType = bT;
  d.isFor = Hy;
  d.isForInStatement = Sf;
  d.isForOfStatement = lh;
  d.isForStatement = bf;
  d.isForXStatement = Gy;
  d.isFunction = Qy;
  d.isFunctionDeclaration = xf;
  d.isFunctionExpression = gf;
  d.isFunctionParent = Zy;
  d.isFunctionTypeAnnotation = ed;
  d.isFunctionTypeParam = td;
  d.isGenericTypeAnnotation = rd;
  d.isIdentifier = Ef;
  d.isIfStatement = Pf;
  d.isImmutable = aT;
  d.isImport = Ah;
  d.isImportAttribute = Mh;
  d.isImportDeclaration = uh;
  d.isImportDefaultSpecifier = ch;
  d.isImportExpression = hh;
  d.isImportNamespaceSpecifier = ph;
  d.isImportOrExportDeclaration = Qo;
  d.isImportSpecifier = fh;
  d.isIndexedAccessType = Jd;
  d.isInferredPredicate = id;
  d.isInterfaceDeclaration = nd;
  d.isInterfaceExtends = sd;
  d.isInterfaceTypeAnnotation = ad;
  d.isInterpreterDirective = sf;
  d.isIntersectionTypeAnnotation = od;
  d.isJSX = IT;
  d.isJSXAttribute = Wd;
  d.isJSXClosingElement = $d;
  d.isJSXClosingFragment = om;
  d.isJSXElement = zd;
  d.isJSXEmptyExpression = Hd;
  d.isJSXExpressionContainer = Gd;
  d.isJSXFragment = nm;
  d.isJSXIdentifier = Zd;
  d.isJSXMemberExpression = em;
  d.isJSXNamespacedName = tm;
  d.isJSXOpeningElement = rm;
  d.isJSXOpeningFragment = am;
  d.isJSXSpreadAttribute = im;
  d.isJSXSpreadChild = Qd;
  d.isJSXText = sm;
  d.isLVal = iT;
  d.isLabeledStatement = Af;
  d.isLiteral = nT;
  d.isLogicalExpression = Of;
  d.isLoop = Wy;
  d.isMemberExpression = _f;
  d.isMetaProperty = dh;
  d.isMethod = lT;
  d.isMiscellaneous = vT;
  d.isMixedTypeAnnotation = ld;
  d.isModuleDeclaration = MT;
  d.isModuleExpression = bm;
  d.isModuleSpecifier = mT;
  d.isNewExpression = Df;
  d.isNoop = lm;
  d.isNullLiteral = Cf;
  d.isNullLiteralTypeAnnotation = qh;
  d.isNullableTypeAnnotation = cd;
  d.isNumberLiteral = _T;
  d.isNumberLiteralTypeAnnotation = pd;
  d.isNumberTypeAnnotation = fd;
  d.isNumericLiteral = vf;
  d.isObjectExpression = Lf;
  d.isObjectMember = uT;
  d.isObjectMethod = Mf;
  d.isObjectPattern = yh;
  d.isObjectProperty = Bf;
  d.isObjectTypeAnnotation = hd;
  d.isObjectTypeCallProperty = md;
  d.isObjectTypeIndexer = yd;
  d.isObjectTypeInternalSlot = dd;
  d.isObjectTypeProperty = Td;
  d.isObjectTypeSpreadProperty = Sd;
  d.isOpaqueType = bd;
  d.isOptionalCallExpression = wh;
  d.isOptionalIndexedAccessType = Xd;
  d.isOptionalMemberExpression = Ch;
  d.isParenthesizedExpression = qf;
  d.isPattern = fT;
  d.isPatternLike = rT;
  d.isPipelineBareFunction = Em;
  d.isPipelinePrimaryTopicReference = Pm;
  d.isPipelineTopicExpression = gm;
  d.isPlaceholder = um;
  d.isPrivate = TT;
  d.isPrivateName = kh;
  d.isProgram = kf;
  d.isProperty = cT;
  d.isPureish = eT;
  d.isQualifiedTypeIdentifier = xd;
  d.isRecordExpression = ym;
  d.isRegExpLiteral = Nf;
  d.isRegexLiteral = DT;
  d.isRestElement = jf;
  d.isRestProperty = kT;
  d.isReturnStatement = Ff;
  d.isScopable = qy;
  d.isSequenceExpression = Rf;
  d.isSpreadElement = Th;
  d.isSpreadProperty = LT;
  d.isStandardized = jy;
  d.isStatement = Vy;
  d.isStaticBlock = Lh;
  d.isStringLiteral = If;
  d.isStringLiteralTypeAnnotation = gd;
  d.isStringTypeAnnotation = Ed;
  d.isSuper = Sh;
  d.isSwitchCase = Uf;
  d.isSwitchStatement = Kf;
  d.isSymbolTypeAnnotation = Pd;
  d.isTSAnyKeyword = km;
  d.isTSArrayType = Zm;
  d.isTSAsExpression = by;
  d.isTSBaseType = OT;
  d.isTSBigIntKeyword = Mm;
  d.isTSBooleanKeyword = Lm;
  d.isTSCallSignatureDeclaration = wm;
  d.isTSConditionalType = ay;
  d.isTSConstructSignatureDeclaration = Nm;
  d.isTSConstructorType = $m;
  d.isTSDeclareFunction = Im;
  d.isTSDeclareMethod = vm;
  d.isTSEntityName = sT;
  d.isTSEnumBody = Ey;
  d.isTSEnumDeclaration = Py;
  d.isTSEnumMember = Ay;
  d.isTSExportAssignment = _y;
  d.isTSExpressionWithTypeArguments = dy;
  d.isTSExternalModuleReference = Ny;
  d.isTSFunctionType = Wm;
  d.isTSImportEqualsDeclaration = wy;
  d.isTSImportType = Cy;
  d.isTSIndexSignature = Dm;
  d.isTSIndexedAccessType = cy;
  d.isTSInferType = oy;
  d.isTSInstantiationExpression = Sy;
  d.isTSInterfaceBody = yy;
  d.isTSInterfaceDeclaration = my;
  d.isTSIntersectionType = ny;
  d.isTSIntrinsicKeyword = Bm;
  d.isTSLiteralType = hy;
  d.isTSMappedType = py;
  d.isTSMethodSignature = _m;
  d.isTSModuleBlock = vy;
  d.isTSModuleDeclaration = Iy;
  d.isTSNamedTupleMember = iy;
  d.isTSNamespaceExportDeclaration = Dy;
  d.isTSNeverKeyword = jm;
  d.isTSNonNullExpression = Oy;
  d.isTSNullKeyword = Fm;
  d.isTSNumberKeyword = Rm;
  d.isTSObjectKeyword = qm;
  d.isTSOptionalType = ty;
  d.isTSParameterProperty = Am;
  d.isTSParenthesizedType = ly;
  d.isTSPropertySignature = Om;
  d.isTSQualifiedName = Cm;
  d.isTSRestType = ry;
  d.isTSSatisfiesExpression = xy;
  d.isTSStringKeyword = Um;
  d.isTSSymbolKeyword = Km;
  d.isTSTemplateLiteralType = fy;
  d.isTSThisType = Xm;
  d.isTSTupleType = ey;
  d.isTSType = NT;
  d.isTSTypeAliasDeclaration = Ty;
  d.isTSTypeAnnotation = ky;
  d.isTSTypeAssertion = gy;
  d.isTSTypeElement = wT;
  d.isTSTypeLiteral = Qm;
  d.isTSTypeOperator = uy;
  d.isTSTypeParameter = By;
  d.isTSTypeParameterDeclaration = My;
  d.isTSTypeParameterInstantiation = Ly;
  d.isTSTypePredicate = Hm;
  d.isTSTypeQuery = Gm;
  d.isTSTypeReference = zm;
  d.isTSUndefinedKeyword = Vm;
  d.isTSUnionType = sy;
  d.isTSUnknownKeyword = Ym;
  d.isTSVoidKeyword = Jm;
  d.isTaggedTemplateExpression = bh;
  d.isTemplateElement = xh;
  d.isTemplateLiteral = gh;
  d.isTerminatorless = Yy;
  d.isThisExpression = Vf;
  d.isThisTypeAnnotation = Ad;
  d.isThrowStatement = Yf;
  d.isTopicReference = xm;
  d.isTryStatement = Jf;
  d.isTupleExpression = Tm;
  d.isTupleTypeAnnotation = Id;
  d.isTypeAlias = Cd;
  d.isTypeAnnotation = wd;
  d.isTypeCastExpression = Nd;
  d.isTypeParameter = Od;
  d.isTypeParameterDeclaration = _d;
  d.isTypeParameterInstantiation = Dd;
  d.isTypeScript = CT;
  d.isTypeofTypeAnnotation = vd;
  d.isUnaryExpression = Xf;
  d.isUnaryLike = pT;
  d.isUnionTypeAnnotation = kd;
  d.isUpdateExpression = Wf;
  d.isUserWhitespacable = oT;
  d.isV8IntrinsicIdentifier = cm;
  d.isVariableDeclaration = $f;
  d.isVariableDeclarator = zf;
  d.isVariance = Ld;
  d.isVoidTypeAnnotation = Md;
  d.isWhile = $y;
  d.isWhileStatement = Hf;
  d.isWithStatement = Gf;
  d.isYieldExpression = Eh;
  var T = mi(), vr = Ir();
  function ef(t, e) {
    return !t || t.type !== "ArrayExpression" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(ef, "isArrayExpression");
  function tf(t, e) {
    return !t || t.type !== "AssignmentExpression" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(tf, "isAssignmentExpression");
  function rf(t, e) {
    return !t || t.type !== "BinaryExpression" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(rf, "isBinaryExpression");
  function sf(t, e) {
    return !t || t.type !== "InterpreterDirective" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(sf, "isInterpreterDirective");
  function nf(t, e) {
    return !t || t.type !== "Directive" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(nf, "isDirective");
  function af(t, e) {
    return !t || t.type !== "DirectiveLiteral" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(af, "isDirectiveLiteral");
  function of(t, e) {
    return !t || t.type !== "BlockStatement" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(of, "isBlockStatement");
  function lf(t, e) {
    return !t || t.type !== "BreakStatement" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(lf, "isBreakStatement");
  function uf(t, e) {
    return !t || t.type !== "CallExpression" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(uf, "isCallExpression");
  function cf(t, e) {
    return !t || t.type !== "CatchClause" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(cf, "isCatchClause");
  function pf(t, e) {
    return !t || t.type !== "ConditionalExpression" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(pf, "isConditionalExpression");
  function ff(t, e) {
    return !t || t.type !== "ContinueStatement" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(ff, "isContinueStatement");
  function hf(t, e) {
    return !t || t.type !== "DebuggerStatement" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(hf, "isDebuggerStatement");
  function df(t, e) {
    return !t || t.type !== "DoWhileStatement" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(df, "isDoWhileStatement");
  function mf(t, e) {
    return !t || t.type !== "EmptyStatement" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(mf, "isEmptyStatement");
  function yf(t, e) {
    return !t || t.type !== "ExpressionStatement" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(yf, "isExpressionStatement");
  function Tf(t, e) {
    return !t || t.type !== "File" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Tf, "isFile");
  function Sf(t, e) {
    return !t || t.type !== "ForInStatement" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Sf, "isForInStatement");
  function bf(t, e) {
    return !t || t.type !== "ForStatement" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(bf, "isForStatement");
  function xf(t, e) {
    return !t || t.type !== "FunctionDeclaration" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(xf, "isFunctionDeclaration");
  function gf(t, e) {
    return !t || t.type !== "FunctionExpression" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(gf, "isFunctionExpression");
  function Ef(t, e) {
    return !t || t.type !== "Identifier" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Ef, "isIdentifier");
  function Pf(t, e) {
    return !t || t.type !== "IfStatement" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Pf, "isIfStatement");
  function Af(t, e) {
    return !t || t.type !== "LabeledStatement" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Af, "isLabeledStatement");
  function If(t, e) {
    return !t || t.type !== "StringLiteral" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(If, "isStringLiteral");
  function vf(t, e) {
    return !t || t.type !== "NumericLiteral" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(vf, "isNumericLiteral");
  function Cf(t, e) {
    return !t || t.type !== "NullLiteral" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Cf, "isNullLiteral");
  function wf(t, e) {
    return !t || t.type !== "BooleanLiteral" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(wf, "isBooleanLiteral");
  function Nf(t, e) {
    return !t || t.type !== "RegExpLiteral" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Nf, "isRegExpLiteral");
  function Of(t, e) {
    return !t || t.type !== "LogicalExpression" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Of, "isLogicalExpression");
  function _f(t, e) {
    return !t || t.type !== "MemberExpression" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(_f, "isMemberExpression");
  function Df(t, e) {
    return !t || t.type !== "NewExpression" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Df, "isNewExpression");
  function kf(t, e) {
    return !t || t.type !== "Program" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(kf, "isProgram");
  function Lf(t, e) {
    return !t || t.type !== "ObjectExpression" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Lf, "isObjectExpression");
  function Mf(t, e) {
    return !t || t.type !== "ObjectMethod" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Mf, "isObjectMethod");
  function Bf(t, e) {
    return !t || t.type !== "ObjectProperty" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Bf, "isObjectProperty");
  function jf(t, e) {
    return !t || t.type !== "RestElement" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(jf, "isRestElement");
  function Ff(t, e) {
    return !t || t.type !== "ReturnStatement" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Ff, "isReturnStatement");
  function Rf(t, e) {
    return !t || t.type !== "SequenceExpression" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Rf, "isSequenceExpression");
  function qf(t, e) {
    return !t || t.type !== "ParenthesizedExpression" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(qf, "isParenthesizedExpression");
  function Uf(t, e) {
    return !t || t.type !== "SwitchCase" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Uf, "isSwitchCase");
  function Kf(t, e) {
    return !t || t.type !== "SwitchStatement" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Kf, "isSwitchStatement");
  function Vf(t, e) {
    return !t || t.type !== "ThisExpression" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Vf, "isThisExpression");
  function Yf(t, e) {
    return !t || t.type !== "ThrowStatement" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Yf, "isThrowStatement");
  function Jf(t, e) {
    return !t || t.type !== "TryStatement" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Jf, "isTryStatement");
  function Xf(t, e) {
    return !t || t.type !== "UnaryExpression" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Xf, "isUnaryExpression");
  function Wf(t, e) {
    return !t || t.type !== "UpdateExpression" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Wf, "isUpdateExpression");
  function $f(t, e) {
    return !t || t.type !== "VariableDeclaration" ? !1 : e == null || (0, T.default)(t, e);
  }
  s($f, "isVariableDeclaration");
  function zf(t, e) {
    return !t || t.type !== "VariableDeclarator" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(zf, "isVariableDeclarator");
  function Hf(t, e) {
    return !t || t.type !== "WhileStatement" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Hf, "isWhileStatement");
  function Gf(t, e) {
    return !t || t.type !== "WithStatement" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Gf, "isWithStatement");
  function Qf(t, e) {
    return !t || t.type !== "AssignmentPattern" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Qf, "isAssignmentPattern");
  function Zf(t, e) {
    return !t || t.type !== "ArrayPattern" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Zf, "isArrayPattern");
  function eh(t, e) {
    return !t || t.type !== "ArrowFunctionExpression" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(eh, "isArrowFunctionExpression");
  function th(t, e) {
    return !t || t.type !== "ClassBody" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(th, "isClassBody");
  function rh(t, e) {
    return !t || t.type !== "ClassExpression" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(rh, "isClassExpression");
  function ih(t, e) {
    return !t || t.type !== "ClassDeclaration" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(ih, "isClassDeclaration");
  function sh(t, e) {
    return !t || t.type !== "ExportAllDeclaration" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(sh, "isExportAllDeclaration");
  function nh(t, e) {
    return !t || t.type !== "ExportDefaultDeclaration" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(nh, "isExportDefaultDeclaration");
  function ah(t, e) {
    return !t || t.type !== "ExportNamedDeclaration" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(ah, "isExportNamedDeclaration");
  function oh(t, e) {
    return !t || t.type !== "ExportSpecifier" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(oh, "isExportSpecifier");
  function lh(t, e) {
    return !t || t.type !== "ForOfStatement" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(lh, "isForOfStatement");
  function uh(t, e) {
    return !t || t.type !== "ImportDeclaration" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(uh, "isImportDeclaration");
  function ch(t, e) {
    return !t || t.type !== "ImportDefaultSpecifier" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(ch, "isImportDefaultSpecifier");
  function ph(t, e) {
    return !t || t.type !== "ImportNamespaceSpecifier" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(ph, "isImportNamespaceSpecifier");
  function fh(t, e) {
    return !t || t.type !== "ImportSpecifier" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(fh, "isImportSpecifier");
  function hh(t, e) {
    return !t || t.type !== "ImportExpression" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(hh, "isImportExpression");
  function dh(t, e) {
    return !t || t.type !== "MetaProperty" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(dh, "isMetaProperty");
  function mh(t, e) {
    return !t || t.type !== "ClassMethod" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(mh, "isClassMethod");
  function yh(t, e) {
    return !t || t.type !== "ObjectPattern" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(yh, "isObjectPattern");
  function Th(t, e) {
    return !t || t.type !== "SpreadElement" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Th, "isSpreadElement");
  function Sh(t, e) {
    return !t || t.type !== "Super" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Sh, "isSuper");
  function bh(t, e) {
    return !t || t.type !== "TaggedTemplateExpression" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(bh, "isTaggedTemplateExpression");
  function xh(t, e) {
    return !t || t.type !== "TemplateElement" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(xh, "isTemplateElement");
  function gh(t, e) {
    return !t || t.type !== "TemplateLiteral" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(gh, "isTemplateLiteral");
  function Eh(t, e) {
    return !t || t.type !== "YieldExpression" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Eh, "isYieldExpression");
  function Ph(t, e) {
    return !t || t.type !== "AwaitExpression" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Ph, "isAwaitExpression");
  function Ah(t, e) {
    return !t || t.type !== "Import" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Ah, "isImport");
  function Ih(t, e) {
    return !t || t.type !== "BigIntLiteral" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Ih, "isBigIntLiteral");
  function vh(t, e) {
    return !t || t.type !== "ExportNamespaceSpecifier" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(vh, "isExportNamespaceSpecifier");
  function Ch(t, e) {
    return !t || t.type !== "OptionalMemberExpression" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Ch, "isOptionalMemberExpression");
  function wh(t, e) {
    return !t || t.type !== "OptionalCallExpression" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(wh, "isOptionalCallExpression");
  function Nh(t, e) {
    return !t || t.type !== "ClassProperty" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Nh, "isClassProperty");
  function Oh(t, e) {
    return !t || t.type !== "ClassAccessorProperty" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Oh, "isClassAccessorProperty");
  function _h(t, e) {
    return !t || t.type !== "ClassPrivateProperty" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(_h, "isClassPrivateProperty");
  function Dh(t, e) {
    return !t || t.type !== "ClassPrivateMethod" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Dh, "isClassPrivateMethod");
  function kh(t, e) {
    return !t || t.type !== "PrivateName" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(kh, "isPrivateName");
  function Lh(t, e) {
    return !t || t.type !== "StaticBlock" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Lh, "isStaticBlock");
  function Mh(t, e) {
    return !t || t.type !== "ImportAttribute" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Mh, "isImportAttribute");
  function Bh(t, e) {
    return !t || t.type !== "AnyTypeAnnotation" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Bh, "isAnyTypeAnnotation");
  function jh(t, e) {
    return !t || t.type !== "ArrayTypeAnnotation" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(jh, "isArrayTypeAnnotation");
  function Fh(t, e) {
    return !t || t.type !== "BooleanTypeAnnotation" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Fh, "isBooleanTypeAnnotation");
  function Rh(t, e) {
    return !t || t.type !== "BooleanLiteralTypeAnnotation" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Rh, "isBooleanLiteralTypeAnnotation");
  function qh(t, e) {
    return !t || t.type !== "NullLiteralTypeAnnotation" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(qh, "isNullLiteralTypeAnnotation");
  function Uh(t, e) {
    return !t || t.type !== "ClassImplements" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Uh, "isClassImplements");
  function Kh(t, e) {
    return !t || t.type !== "DeclareClass" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Kh, "isDeclareClass");
  function Vh(t, e) {
    return !t || t.type !== "DeclareFunction" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Vh, "isDeclareFunction");
  function Yh(t, e) {
    return !t || t.type !== "DeclareInterface" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Yh, "isDeclareInterface");
  function Jh(t, e) {
    return !t || t.type !== "DeclareModule" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Jh, "isDeclareModule");
  function Xh(t, e) {
    return !t || t.type !== "DeclareModuleExports" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Xh, "isDeclareModuleExports");
  function Wh(t, e) {
    return !t || t.type !== "DeclareTypeAlias" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Wh, "isDeclareTypeAlias");
  function $h(t, e) {
    return !t || t.type !== "DeclareOpaqueType" ? !1 : e == null || (0, T.default)(t, e);
  }
  s($h, "isDeclareOpaqueType");
  function zh(t, e) {
    return !t || t.type !== "DeclareVariable" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(zh, "isDeclareVariable");
  function Hh(t, e) {
    return !t || t.type !== "DeclareExportDeclaration" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Hh, "isDeclareExportDeclaration");
  function Gh(t, e) {
    return !t || t.type !== "DeclareExportAllDeclaration" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Gh, "isDeclareExportAllDeclaration");
  function Qh(t, e) {
    return !t || t.type !== "DeclaredPredicate" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Qh, "isDeclaredPredicate");
  function Zh(t, e) {
    return !t || t.type !== "ExistsTypeAnnotation" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Zh, "isExistsTypeAnnotation");
  function ed(t, e) {
    return !t || t.type !== "FunctionTypeAnnotation" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(ed, "isFunctionTypeAnnotation");
  function td(t, e) {
    return !t || t.type !== "FunctionTypeParam" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(td, "isFunctionTypeParam");
  function rd(t, e) {
    return !t || t.type !== "GenericTypeAnnotation" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(rd, "isGenericTypeAnnotation");
  function id(t, e) {
    return !t || t.type !== "InferredPredicate" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(id, "isInferredPredicate");
  function sd(t, e) {
    return !t || t.type !== "InterfaceExtends" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(sd, "isInterfaceExtends");
  function nd(t, e) {
    return !t || t.type !== "InterfaceDeclaration" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(nd, "isInterfaceDeclaration");
  function ad(t, e) {
    return !t || t.type !== "InterfaceTypeAnnotation" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(ad, "isInterfaceTypeAnnotation");
  function od(t, e) {
    return !t || t.type !== "IntersectionTypeAnnotation" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(od, "isIntersectionTypeAnnotation");
  function ld(t, e) {
    return !t || t.type !== "MixedTypeAnnotation" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(ld, "isMixedTypeAnnotation");
  function ud(t, e) {
    return !t || t.type !== "EmptyTypeAnnotation" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(ud, "isEmptyTypeAnnotation");
  function cd(t, e) {
    return !t || t.type !== "NullableTypeAnnotation" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(cd, "isNullableTypeAnnotation");
  function pd(t, e) {
    return !t || t.type !== "NumberLiteralTypeAnnotation" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(pd, "isNumberLiteralTypeAnnotation");
  function fd(t, e) {
    return !t || t.type !== "NumberTypeAnnotation" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(fd, "isNumberTypeAnnotation");
  function hd(t, e) {
    return !t || t.type !== "ObjectTypeAnnotation" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(hd, "isObjectTypeAnnotation");
  function dd(t, e) {
    return !t || t.type !== "ObjectTypeInternalSlot" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(dd, "isObjectTypeInternalSlot");
  function md(t, e) {
    return !t || t.type !== "ObjectTypeCallProperty" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(md, "isObjectTypeCallProperty");
  function yd(t, e) {
    return !t || t.type !== "ObjectTypeIndexer" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(yd, "isObjectTypeIndexer");
  function Td(t, e) {
    return !t || t.type !== "ObjectTypeProperty" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Td, "isObjectTypeProperty");
  function Sd(t, e) {
    return !t || t.type !== "ObjectTypeSpreadProperty" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Sd, "isObjectTypeSpreadProperty");
  function bd(t, e) {
    return !t || t.type !== "OpaqueType" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(bd, "isOpaqueType");
  function xd(t, e) {
    return !t || t.type !== "QualifiedTypeIdentifier" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(xd, "isQualifiedTypeIdentifier");
  function gd(t, e) {
    return !t || t.type !== "StringLiteralTypeAnnotation" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(gd, "isStringLiteralTypeAnnotation");
  function Ed(t, e) {
    return !t || t.type !== "StringTypeAnnotation" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Ed, "isStringTypeAnnotation");
  function Pd(t, e) {
    return !t || t.type !== "SymbolTypeAnnotation" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Pd, "isSymbolTypeAnnotation");
  function Ad(t, e) {
    return !t || t.type !== "ThisTypeAnnotation" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Ad, "isThisTypeAnnotation");
  function Id(t, e) {
    return !t || t.type !== "TupleTypeAnnotation" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Id, "isTupleTypeAnnotation");
  function vd(t, e) {
    return !t || t.type !== "TypeofTypeAnnotation" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(vd, "isTypeofTypeAnnotation");
  function Cd(t, e) {
    return !t || t.type !== "TypeAlias" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Cd, "isTypeAlias");
  function wd(t, e) {
    return !t || t.type !== "TypeAnnotation" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(wd, "isTypeAnnotation");
  function Nd(t, e) {
    return !t || t.type !== "TypeCastExpression" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Nd, "isTypeCastExpression");
  function Od(t, e) {
    return !t || t.type !== "TypeParameter" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Od, "isTypeParameter");
  function _d(t, e) {
    return !t || t.type !== "TypeParameterDeclaration" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(_d, "isTypeParameterDeclaration");
  function Dd(t, e) {
    return !t || t.type !== "TypeParameterInstantiation" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Dd, "isTypeParameterInstantiation");
  function kd(t, e) {
    return !t || t.type !== "UnionTypeAnnotation" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(kd, "isUnionTypeAnnotation");
  function Ld(t, e) {
    return !t || t.type !== "Variance" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Ld, "isVariance");
  function Md(t, e) {
    return !t || t.type !== "VoidTypeAnnotation" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Md, "isVoidTypeAnnotation");
  function Bd(t, e) {
    return !t || t.type !== "EnumDeclaration" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Bd, "isEnumDeclaration");
  function jd(t, e) {
    return !t || t.type !== "EnumBooleanBody" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(jd, "isEnumBooleanBody");
  function Fd(t, e) {
    return !t || t.type !== "EnumNumberBody" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Fd, "isEnumNumberBody");
  function Rd(t, e) {
    return !t || t.type !== "EnumStringBody" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Rd, "isEnumStringBody");
  function qd(t, e) {
    return !t || t.type !== "EnumSymbolBody" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(qd, "isEnumSymbolBody");
  function Ud(t, e) {
    return !t || t.type !== "EnumBooleanMember" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Ud, "isEnumBooleanMember");
  function Kd(t, e) {
    return !t || t.type !== "EnumNumberMember" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Kd, "isEnumNumberMember");
  function Vd(t, e) {
    return !t || t.type !== "EnumStringMember" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Vd, "isEnumStringMember");
  function Yd(t, e) {
    return !t || t.type !== "EnumDefaultedMember" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Yd, "isEnumDefaultedMember");
  function Jd(t, e) {
    return !t || t.type !== "IndexedAccessType" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Jd, "isIndexedAccessType");
  function Xd(t, e) {
    return !t || t.type !== "OptionalIndexedAccessType" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Xd, "isOptionalIndexedAccessType");
  function Wd(t, e) {
    return !t || t.type !== "JSXAttribute" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Wd, "isJSXAttribute");
  function $d(t, e) {
    return !t || t.type !== "JSXClosingElement" ? !1 : e == null || (0, T.default)(t, e);
  }
  s($d, "isJSXClosingElement");
  function zd(t, e) {
    return !t || t.type !== "JSXElement" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(zd, "isJSXElement");
  function Hd(t, e) {
    return !t || t.type !== "JSXEmptyExpression" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Hd, "isJSXEmptyExpression");
  function Gd(t, e) {
    return !t || t.type !== "JSXExpressionContainer" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Gd, "isJSXExpressionContainer");
  function Qd(t, e) {
    return !t || t.type !== "JSXSpreadChild" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Qd, "isJSXSpreadChild");
  function Zd(t, e) {
    return !t || t.type !== "JSXIdentifier" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Zd, "isJSXIdentifier");
  function em(t, e) {
    return !t || t.type !== "JSXMemberExpression" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(em, "isJSXMemberExpression");
  function tm(t, e) {
    return !t || t.type !== "JSXNamespacedName" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(tm, "isJSXNamespacedName");
  function rm(t, e) {
    return !t || t.type !== "JSXOpeningElement" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(rm, "isJSXOpeningElement");
  function im(t, e) {
    return !t || t.type !== "JSXSpreadAttribute" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(im, "isJSXSpreadAttribute");
  function sm(t, e) {
    return !t || t.type !== "JSXText" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(sm, "isJSXText");
  function nm(t, e) {
    return !t || t.type !== "JSXFragment" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(nm, "isJSXFragment");
  function am(t, e) {
    return !t || t.type !== "JSXOpeningFragment" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(am, "isJSXOpeningFragment");
  function om(t, e) {
    return !t || t.type !== "JSXClosingFragment" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(om, "isJSXClosingFragment");
  function lm(t, e) {
    return !t || t.type !== "Noop" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(lm, "isNoop");
  function um(t, e) {
    return !t || t.type !== "Placeholder" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(um, "isPlaceholder");
  function cm(t, e) {
    return !t || t.type !== "V8IntrinsicIdentifier" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(cm, "isV8IntrinsicIdentifier");
  function pm(t, e) {
    return !t || t.type !== "ArgumentPlaceholder" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(pm, "isArgumentPlaceholder");
  function fm(t, e) {
    return !t || t.type !== "BindExpression" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(fm, "isBindExpression");
  function hm(t, e) {
    return !t || t.type !== "Decorator" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(hm, "isDecorator");
  function dm(t, e) {
    return !t || t.type !== "DoExpression" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(dm, "isDoExpression");
  function mm(t, e) {
    return !t || t.type !== "ExportDefaultSpecifier" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(mm, "isExportDefaultSpecifier");
  function ym(t, e) {
    return !t || t.type !== "RecordExpression" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(ym, "isRecordExpression");
  function Tm(t, e) {
    return !t || t.type !== "TupleExpression" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Tm, "isTupleExpression");
  function Sm(t, e) {
    return !t || t.type !== "DecimalLiteral" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Sm, "isDecimalLiteral");
  function bm(t, e) {
    return !t || t.type !== "ModuleExpression" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(bm, "isModuleExpression");
  function xm(t, e) {
    return !t || t.type !== "TopicReference" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(xm, "isTopicReference");
  function gm(t, e) {
    return !t || t.type !== "PipelineTopicExpression" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(gm, "isPipelineTopicExpression");
  function Em(t, e) {
    return !t || t.type !== "PipelineBareFunction" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Em, "isPipelineBareFunction");
  function Pm(t, e) {
    return !t || t.type !== "PipelinePrimaryTopicReference" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Pm, "isPipelinePrimaryTopicReference");
  function Am(t, e) {
    return !t || t.type !== "TSParameterProperty" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Am, "isTSParameterProperty");
  function Im(t, e) {
    return !t || t.type !== "TSDeclareFunction" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Im, "isTSDeclareFunction");
  function vm(t, e) {
    return !t || t.type !== "TSDeclareMethod" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(vm, "isTSDeclareMethod");
  function Cm(t, e) {
    return !t || t.type !== "TSQualifiedName" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Cm, "isTSQualifiedName");
  function wm(t, e) {
    return !t || t.type !== "TSCallSignatureDeclaration" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(wm, "isTSCallSignatureDeclaration");
  function Nm(t, e) {
    return !t || t.type !== "TSConstructSignatureDeclaration" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Nm, "isTSConstructSignatureDeclaration");
  function Om(t, e) {
    return !t || t.type !== "TSPropertySignature" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Om, "isTSPropertySignature");
  function _m(t, e) {
    return !t || t.type !== "TSMethodSignature" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(_m, "isTSMethodSignature");
  function Dm(t, e) {
    return !t || t.type !== "TSIndexSignature" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Dm, "isTSIndexSignature");
  function km(t, e) {
    return !t || t.type !== "TSAnyKeyword" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(km, "isTSAnyKeyword");
  function Lm(t, e) {
    return !t || t.type !== "TSBooleanKeyword" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Lm, "isTSBooleanKeyword");
  function Mm(t, e) {
    return !t || t.type !== "TSBigIntKeyword" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Mm, "isTSBigIntKeyword");
  function Bm(t, e) {
    return !t || t.type !== "TSIntrinsicKeyword" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Bm, "isTSIntrinsicKeyword");
  function jm(t, e) {
    return !t || t.type !== "TSNeverKeyword" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(jm, "isTSNeverKeyword");
  function Fm(t, e) {
    return !t || t.type !== "TSNullKeyword" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Fm, "isTSNullKeyword");
  function Rm(t, e) {
    return !t || t.type !== "TSNumberKeyword" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Rm, "isTSNumberKeyword");
  function qm(t, e) {
    return !t || t.type !== "TSObjectKeyword" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(qm, "isTSObjectKeyword");
  function Um(t, e) {
    return !t || t.type !== "TSStringKeyword" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Um, "isTSStringKeyword");
  function Km(t, e) {
    return !t || t.type !== "TSSymbolKeyword" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Km, "isTSSymbolKeyword");
  function Vm(t, e) {
    return !t || t.type !== "TSUndefinedKeyword" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Vm, "isTSUndefinedKeyword");
  function Ym(t, e) {
    return !t || t.type !== "TSUnknownKeyword" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Ym, "isTSUnknownKeyword");
  function Jm(t, e) {
    return !t || t.type !== "TSVoidKeyword" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Jm, "isTSVoidKeyword");
  function Xm(t, e) {
    return !t || t.type !== "TSThisType" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Xm, "isTSThisType");
  function Wm(t, e) {
    return !t || t.type !== "TSFunctionType" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Wm, "isTSFunctionType");
  function $m(t, e) {
    return !t || t.type !== "TSConstructorType" ? !1 : e == null || (0, T.default)(t, e);
  }
  s($m, "isTSConstructorType");
  function zm(t, e) {
    return !t || t.type !== "TSTypeReference" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(zm, "isTSTypeReference");
  function Hm(t, e) {
    return !t || t.type !== "TSTypePredicate" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Hm, "isTSTypePredicate");
  function Gm(t, e) {
    return !t || t.type !== "TSTypeQuery" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Gm, "isTSTypeQuery");
  function Qm(t, e) {
    return !t || t.type !== "TSTypeLiteral" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Qm, "isTSTypeLiteral");
  function Zm(t, e) {
    return !t || t.type !== "TSArrayType" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Zm, "isTSArrayType");
  function ey(t, e) {
    return !t || t.type !== "TSTupleType" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(ey, "isTSTupleType");
  function ty(t, e) {
    return !t || t.type !== "TSOptionalType" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(ty, "isTSOptionalType");
  function ry(t, e) {
    return !t || t.type !== "TSRestType" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(ry, "isTSRestType");
  function iy(t, e) {
    return !t || t.type !== "TSNamedTupleMember" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(iy, "isTSNamedTupleMember");
  function sy(t, e) {
    return !t || t.type !== "TSUnionType" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(sy, "isTSUnionType");
  function ny(t, e) {
    return !t || t.type !== "TSIntersectionType" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(ny, "isTSIntersectionType");
  function ay(t, e) {
    return !t || t.type !== "TSConditionalType" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(ay, "isTSConditionalType");
  function oy(t, e) {
    return !t || t.type !== "TSInferType" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(oy, "isTSInferType");
  function ly(t, e) {
    return !t || t.type !== "TSParenthesizedType" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(ly, "isTSParenthesizedType");
  function uy(t, e) {
    return !t || t.type !== "TSTypeOperator" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(uy, "isTSTypeOperator");
  function cy(t, e) {
    return !t || t.type !== "TSIndexedAccessType" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(cy, "isTSIndexedAccessType");
  function py(t, e) {
    return !t || t.type !== "TSMappedType" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(py, "isTSMappedType");
  function fy(t, e) {
    return !t || t.type !== "TSTemplateLiteralType" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(fy, "isTSTemplateLiteralType");
  function hy(t, e) {
    return !t || t.type !== "TSLiteralType" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(hy, "isTSLiteralType");
  function dy(t, e) {
    return !t || t.type !== "TSExpressionWithTypeArguments" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(dy, "isTSExpressionWithTypeArguments");
  function my(t, e) {
    return !t || t.type !== "TSInterfaceDeclaration" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(my, "isTSInterfaceDeclaration");
  function yy(t, e) {
    return !t || t.type !== "TSInterfaceBody" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(yy, "isTSInterfaceBody");
  function Ty(t, e) {
    return !t || t.type !== "TSTypeAliasDeclaration" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Ty, "isTSTypeAliasDeclaration");
  function Sy(t, e) {
    return !t || t.type !== "TSInstantiationExpression" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Sy, "isTSInstantiationExpression");
  function by(t, e) {
    return !t || t.type !== "TSAsExpression" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(by, "isTSAsExpression");
  function xy(t, e) {
    return !t || t.type !== "TSSatisfiesExpression" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(xy, "isTSSatisfiesExpression");
  function gy(t, e) {
    return !t || t.type !== "TSTypeAssertion" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(gy, "isTSTypeAssertion");
  function Ey(t, e) {
    return !t || t.type !== "TSEnumBody" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Ey, "isTSEnumBody");
  function Py(t, e) {
    return !t || t.type !== "TSEnumDeclaration" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Py, "isTSEnumDeclaration");
  function Ay(t, e) {
    return !t || t.type !== "TSEnumMember" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Ay, "isTSEnumMember");
  function Iy(t, e) {
    return !t || t.type !== "TSModuleDeclaration" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Iy, "isTSModuleDeclaration");
  function vy(t, e) {
    return !t || t.type !== "TSModuleBlock" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(vy, "isTSModuleBlock");
  function Cy(t, e) {
    return !t || t.type !== "TSImportType" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Cy, "isTSImportType");
  function wy(t, e) {
    return !t || t.type !== "TSImportEqualsDeclaration" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(wy, "isTSImportEqualsDeclaration");
  function Ny(t, e) {
    return !t || t.type !== "TSExternalModuleReference" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Ny, "isTSExternalModuleReference");
  function Oy(t, e) {
    return !t || t.type !== "TSNonNullExpression" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Oy, "isTSNonNullExpression");
  function _y(t, e) {
    return !t || t.type !== "TSExportAssignment" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(_y, "isTSExportAssignment");
  function Dy(t, e) {
    return !t || t.type !== "TSNamespaceExportDeclaration" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Dy, "isTSNamespaceExportDeclaration");
  function ky(t, e) {
    return !t || t.type !== "TSTypeAnnotation" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(ky, "isTSTypeAnnotation");
  function Ly(t, e) {
    return !t || t.type !== "TSTypeParameterInstantiation" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(Ly, "isTSTypeParameterInstantiation");
  function My(t, e) {
    return !t || t.type !== "TSTypeParameterDeclaration" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(My, "isTSTypeParameterDeclaration");
  function By(t, e) {
    return !t || t.type !== "TSTypeParameter" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(By, "isTSTypeParameter");
  function jy(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ArrayExpression":
      case "AssignmentExpression":
      case "BinaryExpression":
      case "InterpreterDirective":
      case "Directive":
      case "DirectiveLiteral":
      case "BlockStatement":
      case "BreakStatement":
      case "CallExpression":
      case "CatchClause":
      case "ConditionalExpression":
      case "ContinueStatement":
      case "DebuggerStatement":
      case "DoWhileStatement":
      case "EmptyStatement":
      case "ExpressionStatement":
      case "File":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "Identifier":
      case "IfStatement":
      case "LabeledStatement":
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "LogicalExpression":
      case "MemberExpression":
      case "NewExpression":
      case "Program":
      case "ObjectExpression":
      case "ObjectMethod":
      case "ObjectProperty":
      case "RestElement":
      case "ReturnStatement":
      case "SequenceExpression":
      case "ParenthesizedExpression":
      case "SwitchCase":
      case "SwitchStatement":
      case "ThisExpression":
      case "ThrowStatement":
      case "TryStatement":
      case "UnaryExpression":
      case "UpdateExpression":
      case "VariableDeclaration":
      case "VariableDeclarator":
      case "WhileStatement":
      case "WithStatement":
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ArrowFunctionExpression":
      case "ClassBody":
      case "ClassExpression":
      case "ClassDeclaration":
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ExportSpecifier":
      case "ForOfStatement":
      case "ImportDeclaration":
      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "ImportSpecifier":
      case "ImportExpression":
      case "MetaProperty":
      case "ClassMethod":
      case "ObjectPattern":
      case "SpreadElement":
      case "Super":
      case "TaggedTemplateExpression":
      case "TemplateElement":
      case "TemplateLiteral":
      case "YieldExpression":
      case "AwaitExpression":
      case "Import":
      case "BigIntLiteral":
      case "ExportNamespaceSpecifier":
      case "OptionalMemberExpression":
      case "OptionalCallExpression":
      case "ClassProperty":
      case "ClassAccessorProperty":
      case "ClassPrivateProperty":
      case "ClassPrivateMethod":
      case "PrivateName":
      case "StaticBlock":
      case "ImportAttribute":
        break;
      case "Placeholder":
        switch (t.expectedNode) {
          case "Identifier":
          case "StringLiteral":
          case "BlockStatement":
          case "ClassBody":
            break;
          default:
            return !1;
        }
        break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(jy, "isStandardized");
  function Fy(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ArrayExpression":
      case "AssignmentExpression":
      case "BinaryExpression":
      case "CallExpression":
      case "ConditionalExpression":
      case "FunctionExpression":
      case "Identifier":
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "LogicalExpression":
      case "MemberExpression":
      case "NewExpression":
      case "ObjectExpression":
      case "SequenceExpression":
      case "ParenthesizedExpression":
      case "ThisExpression":
      case "UnaryExpression":
      case "UpdateExpression":
      case "ArrowFunctionExpression":
      case "ClassExpression":
      case "ImportExpression":
      case "MetaProperty":
      case "Super":
      case "TaggedTemplateExpression":
      case "TemplateLiteral":
      case "YieldExpression":
      case "AwaitExpression":
      case "Import":
      case "BigIntLiteral":
      case "OptionalMemberExpression":
      case "OptionalCallExpression":
      case "TypeCastExpression":
      case "JSXElement":
      case "JSXFragment":
      case "BindExpression":
      case "DoExpression":
      case "RecordExpression":
      case "TupleExpression":
      case "DecimalLiteral":
      case "ModuleExpression":
      case "TopicReference":
      case "PipelineTopicExpression":
      case "PipelineBareFunction":
      case "PipelinePrimaryTopicReference":
      case "TSInstantiationExpression":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSNonNullExpression":
        break;
      case "Placeholder":
        switch (t.expectedNode) {
          case "Expression":
          case "Identifier":
          case "StringLiteral":
            break;
          default:
            return !1;
        }
        break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(Fy, "isExpression");
  function Ry(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "BinaryExpression":
      case "LogicalExpression":
        break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(Ry, "isBinary");
  function qy(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "BlockStatement":
      case "CatchClause":
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "Program":
      case "ObjectMethod":
      case "SwitchStatement":
      case "WhileStatement":
      case "ArrowFunctionExpression":
      case "ClassExpression":
      case "ClassDeclaration":
      case "ForOfStatement":
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "StaticBlock":
      case "TSModuleBlock":
        break;
      case "Placeholder":
        if (t.expectedNode === "BlockStatement") break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(qy, "isScopable");
  function Uy(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "BlockStatement":
      case "CatchClause":
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "Program":
      case "ObjectMethod":
      case "SwitchStatement":
      case "WhileStatement":
      case "ArrowFunctionExpression":
      case "ForOfStatement":
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "StaticBlock":
      case "TSModuleBlock":
        break;
      case "Placeholder":
        if (t.expectedNode === "BlockStatement") break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(Uy, "isBlockParent");
  function Ky(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "BlockStatement":
      case "Program":
      case "TSModuleBlock":
        break;
      case "Placeholder":
        if (t.expectedNode === "BlockStatement") break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(Ky, "isBlock");
  function Vy(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "BlockStatement":
      case "BreakStatement":
      case "ContinueStatement":
      case "DebuggerStatement":
      case "DoWhileStatement":
      case "EmptyStatement":
      case "ExpressionStatement":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "IfStatement":
      case "LabeledStatement":
      case "ReturnStatement":
      case "SwitchStatement":
      case "ThrowStatement":
      case "TryStatement":
      case "VariableDeclaration":
      case "WhileStatement":
      case "WithStatement":
      case "ClassDeclaration":
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ForOfStatement":
      case "ImportDeclaration":
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "InterfaceDeclaration":
      case "OpaqueType":
      case "TypeAlias":
      case "EnumDeclaration":
      case "TSDeclareFunction":
      case "TSInterfaceDeclaration":
      case "TSTypeAliasDeclaration":
      case "TSEnumDeclaration":
      case "TSModuleDeclaration":
      case "TSImportEqualsDeclaration":
      case "TSExportAssignment":
      case "TSNamespaceExportDeclaration":
        break;
      case "Placeholder":
        switch (t.expectedNode) {
          case "Statement":
          case "Declaration":
          case "BlockStatement":
            break;
          default:
            return !1;
        }
        break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(Vy, "isStatement");
  function Yy(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "BreakStatement":
      case "ContinueStatement":
      case "ReturnStatement":
      case "ThrowStatement":
      case "YieldExpression":
      case "AwaitExpression":
        break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(Yy, "isTerminatorless");
  function Jy(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "BreakStatement":
      case "ContinueStatement":
      case "ReturnStatement":
      case "ThrowStatement":
        break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(Jy, "isCompletionStatement");
  function Xy(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ConditionalExpression":
      case "IfStatement":
        break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(Xy, "isConditional");
  function Wy(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForStatement":
      case "WhileStatement":
      case "ForOfStatement":
        break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(Wy, "isLoop");
  function $y(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "DoWhileStatement":
      case "WhileStatement":
        break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s($y, "isWhile");
  function zy(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ExpressionStatement":
      case "ParenthesizedExpression":
      case "TypeCastExpression":
        break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(zy, "isExpressionWrapper");
  function Hy(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ForInStatement":
      case "ForStatement":
      case "ForOfStatement":
        break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(Hy, "isFor");
  function Gy(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ForInStatement":
      case "ForOfStatement":
        break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(Gy, "isForXStatement");
  function Qy(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "ObjectMethod":
      case "ArrowFunctionExpression":
      case "ClassMethod":
      case "ClassPrivateMethod":
        break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(Qy, "isFunction");
  function Zy(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "ObjectMethod":
      case "ArrowFunctionExpression":
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "StaticBlock":
      case "TSModuleBlock":
        break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(Zy, "isFunctionParent");
  function eT(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "ArrowFunctionExpression":
      case "BigIntLiteral":
      case "DecimalLiteral":
        break;
      case "Placeholder":
        if (t.expectedNode === "StringLiteral") break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(eT, "isPureish");
  function tT(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "FunctionDeclaration":
      case "VariableDeclaration":
      case "ClassDeclaration":
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ImportDeclaration":
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "InterfaceDeclaration":
      case "OpaqueType":
      case "TypeAlias":
      case "EnumDeclaration":
      case "TSDeclareFunction":
      case "TSInterfaceDeclaration":
      case "TSTypeAliasDeclaration":
      case "TSEnumDeclaration":
      case "TSModuleDeclaration":
      case "TSImportEqualsDeclaration":
        break;
      case "Placeholder":
        if (t.expectedNode === "Declaration") break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(tT, "isDeclaration");
  function rT(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "Identifier":
      case "RestElement":
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ObjectPattern":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSNonNullExpression":
        break;
      case "Placeholder":
        switch (t.expectedNode) {
          case "Pattern":
          case "Identifier":
            break;
          default:
            return !1;
        }
        break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(rT, "isPatternLike");
  function iT(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "Identifier":
      case "MemberExpression":
      case "RestElement":
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ObjectPattern":
      case "TSParameterProperty":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSNonNullExpression":
        break;
      case "Placeholder":
        switch (t.expectedNode) {
          case "Pattern":
          case "Identifier":
            break;
          default:
            return !1;
        }
        break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(iT, "isLVal");
  function sT(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "Identifier":
      case "TSQualifiedName":
        break;
      case "Placeholder":
        if (t.expectedNode === "Identifier") break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(sT, "isTSEntityName");
  function nT(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "TemplateLiteral":
      case "BigIntLiteral":
      case "DecimalLiteral":
        break;
      case "Placeholder":
        if (t.expectedNode === "StringLiteral") break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(nT, "isLiteral");
  function aT(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "BigIntLiteral":
      case "JSXAttribute":
      case "JSXClosingElement":
      case "JSXElement":
      case "JSXExpressionContainer":
      case "JSXSpreadChild":
      case "JSXOpeningElement":
      case "JSXText":
      case "JSXFragment":
      case "JSXOpeningFragment":
      case "JSXClosingFragment":
      case "DecimalLiteral":
        break;
      case "Placeholder":
        if (t.expectedNode === "StringLiteral") break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(aT, "isImmutable");
  function oT(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ObjectMethod":
      case "ObjectProperty":
      case "ObjectTypeInternalSlot":
      case "ObjectTypeCallProperty":
      case "ObjectTypeIndexer":
      case "ObjectTypeProperty":
      case "ObjectTypeSpreadProperty":
        break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(oT, "isUserWhitespacable");
  function lT(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ObjectMethod":
      case "ClassMethod":
      case "ClassPrivateMethod":
        break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(lT, "isMethod");
  function uT(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ObjectMethod":
      case "ObjectProperty":
        break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(uT, "isObjectMember");
  function cT(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ObjectProperty":
      case "ClassProperty":
      case "ClassAccessorProperty":
      case "ClassPrivateProperty":
        break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(cT, "isProperty");
  function pT(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "UnaryExpression":
      case "SpreadElement":
        break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(pT, "isUnaryLike");
  function fT(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ObjectPattern":
        break;
      case "Placeholder":
        if (t.expectedNode === "Pattern") break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(fT, "isPattern");
  function hT(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ClassExpression":
      case "ClassDeclaration":
        break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(hT, "isClass");
  function Qo(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ImportDeclaration":
        break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(Qo, "isImportOrExportDeclaration");
  function dT(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
        break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(dT, "isExportDeclaration");
  function mT(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ExportSpecifier":
      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "ImportSpecifier":
      case "ExportNamespaceSpecifier":
      case "ExportDefaultSpecifier":
        break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(mT, "isModuleSpecifier");
  function yT(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ClassAccessorProperty":
        break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(yT, "isAccessor");
  function TT(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ClassPrivateProperty":
      case "ClassPrivateMethod":
      case "PrivateName":
        break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(TT, "isPrivate");
  function ST(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "AnyTypeAnnotation":
      case "ArrayTypeAnnotation":
      case "BooleanTypeAnnotation":
      case "BooleanLiteralTypeAnnotation":
      case "NullLiteralTypeAnnotation":
      case "ClassImplements":
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "DeclaredPredicate":
      case "ExistsTypeAnnotation":
      case "FunctionTypeAnnotation":
      case "FunctionTypeParam":
      case "GenericTypeAnnotation":
      case "InferredPredicate":
      case "InterfaceExtends":
      case "InterfaceDeclaration":
      case "InterfaceTypeAnnotation":
      case "IntersectionTypeAnnotation":
      case "MixedTypeAnnotation":
      case "EmptyTypeAnnotation":
      case "NullableTypeAnnotation":
      case "NumberLiteralTypeAnnotation":
      case "NumberTypeAnnotation":
      case "ObjectTypeAnnotation":
      case "ObjectTypeInternalSlot":
      case "ObjectTypeCallProperty":
      case "ObjectTypeIndexer":
      case "ObjectTypeProperty":
      case "ObjectTypeSpreadProperty":
      case "OpaqueType":
      case "QualifiedTypeIdentifier":
      case "StringLiteralTypeAnnotation":
      case "StringTypeAnnotation":
      case "SymbolTypeAnnotation":
      case "ThisTypeAnnotation":
      case "TupleTypeAnnotation":
      case "TypeofTypeAnnotation":
      case "TypeAlias":
      case "TypeAnnotation":
      case "TypeCastExpression":
      case "TypeParameter":
      case "TypeParameterDeclaration":
      case "TypeParameterInstantiation":
      case "UnionTypeAnnotation":
      case "Variance":
      case "VoidTypeAnnotation":
      case "EnumDeclaration":
      case "EnumBooleanBody":
      case "EnumNumberBody":
      case "EnumStringBody":
      case "EnumSymbolBody":
      case "EnumBooleanMember":
      case "EnumNumberMember":
      case "EnumStringMember":
      case "EnumDefaultedMember":
      case "IndexedAccessType":
      case "OptionalIndexedAccessType":
        break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(ST, "isFlow");
  function bT(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "AnyTypeAnnotation":
      case "ArrayTypeAnnotation":
      case "BooleanTypeAnnotation":
      case "BooleanLiteralTypeAnnotation":
      case "NullLiteralTypeAnnotation":
      case "ExistsTypeAnnotation":
      case "FunctionTypeAnnotation":
      case "GenericTypeAnnotation":
      case "InterfaceTypeAnnotation":
      case "IntersectionTypeAnnotation":
      case "MixedTypeAnnotation":
      case "EmptyTypeAnnotation":
      case "NullableTypeAnnotation":
      case "NumberLiteralTypeAnnotation":
      case "NumberTypeAnnotation":
      case "ObjectTypeAnnotation":
      case "StringLiteralTypeAnnotation":
      case "StringTypeAnnotation":
      case "SymbolTypeAnnotation":
      case "ThisTypeAnnotation":
      case "TupleTypeAnnotation":
      case "TypeofTypeAnnotation":
      case "UnionTypeAnnotation":
      case "VoidTypeAnnotation":
      case "IndexedAccessType":
      case "OptionalIndexedAccessType":
        break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(bT, "isFlowType");
  function xT(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "AnyTypeAnnotation":
      case "BooleanTypeAnnotation":
      case "NullLiteralTypeAnnotation":
      case "MixedTypeAnnotation":
      case "EmptyTypeAnnotation":
      case "NumberTypeAnnotation":
      case "StringTypeAnnotation":
      case "SymbolTypeAnnotation":
      case "ThisTypeAnnotation":
      case "VoidTypeAnnotation":
        break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(xT, "isFlowBaseAnnotation");
  function gT(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "InterfaceDeclaration":
      case "OpaqueType":
      case "TypeAlias":
        break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(gT, "isFlowDeclaration");
  function ET(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "DeclaredPredicate":
      case "InferredPredicate":
        break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(ET, "isFlowPredicate");
  function PT(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "EnumBooleanBody":
      case "EnumNumberBody":
      case "EnumStringBody":
      case "EnumSymbolBody":
        break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(PT, "isEnumBody");
  function AT(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "EnumBooleanMember":
      case "EnumNumberMember":
      case "EnumStringMember":
      case "EnumDefaultedMember":
        break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(AT, "isEnumMember");
  function IT(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "JSXAttribute":
      case "JSXClosingElement":
      case "JSXElement":
      case "JSXEmptyExpression":
      case "JSXExpressionContainer":
      case "JSXSpreadChild":
      case "JSXIdentifier":
      case "JSXMemberExpression":
      case "JSXNamespacedName":
      case "JSXOpeningElement":
      case "JSXSpreadAttribute":
      case "JSXText":
      case "JSXFragment":
      case "JSXOpeningFragment":
      case "JSXClosingFragment":
        break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(IT, "isJSX");
  function vT(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "Noop":
      case "Placeholder":
      case "V8IntrinsicIdentifier":
        break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(vT, "isMiscellaneous");
  function CT(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "TSParameterProperty":
      case "TSDeclareFunction":
      case "TSDeclareMethod":
      case "TSQualifiedName":
      case "TSCallSignatureDeclaration":
      case "TSConstructSignatureDeclaration":
      case "TSPropertySignature":
      case "TSMethodSignature":
      case "TSIndexSignature":
      case "TSAnyKeyword":
      case "TSBooleanKeyword":
      case "TSBigIntKeyword":
      case "TSIntrinsicKeyword":
      case "TSNeverKeyword":
      case "TSNullKeyword":
      case "TSNumberKeyword":
      case "TSObjectKeyword":
      case "TSStringKeyword":
      case "TSSymbolKeyword":
      case "TSUndefinedKeyword":
      case "TSUnknownKeyword":
      case "TSVoidKeyword":
      case "TSThisType":
      case "TSFunctionType":
      case "TSConstructorType":
      case "TSTypeReference":
      case "TSTypePredicate":
      case "TSTypeQuery":
      case "TSTypeLiteral":
      case "TSArrayType":
      case "TSTupleType":
      case "TSOptionalType":
      case "TSRestType":
      case "TSNamedTupleMember":
      case "TSUnionType":
      case "TSIntersectionType":
      case "TSConditionalType":
      case "TSInferType":
      case "TSParenthesizedType":
      case "TSTypeOperator":
      case "TSIndexedAccessType":
      case "TSMappedType":
      case "TSTemplateLiteralType":
      case "TSLiteralType":
      case "TSExpressionWithTypeArguments":
      case "TSInterfaceDeclaration":
      case "TSInterfaceBody":
      case "TSTypeAliasDeclaration":
      case "TSInstantiationExpression":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSEnumBody":
      case "TSEnumDeclaration":
      case "TSEnumMember":
      case "TSModuleDeclaration":
      case "TSModuleBlock":
      case "TSImportType":
      case "TSImportEqualsDeclaration":
      case "TSExternalModuleReference":
      case "TSNonNullExpression":
      case "TSExportAssignment":
      case "TSNamespaceExportDeclaration":
      case "TSTypeAnnotation":
      case "TSTypeParameterInstantiation":
      case "TSTypeParameterDeclaration":
      case "TSTypeParameter":
        break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(CT, "isTypeScript");
  function wT(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "TSCallSignatureDeclaration":
      case "TSConstructSignatureDeclaration":
      case "TSPropertySignature":
      case "TSMethodSignature":
      case "TSIndexSignature":
        break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(wT, "isTSTypeElement");
  function NT(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "TSAnyKeyword":
      case "TSBooleanKeyword":
      case "TSBigIntKeyword":
      case "TSIntrinsicKeyword":
      case "TSNeverKeyword":
      case "TSNullKeyword":
      case "TSNumberKeyword":
      case "TSObjectKeyword":
      case "TSStringKeyword":
      case "TSSymbolKeyword":
      case "TSUndefinedKeyword":
      case "TSUnknownKeyword":
      case "TSVoidKeyword":
      case "TSThisType":
      case "TSFunctionType":
      case "TSConstructorType":
      case "TSTypeReference":
      case "TSTypePredicate":
      case "TSTypeQuery":
      case "TSTypeLiteral":
      case "TSArrayType":
      case "TSTupleType":
      case "TSOptionalType":
      case "TSRestType":
      case "TSUnionType":
      case "TSIntersectionType":
      case "TSConditionalType":
      case "TSInferType":
      case "TSParenthesizedType":
      case "TSTypeOperator":
      case "TSIndexedAccessType":
      case "TSMappedType":
      case "TSTemplateLiteralType":
      case "TSLiteralType":
      case "TSExpressionWithTypeArguments":
      case "TSImportType":
        break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(NT, "isTSType");
  function OT(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "TSAnyKeyword":
      case "TSBooleanKeyword":
      case "TSBigIntKeyword":
      case "TSIntrinsicKeyword":
      case "TSNeverKeyword":
      case "TSNullKeyword":
      case "TSNumberKeyword":
      case "TSObjectKeyword":
      case "TSStringKeyword":
      case "TSSymbolKeyword":
      case "TSUndefinedKeyword":
      case "TSUnknownKeyword":
      case "TSVoidKeyword":
      case "TSThisType":
      case "TSTemplateLiteralType":
      case "TSLiteralType":
        break;
      default:
        return !1;
    }
    return e == null || (0, T.default)(t, e);
  }
  s(OT, "isTSBaseType");
  function _T(t, e) {
    return (0, vr.default)("isNumberLiteral", "isNumericLiteral"), !t || t.type !== "NumberLiteral" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(_T, "isNumberLiteral");
  function DT(t, e) {
    return (0, vr.default)("isRegexLiteral", "isRegExpLiteral"), !t || t.type !== "RegexLiteral" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(DT, "isRegexLiteral");
  function kT(t, e) {
    return (0, vr.default)("isRestProperty", "isRestElement"), !t || t.type !== "RestProperty" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(kT, "isRestProperty");
  function LT(t, e) {
    return (0, vr.default)("isSpreadProperty", "isSpreadElement"), !t || t.type !== "SpreadProperty" ? !1 : e == null || (0, T.default)(t, e);
  }
  s(LT, "isSpreadProperty");
  function MT(t, e) {
    return (0, vr.default)("isModuleDeclaration", "isImportOrExportDeclaration"), Qo(t, e);
  }
  s(MT, "isModuleDeclaration");
});

// ../node_modules/@babel/types/lib/validators/matchesPattern.js
var Ps = D((Es) => {
  "use strict";
  Object.defineProperty(Es, "__esModule", {
    value: !0
  });
  Es.default = BT;
  var Cr = Be();
  function BT(t, e, r) {
    if (!(0, Cr.isMemberExpression)(t)) return !1;
    let i = Array.isArray(e) ? e : e.split("."), n = [], a;
    for (a = t; (0, Cr.isMemberExpression)(a); a = a.object)
      n.push(a.property);
    if (n.push(a), n.length < i.length || !r && n.length > i.length) return !1;
    for (let o = 0, l = n.length - 1; o < i.length; o++, l--) {
      let u = n[l], p;
      if ((0, Cr.isIdentifier)(u))
        p = u.name;
      else if ((0, Cr.isStringLiteral)(u))
        p = u.value;
      else if ((0, Cr.isThisExpression)(u))
        p = "this";
      else
        return !1;
      if (i[o] !== p) return !1;
    }
    return !0;
  }
  s(BT, "matchesPattern");
});

// ../node_modules/@babel/types/lib/validators/buildMatchMemberExpression.js
var Is = D((As) => {
  "use strict";
  Object.defineProperty(As, "__esModule", {
    value: !0
  });
  As.default = FT;
  var jT = Ps();
  function FT(t, e) {
    let r = t.split(".");
    return (i) => (0, jT.default)(i, r, e);
  }
  s(FT, "buildMatchMemberExpression");
});

// ../node_modules/@babel/types/lib/validators/react/isReactComponent.js
var Zo = D((yi) => {
  "use strict";
  Object.defineProperty(yi, "__esModule", {
    value: !0
  });
  yi.default = void 0;
  var RT = Is(), qT = (0, RT.default)("React.Component"), jj = yi.default = qT;
});

// ../node_modules/@babel/types/lib/validators/react/isCompatTag.js
var el = D((vs) => {
  "use strict";
  Object.defineProperty(vs, "__esModule", {
    value: !0
  });
  vs.default = UT;
  function UT(t) {
    return !!t && /^[a-z]/.test(t);
  }
  s(UT, "isCompatTag");
});

// ../node_modules/@babel/types/lib/validators/isType.js
var Ti = D((Cs) => {
  "use strict";
  Object.defineProperty(Cs, "__esModule", {
    value: !0
  });
  Cs.default = KT;
  var tl = ot();
  function KT(t, e) {
    if (t === e) return !0;
    if (t == null || tl.ALIAS_KEYS[e]) return !1;
    let r = tl.FLIPPED_ALIAS_KEYS[e];
    return !!(r != null && r.includes(t));
  }
  s(KT, "isType");
});

// ../node_modules/@babel/types/lib/validators/isPlaceholderType.js
var Ns = D((ws) => {
  "use strict";
  Object.defineProperty(ws, "__esModule", {
    value: !0
  });
  ws.default = YT;
  var VT = ot();
  function YT(t, e) {
    if (t === e) return !0;
    let r = VT.PLACEHOLDERS_ALIAS[t];
    return !!(r != null && r.includes(e));
  }
  s(YT, "isPlaceholderType");
});

// ../node_modules/@babel/types/lib/validators/is.js
var sr = D((Os) => {
  "use strict";
  Object.defineProperty(Os, "__esModule", {
    value: !0
  });
  Os.default = zT;
  var JT = mi(), XT = Ti(), WT = Ns(), $T = ot();
  function zT(t, e, r) {
    return e ? (0, XT.default)(e.type, t) ? r === void 0 ? !0 : (0, JT.default)(e, r) : !r && e.type === "Placeholder" && t in $T.FLIPPED_ALIAS_KEYS ?
    (0, WT.default)(e.expectedNode, t) : !1 : !1;
  }
  s(zT, "is");
});

// ../node_modules/@babel/helper-validator-identifier/lib/identifier.js
var al = D((wr) => {
  "use strict";
  Object.defineProperty(wr, "__esModule", {
    value: !0
  });
  wr.isIdentifierChar = nl;
  wr.isIdentifierName = ZT;
  wr.isIdentifierStart = sl;
  var Ds = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993\
-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\
\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\
\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\
\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\
\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CD\uA7D0\uA7D1\uA7D3\uA7D5-\uA7DC\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01\
-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC",
  rl = "\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\
\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\
\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6\
-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20\
-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65", HT = new RegExp("[" + Ds + "]"), GT = new RegExp("[" + Ds + rl + "]");
  Ds = rl = null;
  var il = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157,
  19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5,
  3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7,
  2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 2, 60, 28, 11, 0, 9, 21, 43, 17,
  47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64,
  6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45,
  52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2,
  1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29,
  113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071,
  18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 129, 74, 6, 0, 67, 12,
  65, 1, 2, 0, 29, 6135, 9, 1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991,
  84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30,
  2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3,
  0, 496, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2,
  2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153,
  7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191], QT = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0,
  166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2,
  9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68,
  8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14,
  5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 343, 9, 54, 7, 2,
  7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0,
  7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4,
  4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10,
  9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 726, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
  function _s(t, e) {
    let r = 65536;
    for (let i = 0, n = e.length; i < n; i += 2) {
      if (r += e[i], r > t) return !1;
      if (r += e[i + 1], r >= t) return !0;
    }
    return !1;
  }
  s(_s, "isInAstralSet");
  function sl(t) {
    return t < 65 ? t === 36 : t <= 90 ? !0 : t < 97 ? t === 95 : t <= 122 ? !0 : t <= 65535 ? t >= 170 && HT.test(String.fromCharCode(t)) :
    _s(t, il);
  }
  s(sl, "isIdentifierStart");
  function nl(t) {
    return t < 48 ? t === 36 : t < 58 ? !0 : t < 65 ? !1 : t <= 90 ? !0 : t < 97 ? t === 95 : t <= 122 ? !0 : t <= 65535 ? t >= 170 && GT.test(
    String.fromCharCode(t)) : _s(t, il) || _s(t, QT);
  }
  s(nl, "isIdentifierChar");
  function ZT(t) {
    let e = !0;
    for (let r = 0; r < t.length; r++) {
      let i = t.charCodeAt(r);
      if ((i & 64512) === 55296 && r + 1 < t.length) {
        let n = t.charCodeAt(++r);
        (n & 64512) === 56320 && (i = 65536 + ((i & 1023) << 10) + (n & 1023));
      }
      if (e) {
        if (e = !1, !sl(i))
          return !1;
      } else if (!nl(i))
        return !1;
    }
    return !e;
  }
  s(ZT, "isIdentifierName");
});

// ../node_modules/@babel/helper-validator-identifier/lib/keyword.js
var cl = D((Xt) => {
  "use strict";
  Object.defineProperty(Xt, "__esModule", {
    value: !0
  });
  Xt.isKeyword = sS;
  Xt.isReservedWord = ol;
  Xt.isStrictBindOnlyReservedWord = ul;
  Xt.isStrictBindReservedWord = iS;
  Xt.isStrictReservedWord = ll;
  var ks = {
    keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "swit\
ch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false",
    "in", "instanceof", "typeof", "void", "delete"],
    strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
    strictBind: ["eval", "arguments"]
  }, eS = new Set(ks.keyword), tS = new Set(ks.strict), rS = new Set(ks.strictBind);
  function ol(t, e) {
    return e && t === "await" || t === "enum";
  }
  s(ol, "isReservedWord");
  function ll(t, e) {
    return ol(t, e) || tS.has(t);
  }
  s(ll, "isStrictReservedWord");
  function ul(t) {
    return rS.has(t);
  }
  s(ul, "isStrictBindOnlyReservedWord");
  function iS(t, e) {
    return ll(t, e) || ul(t);
  }
  s(iS, "isStrictBindReservedWord");
  function sS(t) {
    return eS.has(t);
  }
  s(sS, "isKeyword");
});

// ../node_modules/@babel/helper-validator-identifier/lib/index.js
var Si = D((St) => {
  "use strict";
  Object.defineProperty(St, "__esModule", {
    value: !0
  });
  Object.defineProperty(St, "isIdentifierChar", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Ls.isIdentifierChar;
    }, "get")
  });
  Object.defineProperty(St, "isIdentifierName", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Ls.isIdentifierName;
    }, "get")
  });
  Object.defineProperty(St, "isIdentifierStart", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Ls.isIdentifierStart;
    }, "get")
  });
  Object.defineProperty(St, "isKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Nr.isKeyword;
    }, "get")
  });
  Object.defineProperty(St, "isReservedWord", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Nr.isReservedWord;
    }, "get")
  });
  Object.defineProperty(St, "isStrictBindOnlyReservedWord", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Nr.isStrictBindOnlyReservedWord;
    }, "get")
  });
  Object.defineProperty(St, "isStrictBindReservedWord", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Nr.isStrictBindReservedWord;
    }, "get")
  });
  Object.defineProperty(St, "isStrictReservedWord", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Nr.isStrictReservedWord;
    }, "get")
  });
  var Ls = al(), Nr = cl();
});

// ../node_modules/@babel/types/lib/validators/isValidIdentifier.js
var nr = D((Bs) => {
  "use strict";
  Object.defineProperty(Bs, "__esModule", {
    value: !0
  });
  Bs.default = nS;
  var Ms = Si();
  function nS(t, e = !0) {
    return typeof t != "string" || e && ((0, Ms.isKeyword)(t) || (0, Ms.isStrictReservedWord)(t, !0)) ? !1 : (0, Ms.isIdentifierName)(t);
  }
  s(nS, "isValidIdentifier");
});

// ../node_modules/@babel/helper-string-parser/lib/index.js
var dl = D((Or) => {
  "use strict";
  Object.defineProperty(Or, "__esModule", {
    value: !0
  });
  Or.readCodePoint = hl;
  Or.readInt = fl;
  Or.readStringContents = oS;
  var aS = /* @__PURE__ */ s(function(e) {
    return e >= 48 && e <= 57;
  }, "isDigit"), pl = {
    decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]),
    hex: /* @__PURE__ */ new Set([46, 88, 95, 120])
  }, bi = {
    bin: /* @__PURE__ */ s((t) => t === 48 || t === 49, "bin"),
    oct: /* @__PURE__ */ s((t) => t >= 48 && t <= 55, "oct"),
    dec: /* @__PURE__ */ s((t) => t >= 48 && t <= 57, "dec"),
    hex: /* @__PURE__ */ s((t) => t >= 48 && t <= 57 || t >= 65 && t <= 70 || t >= 97 && t <= 102, "hex")
  };
  function oS(t, e, r, i, n, a) {
    let o = r, l = i, u = n, p = "", h = null, E = r, {
      length: I
    } = e;
    for (; ; ) {
      if (r >= I) {
        a.unterminated(o, l, u), p += e.slice(E, r);
        break;
      }
      let v = e.charCodeAt(r);
      if (lS(t, v, e, r)) {
        p += e.slice(E, r);
        break;
      }
      if (v === 92) {
        p += e.slice(E, r);
        let _ = uS(e, r, i, n, t === "template", a);
        _.ch === null && !h ? h = {
          pos: r,
          lineStart: i,
          curLine: n
        } : p += _.ch, {
          pos: r,
          lineStart: i,
          curLine: n
        } = _, E = r;
      } else v === 8232 || v === 8233 ? (++r, ++n, i = r) : v === 10 || v === 13 ? t === "template" ? (p += e.slice(E, r) + `
`, ++r, v === 13 && e.charCodeAt(r) === 10 && ++r, ++n, E = i = r) : a.unterminated(o, l, u) : ++r;
    }
    return {
      pos: r,
      str: p,
      firstInvalidLoc: h,
      lineStart: i,
      curLine: n,
      containsInvalid: !!h
    };
  }
  s(oS, "readStringContents");
  function lS(t, e, r, i) {
    return t === "template" ? e === 96 || e === 36 && r.charCodeAt(i + 1) === 123 : e === (t === "double" ? 34 : 39);
  }
  s(lS, "isStringEnd");
  function uS(t, e, r, i, n, a) {
    let o = !n;
    e++;
    let l = /* @__PURE__ */ s((p) => ({
      pos: e,
      ch: p,
      lineStart: r,
      curLine: i
    }), "res"), u = t.charCodeAt(e++);
    switch (u) {
      case 110:
        return l(`
`);
      case 114:
        return l("\r");
      case 120: {
        let p;
        return {
          code: p,
          pos: e
        } = js(t, e, r, i, 2, !1, o, a), l(p === null ? null : String.fromCharCode(p));
      }
      case 117: {
        let p;
        return {
          code: p,
          pos: e
        } = hl(t, e, r, i, o, a), l(p === null ? null : String.fromCodePoint(p));
      }
      case 116:
        return l("	");
      case 98:
        return l("\b");
      case 118:
        return l("\v");
      case 102:
        return l("\f");
      case 13:
        t.charCodeAt(e) === 10 && ++e;
      case 10:
        r = e, ++i;
      case 8232:
      case 8233:
        return l("");
      case 56:
      case 57:
        if (n)
          return l(null);
        a.strictNumericEscape(e - 1, r, i);
      default:
        if (u >= 48 && u <= 55) {
          let p = e - 1, E = /^[0-7]+/.exec(t.slice(p, e + 2))[0], I = parseInt(E, 8);
          I > 255 && (E = E.slice(0, -1), I = parseInt(E, 8)), e += E.length - 1;
          let v = t.charCodeAt(e);
          if (E !== "0" || v === 56 || v === 57) {
            if (n)
              return l(null);
            a.strictNumericEscape(p, r, i);
          }
          return l(String.fromCharCode(I));
        }
        return l(String.fromCharCode(u));
    }
  }
  s(uS, "readEscapedChar");
  function js(t, e, r, i, n, a, o, l) {
    let u = e, p;
    return {
      n: p,
      pos: e
    } = fl(t, e, r, i, 16, n, a, !1, l, !o), p === null && (o ? l.invalidEscapeSequence(u, r, i) : e = u - 1), {
      code: p,
      pos: e
    };
  }
  s(js, "readHexChar");
  function fl(t, e, r, i, n, a, o, l, u, p) {
    let h = e, E = n === 16 ? pl.hex : pl.decBinOct, I = n === 16 ? bi.hex : n === 10 ? bi.dec : n === 8 ? bi.oct : bi.bin, v = !1, _ = 0;
    for (let j = 0, O = a ?? 1 / 0; j < O; ++j) {
      let k = t.charCodeAt(e), B;
      if (k === 95 && l !== "bail") {
        let ue = t.charCodeAt(e - 1), K = t.charCodeAt(e + 1);
        if (l) {
          if (Number.isNaN(K) || !I(K) || E.has(ue) || E.has(K)) {
            if (p) return {
              n: null,
              pos: e
            };
            u.unexpectedNumericSeparator(e, r, i);
          }
        } else {
          if (p) return {
            n: null,
            pos: e
          };
          u.numericSeparatorInEscapeSequence(e, r, i);
        }
        ++e;
        continue;
      }
      if (k >= 97 ? B = k - 97 + 10 : k >= 65 ? B = k - 65 + 10 : aS(k) ? B = k - 48 : B = 1 / 0, B >= n) {
        if (B <= 9 && p)
          return {
            n: null,
            pos: e
          };
        if (B <= 9 && u.invalidDigit(e, r, i, n))
          B = 0;
        else if (o)
          B = 0, v = !0;
        else
          break;
      }
      ++e, _ = _ * n + B;
    }
    return e === h || a != null && e - h !== a || v ? {
      n: null,
      pos: e
    } : {
      n: _,
      pos: e
    };
  }
  s(fl, "readInt");
  function hl(t, e, r, i, n, a) {
    let o = t.charCodeAt(e), l;
    if (o === 123) {
      if (++e, {
        code: l,
        pos: e
      } = js(t, e, r, i, t.indexOf("}", e) - e, !0, n, a), ++e, l !== null && l > 1114111)
        if (n)
          a.invalidCodePoint(e, r, i);
        else
          return {
            code: null,
            pos: e
          };
    } else
      ({
        code: l,
        pos: e
      } = js(t, e, r, i, 4, !1, n, a));
    return {
      code: l,
      pos: e
    };
  }
  s(hl, "readCodePoint");
});

// ../node_modules/@babel/types/lib/constants/index.js
var ar = D((de) => {
  "use strict";
  Object.defineProperty(de, "__esModule", {
    value: !0
  });
  de.UPDATE_OPERATORS = de.UNARY_OPERATORS = de.STRING_UNARY_OPERATORS = de.STATEMENT_OR_BLOCK_KEYS = de.NUMBER_UNARY_OPERATORS = de.NUMBER_BINARY_OPERATORS =
  de.LOGICAL_OPERATORS = de.INHERIT_KEYS = de.FOR_INIT_KEYS = de.FLATTENABLE_KEYS = de.EQUALITY_BINARY_OPERATORS = de.COMPARISON_BINARY_OPERATORS =
  de.COMMENT_KEYS = de.BOOLEAN_UNARY_OPERATORS = de.BOOLEAN_NUMBER_BINARY_OPERATORS = de.BOOLEAN_BINARY_OPERATORS = de.BINARY_OPERATORS = de.
  ASSIGNMENT_OPERATORS = void 0;
  var iF = de.STATEMENT_OR_BLOCK_KEYS = ["consequent", "body", "alternate"], sF = de.FLATTENABLE_KEYS = ["body", "expressions"], nF = de.FOR_INIT_KEYS =
  ["left", "init"], aF = de.COMMENT_KEYS = ["leadingComments", "trailingComments", "innerComments"], cS = de.LOGICAL_OPERATORS = ["||", "&&",
  "??"], oF = de.UPDATE_OPERATORS = ["++", "--"], pS = de.BOOLEAN_NUMBER_BINARY_OPERATORS = [">", "<", ">=", "<="], fS = de.EQUALITY_BINARY_OPERATORS =
  ["==", "===", "!=", "!=="], hS = de.COMPARISON_BINARY_OPERATORS = [...fS, "in", "instanceof"], dS = de.BOOLEAN_BINARY_OPERATORS = [...hS, ...pS],
  ml = de.NUMBER_BINARY_OPERATORS = ["-", "/", "%", "*", "**", "&", "|", ">>", ">>>", "<<", "^"], lF = de.BINARY_OPERATORS = ["+", ...ml, ...dS,
  "|>"], uF = de.ASSIGNMENT_OPERATORS = ["=", "+=", ...ml.map((t) => t + "="), ...cS.map((t) => t + "=")], mS = de.BOOLEAN_UNARY_OPERATORS =
  ["delete", "!"], yS = de.NUMBER_UNARY_OPERATORS = ["+", "-", "~"], TS = de.STRING_UNARY_OPERATORS = ["typeof"], cF = de.UNARY_OPERATORS = [
  "void", "throw", ...mS, ...yS, ...TS], pF = de.INHERIT_KEYS = {
    optional: ["typeAnnotation", "typeParameters", "returnType"],
    force: ["start", "loc", "end"]
  };
  de.BLOCK_SCOPED_SYMBOL = Symbol.for("var used to be block scoped"), de.NOT_LOCAL_BINDING = Symbol.for("should not be considered a local bi\
nding");
});

// ../node_modules/@babel/types/lib/definitions/utils.js
var bt = D((ge) => {
  "use strict";
  Object.defineProperty(ge, "__esModule", {
    value: !0
  });
  ge.allExpandedTypes = ge.VISITOR_KEYS = ge.NODE_PARENT_VALIDATIONS = ge.NODE_FIELDS = ge.FLIPPED_ALIAS_KEYS = ge.DEPRECATED_KEYS = ge.BUILDER_KEYS =
  ge.ALIAS_KEYS = void 0;
  ge.arrayOf = Tl;
  ge.arrayOfType = Sl;
  ge.assertEach = bl;
  ge.assertNodeOrValueType = OS;
  ge.assertNodeType = gi;
  ge.assertOneOf = wS;
  ge.assertOptionalChainStart = DS;
  ge.assertShape = _S;
  ge.assertValueType = Us;
  ge.chain = xl;
  ge.default = gl;
  ge.defineAliasedType = MS;
  ge.validate = qs;
  ge.validateArrayOfType = CS;
  ge.validateOptional = IS;
  ge.validateOptionalType = vS;
  ge.validateType = AS;
  var yl = sr(), _r = Ei(), SS = ge.VISITOR_KEYS = {}, bS = ge.ALIAS_KEYS = {}, Fs = ge.FLIPPED_ALIAS_KEYS = {}, xS = ge.NODE_FIELDS = {}, gS = ge.
  BUILDER_KEYS = {}, ES = ge.DEPRECATED_KEYS = {}, PS = ge.NODE_PARENT_VALIDATIONS = {};
  function xi(t) {
    return Array.isArray(t) ? "array" : t === null ? "null" : typeof t;
  }
  s(xi, "getType");
  function qs(t) {
    return {
      validate: t
    };
  }
  s(qs, "validate");
  function AS(...t) {
    return qs(gi(...t));
  }
  s(AS, "validateType");
  function IS(t) {
    return {
      validate: t,
      optional: !0
    };
  }
  s(IS, "validateOptional");
  function vS(...t) {
    return {
      validate: gi(...t),
      optional: !0
    };
  }
  s(vS, "validateOptionalType");
  function Tl(t) {
    return xl(Us("array"), bl(t));
  }
  s(Tl, "arrayOf");
  function Sl(...t) {
    return Tl(gi(...t));
  }
  s(Sl, "arrayOfType");
  function CS(...t) {
    return qs(Sl(...t));
  }
  s(CS, "validateArrayOfType");
  function bl(t) {
    let e = process.env.BABEL_TYPES_8_BREAKING ? _r.validateChild : () => {
    };
    function r(i, n, a) {
      if (!Array.isArray(a)) return;
      let o = 0, l = {
        toString() {
          return `${n}[${o}]`;
        }
      };
      for (; o < a.length; o++) {
        let u = a[o];
        t(i, l, u), e(i, l, u);
      }
    }
    return s(r, "validator"), r.each = t, r;
  }
  s(bl, "assertEach");
  function wS(...t) {
    function e(r, i, n) {
      if (!t.includes(n))
        throw new TypeError(`Property ${i} expected value to be one of ${JSON.stringify(t)} but got ${JSON.stringify(n)}`);
    }
    return s(e, "validate"), e.oneOf = t, e;
  }
  s(wS, "assertOneOf");
  var NS = ge.allExpandedTypes = [];
  function gi(...t) {
    let e = /* @__PURE__ */ new Set();
    NS.push({
      types: t,
      set: e
    });
    function r(i, n, a) {
      let o = a?.type;
      if (o != null) {
        if (e.has(o)) {
          (0, _r.validateChild)(i, n, a);
          return;
        }
        if (o === "Placeholder") {
          for (let l of t)
            if ((0, yl.default)(l, a)) {
              (0, _r.validateChild)(i, n, a);
              return;
            }
        }
      }
      throw new TypeError(`Property ${n} of ${i.type} expected node to be of a type ${JSON.stringify(t)} but instead got ${JSON.stringify(o)}`);
    }
    return s(r, "validate"), r.oneOfNodeTypes = t, r;
  }
  s(gi, "assertNodeType");
  function OS(...t) {
    function e(r, i, n) {
      let a = xi(n);
      for (let o of t)
        if (a === o || (0, yl.default)(o, n)) {
          (0, _r.validateChild)(r, i, n);
          return;
        }
      throw new TypeError(`Property ${i} of ${r.type} expected node to be of a type ${JSON.stringify(t)} but instead got ${JSON.stringify(n?.
      type)}`);
    }
    return s(e, "validate"), e.oneOfNodeOrValueTypes = t, e;
  }
  s(OS, "assertNodeOrValueType");
  function Us(t) {
    function e(r, i, n) {
      if (xi(n) !== t)
        throw new TypeError(`Property ${i} expected type of ${t} but got ${xi(n)}`);
    }
    return s(e, "validate"), e.type = t, e;
  }
  s(Us, "assertValueType");
  function _S(t) {
    let e = Object.keys(t);
    function r(i, n, a) {
      let o = [];
      for (let l of e)
        try {
          (0, _r.validateField)(i, l, a[l], t[l]);
        } catch (u) {
          if (u instanceof TypeError) {
            o.push(u.message);
            continue;
          }
          throw u;
        }
      if (o.length)
        throw new TypeError(`Property ${n} of ${i.type} expected to have the following:
${o.join(`
`)}`);
    }
    return s(r, "validate"), r.shapeOf = t, r;
  }
  s(_S, "assertShape");
  function DS() {
    function t(e) {
      var r;
      let i = e;
      for (; e; ) {
        let {
          type: n
        } = i;
        if (n === "OptionalCallExpression") {
          if (i.optional) return;
          i = i.callee;
          continue;
        }
        if (n === "OptionalMemberExpression") {
          if (i.optional) return;
          i = i.object;
          continue;
        }
        break;
      }
      throw new TypeError(`Non-optional ${e.type} must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chai\
n from ${(r = i) == null ? void 0 : r.type}`);
    }
    return s(t, "validate"), t;
  }
  s(DS, "assertOptionalChainStart");
  function xl(...t) {
    function e(...r) {
      for (let i of t)
        i(...r);
    }
    if (s(e, "validate"), e.chainOf = t, t.length >= 2 && "type" in t[0] && t[0].type === "array" && !("each" in t[1]))
      throw new Error('An assertValueType("array") validator can only be followed by an assertEach(...) validator.');
    return e;
  }
  s(xl, "chain");
  var kS = /* @__PURE__ */ new Set(["aliases", "builder", "deprecatedAlias", "fields", "inherits", "visitor", "validate"]), LS = /* @__PURE__ */ new Set(
  ["default", "optional", "deprecated", "validate"]), Rs = {};
  function MS(...t) {
    return (e, r = {}) => {
      let i = r.aliases;
      if (!i) {
        var n;
        r.inherits && (i = (n = Rs[r.inherits].aliases) == null ? void 0 : n.slice()), i ?? (i = []), r.aliases = i;
      }
      let a = t.filter((o) => !i.includes(o));
      i.unshift(...a), gl(e, r);
    };
  }
  s(MS, "defineAliasedType");
  function gl(t, e = {}) {
    let r = e.inherits && Rs[e.inherits] || {}, i = e.fields;
    if (!i && (i = {}, r.fields)) {
      let l = Object.getOwnPropertyNames(r.fields);
      for (let u of l) {
        let p = r.fields[u], h = p.default;
        if (Array.isArray(h) ? h.length > 0 : h && typeof h == "object")
          throw new Error("field defaults can only be primitives or empty arrays currently");
        i[u] = {
          default: Array.isArray(h) ? [] : h,
          optional: p.optional,
          deprecated: p.deprecated,
          validate: p.validate
        };
      }
    }
    let n = e.visitor || r.visitor || [], a = e.aliases || r.aliases || [], o = e.builder || r.builder || e.visitor || [];
    for (let l of Object.keys(e))
      if (!kS.has(l))
        throw new Error(`Unknown type option "${l}" on ${t}`);
    e.deprecatedAlias && (ES[e.deprecatedAlias] = t);
    for (let l of n.concat(o))
      i[l] = i[l] || {};
    for (let l of Object.keys(i)) {
      let u = i[l];
      u.default !== void 0 && !o.includes(l) && (u.optional = !0), u.default === void 0 ? u.default = null : !u.validate && u.default != null &&
      (u.validate = Us(xi(u.default)));
      for (let p of Object.keys(u))
        if (!LS.has(p))
          throw new Error(`Unknown field key "${p}" on ${t}.${l}`);
    }
    SS[t] = e.visitor = n, gS[t] = e.builder = o, xS[t] = e.fields = i, bS[t] = e.aliases = a, a.forEach((l) => {
      Fs[l] = Fs[l] || [], Fs[l].push(t);
    }), e.validate && (PS[t] = e.validate), Rs[t] = e;
  }
  s(gl, "defineType");
});

// ../node_modules/@babel/types/lib/definitions/core.js
var kr = D((Ve) => {
  "use strict";
  Object.defineProperty(Ve, "__esModule", {
    value: !0
  });
  Ve.patternLikeCommon = Ve.importAttributes = Ve.functionTypeAnnotationCommon = Ve.functionDeclarationCommon = Ve.functionCommon = Ve.classMethodOrPropertyCommon =
  Ve.classMethodOrDeclareMethodCommon = void 0;
  var $e = sr(), BS = nr(), El = Si(), jS = dl(), Dr = ar(), S = bt(), R = (0, S.defineAliasedType)("Standardized");
  R("ArrayExpression", {
    fields: {
      elements: {
        validate: (0, S.arrayOf)((0, S.assertNodeOrValueType)("null", "Expression", "SpreadElement")),
        default: process.env.BABEL_TYPES_8_BREAKING ? void 0 : []
      }
    },
    visitor: ["elements"],
    aliases: ["Expression"]
  });
  R("AssignmentExpression", {
    fields: {
      operator: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? Object.assign(function() {
          let t = (0, S.assertOneOf)(...Dr.ASSIGNMENT_OPERATORS), e = (0, S.assertOneOf)("=");
          return function(r, i, n) {
            ((0, $e.default)("Pattern", r.left) ? e : t)(r, i, n);
          };
        }(), {
          type: "string"
        }) : (0, S.assertValueType)("string")
      },
      left: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, S.assertNodeType)("Identifier", "MemberExpression", "OptionalMemberExpression", "\
ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") : (0, S.assertNodeType)(
        "LVal", "OptionalMemberExpression")
      },
      right: {
        validate: (0, S.assertNodeType)("Expression")
      }
    },
    builder: ["operator", "left", "right"],
    visitor: ["left", "right"],
    aliases: ["Expression"]
  });
  R("BinaryExpression", {
    builder: ["operator", "left", "right"],
    fields: {
      operator: {
        validate: (0, S.assertOneOf)(...Dr.BINARY_OPERATORS)
      },
      left: {
        validate: function() {
          let t = (0, S.assertNodeType)("Expression"), e = (0, S.assertNodeType)("Expression", "PrivateName");
          return Object.assign(function(i, n, a) {
            (i.operator === "in" ? e : t)(i, n, a);
          }, {
            oneOfNodeTypes: ["Expression", "PrivateName"]
          });
        }()
      },
      right: {
        validate: (0, S.assertNodeType)("Expression")
      }
    },
    visitor: ["left", "right"],
    aliases: ["Binary", "Expression"]
  });
  R("InterpreterDirective", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, S.assertValueType)("string")
      }
    }
  });
  R("Directive", {
    visitor: ["value"],
    fields: {
      value: {
        validate: (0, S.assertNodeType)("DirectiveLiteral")
      }
    }
  });
  R("DirectiveLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, S.assertValueType)("string")
      }
    }
  });
  R("BlockStatement", {
    builder: ["body", "directives"],
    visitor: ["directives", "body"],
    fields: {
      directives: {
        validate: (0, S.arrayOfType)("Directive"),
        default: []
      },
      body: (0, S.validateArrayOfType)("Statement")
    },
    aliases: ["Scopable", "BlockParent", "Block", "Statement"]
  });
  R("BreakStatement", {
    visitor: ["label"],
    fields: {
      label: {
        validate: (0, S.assertNodeType)("Identifier"),
        optional: !0
      }
    },
    aliases: ["Statement", "Terminatorless", "CompletionStatement"]
  });
  R("CallExpression", {
    visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
    builder: ["callee", "arguments"],
    aliases: ["Expression"],
    fields: Object.assign({
      callee: {
        validate: (0, S.assertNodeType)("Expression", "Super", "V8IntrinsicIdentifier")
      },
      arguments: (0, S.validateArrayOfType)("Expression", "SpreadElement", "ArgumentPlaceholder"),
      typeArguments: {
        validate: (0, S.assertNodeType)("TypeParameterInstantiation"),
        optional: !0
      }
    }, {
      optional: {
        validate: (0, S.assertValueType)("boolean"),
        optional: !0
      },
      typeParameters: {
        validate: (0, S.assertNodeType)("TSTypeParameterInstantiation"),
        optional: !0
      }
    }, process.env.BABEL_TYPES_8_BREAKING ? {} : {
      optional: {
        validate: (0, S.assertValueType)("boolean"),
        optional: !0
      }
    })
  });
  R("CatchClause", {
    visitor: ["param", "body"],
    fields: {
      param: {
        validate: (0, S.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"),
        optional: !0
      },
      body: {
        validate: (0, S.assertNodeType)("BlockStatement")
      }
    },
    aliases: ["Scopable", "BlockParent"]
  });
  R("ConditionalExpression", {
    visitor: ["test", "consequent", "alternate"],
    fields: {
      test: {
        validate: (0, S.assertNodeType)("Expression")
      },
      consequent: {
        validate: (0, S.assertNodeType)("Expression")
      },
      alternate: {
        validate: (0, S.assertNodeType)("Expression")
      }
    },
    aliases: ["Expression", "Conditional"]
  });
  R("ContinueStatement", {
    visitor: ["label"],
    fields: {
      label: {
        validate: (0, S.assertNodeType)("Identifier"),
        optional: !0
      }
    },
    aliases: ["Statement", "Terminatorless", "CompletionStatement"]
  });
  R("DebuggerStatement", {
    aliases: ["Statement"]
  });
  R("DoWhileStatement", {
    builder: ["test", "body"],
    visitor: ["body", "test"],
    fields: {
      test: {
        validate: (0, S.assertNodeType)("Expression")
      },
      body: {
        validate: (0, S.assertNodeType)("Statement")
      }
    },
    aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"]
  });
  R("EmptyStatement", {
    aliases: ["Statement"]
  });
  R("ExpressionStatement", {
    visitor: ["expression"],
    fields: {
      expression: {
        validate: (0, S.assertNodeType)("Expression")
      }
    },
    aliases: ["Statement", "ExpressionWrapper"]
  });
  R("File", {
    builder: ["program", "comments", "tokens"],
    visitor: ["program"],
    fields: {
      program: {
        validate: (0, S.assertNodeType)("Program")
      },
      comments: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, S.assertEach)((0, S.assertNodeType)("CommentBlock", "CommentLine")) : Object.assign(
        () => {
        }, {
          each: {
            oneOfNodeTypes: ["CommentBlock", "CommentLine"]
          }
        }),
        optional: !0
      },
      tokens: {
        validate: (0, S.assertEach)(Object.assign(() => {
        }, {
          type: "any"
        })),
        optional: !0
      }
    }
  });
  R("ForInStatement", {
    visitor: ["left", "right", "body"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
    fields: {
      left: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, S.assertNodeType)("VariableDeclaration", "Identifier", "MemberExpression", "Array\
Pattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") : (0, S.assertNodeType)("Var\
iableDeclaration", "LVal")
      },
      right: {
        validate: (0, S.assertNodeType)("Expression")
      },
      body: {
        validate: (0, S.assertNodeType)("Statement")
      }
    }
  });
  R("ForStatement", {
    visitor: ["init", "test", "update", "body"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop"],
    fields: {
      init: {
        validate: (0, S.assertNodeType)("VariableDeclaration", "Expression"),
        optional: !0
      },
      test: {
        validate: (0, S.assertNodeType)("Expression"),
        optional: !0
      },
      update: {
        validate: (0, S.assertNodeType)("Expression"),
        optional: !0
      },
      body: {
        validate: (0, S.assertNodeType)("Statement")
      }
    }
  });
  var or = /* @__PURE__ */ s(() => ({
    params: (0, S.validateArrayOfType)("Identifier", "Pattern", "RestElement"),
    generator: {
      default: !1
    },
    async: {
      default: !1
    }
  }), "functionCommon");
  Ve.functionCommon = or;
  var Wt = /* @__PURE__ */ s(() => ({
    returnType: {
      validate: (0, S.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
      optional: !0
    },
    typeParameters: {
      validate: (0, S.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
      optional: !0
    }
  }), "functionTypeAnnotationCommon");
  Ve.functionTypeAnnotationCommon = Wt;
  var Pl = /* @__PURE__ */ s(() => Object.assign({}, or(), {
    declare: {
      validate: (0, S.assertValueType)("boolean"),
      optional: !0
    },
    id: {
      validate: (0, S.assertNodeType)("Identifier"),
      optional: !0
    }
  }), "functionDeclarationCommon");
  Ve.functionDeclarationCommon = Pl;
  R("FunctionDeclaration", {
    builder: ["id", "params", "body", "generator", "async"],
    visitor: ["id", "typeParameters", "params", "predicate", "returnType", "body"],
    fields: Object.assign({}, Pl(), Wt(), {
      body: {
        validate: (0, S.assertNodeType)("BlockStatement")
      },
      predicate: {
        validate: (0, S.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
        optional: !0
      }
    }),
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Statement", "Pureish", "Declaration"],
    validate: process.env.BABEL_TYPES_8_BREAKING ? function() {
      let t = (0, S.assertNodeType)("Identifier");
      return function(e, r, i) {
        (0, $e.default)("ExportDefaultDeclaration", e) || t(i, "id", i.id);
      };
    }() : void 0
  });
  R("FunctionExpression", {
    inherits: "FunctionDeclaration",
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
    fields: Object.assign({}, or(), Wt(), {
      id: {
        validate: (0, S.assertNodeType)("Identifier"),
        optional: !0
      },
      body: {
        validate: (0, S.assertNodeType)("BlockStatement")
      },
      predicate: {
        validate: (0, S.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
        optional: !0
      }
    })
  });
  var lr = /* @__PURE__ */ s(() => ({
    typeAnnotation: {
      validate: (0, S.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
      optional: !0
    },
    optional: {
      validate: (0, S.assertValueType)("boolean"),
      optional: !0
    },
    decorators: {
      validate: (0, S.arrayOfType)("Decorator"),
      optional: !0
    }
  }), "patternLikeCommon");
  Ve.patternLikeCommon = lr;
  R("Identifier", {
    builder: ["name"],
    visitor: ["typeAnnotation", "decorators"],
    aliases: ["Expression", "PatternLike", "LVal", "TSEntityName"],
    fields: Object.assign({}, lr(), {
      name: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, S.chain)((0, S.assertValueType)("string"), Object.assign(function(t, e, r) {
          if (!(0, BS.default)(r, !1))
            throw new TypeError(`"${r}" is not a valid identifier name`);
        }, {
          type: "string"
        })) : (0, S.assertValueType)("string")
      }
    }),
    validate: process.env.BABEL_TYPES_8_BREAKING ? function(t, e, r) {
      let i = /\.(\w+)$/.exec(e.toString());
      if (!i) return;
      let [, n] = i, a = {
        computed: !1
      };
      if (n === "property") {
        if ((0, $e.default)("MemberExpression", t, a) || (0, $e.default)("OptionalMemberExpression", t, a)) return;
      } else if (n === "key") {
        if ((0, $e.default)("Property", t, a) || (0, $e.default)("Method", t, a)) return;
      } else if (n === "exported") {
        if ((0, $e.default)("ExportSpecifier", t)) return;
      } else if (n === "imported") {
        if ((0, $e.default)("ImportSpecifier", t, {
          imported: r
        })) return;
      } else if (n === "meta" && (0, $e.default)("MetaProperty", t, {
        meta: r
      }))
        return;
      if (((0, El.isKeyword)(r.name) || (0, El.isReservedWord)(r.name, !1)) && r.name !== "this")
        throw new TypeError(`"${r.name}" is not a valid identifier`);
    } : void 0
  });
  R("IfStatement", {
    visitor: ["test", "consequent", "alternate"],
    aliases: ["Statement", "Conditional"],
    fields: {
      test: {
        validate: (0, S.assertNodeType)("Expression")
      },
      consequent: {
        validate: (0, S.assertNodeType)("Statement")
      },
      alternate: {
        optional: !0,
        validate: (0, S.assertNodeType)("Statement")
      }
    }
  });
  R("LabeledStatement", {
    visitor: ["label", "body"],
    aliases: ["Statement"],
    fields: {
      label: {
        validate: (0, S.assertNodeType)("Identifier")
      },
      body: {
        validate: (0, S.assertNodeType)("Statement")
      }
    }
  });
  R("StringLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, S.assertValueType)("string")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  R("NumericLiteral", {
    builder: ["value"],
    deprecatedAlias: "NumberLiteral",
    fields: {
      value: {
        validate: (0, S.chain)((0, S.assertValueType)("number"), Object.assign(function(t, e, r) {
          if (1 / r < 0 || !Number.isFinite(r)) {
            let i = new Error(`NumericLiterals must be non-negative finite numbers. You can use t.valueToNode(${r}) instead.`);
          }
        }, {
          type: "number"
        }))
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  R("NullLiteral", {
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  R("BooleanLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, S.assertValueType)("boolean")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  R("RegExpLiteral", {
    builder: ["pattern", "flags"],
    deprecatedAlias: "RegexLiteral",
    aliases: ["Expression", "Pureish", "Literal"],
    fields: {
      pattern: {
        validate: (0, S.assertValueType)("string")
      },
      flags: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, S.chain)((0, S.assertValueType)("string"), Object.assign(function(t, e, r) {
          let i = /[^gimsuy]/.exec(r);
          if (i)
            throw new TypeError(`"${i[0]}" is not a valid RegExp flag`);
        }, {
          type: "string"
        })) : (0, S.assertValueType)("string"),
        default: ""
      }
    }
  });
  R("LogicalExpression", {
    builder: ["operator", "left", "right"],
    visitor: ["left", "right"],
    aliases: ["Binary", "Expression"],
    fields: {
      operator: {
        validate: (0, S.assertOneOf)(...Dr.LOGICAL_OPERATORS)
      },
      left: {
        validate: (0, S.assertNodeType)("Expression")
      },
      right: {
        validate: (0, S.assertNodeType)("Expression")
      }
    }
  });
  R("MemberExpression", {
    builder: ["object", "property", "computed", ...process.env.BABEL_TYPES_8_BREAKING ? [] : ["optional"]],
    visitor: ["object", "property"],
    aliases: ["Expression", "LVal"],
    fields: Object.assign({
      object: {
        validate: (0, S.assertNodeType)("Expression", "Super")
      },
      property: {
        validate: function() {
          let t = (0, S.assertNodeType)("Identifier", "PrivateName"), e = (0, S.assertNodeType)("Expression"), r = /* @__PURE__ */ s(function(i, n, a) {
            (i.computed ? e : t)(i, n, a);
          }, "validator");
          return r.oneOfNodeTypes = ["Expression", "Identifier", "PrivateName"], r;
        }()
      },
      computed: {
        default: !1
      }
    }, process.env.BABEL_TYPES_8_BREAKING ? {} : {
      optional: {
        validate: (0, S.assertValueType)("boolean"),
        optional: !0
      }
    })
  });
  R("NewExpression", {
    inherits: "CallExpression"
  });
  R("Program", {
    visitor: ["directives", "body"],
    builder: ["body", "directives", "sourceType", "interpreter"],
    fields: {
      sourceType: {
        validate: (0, S.assertOneOf)("script", "module"),
        default: "script"
      },
      interpreter: {
        validate: (0, S.assertNodeType)("InterpreterDirective"),
        default: null,
        optional: !0
      },
      directives: {
        validate: (0, S.arrayOfType)("Directive"),
        default: []
      },
      body: (0, S.validateArrayOfType)("Statement")
    },
    aliases: ["Scopable", "BlockParent", "Block"]
  });
  R("ObjectExpression", {
    visitor: ["properties"],
    aliases: ["Expression"],
    fields: {
      properties: (0, S.validateArrayOfType)("ObjectMethod", "ObjectProperty", "SpreadElement")
    }
  });
  R("ObjectMethod", {
    builder: ["kind", "key", "params", "body", "computed", "generator", "async"],
    visitor: ["decorators", "key", "typeParameters", "params", "returnType", "body"],
    fields: Object.assign({}, or(), Wt(), {
      kind: Object.assign({
        validate: (0, S.assertOneOf)("method", "get", "set")
      }, process.env.BABEL_TYPES_8_BREAKING ? {} : {
        default: "method"
      }),
      computed: {
        default: !1
      },
      key: {
        validate: function() {
          let t = (0, S.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"), e = (0, S.assertNodeType)("Expres\
sion"), r = /* @__PURE__ */ s(function(i, n, a) {
            (i.computed ? e : t)(i, n, a);
          }, "validator");
          return r.oneOfNodeTypes = ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"], r;
        }()
      },
      decorators: {
        validate: (0, S.arrayOfType)("Decorator"),
        optional: !0
      },
      body: {
        validate: (0, S.assertNodeType)("BlockStatement")
      }
    }),
    aliases: ["UserWhitespacable", "Function", "Scopable", "BlockParent", "FunctionParent", "Method", "ObjectMember"]
  });
  R("ObjectProperty", {
    builder: ["key", "value", "computed", "shorthand", ...process.env.BABEL_TYPES_8_BREAKING ? [] : ["decorators"]],
    fields: {
      computed: {
        default: !1
      },
      key: {
        validate: function() {
          let t = (0, S.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName"), e = (0, S.
          assertNodeType)("Expression");
          return Object.assign(function(i, n, a) {
            (i.computed ? e : t)(i, n, a);
          }, {
            oneOfNodeTypes: ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName"]
          });
        }()
      },
      value: {
        validate: (0, S.assertNodeType)("Expression", "PatternLike")
      },
      shorthand: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, S.chain)((0, S.assertValueType)("boolean"), Object.assign(function(t, e, r) {
          if (r) {
            if (t.computed)
              throw new TypeError("Property shorthand of ObjectProperty cannot be true if computed is true");
            if (!(0, $e.default)("Identifier", t.key))
              throw new TypeError("Property shorthand of ObjectProperty cannot be true if key is not an Identifier");
          }
        }, {
          type: "boolean"
        })) : (0, S.assertValueType)("boolean"),
        default: !1
      },
      decorators: {
        validate: (0, S.arrayOfType)("Decorator"),
        optional: !0
      }
    },
    visitor: ["key", "value", "decorators"],
    aliases: ["UserWhitespacable", "Property", "ObjectMember"],
    validate: process.env.BABEL_TYPES_8_BREAKING ? function() {
      let t = (0, S.assertNodeType)("Identifier", "Pattern", "TSAsExpression", "TSSatisfiesExpression", "TSNonNullExpression", "TSTypeAssert\
ion"), e = (0, S.assertNodeType)("Expression");
      return function(r, i, n) {
        ((0, $e.default)("ObjectPattern", r) ? t : e)(n, "value", n.value);
      };
    }() : void 0
  });
  R("RestElement", {
    visitor: ["argument", "typeAnnotation"],
    builder: ["argument"],
    aliases: ["LVal", "PatternLike"],
    deprecatedAlias: "RestProperty",
    fields: Object.assign({}, lr(), {
      argument: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, S.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern", "MemberExpressio\
n", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") : (0, S.assertNodeType)("LVal")
      }
    }),
    validate: process.env.BABEL_TYPES_8_BREAKING ? function(t, e) {
      let r = /(\w+)\[(\d+)\]/.exec(e.toString());
      if (!r) throw new Error("Internal Babel error: malformed key.");
      let [, i, n] = r;
      if (t[i].length > +n + 1)
        throw new TypeError(`RestElement must be last element of ${i}`);
    } : void 0
  });
  R("ReturnStatement", {
    visitor: ["argument"],
    aliases: ["Statement", "Terminatorless", "CompletionStatement"],
    fields: {
      argument: {
        validate: (0, S.assertNodeType)("Expression"),
        optional: !0
      }
    }
  });
  R("SequenceExpression", {
    visitor: ["expressions"],
    fields: {
      expressions: (0, S.validateArrayOfType)("Expression")
    },
    aliases: ["Expression"]
  });
  R("ParenthesizedExpression", {
    visitor: ["expression"],
    aliases: ["Expression", "ExpressionWrapper"],
    fields: {
      expression: {
        validate: (0, S.assertNodeType)("Expression")
      }
    }
  });
  R("SwitchCase", {
    visitor: ["test", "consequent"],
    fields: {
      test: {
        validate: (0, S.assertNodeType)("Expression"),
        optional: !0
      },
      consequent: (0, S.validateArrayOfType)("Statement")
    }
  });
  R("SwitchStatement", {
    visitor: ["discriminant", "cases"],
    aliases: ["Statement", "BlockParent", "Scopable"],
    fields: {
      discriminant: {
        validate: (0, S.assertNodeType)("Expression")
      },
      cases: (0, S.validateArrayOfType)("SwitchCase")
    }
  });
  R("ThisExpression", {
    aliases: ["Expression"]
  });
  R("ThrowStatement", {
    visitor: ["argument"],
    aliases: ["Statement", "Terminatorless", "CompletionStatement"],
    fields: {
      argument: {
        validate: (0, S.assertNodeType)("Expression")
      }
    }
  });
  R("TryStatement", {
    visitor: ["block", "handler", "finalizer"],
    aliases: ["Statement"],
    fields: {
      block: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, S.chain)((0, S.assertNodeType)("BlockStatement"), Object.assign(function(t) {
          if (!t.handler && !t.finalizer)
            throw new TypeError("TryStatement expects either a handler or finalizer, or both");
        }, {
          oneOfNodeTypes: ["BlockStatement"]
        })) : (0, S.assertNodeType)("BlockStatement")
      },
      handler: {
        optional: !0,
        validate: (0, S.assertNodeType)("CatchClause")
      },
      finalizer: {
        optional: !0,
        validate: (0, S.assertNodeType)("BlockStatement")
      }
    }
  });
  R("UnaryExpression", {
    builder: ["operator", "argument", "prefix"],
    fields: {
      prefix: {
        default: !0
      },
      argument: {
        validate: (0, S.assertNodeType)("Expression")
      },
      operator: {
        validate: (0, S.assertOneOf)(...Dr.UNARY_OPERATORS)
      }
    },
    visitor: ["argument"],
    aliases: ["UnaryLike", "Expression"]
  });
  R("UpdateExpression", {
    builder: ["operator", "argument", "prefix"],
    fields: {
      prefix: {
        default: !1
      },
      argument: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, S.assertNodeType)("Identifier", "MemberExpression") : (0, S.assertNodeType)("Expr\
ession")
      },
      operator: {
        validate: (0, S.assertOneOf)(...Dr.UPDATE_OPERATORS)
      }
    },
    visitor: ["argument"],
    aliases: ["Expression"]
  });
  R("VariableDeclaration", {
    builder: ["kind", "declarations"],
    visitor: ["declarations"],
    aliases: ["Statement", "Declaration"],
    fields: {
      declare: {
        validate: (0, S.assertValueType)("boolean"),
        optional: !0
      },
      kind: {
        validate: (0, S.assertOneOf)("var", "let", "const", "using", "await using")
      },
      declarations: (0, S.validateArrayOfType)("VariableDeclarator")
    },
    validate: process.env.BABEL_TYPES_8_BREAKING ? (() => {
      let t = (0, S.assertNodeType)("Identifier");
      return function(e, r, i) {
        if ((0, $e.default)("ForXStatement", e, {
          left: i
        })) {
          if (i.declarations.length !== 1)
            throw new TypeError(`Exactly one VariableDeclarator is required in the VariableDeclaration of a ${e.type}`);
        } else
          i.declarations.forEach((n) => {
            n.init || t(n, "id", n.id);
          });
      };
    })() : void 0
  });
  R("VariableDeclarator", {
    visitor: ["id", "init"],
    fields: {
      id: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, S.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern") : (0, S.assertNodeType)(
        "LVal")
      },
      definite: {
        optional: !0,
        validate: (0, S.assertValueType)("boolean")
      },
      init: {
        optional: !0,
        validate: (0, S.assertNodeType)("Expression")
      }
    }
  });
  R("WhileStatement", {
    visitor: ["test", "body"],
    aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"],
    fields: {
      test: {
        validate: (0, S.assertNodeType)("Expression")
      },
      body: {
        validate: (0, S.assertNodeType)("Statement")
      }
    }
  });
  R("WithStatement", {
    visitor: ["object", "body"],
    aliases: ["Statement"],
    fields: {
      object: {
        validate: (0, S.assertNodeType)("Expression")
      },
      body: {
        validate: (0, S.assertNodeType)("Statement")
      }
    }
  });
  R("AssignmentPattern", {
    visitor: ["left", "right", "decorators"],
    builder: ["left", "right"],
    aliases: ["Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, lr(), {
      left: {
        validate: (0, S.assertNodeType)("Identifier", "ObjectPattern", "ArrayPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExp\
ression", "TSTypeAssertion", "TSNonNullExpression")
      },
      right: {
        validate: (0, S.assertNodeType)("Expression")
      },
      decorators: {
        validate: (0, S.arrayOfType)("Decorator"),
        optional: !0
      }
    })
  });
  R("ArrayPattern", {
    visitor: ["elements", "typeAnnotation"],
    builder: ["elements"],
    aliases: ["Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, lr(), {
      elements: {
        validate: (0, S.chain)((0, S.assertValueType)("array"), (0, S.assertEach)((0, S.assertNodeOrValueType)("null", "PatternLike", "LVal")))
      }
    })
  });
  R("ArrowFunctionExpression", {
    builder: ["params", "body", "async"],
    visitor: ["typeParameters", "params", "predicate", "returnType", "body"],
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
    fields: Object.assign({}, or(), Wt(), {
      expression: {
        validate: (0, S.assertValueType)("boolean")
      },
      body: {
        validate: (0, S.assertNodeType)("BlockStatement", "Expression")
      },
      predicate: {
        validate: (0, S.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
        optional: !0
      }
    })
  });
  R("ClassBody", {
    visitor: ["body"],
    fields: {
      body: (0, S.validateArrayOfType)("ClassMethod", "ClassPrivateMethod", "ClassProperty", "ClassPrivateProperty", "ClassAccessorProperty",
      "TSDeclareMethod", "TSIndexSignature", "StaticBlock")
    }
  });
  R("ClassExpression", {
    builder: ["id", "superClass", "body", "decorators"],
    visitor: ["decorators", "id", "typeParameters", "superClass", "superTypeParameters", "mixins", "implements", "body"],
    aliases: ["Scopable", "Class", "Expression"],
    fields: {
      id: {
        validate: (0, S.assertNodeType)("Identifier"),
        optional: !0
      },
      typeParameters: {
        validate: (0, S.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
        optional: !0
      },
      body: {
        validate: (0, S.assertNodeType)("ClassBody")
      },
      superClass: {
        optional: !0,
        validate: (0, S.assertNodeType)("Expression")
      },
      superTypeParameters: {
        validate: (0, S.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: !0
      },
      implements: {
        validate: (0, S.arrayOfType)("TSExpressionWithTypeArguments", "ClassImplements"),
        optional: !0
      },
      decorators: {
        validate: (0, S.arrayOfType)("Decorator"),
        optional: !0
      },
      mixins: {
        validate: (0, S.assertNodeType)("InterfaceExtends"),
        optional: !0
      }
    }
  });
  R("ClassDeclaration", {
    inherits: "ClassExpression",
    aliases: ["Scopable", "Class", "Statement", "Declaration"],
    fields: {
      id: {
        validate: (0, S.assertNodeType)("Identifier"),
        optional: !0
      },
      typeParameters: {
        validate: (0, S.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
        optional: !0
      },
      body: {
        validate: (0, S.assertNodeType)("ClassBody")
      },
      superClass: {
        optional: !0,
        validate: (0, S.assertNodeType)("Expression")
      },
      superTypeParameters: {
        validate: (0, S.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: !0
      },
      implements: {
        validate: (0, S.arrayOfType)("TSExpressionWithTypeArguments", "ClassImplements"),
        optional: !0
      },
      decorators: {
        validate: (0, S.arrayOfType)("Decorator"),
        optional: !0
      },
      mixins: {
        validate: (0, S.assertNodeType)("InterfaceExtends"),
        optional: !0
      },
      declare: {
        validate: (0, S.assertValueType)("boolean"),
        optional: !0
      },
      abstract: {
        validate: (0, S.assertValueType)("boolean"),
        optional: !0
      }
    },
    validate: process.env.BABEL_TYPES_8_BREAKING ? function() {
      let t = (0, S.assertNodeType)("Identifier");
      return function(e, r, i) {
        (0, $e.default)("ExportDefaultDeclaration", e) || t(i, "id", i.id);
      };
    }() : void 0
  });
  var Ks = Ve.importAttributes = {
    attributes: {
      optional: !0,
      validate: (0, S.arrayOfType)("ImportAttribute")
    },
    assertions: {
      deprecated: !0,
      optional: !0,
      validate: (0, S.arrayOfType)("ImportAttribute")
    }
  };
  R("ExportAllDeclaration", {
    builder: ["source"],
    visitor: ["source", "attributes", "assertions"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
    fields: Object.assign({
      source: {
        validate: (0, S.assertNodeType)("StringLiteral")
      },
      exportKind: (0, S.validateOptional)((0, S.assertOneOf)("type", "value"))
    }, Ks)
  });
  R("ExportDefaultDeclaration", {
    visitor: ["declaration"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
    fields: {
      declaration: (0, S.validateType)("TSDeclareFunction", "FunctionDeclaration", "ClassDeclaration", "Expression"),
      exportKind: (0, S.validateOptional)((0, S.assertOneOf)("value"))
    }
  });
  R("ExportNamedDeclaration", {
    builder: ["declaration", "specifiers", "source"],
    visitor: process.env ? ["declaration", "specifiers", "source", "attributes"] : ["declaration", "specifiers", "source", "attributes", "as\
sertions"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
    fields: Object.assign({
      declaration: {
        optional: !0,
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, S.chain)((0, S.assertNodeType)("Declaration"), Object.assign(function(t, e, r) {
          if (r && t.specifiers.length)
            throw new TypeError("Only declaration or specifiers is allowed on ExportNamedDeclaration");
          if (r && t.source)
            throw new TypeError("Cannot export a declaration from a source");
        }, {
          oneOfNodeTypes: ["Declaration"]
        })) : (0, S.assertNodeType)("Declaration")
      }
    }, Ks, {
      specifiers: {
        default: [],
        validate: (0, S.arrayOf)(function() {
          let t = (0, S.assertNodeType)("ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier"), e = (0, S.assertNodeType)(
          "ExportSpecifier");
          return process.env.BABEL_TYPES_8_BREAKING ? Object.assign(function(r, i, n) {
            (r.source ? t : e)(r, i, n);
          }, {
            oneOfNodeTypes: ["ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier"]
          }) : t;
        }())
      },
      source: {
        validate: (0, S.assertNodeType)("StringLiteral"),
        optional: !0
      },
      exportKind: (0, S.validateOptional)((0, S.assertOneOf)("type", "value"))
    })
  });
  R("ExportSpecifier", {
    visitor: ["local", "exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, S.assertNodeType)("Identifier")
      },
      exported: {
        validate: (0, S.assertNodeType)("Identifier", "StringLiteral")
      },
      exportKind: {
        validate: (0, S.assertOneOf)("type", "value"),
        optional: !0
      }
    }
  });
  R("ForOfStatement", {
    visitor: ["left", "right", "body"],
    builder: ["left", "right", "body", "await"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
    fields: {
      left: {
        validate: function() {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return (0, S.assertNodeType)("VariableDeclaration", "LVal");
          let t = (0, S.assertNodeType)("VariableDeclaration"), e = (0, S.assertNodeType)("Identifier", "MemberExpression", "ArrayPattern", "\
ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression");
          return Object.assign(function(r, i, n) {
            (0, $e.default)("VariableDeclaration", n) ? t(r, i, n) : e(r, i, n);
          }, {
            oneOfNodeTypes: ["VariableDeclaration", "Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TS\
SatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression"]
          });
        }()
      },
      right: {
        validate: (0, S.assertNodeType)("Expression")
      },
      body: {
        validate: (0, S.assertNodeType)("Statement")
      },
      await: {
        default: !1
      }
    }
  });
  R("ImportDeclaration", {
    builder: ["specifiers", "source"],
    visitor: ["specifiers", "source", "attributes", "assertions"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration"],
    fields: Object.assign({}, Ks, {
      module: {
        optional: !0,
        validate: (0, S.assertValueType)("boolean")
      },
      phase: {
        default: null,
        validate: (0, S.assertOneOf)("source", "defer")
      },
      specifiers: (0, S.validateArrayOfType)("ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier"),
      source: {
        validate: (0, S.assertNodeType)("StringLiteral")
      },
      importKind: {
        validate: (0, S.assertOneOf)("type", "typeof", "value"),
        optional: !0
      }
    })
  });
  R("ImportDefaultSpecifier", {
    visitor: ["local"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, S.assertNodeType)("Identifier")
      }
    }
  });
  R("ImportNamespaceSpecifier", {
    visitor: ["local"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, S.assertNodeType)("Identifier")
      }
    }
  });
  R("ImportSpecifier", {
    visitor: ["imported", "local"],
    builder: ["local", "imported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, S.assertNodeType)("Identifier")
      },
      imported: {
        validate: (0, S.assertNodeType)("Identifier", "StringLiteral")
      },
      importKind: {
        validate: (0, S.assertOneOf)("type", "typeof", "value"),
        optional: !0
      }
    }
  });
  R("ImportExpression", {
    visitor: ["source", "options"],
    aliases: ["Expression"],
    fields: {
      phase: {
        default: null,
        validate: (0, S.assertOneOf)("source", "defer")
      },
      source: {
        validate: (0, S.assertNodeType)("Expression")
      },
      options: {
        validate: (0, S.assertNodeType)("Expression"),
        optional: !0
      }
    }
  });
  R("MetaProperty", {
    visitor: ["meta", "property"],
    aliases: ["Expression"],
    fields: {
      meta: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, S.chain)((0, S.assertNodeType)("Identifier"), Object.assign(function(t, e, r) {
          let i;
          switch (r.name) {
            case "function":
              i = "sent";
              break;
            case "new":
              i = "target";
              break;
            case "import":
              i = "meta";
              break;
          }
          if (!(0, $e.default)("Identifier", t.property, {
            name: i
          }))
            throw new TypeError("Unrecognised MetaProperty");
        }, {
          oneOfNodeTypes: ["Identifier"]
        })) : (0, S.assertNodeType)("Identifier")
      },
      property: {
        validate: (0, S.assertNodeType)("Identifier")
      }
    }
  });
  var Pi = /* @__PURE__ */ s(() => ({
    abstract: {
      validate: (0, S.assertValueType)("boolean"),
      optional: !0
    },
    accessibility: {
      validate: (0, S.assertOneOf)("public", "private", "protected"),
      optional: !0
    },
    static: {
      default: !1
    },
    override: {
      default: !1
    },
    computed: {
      default: !1
    },
    optional: {
      validate: (0, S.assertValueType)("boolean"),
      optional: !0
    },
    key: {
      validate: (0, S.chain)(function() {
        let t = (0, S.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"), e = (0, S.assertNodeType)("Expressi\
on");
        return function(r, i, n) {
          (r.computed ? e : t)(r, i, n);
        };
      }(), (0, S.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression"))
    }
  }), "classMethodOrPropertyCommon");
  Ve.classMethodOrPropertyCommon = Pi;
  var Vs = /* @__PURE__ */ s(() => Object.assign({}, or(), Pi(), {
    params: (0, S.validateArrayOfType)("Identifier", "Pattern", "RestElement", "TSParameterProperty"),
    kind: {
      validate: (0, S.assertOneOf)("get", "set", "method", "constructor"),
      default: "method"
    },
    access: {
      validate: (0, S.chain)((0, S.assertValueType)("string"), (0, S.assertOneOf)("public", "private", "protected")),
      optional: !0
    },
    decorators: {
      validate: (0, S.arrayOfType)("Decorator"),
      optional: !0
    }
  }), "classMethodOrDeclareMethodCommon");
  Ve.classMethodOrDeclareMethodCommon = Vs;
  R("ClassMethod", {
    aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method"],
    builder: ["kind", "key", "params", "body", "computed", "static", "generator", "async"],
    visitor: ["decorators", "key", "typeParameters", "params", "returnType", "body"],
    fields: Object.assign({}, Vs(), Wt(), {
      body: {
        validate: (0, S.assertNodeType)("BlockStatement")
      }
    })
  });
  R("ObjectPattern", {
    visitor: ["properties", "typeAnnotation", "decorators"],
    builder: ["properties"],
    aliases: ["Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, lr(), {
      properties: (0, S.validateArrayOfType)("RestElement", "ObjectProperty")
    })
  });
  R("SpreadElement", {
    visitor: ["argument"],
    aliases: ["UnaryLike"],
    deprecatedAlias: "SpreadProperty",
    fields: {
      argument: {
        validate: (0, S.assertNodeType)("Expression")
      }
    }
  });
  R("Super", {
    aliases: ["Expression"]
  });
  R("TaggedTemplateExpression", {
    visitor: ["tag", "typeParameters", "quasi"],
    builder: ["tag", "quasi"],
    aliases: ["Expression"],
    fields: {
      tag: {
        validate: (0, S.assertNodeType)("Expression")
      },
      quasi: {
        validate: (0, S.assertNodeType)("TemplateLiteral")
      },
      typeParameters: {
        validate: (0, S.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: !0
      }
    }
  });
  R("TemplateElement", {
    builder: ["value", "tail"],
    fields: {
      value: {
        validate: (0, S.chain)((0, S.assertShape)({
          raw: {
            validate: (0, S.assertValueType)("string")
          },
          cooked: {
            validate: (0, S.assertValueType)("string"),
            optional: !0
          }
        }), /* @__PURE__ */ s(function(e) {
          let r = e.value.raw, i = !1, n = /* @__PURE__ */ s(() => {
            throw new Error("Internal @babel/types error.");
          }, "error"), {
            str: a,
            firstInvalidLoc: o
          } = (0, jS.readStringContents)("template", r, 0, 0, 0, {
            unterminated() {
              i = !0;
            },
            strictNumericEscape: n,
            invalidEscapeSequence: n,
            numericSeparatorInEscapeSequence: n,
            unexpectedNumericSeparator: n,
            invalidDigit: n,
            invalidCodePoint: n
          });
          if (!i) throw new Error("Invalid raw");
          e.value.cooked = o ? null : a;
        }, "templateElementCookedValidator"))
      },
      tail: {
        default: !1
      }
    }
  });
  R("TemplateLiteral", {
    visitor: ["quasis", "expressions"],
    aliases: ["Expression", "Literal"],
    fields: {
      quasis: (0, S.validateArrayOfType)("TemplateElement"),
      expressions: {
        validate: (0, S.chain)((0, S.assertValueType)("array"), (0, S.assertEach)((0, S.assertNodeType)("Expression", "TSType")), function(t, e, r) {
          if (t.quasis.length !== r.length + 1)
            throw new TypeError(`Number of ${t.type} quasis should be exactly one more than the number of expressions.
Expected ${r.length + 1} quasis but got ${t.quasis.length}`);
        })
      }
    }
  });
  R("YieldExpression", {
    builder: ["argument", "delegate"],
    visitor: ["argument"],
    aliases: ["Expression", "Terminatorless"],
    fields: {
      delegate: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, S.chain)((0, S.assertValueType)("boolean"), Object.assign(function(t, e, r) {
          if (r && !t.argument)
            throw new TypeError("Property delegate of YieldExpression cannot be true if there is no argument");
        }, {
          type: "boolean"
        })) : (0, S.assertValueType)("boolean"),
        default: !1
      },
      argument: {
        optional: !0,
        validate: (0, S.assertNodeType)("Expression")
      }
    }
  });
  R("AwaitExpression", {
    builder: ["argument"],
    visitor: ["argument"],
    aliases: ["Expression", "Terminatorless"],
    fields: {
      argument: {
        validate: (0, S.assertNodeType)("Expression")
      }
    }
  });
  R("Import", {
    aliases: ["Expression"]
  });
  R("BigIntLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, S.assertValueType)("string")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  R("ExportNamespaceSpecifier", {
    visitor: ["exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      exported: {
        validate: (0, S.assertNodeType)("Identifier")
      }
    }
  });
  R("OptionalMemberExpression", {
    builder: ["object", "property", "computed", "optional"],
    visitor: ["object", "property"],
    aliases: ["Expression"],
    fields: {
      object: {
        validate: (0, S.assertNodeType)("Expression")
      },
      property: {
        validate: function() {
          let t = (0, S.assertNodeType)("Identifier"), e = (0, S.assertNodeType)("Expression");
          return Object.assign(function(i, n, a) {
            (i.computed ? e : t)(i, n, a);
          }, {
            oneOfNodeTypes: ["Expression", "Identifier"]
          });
        }()
      },
      computed: {
        default: !1
      },
      optional: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, S.chain)((0, S.assertValueType)("boolean"), (0, S.assertOptionalChainStart)()) : (0, S.
        assertValueType)("boolean")
      }
    }
  });
  R("OptionalCallExpression", {
    visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
    builder: ["callee", "arguments", "optional"],
    aliases: ["Expression"],
    fields: Object.assign({
      callee: {
        validate: (0, S.assertNodeType)("Expression")
      },
      arguments: (0, S.validateArrayOfType)("Expression", "SpreadElement", "ArgumentPlaceholder"),
      optional: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, S.chain)((0, S.assertValueType)("boolean"), (0, S.assertOptionalChainStart)()) : (0, S.
        assertValueType)("boolean")
      },
      typeArguments: {
        validate: (0, S.assertNodeType)("TypeParameterInstantiation"),
        optional: !0
      }
    }, {
      typeParameters: {
        validate: (0, S.assertNodeType)("TSTypeParameterInstantiation"),
        optional: !0
      }
    })
  });
  R("ClassProperty", {
    visitor: ["decorators", "variance", "key", "typeAnnotation", "value"],
    builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
    aliases: ["Property"],
    fields: Object.assign({}, Pi(), {
      value: {
        validate: (0, S.assertNodeType)("Expression"),
        optional: !0
      },
      definite: {
        validate: (0, S.assertValueType)("boolean"),
        optional: !0
      },
      typeAnnotation: {
        validate: (0, S.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: !0
      },
      decorators: {
        validate: (0, S.arrayOfType)("Decorator"),
        optional: !0
      },
      readonly: {
        validate: (0, S.assertValueType)("boolean"),
        optional: !0
      },
      declare: {
        validate: (0, S.assertValueType)("boolean"),
        optional: !0
      },
      variance: {
        validate: (0, S.assertNodeType)("Variance"),
        optional: !0
      }
    })
  });
  R("ClassAccessorProperty", {
    visitor: ["decorators", "key", "typeAnnotation", "value"],
    builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
    aliases: ["Property", "Accessor"],
    fields: Object.assign({}, Pi(), {
      key: {
        validate: (0, S.chain)(function() {
          let t = (0, S.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "PrivateName"), e = (0, S.assertNodeType)(
          "Expression");
          return function(r, i, n) {
            (r.computed ? e : t)(r, i, n);
          };
        }(), (0, S.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression", "PrivateName"))
      },
      value: {
        validate: (0, S.assertNodeType)("Expression"),
        optional: !0
      },
      definite: {
        validate: (0, S.assertValueType)("boolean"),
        optional: !0
      },
      typeAnnotation: {
        validate: (0, S.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: !0
      },
      decorators: {
        validate: (0, S.arrayOfType)("Decorator"),
        optional: !0
      },
      readonly: {
        validate: (0, S.assertValueType)("boolean"),
        optional: !0
      },
      declare: {
        validate: (0, S.assertValueType)("boolean"),
        optional: !0
      },
      variance: {
        validate: (0, S.assertNodeType)("Variance"),
        optional: !0
      }
    })
  });
  R("ClassPrivateProperty", {
    visitor: ["decorators", "variance", "key", "typeAnnotation", "value"],
    builder: ["key", "value", "decorators", "static"],
    aliases: ["Property", "Private"],
    fields: {
      key: {
        validate: (0, S.assertNodeType)("PrivateName")
      },
      value: {
        validate: (0, S.assertNodeType)("Expression"),
        optional: !0
      },
      typeAnnotation: {
        validate: (0, S.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: !0
      },
      decorators: {
        validate: (0, S.arrayOfType)("Decorator"),
        optional: !0
      },
      static: {
        validate: (0, S.assertValueType)("boolean"),
        default: !1
      },
      readonly: {
        validate: (0, S.assertValueType)("boolean"),
        optional: !0
      },
      optional: {
        validate: (0, S.assertValueType)("boolean"),
        optional: !0
      },
      definite: {
        validate: (0, S.assertValueType)("boolean"),
        optional: !0
      },
      variance: {
        validate: (0, S.assertNodeType)("Variance"),
        optional: !0
      }
    }
  });
  R("ClassPrivateMethod", {
    builder: ["kind", "key", "params", "body", "static"],
    visitor: ["decorators", "key", "typeParameters", "params", "returnType", "body"],
    aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method", "Private"],
    fields: Object.assign({}, Vs(), Wt(), {
      kind: {
        validate: (0, S.assertOneOf)("get", "set", "method"),
        default: "method"
      },
      key: {
        validate: (0, S.assertNodeType)("PrivateName")
      },
      body: {
        validate: (0, S.assertNodeType)("BlockStatement")
      }
    })
  });
  R("PrivateName", {
    visitor: ["id"],
    aliases: ["Private"],
    fields: {
      id: {
        validate: (0, S.assertNodeType)("Identifier")
      }
    }
  });
  R("StaticBlock", {
    visitor: ["body"],
    fields: {
      body: (0, S.validateArrayOfType)("Statement")
    },
    aliases: ["Scopable", "BlockParent", "FunctionParent"]
  });
  R("ImportAttribute", {
    visitor: ["key", "value"],
    fields: {
      key: {
        validate: (0, S.assertNodeType)("Identifier", "StringLiteral")
      },
      value: {
        validate: (0, S.assertNodeType)("StringLiteral")
      }
    }
  });
});

// ../node_modules/@babel/types/lib/definitions/flow.js
var Il = D(() => {
  "use strict";
  var Al = kr(), A = bt(), ee = (0, A.defineAliasedType)("Flow"), Ys = /* @__PURE__ */ s((t) => {
    let e = t === "DeclareClass";
    ee(t, {
      builder: ["id", "typeParameters", "extends", "body"],
      visitor: ["id", "typeParameters", "extends", ...e ? ["mixins", "implements"] : [], "body"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: Object.assign({
        id: (0, A.validateType)("Identifier"),
        typeParameters: (0, A.validateOptionalType)("TypeParameterDeclaration"),
        extends: (0, A.validateOptional)((0, A.arrayOfType)("InterfaceExtends"))
      }, e ? {
        mixins: (0, A.validateOptional)((0, A.arrayOfType)("InterfaceExtends")),
        implements: (0, A.validateOptional)((0, A.arrayOfType)("ClassImplements"))
      } : {}, {
        body: (0, A.validateType)("ObjectTypeAnnotation")
      })
    });
  }, "defineInterfaceishType");
  ee("AnyTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  ee("ArrayTypeAnnotation", {
    visitor: ["elementType"],
    aliases: ["FlowType"],
    fields: {
      elementType: (0, A.validateType)("FlowType")
    }
  });
  ee("BooleanTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  ee("BooleanLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["FlowType"],
    fields: {
      value: (0, A.validate)((0, A.assertValueType)("boolean"))
    }
  });
  ee("NullLiteralTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  ee("ClassImplements", {
    visitor: ["id", "typeParameters"],
    fields: {
      id: (0, A.validateType)("Identifier"),
      typeParameters: (0, A.validateOptionalType)("TypeParameterInstantiation")
    }
  });
  Ys("DeclareClass");
  ee("DeclareFunction", {
    builder: ["id"],
    visitor: ["id", "predicate"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, A.validateType)("Identifier"),
      predicate: (0, A.validateOptionalType)("DeclaredPredicate")
    }
  });
  Ys("DeclareInterface");
  ee("DeclareModule", {
    builder: ["id", "body", "kind"],
    visitor: ["id", "body"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, A.validateType)("Identifier", "StringLiteral"),
      body: (0, A.validateType)("BlockStatement"),
      kind: (0, A.validateOptional)((0, A.assertOneOf)("CommonJS", "ES"))
    }
  });
  ee("DeclareModuleExports", {
    visitor: ["typeAnnotation"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      typeAnnotation: (0, A.validateType)("TypeAnnotation")
    }
  });
  ee("DeclareTypeAlias", {
    visitor: ["id", "typeParameters", "right"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, A.validateType)("Identifier"),
      typeParameters: (0, A.validateOptionalType)("TypeParameterDeclaration"),
      right: (0, A.validateType)("FlowType")
    }
  });
  ee("DeclareOpaqueType", {
    visitor: ["id", "typeParameters", "supertype"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, A.validateType)("Identifier"),
      typeParameters: (0, A.validateOptionalType)("TypeParameterDeclaration"),
      supertype: (0, A.validateOptionalType)("FlowType"),
      impltype: (0, A.validateOptionalType)("FlowType")
    }
  });
  ee("DeclareVariable", {
    visitor: ["id"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, A.validateType)("Identifier")
    }
  });
  ee("DeclareExportDeclaration", {
    visitor: ["declaration", "specifiers", "source", "attributes"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: Object.assign({
      declaration: (0, A.validateOptionalType)("Flow"),
      specifiers: (0, A.validateOptional)((0, A.arrayOfType)("ExportSpecifier", "ExportNamespaceSpecifier")),
      source: (0, A.validateOptionalType)("StringLiteral"),
      default: (0, A.validateOptional)((0, A.assertValueType)("boolean"))
    }, Al.importAttributes)
  });
  ee("DeclareExportAllDeclaration", {
    visitor: ["source", "attributes"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: Object.assign({
      source: (0, A.validateType)("StringLiteral"),
      exportKind: (0, A.validateOptional)((0, A.assertOneOf)("type", "value"))
    }, Al.importAttributes)
  });
  ee("DeclaredPredicate", {
    visitor: ["value"],
    aliases: ["FlowPredicate"],
    fields: {
      value: (0, A.validateType)("Flow")
    }
  });
  ee("ExistsTypeAnnotation", {
    aliases: ["FlowType"]
  });
  ee("FunctionTypeAnnotation", {
    builder: ["typeParameters", "params", "rest", "returnType"],
    visitor: ["typeParameters", "this", "params", "rest", "returnType"],
    aliases: ["FlowType"],
    fields: {
      typeParameters: (0, A.validateOptionalType)("TypeParameterDeclaration"),
      params: (0, A.validateArrayOfType)("FunctionTypeParam"),
      rest: (0, A.validateOptionalType)("FunctionTypeParam"),
      this: (0, A.validateOptionalType)("FunctionTypeParam"),
      returnType: (0, A.validateType)("FlowType")
    }
  });
  ee("FunctionTypeParam", {
    visitor: ["name", "typeAnnotation"],
    fields: {
      name: (0, A.validateOptionalType)("Identifier"),
      typeAnnotation: (0, A.validateType)("FlowType"),
      optional: (0, A.validateOptional)((0, A.assertValueType)("boolean"))
    }
  });
  ee("GenericTypeAnnotation", {
    visitor: ["id", "typeParameters"],
    aliases: ["FlowType"],
    fields: {
      id: (0, A.validateType)("Identifier", "QualifiedTypeIdentifier"),
      typeParameters: (0, A.validateOptionalType)("TypeParameterInstantiation")
    }
  });
  ee("InferredPredicate", {
    aliases: ["FlowPredicate"]
  });
  ee("InterfaceExtends", {
    visitor: ["id", "typeParameters"],
    fields: {
      id: (0, A.validateType)("Identifier", "QualifiedTypeIdentifier"),
      typeParameters: (0, A.validateOptionalType)("TypeParameterInstantiation")
    }
  });
  Ys("InterfaceDeclaration");
  ee("InterfaceTypeAnnotation", {
    visitor: ["extends", "body"],
    aliases: ["FlowType"],
    fields: {
      extends: (0, A.validateOptional)((0, A.arrayOfType)("InterfaceExtends")),
      body: (0, A.validateType)("ObjectTypeAnnotation")
    }
  });
  ee("IntersectionTypeAnnotation", {
    visitor: ["types"],
    aliases: ["FlowType"],
    fields: {
      types: (0, A.validate)((0, A.arrayOfType)("FlowType"))
    }
  });
  ee("MixedTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  ee("EmptyTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  ee("NullableTypeAnnotation", {
    visitor: ["typeAnnotation"],
    aliases: ["FlowType"],
    fields: {
      typeAnnotation: (0, A.validateType)("FlowType")
    }
  });
  ee("NumberLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["FlowType"],
    fields: {
      value: (0, A.validate)((0, A.assertValueType)("number"))
    }
  });
  ee("NumberTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  ee("ObjectTypeAnnotation", {
    visitor: ["properties", "indexers", "callProperties", "internalSlots"],
    aliases: ["FlowType"],
    builder: ["properties", "indexers", "callProperties", "internalSlots", "exact"],
    fields: {
      properties: (0, A.validate)((0, A.arrayOfType)("ObjectTypeProperty", "ObjectTypeSpreadProperty")),
      indexers: {
        validate: (0, A.arrayOfType)("ObjectTypeIndexer"),
        optional: !0,
        default: []
      },
      callProperties: {
        validate: (0, A.arrayOfType)("ObjectTypeCallProperty"),
        optional: !0,
        default: []
      },
      internalSlots: {
        validate: (0, A.arrayOfType)("ObjectTypeInternalSlot"),
        optional: !0,
        default: []
      },
      exact: {
        validate: (0, A.assertValueType)("boolean"),
        default: !1
      },
      inexact: (0, A.validateOptional)((0, A.assertValueType)("boolean"))
    }
  });
  ee("ObjectTypeInternalSlot", {
    visitor: ["id", "value"],
    builder: ["id", "value", "optional", "static", "method"],
    aliases: ["UserWhitespacable"],
    fields: {
      id: (0, A.validateType)("Identifier"),
      value: (0, A.validateType)("FlowType"),
      optional: (0, A.validate)((0, A.assertValueType)("boolean")),
      static: (0, A.validate)((0, A.assertValueType)("boolean")),
      method: (0, A.validate)((0, A.assertValueType)("boolean"))
    }
  });
  ee("ObjectTypeCallProperty", {
    visitor: ["value"],
    aliases: ["UserWhitespacable"],
    fields: {
      value: (0, A.validateType)("FlowType"),
      static: (0, A.validate)((0, A.assertValueType)("boolean"))
    }
  });
  ee("ObjectTypeIndexer", {
    visitor: ["variance", "id", "key", "value"],
    builder: ["id", "key", "value", "variance"],
    aliases: ["UserWhitespacable"],
    fields: {
      id: (0, A.validateOptionalType)("Identifier"),
      key: (0, A.validateType)("FlowType"),
      value: (0, A.validateType)("FlowType"),
      static: (0, A.validate)((0, A.assertValueType)("boolean")),
      variance: (0, A.validateOptionalType)("Variance")
    }
  });
  ee("ObjectTypeProperty", {
    visitor: ["key", "value", "variance"],
    aliases: ["UserWhitespacable"],
    fields: {
      key: (0, A.validateType)("Identifier", "StringLiteral"),
      value: (0, A.validateType)("FlowType"),
      kind: (0, A.validate)((0, A.assertOneOf)("init", "get", "set")),
      static: (0, A.validate)((0, A.assertValueType)("boolean")),
      proto: (0, A.validate)((0, A.assertValueType)("boolean")),
      optional: (0, A.validate)((0, A.assertValueType)("boolean")),
      variance: (0, A.validateOptionalType)("Variance"),
      method: (0, A.validate)((0, A.assertValueType)("boolean"))
    }
  });
  ee("ObjectTypeSpreadProperty", {
    visitor: ["argument"],
    aliases: ["UserWhitespacable"],
    fields: {
      argument: (0, A.validateType)("FlowType")
    }
  });
  ee("OpaqueType", {
    visitor: ["id", "typeParameters", "supertype", "impltype"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, A.validateType)("Identifier"),
      typeParameters: (0, A.validateOptionalType)("TypeParameterDeclaration"),
      supertype: (0, A.validateOptionalType)("FlowType"),
      impltype: (0, A.validateType)("FlowType")
    }
  });
  ee("QualifiedTypeIdentifier", {
    visitor: ["qualification", "id"],
    builder: ["id", "qualification"],
    fields: {
      id: (0, A.validateType)("Identifier"),
      qualification: (0, A.validateType)("Identifier", "QualifiedTypeIdentifier")
    }
  });
  ee("StringLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["FlowType"],
    fields: {
      value: (0, A.validate)((0, A.assertValueType)("string"))
    }
  });
  ee("StringTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  ee("SymbolTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  ee("ThisTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  ee("TupleTypeAnnotation", {
    visitor: ["types"],
    aliases: ["FlowType"],
    fields: {
      types: (0, A.validate)((0, A.arrayOfType)("FlowType"))
    }
  });
  ee("TypeofTypeAnnotation", {
    visitor: ["argument"],
    aliases: ["FlowType"],
    fields: {
      argument: (0, A.validateType)("FlowType")
    }
  });
  ee("TypeAlias", {
    visitor: ["id", "typeParameters", "right"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, A.validateType)("Identifier"),
      typeParameters: (0, A.validateOptionalType)("TypeParameterDeclaration"),
      right: (0, A.validateType)("FlowType")
    }
  });
  ee("TypeAnnotation", {
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, A.validateType)("FlowType")
    }
  });
  ee("TypeCastExpression", {
    visitor: ["expression", "typeAnnotation"],
    aliases: ["ExpressionWrapper", "Expression"],
    fields: {
      expression: (0, A.validateType)("Expression"),
      typeAnnotation: (0, A.validateType)("TypeAnnotation")
    }
  });
  ee("TypeParameter", {
    visitor: ["bound", "default", "variance"],
    fields: {
      name: (0, A.validate)((0, A.assertValueType)("string")),
      bound: (0, A.validateOptionalType)("TypeAnnotation"),
      default: (0, A.validateOptionalType)("FlowType"),
      variance: (0, A.validateOptionalType)("Variance")
    }
  });
  ee("TypeParameterDeclaration", {
    visitor: ["params"],
    fields: {
      params: (0, A.validate)((0, A.arrayOfType)("TypeParameter"))
    }
  });
  ee("TypeParameterInstantiation", {
    visitor: ["params"],
    fields: {
      params: (0, A.validate)((0, A.arrayOfType)("FlowType"))
    }
  });
  ee("UnionTypeAnnotation", {
    visitor: ["types"],
    aliases: ["FlowType"],
    fields: {
      types: (0, A.validate)((0, A.arrayOfType)("FlowType"))
    }
  });
  ee("Variance", {
    builder: ["kind"],
    fields: {
      kind: (0, A.validate)((0, A.assertOneOf)("minus", "plus"))
    }
  });
  ee("VoidTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  ee("EnumDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "body"],
    fields: {
      id: (0, A.validateType)("Identifier"),
      body: (0, A.validateType)("EnumBooleanBody", "EnumNumberBody", "EnumStringBody", "EnumSymbolBody")
    }
  });
  ee("EnumBooleanBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: (0, A.validate)((0, A.assertValueType)("boolean")),
      members: (0, A.validateArrayOfType)("EnumBooleanMember"),
      hasUnknownMembers: (0, A.validate)((0, A.assertValueType)("boolean"))
    }
  });
  ee("EnumNumberBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: (0, A.validate)((0, A.assertValueType)("boolean")),
      members: (0, A.validateArrayOfType)("EnumNumberMember"),
      hasUnknownMembers: (0, A.validate)((0, A.assertValueType)("boolean"))
    }
  });
  ee("EnumStringBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: (0, A.validate)((0, A.assertValueType)("boolean")),
      members: (0, A.validateArrayOfType)("EnumStringMember", "EnumDefaultedMember"),
      hasUnknownMembers: (0, A.validate)((0, A.assertValueType)("boolean"))
    }
  });
  ee("EnumSymbolBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      members: (0, A.validateArrayOfType)("EnumDefaultedMember"),
      hasUnknownMembers: (0, A.validate)((0, A.assertValueType)("boolean"))
    }
  });
  ee("EnumBooleanMember", {
    aliases: ["EnumMember"],
    builder: ["id"],
    visitor: ["id", "init"],
    fields: {
      id: (0, A.validateType)("Identifier"),
      init: (0, A.validateType)("BooleanLiteral")
    }
  });
  ee("EnumNumberMember", {
    aliases: ["EnumMember"],
    visitor: ["id", "init"],
    fields: {
      id: (0, A.validateType)("Identifier"),
      init: (0, A.validateType)("NumericLiteral")
    }
  });
  ee("EnumStringMember", {
    aliases: ["EnumMember"],
    visitor: ["id", "init"],
    fields: {
      id: (0, A.validateType)("Identifier"),
      init: (0, A.validateType)("StringLiteral")
    }
  });
  ee("EnumDefaultedMember", {
    aliases: ["EnumMember"],
    visitor: ["id"],
    fields: {
      id: (0, A.validateType)("Identifier")
    }
  });
  ee("IndexedAccessType", {
    visitor: ["objectType", "indexType"],
    aliases: ["FlowType"],
    fields: {
      objectType: (0, A.validateType)("FlowType"),
      indexType: (0, A.validateType)("FlowType")
    }
  });
  ee("OptionalIndexedAccessType", {
    visitor: ["objectType", "indexType"],
    aliases: ["FlowType"],
    fields: {
      objectType: (0, A.validateType)("FlowType"),
      indexType: (0, A.validateType)("FlowType"),
      optional: (0, A.validate)((0, A.assertValueType)("boolean"))
    }
  });
});

// ../node_modules/@babel/types/lib/definitions/jsx.js
var vl = D(() => {
  "use strict";
  var ke = bt(), ze = (0, ke.defineAliasedType)("JSX");
  ze("JSXAttribute", {
    visitor: ["name", "value"],
    aliases: ["Immutable"],
    fields: {
      name: {
        validate: (0, ke.assertNodeType)("JSXIdentifier", "JSXNamespacedName")
      },
      value: {
        optional: !0,
        validate: (0, ke.assertNodeType)("JSXElement", "JSXFragment", "StringLiteral", "JSXExpressionContainer")
      }
    }
  });
  ze("JSXClosingElement", {
    visitor: ["name"],
    aliases: ["Immutable"],
    fields: {
      name: {
        validate: (0, ke.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
      }
    }
  });
  ze("JSXElement", {
    builder: ["openingElement", "closingElement", "children", "selfClosing"],
    visitor: ["openingElement", "children", "closingElement"],
    aliases: ["Immutable", "Expression"],
    fields: Object.assign({
      openingElement: {
        validate: (0, ke.assertNodeType)("JSXOpeningElement")
      },
      closingElement: {
        optional: !0,
        validate: (0, ke.assertNodeType)("JSXClosingElement")
      },
      children: (0, ke.validateArrayOfType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")
    }, {
      selfClosing: {
        validate: (0, ke.assertValueType)("boolean"),
        optional: !0
      }
    })
  });
  ze("JSXEmptyExpression", {});
  ze("JSXExpressionContainer", {
    visitor: ["expression"],
    aliases: ["Immutable"],
    fields: {
      expression: {
        validate: (0, ke.assertNodeType)("Expression", "JSXEmptyExpression")
      }
    }
  });
  ze("JSXSpreadChild", {
    visitor: ["expression"],
    aliases: ["Immutable"],
    fields: {
      expression: {
        validate: (0, ke.assertNodeType)("Expression")
      }
    }
  });
  ze("JSXIdentifier", {
    builder: ["name"],
    fields: {
      name: {
        validate: (0, ke.assertValueType)("string")
      }
    }
  });
  ze("JSXMemberExpression", {
    visitor: ["object", "property"],
    fields: {
      object: {
        validate: (0, ke.assertNodeType)("JSXMemberExpression", "JSXIdentifier")
      },
      property: {
        validate: (0, ke.assertNodeType)("JSXIdentifier")
      }
    }
  });
  ze("JSXNamespacedName", {
    visitor: ["namespace", "name"],
    fields: {
      namespace: {
        validate: (0, ke.assertNodeType)("JSXIdentifier")
      },
      name: {
        validate: (0, ke.assertNodeType)("JSXIdentifier")
      }
    }
  });
  ze("JSXOpeningElement", {
    builder: ["name", "attributes", "selfClosing"],
    visitor: ["name", "typeParameters", "typeArguments", "attributes"],
    aliases: ["Immutable"],
    fields: Object.assign({
      name: {
        validate: (0, ke.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
      },
      selfClosing: {
        default: !1
      },
      attributes: (0, ke.validateArrayOfType)("JSXAttribute", "JSXSpreadAttribute"),
      typeArguments: {
        validate: (0, ke.assertNodeType)("TypeParameterInstantiation"),
        optional: !0
      }
    }, {
      typeParameters: {
        validate: (0, ke.assertNodeType)("TSTypeParameterInstantiation"),
        optional: !0
      }
    })
  });
  ze("JSXSpreadAttribute", {
    visitor: ["argument"],
    fields: {
      argument: {
        validate: (0, ke.assertNodeType)("Expression")
      }
    }
  });
  ze("JSXText", {
    aliases: ["Immutable"],
    builder: ["value"],
    fields: {
      value: {
        validate: (0, ke.assertValueType)("string")
      }
    }
  });
  ze("JSXFragment", {
    builder: ["openingFragment", "closingFragment", "children"],
    visitor: ["openingFragment", "children", "closingFragment"],
    aliases: ["Immutable", "Expression"],
    fields: {
      openingFragment: {
        validate: (0, ke.assertNodeType)("JSXOpeningFragment")
      },
      closingFragment: {
        validate: (0, ke.assertNodeType)("JSXClosingFragment")
      },
      children: (0, ke.validateArrayOfType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")
    }
  });
  ze("JSXOpeningFragment", {
    aliases: ["Immutable"]
  });
  ze("JSXClosingFragment", {
    aliases: ["Immutable"]
  });
});

// ../node_modules/@babel/types/lib/definitions/placeholders.js
var Ws = D((Lt) => {
  "use strict";
  Object.defineProperty(Lt, "__esModule", {
    value: !0
  });
  Lt.PLACEHOLDERS_FLIPPED_ALIAS = Lt.PLACEHOLDERS_ALIAS = Lt.PLACEHOLDERS = void 0;
  var FS = bt(), RS = Lt.PLACEHOLDERS = ["Identifier", "StringLiteral", "Expression", "Statement", "Declaration", "BlockStatement", "ClassBo\
dy", "Pattern"], Xs = Lt.PLACEHOLDERS_ALIAS = {
    Declaration: ["Statement"],
    Pattern: ["PatternLike", "LVal"]
  };
  for (let t of RS) {
    let e = FS.ALIAS_KEYS[t];
    e != null && e.length && (Xs[t] = e);
  }
  var Js = Lt.PLACEHOLDERS_FLIPPED_ALIAS = {};
  Object.keys(Xs).forEach((t) => {
    Xs[t].forEach((e) => {
      hasOwnProperty.call(Js, e) || (Js[e] = []), Js[e].push(t);
    });
  });
});

// ../node_modules/@babel/types/lib/definitions/misc.js
var Cl = D(() => {
  "use strict";
  var Ai = bt(), qS = Ws(), US = kr(), $s = (0, Ai.defineAliasedType)("Miscellaneous");
  $s("Noop", {
    visitor: []
  });
  $s("Placeholder", {
    visitor: [],
    builder: ["expectedNode", "name"],
    fields: Object.assign({
      name: {
        validate: (0, Ai.assertNodeType)("Identifier")
      },
      expectedNode: {
        validate: (0, Ai.assertOneOf)(...qS.PLACEHOLDERS)
      }
    }, (0, US.patternLikeCommon)())
  });
  $s("V8IntrinsicIdentifier", {
    builder: ["name"],
    fields: {
      name: {
        validate: (0, Ai.assertValueType)("string")
      }
    }
  });
});

// ../node_modules/@babel/types/lib/definitions/experimental.js
var wl = D(() => {
  "use strict";
  var _e = bt();
  (0, _e.default)("ArgumentPlaceholder", {});
  (0, _e.default)("BindExpression", {
    visitor: ["object", "callee"],
    aliases: ["Expression"],
    fields: process.env.BABEL_TYPES_8_BREAKING ? {
      object: {
        validate: (0, _e.assertNodeType)("Expression")
      },
      callee: {
        validate: (0, _e.assertNodeType)("Expression")
      }
    } : {
      object: {
        validate: Object.assign(() => {
        }, {
          oneOfNodeTypes: ["Expression"]
        })
      },
      callee: {
        validate: Object.assign(() => {
        }, {
          oneOfNodeTypes: ["Expression"]
        })
      }
    }
  });
  (0, _e.default)("Decorator", {
    visitor: ["expression"],
    fields: {
      expression: {
        validate: (0, _e.assertNodeType)("Expression")
      }
    }
  });
  (0, _e.default)("DoExpression", {
    visitor: ["body"],
    builder: ["body", "async"],
    aliases: ["Expression"],
    fields: {
      body: {
        validate: (0, _e.assertNodeType)("BlockStatement")
      },
      async: {
        validate: (0, _e.assertValueType)("boolean"),
        default: !1
      }
    }
  });
  (0, _e.default)("ExportDefaultSpecifier", {
    visitor: ["exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      exported: {
        validate: (0, _e.assertNodeType)("Identifier")
      }
    }
  });
  (0, _e.default)("RecordExpression", {
    visitor: ["properties"],
    aliases: ["Expression"],
    fields: {
      properties: (0, _e.validateArrayOfType)("ObjectProperty", "SpreadElement")
    }
  });
  (0, _e.default)("TupleExpression", {
    fields: {
      elements: {
        validate: (0, _e.arrayOfType)("Expression", "SpreadElement"),
        default: []
      }
    },
    visitor: ["elements"],
    aliases: ["Expression"]
  });
  (0, _e.default)("DecimalLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, _e.assertValueType)("string")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  (0, _e.default)("ModuleExpression", {
    visitor: ["body"],
    fields: {
      body: {
        validate: (0, _e.assertNodeType)("Program")
      }
    },
    aliases: ["Expression"]
  });
  (0, _e.default)("TopicReference", {
    aliases: ["Expression"]
  });
  (0, _e.default)("PipelineTopicExpression", {
    builder: ["expression"],
    visitor: ["expression"],
    fields: {
      expression: {
        validate: (0, _e.assertNodeType)("Expression")
      }
    },
    aliases: ["Expression"]
  });
  (0, _e.default)("PipelineBareFunction", {
    builder: ["callee"],
    visitor: ["callee"],
    fields: {
      callee: {
        validate: (0, _e.assertNodeType)("Expression")
      }
    },
    aliases: ["Expression"]
  });
  (0, _e.default)("PipelinePrimaryTopicReference", {
    aliases: ["Expression"]
  });
});

// ../node_modules/@babel/types/lib/definitions/typescript.js
var Bl = D(() => {
  "use strict";
  var N = bt(), Nl = kr(), KS = sr(), ie = (0, N.defineAliasedType)("TypeScript"), tt = (0, N.assertValueType)("boolean"), Ol = /* @__PURE__ */ s(
  () => ({
    returnType: {
      validate: (0, N.assertNodeType)("TSTypeAnnotation", "Noop"),
      optional: !0
    },
    typeParameters: {
      validate: (0, N.assertNodeType)("TSTypeParameterDeclaration", "Noop"),
      optional: !0
    }
  }), "tSFunctionTypeAnnotationCommon");
  ie("TSParameterProperty", {
    aliases: ["LVal"],
    visitor: ["parameter"],
    fields: {
      accessibility: {
        validate: (0, N.assertOneOf)("public", "private", "protected"),
        optional: !0
      },
      readonly: {
        validate: (0, N.assertValueType)("boolean"),
        optional: !0
      },
      parameter: {
        validate: (0, N.assertNodeType)("Identifier", "AssignmentPattern")
      },
      override: {
        validate: (0, N.assertValueType)("boolean"),
        optional: !0
      },
      decorators: {
        validate: (0, N.arrayOfType)("Decorator"),
        optional: !0
      }
    }
  });
  ie("TSDeclareFunction", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "params", "returnType"],
    fields: Object.assign({}, (0, Nl.functionDeclarationCommon)(), Ol())
  });
  ie("TSDeclareMethod", {
    visitor: ["decorators", "key", "typeParameters", "params", "returnType"],
    fields: Object.assign({}, (0, Nl.classMethodOrDeclareMethodCommon)(), Ol())
  });
  ie("TSQualifiedName", {
    aliases: ["TSEntityName"],
    visitor: ["left", "right"],
    fields: {
      left: (0, N.validateType)("TSEntityName"),
      right: (0, N.validateType)("Identifier")
    }
  });
  var Ii = /* @__PURE__ */ s(() => ({
    typeParameters: (0, N.validateOptionalType)("TSTypeParameterDeclaration"),
    parameters: (0, N.validateArrayOfType)("ArrayPattern", "Identifier", "ObjectPattern", "RestElement"),
    typeAnnotation: (0, N.validateOptionalType)("TSTypeAnnotation")
  }), "signatureDeclarationCommon"), _l = {
    aliases: ["TSTypeElement"],
    visitor: ["typeParameters", "parameters", "typeAnnotation"],
    fields: Ii()
  };
  ie("TSCallSignatureDeclaration", _l);
  ie("TSConstructSignatureDeclaration", _l);
  var Dl = /* @__PURE__ */ s(() => ({
    key: (0, N.validateType)("Expression"),
    computed: {
      default: !1
    },
    optional: (0, N.validateOptional)(tt)
  }), "namedTypeElementCommon");
  ie("TSPropertySignature", {
    aliases: ["TSTypeElement"],
    visitor: ["key", "typeAnnotation"],
    fields: Object.assign({}, Dl(), {
      readonly: (0, N.validateOptional)(tt),
      typeAnnotation: (0, N.validateOptionalType)("TSTypeAnnotation"),
      kind: {
        optional: !0,
        validate: (0, N.assertOneOf)("get", "set")
      }
    })
  });
  ie("TSMethodSignature", {
    aliases: ["TSTypeElement"],
    visitor: ["key", "typeParameters", "parameters", "typeAnnotation"],
    fields: Object.assign({}, Ii(), Dl(), {
      kind: {
        validate: (0, N.assertOneOf)("method", "get", "set")
      }
    })
  });
  ie("TSIndexSignature", {
    aliases: ["TSTypeElement"],
    visitor: ["parameters", "typeAnnotation"],
    fields: {
      readonly: (0, N.validateOptional)(tt),
      static: (0, N.validateOptional)(tt),
      parameters: (0, N.validateArrayOfType)("Identifier"),
      typeAnnotation: (0, N.validateOptionalType)("TSTypeAnnotation")
    }
  });
  var VS = ["TSAnyKeyword", "TSBooleanKeyword", "TSBigIntKeyword", "TSIntrinsicKeyword", "TSNeverKeyword", "TSNullKeyword", "TSNumberKeyword",
  "TSObjectKeyword", "TSStringKeyword", "TSSymbolKeyword", "TSUndefinedKeyword", "TSUnknownKeyword", "TSVoidKeyword"];
  for (let t of VS)
    ie(t, {
      aliases: ["TSType", "TSBaseType"],
      visitor: [],
      fields: {}
    });
  ie("TSThisType", {
    aliases: ["TSType", "TSBaseType"],
    visitor: [],
    fields: {}
  });
  var kl = {
    aliases: ["TSType"],
    visitor: ["typeParameters", "parameters", "typeAnnotation"]
  };
  ie("TSFunctionType", Object.assign({}, kl, {
    fields: Ii()
  }));
  ie("TSConstructorType", Object.assign({}, kl, {
    fields: Object.assign({}, Ii(), {
      abstract: (0, N.validateOptional)(tt)
    })
  }));
  ie("TSTypeReference", {
    aliases: ["TSType"],
    visitor: ["typeName", "typeParameters"],
    fields: {
      typeName: (0, N.validateType)("TSEntityName"),
      typeParameters: (0, N.validateOptionalType)("TSTypeParameterInstantiation")
    }
  });
  ie("TSTypePredicate", {
    aliases: ["TSType"],
    visitor: ["parameterName", "typeAnnotation"],
    builder: ["parameterName", "typeAnnotation", "asserts"],
    fields: {
      parameterName: (0, N.validateType)("Identifier", "TSThisType"),
      typeAnnotation: (0, N.validateOptionalType)("TSTypeAnnotation"),
      asserts: (0, N.validateOptional)(tt)
    }
  });
  ie("TSTypeQuery", {
    aliases: ["TSType"],
    visitor: ["exprName", "typeParameters"],
    fields: {
      exprName: (0, N.validateType)("TSEntityName", "TSImportType"),
      typeParameters: (0, N.validateOptionalType)("TSTypeParameterInstantiation")
    }
  });
  ie("TSTypeLiteral", {
    aliases: ["TSType"],
    visitor: ["members"],
    fields: {
      members: (0, N.validateArrayOfType)("TSTypeElement")
    }
  });
  ie("TSArrayType", {
    aliases: ["TSType"],
    visitor: ["elementType"],
    fields: {
      elementType: (0, N.validateType)("TSType")
    }
  });
  ie("TSTupleType", {
    aliases: ["TSType"],
    visitor: ["elementTypes"],
    fields: {
      elementTypes: (0, N.validateArrayOfType)("TSType", "TSNamedTupleMember")
    }
  });
  ie("TSOptionalType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, N.validateType)("TSType")
    }
  });
  ie("TSRestType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, N.validateType)("TSType")
    }
  });
  ie("TSNamedTupleMember", {
    visitor: ["label", "elementType"],
    builder: ["label", "elementType", "optional"],
    fields: {
      label: (0, N.validateType)("Identifier"),
      optional: {
        validate: tt,
        default: !1
      },
      elementType: (0, N.validateType)("TSType")
    }
  });
  var Ll = {
    aliases: ["TSType"],
    visitor: ["types"],
    fields: {
      types: (0, N.validateArrayOfType)("TSType")
    }
  };
  ie("TSUnionType", Ll);
  ie("TSIntersectionType", Ll);
  ie("TSConditionalType", {
    aliases: ["TSType"],
    visitor: ["checkType", "extendsType", "trueType", "falseType"],
    fields: {
      checkType: (0, N.validateType)("TSType"),
      extendsType: (0, N.validateType)("TSType"),
      trueType: (0, N.validateType)("TSType"),
      falseType: (0, N.validateType)("TSType")
    }
  });
  ie("TSInferType", {
    aliases: ["TSType"],
    visitor: ["typeParameter"],
    fields: {
      typeParameter: (0, N.validateType)("TSTypeParameter")
    }
  });
  ie("TSParenthesizedType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, N.validateType)("TSType")
    }
  });
  ie("TSTypeOperator", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      operator: (0, N.validate)((0, N.assertValueType)("string")),
      typeAnnotation: (0, N.validateType)("TSType")
    }
  });
  ie("TSIndexedAccessType", {
    aliases: ["TSType"],
    visitor: ["objectType", "indexType"],
    fields: {
      objectType: (0, N.validateType)("TSType"),
      indexType: (0, N.validateType)("TSType")
    }
  });
  ie("TSMappedType", {
    aliases: ["TSType"],
    visitor: ["typeParameter", "nameType", "typeAnnotation"],
    builder: ["typeParameter", "typeAnnotation", "nameType"],
    fields: Object.assign({}, {
      typeParameter: (0, N.validateType)("TSTypeParameter")
    }, {
      readonly: (0, N.validateOptional)((0, N.assertOneOf)(!0, !1, "+", "-")),
      optional: (0, N.validateOptional)((0, N.assertOneOf)(!0, !1, "+", "-")),
      typeAnnotation: (0, N.validateOptionalType)("TSType"),
      nameType: (0, N.validateOptionalType)("TSType")
    })
  });
  ie("TSTemplateLiteralType", {
    aliases: ["TSType", "TSBaseType"],
    visitor: ["quasis", "types"],
    fields: {
      quasis: (0, N.validateArrayOfType)("TemplateElement"),
      types: {
        validate: (0, N.chain)((0, N.assertValueType)("array"), (0, N.assertEach)((0, N.assertNodeType)("TSType")), function(t, e, r) {
          if (t.quasis.length !== r.length + 1)
            throw new TypeError(`Number of ${t.type} quasis should be exactly one more than the number of types.
Expected ${r.length + 1} quasis but got ${t.quasis.length}`);
        })
      }
    }
  });
  ie("TSLiteralType", {
    aliases: ["TSType", "TSBaseType"],
    visitor: ["literal"],
    fields: {
      literal: {
        validate: function() {
          let t = (0, N.assertNodeType)("NumericLiteral", "BigIntLiteral"), e = (0, N.assertOneOf)("-"), r = (0, N.assertNodeType)("NumericL\
iteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral");
          function i(n, a, o) {
            (0, KS.default)("UnaryExpression", o) ? (e(o, "operator", o.operator), t(o, "argument", o.argument)) : r(n, a, o);
          }
          return s(i, "validator"), i.oneOfNodeTypes = ["NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiter\
al", "UnaryExpression"], i;
        }()
      }
    }
  });
  ie("TSExpressionWithTypeArguments", {
    aliases: ["TSType"],
    visitor: ["expression", "typeParameters"],
    fields: {
      expression: (0, N.validateType)("TSEntityName"),
      typeParameters: (0, N.validateOptionalType)("TSTypeParameterInstantiation")
    }
  });
  ie("TSInterfaceDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "extends", "body"],
    fields: {
      declare: (0, N.validateOptional)(tt),
      id: (0, N.validateType)("Identifier"),
      typeParameters: (0, N.validateOptionalType)("TSTypeParameterDeclaration"),
      extends: (0, N.validateOptional)((0, N.arrayOfType)("TSExpressionWithTypeArguments")),
      body: (0, N.validateType)("TSInterfaceBody")
    }
  });
  ie("TSInterfaceBody", {
    visitor: ["body"],
    fields: {
      body: (0, N.validateArrayOfType)("TSTypeElement")
    }
  });
  ie("TSTypeAliasDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "typeAnnotation"],
    fields: {
      declare: (0, N.validateOptional)(tt),
      id: (0, N.validateType)("Identifier"),
      typeParameters: (0, N.validateOptionalType)("TSTypeParameterDeclaration"),
      typeAnnotation: (0, N.validateType)("TSType")
    }
  });
  ie("TSInstantiationExpression", {
    aliases: ["Expression"],
    visitor: ["expression", "typeParameters"],
    fields: {
      expression: (0, N.validateType)("Expression"),
      typeParameters: (0, N.validateOptionalType)("TSTypeParameterInstantiation")
    }
  });
  var Ml = {
    aliases: ["Expression", "LVal", "PatternLike"],
    visitor: ["expression", "typeAnnotation"],
    fields: {
      expression: (0, N.validateType)("Expression"),
      typeAnnotation: (0, N.validateType)("TSType")
    }
  };
  ie("TSAsExpression", Ml);
  ie("TSSatisfiesExpression", Ml);
  ie("TSTypeAssertion", {
    aliases: ["Expression", "LVal", "PatternLike"],
    visitor: ["typeAnnotation", "expression"],
    fields: {
      typeAnnotation: (0, N.validateType)("TSType"),
      expression: (0, N.validateType)("Expression")
    }
  });
  ie("TSEnumBody", {
    visitor: ["members"],
    fields: {
      members: (0, N.validateArrayOfType)("TSEnumMember")
    }
  });
  ie("TSEnumDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "members"],
    fields: {
      declare: (0, N.validateOptional)(tt),
      const: (0, N.validateOptional)(tt),
      id: (0, N.validateType)("Identifier"),
      members: (0, N.validateArrayOfType)("TSEnumMember"),
      initializer: (0, N.validateOptionalType)("Expression"),
      body: (0, N.validateOptionalType)("TSEnumBody")
    }
  });
  ie("TSEnumMember", {
    visitor: ["id", "initializer"],
    fields: {
      id: (0, N.validateType)("Identifier", "StringLiteral"),
      initializer: (0, N.validateOptionalType)("Expression")
    }
  });
  ie("TSModuleDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "body"],
    fields: Object.assign({
      kind: {
        validate: (0, N.assertOneOf)("global", "module", "namespace")
      },
      declare: (0, N.validateOptional)(tt)
    }, {
      global: (0, N.validateOptional)(tt)
    }, {
      id: (0, N.validateType)("Identifier", "StringLiteral"),
      body: (0, N.validateType)("TSModuleBlock", "TSModuleDeclaration")
    })
  });
  ie("TSModuleBlock", {
    aliases: ["Scopable", "Block", "BlockParent", "FunctionParent"],
    visitor: ["body"],
    fields: {
      body: (0, N.validateArrayOfType)("Statement")
    }
  });
  ie("TSImportType", {
    aliases: ["TSType"],
    builder: ["argument", "qualifier", "typeParameters"],
    visitor: ["argument", "options", "qualifier", "typeParameters"],
    fields: {
      argument: (0, N.validateType)("StringLiteral"),
      qualifier: (0, N.validateOptionalType)("TSEntityName"),
      typeParameters: (0, N.validateOptionalType)("TSTypeParameterInstantiation"),
      options: {
        validate: (0, N.assertNodeType)("Expression"),
        optional: !0
      }
    }
  });
  ie("TSImportEqualsDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "moduleReference"],
    fields: Object.assign({}, {
      isExport: (0, N.validate)(tt)
    }, {
      id: (0, N.validateType)("Identifier"),
      moduleReference: (0, N.validateType)("TSEntityName", "TSExternalModuleReference"),
      importKind: {
        validate: (0, N.assertOneOf)("type", "value"),
        optional: !0
      }
    })
  });
  ie("TSExternalModuleReference", {
    visitor: ["expression"],
    fields: {
      expression: (0, N.validateType)("StringLiteral")
    }
  });
  ie("TSNonNullExpression", {
    aliases: ["Expression", "LVal", "PatternLike"],
    visitor: ["expression"],
    fields: {
      expression: (0, N.validateType)("Expression")
    }
  });
  ie("TSExportAssignment", {
    aliases: ["Statement"],
    visitor: ["expression"],
    fields: {
      expression: (0, N.validateType)("Expression")
    }
  });
  ie("TSNamespaceExportDeclaration", {
    aliases: ["Statement"],
    visitor: ["id"],
    fields: {
      id: (0, N.validateType)("Identifier")
    }
  });
  ie("TSTypeAnnotation", {
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: {
        validate: (0, N.assertNodeType)("TSType")
      }
    }
  });
  ie("TSTypeParameterInstantiation", {
    visitor: ["params"],
    fields: {
      params: (0, N.validateArrayOfType)("TSType")
    }
  });
  ie("TSTypeParameterDeclaration", {
    visitor: ["params"],
    fields: {
      params: (0, N.validateArrayOfType)("TSTypeParameter")
    }
  });
  ie("TSTypeParameter", {
    builder: ["constraint", "default", "name"],
    visitor: ["constraint", "default"],
    fields: {
      name: {
        validate: (0, N.assertValueType)("string")
      },
      in: {
        validate: (0, N.assertValueType)("boolean"),
        optional: !0
      },
      out: {
        validate: (0, N.assertValueType)("boolean"),
        optional: !0
      },
      const: {
        validate: (0, N.assertValueType)("boolean"),
        optional: !0
      },
      constraint: {
        validate: (0, N.assertNodeType)("TSType"),
        optional: !0
      },
      default: {
        validate: (0, N.assertNodeType)("TSType"),
        optional: !0
      }
    }
  });
});

// ../node_modules/@babel/types/lib/definitions/deprecated-aliases.js
var jl = D((vi) => {
  "use strict";
  Object.defineProperty(vi, "__esModule", {
    value: !0
  });
  vi.DEPRECATED_ALIASES = void 0;
  var OF = vi.DEPRECATED_ALIASES = {
    ModuleDeclaration: "ImportOrExportDeclaration"
  };
});

// ../node_modules/@babel/types/lib/definitions/index.js
var ot = D((He) => {
  "use strict";
  Object.defineProperty(He, "__esModule", {
    value: !0
  });
  Object.defineProperty(He, "ALIAS_KEYS", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return rt.ALIAS_KEYS;
    }, "get")
  });
  Object.defineProperty(He, "BUILDER_KEYS", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return rt.BUILDER_KEYS;
    }, "get")
  });
  Object.defineProperty(He, "DEPRECATED_ALIASES", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return zs.DEPRECATED_ALIASES;
    }, "get")
  });
  Object.defineProperty(He, "DEPRECATED_KEYS", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return rt.DEPRECATED_KEYS;
    }, "get")
  });
  Object.defineProperty(He, "FLIPPED_ALIAS_KEYS", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return rt.FLIPPED_ALIAS_KEYS;
    }, "get")
  });
  Object.defineProperty(He, "NODE_FIELDS", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return rt.NODE_FIELDS;
    }, "get")
  });
  Object.defineProperty(He, "NODE_PARENT_VALIDATIONS", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return rt.NODE_PARENT_VALIDATIONS;
    }, "get")
  });
  Object.defineProperty(He, "PLACEHOLDERS", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Hs.PLACEHOLDERS;
    }, "get")
  });
  Object.defineProperty(He, "PLACEHOLDERS_ALIAS", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Hs.PLACEHOLDERS_ALIAS;
    }, "get")
  });
  Object.defineProperty(He, "PLACEHOLDERS_FLIPPED_ALIAS", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Hs.PLACEHOLDERS_FLIPPED_ALIAS;
    }, "get")
  });
  He.TYPES = void 0;
  Object.defineProperty(He, "VISITOR_KEYS", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return rt.VISITOR_KEYS;
    }, "get")
  });
  kr();
  Il();
  vl();
  Cl();
  wl();
  Bl();
  var rt = bt(), Hs = Ws(), zs = jl();
  Object.keys(zs.DEPRECATED_ALIASES).forEach((t) => {
    rt.FLIPPED_ALIAS_KEYS[t] = rt.FLIPPED_ALIAS_KEYS[zs.DEPRECATED_ALIASES[t]];
  });
  for (let {
    types: t,
    set: e
  } of rt.allExpandedTypes)
    for (let r of t) {
      let i = rt.FLIPPED_ALIAS_KEYS[r];
      i ? i.forEach(e.add, e) : e.add(r);
    }
  var DF = He.TYPES = [].concat(Object.keys(rt.VISITOR_KEYS), Object.keys(rt.FLIPPED_ALIAS_KEYS), Object.keys(rt.DEPRECATED_KEYS));
});

// ../node_modules/@babel/types/lib/validators/validate.js
var Ei = D((ur) => {
  "use strict";
  Object.defineProperty(ur, "__esModule", {
    value: !0
  });
  ur.default = YS;
  ur.validateChild = Rl;
  ur.validateField = Fl;
  ur.validateInternal = JS;
  var Lr = ot();
  function YS(t, e, r) {
    if (!t) return;
    let i = Lr.NODE_FIELDS[t.type];
    if (!i) return;
    let n = i[e];
    Fl(t, e, r, n), Rl(t, e, r);
  }
  s(YS, "validate");
  function JS(t, e, r, i, n) {
    if (t != null && t.validate && !(t.optional && i == null) && (t.validate(e, r, i), n)) {
      var a;
      let o = i.type;
      if (o == null) return;
      (a = Lr.NODE_PARENT_VALIDATIONS[o]) == null || a.call(Lr.NODE_PARENT_VALIDATIONS, e, r, i);
    }
  }
  s(JS, "validateInternal");
  function Fl(t, e, r, i) {
    i != null && i.validate && (i.optional && r == null || i.validate(t, e, r));
  }
  s(Fl, "validateField");
  function Rl(t, e, r) {
    var i;
    let n = r?.type;
    n != null && ((i = Lr.NODE_PARENT_VALIDATIONS[n]) == null || i.call(Lr.NODE_PARENT_VALIDATIONS, t, e, r));
  }
  s(Rl, "validateChild");
});

// ../node_modules/@babel/types/lib/builders/generated/lowercase.js
var Gs = D((f) => {
  "use strict";
  Object.defineProperty(f, "__esModule", {
    value: !0
  });
  f.anyTypeAnnotation = I0;
  f.argumentPlaceholder = eg;
  f.arrayExpression = $S;
  f.arrayPattern = Vb;
  f.arrayTypeAnnotation = v0;
  f.arrowFunctionExpression = Yb;
  f.assignmentExpression = zS;
  f.assignmentPattern = Kb;
  f.awaitExpression = f0;
  f.bigIntLiteral = d0;
  f.binaryExpression = HS;
  f.bindExpression = tg;
  f.blockStatement = eb;
  f.booleanLiteral = xb;
  f.booleanLiteralTypeAnnotation = w0;
  f.booleanTypeAnnotation = C0;
  f.breakStatement = tb;
  f.callExpression = rb;
  f.catchClause = ib;
  f.classAccessorProperty = b0;
  f.classBody = Jb;
  f.classDeclaration = Wb;
  f.classExpression = Xb;
  f.classImplements = O0;
  f.classMethod = n0;
  f.classPrivateMethod = g0;
  f.classPrivateProperty = x0;
  f.classProperty = S0;
  f.conditionalExpression = sb;
  f.continueStatement = nb;
  f.debuggerStatement = ab;
  f.decimalLiteral = og;
  f.declareClass = _0;
  f.declareExportAllDeclaration = q0;
  f.declareExportDeclaration = R0;
  f.declareFunction = D0;
  f.declareInterface = k0;
  f.declareModule = L0;
  f.declareModuleExports = M0;
  f.declareOpaqueType = j0;
  f.declareTypeAlias = B0;
  f.declareVariable = F0;
  f.declaredPredicate = U0;
  f.decorator = rg;
  f.directive = QS;
  f.directiveLiteral = ZS;
  f.doExpression = ig;
  f.doWhileStatement = ob;
  f.emptyStatement = lb;
  f.emptyTypeAnnotation = Q0;
  f.enumBooleanBody = vx;
  f.enumBooleanMember = Ox;
  f.enumDeclaration = Ix;
  f.enumDefaultedMember = kx;
  f.enumNumberBody = Cx;
  f.enumNumberMember = _x;
  f.enumStringBody = wx;
  f.enumStringMember = Dx;
  f.enumSymbolBody = Nx;
  f.existsTypeAnnotation = K0;
  f.exportAllDeclaration = $b;
  f.exportDefaultDeclaration = zb;
  f.exportDefaultSpecifier = sg;
  f.exportNamedDeclaration = Hb;
  f.exportNamespaceSpecifier = m0;
  f.exportSpecifier = Gb;
  f.expressionStatement = ub;
  f.file = cb;
  f.forInStatement = pb;
  f.forOfStatement = Qb;
  f.forStatement = fb;
  f.functionDeclaration = hb;
  f.functionExpression = db;
  f.functionTypeAnnotation = V0;
  f.functionTypeParam = Y0;
  f.genericTypeAnnotation = J0;
  f.identifier = mb;
  f.ifStatement = yb;
  f.import = h0;
  f.importAttribute = A0;
  f.importDeclaration = Zb;
  f.importDefaultSpecifier = e0;
  f.importExpression = i0;
  f.importNamespaceSpecifier = t0;
  f.importSpecifier = r0;
  f.indexedAccessType = Lx;
  f.inferredPredicate = X0;
  f.interfaceDeclaration = $0;
  f.interfaceExtends = W0;
  f.interfaceTypeAnnotation = z0;
  f.interpreterDirective = GS;
  f.intersectionTypeAnnotation = H0;
  f.jSXAttribute = f.jsxAttribute = Bx;
  f.jSXClosingElement = f.jsxClosingElement = jx;
  f.jSXClosingFragment = f.jsxClosingFragment = Hx;
  f.jSXElement = f.jsxElement = Fx;
  f.jSXEmptyExpression = f.jsxEmptyExpression = Rx;
  f.jSXExpressionContainer = f.jsxExpressionContainer = qx;
  f.jSXFragment = f.jsxFragment = $x;
  f.jSXIdentifier = f.jsxIdentifier = Kx;
  f.jSXMemberExpression = f.jsxMemberExpression = Vx;
  f.jSXNamespacedName = f.jsxNamespacedName = Yx;
  f.jSXOpeningElement = f.jsxOpeningElement = Jx;
  f.jSXOpeningFragment = f.jsxOpeningFragment = zx;
  f.jSXSpreadAttribute = f.jsxSpreadAttribute = Xx;
  f.jSXSpreadChild = f.jsxSpreadChild = Ux;
  f.jSXText = f.jsxText = Wx;
  f.labeledStatement = Tb;
  f.logicalExpression = gb;
  f.memberExpression = Eb;
  f.metaProperty = s0;
  f.mixedTypeAnnotation = G0;
  f.moduleExpression = lg;
  f.newExpression = Pb;
  f.noop = Gx;
  f.nullLiteral = bb;
  f.nullLiteralTypeAnnotation = N0;
  f.nullableTypeAnnotation = Z0;
  f.numberLiteral = vE;
  f.numberLiteralTypeAnnotation = ex;
  f.numberTypeAnnotation = tx;
  f.numericLiteral = ql;
  f.objectExpression = Ib;
  f.objectMethod = vb;
  f.objectPattern = a0;
  f.objectProperty = Cb;
  f.objectTypeAnnotation = rx;
  f.objectTypeCallProperty = sx;
  f.objectTypeIndexer = nx;
  f.objectTypeInternalSlot = ix;
  f.objectTypeProperty = ax;
  f.objectTypeSpreadProperty = ox;
  f.opaqueType = lx;
  f.optionalCallExpression = T0;
  f.optionalIndexedAccessType = Mx;
  f.optionalMemberExpression = y0;
  f.parenthesizedExpression = Ob;
  f.pipelineBareFunction = pg;
  f.pipelinePrimaryTopicReference = fg;
  f.pipelineTopicExpression = cg;
  f.placeholder = Qx;
  f.privateName = E0;
  f.program = Ab;
  f.qualifiedTypeIdentifier = ux;
  f.recordExpression = ng;
  f.regExpLiteral = Ul;
  f.regexLiteral = CE;
  f.restElement = Kl;
  f.restProperty = wE;
  f.returnStatement = wb;
  f.sequenceExpression = Nb;
  f.spreadElement = Vl;
  f.spreadProperty = NE;
  f.staticBlock = P0;
  f.stringLiteral = Sb;
  f.stringLiteralTypeAnnotation = cx;
  f.stringTypeAnnotation = px;
  f.super = o0;
  f.switchCase = _b;
  f.switchStatement = Db;
  f.symbolTypeAnnotation = fx;
  f.taggedTemplateExpression = l0;
  f.templateElement = u0;
  f.templateLiteral = c0;
  f.thisExpression = kb;
  f.thisTypeAnnotation = hx;
  f.throwStatement = Lb;
  f.topicReference = ug;
  f.tryStatement = Mb;
  f.tSAnyKeyword = f.tsAnyKeyword = Eg;
  f.tSArrayType = f.tsArrayType = Kg;
  f.tSAsExpression = f.tsAsExpression = lE;
  f.tSBigIntKeyword = f.tsBigIntKeyword = Ag;
  f.tSBooleanKeyword = f.tsBooleanKeyword = Pg;
  f.tSCallSignatureDeclaration = f.tsCallSignatureDeclaration = Tg;
  f.tSConditionalType = f.tsConditionalType = zg;
  f.tSConstructSignatureDeclaration = f.tsConstructSignatureDeclaration = Sg;
  f.tSConstructorType = f.tsConstructorType = jg;
  f.tSDeclareFunction = f.tsDeclareFunction = dg;
  f.tSDeclareMethod = f.tsDeclareMethod = mg;
  f.tSEnumBody = f.tsEnumBody = pE;
  f.tSEnumDeclaration = f.tsEnumDeclaration = fE;
  f.tSEnumMember = f.tsEnumMember = hE;
  f.tSExportAssignment = f.tsExportAssignment = xE;
  f.tSExpressionWithTypeArguments = f.tsExpressionWithTypeArguments = iE;
  f.tSExternalModuleReference = f.tsExternalModuleReference = SE;
  f.tSFunctionType = f.tsFunctionType = Bg;
  f.tSImportEqualsDeclaration = f.tsImportEqualsDeclaration = TE;
  f.tSImportType = f.tsImportType = yE;
  f.tSIndexSignature = f.tsIndexSignature = gg;
  f.tSIndexedAccessType = f.tsIndexedAccessType = Zg;
  f.tSInferType = f.tsInferType = Hg;
  f.tSInstantiationExpression = f.tsInstantiationExpression = oE;
  f.tSInterfaceBody = f.tsInterfaceBody = nE;
  f.tSInterfaceDeclaration = f.tsInterfaceDeclaration = sE;
  f.tSIntersectionType = f.tsIntersectionType = $g;
  f.tSIntrinsicKeyword = f.tsIntrinsicKeyword = Ig;
  f.tSLiteralType = f.tsLiteralType = rE;
  f.tSMappedType = f.tsMappedType = eE;
  f.tSMethodSignature = f.tsMethodSignature = xg;
  f.tSModuleBlock = f.tsModuleBlock = mE;
  f.tSModuleDeclaration = f.tsModuleDeclaration = dE;
  f.tSNamedTupleMember = f.tsNamedTupleMember = Xg;
  f.tSNamespaceExportDeclaration = f.tsNamespaceExportDeclaration = gE;
  f.tSNeverKeyword = f.tsNeverKeyword = vg;
  f.tSNonNullExpression = f.tsNonNullExpression = bE;
  f.tSNullKeyword = f.tsNullKeyword = Cg;
  f.tSNumberKeyword = f.tsNumberKeyword = wg;
  f.tSObjectKeyword = f.tsObjectKeyword = Ng;
  f.tSOptionalType = f.tsOptionalType = Yg;
  f.tSParameterProperty = f.tsParameterProperty = hg;
  f.tSParenthesizedType = f.tsParenthesizedType = Gg;
  f.tSPropertySignature = f.tsPropertySignature = bg;
  f.tSQualifiedName = f.tsQualifiedName = yg;
  f.tSRestType = f.tsRestType = Jg;
  f.tSSatisfiesExpression = f.tsSatisfiesExpression = uE;
  f.tSStringKeyword = f.tsStringKeyword = Og;
  f.tSSymbolKeyword = f.tsSymbolKeyword = _g;
  f.tSTemplateLiteralType = f.tsTemplateLiteralType = tE;
  f.tSThisType = f.tsThisType = Mg;
  f.tSTupleType = f.tsTupleType = Vg;
  f.tSTypeAliasDeclaration = f.tsTypeAliasDeclaration = aE;
  f.tSTypeAnnotation = f.tsTypeAnnotation = EE;
  f.tSTypeAssertion = f.tsTypeAssertion = cE;
  f.tSTypeLiteral = f.tsTypeLiteral = Ug;
  f.tSTypeOperator = f.tsTypeOperator = Qg;
  f.tSTypeParameter = f.tsTypeParameter = IE;
  f.tSTypeParameterDeclaration = f.tsTypeParameterDeclaration = AE;
  f.tSTypeParameterInstantiation = f.tsTypeParameterInstantiation = PE;
  f.tSTypePredicate = f.tsTypePredicate = Rg;
  f.tSTypeQuery = f.tsTypeQuery = qg;
  f.tSTypeReference = f.tsTypeReference = Fg;
  f.tSUndefinedKeyword = f.tsUndefinedKeyword = Dg;
  f.tSUnionType = f.tsUnionType = Wg;
  f.tSUnknownKeyword = f.tsUnknownKeyword = kg;
  f.tSVoidKeyword = f.tsVoidKeyword = Lg;
  f.tupleExpression = ag;
  f.tupleTypeAnnotation = dx;
  f.typeAlias = yx;
  f.typeAnnotation = Tx;
  f.typeCastExpression = Sx;
  f.typeParameter = bx;
  f.typeParameterDeclaration = xx;
  f.typeParameterInstantiation = gx;
  f.typeofTypeAnnotation = mx;
  f.unaryExpression = Bb;
  f.unionTypeAnnotation = Ex;
  f.updateExpression = jb;
  f.v8IntrinsicIdentifier = Zx;
  f.variableDeclaration = Fb;
  f.variableDeclarator = Rb;
  f.variance = Px;
  f.voidTypeAnnotation = Ax;
  f.whileStatement = qb;
  f.withStatement = Ub;
  f.yieldExpression = p0;
  var XS = Ei(), Ci = Ir(), WS = bt(), {
    validateInternal: c
  } = XS, {
    NODE_FIELDS: P
  } = WS;
  function $S(t = []) {
    let e = {
      type: "ArrayExpression",
      elements: t
    }, r = P.ArrayExpression;
    return c(r.elements, e, "elements", t, 1), e;
  }
  s($S, "arrayExpression");
  function zS(t, e, r) {
    let i = {
      type: "AssignmentExpression",
      operator: t,
      left: e,
      right: r
    }, n = P.AssignmentExpression;
    return c(n.operator, i, "operator", t), c(n.left, i, "left", e, 1), c(n.right, i, "right", r, 1), i;
  }
  s(zS, "assignmentExpression");
  function HS(t, e, r) {
    let i = {
      type: "BinaryExpression",
      operator: t,
      left: e,
      right: r
    }, n = P.BinaryExpression;
    return c(n.operator, i, "operator", t), c(n.left, i, "left", e, 1), c(n.right, i, "right", r, 1), i;
  }
  s(HS, "binaryExpression");
  function GS(t) {
    let e = {
      type: "InterpreterDirective",
      value: t
    }, r = P.InterpreterDirective;
    return c(r.value, e, "value", t), e;
  }
  s(GS, "interpreterDirective");
  function QS(t) {
    let e = {
      type: "Directive",
      value: t
    }, r = P.Directive;
    return c(r.value, e, "value", t, 1), e;
  }
  s(QS, "directive");
  function ZS(t) {
    let e = {
      type: "DirectiveLiteral",
      value: t
    }, r = P.DirectiveLiteral;
    return c(r.value, e, "value", t), e;
  }
  s(ZS, "directiveLiteral");
  function eb(t, e = []) {
    let r = {
      type: "BlockStatement",
      body: t,
      directives: e
    }, i = P.BlockStatement;
    return c(i.body, r, "body", t, 1), c(i.directives, r, "directives", e, 1), r;
  }
  s(eb, "blockStatement");
  function tb(t = null) {
    let e = {
      type: "BreakStatement",
      label: t
    }, r = P.BreakStatement;
    return c(r.label, e, "label", t, 1), e;
  }
  s(tb, "breakStatement");
  function rb(t, e) {
    let r = {
      type: "CallExpression",
      callee: t,
      arguments: e
    }, i = P.CallExpression;
    return c(i.callee, r, "callee", t, 1), c(i.arguments, r, "arguments", e, 1), r;
  }
  s(rb, "callExpression");
  function ib(t = null, e) {
    let r = {
      type: "CatchClause",
      param: t,
      body: e
    }, i = P.CatchClause;
    return c(i.param, r, "param", t, 1), c(i.body, r, "body", e, 1), r;
  }
  s(ib, "catchClause");
  function sb(t, e, r) {
    let i = {
      type: "ConditionalExpression",
      test: t,
      consequent: e,
      alternate: r
    }, n = P.ConditionalExpression;
    return c(n.test, i, "test", t, 1), c(n.consequent, i, "consequent", e, 1), c(n.alternate, i, "alternate", r, 1), i;
  }
  s(sb, "conditionalExpression");
  function nb(t = null) {
    let e = {
      type: "ContinueStatement",
      label: t
    }, r = P.ContinueStatement;
    return c(r.label, e, "label", t, 1), e;
  }
  s(nb, "continueStatement");
  function ab() {
    return {
      type: "DebuggerStatement"
    };
  }
  s(ab, "debuggerStatement");
  function ob(t, e) {
    let r = {
      type: "DoWhileStatement",
      test: t,
      body: e
    }, i = P.DoWhileStatement;
    return c(i.test, r, "test", t, 1), c(i.body, r, "body", e, 1), r;
  }
  s(ob, "doWhileStatement");
  function lb() {
    return {
      type: "EmptyStatement"
    };
  }
  s(lb, "emptyStatement");
  function ub(t) {
    let e = {
      type: "ExpressionStatement",
      expression: t
    }, r = P.ExpressionStatement;
    return c(r.expression, e, "expression", t, 1), e;
  }
  s(ub, "expressionStatement");
  function cb(t, e = null, r = null) {
    let i = {
      type: "File",
      program: t,
      comments: e,
      tokens: r
    }, n = P.File;
    return c(n.program, i, "program", t, 1), c(n.comments, i, "comments", e, 1), c(n.tokens, i, "tokens", r), i;
  }
  s(cb, "file");
  function pb(t, e, r) {
    let i = {
      type: "ForInStatement",
      left: t,
      right: e,
      body: r
    }, n = P.ForInStatement;
    return c(n.left, i, "left", t, 1), c(n.right, i, "right", e, 1), c(n.body, i, "body", r, 1), i;
  }
  s(pb, "forInStatement");
  function fb(t = null, e = null, r = null, i) {
    let n = {
      type: "ForStatement",
      init: t,
      test: e,
      update: r,
      body: i
    }, a = P.ForStatement;
    return c(a.init, n, "init", t, 1), c(a.test, n, "test", e, 1), c(a.update, n, "update", r, 1), c(a.body, n, "body", i, 1), n;
  }
  s(fb, "forStatement");
  function hb(t = null, e, r, i = !1, n = !1) {
    let a = {
      type: "FunctionDeclaration",
      id: t,
      params: e,
      body: r,
      generator: i,
      async: n
    }, o = P.FunctionDeclaration;
    return c(o.id, a, "id", t, 1), c(o.params, a, "params", e, 1), c(o.body, a, "body", r, 1), c(o.generator, a, "generator", i), c(o.async,
    a, "async", n), a;
  }
  s(hb, "functionDeclaration");
  function db(t = null, e, r, i = !1, n = !1) {
    let a = {
      type: "FunctionExpression",
      id: t,
      params: e,
      body: r,
      generator: i,
      async: n
    }, o = P.FunctionExpression;
    return c(o.id, a, "id", t, 1), c(o.params, a, "params", e, 1), c(o.body, a, "body", r, 1), c(o.generator, a, "generator", i), c(o.async,
    a, "async", n), a;
  }
  s(db, "functionExpression");
  function mb(t) {
    let e = {
      type: "Identifier",
      name: t
    }, r = P.Identifier;
    return c(r.name, e, "name", t), e;
  }
  s(mb, "identifier");
  function yb(t, e, r = null) {
    let i = {
      type: "IfStatement",
      test: t,
      consequent: e,
      alternate: r
    }, n = P.IfStatement;
    return c(n.test, i, "test", t, 1), c(n.consequent, i, "consequent", e, 1), c(n.alternate, i, "alternate", r, 1), i;
  }
  s(yb, "ifStatement");
  function Tb(t, e) {
    let r = {
      type: "LabeledStatement",
      label: t,
      body: e
    }, i = P.LabeledStatement;
    return c(i.label, r, "label", t, 1), c(i.body, r, "body", e, 1), r;
  }
  s(Tb, "labeledStatement");
  function Sb(t) {
    let e = {
      type: "StringLiteral",
      value: t
    }, r = P.StringLiteral;
    return c(r.value, e, "value", t), e;
  }
  s(Sb, "stringLiteral");
  function ql(t) {
    let e = {
      type: "NumericLiteral",
      value: t
    }, r = P.NumericLiteral;
    return c(r.value, e, "value", t), e;
  }
  s(ql, "numericLiteral");
  function bb() {
    return {
      type: "NullLiteral"
    };
  }
  s(bb, "nullLiteral");
  function xb(t) {
    let e = {
      type: "BooleanLiteral",
      value: t
    }, r = P.BooleanLiteral;
    return c(r.value, e, "value", t), e;
  }
  s(xb, "booleanLiteral");
  function Ul(t, e = "") {
    let r = {
      type: "RegExpLiteral",
      pattern: t,
      flags: e
    }, i = P.RegExpLiteral;
    return c(i.pattern, r, "pattern", t), c(i.flags, r, "flags", e), r;
  }
  s(Ul, "regExpLiteral");
  function gb(t, e, r) {
    let i = {
      type: "LogicalExpression",
      operator: t,
      left: e,
      right: r
    }, n = P.LogicalExpression;
    return c(n.operator, i, "operator", t), c(n.left, i, "left", e, 1), c(n.right, i, "right", r, 1), i;
  }
  s(gb, "logicalExpression");
  function Eb(t, e, r = !1, i = null) {
    let n = {
      type: "MemberExpression",
      object: t,
      property: e,
      computed: r,
      optional: i
    }, a = P.MemberExpression;
    return c(a.object, n, "object", t, 1), c(a.property, n, "property", e, 1), c(a.computed, n, "computed", r), c(a.optional, n, "optional",
    i), n;
  }
  s(Eb, "memberExpression");
  function Pb(t, e) {
    let r = {
      type: "NewExpression",
      callee: t,
      arguments: e
    }, i = P.NewExpression;
    return c(i.callee, r, "callee", t, 1), c(i.arguments, r, "arguments", e, 1), r;
  }
  s(Pb, "newExpression");
  function Ab(t, e = [], r = "script", i = null) {
    let n = {
      type: "Program",
      body: t,
      directives: e,
      sourceType: r,
      interpreter: i
    }, a = P.Program;
    return c(a.body, n, "body", t, 1), c(a.directives, n, "directives", e, 1), c(a.sourceType, n, "sourceType", r), c(a.interpreter, n, "int\
erpreter", i, 1), n;
  }
  s(Ab, "program");
  function Ib(t) {
    let e = {
      type: "ObjectExpression",
      properties: t
    }, r = P.ObjectExpression;
    return c(r.properties, e, "properties", t, 1), e;
  }
  s(Ib, "objectExpression");
  function vb(t = "method", e, r, i, n = !1, a = !1, o = !1) {
    let l = {
      type: "ObjectMethod",
      kind: t,
      key: e,
      params: r,
      body: i,
      computed: n,
      generator: a,
      async: o
    }, u = P.ObjectMethod;
    return c(u.kind, l, "kind", t), c(u.key, l, "key", e, 1), c(u.params, l, "params", r, 1), c(u.body, l, "body", i, 1), c(u.computed, l, "\
computed", n), c(u.generator, l, "generator", a), c(u.async, l, "async", o), l;
  }
  s(vb, "objectMethod");
  function Cb(t, e, r = !1, i = !1, n = null) {
    let a = {
      type: "ObjectProperty",
      key: t,
      value: e,
      computed: r,
      shorthand: i,
      decorators: n
    }, o = P.ObjectProperty;
    return c(o.key, a, "key", t, 1), c(o.value, a, "value", e, 1), c(o.computed, a, "computed", r), c(o.shorthand, a, "shorthand", i), c(o.decorators,
    a, "decorators", n, 1), a;
  }
  s(Cb, "objectProperty");
  function Kl(t) {
    let e = {
      type: "RestElement",
      argument: t
    }, r = P.RestElement;
    return c(r.argument, e, "argument", t, 1), e;
  }
  s(Kl, "restElement");
  function wb(t = null) {
    let e = {
      type: "ReturnStatement",
      argument: t
    }, r = P.ReturnStatement;
    return c(r.argument, e, "argument", t, 1), e;
  }
  s(wb, "returnStatement");
  function Nb(t) {
    let e = {
      type: "SequenceExpression",
      expressions: t
    }, r = P.SequenceExpression;
    return c(r.expressions, e, "expressions", t, 1), e;
  }
  s(Nb, "sequenceExpression");
  function Ob(t) {
    let e = {
      type: "ParenthesizedExpression",
      expression: t
    }, r = P.ParenthesizedExpression;
    return c(r.expression, e, "expression", t, 1), e;
  }
  s(Ob, "parenthesizedExpression");
  function _b(t = null, e) {
    let r = {
      type: "SwitchCase",
      test: t,
      consequent: e
    }, i = P.SwitchCase;
    return c(i.test, r, "test", t, 1), c(i.consequent, r, "consequent", e, 1), r;
  }
  s(_b, "switchCase");
  function Db(t, e) {
    let r = {
      type: "SwitchStatement",
      discriminant: t,
      cases: e
    }, i = P.SwitchStatement;
    return c(i.discriminant, r, "discriminant", t, 1), c(i.cases, r, "cases", e, 1), r;
  }
  s(Db, "switchStatement");
  function kb() {
    return {
      type: "ThisExpression"
    };
  }
  s(kb, "thisExpression");
  function Lb(t) {
    let e = {
      type: "ThrowStatement",
      argument: t
    }, r = P.ThrowStatement;
    return c(r.argument, e, "argument", t, 1), e;
  }
  s(Lb, "throwStatement");
  function Mb(t, e = null, r = null) {
    let i = {
      type: "TryStatement",
      block: t,
      handler: e,
      finalizer: r
    }, n = P.TryStatement;
    return c(n.block, i, "block", t, 1), c(n.handler, i, "handler", e, 1), c(n.finalizer, i, "finalizer", r, 1), i;
  }
  s(Mb, "tryStatement");
  function Bb(t, e, r = !0) {
    let i = {
      type: "UnaryExpression",
      operator: t,
      argument: e,
      prefix: r
    }, n = P.UnaryExpression;
    return c(n.operator, i, "operator", t), c(n.argument, i, "argument", e, 1), c(n.prefix, i, "prefix", r), i;
  }
  s(Bb, "unaryExpression");
  function jb(t, e, r = !1) {
    let i = {
      type: "UpdateExpression",
      operator: t,
      argument: e,
      prefix: r
    }, n = P.UpdateExpression;
    return c(n.operator, i, "operator", t), c(n.argument, i, "argument", e, 1), c(n.prefix, i, "prefix", r), i;
  }
  s(jb, "updateExpression");
  function Fb(t, e) {
    let r = {
      type: "VariableDeclaration",
      kind: t,
      declarations: e
    }, i = P.VariableDeclaration;
    return c(i.kind, r, "kind", t), c(i.declarations, r, "declarations", e, 1), r;
  }
  s(Fb, "variableDeclaration");
  function Rb(t, e = null) {
    let r = {
      type: "VariableDeclarator",
      id: t,
      init: e
    }, i = P.VariableDeclarator;
    return c(i.id, r, "id", t, 1), c(i.init, r, "init", e, 1), r;
  }
  s(Rb, "variableDeclarator");
  function qb(t, e) {
    let r = {
      type: "WhileStatement",
      test: t,
      body: e
    }, i = P.WhileStatement;
    return c(i.test, r, "test", t, 1), c(i.body, r, "body", e, 1), r;
  }
  s(qb, "whileStatement");
  function Ub(t, e) {
    let r = {
      type: "WithStatement",
      object: t,
      body: e
    }, i = P.WithStatement;
    return c(i.object, r, "object", t, 1), c(i.body, r, "body", e, 1), r;
  }
  s(Ub, "withStatement");
  function Kb(t, e) {
    let r = {
      type: "AssignmentPattern",
      left: t,
      right: e
    }, i = P.AssignmentPattern;
    return c(i.left, r, "left", t, 1), c(i.right, r, "right", e, 1), r;
  }
  s(Kb, "assignmentPattern");
  function Vb(t) {
    let e = {
      type: "ArrayPattern",
      elements: t
    }, r = P.ArrayPattern;
    return c(r.elements, e, "elements", t, 1), e;
  }
  s(Vb, "arrayPattern");
  function Yb(t, e, r = !1) {
    let i = {
      type: "ArrowFunctionExpression",
      params: t,
      body: e,
      async: r,
      expression: null
    }, n = P.ArrowFunctionExpression;
    return c(n.params, i, "params", t, 1), c(n.body, i, "body", e, 1), c(n.async, i, "async", r), i;
  }
  s(Yb, "arrowFunctionExpression");
  function Jb(t) {
    let e = {
      type: "ClassBody",
      body: t
    }, r = P.ClassBody;
    return c(r.body, e, "body", t, 1), e;
  }
  s(Jb, "classBody");
  function Xb(t = null, e = null, r, i = null) {
    let n = {
      type: "ClassExpression",
      id: t,
      superClass: e,
      body: r,
      decorators: i
    }, a = P.ClassExpression;
    return c(a.id, n, "id", t, 1), c(a.superClass, n, "superClass", e, 1), c(a.body, n, "body", r, 1), c(a.decorators, n, "decorators", i, 1),
    n;
  }
  s(Xb, "classExpression");
  function Wb(t = null, e = null, r, i = null) {
    let n = {
      type: "ClassDeclaration",
      id: t,
      superClass: e,
      body: r,
      decorators: i
    }, a = P.ClassDeclaration;
    return c(a.id, n, "id", t, 1), c(a.superClass, n, "superClass", e, 1), c(a.body, n, "body", r, 1), c(a.decorators, n, "decorators", i, 1),
    n;
  }
  s(Wb, "classDeclaration");
  function $b(t) {
    let e = {
      type: "ExportAllDeclaration",
      source: t
    }, r = P.ExportAllDeclaration;
    return c(r.source, e, "source", t, 1), e;
  }
  s($b, "exportAllDeclaration");
  function zb(t) {
    let e = {
      type: "ExportDefaultDeclaration",
      declaration: t
    }, r = P.ExportDefaultDeclaration;
    return c(r.declaration, e, "declaration", t, 1), e;
  }
  s(zb, "exportDefaultDeclaration");
  function Hb(t = null, e = [], r = null) {
    let i = {
      type: "ExportNamedDeclaration",
      declaration: t,
      specifiers: e,
      source: r
    }, n = P.ExportNamedDeclaration;
    return c(n.declaration, i, "declaration", t, 1), c(n.specifiers, i, "specifiers", e, 1), c(n.source, i, "source", r, 1), i;
  }
  s(Hb, "exportNamedDeclaration");
  function Gb(t, e) {
    let r = {
      type: "ExportSpecifier",
      local: t,
      exported: e
    }, i = P.ExportSpecifier;
    return c(i.local, r, "local", t, 1), c(i.exported, r, "exported", e, 1), r;
  }
  s(Gb, "exportSpecifier");
  function Qb(t, e, r, i = !1) {
    let n = {
      type: "ForOfStatement",
      left: t,
      right: e,
      body: r,
      await: i
    }, a = P.ForOfStatement;
    return c(a.left, n, "left", t, 1), c(a.right, n, "right", e, 1), c(a.body, n, "body", r, 1), c(a.await, n, "await", i), n;
  }
  s(Qb, "forOfStatement");
  function Zb(t, e) {
    let r = {
      type: "ImportDeclaration",
      specifiers: t,
      source: e
    }, i = P.ImportDeclaration;
    return c(i.specifiers, r, "specifiers", t, 1), c(i.source, r, "source", e, 1), r;
  }
  s(Zb, "importDeclaration");
  function e0(t) {
    let e = {
      type: "ImportDefaultSpecifier",
      local: t
    }, r = P.ImportDefaultSpecifier;
    return c(r.local, e, "local", t, 1), e;
  }
  s(e0, "importDefaultSpecifier");
  function t0(t) {
    let e = {
      type: "ImportNamespaceSpecifier",
      local: t
    }, r = P.ImportNamespaceSpecifier;
    return c(r.local, e, "local", t, 1), e;
  }
  s(t0, "importNamespaceSpecifier");
  function r0(t, e) {
    let r = {
      type: "ImportSpecifier",
      local: t,
      imported: e
    }, i = P.ImportSpecifier;
    return c(i.local, r, "local", t, 1), c(i.imported, r, "imported", e, 1), r;
  }
  s(r0, "importSpecifier");
  function i0(t, e = null) {
    let r = {
      type: "ImportExpression",
      source: t,
      options: e
    }, i = P.ImportExpression;
    return c(i.source, r, "source", t, 1), c(i.options, r, "options", e, 1), r;
  }
  s(i0, "importExpression");
  function s0(t, e) {
    let r = {
      type: "MetaProperty",
      meta: t,
      property: e
    }, i = P.MetaProperty;
    return c(i.meta, r, "meta", t, 1), c(i.property, r, "property", e, 1), r;
  }
  s(s0, "metaProperty");
  function n0(t = "method", e, r, i, n = !1, a = !1, o = !1, l = !1) {
    let u = {
      type: "ClassMethod",
      kind: t,
      key: e,
      params: r,
      body: i,
      computed: n,
      static: a,
      generator: o,
      async: l
    }, p = P.ClassMethod;
    return c(p.kind, u, "kind", t), c(p.key, u, "key", e, 1), c(p.params, u, "params", r, 1), c(p.body, u, "body", i, 1), c(p.computed, u, "\
computed", n), c(p.static, u, "static", a), c(p.generator, u, "generator", o), c(p.async, u, "async", l), u;
  }
  s(n0, "classMethod");
  function a0(t) {
    let e = {
      type: "ObjectPattern",
      properties: t
    }, r = P.ObjectPattern;
    return c(r.properties, e, "properties", t, 1), e;
  }
  s(a0, "objectPattern");
  function Vl(t) {
    let e = {
      type: "SpreadElement",
      argument: t
    }, r = P.SpreadElement;
    return c(r.argument, e, "argument", t, 1), e;
  }
  s(Vl, "spreadElement");
  function o0() {
    return {
      type: "Super"
    };
  }
  s(o0, "_super");
  function l0(t, e) {
    let r = {
      type: "TaggedTemplateExpression",
      tag: t,
      quasi: e
    }, i = P.TaggedTemplateExpression;
    return c(i.tag, r, "tag", t, 1), c(i.quasi, r, "quasi", e, 1), r;
  }
  s(l0, "taggedTemplateExpression");
  function u0(t, e = !1) {
    let r = {
      type: "TemplateElement",
      value: t,
      tail: e
    }, i = P.TemplateElement;
    return c(i.value, r, "value", t), c(i.tail, r, "tail", e), r;
  }
  s(u0, "templateElement");
  function c0(t, e) {
    let r = {
      type: "TemplateLiteral",
      quasis: t,
      expressions: e
    }, i = P.TemplateLiteral;
    return c(i.quasis, r, "quasis", t, 1), c(i.expressions, r, "expressions", e, 1), r;
  }
  s(c0, "templateLiteral");
  function p0(t = null, e = !1) {
    let r = {
      type: "YieldExpression",
      argument: t,
      delegate: e
    }, i = P.YieldExpression;
    return c(i.argument, r, "argument", t, 1), c(i.delegate, r, "delegate", e), r;
  }
  s(p0, "yieldExpression");
  function f0(t) {
    let e = {
      type: "AwaitExpression",
      argument: t
    }, r = P.AwaitExpression;
    return c(r.argument, e, "argument", t, 1), e;
  }
  s(f0, "awaitExpression");
  function h0() {
    return {
      type: "Import"
    };
  }
  s(h0, "_import");
  function d0(t) {
    let e = {
      type: "BigIntLiteral",
      value: t
    }, r = P.BigIntLiteral;
    return c(r.value, e, "value", t), e;
  }
  s(d0, "bigIntLiteral");
  function m0(t) {
    let e = {
      type: "ExportNamespaceSpecifier",
      exported: t
    }, r = P.ExportNamespaceSpecifier;
    return c(r.exported, e, "exported", t, 1), e;
  }
  s(m0, "exportNamespaceSpecifier");
  function y0(t, e, r = !1, i) {
    let n = {
      type: "OptionalMemberExpression",
      object: t,
      property: e,
      computed: r,
      optional: i
    }, a = P.OptionalMemberExpression;
    return c(a.object, n, "object", t, 1), c(a.property, n, "property", e, 1), c(a.computed, n, "computed", r), c(a.optional, n, "optional",
    i), n;
  }
  s(y0, "optionalMemberExpression");
  function T0(t, e, r) {
    let i = {
      type: "OptionalCallExpression",
      callee: t,
      arguments: e,
      optional: r
    }, n = P.OptionalCallExpression;
    return c(n.callee, i, "callee", t, 1), c(n.arguments, i, "arguments", e, 1), c(n.optional, i, "optional", r), i;
  }
  s(T0, "optionalCallExpression");
  function S0(t, e = null, r = null, i = null, n = !1, a = !1) {
    let o = {
      type: "ClassProperty",
      key: t,
      value: e,
      typeAnnotation: r,
      decorators: i,
      computed: n,
      static: a
    }, l = P.ClassProperty;
    return c(l.key, o, "key", t, 1), c(l.value, o, "value", e, 1), c(l.typeAnnotation, o, "typeAnnotation", r, 1), c(l.decorators, o, "decor\
ators", i, 1), c(l.computed, o, "computed", n), c(l.static, o, "static", a), o;
  }
  s(S0, "classProperty");
  function b0(t, e = null, r = null, i = null, n = !1, a = !1) {
    let o = {
      type: "ClassAccessorProperty",
      key: t,
      value: e,
      typeAnnotation: r,
      decorators: i,
      computed: n,
      static: a
    }, l = P.ClassAccessorProperty;
    return c(l.key, o, "key", t, 1), c(l.value, o, "value", e, 1), c(l.typeAnnotation, o, "typeAnnotation", r, 1), c(l.decorators, o, "decor\
ators", i, 1), c(l.computed, o, "computed", n), c(l.static, o, "static", a), o;
  }
  s(b0, "classAccessorProperty");
  function x0(t, e = null, r = null, i = !1) {
    let n = {
      type: "ClassPrivateProperty",
      key: t,
      value: e,
      decorators: r,
      static: i
    }, a = P.ClassPrivateProperty;
    return c(a.key, n, "key", t, 1), c(a.value, n, "value", e, 1), c(a.decorators, n, "decorators", r, 1), c(a.static, n, "static", i), n;
  }
  s(x0, "classPrivateProperty");
  function g0(t = "method", e, r, i, n = !1) {
    let a = {
      type: "ClassPrivateMethod",
      kind: t,
      key: e,
      params: r,
      body: i,
      static: n
    }, o = P.ClassPrivateMethod;
    return c(o.kind, a, "kind", t), c(o.key, a, "key", e, 1), c(o.params, a, "params", r, 1), c(o.body, a, "body", i, 1), c(o.static, a, "st\
atic", n), a;
  }
  s(g0, "classPrivateMethod");
  function E0(t) {
    let e = {
      type: "PrivateName",
      id: t
    }, r = P.PrivateName;
    return c(r.id, e, "id", t, 1), e;
  }
  s(E0, "privateName");
  function P0(t) {
    let e = {
      type: "StaticBlock",
      body: t
    }, r = P.StaticBlock;
    return c(r.body, e, "body", t, 1), e;
  }
  s(P0, "staticBlock");
  function A0(t, e) {
    let r = {
      type: "ImportAttribute",
      key: t,
      value: e
    }, i = P.ImportAttribute;
    return c(i.key, r, "key", t, 1), c(i.value, r, "value", e, 1), r;
  }
  s(A0, "importAttribute");
  function I0() {
    return {
      type: "AnyTypeAnnotation"
    };
  }
  s(I0, "anyTypeAnnotation");
  function v0(t) {
    let e = {
      type: "ArrayTypeAnnotation",
      elementType: t
    }, r = P.ArrayTypeAnnotation;
    return c(r.elementType, e, "elementType", t, 1), e;
  }
  s(v0, "arrayTypeAnnotation");
  function C0() {
    return {
      type: "BooleanTypeAnnotation"
    };
  }
  s(C0, "booleanTypeAnnotation");
  function w0(t) {
    let e = {
      type: "BooleanLiteralTypeAnnotation",
      value: t
    }, r = P.BooleanLiteralTypeAnnotation;
    return c(r.value, e, "value", t), e;
  }
  s(w0, "booleanLiteralTypeAnnotation");
  function N0() {
    return {
      type: "NullLiteralTypeAnnotation"
    };
  }
  s(N0, "nullLiteralTypeAnnotation");
  function O0(t, e = null) {
    let r = {
      type: "ClassImplements",
      id: t,
      typeParameters: e
    }, i = P.ClassImplements;
    return c(i.id, r, "id", t, 1), c(i.typeParameters, r, "typeParameters", e, 1), r;
  }
  s(O0, "classImplements");
  function _0(t, e = null, r = null, i) {
    let n = {
      type: "DeclareClass",
      id: t,
      typeParameters: e,
      extends: r,
      body: i
    }, a = P.DeclareClass;
    return c(a.id, n, "id", t, 1), c(a.typeParameters, n, "typeParameters", e, 1), c(a.extends, n, "extends", r, 1), c(a.body, n, "body", i,
    1), n;
  }
  s(_0, "declareClass");
  function D0(t) {
    let e = {
      type: "DeclareFunction",
      id: t
    }, r = P.DeclareFunction;
    return c(r.id, e, "id", t, 1), e;
  }
  s(D0, "declareFunction");
  function k0(t, e = null, r = null, i) {
    let n = {
      type: "DeclareInterface",
      id: t,
      typeParameters: e,
      extends: r,
      body: i
    }, a = P.DeclareInterface;
    return c(a.id, n, "id", t, 1), c(a.typeParameters, n, "typeParameters", e, 1), c(a.extends, n, "extends", r, 1), c(a.body, n, "body", i,
    1), n;
  }
  s(k0, "declareInterface");
  function L0(t, e, r = null) {
    let i = {
      type: "DeclareModule",
      id: t,
      body: e,
      kind: r
    }, n = P.DeclareModule;
    return c(n.id, i, "id", t, 1), c(n.body, i, "body", e, 1), c(n.kind, i, "kind", r), i;
  }
  s(L0, "declareModule");
  function M0(t) {
    let e = {
      type: "DeclareModuleExports",
      typeAnnotation: t
    }, r = P.DeclareModuleExports;
    return c(r.typeAnnotation, e, "typeAnnotation", t, 1), e;
  }
  s(M0, "declareModuleExports");
  function B0(t, e = null, r) {
    let i = {
      type: "DeclareTypeAlias",
      id: t,
      typeParameters: e,
      right: r
    }, n = P.DeclareTypeAlias;
    return c(n.id, i, "id", t, 1), c(n.typeParameters, i, "typeParameters", e, 1), c(n.right, i, "right", r, 1), i;
  }
  s(B0, "declareTypeAlias");
  function j0(t, e = null, r = null) {
    let i = {
      type: "DeclareOpaqueType",
      id: t,
      typeParameters: e,
      supertype: r
    }, n = P.DeclareOpaqueType;
    return c(n.id, i, "id", t, 1), c(n.typeParameters, i, "typeParameters", e, 1), c(n.supertype, i, "supertype", r, 1), i;
  }
  s(j0, "declareOpaqueType");
  function F0(t) {
    let e = {
      type: "DeclareVariable",
      id: t
    }, r = P.DeclareVariable;
    return c(r.id, e, "id", t, 1), e;
  }
  s(F0, "declareVariable");
  function R0(t = null, e = null, r = null, i = null) {
    let n = {
      type: "DeclareExportDeclaration",
      declaration: t,
      specifiers: e,
      source: r,
      attributes: i
    }, a = P.DeclareExportDeclaration;
    return c(a.declaration, n, "declaration", t, 1), c(a.specifiers, n, "specifiers", e, 1), c(a.source, n, "source", r, 1), c(a.attributes,
    n, "attributes", i, 1), n;
  }
  s(R0, "declareExportDeclaration");
  function q0(t, e = null) {
    let r = {
      type: "DeclareExportAllDeclaration",
      source: t,
      attributes: e
    }, i = P.DeclareExportAllDeclaration;
    return c(i.source, r, "source", t, 1), c(i.attributes, r, "attributes", e, 1), r;
  }
  s(q0, "declareExportAllDeclaration");
  function U0(t) {
    let e = {
      type: "DeclaredPredicate",
      value: t
    }, r = P.DeclaredPredicate;
    return c(r.value, e, "value", t, 1), e;
  }
  s(U0, "declaredPredicate");
  function K0() {
    return {
      type: "ExistsTypeAnnotation"
    };
  }
  s(K0, "existsTypeAnnotation");
  function V0(t = null, e, r = null, i) {
    let n = {
      type: "FunctionTypeAnnotation",
      typeParameters: t,
      params: e,
      rest: r,
      returnType: i
    }, a = P.FunctionTypeAnnotation;
    return c(a.typeParameters, n, "typeParameters", t, 1), c(a.params, n, "params", e, 1), c(a.rest, n, "rest", r, 1), c(a.returnType, n, "r\
eturnType", i, 1), n;
  }
  s(V0, "functionTypeAnnotation");
  function Y0(t = null, e) {
    let r = {
      type: "FunctionTypeParam",
      name: t,
      typeAnnotation: e
    }, i = P.FunctionTypeParam;
    return c(i.name, r, "name", t, 1), c(i.typeAnnotation, r, "typeAnnotation", e, 1), r;
  }
  s(Y0, "functionTypeParam");
  function J0(t, e = null) {
    let r = {
      type: "GenericTypeAnnotation",
      id: t,
      typeParameters: e
    }, i = P.GenericTypeAnnotation;
    return c(i.id, r, "id", t, 1), c(i.typeParameters, r, "typeParameters", e, 1), r;
  }
  s(J0, "genericTypeAnnotation");
  function X0() {
    return {
      type: "InferredPredicate"
    };
  }
  s(X0, "inferredPredicate");
  function W0(t, e = null) {
    let r = {
      type: "InterfaceExtends",
      id: t,
      typeParameters: e
    }, i = P.InterfaceExtends;
    return c(i.id, r, "id", t, 1), c(i.typeParameters, r, "typeParameters", e, 1), r;
  }
  s(W0, "interfaceExtends");
  function $0(t, e = null, r = null, i) {
    let n = {
      type: "InterfaceDeclaration",
      id: t,
      typeParameters: e,
      extends: r,
      body: i
    }, a = P.InterfaceDeclaration;
    return c(a.id, n, "id", t, 1), c(a.typeParameters, n, "typeParameters", e, 1), c(a.extends, n, "extends", r, 1), c(a.body, n, "body", i,
    1), n;
  }
  s($0, "interfaceDeclaration");
  function z0(t = null, e) {
    let r = {
      type: "InterfaceTypeAnnotation",
      extends: t,
      body: e
    }, i = P.InterfaceTypeAnnotation;
    return c(i.extends, r, "extends", t, 1), c(i.body, r, "body", e, 1), r;
  }
  s(z0, "interfaceTypeAnnotation");
  function H0(t) {
    let e = {
      type: "IntersectionTypeAnnotation",
      types: t
    }, r = P.IntersectionTypeAnnotation;
    return c(r.types, e, "types", t, 1), e;
  }
  s(H0, "intersectionTypeAnnotation");
  function G0() {
    return {
      type: "MixedTypeAnnotation"
    };
  }
  s(G0, "mixedTypeAnnotation");
  function Q0() {
    return {
      type: "EmptyTypeAnnotation"
    };
  }
  s(Q0, "emptyTypeAnnotation");
  function Z0(t) {
    let e = {
      type: "NullableTypeAnnotation",
      typeAnnotation: t
    }, r = P.NullableTypeAnnotation;
    return c(r.typeAnnotation, e, "typeAnnotation", t, 1), e;
  }
  s(Z0, "nullableTypeAnnotation");
  function ex(t) {
    let e = {
      type: "NumberLiteralTypeAnnotation",
      value: t
    }, r = P.NumberLiteralTypeAnnotation;
    return c(r.value, e, "value", t), e;
  }
  s(ex, "numberLiteralTypeAnnotation");
  function tx() {
    return {
      type: "NumberTypeAnnotation"
    };
  }
  s(tx, "numberTypeAnnotation");
  function rx(t, e = [], r = [], i = [], n = !1) {
    let a = {
      type: "ObjectTypeAnnotation",
      properties: t,
      indexers: e,
      callProperties: r,
      internalSlots: i,
      exact: n
    }, o = P.ObjectTypeAnnotation;
    return c(o.properties, a, "properties", t, 1), c(o.indexers, a, "indexers", e, 1), c(o.callProperties, a, "callProperties", r, 1), c(o.internalSlots,
    a, "internalSlots", i, 1), c(o.exact, a, "exact", n), a;
  }
  s(rx, "objectTypeAnnotation");
  function ix(t, e, r, i, n) {
    let a = {
      type: "ObjectTypeInternalSlot",
      id: t,
      value: e,
      optional: r,
      static: i,
      method: n
    }, o = P.ObjectTypeInternalSlot;
    return c(o.id, a, "id", t, 1), c(o.value, a, "value", e, 1), c(o.optional, a, "optional", r), c(o.static, a, "static", i), c(o.method, a,
    "method", n), a;
  }
  s(ix, "objectTypeInternalSlot");
  function sx(t) {
    let e = {
      type: "ObjectTypeCallProperty",
      value: t,
      static: null
    }, r = P.ObjectTypeCallProperty;
    return c(r.value, e, "value", t, 1), e;
  }
  s(sx, "objectTypeCallProperty");
  function nx(t = null, e, r, i = null) {
    let n = {
      type: "ObjectTypeIndexer",
      id: t,
      key: e,
      value: r,
      variance: i,
      static: null
    }, a = P.ObjectTypeIndexer;
    return c(a.id, n, "id", t, 1), c(a.key, n, "key", e, 1), c(a.value, n, "value", r, 1), c(a.variance, n, "variance", i, 1), n;
  }
  s(nx, "objectTypeIndexer");
  function ax(t, e, r = null) {
    let i = {
      type: "ObjectTypeProperty",
      key: t,
      value: e,
      variance: r,
      kind: null,
      method: null,
      optional: null,
      proto: null,
      static: null
    }, n = P.ObjectTypeProperty;
    return c(n.key, i, "key", t, 1), c(n.value, i, "value", e, 1), c(n.variance, i, "variance", r, 1), i;
  }
  s(ax, "objectTypeProperty");
  function ox(t) {
    let e = {
      type: "ObjectTypeSpreadProperty",
      argument: t
    }, r = P.ObjectTypeSpreadProperty;
    return c(r.argument, e, "argument", t, 1), e;
  }
  s(ox, "objectTypeSpreadProperty");
  function lx(t, e = null, r = null, i) {
    let n = {
      type: "OpaqueType",
      id: t,
      typeParameters: e,
      supertype: r,
      impltype: i
    }, a = P.OpaqueType;
    return c(a.id, n, "id", t, 1), c(a.typeParameters, n, "typeParameters", e, 1), c(a.supertype, n, "supertype", r, 1), c(a.impltype, n, "i\
mpltype", i, 1), n;
  }
  s(lx, "opaqueType");
  function ux(t, e) {
    let r = {
      type: "QualifiedTypeIdentifier",
      id: t,
      qualification: e
    }, i = P.QualifiedTypeIdentifier;
    return c(i.id, r, "id", t, 1), c(i.qualification, r, "qualification", e, 1), r;
  }
  s(ux, "qualifiedTypeIdentifier");
  function cx(t) {
    let e = {
      type: "StringLiteralTypeAnnotation",
      value: t
    }, r = P.StringLiteralTypeAnnotation;
    return c(r.value, e, "value", t), e;
  }
  s(cx, "stringLiteralTypeAnnotation");
  function px() {
    return {
      type: "StringTypeAnnotation"
    };
  }
  s(px, "stringTypeAnnotation");
  function fx() {
    return {
      type: "SymbolTypeAnnotation"
    };
  }
  s(fx, "symbolTypeAnnotation");
  function hx() {
    return {
      type: "ThisTypeAnnotation"
    };
  }
  s(hx, "thisTypeAnnotation");
  function dx(t) {
    let e = {
      type: "TupleTypeAnnotation",
      types: t
    }, r = P.TupleTypeAnnotation;
    return c(r.types, e, "types", t, 1), e;
  }
  s(dx, "tupleTypeAnnotation");
  function mx(t) {
    let e = {
      type: "TypeofTypeAnnotation",
      argument: t
    }, r = P.TypeofTypeAnnotation;
    return c(r.argument, e, "argument", t, 1), e;
  }
  s(mx, "typeofTypeAnnotation");
  function yx(t, e = null, r) {
    let i = {
      type: "TypeAlias",
      id: t,
      typeParameters: e,
      right: r
    }, n = P.TypeAlias;
    return c(n.id, i, "id", t, 1), c(n.typeParameters, i, "typeParameters", e, 1), c(n.right, i, "right", r, 1), i;
  }
  s(yx, "typeAlias");
  function Tx(t) {
    let e = {
      type: "TypeAnnotation",
      typeAnnotation: t
    }, r = P.TypeAnnotation;
    return c(r.typeAnnotation, e, "typeAnnotation", t, 1), e;
  }
  s(Tx, "typeAnnotation");
  function Sx(t, e) {
    let r = {
      type: "TypeCastExpression",
      expression: t,
      typeAnnotation: e
    }, i = P.TypeCastExpression;
    return c(i.expression, r, "expression", t, 1), c(i.typeAnnotation, r, "typeAnnotation", e, 1), r;
  }
  s(Sx, "typeCastExpression");
  function bx(t = null, e = null, r = null) {
    let i = {
      type: "TypeParameter",
      bound: t,
      default: e,
      variance: r,
      name: null
    }, n = P.TypeParameter;
    return c(n.bound, i, "bound", t, 1), c(n.default, i, "default", e, 1), c(n.variance, i, "variance", r, 1), i;
  }
  s(bx, "typeParameter");
  function xx(t) {
    let e = {
      type: "TypeParameterDeclaration",
      params: t
    }, r = P.TypeParameterDeclaration;
    return c(r.params, e, "params", t, 1), e;
  }
  s(xx, "typeParameterDeclaration");
  function gx(t) {
    let e = {
      type: "TypeParameterInstantiation",
      params: t
    }, r = P.TypeParameterInstantiation;
    return c(r.params, e, "params", t, 1), e;
  }
  s(gx, "typeParameterInstantiation");
  function Ex(t) {
    let e = {
      type: "UnionTypeAnnotation",
      types: t
    }, r = P.UnionTypeAnnotation;
    return c(r.types, e, "types", t, 1), e;
  }
  s(Ex, "unionTypeAnnotation");
  function Px(t) {
    let e = {
      type: "Variance",
      kind: t
    }, r = P.Variance;
    return c(r.kind, e, "kind", t), e;
  }
  s(Px, "variance");
  function Ax() {
    return {
      type: "VoidTypeAnnotation"
    };
  }
  s(Ax, "voidTypeAnnotation");
  function Ix(t, e) {
    let r = {
      type: "EnumDeclaration",
      id: t,
      body: e
    }, i = P.EnumDeclaration;
    return c(i.id, r, "id", t, 1), c(i.body, r, "body", e, 1), r;
  }
  s(Ix, "enumDeclaration");
  function vx(t) {
    let e = {
      type: "EnumBooleanBody",
      members: t,
      explicitType: null,
      hasUnknownMembers: null
    }, r = P.EnumBooleanBody;
    return c(r.members, e, "members", t, 1), e;
  }
  s(vx, "enumBooleanBody");
  function Cx(t) {
    let e = {
      type: "EnumNumberBody",
      members: t,
      explicitType: null,
      hasUnknownMembers: null
    }, r = P.EnumNumberBody;
    return c(r.members, e, "members", t, 1), e;
  }
  s(Cx, "enumNumberBody");
  function wx(t) {
    let e = {
      type: "EnumStringBody",
      members: t,
      explicitType: null,
      hasUnknownMembers: null
    }, r = P.EnumStringBody;
    return c(r.members, e, "members", t, 1), e;
  }
  s(wx, "enumStringBody");
  function Nx(t) {
    let e = {
      type: "EnumSymbolBody",
      members: t,
      hasUnknownMembers: null
    }, r = P.EnumSymbolBody;
    return c(r.members, e, "members", t, 1), e;
  }
  s(Nx, "enumSymbolBody");
  function Ox(t) {
    let e = {
      type: "EnumBooleanMember",
      id: t,
      init: null
    }, r = P.EnumBooleanMember;
    return c(r.id, e, "id", t, 1), e;
  }
  s(Ox, "enumBooleanMember");
  function _x(t, e) {
    let r = {
      type: "EnumNumberMember",
      id: t,
      init: e
    }, i = P.EnumNumberMember;
    return c(i.id, r, "id", t, 1), c(i.init, r, "init", e, 1), r;
  }
  s(_x, "enumNumberMember");
  function Dx(t, e) {
    let r = {
      type: "EnumStringMember",
      id: t,
      init: e
    }, i = P.EnumStringMember;
    return c(i.id, r, "id", t, 1), c(i.init, r, "init", e, 1), r;
  }
  s(Dx, "enumStringMember");
  function kx(t) {
    let e = {
      type: "EnumDefaultedMember",
      id: t
    }, r = P.EnumDefaultedMember;
    return c(r.id, e, "id", t, 1), e;
  }
  s(kx, "enumDefaultedMember");
  function Lx(t, e) {
    let r = {
      type: "IndexedAccessType",
      objectType: t,
      indexType: e
    }, i = P.IndexedAccessType;
    return c(i.objectType, r, "objectType", t, 1), c(i.indexType, r, "indexType", e, 1), r;
  }
  s(Lx, "indexedAccessType");
  function Mx(t, e) {
    let r = {
      type: "OptionalIndexedAccessType",
      objectType: t,
      indexType: e,
      optional: null
    }, i = P.OptionalIndexedAccessType;
    return c(i.objectType, r, "objectType", t, 1), c(i.indexType, r, "indexType", e, 1), r;
  }
  s(Mx, "optionalIndexedAccessType");
  function Bx(t, e = null) {
    let r = {
      type: "JSXAttribute",
      name: t,
      value: e
    }, i = P.JSXAttribute;
    return c(i.name, r, "name", t, 1), c(i.value, r, "value", e, 1), r;
  }
  s(Bx, "jsxAttribute");
  function jx(t) {
    let e = {
      type: "JSXClosingElement",
      name: t
    }, r = P.JSXClosingElement;
    return c(r.name, e, "name", t, 1), e;
  }
  s(jx, "jsxClosingElement");
  function Fx(t, e = null, r, i = null) {
    let n = {
      type: "JSXElement",
      openingElement: t,
      closingElement: e,
      children: r,
      selfClosing: i
    }, a = P.JSXElement;
    return c(a.openingElement, n, "openingElement", t, 1), c(a.closingElement, n, "closingElement", e, 1), c(a.children, n, "children", r, 1),
    c(a.selfClosing, n, "selfClosing", i), n;
  }
  s(Fx, "jsxElement");
  function Rx() {
    return {
      type: "JSXEmptyExpression"
    };
  }
  s(Rx, "jsxEmptyExpression");
  function qx(t) {
    let e = {
      type: "JSXExpressionContainer",
      expression: t
    }, r = P.JSXExpressionContainer;
    return c(r.expression, e, "expression", t, 1), e;
  }
  s(qx, "jsxExpressionContainer");
  function Ux(t) {
    let e = {
      type: "JSXSpreadChild",
      expression: t
    }, r = P.JSXSpreadChild;
    return c(r.expression, e, "expression", t, 1), e;
  }
  s(Ux, "jsxSpreadChild");
  function Kx(t) {
    let e = {
      type: "JSXIdentifier",
      name: t
    }, r = P.JSXIdentifier;
    return c(r.name, e, "name", t), e;
  }
  s(Kx, "jsxIdentifier");
  function Vx(t, e) {
    let r = {
      type: "JSXMemberExpression",
      object: t,
      property: e
    }, i = P.JSXMemberExpression;
    return c(i.object, r, "object", t, 1), c(i.property, r, "property", e, 1), r;
  }
  s(Vx, "jsxMemberExpression");
  function Yx(t, e) {
    let r = {
      type: "JSXNamespacedName",
      namespace: t,
      name: e
    }, i = P.JSXNamespacedName;
    return c(i.namespace, r, "namespace", t, 1), c(i.name, r, "name", e, 1), r;
  }
  s(Yx, "jsxNamespacedName");
  function Jx(t, e, r = !1) {
    let i = {
      type: "JSXOpeningElement",
      name: t,
      attributes: e,
      selfClosing: r
    }, n = P.JSXOpeningElement;
    return c(n.name, i, "name", t, 1), c(n.attributes, i, "attributes", e, 1), c(n.selfClosing, i, "selfClosing", r), i;
  }
  s(Jx, "jsxOpeningElement");
  function Xx(t) {
    let e = {
      type: "JSXSpreadAttribute",
      argument: t
    }, r = P.JSXSpreadAttribute;
    return c(r.argument, e, "argument", t, 1), e;
  }
  s(Xx, "jsxSpreadAttribute");
  function Wx(t) {
    let e = {
      type: "JSXText",
      value: t
    }, r = P.JSXText;
    return c(r.value, e, "value", t), e;
  }
  s(Wx, "jsxText");
  function $x(t, e, r) {
    let i = {
      type: "JSXFragment",
      openingFragment: t,
      closingFragment: e,
      children: r
    }, n = P.JSXFragment;
    return c(n.openingFragment, i, "openingFragment", t, 1), c(n.closingFragment, i, "closingFragment", e, 1), c(n.children, i, "children", r,
    1), i;
  }
  s($x, "jsxFragment");
  function zx() {
    return {
      type: "JSXOpeningFragment"
    };
  }
  s(zx, "jsxOpeningFragment");
  function Hx() {
    return {
      type: "JSXClosingFragment"
    };
  }
  s(Hx, "jsxClosingFragment");
  function Gx() {
    return {
      type: "Noop"
    };
  }
  s(Gx, "noop");
  function Qx(t, e) {
    let r = {
      type: "Placeholder",
      expectedNode: t,
      name: e
    }, i = P.Placeholder;
    return c(i.expectedNode, r, "expectedNode", t), c(i.name, r, "name", e, 1), r;
  }
  s(Qx, "placeholder");
  function Zx(t) {
    let e = {
      type: "V8IntrinsicIdentifier",
      name: t
    }, r = P.V8IntrinsicIdentifier;
    return c(r.name, e, "name", t), e;
  }
  s(Zx, "v8IntrinsicIdentifier");
  function eg() {
    return {
      type: "ArgumentPlaceholder"
    };
  }
  s(eg, "argumentPlaceholder");
  function tg(t, e) {
    let r = {
      type: "BindExpression",
      object: t,
      callee: e
    }, i = P.BindExpression;
    return c(i.object, r, "object", t, 1), c(i.callee, r, "callee", e, 1), r;
  }
  s(tg, "bindExpression");
  function rg(t) {
    let e = {
      type: "Decorator",
      expression: t
    }, r = P.Decorator;
    return c(r.expression, e, "expression", t, 1), e;
  }
  s(rg, "decorator");
  function ig(t, e = !1) {
    let r = {
      type: "DoExpression",
      body: t,
      async: e
    }, i = P.DoExpression;
    return c(i.body, r, "body", t, 1), c(i.async, r, "async", e), r;
  }
  s(ig, "doExpression");
  function sg(t) {
    let e = {
      type: "ExportDefaultSpecifier",
      exported: t
    }, r = P.ExportDefaultSpecifier;
    return c(r.exported, e, "exported", t, 1), e;
  }
  s(sg, "exportDefaultSpecifier");
  function ng(t) {
    let e = {
      type: "RecordExpression",
      properties: t
    }, r = P.RecordExpression;
    return c(r.properties, e, "properties", t, 1), e;
  }
  s(ng, "recordExpression");
  function ag(t = []) {
    let e = {
      type: "TupleExpression",
      elements: t
    }, r = P.TupleExpression;
    return c(r.elements, e, "elements", t, 1), e;
  }
  s(ag, "tupleExpression");
  function og(t) {
    let e = {
      type: "DecimalLiteral",
      value: t
    }, r = P.DecimalLiteral;
    return c(r.value, e, "value", t), e;
  }
  s(og, "decimalLiteral");
  function lg(t) {
    let e = {
      type: "ModuleExpression",
      body: t
    }, r = P.ModuleExpression;
    return c(r.body, e, "body", t, 1), e;
  }
  s(lg, "moduleExpression");
  function ug() {
    return {
      type: "TopicReference"
    };
  }
  s(ug, "topicReference");
  function cg(t) {
    let e = {
      type: "PipelineTopicExpression",
      expression: t
    }, r = P.PipelineTopicExpression;
    return c(r.expression, e, "expression", t, 1), e;
  }
  s(cg, "pipelineTopicExpression");
  function pg(t) {
    let e = {
      type: "PipelineBareFunction",
      callee: t
    }, r = P.PipelineBareFunction;
    return c(r.callee, e, "callee", t, 1), e;
  }
  s(pg, "pipelineBareFunction");
  function fg() {
    return {
      type: "PipelinePrimaryTopicReference"
    };
  }
  s(fg, "pipelinePrimaryTopicReference");
  function hg(t) {
    let e = {
      type: "TSParameterProperty",
      parameter: t
    }, r = P.TSParameterProperty;
    return c(r.parameter, e, "parameter", t, 1), e;
  }
  s(hg, "tsParameterProperty");
  function dg(t = null, e = null, r, i = null) {
    let n = {
      type: "TSDeclareFunction",
      id: t,
      typeParameters: e,
      params: r,
      returnType: i
    }, a = P.TSDeclareFunction;
    return c(a.id, n, "id", t, 1), c(a.typeParameters, n, "typeParameters", e, 1), c(a.params, n, "params", r, 1), c(a.returnType, n, "retur\
nType", i, 1), n;
  }
  s(dg, "tsDeclareFunction");
  function mg(t = null, e, r = null, i, n = null) {
    let a = {
      type: "TSDeclareMethod",
      decorators: t,
      key: e,
      typeParameters: r,
      params: i,
      returnType: n
    }, o = P.TSDeclareMethod;
    return c(o.decorators, a, "decorators", t, 1), c(o.key, a, "key", e, 1), c(o.typeParameters, a, "typeParameters", r, 1), c(o.params, a, "\
params", i, 1), c(o.returnType, a, "returnType", n, 1), a;
  }
  s(mg, "tsDeclareMethod");
  function yg(t, e) {
    let r = {
      type: "TSQualifiedName",
      left: t,
      right: e
    }, i = P.TSQualifiedName;
    return c(i.left, r, "left", t, 1), c(i.right, r, "right", e, 1), r;
  }
  s(yg, "tsQualifiedName");
  function Tg(t = null, e, r = null) {
    let i = {
      type: "TSCallSignatureDeclaration",
      typeParameters: t,
      parameters: e,
      typeAnnotation: r
    }, n = P.TSCallSignatureDeclaration;
    return c(n.typeParameters, i, "typeParameters", t, 1), c(n.parameters, i, "parameters", e, 1), c(n.typeAnnotation, i, "typeAnnotation", r,
    1), i;
  }
  s(Tg, "tsCallSignatureDeclaration");
  function Sg(t = null, e, r = null) {
    let i = {
      type: "TSConstructSignatureDeclaration",
      typeParameters: t,
      parameters: e,
      typeAnnotation: r
    }, n = P.TSConstructSignatureDeclaration;
    return c(n.typeParameters, i, "typeParameters", t, 1), c(n.parameters, i, "parameters", e, 1), c(n.typeAnnotation, i, "typeAnnotation", r,
    1), i;
  }
  s(Sg, "tsConstructSignatureDeclaration");
  function bg(t, e = null) {
    let r = {
      type: "TSPropertySignature",
      key: t,
      typeAnnotation: e
    }, i = P.TSPropertySignature;
    return c(i.key, r, "key", t, 1), c(i.typeAnnotation, r, "typeAnnotation", e, 1), r;
  }
  s(bg, "tsPropertySignature");
  function xg(t, e = null, r, i = null) {
    let n = {
      type: "TSMethodSignature",
      key: t,
      typeParameters: e,
      parameters: r,
      typeAnnotation: i,
      kind: null
    }, a = P.TSMethodSignature;
    return c(a.key, n, "key", t, 1), c(a.typeParameters, n, "typeParameters", e, 1), c(a.parameters, n, "parameters", r, 1), c(a.typeAnnotation,
    n, "typeAnnotation", i, 1), n;
  }
  s(xg, "tsMethodSignature");
  function gg(t, e = null) {
    let r = {
      type: "TSIndexSignature",
      parameters: t,
      typeAnnotation: e
    }, i = P.TSIndexSignature;
    return c(i.parameters, r, "parameters", t, 1), c(i.typeAnnotation, r, "typeAnnotation", e, 1), r;
  }
  s(gg, "tsIndexSignature");
  function Eg() {
    return {
      type: "TSAnyKeyword"
    };
  }
  s(Eg, "tsAnyKeyword");
  function Pg() {
    return {
      type: "TSBooleanKeyword"
    };
  }
  s(Pg, "tsBooleanKeyword");
  function Ag() {
    return {
      type: "TSBigIntKeyword"
    };
  }
  s(Ag, "tsBigIntKeyword");
  function Ig() {
    return {
      type: "TSIntrinsicKeyword"
    };
  }
  s(Ig, "tsIntrinsicKeyword");
  function vg() {
    return {
      type: "TSNeverKeyword"
    };
  }
  s(vg, "tsNeverKeyword");
  function Cg() {
    return {
      type: "TSNullKeyword"
    };
  }
  s(Cg, "tsNullKeyword");
  function wg() {
    return {
      type: "TSNumberKeyword"
    };
  }
  s(wg, "tsNumberKeyword");
  function Ng() {
    return {
      type: "TSObjectKeyword"
    };
  }
  s(Ng, "tsObjectKeyword");
  function Og() {
    return {
      type: "TSStringKeyword"
    };
  }
  s(Og, "tsStringKeyword");
  function _g() {
    return {
      type: "TSSymbolKeyword"
    };
  }
  s(_g, "tsSymbolKeyword");
  function Dg() {
    return {
      type: "TSUndefinedKeyword"
    };
  }
  s(Dg, "tsUndefinedKeyword");
  function kg() {
    return {
      type: "TSUnknownKeyword"
    };
  }
  s(kg, "tsUnknownKeyword");
  function Lg() {
    return {
      type: "TSVoidKeyword"
    };
  }
  s(Lg, "tsVoidKeyword");
  function Mg() {
    return {
      type: "TSThisType"
    };
  }
  s(Mg, "tsThisType");
  function Bg(t = null, e, r = null) {
    let i = {
      type: "TSFunctionType",
      typeParameters: t,
      parameters: e,
      typeAnnotation: r
    }, n = P.TSFunctionType;
    return c(n.typeParameters, i, "typeParameters", t, 1), c(n.parameters, i, "parameters", e, 1), c(n.typeAnnotation, i, "typeAnnotation", r,
    1), i;
  }
  s(Bg, "tsFunctionType");
  function jg(t = null, e, r = null) {
    let i = {
      type: "TSConstructorType",
      typeParameters: t,
      parameters: e,
      typeAnnotation: r
    }, n = P.TSConstructorType;
    return c(n.typeParameters, i, "typeParameters", t, 1), c(n.parameters, i, "parameters", e, 1), c(n.typeAnnotation, i, "typeAnnotation", r,
    1), i;
  }
  s(jg, "tsConstructorType");
  function Fg(t, e = null) {
    let r = {
      type: "TSTypeReference",
      typeName: t,
      typeParameters: e
    }, i = P.TSTypeReference;
    return c(i.typeName, r, "typeName", t, 1), c(i.typeParameters, r, "typeParameters", e, 1), r;
  }
  s(Fg, "tsTypeReference");
  function Rg(t, e = null, r = null) {
    let i = {
      type: "TSTypePredicate",
      parameterName: t,
      typeAnnotation: e,
      asserts: r
    }, n = P.TSTypePredicate;
    return c(n.parameterName, i, "parameterName", t, 1), c(n.typeAnnotation, i, "typeAnnotation", e, 1), c(n.asserts, i, "asserts", r), i;
  }
  s(Rg, "tsTypePredicate");
  function qg(t, e = null) {
    let r = {
      type: "TSTypeQuery",
      exprName: t,
      typeParameters: e
    }, i = P.TSTypeQuery;
    return c(i.exprName, r, "exprName", t, 1), c(i.typeParameters, r, "typeParameters", e, 1), r;
  }
  s(qg, "tsTypeQuery");
  function Ug(t) {
    let e = {
      type: "TSTypeLiteral",
      members: t
    }, r = P.TSTypeLiteral;
    return c(r.members, e, "members", t, 1), e;
  }
  s(Ug, "tsTypeLiteral");
  function Kg(t) {
    let e = {
      type: "TSArrayType",
      elementType: t
    }, r = P.TSArrayType;
    return c(r.elementType, e, "elementType", t, 1), e;
  }
  s(Kg, "tsArrayType");
  function Vg(t) {
    let e = {
      type: "TSTupleType",
      elementTypes: t
    }, r = P.TSTupleType;
    return c(r.elementTypes, e, "elementTypes", t, 1), e;
  }
  s(Vg, "tsTupleType");
  function Yg(t) {
    let e = {
      type: "TSOptionalType",
      typeAnnotation: t
    }, r = P.TSOptionalType;
    return c(r.typeAnnotation, e, "typeAnnotation", t, 1), e;
  }
  s(Yg, "tsOptionalType");
  function Jg(t) {
    let e = {
      type: "TSRestType",
      typeAnnotation: t
    }, r = P.TSRestType;
    return c(r.typeAnnotation, e, "typeAnnotation", t, 1), e;
  }
  s(Jg, "tsRestType");
  function Xg(t, e, r = !1) {
    let i = {
      type: "TSNamedTupleMember",
      label: t,
      elementType: e,
      optional: r
    }, n = P.TSNamedTupleMember;
    return c(n.label, i, "label", t, 1), c(n.elementType, i, "elementType", e, 1), c(n.optional, i, "optional", r), i;
  }
  s(Xg, "tsNamedTupleMember");
  function Wg(t) {
    let e = {
      type: "TSUnionType",
      types: t
    }, r = P.TSUnionType;
    return c(r.types, e, "types", t, 1), e;
  }
  s(Wg, "tsUnionType");
  function $g(t) {
    let e = {
      type: "TSIntersectionType",
      types: t
    }, r = P.TSIntersectionType;
    return c(r.types, e, "types", t, 1), e;
  }
  s($g, "tsIntersectionType");
  function zg(t, e, r, i) {
    let n = {
      type: "TSConditionalType",
      checkType: t,
      extendsType: e,
      trueType: r,
      falseType: i
    }, a = P.TSConditionalType;
    return c(a.checkType, n, "checkType", t, 1), c(a.extendsType, n, "extendsType", e, 1), c(a.trueType, n, "trueType", r, 1), c(a.falseType,
    n, "falseType", i, 1), n;
  }
  s(zg, "tsConditionalType");
  function Hg(t) {
    let e = {
      type: "TSInferType",
      typeParameter: t
    }, r = P.TSInferType;
    return c(r.typeParameter, e, "typeParameter", t, 1), e;
  }
  s(Hg, "tsInferType");
  function Gg(t) {
    let e = {
      type: "TSParenthesizedType",
      typeAnnotation: t
    }, r = P.TSParenthesizedType;
    return c(r.typeAnnotation, e, "typeAnnotation", t, 1), e;
  }
  s(Gg, "tsParenthesizedType");
  function Qg(t) {
    let e = {
      type: "TSTypeOperator",
      typeAnnotation: t,
      operator: null
    }, r = P.TSTypeOperator;
    return c(r.typeAnnotation, e, "typeAnnotation", t, 1), e;
  }
  s(Qg, "tsTypeOperator");
  function Zg(t, e) {
    let r = {
      type: "TSIndexedAccessType",
      objectType: t,
      indexType: e
    }, i = P.TSIndexedAccessType;
    return c(i.objectType, r, "objectType", t, 1), c(i.indexType, r, "indexType", e, 1), r;
  }
  s(Zg, "tsIndexedAccessType");
  function eE(t, e = null, r = null) {
    let i = {
      type: "TSMappedType",
      typeParameter: t,
      typeAnnotation: e,
      nameType: r
    }, n = P.TSMappedType;
    return c(n.typeParameter, i, "typeParameter", t, 1), c(n.typeAnnotation, i, "typeAnnotation", e, 1), c(n.nameType, i, "nameType", r, 1),
    i;
  }
  s(eE, "tsMappedType");
  function tE(t, e) {
    let r = {
      type: "TSTemplateLiteralType",
      quasis: t,
      types: e
    }, i = P.TSTemplateLiteralType;
    return c(i.quasis, r, "quasis", t, 1), c(i.types, r, "types", e, 1), r;
  }
  s(tE, "tsTemplateLiteralType");
  function rE(t) {
    let e = {
      type: "TSLiteralType",
      literal: t
    }, r = P.TSLiteralType;
    return c(r.literal, e, "literal", t, 1), e;
  }
  s(rE, "tsLiteralType");
  function iE(t, e = null) {
    let r = {
      type: "TSExpressionWithTypeArguments",
      expression: t,
      typeParameters: e
    }, i = P.TSExpressionWithTypeArguments;
    return c(i.expression, r, "expression", t, 1), c(i.typeParameters, r, "typeParameters", e, 1), r;
  }
  s(iE, "tsExpressionWithTypeArguments");
  function sE(t, e = null, r = null, i) {
    let n = {
      type: "TSInterfaceDeclaration",
      id: t,
      typeParameters: e,
      extends: r,
      body: i
    }, a = P.TSInterfaceDeclaration;
    return c(a.id, n, "id", t, 1), c(a.typeParameters, n, "typeParameters", e, 1), c(a.extends, n, "extends", r, 1), c(a.body, n, "body", i,
    1), n;
  }
  s(sE, "tsInterfaceDeclaration");
  function nE(t) {
    let e = {
      type: "TSInterfaceBody",
      body: t
    }, r = P.TSInterfaceBody;
    return c(r.body, e, "body", t, 1), e;
  }
  s(nE, "tsInterfaceBody");
  function aE(t, e = null, r) {
    let i = {
      type: "TSTypeAliasDeclaration",
      id: t,
      typeParameters: e,
      typeAnnotation: r
    }, n = P.TSTypeAliasDeclaration;
    return c(n.id, i, "id", t, 1), c(n.typeParameters, i, "typeParameters", e, 1), c(n.typeAnnotation, i, "typeAnnotation", r, 1), i;
  }
  s(aE, "tsTypeAliasDeclaration");
  function oE(t, e = null) {
    let r = {
      type: "TSInstantiationExpression",
      expression: t,
      typeParameters: e
    }, i = P.TSInstantiationExpression;
    return c(i.expression, r, "expression", t, 1), c(i.typeParameters, r, "typeParameters", e, 1), r;
  }
  s(oE, "tsInstantiationExpression");
  function lE(t, e) {
    let r = {
      type: "TSAsExpression",
      expression: t,
      typeAnnotation: e
    }, i = P.TSAsExpression;
    return c(i.expression, r, "expression", t, 1), c(i.typeAnnotation, r, "typeAnnotation", e, 1), r;
  }
  s(lE, "tsAsExpression");
  function uE(t, e) {
    let r = {
      type: "TSSatisfiesExpression",
      expression: t,
      typeAnnotation: e
    }, i = P.TSSatisfiesExpression;
    return c(i.expression, r, "expression", t, 1), c(i.typeAnnotation, r, "typeAnnotation", e, 1), r;
  }
  s(uE, "tsSatisfiesExpression");
  function cE(t, e) {
    let r = {
      type: "TSTypeAssertion",
      typeAnnotation: t,
      expression: e
    }, i = P.TSTypeAssertion;
    return c(i.typeAnnotation, r, "typeAnnotation", t, 1), c(i.expression, r, "expression", e, 1), r;
  }
  s(cE, "tsTypeAssertion");
  function pE(t) {
    let e = {
      type: "TSEnumBody",
      members: t
    }, r = P.TSEnumBody;
    return c(r.members, e, "members", t, 1), e;
  }
  s(pE, "tsEnumBody");
  function fE(t, e) {
    let r = {
      type: "TSEnumDeclaration",
      id: t,
      members: e
    }, i = P.TSEnumDeclaration;
    return c(i.id, r, "id", t, 1), c(i.members, r, "members", e, 1), r;
  }
  s(fE, "tsEnumDeclaration");
  function hE(t, e = null) {
    let r = {
      type: "TSEnumMember",
      id: t,
      initializer: e
    }, i = P.TSEnumMember;
    return c(i.id, r, "id", t, 1), c(i.initializer, r, "initializer", e, 1), r;
  }
  s(hE, "tsEnumMember");
  function dE(t, e) {
    let r = {
      type: "TSModuleDeclaration",
      id: t,
      body: e,
      kind: null
    }, i = P.TSModuleDeclaration;
    return c(i.id, r, "id", t, 1), c(i.body, r, "body", e, 1), r;
  }
  s(dE, "tsModuleDeclaration");
  function mE(t) {
    let e = {
      type: "TSModuleBlock",
      body: t
    }, r = P.TSModuleBlock;
    return c(r.body, e, "body", t, 1), e;
  }
  s(mE, "tsModuleBlock");
  function yE(t, e = null, r = null) {
    let i = {
      type: "TSImportType",
      argument: t,
      qualifier: e,
      typeParameters: r
    }, n = P.TSImportType;
    return c(n.argument, i, "argument", t, 1), c(n.qualifier, i, "qualifier", e, 1), c(n.typeParameters, i, "typeParameters", r, 1), i;
  }
  s(yE, "tsImportType");
  function TE(t, e) {
    let r = {
      type: "TSImportEqualsDeclaration",
      id: t,
      moduleReference: e,
      isExport: null
    }, i = P.TSImportEqualsDeclaration;
    return c(i.id, r, "id", t, 1), c(i.moduleReference, r, "moduleReference", e, 1), r;
  }
  s(TE, "tsImportEqualsDeclaration");
  function SE(t) {
    let e = {
      type: "TSExternalModuleReference",
      expression: t
    }, r = P.TSExternalModuleReference;
    return c(r.expression, e, "expression", t, 1), e;
  }
  s(SE, "tsExternalModuleReference");
  function bE(t) {
    let e = {
      type: "TSNonNullExpression",
      expression: t
    }, r = P.TSNonNullExpression;
    return c(r.expression, e, "expression", t, 1), e;
  }
  s(bE, "tsNonNullExpression");
  function xE(t) {
    let e = {
      type: "TSExportAssignment",
      expression: t
    }, r = P.TSExportAssignment;
    return c(r.expression, e, "expression", t, 1), e;
  }
  s(xE, "tsExportAssignment");
  function gE(t) {
    let e = {
      type: "TSNamespaceExportDeclaration",
      id: t
    }, r = P.TSNamespaceExportDeclaration;
    return c(r.id, e, "id", t, 1), e;
  }
  s(gE, "tsNamespaceExportDeclaration");
  function EE(t) {
    let e = {
      type: "TSTypeAnnotation",
      typeAnnotation: t
    }, r = P.TSTypeAnnotation;
    return c(r.typeAnnotation, e, "typeAnnotation", t, 1), e;
  }
  s(EE, "tsTypeAnnotation");
  function PE(t) {
    let e = {
      type: "TSTypeParameterInstantiation",
      params: t
    }, r = P.TSTypeParameterInstantiation;
    return c(r.params, e, "params", t, 1), e;
  }
  s(PE, "tsTypeParameterInstantiation");
  function AE(t) {
    let e = {
      type: "TSTypeParameterDeclaration",
      params: t
    }, r = P.TSTypeParameterDeclaration;
    return c(r.params, e, "params", t, 1), e;
  }
  s(AE, "tsTypeParameterDeclaration");
  function IE(t = null, e = null, r) {
    let i = {
      type: "TSTypeParameter",
      constraint: t,
      default: e,
      name: r
    }, n = P.TSTypeParameter;
    return c(n.constraint, i, "constraint", t, 1), c(n.default, i, "default", e, 1), c(n.name, i, "name", r), i;
  }
  s(IE, "tsTypeParameter");
  function vE(t) {
    return (0, Ci.default)("NumberLiteral", "NumericLiteral", "The node type "), ql(t);
  }
  s(vE, "NumberLiteral");
  function CE(t, e = "") {
    return (0, Ci.default)("RegexLiteral", "RegExpLiteral", "The node type "), Ul(t, e);
  }
  s(CE, "RegexLiteral");
  function wE(t) {
    return (0, Ci.default)("RestProperty", "RestElement", "The node type "), Kl(t);
  }
  s(wE, "RestProperty");
  function NE(t) {
    return (0, Ci.default)("SpreadProperty", "SpreadElement", "The node type "), Vl(t);
  }
  s(NE, "SpreadProperty");
});

// ../node_modules/@babel/types/lib/builders/generated/uppercase.js
var Yl = D((b) => {
  "use strict";
  Object.defineProperty(b, "__esModule", {
    value: !0
  });
  Object.defineProperty(b, "AnyTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.anyTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "ArgumentPlaceholder", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.argumentPlaceholder;
    }, "get")
  });
  Object.defineProperty(b, "ArrayExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.arrayExpression;
    }, "get")
  });
  Object.defineProperty(b, "ArrayPattern", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.arrayPattern;
    }, "get")
  });
  Object.defineProperty(b, "ArrayTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.arrayTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "ArrowFunctionExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.arrowFunctionExpression;
    }, "get")
  });
  Object.defineProperty(b, "AssignmentExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.assignmentExpression;
    }, "get")
  });
  Object.defineProperty(b, "AssignmentPattern", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.assignmentPattern;
    }, "get")
  });
  Object.defineProperty(b, "AwaitExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.awaitExpression;
    }, "get")
  });
  Object.defineProperty(b, "BigIntLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.bigIntLiteral;
    }, "get")
  });
  Object.defineProperty(b, "BinaryExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.binaryExpression;
    }, "get")
  });
  Object.defineProperty(b, "BindExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.bindExpression;
    }, "get")
  });
  Object.defineProperty(b, "BlockStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.blockStatement;
    }, "get")
  });
  Object.defineProperty(b, "BooleanLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.booleanLiteral;
    }, "get")
  });
  Object.defineProperty(b, "BooleanLiteralTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.booleanLiteralTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "BooleanTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.booleanTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "BreakStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.breakStatement;
    }, "get")
  });
  Object.defineProperty(b, "CallExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.callExpression;
    }, "get")
  });
  Object.defineProperty(b, "CatchClause", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.catchClause;
    }, "get")
  });
  Object.defineProperty(b, "ClassAccessorProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.classAccessorProperty;
    }, "get")
  });
  Object.defineProperty(b, "ClassBody", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.classBody;
    }, "get")
  });
  Object.defineProperty(b, "ClassDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.classDeclaration;
    }, "get")
  });
  Object.defineProperty(b, "ClassExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.classExpression;
    }, "get")
  });
  Object.defineProperty(b, "ClassImplements", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.classImplements;
    }, "get")
  });
  Object.defineProperty(b, "ClassMethod", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.classMethod;
    }, "get")
  });
  Object.defineProperty(b, "ClassPrivateMethod", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.classPrivateMethod;
    }, "get")
  });
  Object.defineProperty(b, "ClassPrivateProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.classPrivateProperty;
    }, "get")
  });
  Object.defineProperty(b, "ClassProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.classProperty;
    }, "get")
  });
  Object.defineProperty(b, "ConditionalExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.conditionalExpression;
    }, "get")
  });
  Object.defineProperty(b, "ContinueStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.continueStatement;
    }, "get")
  });
  Object.defineProperty(b, "DebuggerStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.debuggerStatement;
    }, "get")
  });
  Object.defineProperty(b, "DecimalLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.decimalLiteral;
    }, "get")
  });
  Object.defineProperty(b, "DeclareClass", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.declareClass;
    }, "get")
  });
  Object.defineProperty(b, "DeclareExportAllDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.declareExportAllDeclaration;
    }, "get")
  });
  Object.defineProperty(b, "DeclareExportDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.declareExportDeclaration;
    }, "get")
  });
  Object.defineProperty(b, "DeclareFunction", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.declareFunction;
    }, "get")
  });
  Object.defineProperty(b, "DeclareInterface", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.declareInterface;
    }, "get")
  });
  Object.defineProperty(b, "DeclareModule", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.declareModule;
    }, "get")
  });
  Object.defineProperty(b, "DeclareModuleExports", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.declareModuleExports;
    }, "get")
  });
  Object.defineProperty(b, "DeclareOpaqueType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.declareOpaqueType;
    }, "get")
  });
  Object.defineProperty(b, "DeclareTypeAlias", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.declareTypeAlias;
    }, "get")
  });
  Object.defineProperty(b, "DeclareVariable", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.declareVariable;
    }, "get")
  });
  Object.defineProperty(b, "DeclaredPredicate", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.declaredPredicate;
    }, "get")
  });
  Object.defineProperty(b, "Decorator", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.decorator;
    }, "get")
  });
  Object.defineProperty(b, "Directive", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.directive;
    }, "get")
  });
  Object.defineProperty(b, "DirectiveLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.directiveLiteral;
    }, "get")
  });
  Object.defineProperty(b, "DoExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.doExpression;
    }, "get")
  });
  Object.defineProperty(b, "DoWhileStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.doWhileStatement;
    }, "get")
  });
  Object.defineProperty(b, "EmptyStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.emptyStatement;
    }, "get")
  });
  Object.defineProperty(b, "EmptyTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.emptyTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "EnumBooleanBody", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.enumBooleanBody;
    }, "get")
  });
  Object.defineProperty(b, "EnumBooleanMember", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.enumBooleanMember;
    }, "get")
  });
  Object.defineProperty(b, "EnumDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.enumDeclaration;
    }, "get")
  });
  Object.defineProperty(b, "EnumDefaultedMember", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.enumDefaultedMember;
    }, "get")
  });
  Object.defineProperty(b, "EnumNumberBody", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.enumNumberBody;
    }, "get")
  });
  Object.defineProperty(b, "EnumNumberMember", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.enumNumberMember;
    }, "get")
  });
  Object.defineProperty(b, "EnumStringBody", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.enumStringBody;
    }, "get")
  });
  Object.defineProperty(b, "EnumStringMember", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.enumStringMember;
    }, "get")
  });
  Object.defineProperty(b, "EnumSymbolBody", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.enumSymbolBody;
    }, "get")
  });
  Object.defineProperty(b, "ExistsTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.existsTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "ExportAllDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.exportAllDeclaration;
    }, "get")
  });
  Object.defineProperty(b, "ExportDefaultDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.exportDefaultDeclaration;
    }, "get")
  });
  Object.defineProperty(b, "ExportDefaultSpecifier", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.exportDefaultSpecifier;
    }, "get")
  });
  Object.defineProperty(b, "ExportNamedDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.exportNamedDeclaration;
    }, "get")
  });
  Object.defineProperty(b, "ExportNamespaceSpecifier", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.exportNamespaceSpecifier;
    }, "get")
  });
  Object.defineProperty(b, "ExportSpecifier", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.exportSpecifier;
    }, "get")
  });
  Object.defineProperty(b, "ExpressionStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.expressionStatement;
    }, "get")
  });
  Object.defineProperty(b, "File", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.file;
    }, "get")
  });
  Object.defineProperty(b, "ForInStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.forInStatement;
    }, "get")
  });
  Object.defineProperty(b, "ForOfStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.forOfStatement;
    }, "get")
  });
  Object.defineProperty(b, "ForStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.forStatement;
    }, "get")
  });
  Object.defineProperty(b, "FunctionDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.functionDeclaration;
    }, "get")
  });
  Object.defineProperty(b, "FunctionExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.functionExpression;
    }, "get")
  });
  Object.defineProperty(b, "FunctionTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.functionTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "FunctionTypeParam", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.functionTypeParam;
    }, "get")
  });
  Object.defineProperty(b, "GenericTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.genericTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "Identifier", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.identifier;
    }, "get")
  });
  Object.defineProperty(b, "IfStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.ifStatement;
    }, "get")
  });
  Object.defineProperty(b, "Import", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.import;
    }, "get")
  });
  Object.defineProperty(b, "ImportAttribute", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.importAttribute;
    }, "get")
  });
  Object.defineProperty(b, "ImportDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.importDeclaration;
    }, "get")
  });
  Object.defineProperty(b, "ImportDefaultSpecifier", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.importDefaultSpecifier;
    }, "get")
  });
  Object.defineProperty(b, "ImportExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.importExpression;
    }, "get")
  });
  Object.defineProperty(b, "ImportNamespaceSpecifier", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.importNamespaceSpecifier;
    }, "get")
  });
  Object.defineProperty(b, "ImportSpecifier", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.importSpecifier;
    }, "get")
  });
  Object.defineProperty(b, "IndexedAccessType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.indexedAccessType;
    }, "get")
  });
  Object.defineProperty(b, "InferredPredicate", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.inferredPredicate;
    }, "get")
  });
  Object.defineProperty(b, "InterfaceDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.interfaceDeclaration;
    }, "get")
  });
  Object.defineProperty(b, "InterfaceExtends", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.interfaceExtends;
    }, "get")
  });
  Object.defineProperty(b, "InterfaceTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.interfaceTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "InterpreterDirective", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.interpreterDirective;
    }, "get")
  });
  Object.defineProperty(b, "IntersectionTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.intersectionTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "JSXAttribute", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.jsxAttribute;
    }, "get")
  });
  Object.defineProperty(b, "JSXClosingElement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.jsxClosingElement;
    }, "get")
  });
  Object.defineProperty(b, "JSXClosingFragment", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.jsxClosingFragment;
    }, "get")
  });
  Object.defineProperty(b, "JSXElement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.jsxElement;
    }, "get")
  });
  Object.defineProperty(b, "JSXEmptyExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.jsxEmptyExpression;
    }, "get")
  });
  Object.defineProperty(b, "JSXExpressionContainer", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.jsxExpressionContainer;
    }, "get")
  });
  Object.defineProperty(b, "JSXFragment", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.jsxFragment;
    }, "get")
  });
  Object.defineProperty(b, "JSXIdentifier", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.jsxIdentifier;
    }, "get")
  });
  Object.defineProperty(b, "JSXMemberExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.jsxMemberExpression;
    }, "get")
  });
  Object.defineProperty(b, "JSXNamespacedName", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.jsxNamespacedName;
    }, "get")
  });
  Object.defineProperty(b, "JSXOpeningElement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.jsxOpeningElement;
    }, "get")
  });
  Object.defineProperty(b, "JSXOpeningFragment", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.jsxOpeningFragment;
    }, "get")
  });
  Object.defineProperty(b, "JSXSpreadAttribute", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.jsxSpreadAttribute;
    }, "get")
  });
  Object.defineProperty(b, "JSXSpreadChild", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.jsxSpreadChild;
    }, "get")
  });
  Object.defineProperty(b, "JSXText", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.jsxText;
    }, "get")
  });
  Object.defineProperty(b, "LabeledStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.labeledStatement;
    }, "get")
  });
  Object.defineProperty(b, "LogicalExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.logicalExpression;
    }, "get")
  });
  Object.defineProperty(b, "MemberExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.memberExpression;
    }, "get")
  });
  Object.defineProperty(b, "MetaProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.metaProperty;
    }, "get")
  });
  Object.defineProperty(b, "MixedTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.mixedTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "ModuleExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.moduleExpression;
    }, "get")
  });
  Object.defineProperty(b, "NewExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.newExpression;
    }, "get")
  });
  Object.defineProperty(b, "Noop", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.noop;
    }, "get")
  });
  Object.defineProperty(b, "NullLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.nullLiteral;
    }, "get")
  });
  Object.defineProperty(b, "NullLiteralTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.nullLiteralTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "NullableTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.nullableTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "NumberLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.numberLiteral;
    }, "get")
  });
  Object.defineProperty(b, "NumberLiteralTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.numberLiteralTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "NumberTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.numberTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "NumericLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.numericLiteral;
    }, "get")
  });
  Object.defineProperty(b, "ObjectExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.objectExpression;
    }, "get")
  });
  Object.defineProperty(b, "ObjectMethod", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.objectMethod;
    }, "get")
  });
  Object.defineProperty(b, "ObjectPattern", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.objectPattern;
    }, "get")
  });
  Object.defineProperty(b, "ObjectProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.objectProperty;
    }, "get")
  });
  Object.defineProperty(b, "ObjectTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.objectTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "ObjectTypeCallProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.objectTypeCallProperty;
    }, "get")
  });
  Object.defineProperty(b, "ObjectTypeIndexer", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.objectTypeIndexer;
    }, "get")
  });
  Object.defineProperty(b, "ObjectTypeInternalSlot", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.objectTypeInternalSlot;
    }, "get")
  });
  Object.defineProperty(b, "ObjectTypeProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.objectTypeProperty;
    }, "get")
  });
  Object.defineProperty(b, "ObjectTypeSpreadProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.objectTypeSpreadProperty;
    }, "get")
  });
  Object.defineProperty(b, "OpaqueType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.opaqueType;
    }, "get")
  });
  Object.defineProperty(b, "OptionalCallExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.optionalCallExpression;
    }, "get")
  });
  Object.defineProperty(b, "OptionalIndexedAccessType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.optionalIndexedAccessType;
    }, "get")
  });
  Object.defineProperty(b, "OptionalMemberExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.optionalMemberExpression;
    }, "get")
  });
  Object.defineProperty(b, "ParenthesizedExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.parenthesizedExpression;
    }, "get")
  });
  Object.defineProperty(b, "PipelineBareFunction", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.pipelineBareFunction;
    }, "get")
  });
  Object.defineProperty(b, "PipelinePrimaryTopicReference", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.pipelinePrimaryTopicReference;
    }, "get")
  });
  Object.defineProperty(b, "PipelineTopicExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.pipelineTopicExpression;
    }, "get")
  });
  Object.defineProperty(b, "Placeholder", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.placeholder;
    }, "get")
  });
  Object.defineProperty(b, "PrivateName", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.privateName;
    }, "get")
  });
  Object.defineProperty(b, "Program", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.program;
    }, "get")
  });
  Object.defineProperty(b, "QualifiedTypeIdentifier", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.qualifiedTypeIdentifier;
    }, "get")
  });
  Object.defineProperty(b, "RecordExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.recordExpression;
    }, "get")
  });
  Object.defineProperty(b, "RegExpLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.regExpLiteral;
    }, "get")
  });
  Object.defineProperty(b, "RegexLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.regexLiteral;
    }, "get")
  });
  Object.defineProperty(b, "RestElement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.restElement;
    }, "get")
  });
  Object.defineProperty(b, "RestProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.restProperty;
    }, "get")
  });
  Object.defineProperty(b, "ReturnStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.returnStatement;
    }, "get")
  });
  Object.defineProperty(b, "SequenceExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.sequenceExpression;
    }, "get")
  });
  Object.defineProperty(b, "SpreadElement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.spreadElement;
    }, "get")
  });
  Object.defineProperty(b, "SpreadProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.spreadProperty;
    }, "get")
  });
  Object.defineProperty(b, "StaticBlock", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.staticBlock;
    }, "get")
  });
  Object.defineProperty(b, "StringLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.stringLiteral;
    }, "get")
  });
  Object.defineProperty(b, "StringLiteralTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.stringLiteralTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "StringTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.stringTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "Super", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.super;
    }, "get")
  });
  Object.defineProperty(b, "SwitchCase", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.switchCase;
    }, "get")
  });
  Object.defineProperty(b, "SwitchStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.switchStatement;
    }, "get")
  });
  Object.defineProperty(b, "SymbolTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.symbolTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "TSAnyKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsAnyKeyword;
    }, "get")
  });
  Object.defineProperty(b, "TSArrayType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsArrayType;
    }, "get")
  });
  Object.defineProperty(b, "TSAsExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsAsExpression;
    }, "get")
  });
  Object.defineProperty(b, "TSBigIntKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsBigIntKeyword;
    }, "get")
  });
  Object.defineProperty(b, "TSBooleanKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsBooleanKeyword;
    }, "get")
  });
  Object.defineProperty(b, "TSCallSignatureDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsCallSignatureDeclaration;
    }, "get")
  });
  Object.defineProperty(b, "TSConditionalType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsConditionalType;
    }, "get")
  });
  Object.defineProperty(b, "TSConstructSignatureDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsConstructSignatureDeclaration;
    }, "get")
  });
  Object.defineProperty(b, "TSConstructorType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsConstructorType;
    }, "get")
  });
  Object.defineProperty(b, "TSDeclareFunction", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsDeclareFunction;
    }, "get")
  });
  Object.defineProperty(b, "TSDeclareMethod", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsDeclareMethod;
    }, "get")
  });
  Object.defineProperty(b, "TSEnumBody", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsEnumBody;
    }, "get")
  });
  Object.defineProperty(b, "TSEnumDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsEnumDeclaration;
    }, "get")
  });
  Object.defineProperty(b, "TSEnumMember", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsEnumMember;
    }, "get")
  });
  Object.defineProperty(b, "TSExportAssignment", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsExportAssignment;
    }, "get")
  });
  Object.defineProperty(b, "TSExpressionWithTypeArguments", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsExpressionWithTypeArguments;
    }, "get")
  });
  Object.defineProperty(b, "TSExternalModuleReference", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsExternalModuleReference;
    }, "get")
  });
  Object.defineProperty(b, "TSFunctionType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsFunctionType;
    }, "get")
  });
  Object.defineProperty(b, "TSImportEqualsDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsImportEqualsDeclaration;
    }, "get")
  });
  Object.defineProperty(b, "TSImportType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsImportType;
    }, "get")
  });
  Object.defineProperty(b, "TSIndexSignature", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsIndexSignature;
    }, "get")
  });
  Object.defineProperty(b, "TSIndexedAccessType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsIndexedAccessType;
    }, "get")
  });
  Object.defineProperty(b, "TSInferType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsInferType;
    }, "get")
  });
  Object.defineProperty(b, "TSInstantiationExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsInstantiationExpression;
    }, "get")
  });
  Object.defineProperty(b, "TSInterfaceBody", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsInterfaceBody;
    }, "get")
  });
  Object.defineProperty(b, "TSInterfaceDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsInterfaceDeclaration;
    }, "get")
  });
  Object.defineProperty(b, "TSIntersectionType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsIntersectionType;
    }, "get")
  });
  Object.defineProperty(b, "TSIntrinsicKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsIntrinsicKeyword;
    }, "get")
  });
  Object.defineProperty(b, "TSLiteralType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsLiteralType;
    }, "get")
  });
  Object.defineProperty(b, "TSMappedType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsMappedType;
    }, "get")
  });
  Object.defineProperty(b, "TSMethodSignature", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsMethodSignature;
    }, "get")
  });
  Object.defineProperty(b, "TSModuleBlock", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsModuleBlock;
    }, "get")
  });
  Object.defineProperty(b, "TSModuleDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsModuleDeclaration;
    }, "get")
  });
  Object.defineProperty(b, "TSNamedTupleMember", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsNamedTupleMember;
    }, "get")
  });
  Object.defineProperty(b, "TSNamespaceExportDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsNamespaceExportDeclaration;
    }, "get")
  });
  Object.defineProperty(b, "TSNeverKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsNeverKeyword;
    }, "get")
  });
  Object.defineProperty(b, "TSNonNullExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsNonNullExpression;
    }, "get")
  });
  Object.defineProperty(b, "TSNullKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsNullKeyword;
    }, "get")
  });
  Object.defineProperty(b, "TSNumberKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsNumberKeyword;
    }, "get")
  });
  Object.defineProperty(b, "TSObjectKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsObjectKeyword;
    }, "get")
  });
  Object.defineProperty(b, "TSOptionalType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsOptionalType;
    }, "get")
  });
  Object.defineProperty(b, "TSParameterProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsParameterProperty;
    }, "get")
  });
  Object.defineProperty(b, "TSParenthesizedType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsParenthesizedType;
    }, "get")
  });
  Object.defineProperty(b, "TSPropertySignature", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsPropertySignature;
    }, "get")
  });
  Object.defineProperty(b, "TSQualifiedName", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsQualifiedName;
    }, "get")
  });
  Object.defineProperty(b, "TSRestType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsRestType;
    }, "get")
  });
  Object.defineProperty(b, "TSSatisfiesExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsSatisfiesExpression;
    }, "get")
  });
  Object.defineProperty(b, "TSStringKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsStringKeyword;
    }, "get")
  });
  Object.defineProperty(b, "TSSymbolKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsSymbolKeyword;
    }, "get")
  });
  Object.defineProperty(b, "TSTemplateLiteralType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsTemplateLiteralType;
    }, "get")
  });
  Object.defineProperty(b, "TSThisType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsThisType;
    }, "get")
  });
  Object.defineProperty(b, "TSTupleType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsTupleType;
    }, "get")
  });
  Object.defineProperty(b, "TSTypeAliasDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsTypeAliasDeclaration;
    }, "get")
  });
  Object.defineProperty(b, "TSTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "TSTypeAssertion", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsTypeAssertion;
    }, "get")
  });
  Object.defineProperty(b, "TSTypeLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsTypeLiteral;
    }, "get")
  });
  Object.defineProperty(b, "TSTypeOperator", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsTypeOperator;
    }, "get")
  });
  Object.defineProperty(b, "TSTypeParameter", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsTypeParameter;
    }, "get")
  });
  Object.defineProperty(b, "TSTypeParameterDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsTypeParameterDeclaration;
    }, "get")
  });
  Object.defineProperty(b, "TSTypeParameterInstantiation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsTypeParameterInstantiation;
    }, "get")
  });
  Object.defineProperty(b, "TSTypePredicate", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsTypePredicate;
    }, "get")
  });
  Object.defineProperty(b, "TSTypeQuery", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsTypeQuery;
    }, "get")
  });
  Object.defineProperty(b, "TSTypeReference", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsTypeReference;
    }, "get")
  });
  Object.defineProperty(b, "TSUndefinedKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsUndefinedKeyword;
    }, "get")
  });
  Object.defineProperty(b, "TSUnionType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsUnionType;
    }, "get")
  });
  Object.defineProperty(b, "TSUnknownKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsUnknownKeyword;
    }, "get")
  });
  Object.defineProperty(b, "TSVoidKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tsVoidKeyword;
    }, "get")
  });
  Object.defineProperty(b, "TaggedTemplateExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.taggedTemplateExpression;
    }, "get")
  });
  Object.defineProperty(b, "TemplateElement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.templateElement;
    }, "get")
  });
  Object.defineProperty(b, "TemplateLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.templateLiteral;
    }, "get")
  });
  Object.defineProperty(b, "ThisExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.thisExpression;
    }, "get")
  });
  Object.defineProperty(b, "ThisTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.thisTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "ThrowStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.throwStatement;
    }, "get")
  });
  Object.defineProperty(b, "TopicReference", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.topicReference;
    }, "get")
  });
  Object.defineProperty(b, "TryStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tryStatement;
    }, "get")
  });
  Object.defineProperty(b, "TupleExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tupleExpression;
    }, "get")
  });
  Object.defineProperty(b, "TupleTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.tupleTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "TypeAlias", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.typeAlias;
    }, "get")
  });
  Object.defineProperty(b, "TypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.typeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "TypeCastExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.typeCastExpression;
    }, "get")
  });
  Object.defineProperty(b, "TypeParameter", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.typeParameter;
    }, "get")
  });
  Object.defineProperty(b, "TypeParameterDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.typeParameterDeclaration;
    }, "get")
  });
  Object.defineProperty(b, "TypeParameterInstantiation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.typeParameterInstantiation;
    }, "get")
  });
  Object.defineProperty(b, "TypeofTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.typeofTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "UnaryExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.unaryExpression;
    }, "get")
  });
  Object.defineProperty(b, "UnionTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.unionTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "UpdateExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.updateExpression;
    }, "get")
  });
  Object.defineProperty(b, "V8IntrinsicIdentifier", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.v8IntrinsicIdentifier;
    }, "get")
  });
  Object.defineProperty(b, "VariableDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.variableDeclaration;
    }, "get")
  });
  Object.defineProperty(b, "VariableDeclarator", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.variableDeclarator;
    }, "get")
  });
  Object.defineProperty(b, "Variance", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.variance;
    }, "get")
  });
  Object.defineProperty(b, "VoidTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.voidTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "WhileStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.whileStatement;
    }, "get")
  });
  Object.defineProperty(b, "WithStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.withStatement;
    }, "get")
  });
  Object.defineProperty(b, "YieldExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return x.yieldExpression;
    }, "get")
  });
  var x = Gs();
});

// ../node_modules/@babel/types/lib/builders/generated/index.js
var it = D((Mt) => {
  "use strict";
  Object.defineProperty(Mt, "__esModule", {
    value: !0
  });
  var Qs = Gs();
  Object.keys(Qs).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Mt && Mt[t] === Qs[t] || Object.defineProperty(Mt, t, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return Qs[t];
      }, "get")
    });
  });
  var Zs = Yl();
  Object.keys(Zs).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Mt && Mt[t] === Zs[t] || Object.defineProperty(Mt, t, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return Zs[t];
      }, "get")
    });
  });
});

// ../node_modules/@babel/types/lib/utils/react/cleanJSXElementLiteralChild.js
var Jl = D((en) => {
  "use strict";
  Object.defineProperty(en, "__esModule", {
    value: !0
  });
  en.default = DE;
  var OE = it(), _E = Ye();
  function DE(t, e) {
    let r = t.value.split(/\r\n|\n|\r/), i = 0;
    for (let a = 0; a < r.length; a++)
      /[^ \t]/.exec(r[a]) && (i = a);
    let n = "";
    for (let a = 0; a < r.length; a++) {
      let o = r[a], l = a === 0, u = a === r.length - 1, p = a === i, h = o.replace(/\t/g, " ");
      l || (h = h.replace(/^ +/, "")), u || (h = h.replace(/ +$/, "")), h && (p || (h += " "), n += h);
    }
    n && e.push((0, _E.inherits)((0, OE.stringLiteral)(n), t));
  }
  s(DE, "cleanJSXElementLiteralChild");
});

// ../node_modules/@babel/types/lib/builders/react/buildChildren.js
var Xl = D((rn) => {
  "use strict";
  Object.defineProperty(rn, "__esModule", {
    value: !0
  });
  rn.default = LE;
  var tn = Be(), kE = Jl();
  function LE(t) {
    let e = [];
    for (let r = 0; r < t.children.length; r++) {
      let i = t.children[r];
      if ((0, tn.isJSXText)(i)) {
        (0, kE.default)(i, e);
        continue;
      }
      (0, tn.isJSXExpressionContainer)(i) && (i = i.expression), !(0, tn.isJSXEmptyExpression)(i) && e.push(i);
    }
    return e;
  }
  s(LE, "buildChildren");
});

// ../node_modules/@babel/types/lib/validators/isNode.js
var nn = D((sn) => {
  "use strict";
  Object.defineProperty(sn, "__esModule", {
    value: !0
  });
  sn.default = BE;
  var ME = ot();
  function BE(t) {
    return !!(t && ME.VISITOR_KEYS[t.type]);
  }
  s(BE, "isNode");
});

// ../node_modules/@babel/types/lib/asserts/assertNode.js
var Wl = D((an) => {
  "use strict";
  Object.defineProperty(an, "__esModule", {
    value: !0
  });
  an.default = FE;
  var jE = nn();
  function FE(t) {
    if (!(0, jE.default)(t)) {
      var e;
      let r = (e = t?.type) != null ? e : JSON.stringify(t);
      throw new TypeError(`Not a valid node of type "${r}"`);
    }
  }
  s(FE, "assertNode");
});

// ../node_modules/@babel/types/lib/asserts/generated/index.js
var $l = D((m) => {
  "use strict";
  Object.defineProperty(m, "__esModule", {
    value: !0
  });
  m.assertAccessor = rC;
  m.assertAnyTypeAnnotation = gA;
  m.assertArgumentPlaceholder = H1;
  m.assertArrayExpression = qE;
  m.assertArrayPattern = FP;
  m.assertArrayTypeAnnotation = EA;
  m.assertArrowFunctionExpression = RP;
  m.assertAssignmentExpression = UE;
  m.assertAssignmentPattern = jP;
  m.assertAwaitExpression = lA;
  m.assertBigIntLiteral = cA;
  m.assertBinary = Av;
  m.assertBinaryExpression = KE;
  m.assertBindExpression = G1;
  m.assertBlock = Cv;
  m.assertBlockParent = vv;
  m.assertBlockStatement = XE;
  m.assertBooleanLiteral = hP;
  m.assertBooleanLiteralTypeAnnotation = AA;
  m.assertBooleanTypeAnnotation = PA;
  m.assertBreakStatement = WE;
  m.assertCallExpression = $E;
  m.assertCatchClause = zE;
  m.assertClass = Qv;
  m.assertClassAccessorProperty = mA;
  m.assertClassBody = qP;
  m.assertClassDeclaration = KP;
  m.assertClassExpression = UP;
  m.assertClassImplements = vA;
  m.assertClassMethod = eA;
  m.assertClassPrivateMethod = TA;
  m.assertClassPrivateProperty = yA;
  m.assertClassProperty = dA;
  m.assertCompletionStatement = Ov;
  m.assertConditional = _v;
  m.assertConditionalExpression = HE;
  m.assertContinueStatement = GE;
  m.assertDebuggerStatement = QE;
  m.assertDecimalLiteral = iI;
  m.assertDeclaration = qv;
  m.assertDeclareClass = CA;
  m.assertDeclareExportAllDeclaration = BA;
  m.assertDeclareExportDeclaration = MA;
  m.assertDeclareFunction = wA;
  m.assertDeclareInterface = NA;
  m.assertDeclareModule = OA;
  m.assertDeclareModuleExports = _A;
  m.assertDeclareOpaqueType = kA;
  m.assertDeclareTypeAlias = DA;
  m.assertDeclareVariable = LA;
  m.assertDeclaredPredicate = jA;
  m.assertDecorator = Q1;
  m.assertDirective = YE;
  m.assertDirectiveLiteral = JE;
  m.assertDoExpression = Z1;
  m.assertDoWhileStatement = ZE;
  m.assertEmptyStatement = eP;
  m.assertEmptyTypeAnnotation = $A;
  m.assertEnumBody = uC;
  m.assertEnumBooleanBody = E1;
  m.assertEnumBooleanMember = v1;
  m.assertEnumDeclaration = g1;
  m.assertEnumDefaultedMember = N1;
  m.assertEnumMember = cC;
  m.assertEnumNumberBody = P1;
  m.assertEnumNumberMember = C1;
  m.assertEnumStringBody = A1;
  m.assertEnumStringMember = w1;
  m.assertEnumSymbolBody = I1;
  m.assertExistsTypeAnnotation = FA;
  m.assertExportAllDeclaration = VP;
  m.assertExportDeclaration = eC;
  m.assertExportDefaultDeclaration = YP;
  m.assertExportDefaultSpecifier = eI;
  m.assertExportNamedDeclaration = JP;
  m.assertExportNamespaceSpecifier = pA;
  m.assertExportSpecifier = XP;
  m.assertExpression = Pv;
  m.assertExpressionStatement = tP;
  m.assertExpressionWrapper = Lv;
  m.assertFile = rP;
  m.assertFlow = sC;
  m.assertFlowBaseAnnotation = aC;
  m.assertFlowDeclaration = oC;
  m.assertFlowPredicate = lC;
  m.assertFlowType = nC;
  m.assertFor = Mv;
  m.assertForInStatement = iP;
  m.assertForOfStatement = WP;
  m.assertForStatement = sP;
  m.assertForXStatement = Bv;
  m.assertFunction = jv;
  m.assertFunctionDeclaration = nP;
  m.assertFunctionExpression = aP;
  m.assertFunctionParent = Fv;
  m.assertFunctionTypeAnnotation = RA;
  m.assertFunctionTypeParam = qA;
  m.assertGenericTypeAnnotation = UA;
  m.assertIdentifier = oP;
  m.assertIfStatement = lP;
  m.assertImmutable = Jv;
  m.assertImport = uA;
  m.assertImportAttribute = xA;
  m.assertImportDeclaration = $P;
  m.assertImportDefaultSpecifier = zP;
  m.assertImportExpression = QP;
  m.assertImportNamespaceSpecifier = HP;
  m.assertImportOrExportDeclaration = Zv;
  m.assertImportSpecifier = GP;
  m.assertIndexedAccessType = O1;
  m.assertInferredPredicate = KA;
  m.assertInterfaceDeclaration = YA;
  m.assertInterfaceExtends = VA;
  m.assertInterfaceTypeAnnotation = JA;
  m.assertInterpreterDirective = VE;
  m.assertIntersectionTypeAnnotation = XA;
  m.assertJSX = pC;
  m.assertJSXAttribute = D1;
  m.assertJSXClosingElement = k1;
  m.assertJSXClosingFragment = X1;
  m.assertJSXElement = L1;
  m.assertJSXEmptyExpression = M1;
  m.assertJSXExpressionContainer = B1;
  m.assertJSXFragment = Y1;
  m.assertJSXIdentifier = F1;
  m.assertJSXMemberExpression = R1;
  m.assertJSXNamespacedName = q1;
  m.assertJSXOpeningElement = U1;
  m.assertJSXOpeningFragment = J1;
  m.assertJSXSpreadAttribute = K1;
  m.assertJSXSpreadChild = j1;
  m.assertJSXText = V1;
  m.assertLVal = Kv;
  m.assertLabeledStatement = uP;
  m.assertLiteral = Yv;
  m.assertLogicalExpression = mP;
  m.assertLoop = Dv;
  m.assertMemberExpression = yP;
  m.assertMetaProperty = ZP;
  m.assertMethod = Wv;
  m.assertMiscellaneous = fC;
  m.assertMixedTypeAnnotation = WA;
  m.assertModuleDeclaration = gC;
  m.assertModuleExpression = sI;
  m.assertModuleSpecifier = tC;
  m.assertNewExpression = TP;
  m.assertNoop = W1;
  m.assertNullLiteral = fP;
  m.assertNullLiteralTypeAnnotation = IA;
  m.assertNullableTypeAnnotation = zA;
  m.assertNumberLiteral = TC;
  m.assertNumberLiteralTypeAnnotation = HA;
  m.assertNumberTypeAnnotation = GA;
  m.assertNumericLiteral = pP;
  m.assertObjectExpression = bP;
  m.assertObjectMember = $v;
  m.assertObjectMethod = xP;
  m.assertObjectPattern = tA;
  m.assertObjectProperty = gP;
  m.assertObjectTypeAnnotation = QA;
  m.assertObjectTypeCallProperty = e1;
  m.assertObjectTypeIndexer = t1;
  m.assertObjectTypeInternalSlot = ZA;
  m.assertObjectTypeProperty = r1;
  m.assertObjectTypeSpreadProperty = i1;
  m.assertOpaqueType = s1;
  m.assertOptionalCallExpression = hA;
  m.assertOptionalIndexedAccessType = _1;
  m.assertOptionalMemberExpression = fA;
  m.assertParenthesizedExpression = IP;
  m.assertPattern = Gv;
  m.assertPatternLike = Uv;
  m.assertPipelineBareFunction = oI;
  m.assertPipelinePrimaryTopicReference = lI;
  m.assertPipelineTopicExpression = aI;
  m.assertPlaceholder = $1;
  m.assertPrivate = iC;
  m.assertPrivateName = SA;
  m.assertProgram = SP;
  m.assertProperty = zv;
  m.assertPureish = Rv;
  m.assertQualifiedTypeIdentifier = n1;
  m.assertRecordExpression = tI;
  m.assertRegExpLiteral = dP;
  m.assertRegexLiteral = SC;
  m.assertRestElement = EP;
  m.assertRestProperty = bC;
  m.assertReturnStatement = PP;
  m.assertScopable = Iv;
  m.assertSequenceExpression = AP;
  m.assertSpreadElement = rA;
  m.assertSpreadProperty = xC;
  m.assertStandardized = Ev;
  m.assertStatement = wv;
  m.assertStaticBlock = bA;
  m.assertStringLiteral = cP;
  m.assertStringLiteralTypeAnnotation = a1;
  m.assertStringTypeAnnotation = o1;
  m.assertSuper = iA;
  m.assertSwitchCase = vP;
  m.assertSwitchStatement = CP;
  m.assertSymbolTypeAnnotation = l1;
  m.assertTSAnyKeyword = SI;
  m.assertTSArrayType = FI;
  m.assertTSAsExpression = sv;
  m.assertTSBaseType = yC;
  m.assertTSBigIntKeyword = xI;
  m.assertTSBooleanKeyword = bI;
  m.assertTSCallSignatureDeclaration = hI;
  m.assertTSConditionalType = JI;
  m.assertTSConstructSignatureDeclaration = dI;
  m.assertTSConstructorType = kI;
  m.assertTSDeclareFunction = cI;
  m.assertTSDeclareMethod = pI;
  m.assertTSEntityName = Vv;
  m.assertTSEnumBody = ov;
  m.assertTSEnumDeclaration = lv;
  m.assertTSEnumMember = uv;
  m.assertTSExportAssignment = yv;
  m.assertTSExpressionWithTypeArguments = ZI;
  m.assertTSExternalModuleReference = dv;
  m.assertTSFunctionType = DI;
  m.assertTSImportEqualsDeclaration = hv;
  m.assertTSImportType = fv;
  m.assertTSIndexSignature = TI;
  m.assertTSIndexedAccessType = zI;
  m.assertTSInferType = XI;
  m.assertTSInstantiationExpression = iv;
  m.assertTSInterfaceBody = tv;
  m.assertTSInterfaceDeclaration = ev;
  m.assertTSIntersectionType = YI;
  m.assertTSIntrinsicKeyword = gI;
  m.assertTSLiteralType = QI;
  m.assertTSMappedType = HI;
  m.assertTSMethodSignature = yI;
  m.assertTSModuleBlock = pv;
  m.assertTSModuleDeclaration = cv;
  m.assertTSNamedTupleMember = KI;
  m.assertTSNamespaceExportDeclaration = Tv;
  m.assertTSNeverKeyword = EI;
  m.assertTSNonNullExpression = mv;
  m.assertTSNullKeyword = PI;
  m.assertTSNumberKeyword = AI;
  m.assertTSObjectKeyword = II;
  m.assertTSOptionalType = qI;
  m.assertTSParameterProperty = uI;
  m.assertTSParenthesizedType = WI;
  m.assertTSPropertySignature = mI;
  m.assertTSQualifiedName = fI;
  m.assertTSRestType = UI;
  m.assertTSSatisfiesExpression = nv;
  m.assertTSStringKeyword = vI;
  m.assertTSSymbolKeyword = CI;
  m.assertTSTemplateLiteralType = GI;
  m.assertTSThisType = _I;
  m.assertTSTupleType = RI;
  m.assertTSType = mC;
  m.assertTSTypeAliasDeclaration = rv;
  m.assertTSTypeAnnotation = Sv;
  m.assertTSTypeAssertion = av;
  m.assertTSTypeElement = dC;
  m.assertTSTypeLiteral = jI;
  m.assertTSTypeOperator = $I;
  m.assertTSTypeParameter = gv;
  m.assertTSTypeParameterDeclaration = xv;
  m.assertTSTypeParameterInstantiation = bv;
  m.assertTSTypePredicate = MI;
  m.assertTSTypeQuery = BI;
  m.assertTSTypeReference = LI;
  m.assertTSUndefinedKeyword = wI;
  m.assertTSUnionType = VI;
  m.assertTSUnknownKeyword = NI;
  m.assertTSVoidKeyword = OI;
  m.assertTaggedTemplateExpression = sA;
  m.assertTemplateElement = nA;
  m.assertTemplateLiteral = aA;
  m.assertTerminatorless = Nv;
  m.assertThisExpression = wP;
  m.assertThisTypeAnnotation = u1;
  m.assertThrowStatement = NP;
  m.assertTopicReference = nI;
  m.assertTryStatement = OP;
  m.assertTupleExpression = rI;
  m.assertTupleTypeAnnotation = c1;
  m.assertTypeAlias = f1;
  m.assertTypeAnnotation = h1;
  m.assertTypeCastExpression = d1;
  m.assertTypeParameter = m1;
  m.assertTypeParameterDeclaration = y1;
  m.assertTypeParameterInstantiation = T1;
  m.assertTypeScript = hC;
  m.assertTypeofTypeAnnotation = p1;
  m.assertUnaryExpression = _P;
  m.assertUnaryLike = Hv;
  m.assertUnionTypeAnnotation = S1;
  m.assertUpdateExpression = DP;
  m.assertUserWhitespacable = Xv;
  m.assertV8IntrinsicIdentifier = z1;
  m.assertVariableDeclaration = kP;
  m.assertVariableDeclarator = LP;
  m.assertVariance = b1;
  m.assertVoidTypeAnnotation = x1;
  m.assertWhile = kv;
  m.assertWhileStatement = MP;
  m.assertWithStatement = BP;
  m.assertYieldExpression = oA;
  var RE = sr(), Mr = Ir();
  function y(t, e, r) {
    if (!(0, RE.default)(t, e, r))
      throw new Error(`Expected type "${t}" with option ${JSON.stringify(r)}, but instead got "${e.type}".`);
  }
  s(y, "assert");
  function qE(t, e) {
    y("ArrayExpression", t, e);
  }
  s(qE, "assertArrayExpression");
  function UE(t, e) {
    y("AssignmentExpression", t, e);
  }
  s(UE, "assertAssignmentExpression");
  function KE(t, e) {
    y("BinaryExpression", t, e);
  }
  s(KE, "assertBinaryExpression");
  function VE(t, e) {
    y("InterpreterDirective", t, e);
  }
  s(VE, "assertInterpreterDirective");
  function YE(t, e) {
    y("Directive", t, e);
  }
  s(YE, "assertDirective");
  function JE(t, e) {
    y("DirectiveLiteral", t, e);
  }
  s(JE, "assertDirectiveLiteral");
  function XE(t, e) {
    y("BlockStatement", t, e);
  }
  s(XE, "assertBlockStatement");
  function WE(t, e) {
    y("BreakStatement", t, e);
  }
  s(WE, "assertBreakStatement");
  function $E(t, e) {
    y("CallExpression", t, e);
  }
  s($E, "assertCallExpression");
  function zE(t, e) {
    y("CatchClause", t, e);
  }
  s(zE, "assertCatchClause");
  function HE(t, e) {
    y("ConditionalExpression", t, e);
  }
  s(HE, "assertConditionalExpression");
  function GE(t, e) {
    y("ContinueStatement", t, e);
  }
  s(GE, "assertContinueStatement");
  function QE(t, e) {
    y("DebuggerStatement", t, e);
  }
  s(QE, "assertDebuggerStatement");
  function ZE(t, e) {
    y("DoWhileStatement", t, e);
  }
  s(ZE, "assertDoWhileStatement");
  function eP(t, e) {
    y("EmptyStatement", t, e);
  }
  s(eP, "assertEmptyStatement");
  function tP(t, e) {
    y("ExpressionStatement", t, e);
  }
  s(tP, "assertExpressionStatement");
  function rP(t, e) {
    y("File", t, e);
  }
  s(rP, "assertFile");
  function iP(t, e) {
    y("ForInStatement", t, e);
  }
  s(iP, "assertForInStatement");
  function sP(t, e) {
    y("ForStatement", t, e);
  }
  s(sP, "assertForStatement");
  function nP(t, e) {
    y("FunctionDeclaration", t, e);
  }
  s(nP, "assertFunctionDeclaration");
  function aP(t, e) {
    y("FunctionExpression", t, e);
  }
  s(aP, "assertFunctionExpression");
  function oP(t, e) {
    y("Identifier", t, e);
  }
  s(oP, "assertIdentifier");
  function lP(t, e) {
    y("IfStatement", t, e);
  }
  s(lP, "assertIfStatement");
  function uP(t, e) {
    y("LabeledStatement", t, e);
  }
  s(uP, "assertLabeledStatement");
  function cP(t, e) {
    y("StringLiteral", t, e);
  }
  s(cP, "assertStringLiteral");
  function pP(t, e) {
    y("NumericLiteral", t, e);
  }
  s(pP, "assertNumericLiteral");
  function fP(t, e) {
    y("NullLiteral", t, e);
  }
  s(fP, "assertNullLiteral");
  function hP(t, e) {
    y("BooleanLiteral", t, e);
  }
  s(hP, "assertBooleanLiteral");
  function dP(t, e) {
    y("RegExpLiteral", t, e);
  }
  s(dP, "assertRegExpLiteral");
  function mP(t, e) {
    y("LogicalExpression", t, e);
  }
  s(mP, "assertLogicalExpression");
  function yP(t, e) {
    y("MemberExpression", t, e);
  }
  s(yP, "assertMemberExpression");
  function TP(t, e) {
    y("NewExpression", t, e);
  }
  s(TP, "assertNewExpression");
  function SP(t, e) {
    y("Program", t, e);
  }
  s(SP, "assertProgram");
  function bP(t, e) {
    y("ObjectExpression", t, e);
  }
  s(bP, "assertObjectExpression");
  function xP(t, e) {
    y("ObjectMethod", t, e);
  }
  s(xP, "assertObjectMethod");
  function gP(t, e) {
    y("ObjectProperty", t, e);
  }
  s(gP, "assertObjectProperty");
  function EP(t, e) {
    y("RestElement", t, e);
  }
  s(EP, "assertRestElement");
  function PP(t, e) {
    y("ReturnStatement", t, e);
  }
  s(PP, "assertReturnStatement");
  function AP(t, e) {
    y("SequenceExpression", t, e);
  }
  s(AP, "assertSequenceExpression");
  function IP(t, e) {
    y("ParenthesizedExpression", t, e);
  }
  s(IP, "assertParenthesizedExpression");
  function vP(t, e) {
    y("SwitchCase", t, e);
  }
  s(vP, "assertSwitchCase");
  function CP(t, e) {
    y("SwitchStatement", t, e);
  }
  s(CP, "assertSwitchStatement");
  function wP(t, e) {
    y("ThisExpression", t, e);
  }
  s(wP, "assertThisExpression");
  function NP(t, e) {
    y("ThrowStatement", t, e);
  }
  s(NP, "assertThrowStatement");
  function OP(t, e) {
    y("TryStatement", t, e);
  }
  s(OP, "assertTryStatement");
  function _P(t, e) {
    y("UnaryExpression", t, e);
  }
  s(_P, "assertUnaryExpression");
  function DP(t, e) {
    y("UpdateExpression", t, e);
  }
  s(DP, "assertUpdateExpression");
  function kP(t, e) {
    y("VariableDeclaration", t, e);
  }
  s(kP, "assertVariableDeclaration");
  function LP(t, e) {
    y("VariableDeclarator", t, e);
  }
  s(LP, "assertVariableDeclarator");
  function MP(t, e) {
    y("WhileStatement", t, e);
  }
  s(MP, "assertWhileStatement");
  function BP(t, e) {
    y("WithStatement", t, e);
  }
  s(BP, "assertWithStatement");
  function jP(t, e) {
    y("AssignmentPattern", t, e);
  }
  s(jP, "assertAssignmentPattern");
  function FP(t, e) {
    y("ArrayPattern", t, e);
  }
  s(FP, "assertArrayPattern");
  function RP(t, e) {
    y("ArrowFunctionExpression", t, e);
  }
  s(RP, "assertArrowFunctionExpression");
  function qP(t, e) {
    y("ClassBody", t, e);
  }
  s(qP, "assertClassBody");
  function UP(t, e) {
    y("ClassExpression", t, e);
  }
  s(UP, "assertClassExpression");
  function KP(t, e) {
    y("ClassDeclaration", t, e);
  }
  s(KP, "assertClassDeclaration");
  function VP(t, e) {
    y("ExportAllDeclaration", t, e);
  }
  s(VP, "assertExportAllDeclaration");
  function YP(t, e) {
    y("ExportDefaultDeclaration", t, e);
  }
  s(YP, "assertExportDefaultDeclaration");
  function JP(t, e) {
    y("ExportNamedDeclaration", t, e);
  }
  s(JP, "assertExportNamedDeclaration");
  function XP(t, e) {
    y("ExportSpecifier", t, e);
  }
  s(XP, "assertExportSpecifier");
  function WP(t, e) {
    y("ForOfStatement", t, e);
  }
  s(WP, "assertForOfStatement");
  function $P(t, e) {
    y("ImportDeclaration", t, e);
  }
  s($P, "assertImportDeclaration");
  function zP(t, e) {
    y("ImportDefaultSpecifier", t, e);
  }
  s(zP, "assertImportDefaultSpecifier");
  function HP(t, e) {
    y("ImportNamespaceSpecifier", t, e);
  }
  s(HP, "assertImportNamespaceSpecifier");
  function GP(t, e) {
    y("ImportSpecifier", t, e);
  }
  s(GP, "assertImportSpecifier");
  function QP(t, e) {
    y("ImportExpression", t, e);
  }
  s(QP, "assertImportExpression");
  function ZP(t, e) {
    y("MetaProperty", t, e);
  }
  s(ZP, "assertMetaProperty");
  function eA(t, e) {
    y("ClassMethod", t, e);
  }
  s(eA, "assertClassMethod");
  function tA(t, e) {
    y("ObjectPattern", t, e);
  }
  s(tA, "assertObjectPattern");
  function rA(t, e) {
    y("SpreadElement", t, e);
  }
  s(rA, "assertSpreadElement");
  function iA(t, e) {
    y("Super", t, e);
  }
  s(iA, "assertSuper");
  function sA(t, e) {
    y("TaggedTemplateExpression", t, e);
  }
  s(sA, "assertTaggedTemplateExpression");
  function nA(t, e) {
    y("TemplateElement", t, e);
  }
  s(nA, "assertTemplateElement");
  function aA(t, e) {
    y("TemplateLiteral", t, e);
  }
  s(aA, "assertTemplateLiteral");
  function oA(t, e) {
    y("YieldExpression", t, e);
  }
  s(oA, "assertYieldExpression");
  function lA(t, e) {
    y("AwaitExpression", t, e);
  }
  s(lA, "assertAwaitExpression");
  function uA(t, e) {
    y("Import", t, e);
  }
  s(uA, "assertImport");
  function cA(t, e) {
    y("BigIntLiteral", t, e);
  }
  s(cA, "assertBigIntLiteral");
  function pA(t, e) {
    y("ExportNamespaceSpecifier", t, e);
  }
  s(pA, "assertExportNamespaceSpecifier");
  function fA(t, e) {
    y("OptionalMemberExpression", t, e);
  }
  s(fA, "assertOptionalMemberExpression");
  function hA(t, e) {
    y("OptionalCallExpression", t, e);
  }
  s(hA, "assertOptionalCallExpression");
  function dA(t, e) {
    y("ClassProperty", t, e);
  }
  s(dA, "assertClassProperty");
  function mA(t, e) {
    y("ClassAccessorProperty", t, e);
  }
  s(mA, "assertClassAccessorProperty");
  function yA(t, e) {
    y("ClassPrivateProperty", t, e);
  }
  s(yA, "assertClassPrivateProperty");
  function TA(t, e) {
    y("ClassPrivateMethod", t, e);
  }
  s(TA, "assertClassPrivateMethod");
  function SA(t, e) {
    y("PrivateName", t, e);
  }
  s(SA, "assertPrivateName");
  function bA(t, e) {
    y("StaticBlock", t, e);
  }
  s(bA, "assertStaticBlock");
  function xA(t, e) {
    y("ImportAttribute", t, e);
  }
  s(xA, "assertImportAttribute");
  function gA(t, e) {
    y("AnyTypeAnnotation", t, e);
  }
  s(gA, "assertAnyTypeAnnotation");
  function EA(t, e) {
    y("ArrayTypeAnnotation", t, e);
  }
  s(EA, "assertArrayTypeAnnotation");
  function PA(t, e) {
    y("BooleanTypeAnnotation", t, e);
  }
  s(PA, "assertBooleanTypeAnnotation");
  function AA(t, e) {
    y("BooleanLiteralTypeAnnotation", t, e);
  }
  s(AA, "assertBooleanLiteralTypeAnnotation");
  function IA(t, e) {
    y("NullLiteralTypeAnnotation", t, e);
  }
  s(IA, "assertNullLiteralTypeAnnotation");
  function vA(t, e) {
    y("ClassImplements", t, e);
  }
  s(vA, "assertClassImplements");
  function CA(t, e) {
    y("DeclareClass", t, e);
  }
  s(CA, "assertDeclareClass");
  function wA(t, e) {
    y("DeclareFunction", t, e);
  }
  s(wA, "assertDeclareFunction");
  function NA(t, e) {
    y("DeclareInterface", t, e);
  }
  s(NA, "assertDeclareInterface");
  function OA(t, e) {
    y("DeclareModule", t, e);
  }
  s(OA, "assertDeclareModule");
  function _A(t, e) {
    y("DeclareModuleExports", t, e);
  }
  s(_A, "assertDeclareModuleExports");
  function DA(t, e) {
    y("DeclareTypeAlias", t, e);
  }
  s(DA, "assertDeclareTypeAlias");
  function kA(t, e) {
    y("DeclareOpaqueType", t, e);
  }
  s(kA, "assertDeclareOpaqueType");
  function LA(t, e) {
    y("DeclareVariable", t, e);
  }
  s(LA, "assertDeclareVariable");
  function MA(t, e) {
    y("DeclareExportDeclaration", t, e);
  }
  s(MA, "assertDeclareExportDeclaration");
  function BA(t, e) {
    y("DeclareExportAllDeclaration", t, e);
  }
  s(BA, "assertDeclareExportAllDeclaration");
  function jA(t, e) {
    y("DeclaredPredicate", t, e);
  }
  s(jA, "assertDeclaredPredicate");
  function FA(t, e) {
    y("ExistsTypeAnnotation", t, e);
  }
  s(FA, "assertExistsTypeAnnotation");
  function RA(t, e) {
    y("FunctionTypeAnnotation", t, e);
  }
  s(RA, "assertFunctionTypeAnnotation");
  function qA(t, e) {
    y("FunctionTypeParam", t, e);
  }
  s(qA, "assertFunctionTypeParam");
  function UA(t, e) {
    y("GenericTypeAnnotation", t, e);
  }
  s(UA, "assertGenericTypeAnnotation");
  function KA(t, e) {
    y("InferredPredicate", t, e);
  }
  s(KA, "assertInferredPredicate");
  function VA(t, e) {
    y("InterfaceExtends", t, e);
  }
  s(VA, "assertInterfaceExtends");
  function YA(t, e) {
    y("InterfaceDeclaration", t, e);
  }
  s(YA, "assertInterfaceDeclaration");
  function JA(t, e) {
    y("InterfaceTypeAnnotation", t, e);
  }
  s(JA, "assertInterfaceTypeAnnotation");
  function XA(t, e) {
    y("IntersectionTypeAnnotation", t, e);
  }
  s(XA, "assertIntersectionTypeAnnotation");
  function WA(t, e) {
    y("MixedTypeAnnotation", t, e);
  }
  s(WA, "assertMixedTypeAnnotation");
  function $A(t, e) {
    y("EmptyTypeAnnotation", t, e);
  }
  s($A, "assertEmptyTypeAnnotation");
  function zA(t, e) {
    y("NullableTypeAnnotation", t, e);
  }
  s(zA, "assertNullableTypeAnnotation");
  function HA(t, e) {
    y("NumberLiteralTypeAnnotation", t, e);
  }
  s(HA, "assertNumberLiteralTypeAnnotation");
  function GA(t, e) {
    y("NumberTypeAnnotation", t, e);
  }
  s(GA, "assertNumberTypeAnnotation");
  function QA(t, e) {
    y("ObjectTypeAnnotation", t, e);
  }
  s(QA, "assertObjectTypeAnnotation");
  function ZA(t, e) {
    y("ObjectTypeInternalSlot", t, e);
  }
  s(ZA, "assertObjectTypeInternalSlot");
  function e1(t, e) {
    y("ObjectTypeCallProperty", t, e);
  }
  s(e1, "assertObjectTypeCallProperty");
  function t1(t, e) {
    y("ObjectTypeIndexer", t, e);
  }
  s(t1, "assertObjectTypeIndexer");
  function r1(t, e) {
    y("ObjectTypeProperty", t, e);
  }
  s(r1, "assertObjectTypeProperty");
  function i1(t, e) {
    y("ObjectTypeSpreadProperty", t, e);
  }
  s(i1, "assertObjectTypeSpreadProperty");
  function s1(t, e) {
    y("OpaqueType", t, e);
  }
  s(s1, "assertOpaqueType");
  function n1(t, e) {
    y("QualifiedTypeIdentifier", t, e);
  }
  s(n1, "assertQualifiedTypeIdentifier");
  function a1(t, e) {
    y("StringLiteralTypeAnnotation", t, e);
  }
  s(a1, "assertStringLiteralTypeAnnotation");
  function o1(t, e) {
    y("StringTypeAnnotation", t, e);
  }
  s(o1, "assertStringTypeAnnotation");
  function l1(t, e) {
    y("SymbolTypeAnnotation", t, e);
  }
  s(l1, "assertSymbolTypeAnnotation");
  function u1(t, e) {
    y("ThisTypeAnnotation", t, e);
  }
  s(u1, "assertThisTypeAnnotation");
  function c1(t, e) {
    y("TupleTypeAnnotation", t, e);
  }
  s(c1, "assertTupleTypeAnnotation");
  function p1(t, e) {
    y("TypeofTypeAnnotation", t, e);
  }
  s(p1, "assertTypeofTypeAnnotation");
  function f1(t, e) {
    y("TypeAlias", t, e);
  }
  s(f1, "assertTypeAlias");
  function h1(t, e) {
    y("TypeAnnotation", t, e);
  }
  s(h1, "assertTypeAnnotation");
  function d1(t, e) {
    y("TypeCastExpression", t, e);
  }
  s(d1, "assertTypeCastExpression");
  function m1(t, e) {
    y("TypeParameter", t, e);
  }
  s(m1, "assertTypeParameter");
  function y1(t, e) {
    y("TypeParameterDeclaration", t, e);
  }
  s(y1, "assertTypeParameterDeclaration");
  function T1(t, e) {
    y("TypeParameterInstantiation", t, e);
  }
  s(T1, "assertTypeParameterInstantiation");
  function S1(t, e) {
    y("UnionTypeAnnotation", t, e);
  }
  s(S1, "assertUnionTypeAnnotation");
  function b1(t, e) {
    y("Variance", t, e);
  }
  s(b1, "assertVariance");
  function x1(t, e) {
    y("VoidTypeAnnotation", t, e);
  }
  s(x1, "assertVoidTypeAnnotation");
  function g1(t, e) {
    y("EnumDeclaration", t, e);
  }
  s(g1, "assertEnumDeclaration");
  function E1(t, e) {
    y("EnumBooleanBody", t, e);
  }
  s(E1, "assertEnumBooleanBody");
  function P1(t, e) {
    y("EnumNumberBody", t, e);
  }
  s(P1, "assertEnumNumberBody");
  function A1(t, e) {
    y("EnumStringBody", t, e);
  }
  s(A1, "assertEnumStringBody");
  function I1(t, e) {
    y("EnumSymbolBody", t, e);
  }
  s(I1, "assertEnumSymbolBody");
  function v1(t, e) {
    y("EnumBooleanMember", t, e);
  }
  s(v1, "assertEnumBooleanMember");
  function C1(t, e) {
    y("EnumNumberMember", t, e);
  }
  s(C1, "assertEnumNumberMember");
  function w1(t, e) {
    y("EnumStringMember", t, e);
  }
  s(w1, "assertEnumStringMember");
  function N1(t, e) {
    y("EnumDefaultedMember", t, e);
  }
  s(N1, "assertEnumDefaultedMember");
  function O1(t, e) {
    y("IndexedAccessType", t, e);
  }
  s(O1, "assertIndexedAccessType");
  function _1(t, e) {
    y("OptionalIndexedAccessType", t, e);
  }
  s(_1, "assertOptionalIndexedAccessType");
  function D1(t, e) {
    y("JSXAttribute", t, e);
  }
  s(D1, "assertJSXAttribute");
  function k1(t, e) {
    y("JSXClosingElement", t, e);
  }
  s(k1, "assertJSXClosingElement");
  function L1(t, e) {
    y("JSXElement", t, e);
  }
  s(L1, "assertJSXElement");
  function M1(t, e) {
    y("JSXEmptyExpression", t, e);
  }
  s(M1, "assertJSXEmptyExpression");
  function B1(t, e) {
    y("JSXExpressionContainer", t, e);
  }
  s(B1, "assertJSXExpressionContainer");
  function j1(t, e) {
    y("JSXSpreadChild", t, e);
  }
  s(j1, "assertJSXSpreadChild");
  function F1(t, e) {
    y("JSXIdentifier", t, e);
  }
  s(F1, "assertJSXIdentifier");
  function R1(t, e) {
    y("JSXMemberExpression", t, e);
  }
  s(R1, "assertJSXMemberExpression");
  function q1(t, e) {
    y("JSXNamespacedName", t, e);
  }
  s(q1, "assertJSXNamespacedName");
  function U1(t, e) {
    y("JSXOpeningElement", t, e);
  }
  s(U1, "assertJSXOpeningElement");
  function K1(t, e) {
    y("JSXSpreadAttribute", t, e);
  }
  s(K1, "assertJSXSpreadAttribute");
  function V1(t, e) {
    y("JSXText", t, e);
  }
  s(V1, "assertJSXText");
  function Y1(t, e) {
    y("JSXFragment", t, e);
  }
  s(Y1, "assertJSXFragment");
  function J1(t, e) {
    y("JSXOpeningFragment", t, e);
  }
  s(J1, "assertJSXOpeningFragment");
  function X1(t, e) {
    y("JSXClosingFragment", t, e);
  }
  s(X1, "assertJSXClosingFragment");
  function W1(t, e) {
    y("Noop", t, e);
  }
  s(W1, "assertNoop");
  function $1(t, e) {
    y("Placeholder", t, e);
  }
  s($1, "assertPlaceholder");
  function z1(t, e) {
    y("V8IntrinsicIdentifier", t, e);
  }
  s(z1, "assertV8IntrinsicIdentifier");
  function H1(t, e) {
    y("ArgumentPlaceholder", t, e);
  }
  s(H1, "assertArgumentPlaceholder");
  function G1(t, e) {
    y("BindExpression", t, e);
  }
  s(G1, "assertBindExpression");
  function Q1(t, e) {
    y("Decorator", t, e);
  }
  s(Q1, "assertDecorator");
  function Z1(t, e) {
    y("DoExpression", t, e);
  }
  s(Z1, "assertDoExpression");
  function eI(t, e) {
    y("ExportDefaultSpecifier", t, e);
  }
  s(eI, "assertExportDefaultSpecifier");
  function tI(t, e) {
    y("RecordExpression", t, e);
  }
  s(tI, "assertRecordExpression");
  function rI(t, e) {
    y("TupleExpression", t, e);
  }
  s(rI, "assertTupleExpression");
  function iI(t, e) {
    y("DecimalLiteral", t, e);
  }
  s(iI, "assertDecimalLiteral");
  function sI(t, e) {
    y("ModuleExpression", t, e);
  }
  s(sI, "assertModuleExpression");
  function nI(t, e) {
    y("TopicReference", t, e);
  }
  s(nI, "assertTopicReference");
  function aI(t, e) {
    y("PipelineTopicExpression", t, e);
  }
  s(aI, "assertPipelineTopicExpression");
  function oI(t, e) {
    y("PipelineBareFunction", t, e);
  }
  s(oI, "assertPipelineBareFunction");
  function lI(t, e) {
    y("PipelinePrimaryTopicReference", t, e);
  }
  s(lI, "assertPipelinePrimaryTopicReference");
  function uI(t, e) {
    y("TSParameterProperty", t, e);
  }
  s(uI, "assertTSParameterProperty");
  function cI(t, e) {
    y("TSDeclareFunction", t, e);
  }
  s(cI, "assertTSDeclareFunction");
  function pI(t, e) {
    y("TSDeclareMethod", t, e);
  }
  s(pI, "assertTSDeclareMethod");
  function fI(t, e) {
    y("TSQualifiedName", t, e);
  }
  s(fI, "assertTSQualifiedName");
  function hI(t, e) {
    y("TSCallSignatureDeclaration", t, e);
  }
  s(hI, "assertTSCallSignatureDeclaration");
  function dI(t, e) {
    y("TSConstructSignatureDeclaration", t, e);
  }
  s(dI, "assertTSConstructSignatureDeclaration");
  function mI(t, e) {
    y("TSPropertySignature", t, e);
  }
  s(mI, "assertTSPropertySignature");
  function yI(t, e) {
    y("TSMethodSignature", t, e);
  }
  s(yI, "assertTSMethodSignature");
  function TI(t, e) {
    y("TSIndexSignature", t, e);
  }
  s(TI, "assertTSIndexSignature");
  function SI(t, e) {
    y("TSAnyKeyword", t, e);
  }
  s(SI, "assertTSAnyKeyword");
  function bI(t, e) {
    y("TSBooleanKeyword", t, e);
  }
  s(bI, "assertTSBooleanKeyword");
  function xI(t, e) {
    y("TSBigIntKeyword", t, e);
  }
  s(xI, "assertTSBigIntKeyword");
  function gI(t, e) {
    y("TSIntrinsicKeyword", t, e);
  }
  s(gI, "assertTSIntrinsicKeyword");
  function EI(t, e) {
    y("TSNeverKeyword", t, e);
  }
  s(EI, "assertTSNeverKeyword");
  function PI(t, e) {
    y("TSNullKeyword", t, e);
  }
  s(PI, "assertTSNullKeyword");
  function AI(t, e) {
    y("TSNumberKeyword", t, e);
  }
  s(AI, "assertTSNumberKeyword");
  function II(t, e) {
    y("TSObjectKeyword", t, e);
  }
  s(II, "assertTSObjectKeyword");
  function vI(t, e) {
    y("TSStringKeyword", t, e);
  }
  s(vI, "assertTSStringKeyword");
  function CI(t, e) {
    y("TSSymbolKeyword", t, e);
  }
  s(CI, "assertTSSymbolKeyword");
  function wI(t, e) {
    y("TSUndefinedKeyword", t, e);
  }
  s(wI, "assertTSUndefinedKeyword");
  function NI(t, e) {
    y("TSUnknownKeyword", t, e);
  }
  s(NI, "assertTSUnknownKeyword");
  function OI(t, e) {
    y("TSVoidKeyword", t, e);
  }
  s(OI, "assertTSVoidKeyword");
  function _I(t, e) {
    y("TSThisType", t, e);
  }
  s(_I, "assertTSThisType");
  function DI(t, e) {
    y("TSFunctionType", t, e);
  }
  s(DI, "assertTSFunctionType");
  function kI(t, e) {
    y("TSConstructorType", t, e);
  }
  s(kI, "assertTSConstructorType");
  function LI(t, e) {
    y("TSTypeReference", t, e);
  }
  s(LI, "assertTSTypeReference");
  function MI(t, e) {
    y("TSTypePredicate", t, e);
  }
  s(MI, "assertTSTypePredicate");
  function BI(t, e) {
    y("TSTypeQuery", t, e);
  }
  s(BI, "assertTSTypeQuery");
  function jI(t, e) {
    y("TSTypeLiteral", t, e);
  }
  s(jI, "assertTSTypeLiteral");
  function FI(t, e) {
    y("TSArrayType", t, e);
  }
  s(FI, "assertTSArrayType");
  function RI(t, e) {
    y("TSTupleType", t, e);
  }
  s(RI, "assertTSTupleType");
  function qI(t, e) {
    y("TSOptionalType", t, e);
  }
  s(qI, "assertTSOptionalType");
  function UI(t, e) {
    y("TSRestType", t, e);
  }
  s(UI, "assertTSRestType");
  function KI(t, e) {
    y("TSNamedTupleMember", t, e);
  }
  s(KI, "assertTSNamedTupleMember");
  function VI(t, e) {
    y("TSUnionType", t, e);
  }
  s(VI, "assertTSUnionType");
  function YI(t, e) {
    y("TSIntersectionType", t, e);
  }
  s(YI, "assertTSIntersectionType");
  function JI(t, e) {
    y("TSConditionalType", t, e);
  }
  s(JI, "assertTSConditionalType");
  function XI(t, e) {
    y("TSInferType", t, e);
  }
  s(XI, "assertTSInferType");
  function WI(t, e) {
    y("TSParenthesizedType", t, e);
  }
  s(WI, "assertTSParenthesizedType");
  function $I(t, e) {
    y("TSTypeOperator", t, e);
  }
  s($I, "assertTSTypeOperator");
  function zI(t, e) {
    y("TSIndexedAccessType", t, e);
  }
  s(zI, "assertTSIndexedAccessType");
  function HI(t, e) {
    y("TSMappedType", t, e);
  }
  s(HI, "assertTSMappedType");
  function GI(t, e) {
    y("TSTemplateLiteralType", t, e);
  }
  s(GI, "assertTSTemplateLiteralType");
  function QI(t, e) {
    y("TSLiteralType", t, e);
  }
  s(QI, "assertTSLiteralType");
  function ZI(t, e) {
    y("TSExpressionWithTypeArguments", t, e);
  }
  s(ZI, "assertTSExpressionWithTypeArguments");
  function ev(t, e) {
    y("TSInterfaceDeclaration", t, e);
  }
  s(ev, "assertTSInterfaceDeclaration");
  function tv(t, e) {
    y("TSInterfaceBody", t, e);
  }
  s(tv, "assertTSInterfaceBody");
  function rv(t, e) {
    y("TSTypeAliasDeclaration", t, e);
  }
  s(rv, "assertTSTypeAliasDeclaration");
  function iv(t, e) {
    y("TSInstantiationExpression", t, e);
  }
  s(iv, "assertTSInstantiationExpression");
  function sv(t, e) {
    y("TSAsExpression", t, e);
  }
  s(sv, "assertTSAsExpression");
  function nv(t, e) {
    y("TSSatisfiesExpression", t, e);
  }
  s(nv, "assertTSSatisfiesExpression");
  function av(t, e) {
    y("TSTypeAssertion", t, e);
  }
  s(av, "assertTSTypeAssertion");
  function ov(t, e) {
    y("TSEnumBody", t, e);
  }
  s(ov, "assertTSEnumBody");
  function lv(t, e) {
    y("TSEnumDeclaration", t, e);
  }
  s(lv, "assertTSEnumDeclaration");
  function uv(t, e) {
    y("TSEnumMember", t, e);
  }
  s(uv, "assertTSEnumMember");
  function cv(t, e) {
    y("TSModuleDeclaration", t, e);
  }
  s(cv, "assertTSModuleDeclaration");
  function pv(t, e) {
    y("TSModuleBlock", t, e);
  }
  s(pv, "assertTSModuleBlock");
  function fv(t, e) {
    y("TSImportType", t, e);
  }
  s(fv, "assertTSImportType");
  function hv(t, e) {
    y("TSImportEqualsDeclaration", t, e);
  }
  s(hv, "assertTSImportEqualsDeclaration");
  function dv(t, e) {
    y("TSExternalModuleReference", t, e);
  }
  s(dv, "assertTSExternalModuleReference");
  function mv(t, e) {
    y("TSNonNullExpression", t, e);
  }
  s(mv, "assertTSNonNullExpression");
  function yv(t, e) {
    y("TSExportAssignment", t, e);
  }
  s(yv, "assertTSExportAssignment");
  function Tv(t, e) {
    y("TSNamespaceExportDeclaration", t, e);
  }
  s(Tv, "assertTSNamespaceExportDeclaration");
  function Sv(t, e) {
    y("TSTypeAnnotation", t, e);
  }
  s(Sv, "assertTSTypeAnnotation");
  function bv(t, e) {
    y("TSTypeParameterInstantiation", t, e);
  }
  s(bv, "assertTSTypeParameterInstantiation");
  function xv(t, e) {
    y("TSTypeParameterDeclaration", t, e);
  }
  s(xv, "assertTSTypeParameterDeclaration");
  function gv(t, e) {
    y("TSTypeParameter", t, e);
  }
  s(gv, "assertTSTypeParameter");
  function Ev(t, e) {
    y("Standardized", t, e);
  }
  s(Ev, "assertStandardized");
  function Pv(t, e) {
    y("Expression", t, e);
  }
  s(Pv, "assertExpression");
  function Av(t, e) {
    y("Binary", t, e);
  }
  s(Av, "assertBinary");
  function Iv(t, e) {
    y("Scopable", t, e);
  }
  s(Iv, "assertScopable");
  function vv(t, e) {
    y("BlockParent", t, e);
  }
  s(vv, "assertBlockParent");
  function Cv(t, e) {
    y("Block", t, e);
  }
  s(Cv, "assertBlock");
  function wv(t, e) {
    y("Statement", t, e);
  }
  s(wv, "assertStatement");
  function Nv(t, e) {
    y("Terminatorless", t, e);
  }
  s(Nv, "assertTerminatorless");
  function Ov(t, e) {
    y("CompletionStatement", t, e);
  }
  s(Ov, "assertCompletionStatement");
  function _v(t, e) {
    y("Conditional", t, e);
  }
  s(_v, "assertConditional");
  function Dv(t, e) {
    y("Loop", t, e);
  }
  s(Dv, "assertLoop");
  function kv(t, e) {
    y("While", t, e);
  }
  s(kv, "assertWhile");
  function Lv(t, e) {
    y("ExpressionWrapper", t, e);
  }
  s(Lv, "assertExpressionWrapper");
  function Mv(t, e) {
    y("For", t, e);
  }
  s(Mv, "assertFor");
  function Bv(t, e) {
    y("ForXStatement", t, e);
  }
  s(Bv, "assertForXStatement");
  function jv(t, e) {
    y("Function", t, e);
  }
  s(jv, "assertFunction");
  function Fv(t, e) {
    y("FunctionParent", t, e);
  }
  s(Fv, "assertFunctionParent");
  function Rv(t, e) {
    y("Pureish", t, e);
  }
  s(Rv, "assertPureish");
  function qv(t, e) {
    y("Declaration", t, e);
  }
  s(qv, "assertDeclaration");
  function Uv(t, e) {
    y("PatternLike", t, e);
  }
  s(Uv, "assertPatternLike");
  function Kv(t, e) {
    y("LVal", t, e);
  }
  s(Kv, "assertLVal");
  function Vv(t, e) {
    y("TSEntityName", t, e);
  }
  s(Vv, "assertTSEntityName");
  function Yv(t, e) {
    y("Literal", t, e);
  }
  s(Yv, "assertLiteral");
  function Jv(t, e) {
    y("Immutable", t, e);
  }
  s(Jv, "assertImmutable");
  function Xv(t, e) {
    y("UserWhitespacable", t, e);
  }
  s(Xv, "assertUserWhitespacable");
  function Wv(t, e) {
    y("Method", t, e);
  }
  s(Wv, "assertMethod");
  function $v(t, e) {
    y("ObjectMember", t, e);
  }
  s($v, "assertObjectMember");
  function zv(t, e) {
    y("Property", t, e);
  }
  s(zv, "assertProperty");
  function Hv(t, e) {
    y("UnaryLike", t, e);
  }
  s(Hv, "assertUnaryLike");
  function Gv(t, e) {
    y("Pattern", t, e);
  }
  s(Gv, "assertPattern");
  function Qv(t, e) {
    y("Class", t, e);
  }
  s(Qv, "assertClass");
  function Zv(t, e) {
    y("ImportOrExportDeclaration", t, e);
  }
  s(Zv, "assertImportOrExportDeclaration");
  function eC(t, e) {
    y("ExportDeclaration", t, e);
  }
  s(eC, "assertExportDeclaration");
  function tC(t, e) {
    y("ModuleSpecifier", t, e);
  }
  s(tC, "assertModuleSpecifier");
  function rC(t, e) {
    y("Accessor", t, e);
  }
  s(rC, "assertAccessor");
  function iC(t, e) {
    y("Private", t, e);
  }
  s(iC, "assertPrivate");
  function sC(t, e) {
    y("Flow", t, e);
  }
  s(sC, "assertFlow");
  function nC(t, e) {
    y("FlowType", t, e);
  }
  s(nC, "assertFlowType");
  function aC(t, e) {
    y("FlowBaseAnnotation", t, e);
  }
  s(aC, "assertFlowBaseAnnotation");
  function oC(t, e) {
    y("FlowDeclaration", t, e);
  }
  s(oC, "assertFlowDeclaration");
  function lC(t, e) {
    y("FlowPredicate", t, e);
  }
  s(lC, "assertFlowPredicate");
  function uC(t, e) {
    y("EnumBody", t, e);
  }
  s(uC, "assertEnumBody");
  function cC(t, e) {
    y("EnumMember", t, e);
  }
  s(cC, "assertEnumMember");
  function pC(t, e) {
    y("JSX", t, e);
  }
  s(pC, "assertJSX");
  function fC(t, e) {
    y("Miscellaneous", t, e);
  }
  s(fC, "assertMiscellaneous");
  function hC(t, e) {
    y("TypeScript", t, e);
  }
  s(hC, "assertTypeScript");
  function dC(t, e) {
    y("TSTypeElement", t, e);
  }
  s(dC, "assertTSTypeElement");
  function mC(t, e) {
    y("TSType", t, e);
  }
  s(mC, "assertTSType");
  function yC(t, e) {
    y("TSBaseType", t, e);
  }
  s(yC, "assertTSBaseType");
  function TC(t, e) {
    (0, Mr.default)("assertNumberLiteral", "assertNumericLiteral"), y("NumberLiteral", t, e);
  }
  s(TC, "assertNumberLiteral");
  function SC(t, e) {
    (0, Mr.default)("assertRegexLiteral", "assertRegExpLiteral"), y("RegexLiteral", t, e);
  }
  s(SC, "assertRegexLiteral");
  function bC(t, e) {
    (0, Mr.default)("assertRestProperty", "assertRestElement"), y("RestProperty", t, e);
  }
  s(bC, "assertRestProperty");
  function xC(t, e) {
    (0, Mr.default)("assertSpreadProperty", "assertSpreadElement"), y("SpreadProperty", t, e);
  }
  s(xC, "assertSpreadProperty");
  function gC(t, e) {
    (0, Mr.default)("assertModuleDeclaration", "assertImportOrExportDeclaration"), y("ModuleDeclaration", t, e);
  }
  s(gC, "assertModuleDeclaration");
});

// ../node_modules/@babel/types/lib/builders/flow/createTypeAnnotationBasedOnTypeof.js
var zl = D((wi) => {
  "use strict";
  Object.defineProperty(wi, "__esModule", {
    value: !0
  });
  wi.default = void 0;
  var dt = it(), ZF = wi.default = EC;
  function EC(t) {
    switch (t) {
      case "string":
        return (0, dt.stringTypeAnnotation)();
      case "number":
        return (0, dt.numberTypeAnnotation)();
      case "undefined":
        return (0, dt.voidTypeAnnotation)();
      case "boolean":
        return (0, dt.booleanTypeAnnotation)();
      case "function":
        return (0, dt.genericTypeAnnotation)((0, dt.identifier)("Function"));
      case "object":
        return (0, dt.genericTypeAnnotation)((0, dt.identifier)("Object"));
      case "symbol":
        return (0, dt.genericTypeAnnotation)((0, dt.identifier)("Symbol"));
      case "bigint":
        return (0, dt.anyTypeAnnotation)();
    }
    throw new Error("Invalid typeof value: " + t);
  }
  s(EC, "createTypeAnnotationBasedOnTypeof");
});

// ../node_modules/@babel/types/lib/modifications/flow/removeTypeDuplicates.js
var ln = D((on) => {
  "use strict";
  Object.defineProperty(on, "__esModule", {
    value: !0
  });
  on.default = Gl;
  var Br = Be();
  function Hl(t) {
    return (0, Br.isIdentifier)(t) ? t.name : `${t.id.name}.${Hl(t.qualification)}`;
  }
  s(Hl, "getQualifiedName");
  function Gl(t) {
    let e = Array.from(t), r = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Set(), a = [];
    for (let o = 0; o < e.length; o++) {
      let l = e[o];
      if (l && !a.includes(l)) {
        if ((0, Br.isAnyTypeAnnotation)(l))
          return [l];
        if ((0, Br.isFlowBaseAnnotation)(l)) {
          i.set(l.type, l);
          continue;
        }
        if ((0, Br.isUnionTypeAnnotation)(l)) {
          n.has(l.types) || (e.push(...l.types), n.add(l.types));
          continue;
        }
        if ((0, Br.isGenericTypeAnnotation)(l)) {
          let u = Hl(l.id);
          if (r.has(u)) {
            let p = r.get(u);
            p.typeParameters ? l.typeParameters && (p.typeParameters.params.push(...l.typeParameters.params), p.typeParameters.params = Gl(p.
            typeParameters.params)) : p = l.typeParameters;
          } else
            r.set(u, l);
          continue;
        }
        a.push(l);
      }
    }
    for (let [, o] of i)
      a.push(o);
    for (let [, o] of r)
      a.push(o);
    return a;
  }
  s(Gl, "removeTypeDuplicates");
});

// ../node_modules/@babel/types/lib/builders/flow/createFlowUnionType.js
var Ql = D((un) => {
  "use strict";
  Object.defineProperty(un, "__esModule", {
    value: !0
  });
  un.default = IC;
  var PC = it(), AC = ln();
  function IC(t) {
    let e = (0, AC.default)(t);
    return e.length === 1 ? e[0] : (0, PC.unionTypeAnnotation)(e);
  }
  s(IC, "createFlowUnionType");
});

// ../node_modules/@babel/types/lib/modifications/typescript/removeTypeDuplicates.js
var tu = D((cn) => {
  "use strict";
  Object.defineProperty(cn, "__esModule", {
    value: !0
  });
  cn.default = eu;
  var cr = Be();
  function Zl(t) {
    return (0, cr.isIdentifier)(t) ? t.name : (0, cr.isThisExpression)(t) ? "this" : `${t.right.name}.${Zl(t.left)}`;
  }
  s(Zl, "getQualifiedName");
  function eu(t) {
    let e = Array.from(t), r = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Set(), a = [];
    for (let o = 0; o < e.length; o++) {
      let l = e[o];
      if (!l || a.includes(l))
        continue;
      if ((0, cr.isTSAnyKeyword)(l))
        return [l];
      if ((0, cr.isTSBaseType)(l)) {
        i.set(l.type, l);
        continue;
      }
      if ((0, cr.isTSUnionType)(l)) {
        n.has(l.types) || (e.push(...l.types), n.add(l.types));
        continue;
      }
      let u = "typeParameters";
      if ((0, cr.isTSTypeReference)(l) && l[u]) {
        let p = l[u], h = Zl(l.typeName);
        if (r.has(h)) {
          let E = r.get(h), I = E[u];
          I ? (I.params.push(...p.params), I.params = eu(I.params)) : E = p;
        } else
          r.set(h, l);
        continue;
      }
      a.push(l);
    }
    for (let [, o] of i)
      a.push(o);
    for (let [, o] of r)
      a.push(o);
    return a;
  }
  s(eu, "removeTypeDuplicates");
});

// ../node_modules/@babel/types/lib/builders/typescript/createTSUnionType.js
var ru = D((pn) => {
  "use strict";
  Object.defineProperty(pn, "__esModule", {
    value: !0
  });
  pn.default = NC;
  var vC = it(), CC = tu(), wC = Be();
  function NC(t) {
    let e = t.map((i) => (0, wC.isTSTypeAnnotation)(i) ? i.typeAnnotation : i), r = (0, CC.default)(e);
    return r.length === 1 ? r[0] : (0, vC.tsUnionType)(r);
  }
  s(NC, "createTSUnionType");
});

// ../node_modules/@babel/types/lib/builders/productions.js
var hn = D((fn) => {
  "use strict";
  Object.defineProperty(fn, "__esModule", {
    value: !0
  });
  fn.buildUndefinedNode = OC;
  var iu = it();
  function OC() {
    return (0, iu.unaryExpression)("void", (0, iu.numericLiteral)(0), !0);
  }
  s(OC, "buildUndefinedNode");
});

// ../node_modules/@babel/types/lib/clone/cloneNode.js
var Bt = D((mn) => {
  "use strict";
  Object.defineProperty(mn, "__esModule", {
    value: !0
  });
  mn.default = _C;
  var su = ot(), nu = Be(), {
    hasOwn: xt
  } = {
    hasOwn: Function.call.bind(Object.prototype.hasOwnProperty)
  };
  function au(t, e, r, i) {
    return t && typeof t.type == "string" ? ou(t, e, r, i) : t;
  }
  s(au, "cloneIfNode");
  function dn(t, e, r, i) {
    return Array.isArray(t) ? t.map((n) => au(n, e, r, i)) : au(t, e, r, i);
  }
  s(dn, "cloneIfNodeOrArray");
  function _C(t, e = !0, r = !1) {
    return ou(t, e, r, /* @__PURE__ */ new Map());
  }
  s(_C, "cloneNode");
  function ou(t, e = !0, r = !1, i) {
    if (!t) return t;
    let {
      type: n
    } = t, a = {
      type: t.type
    };
    if ((0, nu.isIdentifier)(t))
      a.name = t.name, xt(t, "optional") && typeof t.optional == "boolean" && (a.optional = t.optional), xt(t, "typeAnnotation") && (a.typeAnnotation =
      e ? dn(t.typeAnnotation, !0, r, i) : t.typeAnnotation), xt(t, "decorators") && (a.decorators = e ? dn(t.decorators, !0, r, i) : t.decorators);
    else if (xt(su.NODE_FIELDS, n))
      for (let o of Object.keys(su.NODE_FIELDS[n]))
        xt(t, o) && (e ? a[o] = (0, nu.isFile)(t) && o === "comments" ? Ni(t.comments, e, r, i) : dn(t[o], !0, r, i) : a[o] = t[o]);
    else
      throw new Error(`Unknown node type: "${n}"`);
    return xt(t, "loc") && (r ? a.loc = null : a.loc = t.loc), xt(t, "leadingComments") && (a.leadingComments = Ni(t.leadingComments, e, r, i)),
    xt(t, "innerComments") && (a.innerComments = Ni(t.innerComments, e, r, i)), xt(t, "trailingComments") && (a.trailingComments = Ni(t.trailingComments,
    e, r, i)), xt(t, "extra") && (a.extra = Object.assign({}, t.extra)), a;
  }
  s(ou, "cloneNodeInternal");
  function Ni(t, e, r, i) {
    return !t || !e ? t : t.map((n) => {
      let a = i.get(n);
      if (a) return a;
      let {
        type: o,
        value: l,
        loc: u
      } = n, p = {
        type: o,
        value: l,
        loc: u
      };
      return r && (p.loc = null), i.set(n, p), p;
    });
  }
  s(Ni, "maybeCloneComments");
});

// ../node_modules/@babel/types/lib/clone/clone.js
var lu = D((yn) => {
  "use strict";
  Object.defineProperty(yn, "__esModule", {
    value: !0
  });
  yn.default = kC;
  var DC = Bt();
  function kC(t) {
    return (0, DC.default)(t, !1);
  }
  s(kC, "clone");
});

// ../node_modules/@babel/types/lib/clone/cloneDeep.js
var uu = D((Tn) => {
  "use strict";
  Object.defineProperty(Tn, "__esModule", {
    value: !0
  });
  Tn.default = MC;
  var LC = Bt();
  function MC(t) {
    return (0, LC.default)(t);
  }
  s(MC, "cloneDeep");
});

// ../node_modules/@babel/types/lib/clone/cloneDeepWithoutLoc.js
var cu = D((Sn) => {
  "use strict";
  Object.defineProperty(Sn, "__esModule", {
    value: !0
  });
  Sn.default = jC;
  var BC = Bt();
  function jC(t) {
    return (0, BC.default)(t, !0, !0);
  }
  s(jC, "cloneDeepWithoutLoc");
});

// ../node_modules/@babel/types/lib/clone/cloneWithoutLoc.js
var pu = D((bn) => {
  "use strict";
  Object.defineProperty(bn, "__esModule", {
    value: !0
  });
  bn.default = RC;
  var FC = Bt();
  function RC(t) {
    return (0, FC.default)(t, !1, !0);
  }
  s(RC, "cloneWithoutLoc");
});

// ../node_modules/@babel/types/lib/comments/addComments.js
var gn = D((xn) => {
  "use strict";
  Object.defineProperty(xn, "__esModule", {
    value: !0
  });
  xn.default = qC;
  function qC(t, e, r) {
    if (!r || !t) return t;
    let i = `${e}Comments`;
    return t[i] ? e === "leading" ? t[i] = r.concat(t[i]) : t[i].push(...r) : t[i] = r, t;
  }
  s(qC, "addComments");
});

// ../node_modules/@babel/types/lib/comments/addComment.js
var fu = D((En) => {
  "use strict";
  Object.defineProperty(En, "__esModule", {
    value: !0
  });
  En.default = KC;
  var UC = gn();
  function KC(t, e, r, i) {
    return (0, UC.default)(t, e, [{
      type: i ? "CommentLine" : "CommentBlock",
      value: r
    }]);
  }
  s(KC, "addComment");
});

// ../node_modules/@babel/types/lib/utils/inherit.js
var Oi = D((Pn) => {
  "use strict";
  Object.defineProperty(Pn, "__esModule", {
    value: !0
  });
  Pn.default = VC;
  function VC(t, e, r) {
    e && r && (e[t] = Array.from(new Set([].concat(e[t], r[t]).filter(Boolean))));
  }
  s(VC, "inherit");
});

// ../node_modules/@babel/types/lib/comments/inheritInnerComments.js
var In = D((An) => {
  "use strict";
  Object.defineProperty(An, "__esModule", {
    value: !0
  });
  An.default = JC;
  var YC = Oi();
  function JC(t, e) {
    (0, YC.default)("innerComments", t, e);
  }
  s(JC, "inheritInnerComments");
});

// ../node_modules/@babel/types/lib/comments/inheritLeadingComments.js
var Cn = D((vn) => {
  "use strict";
  Object.defineProperty(vn, "__esModule", {
    value: !0
  });
  vn.default = WC;
  var XC = Oi();
  function WC(t, e) {
    (0, XC.default)("leadingComments", t, e);
  }
  s(WC, "inheritLeadingComments");
});

// ../node_modules/@babel/types/lib/comments/inheritTrailingComments.js
var Nn = D((wn) => {
  "use strict";
  Object.defineProperty(wn, "__esModule", {
    value: !0
  });
  wn.default = zC;
  var $C = Oi();
  function zC(t, e) {
    (0, $C.default)("trailingComments", t, e);
  }
  s(zC, "inheritTrailingComments");
});

// ../node_modules/@babel/types/lib/comments/inheritsComments.js
var _n = D((On) => {
  "use strict";
  Object.defineProperty(On, "__esModule", {
    value: !0
  });
  On.default = ZC;
  var HC = Nn(), GC = Cn(), QC = In();
  function ZC(t, e) {
    return (0, HC.default)(t, e), (0, GC.default)(t, e), (0, QC.default)(t, e), t;
  }
  s(ZC, "inheritsComments");
});

// ../node_modules/@babel/types/lib/comments/removeComments.js
var hu = D((Dn) => {
  "use strict";
  Object.defineProperty(Dn, "__esModule", {
    value: !0
  });
  Dn.default = tw;
  var ew = ar();
  function tw(t) {
    return ew.COMMENT_KEYS.forEach((e) => {
      t[e] = null;
    }), t;
  }
  s(tw, "removeComments");
});

// ../node_modules/@babel/types/lib/constants/generated/index.js
var du = D((L) => {
  "use strict";
  Object.defineProperty(L, "__esModule", {
    value: !0
  });
  L.WHILE_TYPES = L.USERWHITESPACABLE_TYPES = L.UNARYLIKE_TYPES = L.TYPESCRIPT_TYPES = L.TSTYPE_TYPES = L.TSTYPEELEMENT_TYPES = L.TSENTITYNAME_TYPES =
  L.TSBASETYPE_TYPES = L.TERMINATORLESS_TYPES = L.STATEMENT_TYPES = L.STANDARDIZED_TYPES = L.SCOPABLE_TYPES = L.PUREISH_TYPES = L.PROPERTY_TYPES =
  L.PRIVATE_TYPES = L.PATTERN_TYPES = L.PATTERNLIKE_TYPES = L.OBJECTMEMBER_TYPES = L.MODULESPECIFIER_TYPES = L.MODULEDECLARATION_TYPES = L.MISCELLANEOUS_TYPES =
  L.METHOD_TYPES = L.LVAL_TYPES = L.LOOP_TYPES = L.LITERAL_TYPES = L.JSX_TYPES = L.IMPORTOREXPORTDECLARATION_TYPES = L.IMMUTABLE_TYPES = L.FUNCTION_TYPES =
  L.FUNCTIONPARENT_TYPES = L.FOR_TYPES = L.FORXSTATEMENT_TYPES = L.FLOW_TYPES = L.FLOWTYPE_TYPES = L.FLOWPREDICATE_TYPES = L.FLOWDECLARATION_TYPES =
  L.FLOWBASEANNOTATION_TYPES = L.EXPRESSION_TYPES = L.EXPRESSIONWRAPPER_TYPES = L.EXPORTDECLARATION_TYPES = L.ENUMMEMBER_TYPES = L.ENUMBODY_TYPES =
  L.DECLARATION_TYPES = L.CONDITIONAL_TYPES = L.COMPLETIONSTATEMENT_TYPES = L.CLASS_TYPES = L.BLOCK_TYPES = L.BLOCKPARENT_TYPES = L.BINARY_TYPES =
  L.ACCESSOR_TYPES = void 0;
  var ae = ot(), F4 = L.STANDARDIZED_TYPES = ae.FLIPPED_ALIAS_KEYS.Standardized, R4 = L.EXPRESSION_TYPES = ae.FLIPPED_ALIAS_KEYS.Expression,
  q4 = L.BINARY_TYPES = ae.FLIPPED_ALIAS_KEYS.Binary, U4 = L.SCOPABLE_TYPES = ae.FLIPPED_ALIAS_KEYS.Scopable, K4 = L.BLOCKPARENT_TYPES = ae.
  FLIPPED_ALIAS_KEYS.BlockParent, V4 = L.BLOCK_TYPES = ae.FLIPPED_ALIAS_KEYS.Block, Y4 = L.STATEMENT_TYPES = ae.FLIPPED_ALIAS_KEYS.Statement,
  J4 = L.TERMINATORLESS_TYPES = ae.FLIPPED_ALIAS_KEYS.Terminatorless, X4 = L.COMPLETIONSTATEMENT_TYPES = ae.FLIPPED_ALIAS_KEYS.CompletionStatement,
  W4 = L.CONDITIONAL_TYPES = ae.FLIPPED_ALIAS_KEYS.Conditional, $4 = L.LOOP_TYPES = ae.FLIPPED_ALIAS_KEYS.Loop, z4 = L.WHILE_TYPES = ae.FLIPPED_ALIAS_KEYS.
  While, H4 = L.EXPRESSIONWRAPPER_TYPES = ae.FLIPPED_ALIAS_KEYS.ExpressionWrapper, G4 = L.FOR_TYPES = ae.FLIPPED_ALIAS_KEYS.For, Q4 = L.FORXSTATEMENT_TYPES =
  ae.FLIPPED_ALIAS_KEYS.ForXStatement, Z4 = L.FUNCTION_TYPES = ae.FLIPPED_ALIAS_KEYS.Function, eR = L.FUNCTIONPARENT_TYPES = ae.FLIPPED_ALIAS_KEYS.
  FunctionParent, tR = L.PUREISH_TYPES = ae.FLIPPED_ALIAS_KEYS.Pureish, rR = L.DECLARATION_TYPES = ae.FLIPPED_ALIAS_KEYS.Declaration, iR = L.
  PATTERNLIKE_TYPES = ae.FLIPPED_ALIAS_KEYS.PatternLike, sR = L.LVAL_TYPES = ae.FLIPPED_ALIAS_KEYS.LVal, nR = L.TSENTITYNAME_TYPES = ae.FLIPPED_ALIAS_KEYS.
  TSEntityName, aR = L.LITERAL_TYPES = ae.FLIPPED_ALIAS_KEYS.Literal, oR = L.IMMUTABLE_TYPES = ae.FLIPPED_ALIAS_KEYS.Immutable, lR = L.USERWHITESPACABLE_TYPES =
  ae.FLIPPED_ALIAS_KEYS.UserWhitespacable, uR = L.METHOD_TYPES = ae.FLIPPED_ALIAS_KEYS.Method, cR = L.OBJECTMEMBER_TYPES = ae.FLIPPED_ALIAS_KEYS.
  ObjectMember, pR = L.PROPERTY_TYPES = ae.FLIPPED_ALIAS_KEYS.Property, fR = L.UNARYLIKE_TYPES = ae.FLIPPED_ALIAS_KEYS.UnaryLike, hR = L.PATTERN_TYPES =
  ae.FLIPPED_ALIAS_KEYS.Pattern, dR = L.CLASS_TYPES = ae.FLIPPED_ALIAS_KEYS.Class, rw = L.IMPORTOREXPORTDECLARATION_TYPES = ae.FLIPPED_ALIAS_KEYS.
  ImportOrExportDeclaration, mR = L.EXPORTDECLARATION_TYPES = ae.FLIPPED_ALIAS_KEYS.ExportDeclaration, yR = L.MODULESPECIFIER_TYPES = ae.FLIPPED_ALIAS_KEYS.
  ModuleSpecifier, TR = L.ACCESSOR_TYPES = ae.FLIPPED_ALIAS_KEYS.Accessor, SR = L.PRIVATE_TYPES = ae.FLIPPED_ALIAS_KEYS.Private, bR = L.FLOW_TYPES =
  ae.FLIPPED_ALIAS_KEYS.Flow, xR = L.FLOWTYPE_TYPES = ae.FLIPPED_ALIAS_KEYS.FlowType, gR = L.FLOWBASEANNOTATION_TYPES = ae.FLIPPED_ALIAS_KEYS.
  FlowBaseAnnotation, ER = L.FLOWDECLARATION_TYPES = ae.FLIPPED_ALIAS_KEYS.FlowDeclaration, PR = L.FLOWPREDICATE_TYPES = ae.FLIPPED_ALIAS_KEYS.
  FlowPredicate, AR = L.ENUMBODY_TYPES = ae.FLIPPED_ALIAS_KEYS.EnumBody, IR = L.ENUMMEMBER_TYPES = ae.FLIPPED_ALIAS_KEYS.EnumMember, vR = L.
  JSX_TYPES = ae.FLIPPED_ALIAS_KEYS.JSX, CR = L.MISCELLANEOUS_TYPES = ae.FLIPPED_ALIAS_KEYS.Miscellaneous, wR = L.TYPESCRIPT_TYPES = ae.FLIPPED_ALIAS_KEYS.
  TypeScript, NR = L.TSTYPEELEMENT_TYPES = ae.FLIPPED_ALIAS_KEYS.TSTypeElement, OR = L.TSTYPE_TYPES = ae.FLIPPED_ALIAS_KEYS.TSType, _R = L.TSBASETYPE_TYPES =
  ae.FLIPPED_ALIAS_KEYS.TSBaseType, DR = L.MODULEDECLARATION_TYPES = rw;
});

// ../node_modules/@babel/types/lib/converters/toBlock.js
var Mn = D((Ln) => {
  "use strict";
  Object.defineProperty(Ln, "__esModule", {
    value: !0
  });
  Ln.default = iw;
  var _i = Be(), kn = it();
  function iw(t, e) {
    if ((0, _i.isBlockStatement)(t))
      return t;
    let r = [];
    return (0, _i.isEmptyStatement)(t) ? r = [] : ((0, _i.isStatement)(t) || ((0, _i.isFunction)(e) ? t = (0, kn.returnStatement)(t) : t = (0, kn.
    expressionStatement)(t)), r = [t]), (0, kn.blockStatement)(r);
  }
  s(iw, "toBlock");
});

// ../node_modules/@babel/types/lib/converters/ensureBlock.js
var mu = D((Bn) => {
  "use strict";
  Object.defineProperty(Bn, "__esModule", {
    value: !0
  });
  Bn.default = nw;
  var sw = Mn();
  function nw(t, e = "body") {
    let r = (0, sw.default)(t[e], t);
    return t[e] = r, r;
  }
  s(nw, "ensureBlock");
});

// ../node_modules/@babel/types/lib/converters/toIdentifier.js
var Fn = D((jn) => {
  "use strict";
  Object.defineProperty(jn, "__esModule", {
    value: !0
  });
  jn.default = lw;
  var aw = nr(), ow = Si();
  function lw(t) {
    t = t + "";
    let e = "";
    for (let r of t)
      e += (0, ow.isIdentifierChar)(r.codePointAt(0)) ? r : "-";
    return e = e.replace(/^[-0-9]+/, ""), e = e.replace(/[-\s]+(.)?/g, function(r, i) {
      return i ? i.toUpperCase() : "";
    }), (0, aw.default)(e) || (e = `_${e}`), e || "_";
  }
  s(lw, "toIdentifier");
});

// ../node_modules/@babel/types/lib/converters/toBindingIdentifierName.js
var yu = D((Rn) => {
  "use strict";
  Object.defineProperty(Rn, "__esModule", {
    value: !0
  });
  Rn.default = cw;
  var uw = Fn();
  function cw(t) {
    return t = (0, uw.default)(t), (t === "eval" || t === "arguments") && (t = "_" + t), t;
  }
  s(cw, "toBindingIdentifierName");
});

// ../node_modules/@babel/types/lib/converters/toComputedKey.js
var Tu = D((qn) => {
  "use strict";
  Object.defineProperty(qn, "__esModule", {
    value: !0
  });
  qn.default = hw;
  var pw = Be(), fw = it();
  function hw(t, e = t.key || t.property) {
    return !t.computed && (0, pw.isIdentifier)(e) && (e = (0, fw.stringLiteral)(e.name)), e;
  }
  s(hw, "toComputedKey");
});

// ../node_modules/@babel/types/lib/converters/toExpression.js
var Su = D((Di) => {
  "use strict";
  Object.defineProperty(Di, "__esModule", {
    value: !0
  });
  Di.default = void 0;
  var jr = Be(), YR = Di.default = dw;
  function dw(t) {
    if ((0, jr.isExpressionStatement)(t) && (t = t.expression), (0, jr.isExpression)(t))
      return t;
    if ((0, jr.isClass)(t) ? t.type = "ClassExpression" : (0, jr.isFunction)(t) && (t.type = "FunctionExpression"), !(0, jr.isExpression)(t))
      throw new Error(`cannot turn ${t.type} to an expression`);
    return t;
  }
  s(dw, "toExpression");
});

// ../node_modules/@babel/types/lib/traverse/traverseFast.js
var Kn = D((Un) => {
  "use strict";
  Object.defineProperty(Un, "__esModule", {
    value: !0
  });
  Un.default = Fr;
  var mw = ot(), bu = Symbol(), xu = Symbol();
  function Fr(t, e, r) {
    if (!t) return !1;
    let i = mw.VISITOR_KEYS[t.type];
    if (!i) return !1;
    r = r || {};
    let n = e(t, r);
    if (n !== void 0)
      switch (n) {
        case bu:
          return !1;
        case xu:
          return !0;
      }
    for (let a of i) {
      let o = t[a];
      if (o) {
        if (Array.isArray(o)) {
          for (let l of o)
            if (Fr(l, e, r)) return !0;
        } else if (Fr(o, e, r)) return !0;
      }
    }
    return !1;
  }
  s(Fr, "traverseFast");
  Fr.skip = bu;
  Fr.stop = xu;
});

// ../node_modules/@babel/types/lib/modifications/removeProperties.js
var Yn = D((Vn) => {
  "use strict";
  Object.defineProperty(Vn, "__esModule", {
    value: !0
  });
  Vn.default = Sw;
  var yw = ar(), gu = ["tokens", "start", "end", "loc", "raw", "rawValue"], Tw = [...yw.COMMENT_KEYS, "comments", ...gu];
  function Sw(t, e = {}) {
    let r = e.preserveComments ? gu : Tw;
    for (let n of r)
      t[n] != null && (t[n] = void 0);
    for (let n of Object.keys(t))
      n[0] === "_" && t[n] != null && (t[n] = void 0);
    let i = Object.getOwnPropertySymbols(t);
    for (let n of i)
      t[n] = null;
  }
  s(Sw, "removeProperties");
});

// ../node_modules/@babel/types/lib/modifications/removePropertiesDeep.js
var Xn = D((Jn) => {
  "use strict";
  Object.defineProperty(Jn, "__esModule", {
    value: !0
  });
  Jn.default = gw;
  var bw = Kn(), xw = Yn();
  function gw(t, e) {
    return (0, bw.default)(t, xw.default, e), t;
  }
  s(gw, "removePropertiesDeep");
});

// ../node_modules/@babel/types/lib/converters/toKeyAlias.js
var Pu = D((Wn) => {
  "use strict";
  Object.defineProperty(Wn, "__esModule", {
    value: !0
  });
  Wn.default = $t;
  var Eu = Be(), Ew = Bt(), Pw = Xn();
  function $t(t, e = t.key) {
    let r;
    return t.kind === "method" ? $t.increment() + "" : ((0, Eu.isIdentifier)(e) ? r = e.name : (0, Eu.isStringLiteral)(e) ? r = JSON.stringify(
    e.value) : r = JSON.stringify((0, Pw.default)((0, Ew.default)(e))), t.computed && (r = `[${r}]`), t.static && (r = `static:${r}`), r);
  }
  s($t, "toKeyAlias");
  $t.uid = 0;
  $t.increment = function() {
    return $t.uid >= Number.MAX_SAFE_INTEGER ? $t.uid = 0 : $t.uid++;
  };
});

// ../node_modules/@babel/types/lib/converters/toStatement.js
var Au = D((Li) => {
  "use strict";
  Object.defineProperty(Li, "__esModule", {
    value: !0
  });
  Li.default = void 0;
  var ki = Be(), Aw = it(), t8 = Li.default = Iw;
  function Iw(t, e) {
    if ((0, ki.isStatement)(t))
      return t;
    let r = !1, i;
    if ((0, ki.isClass)(t))
      r = !0, i = "ClassDeclaration";
    else if ((0, ki.isFunction)(t))
      r = !0, i = "FunctionDeclaration";
    else if ((0, ki.isAssignmentExpression)(t))
      return (0, Aw.expressionStatement)(t);
    if (r && !t.id && (i = !1), !i) {
      if (e)
        return !1;
      throw new Error(`cannot turn ${t.type} to a statement`);
    }
    return t.type = i, t;
  }
  s(Iw, "toStatement");
});

// ../node_modules/@babel/types/lib/converters/valueToNode.js
var Iu = D((Mi) => {
  "use strict";
  Object.defineProperty(Mi, "__esModule", {
    value: !0
  });
  Mi.default = void 0;
  var vw = nr(), Re = it(), s8 = Mi.default = $n, Cw = Function.call.bind(Object.prototype.toString);
  function ww(t) {
    return Cw(t) === "[object RegExp]";
  }
  s(ww, "isRegExp");
  function Nw(t) {
    if (typeof t != "object" || t === null || Object.prototype.toString.call(t) !== "[object Object]")
      return !1;
    let e = Object.getPrototypeOf(t);
    return e === null || Object.getPrototypeOf(e) === null;
  }
  s(Nw, "isPlainObject");
  function $n(t) {
    if (t === void 0)
      return (0, Re.identifier)("undefined");
    if (t === !0 || t === !1)
      return (0, Re.booleanLiteral)(t);
    if (t === null)
      return (0, Re.nullLiteral)();
    if (typeof t == "string")
      return (0, Re.stringLiteral)(t);
    if (typeof t == "number") {
      let e;
      if (Number.isFinite(t))
        e = (0, Re.numericLiteral)(Math.abs(t));
      else {
        let r;
        Number.isNaN(t) ? r = (0, Re.numericLiteral)(0) : r = (0, Re.numericLiteral)(1), e = (0, Re.binaryExpression)("/", r, (0, Re.numericLiteral)(
        0));
      }
      return (t < 0 || Object.is(t, -0)) && (e = (0, Re.unaryExpression)("-", e)), e;
    }
    if (typeof t == "bigint")
      return (0, Re.bigIntLiteral)(t.toString());
    if (ww(t)) {
      let e = t.source, r = /\/([a-z]*)$/.exec(t.toString())[1];
      return (0, Re.regExpLiteral)(e, r);
    }
    if (Array.isArray(t))
      return (0, Re.arrayExpression)(t.map($n));
    if (Nw(t)) {
      let e = [];
      for (let r of Object.keys(t)) {
        let i, n = !1;
        (0, vw.default)(r) ? r === "__proto__" ? (n = !0, i = (0, Re.stringLiteral)(r)) : i = (0, Re.identifier)(r) : i = (0, Re.stringLiteral)(
        r), e.push((0, Re.objectProperty)(i, $n(t[r]), n));
      }
      return (0, Re.objectExpression)(e);
    }
    throw new Error("don't know how to turn this value into a node");
  }
  s($n, "valueToNode");
});

// ../node_modules/@babel/types/lib/modifications/appendToMemberExpression.js
var vu = D((zn) => {
  "use strict";
  Object.defineProperty(zn, "__esModule", {
    value: !0
  });
  zn.default = _w;
  var Ow = it();
  function _w(t, e, r = !1) {
    return t.object = (0, Ow.memberExpression)(t.object, t.property, t.computed), t.property = e, t.computed = !!r, t;
  }
  s(_w, "appendToMemberExpression");
});

// ../node_modules/@babel/types/lib/modifications/inherits.js
var wu = D((Hn) => {
  "use strict";
  Object.defineProperty(Hn, "__esModule", {
    value: !0
  });
  Hn.default = kw;
  var Cu = ar(), Dw = _n();
  function kw(t, e) {
    if (!t || !e) return t;
    for (let r of Cu.INHERIT_KEYS.optional)
      t[r] == null && (t[r] = e[r]);
    for (let r of Object.keys(e))
      r[0] === "_" && r !== "__clone" && (t[r] = e[r]);
    for (let r of Cu.INHERIT_KEYS.force)
      t[r] = e[r];
    return (0, Dw.default)(t, e), t;
  }
  s(kw, "inherits");
});

// ../node_modules/@babel/types/lib/modifications/prependToMemberExpression.js
var Nu = D((Gn) => {
  "use strict";
  Object.defineProperty(Gn, "__esModule", {
    value: !0
  });
  Gn.default = Bw;
  var Lw = it(), Mw = Ye();
  function Bw(t, e) {
    if ((0, Mw.isSuper)(t.object))
      throw new Error("Cannot prepend node to super property access (`super.foo`).");
    return t.object = (0, Lw.memberExpression)(e, t.object), t;
  }
  s(Bw, "prependToMemberExpression");
});

// ../node_modules/@babel/types/lib/retrievers/getAssignmentIdentifiers.js
var Ou = D((Qn) => {
  "use strict";
  Object.defineProperty(Qn, "__esModule", {
    value: !0
  });
  Qn.default = jw;
  function jw(t) {
    let e = [].concat(t), r = /* @__PURE__ */ Object.create(null);
    for (; e.length; ) {
      let i = e.pop();
      if (i)
        switch (i.type) {
          case "ArrayPattern":
            e.push(...i.elements);
            break;
          case "AssignmentExpression":
          case "AssignmentPattern":
          case "ForInStatement":
          case "ForOfStatement":
            e.push(i.left);
            break;
          case "ObjectPattern":
            e.push(...i.properties);
            break;
          case "ObjectProperty":
            e.push(i.value);
            break;
          case "RestElement":
          case "UpdateExpression":
            e.push(i.argument);
            break;
          case "UnaryExpression":
            i.operator === "delete" && e.push(i.argument);
            break;
          case "Identifier":
            r[i.name] = i;
            break;
          default:
            break;
        }
    }
    return r;
  }
  s(jw, "getAssignmentIdentifiers");
});

// ../node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js
var Rr = D((ea) => {
  "use strict";
  Object.defineProperty(ea, "__esModule", {
    value: !0
  });
  ea.default = Zn;
  var At = Be();
  function Zn(t, e, r, i) {
    let n = [].concat(t), a = /* @__PURE__ */ Object.create(null);
    for (; n.length; ) {
      let o = n.shift();
      if (!o || i && ((0, At.isAssignmentExpression)(o) || (0, At.isUnaryExpression)(o) || (0, At.isUpdateExpression)(o)))
        continue;
      if ((0, At.isIdentifier)(o)) {
        e ? (a[o.name] = a[o.name] || []).push(o) : a[o.name] = o;
        continue;
      }
      if ((0, At.isExportDeclaration)(o) && !(0, At.isExportAllDeclaration)(o)) {
        (0, At.isDeclaration)(o.declaration) && n.push(o.declaration);
        continue;
      }
      if (r) {
        if ((0, At.isFunctionDeclaration)(o)) {
          n.push(o.id);
          continue;
        }
        if ((0, At.isFunctionExpression)(o))
          continue;
      }
      let l = Zn.keys[o.type];
      if (l)
        for (let u = 0; u < l.length; u++) {
          let p = l[u], h = o[p];
          h && (Array.isArray(h) ? n.push(...h) : n.push(h));
        }
    }
    return a;
  }
  s(Zn, "getBindingIdentifiers");
  var Fw = {
    DeclareClass: ["id"],
    DeclareFunction: ["id"],
    DeclareModule: ["id"],
    DeclareVariable: ["id"],
    DeclareInterface: ["id"],
    DeclareTypeAlias: ["id"],
    DeclareOpaqueType: ["id"],
    InterfaceDeclaration: ["id"],
    TypeAlias: ["id"],
    OpaqueType: ["id"],
    CatchClause: ["param"],
    LabeledStatement: ["label"],
    UnaryExpression: ["argument"],
    AssignmentExpression: ["left"],
    ImportSpecifier: ["local"],
    ImportNamespaceSpecifier: ["local"],
    ImportDefaultSpecifier: ["local"],
    ImportDeclaration: ["specifiers"],
    TSImportEqualsDeclaration: ["id"],
    ExportSpecifier: ["exported"],
    ExportNamespaceSpecifier: ["exported"],
    ExportDefaultSpecifier: ["exported"],
    FunctionDeclaration: ["id", "params"],
    FunctionExpression: ["id", "params"],
    ArrowFunctionExpression: ["params"],
    ObjectMethod: ["params"],
    ClassMethod: ["params"],
    ClassPrivateMethod: ["params"],
    ForInStatement: ["left"],
    ForOfStatement: ["left"],
    ClassDeclaration: ["id"],
    ClassExpression: ["id"],
    RestElement: ["argument"],
    UpdateExpression: ["argument"],
    ObjectProperty: ["value"],
    AssignmentPattern: ["left"],
    ArrayPattern: ["elements"],
    ObjectPattern: ["properties"],
    VariableDeclaration: ["declarations"],
    VariableDeclarator: ["id"]
  };
  Zn.keys = Fw;
});

// ../node_modules/@babel/types/lib/retrievers/getOuterBindingIdentifiers.js
var _u = D((Bi) => {
  "use strict";
  Object.defineProperty(Bi, "__esModule", {
    value: !0
  });
  Bi.default = void 0;
  var Rw = Rr(), T8 = Bi.default = qw;
  function qw(t, e) {
    return (0, Rw.default)(t, e, !0);
  }
  s(qw, "getOuterBindingIdentifiers");
});

// ../node_modules/@babel/types/lib/retrievers/getFunctionName.js
var ku = D((ta) => {
  "use strict";
  Object.defineProperty(ta, "__esModule", {
    value: !0
  });
  ta.default = Kw;
  var lt = Be();
  function Uw(t) {
    return (0, lt.isNullLiteral)(t) ? "null" : (0, lt.isRegExpLiteral)(t) ? `/${t.pattern}/${t.flags}` : (0, lt.isTemplateLiteral)(t) ? t.quasis.
    map((e) => e.value.raw).join("") : t.value !== void 0 ? String(t.value) : null;
  }
  s(Uw, "getNameFromLiteralId");
  function Du(t) {
    if (!t.computed || (0, lt.isLiteral)(t.key))
      return t.key;
  }
  s(Du, "getObjectMemberKey");
  function Kw(t, e) {
    if ("id" in t && t.id)
      return {
        name: t.id.name,
        originalNode: t.id
      };
    let r = "", i;
    if ((0, lt.isObjectProperty)(e, {
      value: t
    }) ? i = Du(e) : (0, lt.isObjectMethod)(t) || (0, lt.isClassMethod)(t) ? (i = Du(t), t.kind === "get" ? r = "get " : t.kind === "set" &&
    (r = "set ")) : (0, lt.isVariableDeclarator)(e, {
      init: t
    }) ? i = e.id : (0, lt.isAssignmentExpression)(e, {
      operator: "=",
      right: t
    }) && (i = e.left), !i) return null;
    let n = (0, lt.isLiteral)(i) ? Uw(i) : (0, lt.isIdentifier)(i) ? i.name : (0, lt.isPrivateName)(i) ? i.id.name : null;
    return n == null ? null : {
      name: r + n,
      originalNode: i
    };
  }
  s(Kw, "getFunctionName");
});

// ../node_modules/@babel/types/lib/traverse/traverse.js
var Lu = D((ia) => {
  "use strict";
  Object.defineProperty(ia, "__esModule", {
    value: !0
  });
  ia.default = Yw;
  var Vw = ot();
  function Yw(t, e, r) {
    typeof e == "function" && (e = {
      enter: e
    });
    let {
      enter: i,
      exit: n
    } = e;
    ra(t, i, n, r, []);
  }
  s(Yw, "traverse");
  function ra(t, e, r, i, n) {
    let a = Vw.VISITOR_KEYS[t.type];
    if (a) {
      e && e(t, n, i);
      for (let o of a) {
        let l = t[o];
        if (Array.isArray(l))
          for (let u = 0; u < l.length; u++) {
            let p = l[u];
            p && (n.push({
              node: t,
              key: o,
              index: u
            }), ra(p, e, r, i, n), n.pop());
          }
        else l && (n.push({
          node: t,
          key: o
        }), ra(l, e, r, i, n), n.pop());
      }
      r && r(t, n, i);
    }
  }
  s(ra, "traverseSimpleImpl");
});

// ../node_modules/@babel/types/lib/validators/isBinding.js
var Mu = D((sa) => {
  "use strict";
  Object.defineProperty(sa, "__esModule", {
    value: !0
  });
  sa.default = Xw;
  var Jw = Rr();
  function Xw(t, e, r) {
    if (r && t.type === "Identifier" && e.type === "ObjectProperty" && r.type === "ObjectExpression")
      return !1;
    let i = Jw.default.keys[e.type];
    if (i)
      for (let n = 0; n < i.length; n++) {
        let a = i[n], o = e[a];
        if (Array.isArray(o)) {
          if (o.includes(t)) return !0;
        } else if (o === t) return !0;
      }
    return !1;
  }
  s(Xw, "isBinding");
});

// ../node_modules/@babel/types/lib/validators/isLet.js
var aa = D((na) => {
  "use strict";
  Object.defineProperty(na, "__esModule", {
    value: !0
  });
  na.default = $w;
  var Ww = Be();
  Bu = Symbol.for("var used to be block scoped");
  var Bu;
  function $w(t) {
    return (0, Ww.isVariableDeclaration)(t) && (t.kind !== "var" || t[Bu]);
  }
  s($w, "isLet");
});

// ../node_modules/@babel/types/lib/validators/isBlockScoped.js
var Fu = D((oa) => {
  "use strict";
  Object.defineProperty(oa, "__esModule", {
    value: !0
  });
  oa.default = Hw;
  var ju = Be(), zw = aa();
  function Hw(t) {
    return (0, ju.isFunctionDeclaration)(t) || (0, ju.isClassDeclaration)(t) || (0, zw.default)(t);
  }
  s(Hw, "isBlockScoped");
});

// ../node_modules/@babel/types/lib/validators/isImmutable.js
var Ru = D((la) => {
  "use strict";
  Object.defineProperty(la, "__esModule", {
    value: !0
  });
  la.default = Zw;
  var Gw = Ti(), Qw = Be();
  function Zw(t) {
    return (0, Gw.default)(t.type, "Immutable") ? !0 : (0, Qw.isIdentifier)(t) ? t.name === "undefined" : !1;
  }
  s(Zw, "isImmutable");
});

// ../node_modules/@babel/types/lib/validators/isNodesEquivalent.js
var Uu = D((ca) => {
  "use strict";
  Object.defineProperty(ca, "__esModule", {
    value: !0
  });
  ca.default = ua;
  var qu = ot();
  function ua(t, e) {
    if (typeof t != "object" || typeof e != "object" || t == null || e == null)
      return t === e;
    if (t.type !== e.type)
      return !1;
    let r = Object.keys(qu.NODE_FIELDS[t.type] || t.type), i = qu.VISITOR_KEYS[t.type];
    for (let n of r) {
      let a = t[n], o = e[n];
      if (typeof a != typeof o)
        return !1;
      if (!(a == null && o == null)) {
        if (a == null || o == null)
          return !1;
        if (Array.isArray(a)) {
          if (!Array.isArray(o) || a.length !== o.length)
            return !1;
          for (let l = 0; l < a.length; l++)
            if (!ua(a[l], o[l]))
              return !1;
          continue;
        }
        if (typeof a == "object" && !(i != null && i.includes(n))) {
          for (let l of Object.keys(a))
            if (a[l] !== o[l])
              return !1;
          continue;
        }
        if (!ua(a, o))
          return !1;
      }
    }
    return !0;
  }
  s(ua, "isNodesEquivalent");
});

// ../node_modules/@babel/types/lib/validators/isReferenced.js
var Ku = D((pa) => {
  "use strict";
  Object.defineProperty(pa, "__esModule", {
    value: !0
  });
  pa.default = eN;
  function eN(t, e, r) {
    switch (e.type) {
      case "MemberExpression":
      case "OptionalMemberExpression":
        return e.property === t ? !!e.computed : e.object === t;
      case "JSXMemberExpression":
        return e.object === t;
      case "VariableDeclarator":
        return e.init === t;
      case "ArrowFunctionExpression":
        return e.body === t;
      case "PrivateName":
        return !1;
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "ObjectMethod":
        return e.key === t ? !!e.computed : !1;
      case "ObjectProperty":
        return e.key === t ? !!e.computed : !r || r.type !== "ObjectPattern";
      case "ClassProperty":
      case "ClassAccessorProperty":
        return e.key === t ? !!e.computed : !0;
      case "ClassPrivateProperty":
        return e.key !== t;
      case "ClassDeclaration":
      case "ClassExpression":
        return e.superClass === t;
      case "AssignmentExpression":
        return e.right === t;
      case "AssignmentPattern":
        return e.right === t;
      case "LabeledStatement":
        return !1;
      case "CatchClause":
        return !1;
      case "RestElement":
        return !1;
      case "BreakStatement":
      case "ContinueStatement":
        return !1;
      case "FunctionDeclaration":
      case "FunctionExpression":
        return !1;
      case "ExportNamespaceSpecifier":
      case "ExportDefaultSpecifier":
        return !1;
      case "ExportSpecifier":
        return r != null && r.source ? !1 : e.local === t;
      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "ImportSpecifier":
        return !1;
      case "ImportAttribute":
        return !1;
      case "JSXAttribute":
        return !1;
      case "ObjectPattern":
      case "ArrayPattern":
        return !1;
      case "MetaProperty":
        return !1;
      case "ObjectTypeProperty":
        return e.key !== t;
      case "TSEnumMember":
        return e.id !== t;
      case "TSPropertySignature":
        return e.key === t ? !!e.computed : !0;
    }
    return !0;
  }
  s(eN, "isReferenced");
});

// ../node_modules/@babel/types/lib/validators/isScope.js
var Vu = D((fa) => {
  "use strict";
  Object.defineProperty(fa, "__esModule", {
    value: !0
  });
  fa.default = tN;
  var zt = Be();
  function tN(t, e) {
    return (0, zt.isBlockStatement)(t) && ((0, zt.isFunction)(e) || (0, zt.isCatchClause)(e)) ? !1 : (0, zt.isPattern)(t) && ((0, zt.isFunction)(
    e) || (0, zt.isCatchClause)(e)) ? !0 : (0, zt.isScopable)(t);
  }
  s(tN, "isScope");
});

// ../node_modules/@babel/types/lib/validators/isSpecifierDefault.js
var Ju = D((ha) => {
  "use strict";
  Object.defineProperty(ha, "__esModule", {
    value: !0
  });
  ha.default = rN;
  var Yu = Be();
  function rN(t) {
    return (0, Yu.isImportDefaultSpecifier)(t) || (0, Yu.isIdentifier)(t.imported || t.exported, {
      name: "default"
    });
  }
  s(rN, "isSpecifierDefault");
});

// ../node_modules/@babel/types/lib/validators/isValidES3Identifier.js
var Xu = D((da) => {
  "use strict";
  Object.defineProperty(da, "__esModule", {
    value: !0
  });
  da.default = nN;
  var iN = nr(), sN = /* @__PURE__ */ new Set(["abstract", "boolean", "byte", "char", "double", "enum", "final", "float", "goto", "implement\
s", "int", "interface", "long", "native", "package", "private", "protected", "public", "short", "static", "synchronized", "throws", "transie\
nt", "volatile"]);
  function nN(t) {
    return (0, iN.default)(t) && !sN.has(t);
  }
  s(nN, "isValidES3Identifier");
});

// ../node_modules/@babel/types/lib/validators/isVar.js
var $u = D((ma) => {
  "use strict";
  Object.defineProperty(ma, "__esModule", {
    value: !0
  });
  ma.default = oN;
  var aN = Be();
  Wu = Symbol.for("var used to be block scoped");
  var Wu;
  function oN(t) {
    return (0, aN.isVariableDeclaration)(t, {
      kind: "var"
    }) && !t[Wu];
  }
  s(oN, "isVar");
});

// ../node_modules/@babel/types/lib/converters/gatherSequenceExpressions.js
var zu = D((Sa) => {
  "use strict";
  Object.defineProperty(Sa, "__esModule", {
    value: !0
  });
  Sa.default = ji;
  var lN = Rr(), Ht = Be(), ya = it(), Ta = hn(), uN = Bt();
  function ji(t, e) {
    let r = [], i = !0;
    for (let n of t)
      if ((0, Ht.isEmptyStatement)(n) || (i = !1), (0, Ht.isExpression)(n))
        r.push(n);
      else if ((0, Ht.isExpressionStatement)(n))
        r.push(n.expression);
      else if ((0, Ht.isVariableDeclaration)(n)) {
        if (n.kind !== "var") return;
        for (let a of n.declarations) {
          let o = (0, lN.default)(a);
          for (let l of Object.keys(o))
            e.push({
              kind: n.kind,
              id: (0, uN.default)(o[l])
            });
          a.init && r.push((0, ya.assignmentExpression)("=", a.id, a.init));
        }
        i = !0;
      } else if ((0, Ht.isIfStatement)(n)) {
        let a = n.consequent ? ji([n.consequent], e) : (0, Ta.buildUndefinedNode)(), o = n.alternate ? ji([n.alternate], e) : (0, Ta.buildUndefinedNode)();
        if (!a || !o) return;
        r.push((0, ya.conditionalExpression)(n.test, a, o));
      } else if ((0, Ht.isBlockStatement)(n)) {
        let a = ji(n.body, e);
        if (!a) return;
        r.push(a);
      } else if ((0, Ht.isEmptyStatement)(n))
        t.indexOf(n) === 0 && (i = !0);
      else
        return;
    return i && r.push((0, Ta.buildUndefinedNode)()), r.length === 1 ? r[0] : (0, ya.sequenceExpression)(r);
  }
  s(ji, "gatherSequenceExpressions");
});

// ../node_modules/@babel/types/lib/converters/toSequenceExpression.js
var Hu = D((ba) => {
  "use strict";
  Object.defineProperty(ba, "__esModule", {
    value: !0
  });
  ba.default = pN;
  var cN = zu();
  function pN(t, e) {
    if (!(t != null && t.length)) return;
    let r = [], i = (0, cN.default)(t, r);
    if (i) {
      for (let n of r)
        e.push(n);
      return i;
    }
  }
  s(pN, "toSequenceExpression");
});

// ../node_modules/@babel/types/lib/index.js
var Ye = D((q) => {
  "use strict";
  Object.defineProperty(q, "__esModule", {
    value: !0
  });
  var jt = {
    react: !0,
    assertNode: !0,
    createTypeAnnotationBasedOnTypeof: !0,
    createUnionTypeAnnotation: !0,
    createFlowUnionType: !0,
    createTSUnionType: !0,
    cloneNode: !0,
    clone: !0,
    cloneDeep: !0,
    cloneDeepWithoutLoc: !0,
    cloneWithoutLoc: !0,
    addComment: !0,
    addComments: !0,
    inheritInnerComments: !0,
    inheritLeadingComments: !0,
    inheritsComments: !0,
    inheritTrailingComments: !0,
    removeComments: !0,
    ensureBlock: !0,
    toBindingIdentifierName: !0,
    toBlock: !0,
    toComputedKey: !0,
    toExpression: !0,
    toIdentifier: !0,
    toKeyAlias: !0,
    toStatement: !0,
    valueToNode: !0,
    appendToMemberExpression: !0,
    inherits: !0,
    prependToMemberExpression: !0,
    removeProperties: !0,
    removePropertiesDeep: !0,
    removeTypeDuplicates: !0,
    getAssignmentIdentifiers: !0,
    getBindingIdentifiers: !0,
    getOuterBindingIdentifiers: !0,
    getFunctionName: !0,
    traverse: !0,
    traverseFast: !0,
    shallowEqual: !0,
    is: !0,
    isBinding: !0,
    isBlockScoped: !0,
    isImmutable: !0,
    isLet: !0,
    isNode: !0,
    isNodesEquivalent: !0,
    isPlaceholderType: !0,
    isReferenced: !0,
    isScope: !0,
    isSpecifierDefault: !0,
    isType: !0,
    isValidES3Identifier: !0,
    isValidIdentifier: !0,
    isVar: !0,
    matchesPattern: !0,
    validate: !0,
    buildMatchMemberExpression: !0,
    __internal__deprecationWarning: !0
  };
  Object.defineProperty(q, "__internal__deprecationWarning", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return mO.default;
    }, "get")
  });
  Object.defineProperty(q, "addComment", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return PN.default;
    }, "get")
  });
  Object.defineProperty(q, "addComments", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return AN.default;
    }, "get")
  });
  Object.defineProperty(q, "appendToMemberExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return RN.default;
    }, "get")
  });
  Object.defineProperty(q, "assertNode", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return mN.default;
    }, "get")
  });
  Object.defineProperty(q, "buildMatchMemberExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return dO.default;
    }, "get")
  });
  Object.defineProperty(q, "clone", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return bN.default;
    }, "get")
  });
  Object.defineProperty(q, "cloneDeep", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return xN.default;
    }, "get")
  });
  Object.defineProperty(q, "cloneDeepWithoutLoc", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return gN.default;
    }, "get")
  });
  Object.defineProperty(q, "cloneNode", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return SN.default;
    }, "get")
  });
  Object.defineProperty(q, "cloneWithoutLoc", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return EN.default;
    }, "get")
  });
  Object.defineProperty(q, "createFlowUnionType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Gu.default;
    }, "get")
  });
  Object.defineProperty(q, "createTSUnionType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return TN.default;
    }, "get")
  });
  Object.defineProperty(q, "createTypeAnnotationBasedOnTypeof", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return yN.default;
    }, "get")
  });
  Object.defineProperty(q, "createUnionTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Gu.default;
    }, "get")
  });
  Object.defineProperty(q, "ensureBlock", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return ON.default;
    }, "get")
  });
  Object.defineProperty(q, "getAssignmentIdentifiers", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return JN.default;
    }, "get")
  });
  Object.defineProperty(q, "getBindingIdentifiers", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return XN.default;
    }, "get")
  });
  Object.defineProperty(q, "getFunctionName", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $N.default;
    }, "get")
  });
  Object.defineProperty(q, "getOuterBindingIdentifiers", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return WN.default;
    }, "get")
  });
  Object.defineProperty(q, "inheritInnerComments", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return IN.default;
    }, "get")
  });
  Object.defineProperty(q, "inheritLeadingComments", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return vN.default;
    }, "get")
  });
  Object.defineProperty(q, "inheritTrailingComments", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return wN.default;
    }, "get")
  });
  Object.defineProperty(q, "inherits", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return qN.default;
    }, "get")
  });
  Object.defineProperty(q, "inheritsComments", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return CN.default;
    }, "get")
  });
  Object.defineProperty(q, "is", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return GN.default;
    }, "get")
  });
  Object.defineProperty(q, "isBinding", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return QN.default;
    }, "get")
  });
  Object.defineProperty(q, "isBlockScoped", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return ZN.default;
    }, "get")
  });
  Object.defineProperty(q, "isImmutable", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return eO.default;
    }, "get")
  });
  Object.defineProperty(q, "isLet", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return tO.default;
    }, "get")
  });
  Object.defineProperty(q, "isNode", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return rO.default;
    }, "get")
  });
  Object.defineProperty(q, "isNodesEquivalent", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return iO.default;
    }, "get")
  });
  Object.defineProperty(q, "isPlaceholderType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return sO.default;
    }, "get")
  });
  Object.defineProperty(q, "isReferenced", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return nO.default;
    }, "get")
  });
  Object.defineProperty(q, "isScope", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return aO.default;
    }, "get")
  });
  Object.defineProperty(q, "isSpecifierDefault", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return oO.default;
    }, "get")
  });
  Object.defineProperty(q, "isType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return lO.default;
    }, "get")
  });
  Object.defineProperty(q, "isValidES3Identifier", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return uO.default;
    }, "get")
  });
  Object.defineProperty(q, "isValidIdentifier", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return cO.default;
    }, "get")
  });
  Object.defineProperty(q, "isVar", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return pO.default;
    }, "get")
  });
  Object.defineProperty(q, "matchesPattern", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return fO.default;
    }, "get")
  });
  Object.defineProperty(q, "prependToMemberExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return UN.default;
    }, "get")
  });
  q.react = void 0;
  Object.defineProperty(q, "removeComments", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return NN.default;
    }, "get")
  });
  Object.defineProperty(q, "removeProperties", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return KN.default;
    }, "get")
  });
  Object.defineProperty(q, "removePropertiesDeep", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return VN.default;
    }, "get")
  });
  Object.defineProperty(q, "removeTypeDuplicates", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return YN.default;
    }, "get")
  });
  Object.defineProperty(q, "shallowEqual", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return HN.default;
    }, "get")
  });
  Object.defineProperty(q, "toBindingIdentifierName", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return _N.default;
    }, "get")
  });
  Object.defineProperty(q, "toBlock", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return DN.default;
    }, "get")
  });
  Object.defineProperty(q, "toComputedKey", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return kN.default;
    }, "get")
  });
  Object.defineProperty(q, "toExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return LN.default;
    }, "get")
  });
  Object.defineProperty(q, "toIdentifier", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return MN.default;
    }, "get")
  });
  Object.defineProperty(q, "toKeyAlias", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return BN.default;
    }, "get")
  });
  Object.defineProperty(q, "toStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return jN.default;
    }, "get")
  });
  Object.defineProperty(q, "traverse", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Fi.default;
    }, "get")
  });
  Object.defineProperty(q, "traverseFast", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return zN.default;
    }, "get")
  });
  Object.defineProperty(q, "validate", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return hO.default;
    }, "get")
  });
  Object.defineProperty(q, "valueToNode", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return FN.default;
    }, "get")
  });
  var fN = Zo(), hN = el(), dN = Xl(), mN = Wl(), xa = $l();
  Object.keys(xa).forEach(function(t) {
    t === "default" || t === "__esModule" || Object.prototype.hasOwnProperty.call(jt, t) || t in q && q[t] === xa[t] || Object.defineProperty(
    q, t, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return xa[t];
      }, "get")
    });
  });
  var yN = zl(), Gu = Ql(), TN = ru(), ga = hn();
  Object.keys(ga).forEach(function(t) {
    t === "default" || t === "__esModule" || Object.prototype.hasOwnProperty.call(jt, t) || t in q && q[t] === ga[t] || Object.defineProperty(
    q, t, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return ga[t];
      }, "get")
    });
  });
  var Ea = it();
  Object.keys(Ea).forEach(function(t) {
    t === "default" || t === "__esModule" || Object.prototype.hasOwnProperty.call(jt, t) || t in q && q[t] === Ea[t] || Object.defineProperty(
    q, t, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return Ea[t];
      }, "get")
    });
  });
  var SN = Bt(), bN = lu(), xN = uu(), gN = cu(), EN = pu(), PN = fu(), AN = gn(), IN = In(), vN = Cn(), CN = _n(), wN = Nn(), NN = hu(), Pa = du();
  Object.keys(Pa).forEach(function(t) {
    t === "default" || t === "__esModule" || Object.prototype.hasOwnProperty.call(jt, t) || t in q && q[t] === Pa[t] || Object.defineProperty(
    q, t, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return Pa[t];
      }, "get")
    });
  });
  var Aa = ar();
  Object.keys(Aa).forEach(function(t) {
    t === "default" || t === "__esModule" || Object.prototype.hasOwnProperty.call(jt, t) || t in q && q[t] === Aa[t] || Object.defineProperty(
    q, t, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return Aa[t];
      }, "get")
    });
  });
  var ON = mu(), _N = yu(), DN = Mn(), kN = Tu(), LN = Su(), MN = Fn(), BN = Pu(), jN = Au(), FN = Iu(), Ia = ot();
  Object.keys(Ia).forEach(function(t) {
    t === "default" || t === "__esModule" || Object.prototype.hasOwnProperty.call(jt, t) || t in q && q[t] === Ia[t] || Object.defineProperty(
    q, t, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return Ia[t];
      }, "get")
    });
  });
  var RN = vu(), qN = wu(), UN = Nu(), KN = Yn(), VN = Xn(), YN = ln(), JN = Ou(), XN = Rr(), WN = _u(), $N = ku(), Fi = Lu();
  Object.keys(Fi).forEach(function(t) {
    t === "default" || t === "__esModule" || Object.prototype.hasOwnProperty.call(jt, t) || t in q && q[t] === Fi[t] || Object.defineProperty(
    q, t, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return Fi[t];
      }, "get")
    });
  });
  var zN = Kn(), HN = mi(), GN = sr(), QN = Mu(), ZN = Fu(), eO = Ru(), tO = aa(), rO = nn(), iO = Uu(), sO = Ns(), nO = Ku(), aO = Vu(), oO = Ju(),
  lO = Ti(), uO = Xu(), cO = nr(), pO = $u(), fO = Ps(), hO = Ei(), dO = Is(), va = Be();
  Object.keys(va).forEach(function(t) {
    t === "default" || t === "__esModule" || Object.prototype.hasOwnProperty.call(jt, t) || t in q && q[t] === va[t] || Object.defineProperty(
    q, t, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return va[t];
      }, "get")
    });
  });
  var mO = Ir(), yO = Hu(), $8 = q.react = {
    isReactComponent: fN.default,
    isCompatTag: hN.default,
    buildChildren: dN.default
  };
  q.toSequenceExpression = yO.default;
  process.env.BABEL_TYPES_8_BREAKING && console.warn("BABEL_TYPES_8_BREAKING is not supported anymore. Use the latest Babel 8.0.0 pre-releas\
e instead!");
});

// ../node_modules/@babel/generator/lib/node/whitespace.js
var rc = D((qi) => {
  "use strict";
  Object.defineProperty(qi, "__esModule", {
    value: !0
  });
  qi.nodes = void 0;
  var TO = Ye(), {
    FLIPPED_ALIAS_KEYS: SO,
    isArrayExpression: bO,
    isAssignmentExpression: Zu,
    isBinary: ec,
    isBlockStatement: xO,
    isCallExpression: tc,
    isFunction: qr,
    isIdentifier: Ri,
    isLiteral: gO,
    isMemberExpression: Ca,
    isObjectExpression: EO,
    isOptionalCallExpression: PO,
    isOptionalMemberExpression: AO,
    isStringLiteral: IO
  } = TO;
  function pr(t, e) {
    return t && (Ca(t) || AO(t) ? (pr(t.object, e), t.computed && pr(t.property, e)) : ec(t) || Zu(t) ? (pr(t.left, e), pr(t.right, e)) : tc(
    t) || PO(t) ? (e.hasCall = !0, pr(t.callee, e)) : qr(t) ? e.hasFunction = !0 : Ri(t) && (e.hasHelper = e.hasHelper || t.callee && It(t.callee))),
    e;
  }
  s(pr, "crawlInternal");
  function Qu(t) {
    return pr(t, {
      hasCall: !1,
      hasFunction: !1,
      hasHelper: !1
    });
  }
  s(Qu, "crawl");
  function It(t) {
    return t ? Ca(t) ? It(t.object) || It(t.property) : Ri(t) ? t.name === "require" || t.name.charCodeAt(0) === 95 : tc(t) ? It(t.callee) :
    ec(t) || Zu(t) ? Ri(t.left) && It(t.left) || It(t.right) : !1 : !1;
  }
  s(It, "isHelper");
  function vO(t) {
    return gO(t) || EO(t) || bO(t) || Ri(t) || Ca(t);
  }
  s(vO, "isType");
  var Gt = qi.nodes = {
    AssignmentExpression(t) {
      let e = Qu(t.right);
      if (e.hasCall && e.hasHelper || e.hasFunction)
        return e.hasFunction ? 3 : 2;
    },
    SwitchCase(t, e) {
      return (t.consequent.length || e.cases[0] === t ? 1 : 0) | (!t.consequent.length && e.cases[e.cases.length - 1] === t ? 2 : 0);
    },
    LogicalExpression(t) {
      if (qr(t.left) || qr(t.right))
        return 2;
    },
    Literal(t) {
      if (IO(t) && t.value === "use strict")
        return 2;
    },
    CallExpression(t) {
      if (qr(t.callee) || It(t))
        return 3;
    },
    OptionalCallExpression(t) {
      if (qr(t.callee))
        return 3;
    },
    VariableDeclaration(t) {
      for (let e = 0; e < t.declarations.length; e++) {
        let r = t.declarations[e], i = It(r.id) && !vO(r.init);
        if (!i && r.init) {
          let n = Qu(r.init);
          i = It(r.init) && n.hasCall || n.hasFunction;
        }
        if (i)
          return 3;
      }
    },
    IfStatement(t) {
      if (xO(t.consequent))
        return 3;
    }
  };
  Gt.ObjectProperty = Gt.ObjectTypeProperty = Gt.ObjectMethod = function(t, e) {
    if (e.properties[0] === t)
      return 1;
  };
  Gt.ObjectTypeCallProperty = function(t, e) {
    var r;
    if (e.callProperties[0] === t && !((r = e.properties) != null && r.length))
      return 1;
  };
  Gt.ObjectTypeIndexer = function(t, e) {
    var r, i;
    if (e.indexers[0] === t && !((r = e.properties) != null && r.length) && !((i = e.callProperties) != null && i.length))
      return 1;
  };
  Gt.ObjectTypeInternalSlot = function(t, e) {
    var r, i, n;
    if (e.internalSlots[0] === t && !((r = e.properties) != null && r.length) && !((i = e.callProperties) != null && i.length) && !((n = e.indexers) !=
    null && n.length))
      return 1;
  };
  [["Function", !0], ["Class", !0], ["Loop", !0], ["LabeledStatement", !0], ["SwitchStatement", !0], ["TryStatement", !0]].forEach(function([
  t, e]) {
    [t].concat(SO[t] || []).forEach(function(r) {
      let i = e ? 3 : 0;
      Gt[r] = () => i;
    });
  });
});

// ../node_modules/@babel/generator/lib/node/parentheses.js
var cc = D((xe) => {
  "use strict";
  Object.defineProperty(xe, "__esModule", {
    value: !0
  });
  xe.AssignmentExpression = s_;
  xe.Binary = oc;
  xe.BinaryExpression = QO;
  xe.ClassExpression = t_;
  xe.ArrowFunctionExpression = xe.ConditionalExpression = uc;
  xe.DoExpression = UO;
  xe.FunctionExpression = r_;
  xe.FunctionTypeAnnotation = FO;
  xe.Identifier = a_;
  xe.LogicalExpression = n_;
  xe.NullableTypeAnnotation = jO;
  xe.ObjectExpression = qO;
  xe.OptionalIndexedAccessType = VO;
  xe.OptionalCallExpression = xe.OptionalMemberExpression = i_;
  xe.SequenceExpression = ZO;
  xe.TSSatisfiesExpression = xe.TSAsExpression = YO;
  xe.TSConditionalType = JO;
  xe.TSConstructorType = xe.TSFunctionType = GO;
  xe.TSInferType = $O;
  xe.TSInstantiationExpression = HO;
  xe.TSIntersectionType = WO;
  xe.UnaryLike = xe.TSTypeAssertion = lc;
  xe.TSTypeOperator = zO;
  xe.TSUnionType = XO;
  xe.IntersectionTypeAnnotation = xe.UnionTypeAnnotation = KO;
  xe.UpdateExpression = RO;
  xe.AwaitExpression = xe.YieldExpression = e_;
  var CO = Ye(), ut = Ft(), {
    isArrayTypeAnnotation: wO,
    isBinaryExpression: NO,
    isCallExpression: OO,
    isForOfStatement: _O,
    isIndexedAccessType: DO,
    isMemberExpression: nc,
    isObjectPattern: kO,
    isOptionalMemberExpression: LO,
    isYieldExpression: MO,
    isStatement: BO
  } = CO, ic = /* @__PURE__ */ new Map([["||", 0], ["??", 0], ["|>", 0], ["&&", 1], ["|", 2], ["^", 3], ["&", 4], ["==", 5], ["===", 5], ["!\
=", 5], ["!==", 5], ["<", 6], [">", 6], ["<=", 6], [">=", 6], ["in", 6], ["instanceof", 6], [">>", 7], ["<<", 7], [">>>", 7], ["+", 8], ["-",
  8], ["*", 9], ["/", 9], ["%", 9], ["**", 10]]);
  function sc(t, e) {
    if (e === "BinaryExpression" || e === "LogicalExpression")
      return ic.get(t.operator);
    if (e === "TSAsExpression" || e === "TSSatisfiesExpression")
      return ic.get("in");
  }
  s(sc, "getBinaryPrecedence");
  function wa(t) {
    return t === "TSAsExpression" || t === "TSSatisfiesExpression" || t === "TSTypeAssertion";
  }
  s(wa, "isTSTypeExpression");
  var Ui = /* @__PURE__ */ s((t, e) => {
    let r = e.type;
    return (r === "ClassDeclaration" || r === "ClassExpression") && e.superClass === t;
  }, "isClassExtendsClause"), Ki = /* @__PURE__ */ s((t, e) => {
    let r = e.type;
    return (r === "MemberExpression" || r === "OptionalMemberExpression") && e.object === t || (r === "CallExpression" || r === "OptionalCal\
lExpression" || r === "NewExpression") && e.callee === t || r === "TaggedTemplateExpression" && e.tag === t || r === "TSNonNullExpression";
  }, "hasPostfixPart");
  function jO(t, e) {
    return wO(e);
  }
  s(jO, "NullableTypeAnnotation");
  function FO(t, e, r) {
    let i = e.type;
    return i === "UnionTypeAnnotation" || i === "IntersectionTypeAnnotation" || i === "ArrayTypeAnnotation" || !!(r & ut.TokenContext.arrowFlowReturnType);
  }
  s(FO, "FunctionTypeAnnotation");
  function RO(t, e) {
    return Ki(t, e) || Ui(t, e);
  }
  s(RO, "UpdateExpression");
  function ac(t) {
    return !!(t & (ut.TokenContext.expressionStatement | ut.TokenContext.arrowBody));
  }
  s(ac, "needsParenBeforeExpressionBrace");
  function qO(t, e, r) {
    return ac(r);
  }
  s(qO, "ObjectExpression");
  function UO(t, e, r) {
    return !t.async && !!(r & ut.TokenContext.expressionStatement);
  }
  s(UO, "DoExpression");
  function oc(t, e) {
    let r = e.type;
    if (t.type === "BinaryExpression" && t.operator === "**" && r === "BinaryExpression" && e.operator === "**")
      return e.left === t;
    if (Ui(t, e) || Ki(t, e) || r === "UnaryExpression" || r === "SpreadElement" || r === "AwaitExpression")
      return !0;
    let i = sc(e, r);
    if (i != null) {
      let n = sc(t, t.type);
      if (i === n && r === "BinaryExpression" && e.right === t || i > n)
        return !0;
    }
  }
  s(oc, "Binary");
  function KO(t, e) {
    let r = e.type;
    return r === "ArrayTypeAnnotation" || r === "NullableTypeAnnotation" || r === "IntersectionTypeAnnotation" || r === "UnionTypeAnnotation";
  }
  s(KO, "UnionTypeAnnotation");
  function VO(t, e) {
    return DO(e) && e.objectType === t;
  }
  s(VO, "OptionalIndexedAccessType");
  function YO(t, e) {
    return (e.type === "AssignmentExpression" || e.type === "AssignmentPattern") && e.left === t || e.type === "BinaryExpression" && (e.operator ===
    "|" || e.operator === "&") && t === e.left ? !0 : oc(t, e);
  }
  s(YO, "TSAsExpression");
  function JO(t, e) {
    let r = e.type;
    return r === "TSArrayType" || r === "TSIndexedAccessType" && e.objectType === t || r === "TSOptionalType" || r === "TSTypeOperator" || r ===
    "TSTypeParameter" || (r === "TSIntersectionType" || r === "TSUnionType") && e.types[0] === t || r === "TSConditionalType" && (e.checkType ===
    t || e.extendsType === t);
  }
  s(JO, "TSConditionalType");
  function XO(t, e) {
    let r = e.type;
    return r === "TSIntersectionType" || r === "TSTypeOperator" || r === "TSArrayType" || r === "TSIndexedAccessType" && e.objectType === t ||
    r === "TSOptionalType";
  }
  s(XO, "TSUnionType");
  function WO(t, e) {
    let r = e.type;
    return r === "TSTypeOperator" || r === "TSArrayType" || r === "TSIndexedAccessType" && e.objectType === t || r === "TSOptionalType";
  }
  s(WO, "TSIntersectionType");
  function $O(t, e) {
    let r = e.type;
    return !!(r === "TSArrayType" || r === "TSIndexedAccessType" && e.objectType === t || r === "TSOptionalType" || t.typeParameter.constraint &&
    (r === "TSIntersectionType" || r === "TSUnionType") && e.types[0] === t);
  }
  s($O, "TSInferType");
  function zO(t, e) {
    let r = e.type;
    return r === "TSArrayType" || r === "TSIndexedAccessType" && e.objectType === t || r === "TSOptionalType";
  }
  s(zO, "TSTypeOperator");
  function HO(t, e) {
    let r = e.type;
    return (r === "CallExpression" || r === "OptionalCallExpression" || r === "NewExpression" || r === "TSInstantiationExpression") && !!e.typeParameters;
  }
  s(HO, "TSInstantiationExpression");
  function GO(t, e) {
    let r = e.type;
    return r === "TSIntersectionType" || r === "TSUnionType" || r === "TSTypeOperator" || r === "TSOptionalType" || r === "TSArrayType" || r ===
    "TSIndexedAccessType" && e.objectType === t || r === "TSConditionalType" && (e.checkType === t || e.extendsType === t);
  }
  s(GO, "TSFunctionType");
  function QO(t, e, r, i) {
    return t.operator === "in" && i;
  }
  s(QO, "BinaryExpression");
  function ZO(t, e) {
    let r = e.type;
    return r === "SequenceExpression" || r === "ParenthesizedExpression" || r === "MemberExpression" && e.property === t || r === "OptionalM\
emberExpression" && e.property === t || r === "TemplateLiteral" ? !1 : r === "ClassDeclaration" ? !0 : r === "ForOfStatement" ? e.right === t :
    r === "ExportDefaultDeclaration" ? !0 : !BO(e);
  }
  s(ZO, "SequenceExpression");
  function e_(t, e) {
    let r = e.type;
    return r === "BinaryExpression" || r === "LogicalExpression" || r === "UnaryExpression" || r === "SpreadElement" || Ki(t, e) || r === "A\
waitExpression" && MO(t) || r === "ConditionalExpression" && t === e.test || Ui(t, e) || wa(r);
  }
  s(e_, "YieldExpression");
  function t_(t, e, r) {
    return !!(r & (ut.TokenContext.expressionStatement | ut.TokenContext.exportDefault));
  }
  s(t_, "ClassExpression");
  function lc(t, e) {
    return Ki(t, e) || NO(e) && e.operator === "**" && e.left === t || Ui(t, e);
  }
  s(lc, "UnaryLike");
  function r_(t, e, r) {
    return !!(r & (ut.TokenContext.expressionStatement | ut.TokenContext.exportDefault));
  }
  s(r_, "FunctionExpression");
  function uc(t, e) {
    let r = e.type;
    return r === "UnaryExpression" || r === "SpreadElement" || r === "BinaryExpression" || r === "LogicalExpression" || r === "ConditionalEx\
pression" && e.test === t || r === "AwaitExpression" || wa(r) ? !0 : lc(t, e);
  }
  s(uc, "ConditionalExpression");
  function i_(t, e) {
    return OO(e) && e.callee === t || nc(e) && e.object === t;
  }
  s(i_, "OptionalMemberExpression");
  function s_(t, e, r) {
    return ac(r) && kO(t.left) ? !0 : uc(t, e);
  }
  s(s_, "AssignmentExpression");
  function n_(t, e) {
    let r = e.type;
    if (wa(r)) return !0;
    if (r !== "LogicalExpression") return !1;
    switch (t.operator) {
      case "||":
        return e.operator === "??" || e.operator === "&&";
      case "&&":
        return e.operator === "??";
      case "??":
        return e.operator !== "??";
    }
  }
  s(n_, "LogicalExpression");
  function a_(t, e, r, i, n) {
    var a;
    let o = e.type;
    if ((a = t.extra) != null && a.parenthesized && o === "AssignmentExpression" && e.left === t) {
      let l = e.right.type;
      if ((l === "FunctionExpression" || l === "ClassExpression") && e.right.id == null)
        return !0;
    }
    return n && n(t) !== t.name ? !1 : t.name === "let" ? (nc(e, {
      object: t,
      computed: !0
    }) || LO(e, {
      object: t,
      computed: !0,
      optional: !1
    })) && r & (ut.TokenContext.expressionStatement | ut.TokenContext.forHead | ut.TokenContext.forInHead) ? !0 : !!(r & ut.TokenContext.forOfHead) :
    t.name === "async" && _O(e, {
      left: t,
      await: !1
    });
  }
  s(a_, "Identifier");
});

// ../node_modules/@babel/generator/lib/node/index.js
var Ft = D((vt) => {
  "use strict";
  Object.defineProperty(vt, "__esModule", {
    value: !0
  });
  vt.TokenContext = void 0;
  vt.isLastChild = E_;
  vt.needsParens = g_;
  vt.needsWhitespace = Oa;
  vt.needsWhitespaceAfter = x_;
  vt.needsWhitespaceBefore = b_;
  var o_ = rc(), l_ = cc(), u_ = Ye(), {
    FLIPPED_ALIAS_KEYS: c_,
    VISITOR_KEYS: p_,
    isCallExpression: pc,
    isDecorator: f_,
    isExpressionStatement: h_,
    isMemberExpression: d_,
    isNewExpression: m_,
    isParenthesizedExpression: y_
  } = u_, t6 = vt.TokenContext = {
    expressionStatement: 1,
    arrowBody: 2,
    exportDefault: 4,
    forHead: 8,
    forInHead: 16,
    forOfHead: 32,
    arrowFlowReturnType: 64
  };
  function fc(t) {
    let e = /* @__PURE__ */ new Map();
    function r(i, n) {
      let a = e.get(i);
      e.set(i, a ? function(o, l, u, p, h) {
        var E;
        return (E = a(o, l, u, p, h)) != null ? E : n(o, l, u, p, h);
      } : n);
    }
    s(r, "add");
    for (let i of Object.keys(t)) {
      let n = c_[i];
      if (n)
        for (let a of n)
          r(a, t[i]);
      else
        r(i, t[i]);
    }
    return e;
  }
  s(fc, "expandAliases");
  var T_ = fc(l_), S_ = fc(o_.nodes);
  function hc(t) {
    return pc(t) ? !0 : d_(t) && hc(t.object);
  }
  s(hc, "isOrHasCallExpression");
  function Oa(t, e, r) {
    var i;
    if (!t) return !1;
    h_(t) && (t = t.expression);
    let n = (i = S_.get(t.type)) == null ? void 0 : i(t, e);
    return typeof n == "number" ? (n & r) !== 0 : !1;
  }
  s(Oa, "needsWhitespace");
  function b_(t, e) {
    return Oa(t, e, 1);
  }
  s(b_, "needsWhitespaceBefore");
  function x_(t, e) {
    return Oa(t, e, 2);
  }
  s(x_, "needsWhitespaceAfter");
  function g_(t, e, r, i, n) {
    var a;
    return e ? m_(e) && e.callee === t && hc(t) ? !0 : f_(e) ? !Na(t) && !(pc(t) && Na(t.callee)) && !y_(t) : (a = T_.get(t.type)) == null ?
    void 0 : a(t, e, r, i, n) : !1;
  }
  s(g_, "needsParens");
  function Na(t) {
    switch (t.type) {
      case "Identifier":
        return !0;
      case "MemberExpression":
        return !t.computed && t.property.type === "Identifier" && Na(t.object);
      default:
        return !1;
    }
  }
  s(Na, "isDecoratorMemberExpression");
  function E_(t, e) {
    let r = p_[t.type];
    for (let i = r.length - 1; i >= 0; i--) {
      let n = t[r[i]];
      if (n === e)
        return !0;
      if (Array.isArray(n)) {
        let a = n.length - 1;
        for (; a >= 0 && n[a] === null; ) a--;
        return a >= 0 && n[a] === e;
      } else if (n)
        return !1;
    }
    return !1;
  }
  s(E_, "isLastChild");
});

// ../node_modules/@babel/generator/lib/token-map.js
var dc = D((Vi) => {
  "use strict";
  Object.defineProperty(Vi, "__esModule", {
    value: !0
  });
  Vi.TokenMap = void 0;
  var P_ = Ye(), {
    traverseFast: A_,
    VISITOR_KEYS: I_
  } = P_, _a = class {
    static {
      s(this, "TokenMap");
    }
    constructor(e, r, i) {
      this._tokens = void 0, this._source = void 0, this._nodesToTokenIndexes = /* @__PURE__ */ new Map(), this._nodesOccurrencesCountCache =
      /* @__PURE__ */ new Map(), this._tokensCache = /* @__PURE__ */ new Map(), this._tokens = r, this._source = i, A_(e, (n) => {
        let a = this._getTokensIndexesOfNode(n);
        a.length > 0 && this._nodesToTokenIndexes.set(n, a);
      }), this._tokensCache = null;
    }
    has(e) {
      return this._nodesToTokenIndexes.has(e);
    }
    getIndexes(e) {
      return this._nodesToTokenIndexes.get(e);
    }
    find(e, r) {
      let i = this._nodesToTokenIndexes.get(e);
      if (i)
        for (let n = 0; n < i.length; n++) {
          let a = i[n], o = this._tokens[a];
          if (r(o, a)) return o;
        }
      return null;
    }
    findLastIndex(e, r) {
      let i = this._nodesToTokenIndexes.get(e);
      if (i)
        for (let n = i.length - 1; n >= 0; n--) {
          let a = i[n], o = this._tokens[a];
          if (r(o, a)) return a;
        }
      return -1;
    }
    findMatching(e, r, i = 0) {
      let n = this._nodesToTokenIndexes.get(e);
      if (n) {
        let a = 0, o = i;
        if (o > 1) {
          let l = this._nodesOccurrencesCountCache.get(e);
          l && l.test === r && l.count < o && (a = l.i + 1, i -= l.count + 1);
        }
        for (; a < n.length; a++) {
          let l = this._tokens[n[a]];
          if (this.matchesOriginal(l, r)) {
            if (i === 0)
              return o > 0 && this._nodesOccurrencesCountCache.set(e, {
                test: r,
                count: o,
                i: a
              }), l;
            i--;
          }
        }
      }
      return null;
    }
    matchesOriginal(e, r) {
      return e.end - e.start !== r.length ? !1 : e.value != null ? e.value === r : this._source.startsWith(r, e.start);
    }
    startMatches(e, r) {
      let i = this._nodesToTokenIndexes.get(e);
      if (!i) return !1;
      let n = this._tokens[i[0]];
      return n.start !== e.start ? !1 : this.matchesOriginal(n, r);
    }
    endMatches(e, r) {
      let i = this._nodesToTokenIndexes.get(e);
      if (!i) return !1;
      let n = this._tokens[i[i.length - 1]];
      return n.end !== e.end ? !1 : this.matchesOriginal(n, r);
    }
    _getTokensIndexesOfNode(e) {
      if (e.start == null || e.end == null) return [];
      let {
        first: r,
        last: i
      } = this._findTokensOfNode(e, 0, this._tokens.length - 1), n = r, a = v_(e);
      (e.type === "ExportNamedDeclaration" || e.type === "ExportDefaultDeclaration") && e.declaration && e.declaration.type === "ClassDeclar\
ation" && a.next();
      let o = [];
      for (let l of a) {
        if (l == null || l.start == null || l.end == null) continue;
        let u = this._findTokensOfNode(l, n, i), p = u.first;
        for (let h = n; h < p; h++) o.push(h);
        n = u.last + 1;
      }
      for (let l = n; l <= i; l++) o.push(l);
      return o;
    }
    _findTokensOfNode(e, r, i) {
      let n = this._tokensCache.get(e);
      if (n) return n;
      let a = this._findFirstTokenOfNode(e.start, r, i), o = this._findLastTokenOfNode(e.end, a, i);
      return this._tokensCache.set(e, {
        first: a,
        last: o
      }), {
        first: a,
        last: o
      };
    }
    _findFirstTokenOfNode(e, r, i) {
      for (; r <= i; ) {
        let n = i + r >> 1;
        if (e < this._tokens[n].start)
          i = n - 1;
        else if (e > this._tokens[n].start)
          r = n + 1;
        else
          return n;
      }
      return r;
    }
    _findLastTokenOfNode(e, r, i) {
      for (; r <= i; ) {
        let n = i + r >> 1;
        if (e < this._tokens[n].end)
          i = n - 1;
        else if (e > this._tokens[n].end)
          r = n + 1;
        else
          return n;
      }
      return i;
    }
  };
  Vi.TokenMap = _a;
  function* v_(t) {
    if (t.type === "TemplateLiteral") {
      yield t.quasis[0];
      for (let r = 1; r < t.quasis.length; r++)
        yield t.expressions[r - 1], yield t.quasis[r];
      return;
    }
    let e = I_[t.type];
    for (let r of e) {
      let i = t[r];
      i && (Array.isArray(i) ? yield* i : yield i);
    }
  }
  s(v_, "childrenIterator");
});

// ../node_modules/@babel/generator/lib/generators/template-literals.js
var mc = D((fr) => {
  "use strict";
  Object.defineProperty(fr, "__esModule", {
    value: !0
  });
  fr.TaggedTemplateExpression = C_;
  fr.TemplateElement = w_;
  fr.TemplateLiteral = O_;
  fr._printTemplate = N_;
  function C_(t) {
    this.print(t.tag), this.print(t.typeParameters), this.print(t.quasi);
  }
  s(C_, "TaggedTemplateExpression");
  function w_() {
    throw new Error("TemplateElement printing is handled in TemplateLiteral");
  }
  s(w_, "TemplateElement");
  function N_(t, e) {
    let r = t.quasis, i = "`";
    for (let n = 0; n < r.length - 1; n++)
      if (i += r[n].value.raw, this.token(i + "${", !0), this.print(e[n]), i = "}", this.tokenMap) {
        let a = this.tokenMap.findMatching(t, "}", n);
        a && this._catchUpTo(a.loc.start);
      }
    i += r[r.length - 1].value.raw, this.token(i + "`", !0);
  }
  s(N_, "_printTemplate");
  function O_(t) {
    this._printTemplate(t, t.expressions);
  }
  s(O_, "TemplateLiteral");
});

// ../node_modules/@babel/generator/lib/generators/expressions.js
var Tc = D((Ce) => {
  "use strict";
  Object.defineProperty(Ce, "__esModule", {
    value: !0
  });
  Ce.LogicalExpression = Ce.BinaryExpression = Ce.AssignmentExpression = rD;
  Ce.AssignmentPattern = tD;
  Ce.AwaitExpression = G_;
  Ce.BindExpression = iD;
  Ce.CallExpression = z_;
  Ce.ConditionalExpression = q_;
  Ce.Decorator = X_;
  Ce.DoExpression = j_;
  Ce.EmptyStatement = Z_;
  Ce.ExpressionStatement = eD;
  Ce.Import = H_;
  Ce.MemberExpression = sD;
  Ce.MetaProperty = nD;
  Ce.ModuleExpression = lD;
  Ce.NewExpression = U_;
  Ce.OptionalCallExpression = $_;
  Ce.OptionalMemberExpression = W_;
  Ce.ParenthesizedExpression = F_;
  Ce.PrivateName = aD;
  Ce.SequenceExpression = K_;
  Ce.Super = Y_;
  Ce.ThisExpression = V_;
  Ce.UnaryExpression = B_;
  Ce.UpdateExpression = R_;
  Ce.V8IntrinsicIdentifier = oD;
  Ce.YieldExpression = Q_;
  Ce._shouldPrintDecoratorsBeforeExport = J_;
  var __ = Ye(), D_ = Ft(), {
    isCallExpression: k_,
    isLiteral: yc,
    isMemberExpression: Da,
    isNewExpression: L_,
    isPattern: M_
  } = __;
  function B_(t) {
    let {
      operator: e
    } = t;
    e === "void" || e === "delete" || e === "typeof" || e === "throw" ? (this.word(e), this.space()) : this.token(e), this.print(t.argument);
  }
  s(B_, "UnaryExpression");
  function j_(t) {
    t.async && (this.word("async", !0), this.space()), this.word("do"), this.space(), this.print(t.body);
  }
  s(j_, "DoExpression");
  function F_(t) {
    this.tokenChar(40);
    let e = this.enterDelimited();
    this.print(t.expression), e(), this.rightParens(t);
  }
  s(F_, "ParenthesizedExpression");
  function R_(t) {
    t.prefix ? (this.token(t.operator), this.print(t.argument)) : (this.print(t.argument, !0), this.token(t.operator));
  }
  s(R_, "UpdateExpression");
  function q_(t) {
    this.print(t.test), this.space(), this.tokenChar(63), this.space(), this.print(t.consequent), this.space(), this.tokenChar(58), this.space(),
    this.print(t.alternate);
  }
  s(q_, "ConditionalExpression");
  function U_(t, e) {
    if (this.word("new"), this.space(), this.print(t.callee), this.format.minified && t.arguments.length === 0 && !t.optional && !k_(e, {
      callee: t
    }) && !Da(e) && !L_(e) || (this.print(t.typeArguments), this.print(t.typeParameters), t.optional && this.token("?."), t.arguments.length ===
    0 && this.tokenMap && !this.tokenMap.endMatches(t, ")")))
      return;
    this.tokenChar(40);
    let r = this.enterDelimited();
    this.printList(t.arguments, this.shouldPrintTrailingComma(")")), r(), this.rightParens(t);
  }
  s(U_, "NewExpression");
  function K_(t) {
    this.printList(t.expressions);
  }
  s(K_, "SequenceExpression");
  function V_() {
    this.word("this");
  }
  s(V_, "ThisExpression");
  function Y_() {
    this.word("super");
  }
  s(Y_, "Super");
  function J_(t) {
    return typeof this.format.decoratorsBeforeExport == "boolean" ? this.format.decoratorsBeforeExport : typeof t.start == "number" && t.start ===
    t.declaration.start;
  }
  s(J_, "_shouldPrintDecoratorsBeforeExport");
  function X_(t) {
    this.tokenChar(64), this.print(t.expression), this.newline();
  }
  s(X_, "Decorator");
  function W_(t) {
    let {
      computed: e
    } = t, {
      optional: r,
      property: i
    } = t;
    if (this.print(t.object), !e && Da(i))
      throw new TypeError("Got a MemberExpression for MemberExpression property");
    yc(i) && typeof i.value == "number" && (e = !0), r && this.token("?."), e ? (this.tokenChar(91), this.print(i), this.tokenChar(93)) : (r ||
    this.tokenChar(46), this.print(i));
  }
  s(W_, "OptionalMemberExpression");
  function $_(t) {
    this.print(t.callee), this.print(t.typeParameters), t.optional && this.token("?."), this.print(t.typeArguments), this.tokenChar(40);
    let e = this.enterDelimited();
    this.printList(t.arguments), e(), this.rightParens(t);
  }
  s($_, "OptionalCallExpression");
  function z_(t) {
    this.print(t.callee), this.print(t.typeArguments), this.print(t.typeParameters), this.tokenChar(40);
    let e = this.enterDelimited();
    this.printList(t.arguments, this.shouldPrintTrailingComma(")")), e(), this.rightParens(t);
  }
  s(z_, "CallExpression");
  function H_() {
    this.word("import");
  }
  s(H_, "Import");
  function G_(t) {
    this.word("await"), t.argument && (this.space(), this.printTerminatorless(t.argument));
  }
  s(G_, "AwaitExpression");
  function Q_(t) {
    this.word("yield", !0), t.delegate ? (this.tokenChar(42), t.argument && (this.space(), this.print(t.argument))) : t.argument && (this.space(),
    this.printTerminatorless(t.argument));
  }
  s(Q_, "YieldExpression");
  function Z_() {
    this.semicolon(!0);
  }
  s(Z_, "EmptyStatement");
  function eD(t) {
    this.tokenContext |= D_.TokenContext.expressionStatement, this.print(t.expression), this.semicolon();
  }
  s(eD, "ExpressionStatement");
  function tD(t) {
    this.print(t.left), (t.left.type === "Identifier" || M_(t.left)) && (t.left.optional && this.tokenChar(63), this.print(t.left.typeAnnotation)),
    this.space(), this.tokenChar(61), this.space(), this.print(t.right);
  }
  s(tD, "AssignmentPattern");
  function rD(t) {
    this.print(t.left), this.space(), t.operator === "in" || t.operator === "instanceof" ? this.word(t.operator) : (this.token(t.operator), this.
    _endsWithDiv = t.operator === "/"), this.space(), this.print(t.right);
  }
  s(rD, "AssignmentExpression");
  function iD(t) {
    this.print(t.object), this.token("::"), this.print(t.callee);
  }
  s(iD, "BindExpression");
  function sD(t) {
    if (this.print(t.object), !t.computed && Da(t.property))
      throw new TypeError("Got a MemberExpression for MemberExpression property");
    let e = t.computed;
    if (yc(t.property) && typeof t.property.value == "number" && (e = !0), e) {
      let r = this.enterDelimited();
      this.tokenChar(91), this.print(t.property), this.tokenChar(93), r();
    } else
      this.tokenChar(46), this.print(t.property);
  }
  s(sD, "MemberExpression");
  function nD(t) {
    this.print(t.meta), this.tokenChar(46), this.print(t.property);
  }
  s(nD, "MetaProperty");
  function aD(t) {
    this.tokenChar(35), this.print(t.id);
  }
  s(aD, "PrivateName");
  function oD(t) {
    this.tokenChar(37), this.word(t.name);
  }
  s(oD, "V8IntrinsicIdentifier");
  function lD(t) {
    this.word("module", !0), this.space(), this.tokenChar(123), this.indent();
    let {
      body: e
    } = t;
    (e.body.length || e.directives.length) && this.newline(), this.print(e), this.dedent(), this.rightBrace(t);
  }
  s(lD, "ModuleExpression");
});

// ../node_modules/@babel/generator/lib/generators/statements.js
var gc = D((Le) => {
  "use strict";
  Object.defineProperty(Le, "__esModule", {
    value: !0
  });
  Le.BreakStatement = SD;
  Le.CatchClause = AD;
  Le.ContinueStatement = bD;
  Le.DebuggerStatement = CD;
  Le.DoWhileStatement = TD;
  Le.ForOfStatement = Le.ForInStatement = void 0;
  Le.ForStatement = mD;
  Le.IfStatement = dD;
  Le.LabeledStatement = ED;
  Le.ReturnStatement = xD;
  Le.SwitchCase = vD;
  Le.SwitchStatement = ID;
  Le.ThrowStatement = gD;
  Le.TryStatement = PD;
  Le.VariableDeclaration = wD;
  Le.VariableDeclarator = ND;
  Le.WhileStatement = yD;
  Le.WithStatement = hD;
  var uD = Ye(), ka = Ft(), {
    isFor: Sc,
    isForStatement: cD,
    isIfStatement: pD,
    isStatement: fD
  } = uD;
  function hD(t) {
    this.word("with"), this.space(), this.tokenChar(40), this.print(t.object), this.tokenChar(41), this.printBlock(t);
  }
  s(hD, "WithStatement");
  function dD(t) {
    this.word("if"), this.space(), this.tokenChar(40), this.print(t.test), this.tokenChar(41), this.space();
    let e = t.alternate && pD(bc(t.consequent));
    e && (this.tokenChar(123), this.newline(), this.indent()), this.printAndIndentOnComments(t.consequent), e && (this.dedent(), this.newline(),
    this.tokenChar(125)), t.alternate && (this.endsWith(125) && this.space(), this.word("else"), this.space(), this.printAndIndentOnComments(
    t.alternate));
  }
  s(dD, "IfStatement");
  function bc(t) {
    let {
      body: e
    } = t;
    return fD(e) === !1 ? t : bc(e);
  }
  s(bc, "getLastStatement");
  function mD(t) {
    this.word("for"), this.space(), this.tokenChar(40);
    {
      let e = this.enterForStatementInit();
      this.tokenContext |= ka.TokenContext.forHead, this.print(t.init), e();
    }
    this.tokenChar(59), t.test && (this.space(), this.print(t.test)), this.token(";", !1, 1), t.update && (this.space(), this.print(t.update)),
    this.tokenChar(41), this.printBlock(t);
  }
  s(mD, "ForStatement");
  function yD(t) {
    this.word("while"), this.space(), this.tokenChar(40), this.print(t.test), this.tokenChar(41), this.printBlock(t);
  }
  s(yD, "WhileStatement");
  function xc(t) {
    this.word("for"), this.space();
    let e = t.type === "ForOfStatement";
    e && t.await && (this.word("await"), this.space()), this.noIndentInnerCommentsHere(), this.tokenChar(40);
    {
      let r = e ? null : this.enterForStatementInit();
      this.tokenContext |= e ? ka.TokenContext.forOfHead : ka.TokenContext.forInHead, this.print(t.left), r?.();
    }
    this.space(), this.word(e ? "of" : "in"), this.space(), this.print(t.right), this.tokenChar(41), this.printBlock(t);
  }
  s(xc, "ForXStatement");
  var c6 = Le.ForInStatement = xc, p6 = Le.ForOfStatement = xc;
  function TD(t) {
    this.word("do"), this.space(), this.print(t.body), this.space(), this.word("while"), this.space(), this.tokenChar(40), this.print(t.test),
    this.tokenChar(41), this.semicolon();
  }
  s(TD, "DoWhileStatement");
  function Yi(t, e) {
    e && (t.space(), t.printTerminatorless(e)), t.semicolon();
  }
  s(Yi, "printStatementAfterKeyword");
  function SD(t) {
    this.word("break"), Yi(this, t.label);
  }
  s(SD, "BreakStatement");
  function bD(t) {
    this.word("continue"), Yi(this, t.label);
  }
  s(bD, "ContinueStatement");
  function xD(t) {
    this.word("return"), Yi(this, t.argument);
  }
  s(xD, "ReturnStatement");
  function gD(t) {
    this.word("throw"), Yi(this, t.argument);
  }
  s(gD, "ThrowStatement");
  function ED(t) {
    this.print(t.label), this.tokenChar(58), this.space(), this.print(t.body);
  }
  s(ED, "LabeledStatement");
  function PD(t) {
    this.word("try"), this.space(), this.print(t.block), this.space(), t.handlers ? this.print(t.handlers[0]) : this.print(t.handler), t.finalizer &&
    (this.space(), this.word("finally"), this.space(), this.print(t.finalizer));
  }
  s(PD, "TryStatement");
  function AD(t) {
    this.word("catch"), this.space(), t.param && (this.tokenChar(40), this.print(t.param), this.print(t.param.typeAnnotation), this.tokenChar(
    41), this.space()), this.print(t.body);
  }
  s(AD, "CatchClause");
  function ID(t) {
    this.word("switch"), this.space(), this.tokenChar(40), this.print(t.discriminant), this.tokenChar(41), this.space(), this.tokenChar(123),
    this.printSequence(t.cases, !0, void 0, /* @__PURE__ */ s(function(r, i) {
      if (!r && t.cases[t.cases.length - 1] === i) return -1;
    }, "addNewlines")), this.rightBrace(t);
  }
  s(ID, "SwitchStatement");
  function vD(t) {
    t.test ? (this.word("case"), this.space(), this.print(t.test), this.tokenChar(58)) : (this.word("default"), this.tokenChar(58)), t.consequent.
    length && (this.newline(), this.printSequence(t.consequent, !0));
  }
  s(vD, "SwitchCase");
  function CD() {
    this.word("debugger"), this.semicolon();
  }
  s(CD, "DebuggerStatement");
  function wD(t, e) {
    t.declare && (this.word("declare"), this.space());
    let {
      kind: r
    } = t;
    r === "await using" ? (this.word("await"), this.space(), this.word("using", !0)) : this.word(r, r === "using"), this.space();
    let i = !1;
    if (!Sc(e))
      for (let n of t.declarations)
        n.init && (i = !0);
    if (this.printList(t.declarations, void 0, void 0, t.declarations.length > 1, i ? function(n) {
      this.token(",", !1, n), this.newline();
    } : void 0), Sc(e)) {
      if (cD(e)) {
        if (e.init === t) return;
      } else if (e.left === t) return;
    }
    this.semicolon();
  }
  s(wD, "VariableDeclaration");
  function ND(t) {
    this.print(t.id), t.definite && this.tokenChar(33), this.print(t.id.typeAnnotation), t.init && (this.space(), this.tokenChar(61), this.space(),
    this.print(t.init));
  }
  s(ND, "VariableDeclarator");
});

// ../node_modules/@babel/generator/lib/generators/classes.js
var Ec = D((ct) => {
  "use strict";
  Object.defineProperty(ct, "__esModule", {
    value: !0
  });
  ct.ClassAccessorProperty = jD;
  ct.ClassBody = LD;
  ct.ClassExpression = ct.ClassDeclaration = kD;
  ct.ClassMethod = RD;
  ct.ClassPrivateMethod = qD;
  ct.ClassPrivateProperty = FD;
  ct.ClassProperty = BD;
  ct.StaticBlock = KD;
  ct._classMethodHead = UD;
  var OD = Ye(), {
    isExportDefaultDeclaration: _D,
    isExportNamedDeclaration: DD
  } = OD;
  function kD(t, e) {
    (!(_D(e) || DD(e)) || !this._shouldPrintDecoratorsBeforeExport(e)) && this.printJoin(t.decorators), t.declare && (this.word("declare"), this.
    space()), t.abstract && (this.word("abstract"), this.space()), this.word("class"), t.id && (this.space(), this.print(t.id)), this.print(
    t.typeParameters), t.superClass && (this.space(), this.word("extends"), this.space(), this.print(t.superClass), this.print(t.superTypeParameters)),
    t.implements && (this.space(), this.word("implements"), this.space(), this.printList(t.implements)), this.space(), this.print(t.body);
  }
  s(kD, "ClassDeclaration");
  function LD(t) {
    if (this.tokenChar(123), t.body.length === 0)
      this.tokenChar(125);
    else {
      this.newline();
      let e = MD(this, t);
      e?.(-1);
      let r = this.enterDelimited();
      this.printJoin(t.body, !0, !0, e, !0), r(), this.endsWith(10) || this.newline(), this.rightBrace(t);
    }
  }
  s(LD, "ClassBody");
  function MD(t, e) {
    if (!t.tokenMap || e.start == null || e.end == null)
      return null;
    let r = t.tokenMap.getIndexes(e);
    if (!r) return null;
    let i = 1, n = 0, a = 0, o = /* @__PURE__ */ s(() => {
      for (; a < e.body.length && e.body[a].start == null; )
        a++;
    }, "advanceNextLocIndex");
    return o(), (l) => {
      a <= l && (a = l + 1, o());
      let u = a === e.body.length ? e.end : e.body[a].start, p;
      for (; i < r.length && t.tokenMap.matchesOriginal(p = t._tokens[r[i]], ";") && p.start < u; )
        t.token(";", void 0, n++), i++;
    };
  }
  s(MD, "classBodyEmptySemicolonsPrinter");
  function BD(t) {
    if (this.printJoin(t.decorators), !t.static && !this.format.preserveFormat) {
      var e;
      let r = (e = t.key.loc) == null || (e = e.end) == null ? void 0 : e.line;
      r && this.catchUp(r);
    }
    this.tsPrintClassMemberModifiers(t), t.computed ? (this.tokenChar(91), this.print(t.key), this.tokenChar(93)) : (this._variance(t), this.
    print(t.key)), t.optional && this.tokenChar(63), t.definite && this.tokenChar(33), this.print(t.typeAnnotation), t.value && (this.space(),
    this.tokenChar(61), this.space(), this.print(t.value)), this.semicolon();
  }
  s(BD, "ClassProperty");
  function jD(t) {
    var e;
    this.printJoin(t.decorators);
    let r = (e = t.key.loc) == null || (e = e.end) == null ? void 0 : e.line;
    r && this.catchUp(r), this.tsPrintClassMemberModifiers(t), this.word("accessor", !0), this.space(), t.computed ? (this.tokenChar(91), this.
    print(t.key), this.tokenChar(93)) : (this._variance(t), this.print(t.key)), t.optional && this.tokenChar(63), t.definite && this.tokenChar(
    33), this.print(t.typeAnnotation), t.value && (this.space(), this.tokenChar(61), this.space(), this.print(t.value)), this.semicolon();
  }
  s(jD, "ClassAccessorProperty");
  function FD(t) {
    this.printJoin(t.decorators), this.tsPrintClassMemberModifiers(t), this.print(t.key), t.optional && this.tokenChar(63), t.definite && this.
    tokenChar(33), this.print(t.typeAnnotation), t.value && (this.space(), this.tokenChar(61), this.space(), this.print(t.value)), this.semicolon();
  }
  s(FD, "ClassPrivateProperty");
  function RD(t) {
    this._classMethodHead(t), this.space(), this.print(t.body);
  }
  s(RD, "ClassMethod");
  function qD(t) {
    this._classMethodHead(t), this.space(), this.print(t.body);
  }
  s(qD, "ClassPrivateMethod");
  function UD(t) {
    if (this.printJoin(t.decorators), !this.format.preserveFormat) {
      var e;
      let r = (e = t.key.loc) == null || (e = e.end) == null ? void 0 : e.line;
      r && this.catchUp(r);
    }
    this.tsPrintClassMemberModifiers(t), this._methodHead(t);
  }
  s(UD, "_classMethodHead");
  function KD(t) {
    this.word("static"), this.space(), this.tokenChar(123), t.body.length === 0 ? this.tokenChar(125) : (this.newline(), this.printSequence(
    t.body, !0), this.rightBrace(t));
  }
  s(KD, "StaticBlock");
});

// ../node_modules/@babel/generator/lib/generators/methods.js
var Pc = D((pt) => {
  "use strict";
  Object.defineProperty(pt, "__esModule", {
    value: !0
  });
  pt.ArrowFunctionExpression = ZD;
  pt.FunctionDeclaration = pt.FunctionExpression = QD;
  pt._functionHead = GD;
  pt._methodHead = zD;
  pt._param = $D;
  pt._parameters = WD;
  pt._params = XD;
  pt._predicate = HD;
  pt._shouldPrintArrowParamsParens = ek;
  var VD = Ye(), YD = Ft(), {
    isIdentifier: JD
  } = VD;
  function XD(t, e, r) {
    this.print(t.typeParameters);
    let i = tk.call(this, e, r);
    i && this.sourceIdentifierName(i.name, i.pos), this.tokenChar(40), this._parameters(t.params, ")");
    let n = t.type === "ArrowFunctionExpression";
    this.print(t.returnType, n), this._noLineTerminator = n;
  }
  s(XD, "_params");
  function WD(t, e) {
    let r = this.enterDelimited(), i = this.shouldPrintTrailingComma(e), n = t.length;
    for (let a = 0; a < n; a++)
      this._param(t[a]), (i || a < n - 1) && (this.token(",", null, a), this.space());
    this.token(e), r();
  }
  s(WD, "_parameters");
  function $D(t) {
    this.printJoin(t.decorators), this.print(t), t.optional && this.tokenChar(63), this.print(t.typeAnnotation);
  }
  s($D, "_param");
  function zD(t) {
    let e = t.kind, r = t.key;
    (e === "get" || e === "set") && (this.word(e), this.space()), t.async && (this.word("async", !0), this.space()), (e === "method" || e ===
    "init") && t.generator && this.tokenChar(42), t.computed ? (this.tokenChar(91), this.print(r), this.tokenChar(93)) : this.print(r), t.optional &&
    this.tokenChar(63), this._params(t, t.computed && t.key.type !== "StringLiteral" ? void 0 : t.key, void 0);
  }
  s(zD, "_methodHead");
  function HD(t, e) {
    t.predicate && (t.returnType || this.tokenChar(58), this.space(), this.print(t.predicate, e));
  }
  s(HD, "_predicate");
  function GD(t, e) {
    t.async && (this.word("async"), this.format.preserveFormat || (this._endsWithInnerRaw = !1), this.space()), this.word("function"), t.generator &&
    (this.format.preserveFormat || (this._endsWithInnerRaw = !1), this.tokenChar(42)), this.space(), t.id && this.print(t.id), this._params(
    t, t.id, e), t.type !== "TSDeclareFunction" && this._predicate(t);
  }
  s(GD, "_functionHead");
  function QD(t, e) {
    this._functionHead(t, e), this.space(), this.print(t.body);
  }
  s(QD, "FunctionExpression");
  function ZD(t, e) {
    t.async && (this.word("async", !0), this.space()), this._shouldPrintArrowParamsParens(t) ? this._params(t, void 0, e) : this.print(t.params[0],
    !0), this._predicate(t, !0), this.space(), this.printInnerComments(), this.token("=>"), this.space(), this.tokenContext |= YD.TokenContext.
    arrowBody, this.print(t.body);
  }
  s(ZD, "ArrowFunctionExpression");
  function ek(t) {
    var e, r;
    if (t.params.length !== 1 || t.typeParameters || t.returnType || t.predicate)
      return !0;
    let i = t.params[0];
    if (!JD(i) || i.typeAnnotation || i.optional || (e = i.leadingComments) != null && e.length || (r = i.trailingComments) != null && r.length)
      return !0;
    if (this.tokenMap) {
      if (t.loc == null || this.tokenMap.findMatching(t, "(") !== null) return !0;
      let n = this.tokenMap.findMatching(t, "=>");
      return n?.loc == null ? !0 : n.loc.start.line !== t.loc.start.line;
    }
    return !!this.format.retainLines;
  }
  s(ek, "_shouldPrintArrowParamsParens");
  function tk(t, e) {
    let r = t;
    if (!r && e) {
      let u = e.type;
      u === "VariableDeclarator" ? r = e.id : u === "AssignmentExpression" || u === "AssignmentPattern" ? r = e.left : u === "ObjectProperty" ||
      u === "ClassProperty" ? (!e.computed || e.key.type === "StringLiteral") && (r = e.key) : (u === "ClassPrivateProperty" || u === "Class\
AccessorProperty") && (r = e.key);
    }
    if (!r) return;
    let i;
    if (r.type === "Identifier") {
      var n, a;
      i = {
        pos: (n = r.loc) == null ? void 0 : n.start,
        name: ((a = r.loc) == null ? void 0 : a.identifierName) || r.name
      };
    } else if (r.type === "PrivateName") {
      var o;
      i = {
        pos: (o = r.loc) == null ? void 0 : o.start,
        name: "#" + r.id.name
      };
    } else if (r.type === "StringLiteral") {
      var l;
      i = {
        pos: (l = r.loc) == null ? void 0 : l.start,
        name: r.value
      };
    }
    return i;
  }
  s(tk, "_getFuncIdName");
});

// ../node_modules/@babel/generator/lib/generators/modules.js
var La = D((Ge) => {
  "use strict";
  Object.defineProperty(Ge, "__esModule", {
    value: !0
  });
  Ge.ExportAllDeclaration = mk;
  Ge.ExportDefaultDeclaration = Tk;
  Ge.ExportDefaultSpecifier = pk;
  Ge.ExportNamedDeclaration = yk;
  Ge.ExportNamespaceSpecifier = hk;
  Ge.ExportSpecifier = fk;
  Ge.ImportAttribute = bk;
  Ge.ImportDeclaration = Sk;
  Ge.ImportDefaultSpecifier = ck;
  Ge.ImportExpression = gk;
  Ge.ImportNamespaceSpecifier = xk;
  Ge.ImportSpecifier = uk;
  Ge._printAttributes = dk;
  var rk = Ye(), ik = Ft(), {
    isClassDeclaration: sk,
    isExportDefaultSpecifier: nk,
    isExportNamespaceSpecifier: ak,
    isImportDefaultSpecifier: ok,
    isImportNamespaceSpecifier: lk,
    isStatement: Ic
  } = rk;
  function uk(t) {
    (t.importKind === "type" || t.importKind === "typeof") && (this.word(t.importKind), this.space()), this.print(t.imported), t.local && t.
    local.name !== t.imported.name && (this.space(), this.word("as"), this.space(), this.print(t.local));
  }
  s(uk, "ImportSpecifier");
  function ck(t) {
    this.print(t.local);
  }
  s(ck, "ImportDefaultSpecifier");
  function pk(t) {
    this.print(t.exported);
  }
  s(pk, "ExportDefaultSpecifier");
  function fk(t) {
    t.exportKind === "type" && (this.word("type"), this.space()), this.print(t.local), t.exported && t.local.name !== t.exported.name && (this.
    space(), this.word("as"), this.space(), this.print(t.exported));
  }
  s(fk, "ExportSpecifier");
  function hk(t) {
    this.tokenChar(42), this.space(), this.word("as"), this.space(), this.print(t.exported);
  }
  s(hk, "ExportNamespaceSpecifier");
  var Ac = !1;
  function dk(t, e) {
    var r;
    let {
      importAttributesKeyword: i
    } = this.format, {
      attributes: n,
      assertions: a
    } = t;
    n && !i && t.extra && (t.extra.deprecatedAssertSyntax || t.extra.deprecatedWithLegacySyntax) && !Ac && (Ac = !0, console.warn('You are u\
sing import attributes, without specifying the desired output syntax.\nPlease specify the "importAttributesKeyword" generator option, whose v\
alue can be one of:\n - "with"        : `import { a } from "b" with { type: "json" };`\n - "assert"      : `import { a } from "b" assert { typ\
e: "json" };`\n - "with-legacy" : `import { a } from "b" with type: "json";`\n'));
    let o = i === "assert" || !i && a;
    if (this.word(o ? "assert" : "with"), this.space(), !o && (i === "with-legacy" || !i && (r = t.extra) != null && r.deprecatedWithLegacySyntax)) {
      this.printList(n || a);
      return;
    }
    let l = e ? 1 : 0;
    this.token("{", null, l), this.space(), this.printList(n || a, this.shouldPrintTrailingComma("}")), this.space(), this.token("}", null, l);
  }
  s(dk, "_printAttributes");
  function mk(t) {
    var e, r;
    this.word("export"), this.space(), t.exportKind === "type" && (this.word("type"), this.space()), this.tokenChar(42), this.space(), this.
    word("from"), this.space(), (e = t.attributes) != null && e.length || (r = t.assertions) != null && r.length ? (this.print(t.source, !0),
    this.space(), this._printAttributes(t, !1)) : this.print(t.source), this.semicolon();
  }
  s(mk, "ExportAllDeclaration");
  function vc(t, e) {
    sk(e.declaration) && t._shouldPrintDecoratorsBeforeExport(e) && t.printJoin(e.declaration.decorators);
  }
  s(vc, "maybePrintDecoratorsBeforeExport");
  function yk(t) {
    if (vc(this, t), this.word("export"), this.space(), t.declaration) {
      let i = t.declaration;
      this.print(i), Ic(i) || this.semicolon();
    } else {
      t.exportKind === "type" && (this.word("type"), this.space());
      let i = t.specifiers.slice(0), n = !1;
      for (; ; ) {
        let o = i[0];
        if (nk(o) || ak(o))
          n = !0, this.print(i.shift()), i.length && (this.tokenChar(44), this.space());
        else
          break;
      }
      let a = !1;
      if ((i.length || !i.length && !n) && (a = !0, this.tokenChar(123), i.length && (this.space(), this.printList(i, this.shouldPrintTrailingComma(
      "}")), this.space()), this.tokenChar(125)), t.source) {
        var e, r;
        this.space(), this.word("from"), this.space(), (e = t.attributes) != null && e.length || (r = t.assertions) != null && r.length ? (this.
        print(t.source, !0), this.space(), this._printAttributes(t, a)) : this.print(t.source);
      }
      this.semicolon();
    }
  }
  s(yk, "ExportNamedDeclaration");
  function Tk(t) {
    vc(this, t), this.word("export"), this.noIndentInnerCommentsHere(), this.space(), this.word("default"), this.space(), this.tokenContext |=
    ik.TokenContext.exportDefault;
    let e = t.declaration;
    this.print(e), Ic(e) || this.semicolon();
  }
  s(Tk, "ExportDefaultDeclaration");
  function Sk(t) {
    var e, r;
    this.word("import"), this.space();
    let i = t.importKind === "type" || t.importKind === "typeof";
    i ? (this.noIndentInnerCommentsHere(), this.word(t.importKind), this.space()) : t.module ? (this.noIndentInnerCommentsHere(), this.word(
    "module"), this.space()) : t.phase && (this.noIndentInnerCommentsHere(), this.word(t.phase), this.space());
    let n = t.specifiers.slice(0), a = !!n.length;
    for (; a; ) {
      let l = n[0];
      if (ok(l) || lk(l))
        this.print(n.shift()), n.length && (this.tokenChar(44), this.space());
      else
        break;
    }
    let o = !1;
    n.length ? (o = !0, this.tokenChar(123), this.space(), this.printList(n, this.shouldPrintTrailingComma("}")), this.space(), this.tokenChar(
    125)) : i && !a && (o = !0, this.tokenChar(123), this.tokenChar(125)), (a || i) && (this.space(), this.word("from"), this.space()), (e =
    t.attributes) != null && e.length || (r = t.assertions) != null && r.length ? (this.print(t.source, !0), this.space(), this._printAttributes(
    t, o)) : this.print(t.source), this.semicolon();
  }
  s(Sk, "ImportDeclaration");
  function bk(t) {
    this.print(t.key), this.tokenChar(58), this.space(), this.print(t.value);
  }
  s(bk, "ImportAttribute");
  function xk(t) {
    this.tokenChar(42), this.space(), this.word("as"), this.space(), this.print(t.local);
  }
  s(xk, "ImportNamespaceSpecifier");
  function gk(t) {
    this.word("import"), t.phase && (this.tokenChar(46), this.word(t.phase)), this.tokenChar(40), this.print(t.source), t.options != null &&
    (this.tokenChar(44), this.space(), this.print(t.options)), this.tokenChar(41);
  }
  s(gk, "ImportExpression");
});

// ../node_modules/jsesc/jsesc.js
var Oc = D((x6, Nc) => {
  "use strict";
  var Cc = {}, Ek = Cc.hasOwnProperty, wc = /* @__PURE__ */ s((t, e) => {
    for (let r in t)
      Ek.call(t, r) && e(r, t[r]);
  }, "forOwn"), Pk = /* @__PURE__ */ s((t, e) => (e && wc(e, (r, i) => {
    t[r] = i;
  }), t), "extend"), Ak = /* @__PURE__ */ s((t, e) => {
    let r = t.length, i = -1;
    for (; ++i < r; )
      e(t[i]);
  }, "forEach"), Ji = /* @__PURE__ */ s((t) => "\\u" + ("0000" + t).slice(-4), "fourHexEscape"), Ur = /* @__PURE__ */ s((t, e) => {
    let r = t.toString(16);
    return e ? r : r.toUpperCase();
  }, "hexadecimal"), Kr = Cc.toString, Ik = Array.isArray, vk = /* @__PURE__ */ s((t) => typeof Buffer == "function" && Buffer.isBuffer(t), "\
isBuffer"), Ck = /* @__PURE__ */ s((t) => Kr.call(t) == "[object Object]", "isObject"), wk = /* @__PURE__ */ s((t) => typeof t == "string" ||
  Kr.call(t) == "[object String]", "isString"), Nk = /* @__PURE__ */ s((t) => typeof t == "number" || Kr.call(t) == "[object Number]", "isNu\
mber"), Ma = /* @__PURE__ */ s((t) => typeof t == "bigint", "isBigInt"), Ok = /* @__PURE__ */ s((t) => typeof t == "function", "isFunction"),
  _k = /* @__PURE__ */ s((t) => Kr.call(t) == "[object Map]", "isMap"), Dk = /* @__PURE__ */ s((t) => Kr.call(t) == "[object Set]", "isSet"),
  kk = {
    "\\": "\\\\",
    "\b": "\\b",
    "\f": "\\f",
    "\n": "\\n",
    "\r": "\\r",
    "	": "\\t"
    // `\v` is omitted intentionally, because in IE < 9, '\v' == 'v'.
    // '\v': '\\x0B'
  }, Lk = /[\\\b\f\n\r\t]/, Mk = /[0-9]/, Bk = /[\xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/, jk = /([\uD800-\uDBFF][\uDC00-\uDFFF])|([\uD800-\uDFFF])|(['"`])|[^]/g,
  Fk = /([\uD800-\uDBFF][\uDC00-\uDFFF])|([\uD800-\uDFFF])|(['"`])|[^ !#-&\(-\[\]-_a-~]/g, Rt = /* @__PURE__ */ s((t, e) => {
    let r = /* @__PURE__ */ s(() => {
      p = u, ++e.indentLevel, u = e.indent.repeat(e.indentLevel);
    }, "increaseIndentation"), i = {
      escapeEverything: !1,
      minimal: !1,
      isScriptContext: !1,
      quotes: "single",
      wrap: !1,
      es6: !1,
      json: !1,
      compact: !0,
      lowercaseHex: !1,
      numbers: "decimal",
      indent: "	",
      indentLevel: 0,
      __inline1__: !1,
      __inline2__: !1
    }, n = e && e.json;
    n && (i.quotes = "double", i.wrap = !0), e = Pk(i, e), e.quotes != "single" && e.quotes != "double" && e.quotes != "backtick" && (e.quotes =
    "single");
    let a = e.quotes == "double" ? '"' : e.quotes == "backtick" ? "`" : "'", o = e.compact, l = e.lowercaseHex, u = e.indent.repeat(e.indentLevel),
    p = "", h = e.__inline1__, E = e.__inline2__, I = o ? "" : `
`, v, _ = !0, j = e.numbers == "binary", O = e.numbers == "octal", k = e.numbers == "decimal", B = e.numbers == "hexadecimal";
    if (n && t && Ok(t.toJSON) && (t = t.toJSON()), !wk(t)) {
      if (_k(t))
        return t.size == 0 ? "new Map()" : (o || (e.__inline1__ = !0, e.__inline2__ = !1), "new Map(" + Rt(Array.from(t), e) + ")");
      if (Dk(t))
        return t.size == 0 ? "new Set()" : "new Set(" + Rt(Array.from(t), e) + ")";
      if (vk(t))
        return t.length == 0 ? "Buffer.from([])" : "Buffer.from(" + Rt(Array.from(t), e) + ")";
      if (Ik(t))
        return v = [], e.wrap = !0, h && (e.__inline1__ = !1, e.__inline2__ = !0), E || r(), Ak(t, (K) => {
          _ = !1, E && (e.__inline2__ = !1), v.push(
            (o || E ? "" : u) + Rt(K, e)
          );
        }), _ ? "[]" : E ? "[" + v.join(", ") + "]" : "[" + I + v.join("," + I) + I + (o ? "" : p) + "]";
      if (Nk(t) || Ma(t)) {
        if (n)
          return JSON.stringify(Number(t));
        let K;
        if (k)
          K = String(t);
        else if (B) {
          let oe = t.toString(16);
          l || (oe = oe.toUpperCase()), K = "0x" + oe;
        } else j ? K = "0b" + t.toString(2) : O && (K = "0o" + t.toString(8));
        return Ma(t) ? K + "n" : K;
      } else return Ma(t) ? n ? JSON.stringify(Number(t)) : t + "n" : Ck(t) ? (v = [], e.wrap = !0, r(), wc(t, (K, oe) => {
        _ = !1, v.push(
          (o ? "" : u) + Rt(K, e) + ":" + (o ? "" : " ") + Rt(oe, e)
        );
      }), _ ? "{}" : "{" + I + v.join("," + I) + I + (o ? "" : p) + "}") : n ? JSON.stringify(t) || "null" : String(t);
    }
    let ue = e.escapeEverything ? jk : Fk;
    return v = t.replace(ue, (K, oe, we, je, Je, H) => {
      if (oe) {
        if (e.minimal) return oe;
        let w = oe.charCodeAt(0), $ = oe.charCodeAt(1);
        if (e.es6) {
          let ce = (w - 55296) * 1024 + $ - 56320 + 65536;
          return "\\u{" + Ur(ce, l) + "}";
        }
        return Ji(Ur(w, l)) + Ji(Ur($, l));
      }
      if (we)
        return Ji(Ur(we.charCodeAt(0), l));
      if (K == "\0" && !n && !Mk.test(H.charAt(Je + 1)))
        return "\\0";
      if (je)
        return je == a || e.escapeEverything ? "\\" + je : je;
      if (Lk.test(K))
        return kk[K];
      if (e.minimal && !Bk.test(K))
        return K;
      let J = Ur(K.charCodeAt(0), l);
      return n || J.length > 2 ? Ji(J) : "\\x" + ("00" + J).slice(-2);
    }), a == "`" && (v = v.replace(/\$\{/g, "\\${")), e.isScriptContext && (v = v.replace(/<\/(script|style)/gi, "<\\/$1").replace(/<!--/g, n ?
    "\\u003C!--" : "\\x3C!--")), e.wrap && (v = a + v + a), v;
  }, "jsesc");
  Rt.version = "3.0.2";
  Nc.exports = Rt;
});

// ../node_modules/@babel/generator/lib/generators/types.js
var ja = D((De) => {
  "use strict";
  Object.defineProperty(De, "__esModule", {
    value: !0
  });
  De.ArgumentPlaceholder = Vk;
  De.ArrayPattern = De.ArrayExpression = $k;
  De.BigIntLiteral = rL;
  De.BooleanLiteral = Qk;
  De.Identifier = Kk;
  De.NullLiteral = Zk;
  De.NumericLiteral = eL;
  De.ObjectPattern = De.ObjectExpression = Jk;
  De.ObjectMethod = Xk;
  De.ObjectProperty = Wk;
  De.PipelineBareFunction = nL;
  De.PipelinePrimaryTopicReference = aL;
  De.PipelineTopicExpression = sL;
  De.RecordExpression = zk;
  De.RegExpLiteral = Gk;
  De.SpreadElement = De.RestElement = Yk;
  De.StringLiteral = tL;
  De.TopicReference = iL;
  De.TupleExpression = Hk;
  De._getRawIdentifier = Uk;
  var Rk = Ye(), kc = Oc(), {
    isAssignmentPattern: qk,
    isIdentifier: Ba
  } = Rk, _c = null, Xi = "";
  function Uk(t) {
    if (t === _c) return Xi;
    _c = t;
    let {
      name: e
    } = t, r = this.tokenMap.find(t, (i) => i.value === e);
    return r ? (Xi = this._originalCode.slice(r.start, r.end), Xi) : Xi = t.name;
  }
  s(Uk, "_getRawIdentifier");
  function Kk(t) {
    var e;
    this.sourceIdentifierName(((e = t.loc) == null ? void 0 : e.identifierName) || t.name), this.word(this.tokenMap ? this._getRawIdentifier(
    t) : t.name);
  }
  s(Kk, "Identifier");
  function Vk() {
    this.tokenChar(63);
  }
  s(Vk, "ArgumentPlaceholder");
  function Yk(t) {
    this.token("..."), this.print(t.argument);
  }
  s(Yk, "RestElement");
  function Jk(t) {
    let e = t.properties;
    if (this.tokenChar(123), e.length) {
      let r = this.enterDelimited();
      this.space(), this.printList(e, this.shouldPrintTrailingComma("}"), !0, !0), this.space(), r();
    }
    this.sourceWithOffset("end", t.loc, -1), this.tokenChar(125);
  }
  s(Jk, "ObjectExpression");
  function Xk(t) {
    this.printJoin(t.decorators), this._methodHead(t), this.space(), this.print(t.body);
  }
  s(Xk, "ObjectMethod");
  function Wk(t) {
    if (this.printJoin(t.decorators), t.computed)
      this.tokenChar(91), this.print(t.key), this.tokenChar(93);
    else {
      if (qk(t.value) && Ba(t.key) && t.key.name === t.value.left.name) {
        this.print(t.value);
        return;
      }
      if (this.print(t.key), t.shorthand && Ba(t.key) && Ba(t.value) && t.key.name === t.value.name)
        return;
    }
    this.tokenChar(58), this.space(), this.print(t.value);
  }
  s(Wk, "ObjectProperty");
  function $k(t) {
    let e = t.elements, r = e.length;
    this.tokenChar(91);
    let i = this.enterDelimited();
    for (let n = 0; n < e.length; n++) {
      let a = e[n];
      a ? (n > 0 && this.space(), this.print(a), (n < r - 1 || this.shouldPrintTrailingComma("]")) && this.token(",", !1, n)) : this.token("\
,", !1, n);
    }
    i(), this.tokenChar(93);
  }
  s($k, "ArrayExpression");
  function zk(t) {
    let e = t.properties, r, i;
    if (this.format.recordAndTupleSyntaxType === "bar")
      r = "{|", i = "|}";
    else {
      if (this.format.recordAndTupleSyntaxType !== "hash" && this.format.recordAndTupleSyntaxType != null)
        throw new Error(`The "recordAndTupleSyntaxType" generator option must be "bar" or "hash" (${JSON.stringify(this.format.recordAndTupleSyntaxType)}\
 received).`);
      r = "#{", i = "}";
    }
    this.token(r), e.length && (this.space(), this.printList(e, this.shouldPrintTrailingComma(i), !0, !0), this.space()), this.token(i);
  }
  s(zk, "RecordExpression");
  function Hk(t) {
    let e = t.elements, r = e.length, i, n;
    if (this.format.recordAndTupleSyntaxType === "bar")
      i = "[|", n = "|]";
    else if (this.format.recordAndTupleSyntaxType === "hash")
      i = "#[", n = "]";
    else
      throw new Error(`${this.format.recordAndTupleSyntaxType} is not a valid recordAndTuple syntax type`);
    this.token(i);
    for (let a = 0; a < e.length; a++) {
      let o = e[a];
      o && (a > 0 && this.space(), this.print(o), (a < r - 1 || this.shouldPrintTrailingComma(n)) && this.token(",", !1, a));
    }
    this.token(n);
  }
  s(Hk, "TupleExpression");
  function Gk(t) {
    this.word(`/${t.pattern}/${t.flags}`);
  }
  s(Gk, "RegExpLiteral");
  function Qk(t) {
    this.word(t.value ? "true" : "false");
  }
  s(Qk, "BooleanLiteral");
  function Zk() {
    this.word("null");
  }
  s(Zk, "NullLiteral");
  function eL(t) {
    let e = this.getPossibleRaw(t), r = this.format.jsescOption, i = t.value, n = i + "";
    r.numbers ? this.number(kc(i, r), i) : e == null ? this.number(n, i) : this.format.minified ? this.number(e.length < n.length ? e : n, i) :
    this.number(e, i);
  }
  s(eL, "NumericLiteral");
  function tL(t) {
    let e = this.getPossibleRaw(t);
    if (!this.format.minified && e !== void 0) {
      this.token(e);
      return;
    }
    let r = kc(t.value, this.format.jsescOption);
    this.token(r);
  }
  s(tL, "StringLiteral");
  function rL(t) {
    let e = this.getPossibleRaw(t);
    if (!this.format.minified && e !== void 0) {
      this.word(e);
      return;
    }
    this.word(t.value + "n");
  }
  s(rL, "BigIntLiteral");
  var Dc = /* @__PURE__ */ new Set(["^^", "@@", "^", "%", "#"]);
  function iL() {
    let {
      topicToken: t
    } = this.format;
    if (Dc.has(t))
      this.token(t);
    else {
      let e = JSON.stringify(t), r = Array.from(Dc, (i) => JSON.stringify(i));
      throw new Error(`The "topicToken" generator option must be one of ${r.join(", ")} (${e} received instead).`);
    }
  }
  s(iL, "TopicReference");
  function sL(t) {
    this.print(t.expression);
  }
  s(sL, "PipelineTopicExpression");
  function nL(t) {
    this.print(t.callee);
  }
  s(nL, "PipelineBareFunction");
  function aL() {
    this.tokenChar(35);
  }
  s(aL, "PipelinePrimaryTopicReference");
});

// ../node_modules/@babel/generator/lib/generators/flow.js
var Mc = D((G) => {
  "use strict";
  Object.defineProperty(G, "__esModule", {
    value: !0
  });
  G.AnyTypeAnnotation = pL;
  G.ArrayTypeAnnotation = fL;
  G.BooleanLiteralTypeAnnotation = dL;
  G.BooleanTypeAnnotation = hL;
  G.DeclareClass = yL;
  G.DeclareExportAllDeclaration = CL;
  G.DeclareExportDeclaration = vL;
  G.DeclareFunction = TL;
  G.DeclareInterface = xL;
  G.DeclareModule = gL;
  G.DeclareModuleExports = EL;
  G.DeclareOpaqueType = AL;
  G.DeclareTypeAlias = PL;
  G.DeclareVariable = IL;
  G.DeclaredPredicate = bL;
  G.EmptyTypeAnnotation = zL;
  G.EnumBooleanBody = NL;
  G.EnumBooleanMember = LL;
  G.EnumDeclaration = wL;
  G.EnumDefaultedMember = kL;
  G.EnumNumberBody = OL;
  G.EnumNumberMember = ML;
  G.EnumStringBody = _L;
  G.EnumStringMember = BL;
  G.EnumSymbolBody = DL;
  G.ExistsTypeAnnotation = FL;
  G.FunctionTypeAnnotation = RL;
  G.FunctionTypeParam = qL;
  G.IndexedAccessType = x2;
  G.InferredPredicate = SL;
  G.InterfaceDeclaration = YL;
  G.GenericTypeAnnotation = G.ClassImplements = G.InterfaceExtends = UL;
  G.InterfaceTypeAnnotation = XL;
  G.IntersectionTypeAnnotation = WL;
  G.MixedTypeAnnotation = $L;
  G.NullLiteralTypeAnnotation = mL;
  G.NullableTypeAnnotation = HL;
  Object.defineProperty(G, "NumberLiteralTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Lc.NumericLiteral;
    }, "get")
  });
  G.NumberTypeAnnotation = GL;
  G.ObjectTypeAnnotation = o2;
  G.ObjectTypeCallProperty = u2;
  G.ObjectTypeIndexer = c2;
  G.ObjectTypeInternalSlot = l2;
  G.ObjectTypeProperty = p2;
  G.ObjectTypeSpreadProperty = f2;
  G.OpaqueType = a2;
  G.OptionalIndexedAccessType = g2;
  G.QualifiedTypeIdentifier = h2;
  Object.defineProperty(G, "StringLiteralTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Lc.StringLiteral;
    }, "get")
  });
  G.StringTypeAnnotation = QL;
  G.SymbolTypeAnnotation = d2;
  G.ThisTypeAnnotation = ZL;
  G.TupleTypeAnnotation = e2;
  G.TypeAlias = r2;
  G.TypeAnnotation = i2;
  G.TypeCastExpression = T2;
  G.TypeParameter = n2;
  G.TypeParameterDeclaration = G.TypeParameterInstantiation = s2;
  G.TypeofTypeAnnotation = t2;
  G.UnionTypeAnnotation = y2;
  G.Variance = S2;
  G.VoidTypeAnnotation = b2;
  G._interfaceish = KL;
  G._variance = VL;
  var oL = Ye(), lL = La(), uL = Ft(), Lc = ja(), {
    isDeclareExportDeclaration: Wi,
    isStatement: cL
  } = oL;
  function pL() {
    this.word("any");
  }
  s(pL, "AnyTypeAnnotation");
  function fL(t) {
    this.print(t.elementType, !0), this.tokenChar(91), this.tokenChar(93);
  }
  s(fL, "ArrayTypeAnnotation");
  function hL() {
    this.word("boolean");
  }
  s(hL, "BooleanTypeAnnotation");
  function dL(t) {
    this.word(t.value ? "true" : "false");
  }
  s(dL, "BooleanLiteralTypeAnnotation");
  function mL() {
    this.word("null");
  }
  s(mL, "NullLiteralTypeAnnotation");
  function yL(t, e) {
    Wi(e) || (this.word("declare"), this.space()), this.word("class"), this.space(), this._interfaceish(t);
  }
  s(yL, "DeclareClass");
  function TL(t, e) {
    Wi(e) || (this.word("declare"), this.space()), this.word("function"), this.space(), this.print(t.id), this.print(t.id.typeAnnotation.typeAnnotation),
    t.predicate && (this.space(), this.print(t.predicate)), this.semicolon();
  }
  s(TL, "DeclareFunction");
  function SL() {
    this.tokenChar(37), this.word("checks");
  }
  s(SL, "InferredPredicate");
  function bL(t) {
    this.tokenChar(37), this.word("checks"), this.tokenChar(40), this.print(t.value), this.tokenChar(41);
  }
  s(bL, "DeclaredPredicate");
  function xL(t) {
    this.word("declare"), this.space(), this.InterfaceDeclaration(t);
  }
  s(xL, "DeclareInterface");
  function gL(t) {
    this.word("declare"), this.space(), this.word("module"), this.space(), this.print(t.id), this.space(), this.print(t.body);
  }
  s(gL, "DeclareModule");
  function EL(t) {
    this.word("declare"), this.space(), this.word("module"), this.tokenChar(46), this.word("exports"), this.print(t.typeAnnotation);
  }
  s(EL, "DeclareModuleExports");
  function PL(t) {
    this.word("declare"), this.space(), this.TypeAlias(t);
  }
  s(PL, "DeclareTypeAlias");
  function AL(t, e) {
    Wi(e) || (this.word("declare"), this.space()), this.OpaqueType(t);
  }
  s(AL, "DeclareOpaqueType");
  function IL(t, e) {
    Wi(e) || (this.word("declare"), this.space()), this.word("var"), this.space(), this.print(t.id), this.print(t.id.typeAnnotation), this.semicolon();
  }
  s(IL, "DeclareVariable");
  function vL(t) {
    this.word("declare"), this.space(), this.word("export"), this.space(), t.default && (this.word("default"), this.space()), jL.call(this, t);
  }
  s(vL, "DeclareExportDeclaration");
  function CL(t) {
    this.word("declare"), this.space(), lL.ExportAllDeclaration.call(this, t);
  }
  s(CL, "DeclareExportAllDeclaration");
  function wL(t) {
    let {
      id: e,
      body: r
    } = t;
    this.word("enum"), this.space(), this.print(e), this.print(r);
  }
  s(wL, "EnumDeclaration");
  function $i(t, e, r) {
    r && (t.space(), t.word("of"), t.space(), t.word(e)), t.space();
  }
  s($i, "enumExplicitType");
  function zi(t, e) {
    let {
      members: r
    } = e;
    t.token("{"), t.indent(), t.newline();
    for (let i of r)
      t.print(i), t.newline();
    e.hasUnknownMembers && (t.token("..."), t.newline()), t.dedent(), t.token("}");
  }
  s(zi, "enumBody");
  function NL(t) {
    let {
      explicitType: e
    } = t;
    $i(this, "boolean", e), zi(this, t);
  }
  s(NL, "EnumBooleanBody");
  function OL(t) {
    let {
      explicitType: e
    } = t;
    $i(this, "number", e), zi(this, t);
  }
  s(OL, "EnumNumberBody");
  function _L(t) {
    let {
      explicitType: e
    } = t;
    $i(this, "string", e), zi(this, t);
  }
  s(_L, "EnumStringBody");
  function DL(t) {
    $i(this, "symbol", !0), zi(this, t);
  }
  s(DL, "EnumSymbolBody");
  function kL(t) {
    let {
      id: e
    } = t;
    this.print(e), this.tokenChar(44);
  }
  s(kL, "EnumDefaultedMember");
  function Fa(t, e) {
    t.print(e.id), t.space(), t.token("="), t.space(), t.print(e.init), t.token(",");
  }
  s(Fa, "enumInitializedMember");
  function LL(t) {
    Fa(this, t);
  }
  s(LL, "EnumBooleanMember");
  function ML(t) {
    Fa(this, t);
  }
  s(ML, "EnumNumberMember");
  function BL(t) {
    Fa(this, t);
  }
  s(BL, "EnumStringMember");
  function jL(t) {
    if (t.declaration) {
      let e = t.declaration;
      this.print(e), cL(e) || this.semicolon();
    } else
      this.tokenChar(123), t.specifiers.length && (this.space(), this.printList(t.specifiers), this.space()), this.tokenChar(125), t.source &&
      (this.space(), this.word("from"), this.space(), this.print(t.source)), this.semicolon();
  }
  s(jL, "FlowExportDeclaration");
  function FL() {
    this.tokenChar(42);
  }
  s(FL, "ExistsTypeAnnotation");
  function RL(t, e) {
    this.print(t.typeParameters), this.tokenChar(40), t.this && (this.word("this"), this.tokenChar(58), this.space(), this.print(t.this.typeAnnotation),
    (t.params.length || t.rest) && (this.tokenChar(44), this.space())), this.printList(t.params), t.rest && (t.params.length && (this.tokenChar(
    44), this.space()), this.token("..."), this.print(t.rest)), this.tokenChar(41);
    let r = e?.type;
    r != null && (r === "ObjectTypeCallProperty" || r === "ObjectTypeInternalSlot" || r === "DeclareFunction" || r === "ObjectTypeProperty" &&
    e.method) ? this.tokenChar(58) : (this.space(), this.token("=>")), this.space(), this.print(t.returnType);
  }
  s(RL, "FunctionTypeAnnotation");
  function qL(t) {
    this.print(t.name), t.optional && this.tokenChar(63), t.name && (this.tokenChar(58), this.space()), this.print(t.typeAnnotation);
  }
  s(qL, "FunctionTypeParam");
  function UL(t) {
    this.print(t.id), this.print(t.typeParameters, !0);
  }
  s(UL, "InterfaceExtends");
  function KL(t) {
    var e;
    if (this.print(t.id), this.print(t.typeParameters), (e = t.extends) != null && e.length && (this.space(), this.word("extends"), this.space(),
    this.printList(t.extends)), t.type === "DeclareClass") {
      var r, i;
      (r = t.mixins) != null && r.length && (this.space(), this.word("mixins"), this.space(), this.printList(t.mixins)), (i = t.implements) !=
      null && i.length && (this.space(), this.word("implements"), this.space(), this.printList(t.implements));
    }
    this.space(), this.print(t.body);
  }
  s(KL, "_interfaceish");
  function VL(t) {
    var e;
    let r = (e = t.variance) == null ? void 0 : e.kind;
    r != null && (r === "plus" ? this.tokenChar(43) : r === "minus" && this.tokenChar(45));
  }
  s(VL, "_variance");
  function YL(t) {
    this.word("interface"), this.space(), this._interfaceish(t);
  }
  s(YL, "InterfaceDeclaration");
  function JL(t) {
    this.space(), this.token("&", !1, t), this.space();
  }
  s(JL, "andSeparator");
  function XL(t) {
    var e;
    this.word("interface"), (e = t.extends) != null && e.length && (this.space(), this.word("extends"), this.space(), this.printList(t.extends)),
    this.space(), this.print(t.body);
  }
  s(XL, "InterfaceTypeAnnotation");
  function WL(t) {
    this.printJoin(t.types, void 0, void 0, JL);
  }
  s(WL, "IntersectionTypeAnnotation");
  function $L() {
    this.word("mixed");
  }
  s($L, "MixedTypeAnnotation");
  function zL() {
    this.word("empty");
  }
  s(zL, "EmptyTypeAnnotation");
  function HL(t) {
    this.tokenChar(63), this.print(t.typeAnnotation);
  }
  s(HL, "NullableTypeAnnotation");
  function GL() {
    this.word("number");
  }
  s(GL, "NumberTypeAnnotation");
  function QL() {
    this.word("string");
  }
  s(QL, "StringTypeAnnotation");
  function ZL() {
    this.word("this");
  }
  s(ZL, "ThisTypeAnnotation");
  function e2(t) {
    this.tokenChar(91), this.printList(t.types), this.tokenChar(93);
  }
  s(e2, "TupleTypeAnnotation");
  function t2(t) {
    this.word("typeof"), this.space(), this.print(t.argument);
  }
  s(t2, "TypeofTypeAnnotation");
  function r2(t) {
    this.word("type"), this.space(), this.print(t.id), this.print(t.typeParameters), this.space(), this.tokenChar(61), this.space(), this.print(
    t.right), this.semicolon();
  }
  s(r2, "TypeAlias");
  function i2(t, e) {
    this.tokenChar(58), this.space(), e.type === "ArrowFunctionExpression" ? this.tokenContext |= uL.TokenContext.arrowFlowReturnType : t.optional &&
    this.tokenChar(63), this.print(t.typeAnnotation);
  }
  s(i2, "TypeAnnotation");
  function s2(t) {
    this.tokenChar(60), this.printList(t.params), this.tokenChar(62);
  }
  s(s2, "TypeParameterInstantiation");
  function n2(t) {
    this._variance(t), this.word(t.name), t.bound && this.print(t.bound), t.default && (this.space(), this.tokenChar(61), this.space(), this.
    print(t.default));
  }
  s(n2, "TypeParameter");
  function a2(t) {
    this.word("opaque"), this.space(), this.word("type"), this.space(), this.print(t.id), this.print(t.typeParameters), t.supertype && (this.
    tokenChar(58), this.space(), this.print(t.supertype)), t.impltype && (this.space(), this.tokenChar(61), this.space(), this.print(t.impltype)),
    this.semicolon();
  }
  s(a2, "OpaqueType");
  function o2(t) {
    t.exact ? this.token("{|") : this.tokenChar(123);
    let e = [...t.properties, ...t.callProperties || [], ...t.indexers || [], ...t.internalSlots || []];
    e.length && (this.newline(), this.space(), this.printJoin(e, !0, !0, void 0, void 0, /* @__PURE__ */ s(function(i) {
      if (i && !e[0]) return 1;
    }, "addNewlines"), () => {
      (e.length !== 1 || t.inexact) && (this.tokenChar(44), this.space());
    }), this.space()), t.inexact && (this.indent(), this.token("..."), e.length && this.newline(), this.dedent()), t.exact ? this.token("|}") :
    this.tokenChar(125);
  }
  s(o2, "ObjectTypeAnnotation");
  function l2(t) {
    t.static && (this.word("static"), this.space()), this.tokenChar(91), this.tokenChar(91), this.print(t.id), this.tokenChar(93), this.tokenChar(
    93), t.optional && this.tokenChar(63), t.method || (this.tokenChar(58), this.space()), this.print(t.value);
  }
  s(l2, "ObjectTypeInternalSlot");
  function u2(t) {
    t.static && (this.word("static"), this.space()), this.print(t.value);
  }
  s(u2, "ObjectTypeCallProperty");
  function c2(t) {
    t.static && (this.word("static"), this.space()), this._variance(t), this.tokenChar(91), t.id && (this.print(t.id), this.tokenChar(58), this.
    space()), this.print(t.key), this.tokenChar(93), this.tokenChar(58), this.space(), this.print(t.value);
  }
  s(c2, "ObjectTypeIndexer");
  function p2(t) {
    t.proto && (this.word("proto"), this.space()), t.static && (this.word("static"), this.space()), (t.kind === "get" || t.kind === "set") &&
    (this.word(t.kind), this.space()), this._variance(t), this.print(t.key), t.optional && this.tokenChar(63), t.method || (this.tokenChar(58),
    this.space()), this.print(t.value);
  }
  s(p2, "ObjectTypeProperty");
  function f2(t) {
    this.token("..."), this.print(t.argument);
  }
  s(f2, "ObjectTypeSpreadProperty");
  function h2(t) {
    this.print(t.qualification), this.tokenChar(46), this.print(t.id);
  }
  s(h2, "QualifiedTypeIdentifier");
  function d2() {
    this.word("symbol");
  }
  s(d2, "SymbolTypeAnnotation");
  function m2(t) {
    this.space(), this.token("|", !1, t), this.space();
  }
  s(m2, "orSeparator");
  function y2(t) {
    this.printJoin(t.types, void 0, void 0, m2);
  }
  s(y2, "UnionTypeAnnotation");
  function T2(t) {
    this.tokenChar(40), this.print(t.expression), this.print(t.typeAnnotation), this.tokenChar(41);
  }
  s(T2, "TypeCastExpression");
  function S2(t) {
    t.kind === "plus" ? this.tokenChar(43) : this.tokenChar(45);
  }
  s(S2, "Variance");
  function b2() {
    this.word("void");
  }
  s(b2, "VoidTypeAnnotation");
  function x2(t) {
    this.print(t.objectType, !0), this.tokenChar(91), this.print(t.indexType), this.tokenChar(93);
  }
  s(x2, "IndexedAccessType");
  function g2(t) {
    this.print(t.objectType), t.optional && this.token("?."), this.tokenChar(91), this.print(t.indexType), this.tokenChar(93);
  }
  s(g2, "OptionalIndexedAccessType");
});

// ../node_modules/@babel/generator/lib/generators/base.js
var Bc = D((Ct) => {
  "use strict";
  Object.defineProperty(Ct, "__esModule", {
    value: !0
  });
  Ct.BlockStatement = A2;
  Ct.Directive = I2;
  Ct.DirectiveLiteral = w2;
  Ct.File = E2;
  Ct.InterpreterDirective = N2;
  Ct.Placeholder = O2;
  Ct.Program = P2;
  function E2(t) {
    t.program && this.print(t.program.interpreter), this.print(t.program);
  }
  s(E2, "File");
  function P2(t) {
    var e;
    this.noIndentInnerCommentsHere(), this.printInnerComments();
    let r = (e = t.directives) == null ? void 0 : e.length;
    if (r) {
      var i;
      let n = t.body.length ? 2 : 1;
      this.printSequence(t.directives, void 0, n), (i = t.directives[r - 1].trailingComments) != null && i.length || this.newline(n);
    }
    this.printSequence(t.body);
  }
  s(P2, "Program");
  function A2(t) {
    var e;
    this.tokenChar(123);
    let r = this.enterDelimited(), i = (e = t.directives) == null ? void 0 : e.length;
    if (i) {
      var n;
      let a = t.body.length ? 2 : 1;
      this.printSequence(t.directives, !0, a), (n = t.directives[i - 1].trailingComments) != null && n.length || this.newline(a);
    }
    this.printSequence(t.body, !0), r(), this.rightBrace(t);
  }
  s(A2, "BlockStatement");
  function I2(t) {
    this.print(t.value), this.semicolon();
  }
  s(I2, "Directive");
  var v2 = /(?:^|[^\\])(?:\\\\)*'/, C2 = /(?:^|[^\\])(?:\\\\)*"/;
  function w2(t) {
    let e = this.getPossibleRaw(t);
    if (!this.format.minified && e !== void 0) {
      this.token(e);
      return;
    }
    let {
      value: r
    } = t;
    if (!C2.test(r))
      this.token(`"${r}"`);
    else if (!v2.test(r))
      this.token(`'${r}'`);
    else
      throw new Error("Malformed AST: it is not possible to print a directive containing both unescaped single and double quotes.");
  }
  s(w2, "DirectiveLiteral");
  function N2(t) {
    this.token(`#!${t.value}`), this.newline(1, !0);
  }
  s(N2, "InterpreterDirective");
  function O2(t) {
    this.token("%%"), this.print(t.name), this.token("%%"), t.expectedNode === "Statement" && this.semicolon();
  }
  s(O2, "Placeholder");
});

// ../node_modules/@babel/generator/lib/generators/jsx.js
var jc = D((Ue) => {
  "use strict";
  Object.defineProperty(Ue, "__esModule", {
    value: !0
  });
  Ue.JSXAttribute = _2;
  Ue.JSXClosingElement = K2;
  Ue.JSXClosingFragment = X2;
  Ue.JSXElement = R2;
  Ue.JSXEmptyExpression = V2;
  Ue.JSXExpressionContainer = B2;
  Ue.JSXFragment = Y2;
  Ue.JSXIdentifier = D2;
  Ue.JSXMemberExpression = L2;
  Ue.JSXNamespacedName = k2;
  Ue.JSXOpeningElement = U2;
  Ue.JSXOpeningFragment = J2;
  Ue.JSXSpreadAttribute = M2;
  Ue.JSXSpreadChild = j2;
  Ue.JSXText = F2;
  function _2(t) {
    this.print(t.name), t.value && (this.tokenChar(61), this.print(t.value));
  }
  s(_2, "JSXAttribute");
  function D2(t) {
    this.word(t.name);
  }
  s(D2, "JSXIdentifier");
  function k2(t) {
    this.print(t.namespace), this.tokenChar(58), this.print(t.name);
  }
  s(k2, "JSXNamespacedName");
  function L2(t) {
    this.print(t.object), this.tokenChar(46), this.print(t.property);
  }
  s(L2, "JSXMemberExpression");
  function M2(t) {
    this.tokenChar(123), this.token("..."), this.print(t.argument), this.rightBrace(t);
  }
  s(M2, "JSXSpreadAttribute");
  function B2(t) {
    this.tokenChar(123), this.print(t.expression), this.rightBrace(t);
  }
  s(B2, "JSXExpressionContainer");
  function j2(t) {
    this.tokenChar(123), this.token("..."), this.print(t.expression), this.rightBrace(t);
  }
  s(j2, "JSXSpreadChild");
  function F2(t) {
    let e = this.getPossibleRaw(t);
    e !== void 0 ? this.token(e, !0) : this.token(t.value, !0);
  }
  s(F2, "JSXText");
  function R2(t) {
    let e = t.openingElement;
    if (this.print(e), !e.selfClosing) {
      this.indent();
      for (let r of t.children)
        this.print(r);
      this.dedent(), this.print(t.closingElement);
    }
  }
  s(R2, "JSXElement");
  function q2() {
    this.space();
  }
  s(q2, "spaceSeparator");
  function U2(t) {
    this.tokenChar(60), this.print(t.name), t.typeArguments && this.print(t.typeArguments), this.print(t.typeParameters), t.attributes.length >
    0 && (this.space(), this.printJoin(t.attributes, void 0, void 0, q2)), t.selfClosing && (this.space(), this.tokenChar(47)), this.tokenChar(
    62);
  }
  s(U2, "JSXOpeningElement");
  function K2(t) {
    this.tokenChar(60), this.tokenChar(47), this.print(t.name), this.tokenChar(62);
  }
  s(K2, "JSXClosingElement");
  function V2() {
    this.printInnerComments();
  }
  s(V2, "JSXEmptyExpression");
  function Y2(t) {
    this.print(t.openingFragment), this.indent();
    for (let e of t.children)
      this.print(e);
    this.dedent(), this.print(t.closingFragment);
  }
  s(Y2, "JSXFragment");
  function J2() {
    this.tokenChar(60), this.tokenChar(62);
  }
  s(J2, "JSXOpeningFragment");
  function X2() {
    this.token("</"), this.tokenChar(62);
  }
  s(X2, "JSXClosingFragment");
});

// ../node_modules/@babel/generator/lib/generators/typescript.js
var Kc = D((W) => {
  "use strict";
  Object.defineProperty(W, "__esModule", {
    value: !0
  });
  W.TSAnyKeyword = aM;
  W.TSArrayType = CM;
  W.TSSatisfiesExpression = W.TSAsExpression = XM;
  W.TSBigIntKeyword = oM;
  W.TSBooleanKeyword = pM;
  W.TSCallSignatureDeclaration = eM;
  W.TSInterfaceHeritage = W.TSClassImplements = KM;
  W.TSConditionalType = LM;
  W.TSConstructSignatureDeclaration = tM;
  W.TSConstructorType = gM;
  W.TSDeclareFunction = G2;
  W.TSDeclareMethod = Q2;
  W.TSEnumBody = Uc;
  W.TSEnumDeclaration = zM;
  W.TSEnumMember = HM;
  W.TSExportAssignment = i3;
  W.TSExternalModuleReference = t3;
  W.TSFunctionType = xM;
  W.TSImportEqualsDeclaration = e3;
  W.TSImportType = ZM;
  W.TSIndexSignature = nM;
  W.TSIndexedAccessType = FM;
  W.TSInferType = MM;
  W.TSInstantiationExpression = $M;
  W.TSInterfaceBody = YM;
  W.TSInterfaceDeclaration = VM;
  W.TSIntersectionType = kM;
  W.TSIntrinsicKeyword = SM;
  W.TSLiteralType = UM;
  W.TSMappedType = RM;
  W.TSMethodSignature = sM;
  W.TSModuleBlock = QM;
  W.TSModuleDeclaration = GM;
  W.TSNamedTupleMember = _M;
  W.TSNamespaceExportDeclaration = s3;
  W.TSNeverKeyword = TM;
  W.TSNonNullExpression = r3;
  W.TSNullKeyword = yM;
  W.TSNumberKeyword = uM;
  W.TSObjectKeyword = cM;
  W.TSOptionalType = NM;
  W.TSParameterProperty = H2;
  W.TSParenthesizedType = BM;
  W.TSPropertySignature = rM;
  W.TSQualifiedName = Z2;
  W.TSRestType = OM;
  W.TSStringKeyword = fM;
  W.TSSymbolKeyword = hM;
  W.TSTemplateLiteralType = qM;
  W.TSThisType = bM;
  W.TSTupleType = wM;
  W.TSTypeAliasDeclaration = JM;
  W.TSTypeAnnotation = W2;
  W.TSTypeAssertion = WM;
  W.TSTypeLiteral = vM;
  W.TSTypeOperator = jM;
  W.TSTypeParameter = z2;
  W.TSTypeParameterDeclaration = W.TSTypeParameterInstantiation = $2;
  W.TSTypePredicate = AM;
  W.TSTypeQuery = IM;
  W.TSTypeReference = PM;
  W.TSUndefinedKeyword = mM;
  W.TSUnionType = DM;
  W.TSUnknownKeyword = lM;
  W.TSVoidKeyword = dM;
  W.tsPrintClassMemberModifiers = a3;
  W.tsPrintFunctionOrConstructorType = EM;
  W.tsPrintPropertyOrMethodName = iM;
  W.tsPrintSignatureDeclarationBase = n3;
  function W2(t, e) {
    this.token((e.type === "TSFunctionType" || e.type === "TSConstructorType") && e.typeAnnotation === t ? "=>" : ":"), this.space(), t.optional &&
    this.tokenChar(63), this.print(t.typeAnnotation);
  }
  s(W2, "TSTypeAnnotation");
  function $2(t, e) {
    this.tokenChar(60);
    let r = e.type === "ArrowFunctionExpression" && t.params.length === 1;
    this.tokenMap && t.start != null && t.end != null && (r && (r = !!this.tokenMap.find(t, (i) => this.tokenMap.matchesOriginal(i, ","))), r ||
    (r = this.shouldPrintTrailingComma(">"))), this.printList(t.params, r), this.tokenChar(62);
  }
  s($2, "TSTypeParameterInstantiation");
  function z2(t) {
    t.in && (this.word("in"), this.space()), t.out && (this.word("out"), this.space()), this.word(t.name), t.constraint && (this.space(), this.
    word("extends"), this.space(), this.print(t.constraint)), t.default && (this.space(), this.tokenChar(61), this.space(), this.print(t.default));
  }
  s(z2, "TSTypeParameter");
  function H2(t) {
    t.accessibility && (this.word(t.accessibility), this.space()), t.readonly && (this.word("readonly"), this.space()), this._param(t.parameter);
  }
  s(H2, "TSParameterProperty");
  function G2(t, e) {
    t.declare && (this.word("declare"), this.space()), this._functionHead(t, e), this.semicolon();
  }
  s(G2, "TSDeclareFunction");
  function Q2(t) {
    this._classMethodHead(t), this.semicolon();
  }
  s(Q2, "TSDeclareMethod");
  function Z2(t) {
    this.print(t.left), this.tokenChar(46), this.print(t.right);
  }
  s(Z2, "TSQualifiedName");
  function eM(t) {
    this.tsPrintSignatureDeclarationBase(t), Vr(this, t);
  }
  s(eM, "TSCallSignatureDeclaration");
  function Vr(t, e) {
    if (!t.tokenMap || !e.start || !e.end) {
      t.semicolon();
      return;
    }
    t.tokenMap.endMatches(e, ",") ? t.token(",") : t.tokenMap.endMatches(e, ";") && t.semicolon();
  }
  s(Vr, "maybePrintTrailingCommaOrSemicolon");
  function tM(t) {
    this.word("new"), this.space(), this.tsPrintSignatureDeclarationBase(t), Vr(this, t);
  }
  s(tM, "TSConstructSignatureDeclaration");
  function rM(t) {
    let {
      readonly: e
    } = t;
    e && (this.word("readonly"), this.space()), this.tsPrintPropertyOrMethodName(t), this.print(t.typeAnnotation), Vr(this, t);
  }
  s(rM, "TSPropertySignature");
  function iM(t) {
    t.computed && this.tokenChar(91), this.print(t.key), t.computed && this.tokenChar(93), t.optional && this.tokenChar(63);
  }
  s(iM, "tsPrintPropertyOrMethodName");
  function sM(t) {
    let {
      kind: e
    } = t;
    (e === "set" || e === "get") && (this.word(e), this.space()), this.tsPrintPropertyOrMethodName(t), this.tsPrintSignatureDeclarationBase(
    t), Vr(this, t);
  }
  s(sM, "TSMethodSignature");
  function nM(t) {
    let {
      readonly: e,
      static: r
    } = t;
    r && (this.word("static"), this.space()), e && (this.word("readonly"), this.space()), this.tokenChar(91), this._parameters(t.parameters,
    "]"), this.print(t.typeAnnotation), Vr(this, t);
  }
  s(nM, "TSIndexSignature");
  function aM() {
    this.word("any");
  }
  s(aM, "TSAnyKeyword");
  function oM() {
    this.word("bigint");
  }
  s(oM, "TSBigIntKeyword");
  function lM() {
    this.word("unknown");
  }
  s(lM, "TSUnknownKeyword");
  function uM() {
    this.word("number");
  }
  s(uM, "TSNumberKeyword");
  function cM() {
    this.word("object");
  }
  s(cM, "TSObjectKeyword");
  function pM() {
    this.word("boolean");
  }
  s(pM, "TSBooleanKeyword");
  function fM() {
    this.word("string");
  }
  s(fM, "TSStringKeyword");
  function hM() {
    this.word("symbol");
  }
  s(hM, "TSSymbolKeyword");
  function dM() {
    this.word("void");
  }
  s(dM, "TSVoidKeyword");
  function mM() {
    this.word("undefined");
  }
  s(mM, "TSUndefinedKeyword");
  function yM() {
    this.word("null");
  }
  s(yM, "TSNullKeyword");
  function TM() {
    this.word("never");
  }
  s(TM, "TSNeverKeyword");
  function SM() {
    this.word("intrinsic");
  }
  s(SM, "TSIntrinsicKeyword");
  function bM() {
    this.word("this");
  }
  s(bM, "TSThisType");
  function xM(t) {
    this.tsPrintFunctionOrConstructorType(t);
  }
  s(xM, "TSFunctionType");
  function gM(t) {
    t.abstract && (this.word("abstract"), this.space()), this.word("new"), this.space(), this.tsPrintFunctionOrConstructorType(t);
  }
  s(gM, "TSConstructorType");
  function EM(t) {
    let {
      typeParameters: e
    } = t, r = t.parameters;
    this.print(e), this.tokenChar(40), this._parameters(r, ")"), this.space();
    let i = t.typeAnnotation;
    this.print(i);
  }
  s(EM, "tsPrintFunctionOrConstructorType");
  function PM(t) {
    let e = t.typeParameters;
    this.print(t.typeName, !!e), this.print(e);
  }
  s(PM, "TSTypeReference");
  function AM(t) {
    t.asserts && (this.word("asserts"), this.space()), this.print(t.parameterName), t.typeAnnotation && (this.space(), this.word("is"), this.
    space(), this.print(t.typeAnnotation.typeAnnotation));
  }
  s(AM, "TSTypePredicate");
  function IM(t) {
    this.word("typeof"), this.space(), this.print(t.exprName);
    let e = t.typeParameters;
    e && this.print(e);
  }
  s(IM, "TSTypeQuery");
  function vM(t) {
    Hi(this, t, () => this.printJoin(t.members, !0, !0));
  }
  s(vM, "TSTypeLiteral");
  function CM(t) {
    this.print(t.elementType, !0), this.tokenChar(91), this.tokenChar(93);
  }
  s(CM, "TSArrayType");
  function wM(t) {
    this.tokenChar(91), this.printList(t.elementTypes, this.shouldPrintTrailingComma("]")), this.tokenChar(93);
  }
  s(wM, "TSTupleType");
  function NM(t) {
    this.print(t.typeAnnotation), this.tokenChar(63);
  }
  s(NM, "TSOptionalType");
  function OM(t) {
    this.token("..."), this.print(t.typeAnnotation);
  }
  s(OM, "TSRestType");
  function _M(t) {
    this.print(t.label), t.optional && this.tokenChar(63), this.tokenChar(58), this.space(), this.print(t.elementType);
  }
  s(_M, "TSNamedTupleMember");
  function DM(t) {
    qc(this, t, "|");
  }
  s(DM, "TSUnionType");
  function kM(t) {
    qc(this, t, "&");
  }
  s(kM, "TSIntersectionType");
  function qc(t, e, r) {
    var i;
    let n = 0;
    (i = t.tokenMap) != null && i.startMatches(e, r) && (n = 1, t.token(r)), t.printJoin(e.types, void 0, void 0, function(a) {
      this.space(), this.token(r, null, a + n), this.space();
    });
  }
  s(qc, "tsPrintUnionOrIntersectionType");
  function LM(t) {
    this.print(t.checkType), this.space(), this.word("extends"), this.space(), this.print(t.extendsType), this.space(), this.tokenChar(63), this.
    space(), this.print(t.trueType), this.space(), this.tokenChar(58), this.space(), this.print(t.falseType);
  }
  s(LM, "TSConditionalType");
  function MM(t) {
    this.word("infer"), this.print(t.typeParameter);
  }
  s(MM, "TSInferType");
  function BM(t) {
    this.tokenChar(40), this.print(t.typeAnnotation), this.tokenChar(41);
  }
  s(BM, "TSParenthesizedType");
  function jM(t) {
    this.word(t.operator), this.space(), this.print(t.typeAnnotation);
  }
  s(jM, "TSTypeOperator");
  function FM(t) {
    this.print(t.objectType, !0), this.tokenChar(91), this.print(t.indexType), this.tokenChar(93);
  }
  s(FM, "TSIndexedAccessType");
  function RM(t) {
    let {
      nameType: e,
      optional: r,
      readonly: i,
      typeAnnotation: n
    } = t;
    this.tokenChar(123);
    let a = this.enterDelimited();
    this.space(), i && (Fc(this, i), this.word("readonly"), this.space()), this.tokenChar(91), this.word(t.typeParameter.name), this.space(),
    this.word("in"), this.space(), this.print(t.typeParameter.constraint), e && (this.space(), this.word("as"), this.space(), this.print(e)),
    this.tokenChar(93), r && (Fc(this, r), this.tokenChar(63)), n && (this.tokenChar(58), this.space(), this.print(n)), this.space(), a(), this.
    tokenChar(125);
  }
  s(RM, "TSMappedType");
  function Fc(t, e) {
    e !== !0 && t.token(e);
  }
  s(Fc, "tokenIfPlusMinus");
  function qM(t) {
    this._printTemplate(t, t.types);
  }
  s(qM, "TSTemplateLiteralType");
  function UM(t) {
    this.print(t.literal);
  }
  s(UM, "TSLiteralType");
  function KM(t) {
    this.print(t.expression), this.print(t.typeArguments);
  }
  s(KM, "TSClassImplements");
  function VM(t) {
    let {
      declare: e,
      id: r,
      typeParameters: i,
      extends: n,
      body: a
    } = t;
    e && (this.word("declare"), this.space()), this.word("interface"), this.space(), this.print(r), this.print(i), n != null && n.length && (this.
    space(), this.word("extends"), this.space(), this.printList(n)), this.space(), this.print(a);
  }
  s(VM, "TSInterfaceDeclaration");
  function YM(t) {
    Hi(this, t, () => this.printJoin(t.body, !0, !0));
  }
  s(YM, "TSInterfaceBody");
  function JM(t) {
    let {
      declare: e,
      id: r,
      typeParameters: i,
      typeAnnotation: n
    } = t;
    e && (this.word("declare"), this.space()), this.word("type"), this.space(), this.print(r), this.print(i), this.space(), this.tokenChar(61),
    this.space(), this.print(n), this.semicolon();
  }
  s(JM, "TSTypeAliasDeclaration");
  function XM(t) {
    let {
      type: e,
      expression: r,
      typeAnnotation: i
    } = t;
    this.print(r, !0), this.space(), this.word(e === "TSAsExpression" ? "as" : "satisfies"), this.space(), this.print(i);
  }
  s(XM, "TSTypeExpression");
  function WM(t) {
    let {
      typeAnnotation: e,
      expression: r
    } = t;
    this.tokenChar(60), this.print(e), this.tokenChar(62), this.space(), this.print(r);
  }
  s(WM, "TSTypeAssertion");
  function $M(t) {
    this.print(t.expression), this.print(t.typeParameters);
  }
  s($M, "TSInstantiationExpression");
  function zM(t) {
    let {
      declare: e,
      const: r,
      id: i
    } = t;
    e && (this.word("declare"), this.space()), r && (this.word("const"), this.space()), this.word("enum"), this.space(), this.print(i), this.
    space(), Uc.call(this, t);
  }
  s(zM, "TSEnumDeclaration");
  function Uc(t) {
    Hi(this, t, () => {
      var e;
      return this.printList(t.members, (e = this.shouldPrintTrailingComma("}")) != null ? e : !0, !0, !0);
    });
  }
  s(Uc, "TSEnumBody");
  function HM(t) {
    let {
      id: e,
      initializer: r
    } = t;
    this.print(e), r && (this.space(), this.tokenChar(61), this.space(), this.print(r));
  }
  s(HM, "TSEnumMember");
  function GM(t) {
    let {
      declare: e,
      id: r,
      kind: i
    } = t;
    e && (this.word("declare"), this.space());
    {
      if (t.global || (this.word(i ?? (r.type === "Identifier" ? "namespace" : "module")), this.space()), this.print(r), !t.body) {
        this.semicolon();
        return;
      }
      let n = t.body;
      for (; n.type === "TSModuleDeclaration"; )
        this.tokenChar(46), this.print(n.id), n = n.body;
      this.space(), this.print(n);
    }
  }
  s(GM, "TSModuleDeclaration");
  function QM(t) {
    Hi(this, t, () => this.printSequence(t.body, !0));
  }
  s(QM, "TSModuleBlock");
  function ZM(t) {
    let {
      argument: e,
      qualifier: r,
      options: i
    } = t;
    this.word("import"), this.tokenChar(40), this.print(e), i && (this.tokenChar(44), this.print(i)), this.tokenChar(41), r && (this.tokenChar(
    46), this.print(r));
    let n = t.typeParameters;
    n && this.print(n);
  }
  s(ZM, "TSImportType");
  function e3(t) {
    let {
      id: e,
      moduleReference: r
    } = t;
    t.isExport && (this.word("export"), this.space()), this.word("import"), this.space(), this.print(e), this.space(), this.tokenChar(61), this.
    space(), this.print(r), this.semicolon();
  }
  s(e3, "TSImportEqualsDeclaration");
  function t3(t) {
    this.token("require("), this.print(t.expression), this.tokenChar(41);
  }
  s(t3, "TSExternalModuleReference");
  function r3(t) {
    this.print(t.expression), this.tokenChar(33);
  }
  s(r3, "TSNonNullExpression");
  function i3(t) {
    this.word("export"), this.space(), this.tokenChar(61), this.space(), this.print(t.expression), this.semicolon();
  }
  s(i3, "TSExportAssignment");
  function s3(t) {
    this.word("export"), this.space(), this.word("as"), this.space(), this.word("namespace"), this.space(), this.print(t.id), this.semicolon();
  }
  s(s3, "TSNamespaceExportDeclaration");
  function n3(t) {
    let {
      typeParameters: e
    } = t, r = t.parameters;
    this.print(e), this.tokenChar(40), this._parameters(r, ")");
    let i = t.typeAnnotation;
    this.print(i);
  }
  s(n3, "tsPrintSignatureDeclarationBase");
  function a3(t) {
    let e = t.type === "ClassPrivateProperty", r = t.type === "ClassAccessorProperty" || t.type === "ClassProperty";
    Rc(this, t, [r && t.declare && "declare", !e && t.accessibility]), t.static && (this.word("static"), this.space()), Rc(this, t, [!e && t.
    abstract && "abstract", !e && t.override && "override", (r || e) && t.readonly && "readonly"]);
  }
  s(a3, "tsPrintClassMemberModifiers");
  function Hi(t, e, r) {
    t.token("{");
    let i = t.enterDelimited();
    r(), i(), t.rightBrace(e);
  }
  s(Hi, "printBraced");
  function Rc(t, e, r) {
    var i;
    let n = /* @__PURE__ */ new Set();
    for (let a of r)
      a && n.add(a);
    (i = t.tokenMap) == null || i.find(e, (a) => {
      if (n.has(a.value))
        return t.token(a.value), t.space(), n.delete(a.value), n.size === 0;
    });
    for (let a of n)
      t.word(a), t.space();
  }
  s(Rc, "printModifiersList");
});

// ../node_modules/@babel/generator/lib/generators/index.js
var Vc = D((Ee) => {
  "use strict";
  Object.defineProperty(Ee, "__esModule", {
    value: !0
  });
  var Ra = mc();
  Object.keys(Ra).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Ee && Ee[t] === Ra[t] || Object.defineProperty(Ee, t, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return Ra[t];
      }, "get")
    });
  });
  var qa = Tc();
  Object.keys(qa).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Ee && Ee[t] === qa[t] || Object.defineProperty(Ee, t, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return qa[t];
      }, "get")
    });
  });
  var Ua = gc();
  Object.keys(Ua).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Ee && Ee[t] === Ua[t] || Object.defineProperty(Ee, t, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return Ua[t];
      }, "get")
    });
  });
  var Ka = Ec();
  Object.keys(Ka).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Ee && Ee[t] === Ka[t] || Object.defineProperty(Ee, t, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return Ka[t];
      }, "get")
    });
  });
  var Va = Pc();
  Object.keys(Va).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Ee && Ee[t] === Va[t] || Object.defineProperty(Ee, t, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return Va[t];
      }, "get")
    });
  });
  var Ya = La();
  Object.keys(Ya).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Ee && Ee[t] === Ya[t] || Object.defineProperty(Ee, t, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return Ya[t];
      }, "get")
    });
  });
  var Ja = ja();
  Object.keys(Ja).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Ee && Ee[t] === Ja[t] || Object.defineProperty(Ee, t, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return Ja[t];
      }, "get")
    });
  });
  var Xa = Mc();
  Object.keys(Xa).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Ee && Ee[t] === Xa[t] || Object.defineProperty(Ee, t, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return Xa[t];
      }, "get")
    });
  });
  var Wa = Bc();
  Object.keys(Wa).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Ee && Ee[t] === Wa[t] || Object.defineProperty(Ee, t, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return Wa[t];
      }, "get")
    });
  });
  var $a = jc();
  Object.keys($a).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Ee && Ee[t] === $a[t] || Object.defineProperty(Ee, t, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return $a[t];
      }, "get")
    });
  });
  var za = Kc();
  Object.keys(za).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Ee && Ee[t] === za[t] || Object.defineProperty(Ee, t, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return za[t];
      }, "get")
    });
  });
});

// ../node_modules/@babel/generator/lib/generators/deprecated.js
var Yc = D((Ha) => {
  "use strict";
  Object.defineProperty(Ha, "__esModule", {
    value: !0
  });
  Ha.addDeprecatedGenerators = o3;
  function o3(t) {
    {
      let e = {
        Noop() {
        },
        TSExpressionWithTypeArguments(r) {
          this.print(r.expression), this.print(r.typeParameters);
        },
        DecimalLiteral(r) {
          let i = this.getPossibleRaw(r);
          if (!this.format.minified && i !== void 0) {
            this.word(i);
            return;
          }
          this.word(r.value + "m");
        }
      };
      Object.assign(t.prototype, e);
    }
  }
  s(o3, "addDeprecatedGenerators");
});

// ../node_modules/@babel/generator/lib/printer.js
var $c = D((Gi) => {
  "use strict";
  Object.defineProperty(Gi, "__esModule", {
    value: !0
  });
  Gi.default = void 0;
  var l3 = Ho(), Xc = Ft(), u3 = Ye(), c3 = dc(), p3 = Vc(), f3 = Yc(), {
    isExpression: h3,
    isFunction: d3,
    isStatement: m3,
    isClassBody: y3,
    isTSInterfaceBody: T3,
    isTSEnumMember: S3
  } = u3, b3 = /e/i, x3 = /\.0+$/, Wc = /[\n\r\u2028\u2029]/, g3 = /[\n\r\u2028\u2029]|\*\//;
  function Jc(t) {
    return t.type === "CommentLine" || Wc.test(t.value);
  }
  s(Jc, "commentIsNewline");
  var {
    needsParens: E3
  } = Xc, Yr = class {
    static {
      s(this, "Printer");
    }
    constructor(e, r, i, n) {
      this.inForStatementInit = !1, this.tokenContext = 0, this._tokens = null, this._originalCode = null, this._currentNode = null, this._indent =
      0, this._indentRepeat = 0, this._insideAux = !1, this._noLineTerminator = !1, this._noLineTerminatorAfterNode = null, this._printAuxAfterOnNextUserNode =
      !1, this._printedComments = /* @__PURE__ */ new Set(), this._endsWithInteger = !1, this._endsWithWord = !1, this._endsWithDiv = !1, this.
      _lastCommentLine = 0, this._endsWithInnerRaw = !1, this._indentInnerComments = !0, this.tokenMap = null, this._boundGetRawIdentifier =
      this._getRawIdentifier.bind(this), this._printSemicolonBeforeNextNode = -1, this._printSemicolonBeforeNextToken = -1, this.format = e,
      this._tokens = i, this._originalCode = n, this._indentRepeat = e.indent.style.length, this._inputMap = r?._inputMap, this._buf = new l3.
      default(r, e.indent.style[0]);
    }
    enterForStatementInit() {
      return this.inForStatementInit ? () => {
      } : (this.inForStatementInit = !0, () => {
        this.inForStatementInit = !1;
      });
    }
    enterDelimited() {
      let e = this.inForStatementInit, r = this._noLineTerminatorAfterNode;
      return e === !1 && r === null ? () => {
      } : (this.inForStatementInit = !1, this._noLineTerminatorAfterNode = null, () => {
        this.inForStatementInit = e, this._noLineTerminatorAfterNode = r;
      });
    }
    generate(e) {
      return this.format.preserveFormat && (this.tokenMap = new c3.TokenMap(e, this._tokens, this._originalCode)), this.print(e), this._maybeAddAuxComment(),
      this._buf.get();
    }
    indent() {
      let {
        format: e
      } = this;
      e.preserveFormat || e.compact || e.concise || this._indent++;
    }
    dedent() {
      let {
        format: e
      } = this;
      e.preserveFormat || e.compact || e.concise || this._indent--;
    }
    semicolon(e = !1) {
      if (this._maybeAddAuxComment(), e) {
        this._appendChar(59), this._noLineTerminator = !1;
        return;
      }
      if (this.tokenMap) {
        let r = this._currentNode;
        if (r.start != null && r.end != null) {
          if (!this.tokenMap.endMatches(r, ";")) {
            this._printSemicolonBeforeNextNode = this._buf.getCurrentLine();
            return;
          }
          let i = this.tokenMap.getIndexes(this._currentNode);
          this._catchUpTo(this._tokens[i[i.length - 1]].loc.start);
        }
      }
      this._queue(59), this._noLineTerminator = !1;
    }
    rightBrace(e) {
      this.format.minified && this._buf.removeLastSemicolon(), this.sourceWithOffset("end", e.loc, -1), this.tokenChar(125);
    }
    rightParens(e) {
      this.sourceWithOffset("end", e.loc, -1), this.tokenChar(41);
    }
    space(e = !1) {
      let {
        format: r
      } = this;
      if (!(r.compact || r.preserveFormat)) {
        if (e)
          this._space();
        else if (this._buf.hasContent()) {
          let i = this.getLastChar();
          i !== 32 && i !== 10 && this._space();
        }
      }
    }
    word(e, r = !1) {
      this.tokenContext = 0, this._maybePrintInnerComments(e), this._maybeAddAuxComment(), this.tokenMap && this._catchUpToCurrentToken(e), (this.
      _endsWithWord || this._endsWithDiv && e.charCodeAt(0) === 47) && this._space(), this._append(e, !1), this._endsWithWord = !0, this._noLineTerminator =
      r;
    }
    number(e, r) {
      function i(n) {
        if (n.length > 2 && n.charCodeAt(0) === 48) {
          let a = n.charCodeAt(1);
          return a === 98 || a === 111 || a === 120;
        }
        return !1;
      }
      s(i, "isNonDecimalLiteral"), this.word(e), this._endsWithInteger = Number.isInteger(r) && !i(e) && !b3.test(e) && !x3.test(e) && e.charCodeAt(
      e.length - 1) !== 46;
    }
    token(e, r = !1, i = 0) {
      this.tokenContext = 0, this._maybePrintInnerComments(e, i), this._maybeAddAuxComment(), this.tokenMap && this._catchUpToCurrentToken(e,
      i);
      let n = this.getLastChar(), a = e.charCodeAt(0);
      (n === 33 && (e === "--" || a === 61) || a === 43 && n === 43 || a === 45 && n === 45 || a === 46 && this._endsWithInteger) && this._space(),
      this._append(e, r), this._noLineTerminator = !1;
    }
    tokenChar(e) {
      this.tokenContext = 0;
      let r = String.fromCharCode(e);
      this._maybePrintInnerComments(r), this._maybeAddAuxComment(), this.tokenMap && this._catchUpToCurrentToken(r);
      let i = this.getLastChar();
      (e === 43 && i === 43 || e === 45 && i === 45 || e === 46 && this._endsWithInteger) && this._space(), this._appendChar(e), this._noLineTerminator =
      !1;
    }
    newline(e = 1, r) {
      if (!(e <= 0)) {
        if (!r) {
          if (this.format.retainLines || this.format.compact) return;
          if (this.format.concise) {
            this.space();
            return;
          }
        }
        e > 2 && (e = 2), e -= this._buf.getNewlineCount();
        for (let i = 0; i < e; i++)
          this._newline();
      }
    }
    endsWith(e) {
      return this.getLastChar() === e;
    }
    getLastChar() {
      return this._buf.getLastChar();
    }
    endsWithCharAndNewline() {
      return this._buf.endsWithCharAndNewline();
    }
    removeTrailingNewline() {
      this._buf.removeTrailingNewline();
    }
    exactSource(e, r) {
      if (!e) {
        r();
        return;
      }
      this._catchUp("start", e), this._buf.exactSource(e, r);
    }
    source(e, r) {
      r && (this._catchUp(e, r), this._buf.source(e, r));
    }
    sourceWithOffset(e, r, i) {
      !r || this.format.preserveFormat || (this._catchUp(e, r), this._buf.sourceWithOffset(e, r, i));
    }
    sourceIdentifierName(e, r) {
      if (!this._buf._canMarkIdName) return;
      let i = this._buf._sourcePosition;
      i.identifierNamePos = r, i.identifierName = e;
    }
    _space() {
      this._queue(32);
    }
    _newline() {
      this._queue(10);
    }
    _catchUpToCurrentToken(e, r = 0) {
      let i = this.tokenMap.findMatching(this._currentNode, e, r);
      i && this._catchUpTo(i.loc.start), this._printSemicolonBeforeNextToken !== -1 && this._printSemicolonBeforeNextToken === this._buf.getCurrentLine() &&
      (this._buf.appendChar(59), this._endsWithWord = !1, this._endsWithInteger = !1, this._endsWithDiv = !1), this._printSemicolonBeforeNextToken =
      -1, this._printSemicolonBeforeNextNode = -1;
    }
    _append(e, r) {
      this._maybeIndent(e.charCodeAt(0)), this._buf.append(e, r), this._endsWithWord = !1, this._endsWithInteger = !1, this._endsWithDiv = !1;
    }
    _appendChar(e) {
      this._maybeIndent(e), this._buf.appendChar(e), this._endsWithWord = !1, this._endsWithInteger = !1, this._endsWithDiv = !1;
    }
    _queue(e) {
      this._maybeIndent(e), this._buf.queue(e), this._endsWithWord = !1, this._endsWithInteger = !1;
    }
    _maybeIndent(e) {
      this._indent && e !== 10 && this.endsWith(10) && this._buf.queueIndentation(this._getIndent());
    }
    _shouldIndent(e) {
      if (this._indent && e !== 10 && this.endsWith(10))
        return !0;
    }
    catchUp(e) {
      if (!this.format.retainLines) return;
      let r = e - this._buf.getCurrentLine();
      for (let i = 0; i < r; i++)
        this._newline();
    }
    _catchUp(e, r) {
      let {
        format: i
      } = this;
      if (!i.preserveFormat) {
        i.retainLines && r != null && r[e] && this.catchUp(r[e].line);
        return;
      }
      let n = r?.[e];
      n != null && this._catchUpTo(n);
    }
    _catchUpTo({
      line: e,
      column: r,
      index: i
    }) {
      let n = e - this._buf.getCurrentLine();
      if (n > 0 && this._noLineTerminator)
        return;
      for (let o = 0; o < n; o++)
        this._newline();
      let a = n > 0 ? r : r - this._buf.getCurrentColumn();
      if (a > 0) {
        let o = this._originalCode ? this._originalCode.slice(i - a, i).replace(/[^\t\x0B\f \xA0\u1680\u2000-\u200A\u202F\u205F\u3000\uFEFF]/gu,
        " ") : " ".repeat(a);
        this._append(o, !1);
      }
    }
    _getIndent() {
      return this._indentRepeat * this._indent;
    }
    printTerminatorless(e) {
      this._noLineTerminator = !0, this.print(e);
    }
    print(e, r, i) {
      var n, a, o;
      if (!e) return;
      this._endsWithInnerRaw = !1;
      let l = e.type, u = this.format, p = u.concise;
      e._compact && (u.concise = !0);
      let h = this[l];
      if (h === void 0)
        throw new ReferenceError(`unknown node of type ${JSON.stringify(l)} with constructor ${JSON.stringify(e.constructor.name)}`);
      let E = this._currentNode;
      this._currentNode = e, this.tokenMap && (this._printSemicolonBeforeNextToken = this._printSemicolonBeforeNextNode);
      let I = this._insideAux;
      this._insideAux = e.loc == null, this._maybeAddAuxComment(this._insideAux && !I);
      let v = (n = e.extra) == null ? void 0 : n.parenthesized, _ = v && u.preserveFormat || v && u.retainFunctionParens && l === "FunctionE\
xpression" || E3(e, E, this.tokenContext, this.inForStatementInit, u.preserveFormat ? this._boundGetRawIdentifier : void 0);
      if (!_ && v && (a = e.leadingComments) != null && a.length && e.leadingComments[0].type === "CommentBlock")
        switch (E?.type) {
          case "ExpressionStatement":
          case "VariableDeclarator":
          case "AssignmentExpression":
          case "ReturnStatement":
            break;
          case "CallExpression":
          case "OptionalCallExpression":
          case "NewExpression":
            if (E.callee !== e) break;
          default:
            _ = !0;
        }
      let j = !1;
      !_ && this._noLineTerminator && ((o = e.leadingComments) != null && o.some(Jc) || this.format.retainLines && e.loc && e.loc.start.line >
      this._buf.getCurrentLine()) && (_ = !0, j = !0);
      let O, k;
      if (!_ && (r || (r = E && this._noLineTerminatorAfterNode === E && Xc.isLastChild(E, e)), r)) {
        var B;
        (B = e.trailingComments) != null && B.some(Jc) ? h3(e) && (_ = !0) : (O = this._noLineTerminatorAfterNode, this._noLineTerminatorAfterNode =
        e);
      }
      _ && (this.tokenChar(40), j && this.indent(), this._endsWithInnerRaw = !1, this.inForStatementInit && (k = !0, this.inForStatementInit =
      !1), O = this._noLineTerminatorAfterNode, this._noLineTerminatorAfterNode = null), this._lastCommentLine = 0, this._printLeadingComments(
      e, E);
      let ue = l === "Program" || l === "File" ? null : e.loc;
      this.exactSource(ue, h.bind(this, e, E)), _ ? (this._printTrailingComments(e, E), j && (this.dedent(), this.newline()), this.tokenChar(
      41), this._noLineTerminator = r, k && (this.inForStatementInit = !0)) : r && !this._noLineTerminator ? (this._noLineTerminator = !0, this.
      _printTrailingComments(e, E)) : this._printTrailingComments(e, E, i), this._currentNode = E, u.concise = p, this._insideAux = I, O !==
      void 0 && (this._noLineTerminatorAfterNode = O), this._endsWithInnerRaw = !1;
    }
    _maybeAddAuxComment(e) {
      e && this._printAuxBeforeComment(), this._insideAux || this._printAuxAfterComment();
    }
    _printAuxBeforeComment() {
      if (this._printAuxAfterOnNextUserNode) return;
      this._printAuxAfterOnNextUserNode = !0;
      let e = this.format.auxiliaryCommentBefore;
      e && this._printComment({
        type: "CommentBlock",
        value: e
      }, 0);
    }
    _printAuxAfterComment() {
      if (!this._printAuxAfterOnNextUserNode) return;
      this._printAuxAfterOnNextUserNode = !1;
      let e = this.format.auxiliaryCommentAfter;
      e && this._printComment({
        type: "CommentBlock",
        value: e
      }, 0);
    }
    getPossibleRaw(e) {
      let r = e.extra;
      if (r?.raw != null && r.rawValue != null && e.value === r.rawValue)
        return r.raw;
    }
    printJoin(e, r, i, n, a, o, l, u) {
      if (!(e != null && e.length)) return;
      if (i == null && this.format.retainLines) {
        var p;
        let j = (p = e[0].loc) == null ? void 0 : p.start.line;
        j != null && j !== this._buf.getCurrentLine() && (i = !0);
      }
      i && this.indent();
      let h = {
        addNewlines: o,
        nextNodeStartLine: 0
      }, E = n?.bind(this), I = e.length;
      for (let j = 0; j < I; j++) {
        let O = e[j];
        if (O && (r && this._printNewline(j === 0, h), this.print(O, void 0, u || 0), l?.(O, j), E != null && (j < I - 1 ? E(j, !1) : a && E(
        j, !0)), r)) {
          var v;
          if ((v = O.trailingComments) != null && v.length || (this._lastCommentLine = 0), j + 1 === I)
            this.newline(1);
          else {
            var _;
            let k = e[j + 1];
            h.nextNodeStartLine = ((_ = k.loc) == null ? void 0 : _.start.line) || 0, this._printNewline(!0, h);
          }
        }
      }
      i && this.dedent();
    }
    printAndIndentOnComments(e) {
      let r = e.leadingComments && e.leadingComments.length > 0;
      r && this.indent(), this.print(e), r && this.dedent();
    }
    printBlock(e) {
      let r = e.body;
      r.type !== "EmptyStatement" && this.space(), this.print(r);
    }
    _printTrailingComments(e, r, i) {
      let {
        innerComments: n,
        trailingComments: a
      } = e;
      n != null && n.length && this._printComments(2, n, e, r, i), a != null && a.length && this._printComments(2, a, e, r, i);
    }
    _printLeadingComments(e, r) {
      let i = e.leadingComments;
      i != null && i.length && this._printComments(0, i, e, r);
    }
    _maybePrintInnerComments(e, r) {
      if (this._endsWithInnerRaw) {
        var i;
        this.printInnerComments((i = this.tokenMap) == null ? void 0 : i.findMatching(this._currentNode, e, r));
      }
      this._endsWithInnerRaw = !0, this._indentInnerComments = !0;
    }
    printInnerComments(e) {
      let r = this._currentNode, i = r.innerComments;
      if (!(i != null && i.length)) return;
      let n = this.endsWith(32), a = this._indentInnerComments, o = this._printedComments.size;
      a && this.indent(), this._printComments(1, i, r, void 0, void 0, e), n && o !== this._printedComments.size && this.space(), a && this.
      dedent();
    }
    noIndentInnerCommentsHere() {
      this._indentInnerComments = !1;
    }
    printSequence(e, r, i, n) {
      this.printJoin(e, !0, r ?? !1, void 0, void 0, n, void 0, i);
    }
    printList(e, r, i, n, a, o) {
      this.printJoin(e, i, n, a ?? P3, r, void 0, o);
    }
    shouldPrintTrailingComma(e) {
      if (!this.tokenMap) return null;
      let r = this.tokenMap.findLastIndex(this._currentNode, (i) => this.tokenMap.matchesOriginal(i, e));
      return r <= 0 ? null : this.tokenMap.matchesOriginal(this._tokens[r - 1], ",");
    }
    _printNewline(e, r) {
      let i = this.format;
      if (i.retainLines || i.compact) return;
      if (i.concise) {
        this.space();
        return;
      }
      if (!e)
        return;
      let n = r.nextNodeStartLine, a = this._lastCommentLine;
      if (n > 0 && a > 0) {
        let o = n - a;
        if (o >= 0) {
          this.newline(o || 1);
          return;
        }
      }
      this._buf.hasContent() && this.newline(1);
    }
    _shouldPrintComment(e, r) {
      if (e.ignore || this._printedComments.has(e)) return 0;
      if (this._noLineTerminator && g3.test(e.value))
        return 2;
      if (r && this.tokenMap) {
        let i = this.tokenMap.find(this._currentNode, (n) => n.value === e.value);
        if (i && i.start > r.start)
          return 2;
      }
      return this._printedComments.add(e), this.format.shouldPrintComment(e.value) ? 1 : 0;
    }
    _printComment(e, r) {
      let i = this._noLineTerminator, n = e.type === "CommentBlock", a = n && r !== 1 && !this._noLineTerminator;
      a && this._buf.hasContent() && r !== 2 && this.newline(1);
      let o = this.getLastChar();
      o !== 91 && o !== 123 && o !== 40 && this.space();
      let l;
      if (n) {
        if (l = `/*${e.value}*/`, this.format.indent.adjustMultilineComment) {
          var u;
          let p = (u = e.loc) == null ? void 0 : u.start.column;
          if (p) {
            let h = new RegExp("\\n\\s{1," + p + "}", "g");
            l = l.replace(h, `
`);
          }
          if (this.format.concise)
            l = l.replace(/\n(?!$)/g, `
`);
          else {
            let h = this.format.retainLines ? 0 : this._buf.getCurrentColumn();
            (this._shouldIndent(47) || this.format.retainLines) && (h += this._getIndent()), l = l.replace(/\n(?!$)/g, `
${" ".repeat(h)}`);
          }
        }
      } else i ? l = `/*${e.value}*/` : l = `//${e.value}`;
      if (this._endsWithDiv && this._space(), this.tokenMap) {
        let {
          _printSemicolonBeforeNextToken: p,
          _printSemicolonBeforeNextNode: h
        } = this;
        this._printSemicolonBeforeNextToken = -1, this._printSemicolonBeforeNextNode = -1, this.source("start", e.loc), this._append(l, n), this.
        _printSemicolonBeforeNextNode = h, this._printSemicolonBeforeNextToken = p;
      } else
        this.source("start", e.loc), this._append(l, n);
      !n && !i && this.newline(1, !0), a && r !== 3 && this.newline(1);
    }
    _printComments(e, r, i, n, a = 0, o) {
      let l = i.loc, u = r.length, p = !!l, h = p ? l.start.line : 0, E = p ? l.end.line : 0, I = 0, v = 0, _ = this._noLineTerminator ? function() {
      } : this.newline.bind(this);
      for (let j = 0; j < u; j++) {
        let O = r[j], k = this._shouldPrintComment(O, o);
        if (k === 2) {
          p = !1;
          break;
        }
        if (p && O.loc && k === 1) {
          let B = O.loc.start.line, ue = O.loc.end.line;
          if (e === 0) {
            let K = 0;
            j === 0 ? this._buf.hasContent() && (O.type === "CommentLine" || B !== ue) && (K = v = 1) : K = B - I, I = ue, _(K), this._printComment(
            O, 1), j + 1 === u && (_(Math.max(h - I, v)), I = h);
          } else if (e === 1) {
            let K = B - (j === 0 ? h : I);
            I = ue, _(K), this._printComment(O, 1), j + 1 === u && (_(Math.min(1, E - I)), I = E);
          } else {
            let K = B - (j === 0 ? E - a : I);
            I = ue, _(K), this._printComment(O, 1);
          }
        } else {
          if (p = !1, k !== 1)
            continue;
          if (u === 1) {
            let B = O.loc ? O.loc.start.line === O.loc.end.line : !Wc.test(O.value), ue = B && !m3(i) && !y3(n) && !T3(n) && !S3(i);
            e === 0 ? this._printComment(O, ue && i.type !== "ObjectExpression" || B && d3(n, {
              body: i
            }) ? 1 : 0) : ue && e === 2 ? this._printComment(O, 1) : this._printComment(O, 0);
          } else e === 1 && !(i.type === "ObjectExpression" && i.properties.length > 1) && i.type !== "ClassBody" && i.type !== "TSInterface\
Body" ? this._printComment(O, j === 0 ? 2 : j === u - 1 ? 3 : 0) : this._printComment(O, 0);
        }
      }
      e === 2 && p && I && (this._lastCommentLine = I);
    }
  };
  Object.assign(Yr.prototype, p3);
  (0, f3.addDeprecatedGenerators)(Yr);
  var B6 = Gi.default = Yr;
  function P3(t, e) {
    this.token(",", !1, t), e || this.space();
  }
  s(P3, "commaSeparator");
});

// ../node_modules/@babel/generator/lib/index.js
var Zc = D((hr) => {
  "use strict";
  Object.defineProperty(hr, "__esModule", {
    value: !0
  });
  hr.default = void 0;
  hr.generate = Qc;
  var zc = zo(), Hc = $c();
  function Gc(t, e, r) {
    if (e.experimental_preserveFormat) {
      if (typeof t != "string")
        throw new Error("`experimental_preserveFormat` requires the original `code` to be passed to @babel/generator as a string");
      if (!e.retainLines)
        throw new Error("`experimental_preserveFormat` requires `retainLines` to be set to `true`");
      if (e.compact && e.compact !== "auto")
        throw new Error("`experimental_preserveFormat` is not compatible with the `compact` option");
      if (e.minified)
        throw new Error("`experimental_preserveFormat` is not compatible with the `minified` option");
      if (e.jsescOption)
        throw new Error("`experimental_preserveFormat` is not compatible with the `jsescOption` option");
      if (!Array.isArray(r.tokens))
        throw new Error("`experimental_preserveFormat` requires the AST to have attatched the token of the input code. Make sure to enable t\
he `tokens: true` parser option.");
    }
    let i = {
      auxiliaryCommentBefore: e.auxiliaryCommentBefore,
      auxiliaryCommentAfter: e.auxiliaryCommentAfter,
      shouldPrintComment: e.shouldPrintComment,
      preserveFormat: e.experimental_preserveFormat,
      retainLines: e.retainLines,
      retainFunctionParens: e.retainFunctionParens,
      comments: e.comments == null || e.comments,
      compact: e.compact,
      minified: e.minified,
      concise: e.concise,
      indent: {
        adjustMultilineComment: !0,
        style: "  "
      },
      jsescOption: Object.assign({
        quotes: "double",
        wrap: !0,
        minimal: !1
      }, e.jsescOption),
      topicToken: e.topicToken,
      importAttributesKeyword: e.importAttributesKeyword
    };
    {
      var n;
      i.decoratorsBeforeExport = e.decoratorsBeforeExport, i.jsescOption.json = e.jsonCompatibleStrings, i.recordAndTupleSyntaxType = (n = e.
      recordAndTupleSyntaxType) != null ? n : "hash";
    }
    i.minified ? (i.compact = !0, i.shouldPrintComment = i.shouldPrintComment || (() => i.comments)) : i.shouldPrintComment = i.shouldPrintComment ||
    ((u) => i.comments || u.includes("@license") || u.includes("@preserve")), i.compact === "auto" && (i.compact = typeof t == "string" && t.
    length > 5e5, i.compact && console.error(`[BABEL] Note: The code generator has deoptimised the styling of ${e.filename} as it exceeds th\
e max of 500KB.`)), (i.compact || i.preserveFormat) && (i.indent.adjustMultilineComment = !1);
    let {
      auxiliaryCommentBefore: a,
      auxiliaryCommentAfter: o,
      shouldPrintComment: l
    } = i;
    return a && !l(a) && (i.auxiliaryCommentBefore = void 0), o && !l(o) && (i.auxiliaryCommentAfter = void 0), i;
  }
  s(Gc, "normalizeOptions");
  hr.CodeGenerator = class {
    static {
      s(this, "CodeGenerator");
    }
    constructor(e, r = {}, i) {
      this._ast = void 0, this._format = void 0, this._map = void 0, this._ast = e, this._format = Gc(i, r, e), this._map = r.sourceMaps ? new zc.
      default(r, i) : null;
    }
    generate() {
      return new Hc.default(this._format, this._map).generate(this._ast);
    }
  };
  function Qc(t, e = {}, r) {
    let i = Gc(r, e, t), n = e.sourceMaps ? new zc.default(e, r) : null;
    return new Hc.default(i, n, t.tokens, typeof r == "string" ? r : null).generate(t);
  }
  s(Qc, "generate");
  var q6 = hr.default = Qc;
});

// ../node_modules/@babel/parser/lib/index.js
var Op = D((ei) => {
  "use strict";
  Object.defineProperty(ei, "__esModule", {
    value: !0
  });
  function A3(t, e) {
    if (t == null) return {};
    var r = {};
    for (var i in t) if ({}.hasOwnProperty.call(t, i)) {
      if (e.indexOf(i) !== -1) continue;
      r[i] = t[i];
    }
    return r;
  }
  s(A3, "_objectWithoutPropertiesLoose");
  var Et = class {
    static {
      s(this, "Position");
    }
    constructor(e, r, i) {
      this.line = void 0, this.column = void 0, this.index = void 0, this.line = e, this.column = r, this.index = i;
    }
  }, Sr = class {
    static {
      s(this, "SourceLocation");
    }
    constructor(e, r) {
      this.start = void 0, this.end = void 0, this.filename = void 0, this.identifierName = void 0, this.start = e, this.end = r;
    }
  };
  function Ze(t, e) {
    let {
      line: r,
      column: i,
      index: n
    } = t;
    return new Et(r, i + e, n + e);
  }
  s(Ze, "createPositionWithColumnOffset");
  var ep = "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED", I3 = {
    ImportMetaOutsideModule: {
      message: `import.meta may appear only with 'sourceType: "module"'`,
      code: ep
    },
    ImportOutsideModule: {
      message: `'import' and 'export' may appear only with 'sourceType: "module"'`,
      code: ep
    }
  }, tp = {
    ArrayPattern: "array destructuring pattern",
    AssignmentExpression: "assignment expression",
    AssignmentPattern: "assignment expression",
    ArrowFunctionExpression: "arrow function expression",
    ConditionalExpression: "conditional expression",
    CatchClause: "catch clause",
    ForOfStatement: "for-of statement",
    ForInStatement: "for-in statement",
    ForStatement: "for-loop",
    FormalParameters: "function parameter list",
    Identifier: "identifier",
    ImportSpecifier: "import specifier",
    ImportDefaultSpecifier: "import default specifier",
    ImportNamespaceSpecifier: "import namespace specifier",
    ObjectPattern: "object destructuring pattern",
    ParenthesizedExpression: "parenthesized expression",
    RestElement: "rest element",
    UpdateExpression: {
      true: "prefix operation",
      false: "postfix operation"
    },
    VariableDeclarator: "variable declaration",
    YieldExpression: "yield expression"
  }, es = /* @__PURE__ */ s((t) => t.type === "UpdateExpression" ? tp.UpdateExpression[`${t.prefix}`] : tp[t.type], "toNodeDescription"), v3 = {
    AccessorIsGenerator: /* @__PURE__ */ s(({
      kind: t
    }) => `A ${t}ter cannot be a generator.`, "AccessorIsGenerator"),
    ArgumentsInClass: "'arguments' is only allowed in functions and class methods.",
    AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.",
    AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.",
    AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.",
    AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.",
    AwaitUsingNotInAsyncContext: "'await using' is only allowed within async functions and at the top levels of modules.",
    AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.",
    BadGetterArity: "A 'get' accessor must not have any formal parameters.",
    BadSetterArity: "A 'set' accessor must have exactly one formal parameter.",
    BadSetterRestParameter: "A 'set' accessor function argument must not be a rest parameter.",
    ConstructorClassField: "Classes may not have a field named 'constructor'.",
    ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.",
    ConstructorIsAccessor: "Class constructor may not be an accessor.",
    ConstructorIsAsync: "Constructor can't be an async function.",
    ConstructorIsGenerator: "Constructor can't be a generator.",
    DeclarationMissingInitializer: /* @__PURE__ */ s(({
      kind: t
    }) => `Missing initializer in ${t} declaration.`, "DeclarationMissingInitializer"),
    DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(deco\
rator)(args)'.",
    DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use\
 the 'export @decorator class {}' syntax.",
    DecoratorsBeforeAfterExport: "Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the s\
ame time.",
    DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
    DecoratorExportClass: "Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use \
the '@decorator export class {}' syntax.",
    DecoratorSemicolon: "Decorators must not be followed by a semicolon.",
    DecoratorStaticBlock: "Decorators can't be used with a static block.",
    DeferImportRequiresNamespace: 'Only `import defer * as x from "./module"` is valid.',
    DeletePrivateField: "Deleting a private field is not allowed.",
    DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",
    DuplicateConstructor: "Duplicate constructor in the same class.",
    DuplicateDefaultExport: "Only one default export allowed per module.",
    DuplicateExport: /* @__PURE__ */ s(({
      exportName: t
    }) => `\`${t}\` has already been exported. Exported identifiers must be unique.`, "DuplicateExport"),
    DuplicateProto: "Redefinition of __proto__ property.",
    DuplicateRegExpFlags: "Duplicate regular expression flag.",
    DynamicImportPhaseRequiresImportExpressions: /* @__PURE__ */ s(({
      phase: t
    }) => `'import.${t}(...)' can only be parsed when using the 'createImportExpressions' option.`, "DynamicImportPhaseRequiresImportExpress\
ions"),
    ElementAfterRest: "Rest element must be last element.",
    EscapedCharNotAnIdentifier: "Invalid Unicode escape.",
    ExportBindingIsString: /* @__PURE__ */ s(({
      localName: t,
      exportName: e
    }) => `A string literal cannot be used as an exported binding without \`from\`.
- Did you mean \`export { '${t}' as '${e}' } from 'some-module'\`?`, "ExportBindingIsString"),
    ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.",
    ForInOfLoopInitializer: /* @__PURE__ */ s(({
      type: t
    }) => `'${t === "ForInStatement" ? "for-in" : "for-of"}' loop variable declaration may not have an initializer.`, "ForInOfLoopInitialize\
r"),
    ForInUsing: "For-in loop may not start with 'using' declaration.",
    ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.",
    ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.",
    GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.",
    IllegalBreakContinue: /* @__PURE__ */ s(({
      type: t
    }) => `Unsyntactic ${t === "BreakStatement" ? "break" : "continue"}.`, "IllegalBreakContinue"),
    IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.",
    IllegalReturn: "'return' outside of function.",
    ImportAttributesUseAssert: "The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You \
can enable the `deprecatedImportAssert` parser plugin to suppress this error.",
    ImportBindingIsString: /* @__PURE__ */ s(({
      importName: t
    }) => `A string literal cannot be used as an imported binding.
- Did you mean \`import { "${t}" as foo }\`?`, "ImportBindingIsString"),
    ImportCallArity: "`import()` requires exactly one or two arguments.",
    ImportCallNotNewExpression: "Cannot use new with import(...).",
    ImportCallSpreadArgument: "`...` is not allowed in `import()`.",
    ImportJSONBindingNotDefault: "A JSON module can only be imported with `default`.",
    ImportReflectionHasAssertion: "`import module x` cannot have assertions.",
    ImportReflectionNotBinding: 'Only `import module x from "./module"` is valid.',
    IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.",
    InvalidBigIntLiteral: "Invalid BigIntLiteral.",
    InvalidCodePoint: "Code point out of bounds.",
    InvalidCoverInitializedName: "Invalid shorthand property initializer.",
    InvalidDecimal: "Invalid decimal.",
    InvalidDigit: /* @__PURE__ */ s(({
      radix: t
    }) => `Expected number in radix ${t}.`, "InvalidDigit"),
    InvalidEscapeSequence: "Bad character escape sequence.",
    InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.",
    InvalidEscapedReservedWord: /* @__PURE__ */ s(({
      reservedWord: t
    }) => `Escape sequence in keyword ${t}.`, "InvalidEscapedReservedWord"),
    InvalidIdentifier: /* @__PURE__ */ s(({
      identifierName: t
    }) => `Invalid identifier ${t}.`, "InvalidIdentifier"),
    InvalidLhs: /* @__PURE__ */ s(({
      ancestor: t
    }) => `Invalid left-hand side in ${es(t)}.`, "InvalidLhs"),
    InvalidLhsBinding: /* @__PURE__ */ s(({
      ancestor: t
    }) => `Binding invalid left-hand side in ${es(t)}.`, "InvalidLhsBinding"),
    InvalidLhsOptionalChaining: /* @__PURE__ */ s(({
      ancestor: t
    }) => `Invalid optional chaining in the left-hand side of ${es(t)}.`, "InvalidLhsOptionalChaining"),
    InvalidNumber: "Invalid number.",
    InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.",
    InvalidOrUnexpectedToken: /* @__PURE__ */ s(({
      unexpected: t
    }) => `Unexpected character '${t}'.`, "InvalidOrUnexpectedToken"),
    InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.",
    InvalidPrivateFieldResolution: /* @__PURE__ */ s(({
      identifierName: t
    }) => `Private name #${t} is not defined.`, "InvalidPrivateFieldResolution"),
    InvalidPropertyBindingPattern: "Binding member expression.",
    InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.",
    InvalidRestAssignmentPattern: "Invalid rest operator's argument.",
    LabelRedeclaration: /* @__PURE__ */ s(({
      labelName: t
    }) => `Label '${t}' is already declared.`, "LabelRedeclaration"),
    LetInLexicalBinding: "'let' is disallowed as a lexically bound name.",
    LineTerminatorBeforeArrow: "No line break is allowed before '=>'.",
    MalformedRegExpFlags: "Invalid regular expression flag.",
    MissingClassName: "A class name is required.",
    MissingEqInAssignment: "Only '=' operator can be used for specifying default value.",
    MissingSemicolon: "Missing semicolon.",
    MissingPlugin: /* @__PURE__ */ s(({
      missingPlugin: t
    }) => `This experimental syntax requires enabling the parser plugin: ${t.map((e) => JSON.stringify(e)).join(", ")}.`, "MissingPlugin"),
    MissingOneOfPlugins: /* @__PURE__ */ s(({
      missingPlugin: t
    }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${t.map((e) => JSON.stringify(e)).join(", ")}.`,
    "MissingOneOfPlugins"),
    MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.",
    MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.",
    ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.",
    ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.",
    ModuleAttributesWithDuplicateKeys: /* @__PURE__ */ s(({
      key: t
    }) => `Duplicate key "${t}" is not allowed in module attributes.`, "ModuleAttributesWithDuplicateKeys"),
    ModuleExportNameHasLoneSurrogate: /* @__PURE__ */ s(({
      surrogateCharCode: t
    }) => `An export name cannot include a lone surrogate, found '\\u${t.toString(16)}'.`, "ModuleExportNameHasLoneSurrogate"),
    ModuleExportUndefined: /* @__PURE__ */ s(({
      localName: t
    }) => `Export '${t}' is not defined.`, "ModuleExportUndefined"),
    MultipleDefaultsInSwitch: "Multiple default clauses.",
    NewlineAfterThrow: "Illegal newline after throw.",
    NoCatchOrFinally: "Missing catch or finally clause.",
    NumberIdentifier: "Identifier directly after number.",
    NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.",
    ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.",
    OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.",
    OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.",
    OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.",
    ParamDupe: "Argument name clash.",
    PatternHasAccessor: "Object pattern can't contain getter or setter.",
    PatternHasMethod: "Object pattern can't contain methods.",
    PrivateInExpectedIn: /* @__PURE__ */ s(({
      identifierName: t
    }) => `Private names are only allowed in property accesses (\`obj.#${t}\`) or in \`in\` expressions (\`#${t} in obj\`).`, "PrivateInExpe\
ctedIn"),
    PrivateNameRedeclaration: /* @__PURE__ */ s(({
      identifierName: t
    }) => `Duplicate private name #${t}.`, "PrivateNameRedeclaration"),
    RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 're\
cordAndTuple' plugin is set to 'bar'.",
    RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the\
 'recordAndTuple' plugin is set to 'bar'.",
    RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of th\
e 'recordAndTuple' plugin is set to 'hash'.",
    RecordNoProto: "'__proto__' is not allowed in Record expressions.",
    RestTrailingComma: "Unexpected trailing comma after rest element.",
    SloppyFunction: "In non-strict mode code, functions can only be declared at top level or inside a block.",
    SloppyFunctionAnnexB: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if sta\
tement.",
    SourcePhaseImportRequiresDefault: 'Only `import source x from "./module"` is valid.',
    StaticPrototype: "Classes may not have static property named prototype.",
    SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or n\
ot extending another class?",
    SuperPrivateField: "Private fields can't be accessed on super.",
    TrailingDecorator: "Decorators must be attached to a class element.",
    TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'reco\
rdAndTuple' plugin is set to 'bar'.",
    TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the '\
recordAndTuple' plugin is set to 'bar'.",
    TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the \
'recordAndTuple' plugin is set to 'hash'.",
    UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.",
    UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.',
    UnexpectedDigitAfterHash: "Unexpected digit after hash token.",
    UnexpectedImportExport: "'import' and 'export' may only appear at the top level.",
    UnexpectedKeyword: /* @__PURE__ */ s(({
      keyword: t
    }) => `Unexpected keyword '${t}'.`, "UnexpectedKeyword"),
    UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.",
    UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.",
    UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.",
    UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.",
    UnexpectedPrivateField: "Unexpected private name.",
    UnexpectedReservedWord: /* @__PURE__ */ s(({
      reservedWord: t
    }) => `Unexpected reserved word '${t}'.`, "UnexpectedReservedWord"),
    UnexpectedSuper: "'super' is only allowed in object methods and classes.",
    UnexpectedToken: /* @__PURE__ */ s(({
      expected: t,
      unexpected: e
    }) => `Unexpected token${e ? ` '${e}'.` : ""}${t ? `, expected "${t}"` : ""}`, "UnexpectedToken"),
    UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",
    UnexpectedUsingDeclaration: "Using declaration cannot appear in the top level when source type is `script`.",
    UnsupportedBind: "Binding should be performed on object property.",
    UnsupportedDecoratorExport: "A decorated export must export a class declaration.",
    UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.",
    UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.",
    UnsupportedMetaProperty: /* @__PURE__ */ s(({
      target: t,
      onlyValidPropertyName: e
    }) => `The only valid meta property for ${t} is ${t}.${e}.`, "UnsupportedMetaProperty"),
    UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.",
    UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.",
    UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).",
    UnterminatedComment: "Unterminated comment.",
    UnterminatedRegExp: "Unterminated regular expression.",
    UnterminatedString: "Unterminated string constant.",
    UnterminatedTemplate: "Unterminated template.",
    UsingDeclarationExport: "Using declaration cannot be exported.",
    UsingDeclarationHasBindingPattern: "Using declaration cannot have destructuring patterns.",
    VarRedeclaration: /* @__PURE__ */ s(({
      identifierName: t
    }) => `Identifier '${t}' has already been declared.`, "VarRedeclaration"),
    YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.",
    YieldInParameter: "Yield expression is not allowed in formal parameters.",
    YieldNotInGeneratorFunction: "'yield' is only allowed within generator functions.",
    ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0."
  }, C3 = {
    StrictDelete: "Deleting local variable in strict mode.",
    StrictEvalArguments: /* @__PURE__ */ s(({
      referenceName: t
    }) => `Assigning to '${t}' in strict mode.`, "StrictEvalArguments"),
    StrictEvalArgumentsBinding: /* @__PURE__ */ s(({
      bindingName: t
    }) => `Binding '${t}' in strict mode.`, "StrictEvalArgumentsBinding"),
    StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.",
    StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.",
    StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.",
    StrictWith: "'with' in strict mode."
  }, w3 = /* @__PURE__ */ new Set(["ArrowFunctionExpression", "AssignmentExpression", "ConditionalExpression", "YieldExpression"]), N3 = Object.
  assign({
    PipeBodyIsTighter: "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due \
to its loose operator precedence.",
    PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" opt\
ion.',
    PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.",
    PipeTopicUnconfiguredToken: /* @__PURE__ */ s(({
      token: t
    }) => `Invalid topic token ${t}. In order to use ${t} as a topic reference, the pipelineOperator plugin must be configured with { "propo\
sal": "hack", "topicToken": "${t}" }.`, "PipeTopicUnconfiguredToken"),
    PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.",
    PipeUnparenthesizedBody: /* @__PURE__ */ s(({
      type: t
    }) => `Hack-style pipe body cannot be an unparenthesized ${es({
      type: t
    })}; please wrap it in parentheses.`, "PipeUnparenthesizedBody")
  }, {
    PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.',
    PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.",
    PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.",
    PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.",
    PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.",
    PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "sma\
rt" option.'
  }), O3 = ["message"];
  function rp(t, e, r) {
    Object.defineProperty(t, e, {
      enumerable: !1,
      configurable: !0,
      value: r
    });
  }
  s(rp, "defineHidden");
  function _3({
    toMessage: t,
    code: e,
    reasonCode: r,
    syntaxPlugin: i
  }) {
    let n = r === "MissingPlugin" || r === "MissingOneOfPlugins";
    {
      let a = {
        AccessorCannotDeclareThisParameter: "AccesorCannotDeclareThisParameter",
        AccessorCannotHaveTypeParameters: "AccesorCannotHaveTypeParameters",
        ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference: "ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumRefer\
ence",
        SetAccessorCannotHaveOptionalParameter: "SetAccesorCannotHaveOptionalParameter",
        SetAccessorCannotHaveRestParameter: "SetAccesorCannotHaveRestParameter",
        SetAccessorCannotHaveReturnType: "SetAccesorCannotHaveReturnType"
      };
      a[r] && (r = a[r]);
    }
    return /* @__PURE__ */ s(function a(o, l) {
      let u = new SyntaxError();
      return u.code = e, u.reasonCode = r, u.loc = o, u.pos = o.index, u.syntaxPlugin = i, n && (u.missingPlugin = l.missingPlugin), rp(u, "\
clone", /* @__PURE__ */ s(function(h = {}) {
        var E;
        let {
          line: I,
          column: v,
          index: _
        } = (E = h.loc) != null ? E : o;
        return a(new Et(I, v, _), Object.assign({}, l, h.details));
      }, "clone")), rp(u, "details", l), Object.defineProperty(u, "message", {
        configurable: !0,
        get() {
          let p = `${t(l)} (${o.line}:${o.column})`;
          return this.message = p, p;
        },
        set(p) {
          Object.defineProperty(this, "message", {
            value: p,
            writable: !0
          });
        }
      }), u;
    }, "constructor");
  }
  s(_3, "toParseErrorConstructor");
  function _t(t, e) {
    if (Array.isArray(t))
      return (i) => _t(i, t[0]);
    let r = {};
    for (let i of Object.keys(t)) {
      let n = t[i], a = typeof n == "string" ? {
        message: /* @__PURE__ */ s(() => n, "message")
      } : typeof n == "function" ? {
        message: n
      } : n, {
        message: o
      } = a, l = A3(a, O3), u = typeof o == "string" ? () => o : o;
      r[i] = _3(Object.assign({
        code: "BABEL_PARSER_SYNTAX_ERROR",
        reasonCode: i,
        toMessage: u
      }, e ? {
        syntaxPlugin: e
      } : {}, l));
    }
    return r;
  }
  s(_t, "ParseErrorEnum");
  var g = Object.assign({}, _t(I3), _t(v3), _t(C3), _t`pipelineOperator`(N3));
  function D3() {
    return {
      sourceType: "script",
      sourceFilename: void 0,
      startIndex: 0,
      startColumn: 0,
      startLine: 1,
      allowAwaitOutsideFunction: !1,
      allowReturnOutsideFunction: !1,
      allowNewTargetOutsideFunction: !1,
      allowImportExportEverywhere: !1,
      allowSuperOutsideMethod: !1,
      allowUndeclaredExports: !1,
      allowYieldOutsideFunction: !1,
      plugins: [],
      strictMode: null,
      ranges: !1,
      tokens: !1,
      createImportExpressions: !1,
      createParenthesizedExpressions: !1,
      errorRecovery: !1,
      attachComment: !0,
      annexB: !0
    };
  }
  s(D3, "createDefaultOptions");
  function k3(t) {
    let e = D3();
    if (t == null)
      return e;
    if (t.annexB != null && t.annexB !== !1)
      throw new Error("The `annexB` option can only be set to `false`.");
    for (let r of Object.keys(e))
      t[r] != null && (e[r] = t[r]);
    if (e.startLine === 1)
      t.startIndex == null && e.startColumn > 0 ? e.startIndex = e.startColumn : t.startColumn == null && e.startIndex > 0 && (e.startColumn =
      e.startIndex);
    else if ((t.startColumn == null || t.startIndex == null) && t.startIndex != null)
      throw new Error("With a `startLine > 1` you must also specify `startIndex` and `startColumn`.");
    return e;
  }
  s(k3, "getOptions");
  var {
    defineProperty: L3
  } = Object, ip = /* @__PURE__ */ s((t, e) => {
    t && L3(t, e, {
      enumerable: !1,
      value: t[e]
    });
  }, "toUnenumerable");
  function Jr(t) {
    return ip(t.loc.start, "index"), ip(t.loc.end, "index"), t;
  }
  s(Jr, "toESTreeLocation");
  var M3 = /* @__PURE__ */ s((t) => class extends t {
    static {
      s(this, "ESTreeParserMixin");
    }
    parse() {
      let r = Jr(super.parse());
      return this.optionFlags & 256 && (r.tokens = r.tokens.map(Jr)), r;
    }
    parseRegExpLiteral({
      pattern: r,
      flags: i
    }) {
      let n = null;
      try {
        n = new RegExp(r, i);
      } catch {
      }
      let a = this.estreeParseLiteral(n);
      return a.regex = {
        pattern: r,
        flags: i
      }, a;
    }
    parseBigIntLiteral(r) {
      let i;
      try {
        i = BigInt(r);
      } catch {
        i = null;
      }
      let n = this.estreeParseLiteral(i);
      return n.bigint = String(n.value || r), n;
    }
    parseDecimalLiteral(r) {
      let n = this.estreeParseLiteral(null);
      return n.decimal = String(n.value || r), n;
    }
    estreeParseLiteral(r) {
      return this.parseLiteral(r, "Literal");
    }
    parseStringLiteral(r) {
      return this.estreeParseLiteral(r);
    }
    parseNumericLiteral(r) {
      return this.estreeParseLiteral(r);
    }
    parseNullLiteral() {
      return this.estreeParseLiteral(null);
    }
    parseBooleanLiteral(r) {
      return this.estreeParseLiteral(r);
    }
    directiveToStmt(r) {
      let i = r.value;
      delete r.value, i.type = "Literal", i.raw = i.extra.raw, i.value = i.extra.expressionValue;
      let n = r;
      return n.type = "ExpressionStatement", n.expression = i, n.directive = i.extra.rawValue, delete i.extra, n;
    }
    initFunction(r, i) {
      super.initFunction(r, i), r.expression = !1;
    }
    checkDeclaration(r) {
      r != null && this.isObjectProperty(r) ? this.checkDeclaration(r.value) : super.checkDeclaration(r);
    }
    getObjectOrClassMethodParams(r) {
      return r.value.params;
    }
    isValidDirective(r) {
      var i;
      return r.type === "ExpressionStatement" && r.expression.type === "Literal" && typeof r.expression.value == "string" && !((i = r.expression.
      extra) != null && i.parenthesized);
    }
    parseBlockBody(r, i, n, a, o) {
      super.parseBlockBody(r, i, n, a, o);
      let l = r.directives.map((u) => this.directiveToStmt(u));
      r.body = l.concat(r.body), delete r.directives;
    }
    parsePrivateName() {
      let r = super.parsePrivateName();
      return this.getPluginOption("estree", "classFeatures") ? this.convertPrivateNameToPrivateIdentifier(r) : r;
    }
    convertPrivateNameToPrivateIdentifier(r) {
      let i = super.getPrivateNameSV(r);
      return r = r, delete r.id, r.name = i, r.type = "PrivateIdentifier", r;
    }
    isPrivateName(r) {
      return this.getPluginOption("estree", "classFeatures") ? r.type === "PrivateIdentifier" : super.isPrivateName(r);
    }
    getPrivateNameSV(r) {
      return this.getPluginOption("estree", "classFeatures") ? r.name : super.getPrivateNameSV(r);
    }
    parseLiteral(r, i) {
      let n = super.parseLiteral(r, i);
      return n.raw = n.extra.raw, delete n.extra, n;
    }
    parseFunctionBody(r, i, n = !1) {
      super.parseFunctionBody(r, i, n), r.expression = r.body.type !== "BlockStatement";
    }
    parseMethod(r, i, n, a, o, l, u = !1) {
      let p = this.startNode();
      p.kind = r.kind, p = super.parseMethod(p, i, n, a, o, l, u), p.type = "FunctionExpression", delete p.kind, r.value = p;
      let {
        typeParameters: h
      } = r;
      return h && (delete r.typeParameters, p.typeParameters = h, this.resetStartLocationFromNode(p, h)), l === "ClassPrivateMethod" && (r.computed =
      !1), this.finishNode(r, "MethodDefinition");
    }
    nameIsConstructor(r) {
      return r.type === "Literal" ? r.value === "constructor" : super.nameIsConstructor(r);
    }
    parseClassProperty(...r) {
      let i = super.parseClassProperty(...r);
      return this.getPluginOption("estree", "classFeatures") && (i.type = "PropertyDefinition"), i;
    }
    parseClassPrivateProperty(...r) {
      let i = super.parseClassPrivateProperty(...r);
      return this.getPluginOption("estree", "classFeatures") && (i.type = "PropertyDefinition", i.computed = !1), i;
    }
    parseClassAccessorProperty(r) {
      let i = super.parseClassAccessorProperty(r);
      return this.getPluginOption("estree", "classFeatures") && (i.type = "AccessorProperty"), i;
    }
    parseObjectMethod(r, i, n, a, o) {
      let l = super.parseObjectMethod(r, i, n, a, o);
      return l && (l.type = "Property", l.kind === "method" && (l.kind = "init"), l.shorthand = !1), l;
    }
    parseObjectProperty(r, i, n, a) {
      let o = super.parseObjectProperty(r, i, n, a);
      return o && (o.kind = "init", o.type = "Property"), o;
    }
    isValidLVal(r, i, n) {
      return r === "Property" ? "value" : super.isValidLVal(r, i, n);
    }
    isAssignable(r, i) {
      return r != null && this.isObjectProperty(r) ? this.isAssignable(r.value, i) : super.isAssignable(r, i);
    }
    toAssignable(r, i = !1) {
      if (r != null && this.isObjectProperty(r)) {
        let {
          key: n,
          value: a
        } = r;
        this.isPrivateName(n) && this.classScope.usePrivateName(this.getPrivateNameSV(n), n.loc.start), this.toAssignable(a, i);
      } else
        super.toAssignable(r, i);
    }
    toAssignableObjectExpressionProp(r, i, n) {
      r.type === "Property" && (r.kind === "get" || r.kind === "set") ? this.raise(g.PatternHasAccessor, r.key) : r.type === "Property" && r.
      method ? this.raise(g.PatternHasMethod, r.key) : super.toAssignableObjectExpressionProp(r, i, n);
    }
    finishCallExpression(r, i) {
      let n = super.finishCallExpression(r, i);
      if (n.callee.type === "Import") {
        var a, o;
        n.type = "ImportExpression", n.source = n.arguments[0], n.options = (a = n.arguments[1]) != null ? a : null, n.attributes = (o = n.arguments[1]) !=
        null ? o : null, delete n.arguments, delete n.callee;
      }
      return n;
    }
    toReferencedArguments(r) {
      r.type !== "ImportExpression" && super.toReferencedArguments(r);
    }
    parseExport(r, i) {
      let n = this.state.lastTokStartLoc, a = super.parseExport(r, i);
      switch (a.type) {
        case "ExportAllDeclaration":
          a.exported = null;
          break;
        case "ExportNamedDeclaration":
          a.specifiers.length === 1 && a.specifiers[0].type === "ExportNamespaceSpecifier" && (a.type = "ExportAllDeclaration", a.exported =
          a.specifiers[0].exported, delete a.specifiers);
        case "ExportDefaultDeclaration":
          {
            var o;
            let {
              declaration: l
            } = a;
            l?.type === "ClassDeclaration" && ((o = l.decorators) == null ? void 0 : o.length) > 0 && l.start === a.start && this.resetStartLocation(
            a, n);
          }
          break;
      }
      return a;
    }
    parseSubscript(r, i, n, a) {
      let o = super.parseSubscript(r, i, n, a);
      if (a.optionalChainMember) {
        if ((o.type === "OptionalMemberExpression" || o.type === "OptionalCallExpression") && (o.type = o.type.substring(8)), a.stop) {
          let l = this.startNodeAtNode(o);
          return l.expression = o, this.finishNode(l, "ChainExpression");
        }
      } else (o.type === "MemberExpression" || o.type === "CallExpression") && (o.optional = !1);
      return o;
    }
    isOptionalMemberExpression(r) {
      return r.type === "ChainExpression" ? r.expression.type === "MemberExpression" : super.isOptionalMemberExpression(r);
    }
    hasPropertyAsPrivateName(r) {
      return r.type === "ChainExpression" && (r = r.expression), super.hasPropertyAsPrivateName(r);
    }
    isObjectProperty(r) {
      return r.type === "Property" && r.kind === "init" && !r.method;
    }
    isObjectMethod(r) {
      return r.type === "Property" && (r.method || r.kind === "get" || r.kind === "set");
    }
    finishNodeAt(r, i, n) {
      return Jr(super.finishNodeAt(r, i, n));
    }
    resetStartLocation(r, i) {
      super.resetStartLocation(r, i), Jr(r);
    }
    resetEndLocation(r, i = this.state.lastTokEndLoc) {
      super.resetEndLocation(r, i), Jr(r);
    }
  }, "estree"), er = class {
    static {
      s(this, "TokContext");
    }
    constructor(e, r) {
      this.token = void 0, this.preserveSpace = void 0, this.token = e, this.preserveSpace = !!r;
    }
  }, Ie = {
    brace: new er("{"),
    j_oTag: new er("<tag"),
    j_cTag: new er("</tag"),
    j_expr: new er("<tag>...</tag>", !0)
  };
  Ie.template = new er("`", !0);
  var ye = !0, Y = !0, Ga = !0, Xr = !0, qt = !0, B3 = !0, is = class {
    static {
      s(this, "ExportedTokenType");
    }
    constructor(e, r = {}) {
      this.label = void 0, this.keyword = void 0, this.beforeExpr = void 0, this.startsExpr = void 0, this.rightAssociative = void 0, this.isLoop =
      void 0, this.isAssign = void 0, this.prefix = void 0, this.postfix = void 0, this.binop = void 0, this.label = e, this.keyword = r.keyword,
      this.beforeExpr = !!r.beforeExpr, this.startsExpr = !!r.startsExpr, this.rightAssociative = !!r.rightAssociative, this.isLoop = !!r.isLoop,
      this.isAssign = !!r.isAssign, this.prefix = !!r.prefix, this.postfix = !!r.postfix, this.binop = r.binop != null ? r.binop : null, this.
      updateContext = null;
    }
  }, Eo = /* @__PURE__ */ new Map();
  function Pe(t, e = {}) {
    e.keyword = t;
    let r = te(t, e);
    return Eo.set(t, r), r;
  }
  s(Pe, "createKeyword");
  function Qe(t, e) {
    return te(t, {
      beforeExpr: ye,
      binop: e
    });
  }
  s(Qe, "createBinop");
  var Hr = -1, Nt = [], Po = [], Ao = [], Io = [], vo = [], Co = [];
  function te(t, e = {}) {
    var r, i, n, a;
    return ++Hr, Po.push(t), Ao.push((r = e.binop) != null ? r : -1), Io.push((i = e.beforeExpr) != null ? i : !1), vo.push((n = e.startsExpr) !=
    null ? n : !1), Co.push((a = e.prefix) != null ? a : !1), Nt.push(new is(t, e)), Hr;
  }
  s(te, "createToken");
  function me(t, e = {}) {
    var r, i, n, a;
    return ++Hr, Eo.set(t, Hr), Po.push(t), Ao.push((r = e.binop) != null ? r : -1), Io.push((i = e.beforeExpr) != null ? i : !1), vo.push((n =
    e.startsExpr) != null ? n : !1), Co.push((a = e.prefix) != null ? a : !1), Nt.push(new is("name", e)), Hr;
  }
  s(me, "createKeywordLike");
  var j3 = {
    bracketL: te("[", {
      beforeExpr: ye,
      startsExpr: Y
    }),
    bracketHashL: te("#[", {
      beforeExpr: ye,
      startsExpr: Y
    }),
    bracketBarL: te("[|", {
      beforeExpr: ye,
      startsExpr: Y
    }),
    bracketR: te("]"),
    bracketBarR: te("|]"),
    braceL: te("{", {
      beforeExpr: ye,
      startsExpr: Y
    }),
    braceBarL: te("{|", {
      beforeExpr: ye,
      startsExpr: Y
    }),
    braceHashL: te("#{", {
      beforeExpr: ye,
      startsExpr: Y
    }),
    braceR: te("}"),
    braceBarR: te("|}"),
    parenL: te("(", {
      beforeExpr: ye,
      startsExpr: Y
    }),
    parenR: te(")"),
    comma: te(",", {
      beforeExpr: ye
    }),
    semi: te(";", {
      beforeExpr: ye
    }),
    colon: te(":", {
      beforeExpr: ye
    }),
    doubleColon: te("::", {
      beforeExpr: ye
    }),
    dot: te("."),
    question: te("?", {
      beforeExpr: ye
    }),
    questionDot: te("?."),
    arrow: te("=>", {
      beforeExpr: ye
    }),
    template: te("template"),
    ellipsis: te("...", {
      beforeExpr: ye
    }),
    backQuote: te("`", {
      startsExpr: Y
    }),
    dollarBraceL: te("${", {
      beforeExpr: ye,
      startsExpr: Y
    }),
    templateTail: te("...`", {
      startsExpr: Y
    }),
    templateNonTail: te("...${", {
      beforeExpr: ye,
      startsExpr: Y
    }),
    at: te("@"),
    hash: te("#", {
      startsExpr: Y
    }),
    interpreterDirective: te("#!..."),
    eq: te("=", {
      beforeExpr: ye,
      isAssign: Xr
    }),
    assign: te("_=", {
      beforeExpr: ye,
      isAssign: Xr
    }),
    slashAssign: te("_=", {
      beforeExpr: ye,
      isAssign: Xr
    }),
    xorAssign: te("_=", {
      beforeExpr: ye,
      isAssign: Xr
    }),
    moduloAssign: te("_=", {
      beforeExpr: ye,
      isAssign: Xr
    }),
    incDec: te("++/--", {
      prefix: qt,
      postfix: B3,
      startsExpr: Y
    }),
    bang: te("!", {
      beforeExpr: ye,
      prefix: qt,
      startsExpr: Y
    }),
    tilde: te("~", {
      beforeExpr: ye,
      prefix: qt,
      startsExpr: Y
    }),
    doubleCaret: te("^^", {
      startsExpr: Y
    }),
    doubleAt: te("@@", {
      startsExpr: Y
    }),
    pipeline: Qe("|>", 0),
    nullishCoalescing: Qe("??", 1),
    logicalOR: Qe("||", 1),
    logicalAND: Qe("&&", 2),
    bitwiseOR: Qe("|", 3),
    bitwiseXOR: Qe("^", 4),
    bitwiseAND: Qe("&", 5),
    equality: Qe("==/!=/===/!==", 6),
    lt: Qe("</>/<=/>=", 7),
    gt: Qe("</>/<=/>=", 7),
    relational: Qe("</>/<=/>=", 7),
    bitShift: Qe("<</>>/>>>", 8),
    bitShiftL: Qe("<</>>/>>>", 8),
    bitShiftR: Qe("<</>>/>>>", 8),
    plusMin: te("+/-", {
      beforeExpr: ye,
      binop: 9,
      prefix: qt,
      startsExpr: Y
    }),
    modulo: te("%", {
      binop: 10,
      startsExpr: Y
    }),
    star: te("*", {
      binop: 10
    }),
    slash: Qe("/", 10),
    exponent: te("**", {
      beforeExpr: ye,
      binop: 11,
      rightAssociative: !0
    }),
    _in: Pe("in", {
      beforeExpr: ye,
      binop: 7
    }),
    _instanceof: Pe("instanceof", {
      beforeExpr: ye,
      binop: 7
    }),
    _break: Pe("break"),
    _case: Pe("case", {
      beforeExpr: ye
    }),
    _catch: Pe("catch"),
    _continue: Pe("continue"),
    _debugger: Pe("debugger"),
    _default: Pe("default", {
      beforeExpr: ye
    }),
    _else: Pe("else", {
      beforeExpr: ye
    }),
    _finally: Pe("finally"),
    _function: Pe("function", {
      startsExpr: Y
    }),
    _if: Pe("if"),
    _return: Pe("return", {
      beforeExpr: ye
    }),
    _switch: Pe("switch"),
    _throw: Pe("throw", {
      beforeExpr: ye,
      prefix: qt,
      startsExpr: Y
    }),
    _try: Pe("try"),
    _var: Pe("var"),
    _const: Pe("const"),
    _with: Pe("with"),
    _new: Pe("new", {
      beforeExpr: ye,
      startsExpr: Y
    }),
    _this: Pe("this", {
      startsExpr: Y
    }),
    _super: Pe("super", {
      startsExpr: Y
    }),
    _class: Pe("class", {
      startsExpr: Y
    }),
    _extends: Pe("extends", {
      beforeExpr: ye
    }),
    _export: Pe("export"),
    _import: Pe("import", {
      startsExpr: Y
    }),
    _null: Pe("null", {
      startsExpr: Y
    }),
    _true: Pe("true", {
      startsExpr: Y
    }),
    _false: Pe("false", {
      startsExpr: Y
    }),
    _typeof: Pe("typeof", {
      beforeExpr: ye,
      prefix: qt,
      startsExpr: Y
    }),
    _void: Pe("void", {
      beforeExpr: ye,
      prefix: qt,
      startsExpr: Y
    }),
    _delete: Pe("delete", {
      beforeExpr: ye,
      prefix: qt,
      startsExpr: Y
    }),
    _do: Pe("do", {
      isLoop: Ga,
      beforeExpr: ye
    }),
    _for: Pe("for", {
      isLoop: Ga
    }),
    _while: Pe("while", {
      isLoop: Ga
    }),
    _as: me("as", {
      startsExpr: Y
    }),
    _assert: me("assert", {
      startsExpr: Y
    }),
    _async: me("async", {
      startsExpr: Y
    }),
    _await: me("await", {
      startsExpr: Y
    }),
    _defer: me("defer", {
      startsExpr: Y
    }),
    _from: me("from", {
      startsExpr: Y
    }),
    _get: me("get", {
      startsExpr: Y
    }),
    _let: me("let", {
      startsExpr: Y
    }),
    _meta: me("meta", {
      startsExpr: Y
    }),
    _of: me("of", {
      startsExpr: Y
    }),
    _sent: me("sent", {
      startsExpr: Y
    }),
    _set: me("set", {
      startsExpr: Y
    }),
    _source: me("source", {
      startsExpr: Y
    }),
    _static: me("static", {
      startsExpr: Y
    }),
    _using: me("using", {
      startsExpr: Y
    }),
    _yield: me("yield", {
      startsExpr: Y
    }),
    _asserts: me("asserts", {
      startsExpr: Y
    }),
    _checks: me("checks", {
      startsExpr: Y
    }),
    _exports: me("exports", {
      startsExpr: Y
    }),
    _global: me("global", {
      startsExpr: Y
    }),
    _implements: me("implements", {
      startsExpr: Y
    }),
    _intrinsic: me("intrinsic", {
      startsExpr: Y
    }),
    _infer: me("infer", {
      startsExpr: Y
    }),
    _is: me("is", {
      startsExpr: Y
    }),
    _mixins: me("mixins", {
      startsExpr: Y
    }),
    _proto: me("proto", {
      startsExpr: Y
    }),
    _require: me("require", {
      startsExpr: Y
    }),
    _satisfies: me("satisfies", {
      startsExpr: Y
    }),
    _keyof: me("keyof", {
      startsExpr: Y
    }),
    _readonly: me("readonly", {
      startsExpr: Y
    }),
    _unique: me("unique", {
      startsExpr: Y
    }),
    _abstract: me("abstract", {
      startsExpr: Y
    }),
    _declare: me("declare", {
      startsExpr: Y
    }),
    _enum: me("enum", {
      startsExpr: Y
    }),
    _module: me("module", {
      startsExpr: Y
    }),
    _namespace: me("namespace", {
      startsExpr: Y
    }),
    _interface: me("interface", {
      startsExpr: Y
    }),
    _type: me("type", {
      startsExpr: Y
    }),
    _opaque: me("opaque", {
      startsExpr: Y
    }),
    name: te("name", {
      startsExpr: Y
    }),
    placeholder: te("%%", {
      startsExpr: !0
    }),
    string: te("string", {
      startsExpr: Y
    }),
    num: te("num", {
      startsExpr: Y
    }),
    bigint: te("bigint", {
      startsExpr: Y
    }),
    decimal: te("decimal", {
      startsExpr: Y
    }),
    regexp: te("regexp", {
      startsExpr: Y
    }),
    privateName: te("#name", {
      startsExpr: Y
    }),
    eof: te("eof"),
    jsxName: te("jsxName"),
    jsxText: te("jsxText", {
      beforeExpr: !0
    }),
    jsxTagStart: te("jsxTagStart", {
      startsExpr: !0
    }),
    jsxTagEnd: te("jsxTagEnd")
  };
  function ve(t) {
    return t >= 93 && t <= 133;
  }
  s(ve, "tokenIsIdentifier");
  function F3(t) {
    return t <= 92;
  }
  s(F3, "tokenKeywordOrIdentifierIsKeyword");
  function mt(t) {
    return t >= 58 && t <= 133;
  }
  s(mt, "tokenIsKeywordOrIdentifier");
  function mp(t) {
    return t >= 58 && t <= 137;
  }
  s(mp, "tokenIsLiteralPropertyName");
  function R3(t) {
    return Io[t];
  }
  s(R3, "tokenComesBeforeExpression");
  function $r(t) {
    return vo[t];
  }
  s($r, "tokenCanStartExpression");
  function q3(t) {
    return t >= 29 && t <= 33;
  }
  s(q3, "tokenIsAssignment");
  function sp(t) {
    return t >= 129 && t <= 131;
  }
  s(sp, "tokenIsFlowInterfaceOrTypeOrOpaque");
  function U3(t) {
    return t >= 90 && t <= 92;
  }
  s(U3, "tokenIsLoop");
  function wo(t) {
    return t >= 58 && t <= 92;
  }
  s(wo, "tokenIsKeyword");
  function K3(t) {
    return t >= 39 && t <= 59;
  }
  s(K3, "tokenIsOperator");
  function V3(t) {
    return t === 34;
  }
  s(V3, "tokenIsPostfix");
  function Y3(t) {
    return Co[t];
  }
  s(Y3, "tokenIsPrefix");
  function J3(t) {
    return t >= 121 && t <= 123;
  }
  s(J3, "tokenIsTSTypeOperator");
  function X3(t) {
    return t >= 124 && t <= 130;
  }
  s(X3, "tokenIsTSDeclarationStart");
  function Kt(t) {
    return Po[t];
  }
  s(Kt, "tokenLabelName");
  function ts(t) {
    return Ao[t];
  }
  s(ts, "tokenOperatorPrecedence");
  function W3(t) {
    return t === 57;
  }
  s(W3, "tokenIsRightAssociative");
  function ss(t) {
    return t >= 24 && t <= 25;
  }
  s(ss, "tokenIsTemplate");
  function wt(t) {
    return Nt[t];
  }
  s(wt, "getExportedToken");
  Nt[8].updateContext = (t) => {
    t.pop();
  }, Nt[5].updateContext = Nt[7].updateContext = Nt[23].updateContext = (t) => {
    t.push(Ie.brace);
  }, Nt[22].updateContext = (t) => {
    t[t.length - 1] === Ie.template ? t.pop() : t.push(Ie.template);
  }, Nt[143].updateContext = (t) => {
    t.push(Ie.j_expr, Ie.j_oTag);
  };
  var No = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993\
-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\
\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\
\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\
\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\
\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CD\uA7D0\uA7D1\uA7D3\uA7D5-\uA7DC\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01\
-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC",
  yp = "\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\
\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\
\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6\
-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20\
-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65", $3 = new RegExp("[" + No + "]"), z3 = new RegExp("[" + No + yp + "]");
  No = yp = null;
  var Tp = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157,
  19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5,
  3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7,
  2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 2, 60, 28, 11, 0, 9, 21, 43, 17,
  47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64,
  6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45,
  52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2,
  1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29,
  113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071,
  18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 129, 74, 6, 0, 67, 12,
  65, 1, 2, 0, 29, 6135, 9, 1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991,
  84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30,
  2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3,
  0, 496, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2,
  2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153,
  7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191], H3 = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0,
  166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2,
  9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68,
  8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14,
  5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 343, 9, 54, 7, 2,
  7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0,
  7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4,
  4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10,
  9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 726, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
  function ro(t, e) {
    let r = 65536;
    for (let i = 0, n = e.length; i < n; i += 2) {
      if (r += e[i], r > t) return !1;
      if (r += e[i + 1], r >= t) return !0;
    }
    return !1;
  }
  s(ro, "isInAstralSet");
  function Ot(t) {
    return t < 65 ? t === 36 : t <= 90 ? !0 : t < 97 ? t === 95 : t <= 122 ? !0 : t <= 65535 ? t >= 170 && $3.test(String.fromCharCode(t)) :
    ro(t, Tp);
  }
  s(Ot, "isIdentifierStart");
  function mr(t) {
    return t < 48 ? t === 36 : t < 58 ? !0 : t < 65 ? !1 : t <= 90 ? !0 : t < 97 ? t === 95 : t <= 122 ? !0 : t <= 65535 ? t >= 170 && z3.test(
    String.fromCharCode(t)) : ro(t, Tp) || ro(t, H3);
  }
  s(mr, "isIdentifierChar");
  var Oo = {
    keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "swit\
ch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false",
    "in", "instanceof", "typeof", "void", "delete"],
    strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
    strictBind: ["eval", "arguments"]
  }, G3 = new Set(Oo.keyword), Q3 = new Set(Oo.strict), Z3 = new Set(Oo.strictBind);
  function Sp(t, e) {
    return e && t === "await" || t === "enum";
  }
  s(Sp, "isReservedWord");
  function bp(t, e) {
    return Sp(t, e) || Q3.has(t);
  }
  s(bp, "isStrictReservedWord");
  function xp(t) {
    return Z3.has(t);
  }
  s(xp, "isStrictBindOnlyReservedWord");
  function gp(t, e) {
    return bp(t, e) || xp(t);
  }
  s(gp, "isStrictBindReservedWord");
  function eB(t) {
    return G3.has(t);
  }
  s(eB, "isKeyword");
  function tB(t, e, r) {
    return t === 64 && e === 64 && Ot(r);
  }
  s(tB, "isIteratorStart");
  var rB = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function",
  "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import",
  "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protecte\
d", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
  function iB(t) {
    return rB.has(t);
  }
  s(iB, "canBeReservedWord");
  var Gr = class {
    static {
      s(this, "Scope");
    }
    constructor(e) {
      this.flags = 0, this.names = /* @__PURE__ */ new Map(), this.firstLexicalName = "", this.flags = e;
    }
  }, Qr = class {
    static {
      s(this, "ScopeHandler");
    }
    constructor(e, r) {
      this.parser = void 0, this.scopeStack = [], this.inModule = void 0, this.undefinedExports = /* @__PURE__ */ new Map(), this.parser = e,
      this.inModule = r;
    }
    get inTopLevel() {
      return (this.currentScope().flags & 1) > 0;
    }
    get inFunction() {
      return (this.currentVarScopeFlags() & 2) > 0;
    }
    get allowSuper() {
      return (this.currentThisScopeFlags() & 16) > 0;
    }
    get allowDirectSuper() {
      return (this.currentThisScopeFlags() & 32) > 0;
    }
    get inClass() {
      return (this.currentThisScopeFlags() & 64) > 0;
    }
    get inClassAndNotInNonArrowFunction() {
      let e = this.currentThisScopeFlags();
      return (e & 64) > 0 && (e & 2) === 0;
    }
    get inStaticBlock() {
      for (let e = this.scopeStack.length - 1; ; e--) {
        let {
          flags: r
        } = this.scopeStack[e];
        if (r & 128)
          return !0;
        if (r & 451)
          return !1;
      }
    }
    get inNonArrowFunction() {
      return (this.currentThisScopeFlags() & 2) > 0;
    }
    get treatFunctionsAsVar() {
      return this.treatFunctionsAsVarInScope(this.currentScope());
    }
    createScope(e) {
      return new Gr(e);
    }
    enter(e) {
      this.scopeStack.push(this.createScope(e));
    }
    exit() {
      return this.scopeStack.pop().flags;
    }
    treatFunctionsAsVarInScope(e) {
      return !!(e.flags & 130 || !this.parser.inModule && e.flags & 1);
    }
    declareName(e, r, i) {
      let n = this.currentScope();
      if (r & 8 || r & 16) {
        this.checkRedeclarationInScope(n, e, r, i);
        let a = n.names.get(e) || 0;
        r & 16 ? a = a | 4 : (n.firstLexicalName || (n.firstLexicalName = e), a = a | 2), n.names.set(e, a), r & 8 && this.maybeExportDefined(
        n, e);
      } else if (r & 4)
        for (let a = this.scopeStack.length - 1; a >= 0 && (n = this.scopeStack[a], this.checkRedeclarationInScope(n, e, r, i), n.names.set(
        e, (n.names.get(e) || 0) | 1), this.maybeExportDefined(n, e), !(n.flags & 387)); --a)
          ;
      this.parser.inModule && n.flags & 1 && this.undefinedExports.delete(e);
    }
    maybeExportDefined(e, r) {
      this.parser.inModule && e.flags & 1 && this.undefinedExports.delete(r);
    }
    checkRedeclarationInScope(e, r, i, n) {
      this.isRedeclaredInScope(e, r, i) && this.parser.raise(g.VarRedeclaration, n, {
        identifierName: r
      });
    }
    isRedeclaredInScope(e, r, i) {
      if (!(i & 1)) return !1;
      if (i & 8)
        return e.names.has(r);
      let n = e.names.get(r);
      return i & 16 ? (n & 2) > 0 || !this.treatFunctionsAsVarInScope(e) && (n & 1) > 0 : (n & 2) > 0 && !(e.flags & 8 && e.firstLexicalName ===
      r) || !this.treatFunctionsAsVarInScope(e) && (n & 4) > 0;
    }
    checkLocalExport(e) {
      let {
        name: r
      } = e;
      this.scopeStack[0].names.has(r) || this.undefinedExports.set(r, e.loc.start);
    }
    currentScope() {
      return this.scopeStack[this.scopeStack.length - 1];
    }
    currentVarScopeFlags() {
      for (let e = this.scopeStack.length - 1; ; e--) {
        let {
          flags: r
        } = this.scopeStack[e];
        if (r & 387)
          return r;
      }
    }
    currentThisScopeFlags() {
      for (let e = this.scopeStack.length - 1; ; e--) {
        let {
          flags: r
        } = this.scopeStack[e];
        if (r & 451 && !(r & 4))
          return r;
      }
    }
  }, io = class extends Gr {
    static {
      s(this, "FlowScope");
    }
    constructor(...e) {
      super(...e), this.declareFunctions = /* @__PURE__ */ new Set();
    }
  }, so = class extends Qr {
    static {
      s(this, "FlowScopeHandler");
    }
    createScope(e) {
      return new io(e);
    }
    declareName(e, r, i) {
      let n = this.currentScope();
      if (r & 2048) {
        this.checkRedeclarationInScope(n, e, r, i), this.maybeExportDefined(n, e), n.declareFunctions.add(e);
        return;
      }
      super.declareName(e, r, i);
    }
    isRedeclaredInScope(e, r, i) {
      if (super.isRedeclaredInScope(e, r, i)) return !0;
      if (i & 2048 && !e.declareFunctions.has(r)) {
        let n = e.names.get(r);
        return (n & 4) > 0 || (n & 2) > 0;
      }
      return !1;
    }
    checkLocalExport(e) {
      this.scopeStack[0].declareFunctions.has(e.name) || super.checkLocalExport(e);
    }
  }, no = class {
    static {
      s(this, "BaseParser");
    }
    constructor() {
      this.sawUnambiguousESM = !1, this.ambiguousScriptDifferentAst = !1;
    }
    sourceToOffsetPos(e) {
      return e + this.startIndex;
    }
    offsetToSourcePos(e) {
      return e - this.startIndex;
    }
    hasPlugin(e) {
      if (typeof e == "string")
        return this.plugins.has(e);
      {
        let [r, i] = e;
        if (!this.hasPlugin(r))
          return !1;
        let n = this.plugins.get(r);
        for (let a of Object.keys(i))
          if (n?.[a] !== i[a])
            return !1;
        return !0;
      }
    }
    getPluginOption(e, r) {
      var i;
      return (i = this.plugins.get(e)) == null ? void 0 : i[r];
    }
  };
  function Ep(t, e) {
    t.trailingComments === void 0 ? t.trailingComments = e : t.trailingComments.unshift(...e);
  }
  s(Ep, "setTrailingComments");
  function sB(t, e) {
    t.leadingComments === void 0 ? t.leadingComments = e : t.leadingComments.unshift(...e);
  }
  s(sB, "setLeadingComments");
  function Zr(t, e) {
    t.innerComments === void 0 ? t.innerComments = e : t.innerComments.unshift(...e);
  }
  s(Zr, "setInnerComments");
  function Qt(t, e, r) {
    let i = null, n = e.length;
    for (; i === null && n > 0; )
      i = e[--n];
    i === null || i.start > r.start ? Zr(t, r.comments) : Ep(i, r.comments);
  }
  s(Qt, "adjustInnerComments");
  var ao = class extends no {
    static {
      s(this, "CommentsParser");
    }
    addComment(e) {
      this.filename && (e.loc.filename = this.filename);
      let {
        commentsLen: r
      } = this.state;
      this.comments.length !== r && (this.comments.length = r), this.comments.push(e), this.state.commentsLen++;
    }
    processComment(e) {
      let {
        commentStack: r
      } = this.state, i = r.length;
      if (i === 0) return;
      let n = i - 1, a = r[n];
      a.start === e.end && (a.leadingNode = e, n--);
      let {
        start: o
      } = e;
      for (; n >= 0; n--) {
        let l = r[n], u = l.end;
        if (u > o)
          l.containingNode = e, this.finalizeComment(l), r.splice(n, 1);
        else {
          u === o && (l.trailingNode = e);
          break;
        }
      }
    }
    finalizeComment(e) {
      let {
        comments: r
      } = e;
      if (e.leadingNode !== null || e.trailingNode !== null)
        e.leadingNode !== null && Ep(e.leadingNode, r), e.trailingNode !== null && sB(e.trailingNode, r);
      else {
        let {
          containingNode: i,
          start: n
        } = e;
        if (this.input.charCodeAt(this.offsetToSourcePos(n) - 1) === 44)
          switch (i.type) {
            case "ObjectExpression":
            case "ObjectPattern":
            case "RecordExpression":
              Qt(i, i.properties, e);
              break;
            case "CallExpression":
            case "OptionalCallExpression":
              Qt(i, i.arguments, e);
              break;
            case "FunctionDeclaration":
            case "FunctionExpression":
            case "ArrowFunctionExpression":
            case "ObjectMethod":
            case "ClassMethod":
            case "ClassPrivateMethod":
              Qt(i, i.params, e);
              break;
            case "ArrayExpression":
            case "ArrayPattern":
            case "TupleExpression":
              Qt(i, i.elements, e);
              break;
            case "ExportNamedDeclaration":
            case "ImportDeclaration":
              Qt(i, i.specifiers, e);
              break;
            case "TSEnumDeclaration":
              Qt(i, i.members, e);
              break;
            case "TSEnumBody":
              Qt(i, i.members, e);
              break;
            default:
              Zr(i, r);
          }
        else
          Zr(i, r);
      }
    }
    finalizeRemainingComments() {
      let {
        commentStack: e
      } = this.state;
      for (let r = e.length - 1; r >= 0; r--)
        this.finalizeComment(e[r]);
      this.state.commentStack = [];
    }
    resetPreviousNodeTrailingComments(e) {
      let {
        commentStack: r
      } = this.state, {
        length: i
      } = r;
      if (i === 0) return;
      let n = r[i - 1];
      n.leadingNode === e && (n.leadingNode = null);
    }
    resetPreviousIdentifierLeadingComments(e) {
      let {
        commentStack: r
      } = this.state, {
        length: i
      } = r;
      i !== 0 && (r[i - 1].trailingNode === e ? r[i - 1].trailingNode = null : i >= 2 && r[i - 2].trailingNode === e && (r[i - 2].trailingNode =
      null));
    }
    takeSurroundingComments(e, r, i) {
      let {
        commentStack: n
      } = this.state, a = n.length;
      if (a === 0) return;
      let o = a - 1;
      for (; o >= 0; o--) {
        let l = n[o], u = l.end;
        if (l.start === i)
          l.leadingNode = e;
        else if (u === r)
          l.trailingNode = e;
        else if (u < r)
          break;
      }
    }
  }, nB = /\r\n|[\r\n\u2028\u2029]/, Qi = new RegExp(nB.source, "g");
  function yr(t) {
    switch (t) {
      case 10:
      case 13:
      case 8232:
      case 8233:
        return !0;
      default:
        return !1;
    }
  }
  s(yr, "isNewLine");
  function np(t, e, r) {
    for (let i = e; i < r; i++)
      if (yr(t.charCodeAt(i)))
        return !0;
    return !1;
  }
  s(np, "hasNewLine");
  var Qa = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, Za = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g;
  function aB(t) {
    switch (t) {
      case 9:
      case 11:
      case 12:
      case 32:
      case 160:
      case 5760:
      case 8192:
      case 8193:
      case 8194:
      case 8195:
      case 8196:
      case 8197:
      case 8198:
      case 8199:
      case 8200:
      case 8201:
      case 8202:
      case 8239:
      case 8287:
      case 12288:
      case 65279:
        return !0;
      default:
        return !1;
    }
  }
  s(aB, "isWhitespace");
  var oo = class t {
    static {
      s(this, "State");
    }
    constructor() {
      this.flags = 1024, this.startIndex = void 0, this.curLine = void 0, this.lineStart = void 0, this.startLoc = void 0, this.endLoc = void 0,
      this.errors = [], this.potentialArrowAt = -1, this.noArrowAt = [], this.noArrowParamsConversionAt = [], this.topicContext = {
        maxNumOfResolvableTopics: 0,
        maxTopicIndex: null
      }, this.labels = [], this.commentsLen = 0, this.commentStack = [], this.pos = 0, this.type = 140, this.value = null, this.start = 0, this.
      end = 0, this.lastTokEndLoc = null, this.lastTokStartLoc = null, this.context = [Ie.brace], this.firstInvalidTemplateEscapePos = null,
      this.strictErrors = /* @__PURE__ */ new Map(), this.tokensLength = 0;
    }
    get strict() {
      return (this.flags & 1) > 0;
    }
    set strict(e) {
      e ? this.flags |= 1 : this.flags &= -2;
    }
    init({
      strictMode: e,
      sourceType: r,
      startIndex: i,
      startLine: n,
      startColumn: a
    }) {
      this.strict = e === !1 ? !1 : e === !0 ? !0 : r === "module", this.startIndex = i, this.curLine = n, this.lineStart = -a, this.startLoc =
      this.endLoc = new Et(n, a, i);
    }
    get maybeInArrowParameters() {
      return (this.flags & 2) > 0;
    }
    set maybeInArrowParameters(e) {
      e ? this.flags |= 2 : this.flags &= -3;
    }
    get inType() {
      return (this.flags & 4) > 0;
    }
    set inType(e) {
      e ? this.flags |= 4 : this.flags &= -5;
    }
    get noAnonFunctionType() {
      return (this.flags & 8) > 0;
    }
    set noAnonFunctionType(e) {
      e ? this.flags |= 8 : this.flags &= -9;
    }
    get hasFlowComment() {
      return (this.flags & 16) > 0;
    }
    set hasFlowComment(e) {
      e ? this.flags |= 16 : this.flags &= -17;
    }
    get isAmbientContext() {
      return (this.flags & 32) > 0;
    }
    set isAmbientContext(e) {
      e ? this.flags |= 32 : this.flags &= -33;
    }
    get inAbstractClass() {
      return (this.flags & 64) > 0;
    }
    set inAbstractClass(e) {
      e ? this.flags |= 64 : this.flags &= -65;
    }
    get inDisallowConditionalTypesContext() {
      return (this.flags & 128) > 0;
    }
    set inDisallowConditionalTypesContext(e) {
      e ? this.flags |= 128 : this.flags &= -129;
    }
    get soloAwait() {
      return (this.flags & 256) > 0;
    }
    set soloAwait(e) {
      e ? this.flags |= 256 : this.flags &= -257;
    }
    get inFSharpPipelineDirectBody() {
      return (this.flags & 512) > 0;
    }
    set inFSharpPipelineDirectBody(e) {
      e ? this.flags |= 512 : this.flags &= -513;
    }
    get canStartJSXElement() {
      return (this.flags & 1024) > 0;
    }
    set canStartJSXElement(e) {
      e ? this.flags |= 1024 : this.flags &= -1025;
    }
    get containsEsc() {
      return (this.flags & 2048) > 0;
    }
    set containsEsc(e) {
      e ? this.flags |= 2048 : this.flags &= -2049;
    }
    get hasTopLevelAwait() {
      return (this.flags & 4096) > 0;
    }
    set hasTopLevelAwait(e) {
      e ? this.flags |= 4096 : this.flags &= -4097;
    }
    curPosition() {
      return new Et(this.curLine, this.pos - this.lineStart, this.pos + this.startIndex);
    }
    clone() {
      let e = new t();
      return e.flags = this.flags, e.startIndex = this.startIndex, e.curLine = this.curLine, e.lineStart = this.lineStart, e.startLoc = this.
      startLoc, e.endLoc = this.endLoc, e.errors = this.errors.slice(), e.potentialArrowAt = this.potentialArrowAt, e.noArrowAt = this.noArrowAt.
      slice(), e.noArrowParamsConversionAt = this.noArrowParamsConversionAt.slice(), e.topicContext = this.topicContext, e.labels = this.labels.
      slice(), e.commentsLen = this.commentsLen, e.commentStack = this.commentStack.slice(), e.pos = this.pos, e.type = this.type, e.value =
      this.value, e.start = this.start, e.end = this.end, e.lastTokEndLoc = this.lastTokEndLoc, e.lastTokStartLoc = this.lastTokStartLoc, e.
      context = this.context.slice(), e.firstInvalidTemplateEscapePos = this.firstInvalidTemplateEscapePos, e.strictErrors = this.strictErrors,
      e.tokensLength = this.tokensLength, e;
    }
  }, oB = /* @__PURE__ */ s(function(e) {
    return e >= 48 && e <= 57;
  }, "isDigit"), ap = {
    decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]),
    hex: /* @__PURE__ */ new Set([46, 88, 95, 120])
  }, Zi = {
    bin: /* @__PURE__ */ s((t) => t === 48 || t === 49, "bin"),
    oct: /* @__PURE__ */ s((t) => t >= 48 && t <= 55, "oct"),
    dec: /* @__PURE__ */ s((t) => t >= 48 && t <= 57, "dec"),
    hex: /* @__PURE__ */ s((t) => t >= 48 && t <= 57 || t >= 65 && t <= 70 || t >= 97 && t <= 102, "hex")
  };
  function op(t, e, r, i, n, a) {
    let o = r, l = i, u = n, p = "", h = null, E = r, {
      length: I
    } = e;
    for (; ; ) {
      if (r >= I) {
        a.unterminated(o, l, u), p += e.slice(E, r);
        break;
      }
      let v = e.charCodeAt(r);
      if (lB(t, v, e, r)) {
        p += e.slice(E, r);
        break;
      }
      if (v === 92) {
        p += e.slice(E, r);
        let _ = uB(e, r, i, n, t === "template", a);
        _.ch === null && !h ? h = {
          pos: r,
          lineStart: i,
          curLine: n
        } : p += _.ch, {
          pos: r,
          lineStart: i,
          curLine: n
        } = _, E = r;
      } else v === 8232 || v === 8233 ? (++r, ++n, i = r) : v === 10 || v === 13 ? t === "template" ? (p += e.slice(E, r) + `
`, ++r, v === 13 && e.charCodeAt(r) === 10 && ++r, ++n, E = i = r) : a.unterminated(o, l, u) : ++r;
    }
    return {
      pos: r,
      str: p,
      firstInvalidLoc: h,
      lineStart: i,
      curLine: n,
      containsInvalid: !!h
    };
  }
  s(op, "readStringContents");
  function lB(t, e, r, i) {
    return t === "template" ? e === 96 || e === 36 && r.charCodeAt(i + 1) === 123 : e === (t === "double" ? 34 : 39);
  }
  s(lB, "isStringEnd");
  function uB(t, e, r, i, n, a) {
    let o = !n;
    e++;
    let l = /* @__PURE__ */ s((p) => ({
      pos: e,
      ch: p,
      lineStart: r,
      curLine: i
    }), "res"), u = t.charCodeAt(e++);
    switch (u) {
      case 110:
        return l(`
`);
      case 114:
        return l("\r");
      case 120: {
        let p;
        return {
          code: p,
          pos: e
        } = lo(t, e, r, i, 2, !1, o, a), l(p === null ? null : String.fromCharCode(p));
      }
      case 117: {
        let p;
        return {
          code: p,
          pos: e
        } = Ap(t, e, r, i, o, a), l(p === null ? null : String.fromCodePoint(p));
      }
      case 116:
        return l("	");
      case 98:
        return l("\b");
      case 118:
        return l("\v");
      case 102:
        return l("\f");
      case 13:
        t.charCodeAt(e) === 10 && ++e;
      case 10:
        r = e, ++i;
      case 8232:
      case 8233:
        return l("");
      case 56:
      case 57:
        if (n)
          return l(null);
        a.strictNumericEscape(e - 1, r, i);
      default:
        if (u >= 48 && u <= 55) {
          let p = e - 1, E = /^[0-7]+/.exec(t.slice(p, e + 2))[0], I = parseInt(E, 8);
          I > 255 && (E = E.slice(0, -1), I = parseInt(E, 8)), e += E.length - 1;
          let v = t.charCodeAt(e);
          if (E !== "0" || v === 56 || v === 57) {
            if (n)
              return l(null);
            a.strictNumericEscape(p, r, i);
          }
          return l(String.fromCharCode(I));
        }
        return l(String.fromCharCode(u));
    }
  }
  s(uB, "readEscapedChar");
  function lo(t, e, r, i, n, a, o, l) {
    let u = e, p;
    return {
      n: p,
      pos: e
    } = Pp(t, e, r, i, 16, n, a, !1, l, !o), p === null && (o ? l.invalidEscapeSequence(u, r, i) : e = u - 1), {
      code: p,
      pos: e
    };
  }
  s(lo, "readHexChar");
  function Pp(t, e, r, i, n, a, o, l, u, p) {
    let h = e, E = n === 16 ? ap.hex : ap.decBinOct, I = n === 16 ? Zi.hex : n === 10 ? Zi.dec : n === 8 ? Zi.oct : Zi.bin, v = !1, _ = 0;
    for (let j = 0, O = a ?? 1 / 0; j < O; ++j) {
      let k = t.charCodeAt(e), B;
      if (k === 95 && l !== "bail") {
        let ue = t.charCodeAt(e - 1), K = t.charCodeAt(e + 1);
        if (l) {
          if (Number.isNaN(K) || !I(K) || E.has(ue) || E.has(K)) {
            if (p) return {
              n: null,
              pos: e
            };
            u.unexpectedNumericSeparator(e, r, i);
          }
        } else {
          if (p) return {
            n: null,
            pos: e
          };
          u.numericSeparatorInEscapeSequence(e, r, i);
        }
        ++e;
        continue;
      }
      if (k >= 97 ? B = k - 97 + 10 : k >= 65 ? B = k - 65 + 10 : oB(k) ? B = k - 48 : B = 1 / 0, B >= n) {
        if (B <= 9 && p)
          return {
            n: null,
            pos: e
          };
        if (B <= 9 && u.invalidDigit(e, r, i, n))
          B = 0;
        else if (o)
          B = 0, v = !0;
        else
          break;
      }
      ++e, _ = _ * n + B;
    }
    return e === h || a != null && e - h !== a || v ? {
      n: null,
      pos: e
    } : {
      n: _,
      pos: e
    };
  }
  s(Pp, "readInt");
  function Ap(t, e, r, i, n, a) {
    let o = t.charCodeAt(e), l;
    if (o === 123) {
      if (++e, {
        code: l,
        pos: e
      } = lo(t, e, r, i, t.indexOf("}", e) - e, !0, n, a), ++e, l !== null && l > 1114111)
        if (n)
          a.invalidCodePoint(e, r, i);
        else
          return {
            code: null,
            pos: e
          };
    } else
      ({
        code: l,
        pos: e
      } = lo(t, e, r, i, 4, !1, n, a));
    return {
      code: l,
      pos: e
    };
  }
  s(Ap, "readCodePoint");
  function Wr(t, e, r) {
    return new Et(r, t - e, t);
  }
  s(Wr, "buildPosition");
  var cB = /* @__PURE__ */ new Set([103, 109, 115, 105, 121, 117, 100, 118]), gt = class {
    static {
      s(this, "Token");
    }
    constructor(e) {
      let r = e.startIndex || 0;
      this.type = e.type, this.value = e.value, this.start = r + e.start, this.end = r + e.end, this.loc = new Sr(e.startLoc, e.endLoc);
    }
  }, uo = class extends ao {
    static {
      s(this, "Tokenizer");
    }
    constructor(e, r) {
      super(), this.isLookahead = void 0, this.tokens = [], this.errorHandlers_readInt = {
        invalidDigit: /* @__PURE__ */ s((i, n, a, o) => this.optionFlags & 2048 ? (this.raise(g.InvalidDigit, Wr(i, n, a), {
          radix: o
        }), !0) : !1, "invalidDigit"),
        numericSeparatorInEscapeSequence: this.errorBuilder(g.NumericSeparatorInEscapeSequence),
        unexpectedNumericSeparator: this.errorBuilder(g.UnexpectedNumericSeparator)
      }, this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, {
        invalidEscapeSequence: this.errorBuilder(g.InvalidEscapeSequence),
        invalidCodePoint: this.errorBuilder(g.InvalidCodePoint)
      }), this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, {
        strictNumericEscape: /* @__PURE__ */ s((i, n, a) => {
          this.recordStrictModeErrors(g.StrictNumericEscape, Wr(i, n, a));
        }, "strictNumericEscape"),
        unterminated: /* @__PURE__ */ s((i, n, a) => {
          throw this.raise(g.UnterminatedString, Wr(i - 1, n, a));
        }, "unterminated")
      }), this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, {
        strictNumericEscape: this.errorBuilder(g.StrictNumericEscape),
        unterminated: /* @__PURE__ */ s((i, n, a) => {
          throw this.raise(g.UnterminatedTemplate, Wr(i, n, a));
        }, "unterminated")
      }), this.state = new oo(), this.state.init(e), this.input = r, this.length = r.length, this.comments = [], this.isLookahead = !1;
    }
    pushToken(e) {
      this.tokens.length = this.state.tokensLength, this.tokens.push(e), ++this.state.tokensLength;
    }
    next() {
      this.checkKeywordEscapes(), this.optionFlags & 256 && this.pushToken(new gt(this.state)), this.state.lastTokEndLoc = this.state.endLoc,
      this.state.lastTokStartLoc = this.state.startLoc, this.nextToken();
    }
    eat(e) {
      return this.match(e) ? (this.next(), !0) : !1;
    }
    match(e) {
      return this.state.type === e;
    }
    createLookaheadState(e) {
      return {
        pos: e.pos,
        value: null,
        type: e.type,
        start: e.start,
        end: e.end,
        context: [this.curContext()],
        inType: e.inType,
        startLoc: e.startLoc,
        lastTokEndLoc: e.lastTokEndLoc,
        curLine: e.curLine,
        lineStart: e.lineStart,
        curPosition: e.curPosition
      };
    }
    lookahead() {
      let e = this.state;
      this.state = this.createLookaheadState(e), this.isLookahead = !0, this.nextToken(), this.isLookahead = !1;
      let r = this.state;
      return this.state = e, r;
    }
    nextTokenStart() {
      return this.nextTokenStartSince(this.state.pos);
    }
    nextTokenStartSince(e) {
      return Qa.lastIndex = e, Qa.test(this.input) ? Qa.lastIndex : e;
    }
    lookaheadCharCode() {
      return this.input.charCodeAt(this.nextTokenStart());
    }
    nextTokenInLineStart() {
      return this.nextTokenInLineStartSince(this.state.pos);
    }
    nextTokenInLineStartSince(e) {
      return Za.lastIndex = e, Za.test(this.input) ? Za.lastIndex : e;
    }
    lookaheadInLineCharCode() {
      return this.input.charCodeAt(this.nextTokenInLineStart());
    }
    codePointAtPos(e) {
      let r = this.input.charCodeAt(e);
      if ((r & 64512) === 55296 && ++e < this.input.length) {
        let i = this.input.charCodeAt(e);
        (i & 64512) === 56320 && (r = 65536 + ((r & 1023) << 10) + (i & 1023));
      }
      return r;
    }
    setStrict(e) {
      this.state.strict = e, e && (this.state.strictErrors.forEach(([r, i]) => this.raise(r, i)), this.state.strictErrors.clear());
    }
    curContext() {
      return this.state.context[this.state.context.length - 1];
    }
    nextToken() {
      if (this.skipSpace(), this.state.start = this.state.pos, this.isLookahead || (this.state.startLoc = this.state.curPosition()), this.state.
      pos >= this.length) {
        this.finishToken(140);
        return;
      }
      this.getTokenFromCode(this.codePointAtPos(this.state.pos));
    }
    skipBlockComment(e) {
      let r;
      this.isLookahead || (r = this.state.curPosition());
      let i = this.state.pos, n = this.input.indexOf(e, i + 2);
      if (n === -1)
        throw this.raise(g.UnterminatedComment, this.state.curPosition());
      for (this.state.pos = n + e.length, Qi.lastIndex = i + 2; Qi.test(this.input) && Qi.lastIndex <= n; )
        ++this.state.curLine, this.state.lineStart = Qi.lastIndex;
      if (this.isLookahead) return;
      let a = {
        type: "CommentBlock",
        value: this.input.slice(i + 2, n),
        start: this.sourceToOffsetPos(i),
        end: this.sourceToOffsetPos(n + e.length),
        loc: new Sr(r, this.state.curPosition())
      };
      return this.optionFlags & 256 && this.pushToken(a), a;
    }
    skipLineComment(e) {
      let r = this.state.pos, i;
      this.isLookahead || (i = this.state.curPosition());
      let n = this.input.charCodeAt(this.state.pos += e);
      if (this.state.pos < this.length)
        for (; !yr(n) && ++this.state.pos < this.length; )
          n = this.input.charCodeAt(this.state.pos);
      if (this.isLookahead) return;
      let a = this.state.pos, l = {
        type: "CommentLine",
        value: this.input.slice(r + e, a),
        start: this.sourceToOffsetPos(r),
        end: this.sourceToOffsetPos(a),
        loc: new Sr(i, this.state.curPosition())
      };
      return this.optionFlags & 256 && this.pushToken(l), l;
    }
    skipSpace() {
      let e = this.state.pos, r = this.optionFlags & 4096 ? [] : null;
      e: for (; this.state.pos < this.length; ) {
        let i = this.input.charCodeAt(this.state.pos);
        switch (i) {
          case 32:
          case 160:
          case 9:
            ++this.state.pos;
            break;
          case 13:
            this.input.charCodeAt(this.state.pos + 1) === 10 && ++this.state.pos;
          case 10:
          case 8232:
          case 8233:
            ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
            break;
          case 47:
            switch (this.input.charCodeAt(this.state.pos + 1)) {
              case 42: {
                let n = this.skipBlockComment("*/");
                n !== void 0 && (this.addComment(n), r?.push(n));
                break;
              }
              case 47: {
                let n = this.skipLineComment(2);
                n !== void 0 && (this.addComment(n), r?.push(n));
                break;
              }
              default:
                break e;
            }
            break;
          default:
            if (aB(i))
              ++this.state.pos;
            else if (i === 45 && !this.inModule && this.optionFlags & 8192) {
              let n = this.state.pos;
              if (this.input.charCodeAt(n + 1) === 45 && this.input.charCodeAt(n + 2) === 62 && (e === 0 || this.state.lineStart > e)) {
                let a = this.skipLineComment(3);
                a !== void 0 && (this.addComment(a), r?.push(a));
              } else
                break e;
            } else if (i === 60 && !this.inModule && this.optionFlags & 8192) {
              let n = this.state.pos;
              if (this.input.charCodeAt(n + 1) === 33 && this.input.charCodeAt(n + 2) === 45 && this.input.charCodeAt(n + 3) === 45) {
                let a = this.skipLineComment(4);
                a !== void 0 && (this.addComment(a), r?.push(a));
              } else
                break e;
            } else
              break e;
        }
      }
      if (r?.length > 0) {
        let i = this.state.pos, n = {
          start: this.sourceToOffsetPos(e),
          end: this.sourceToOffsetPos(i),
          comments: r,
          leadingNode: null,
          trailingNode: null,
          containingNode: null
        };
        this.state.commentStack.push(n);
      }
    }
    finishToken(e, r) {
      this.state.end = this.state.pos, this.state.endLoc = this.state.curPosition();
      let i = this.state.type;
      this.state.type = e, this.state.value = r, this.isLookahead || this.updateContext(i);
    }
    replaceToken(e) {
      this.state.type = e, this.updateContext();
    }
    readToken_numberSign() {
      if (this.state.pos === 0 && this.readToken_interpreter())
        return;
      let e = this.state.pos + 1, r = this.codePointAtPos(e);
      if (r >= 48 && r <= 57)
        throw this.raise(g.UnexpectedDigitAfterHash, this.state.curPosition());
      if (r === 123 || r === 91 && this.hasPlugin("recordAndTuple")) {
        if (this.expectPlugin("recordAndTuple"), this.getPluginOption("recordAndTuple", "syntaxType") === "bar")
          throw this.raise(r === 123 ? g.RecordExpressionHashIncorrectStartSyntaxType : g.TupleExpressionHashIncorrectStartSyntaxType, this.
          state.curPosition());
        this.state.pos += 2, r === 123 ? this.finishToken(7) : this.finishToken(1);
      } else Ot(r) ? (++this.state.pos, this.finishToken(139, this.readWord1(r))) : r === 92 ? (++this.state.pos, this.finishToken(139, this.
      readWord1())) : this.finishOp(27, 1);
    }
    readToken_dot() {
      let e = this.input.charCodeAt(this.state.pos + 1);
      if (e >= 48 && e <= 57) {
        this.readNumber(!0);
        return;
      }
      e === 46 && this.input.charCodeAt(this.state.pos + 2) === 46 ? (this.state.pos += 3, this.finishToken(21)) : (++this.state.pos, this.finishToken(
      16));
    }
    readToken_slash() {
      this.input.charCodeAt(this.state.pos + 1) === 61 ? this.finishOp(31, 2) : this.finishOp(56, 1);
    }
    readToken_interpreter() {
      if (this.state.pos !== 0 || this.length < 2) return !1;
      let e = this.input.charCodeAt(this.state.pos + 1);
      if (e !== 33) return !1;
      let r = this.state.pos;
      for (this.state.pos += 1; !yr(e) && ++this.state.pos < this.length; )
        e = this.input.charCodeAt(this.state.pos);
      let i = this.input.slice(r + 2, this.state.pos);
      return this.finishToken(28, i), !0;
    }
    readToken_mult_modulo(e) {
      let r = e === 42 ? 55 : 54, i = 1, n = this.input.charCodeAt(this.state.pos + 1);
      e === 42 && n === 42 && (i++, n = this.input.charCodeAt(this.state.pos + 2), r = 57), n === 61 && !this.state.inType && (i++, r = e ===
      37 ? 33 : 30), this.finishOp(r, i);
    }
    readToken_pipe_amp(e) {
      let r = this.input.charCodeAt(this.state.pos + 1);
      if (r === e) {
        this.input.charCodeAt(this.state.pos + 2) === 61 ? this.finishOp(30, 3) : this.finishOp(e === 124 ? 41 : 42, 2);
        return;
      }
      if (e === 124) {
        if (r === 62) {
          this.finishOp(39, 2);
          return;
        }
        if (this.hasPlugin("recordAndTuple") && r === 125) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
            throw this.raise(g.RecordExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
          this.state.pos += 2, this.finishToken(9);
          return;
        }
        if (this.hasPlugin("recordAndTuple") && r === 93) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
            throw this.raise(g.TupleExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
          this.state.pos += 2, this.finishToken(4);
          return;
        }
      }
      if (r === 61) {
        this.finishOp(30, 2);
        return;
      }
      this.finishOp(e === 124 ? 43 : 45, 1);
    }
    readToken_caret() {
      let e = this.input.charCodeAt(this.state.pos + 1);
      e === 61 && !this.state.inType ? this.finishOp(32, 2) : e === 94 && this.hasPlugin(["pipelineOperator", {
        proposal: "hack",
        topicToken: "^^"
      }]) ? (this.finishOp(37, 2), this.input.codePointAt(this.state.pos) === 94 && this.unexpected()) : this.finishOp(44, 1);
    }
    readToken_atSign() {
      this.input.charCodeAt(this.state.pos + 1) === 64 && this.hasPlugin(["pipelineOperator", {
        proposal: "hack",
        topicToken: "@@"
      }]) ? this.finishOp(38, 2) : this.finishOp(26, 1);
    }
    readToken_plus_min(e) {
      let r = this.input.charCodeAt(this.state.pos + 1);
      if (r === e) {
        this.finishOp(34, 2);
        return;
      }
      r === 61 ? this.finishOp(30, 2) : this.finishOp(53, 1);
    }
    readToken_lt() {
      let {
        pos: e
      } = this.state, r = this.input.charCodeAt(e + 1);
      if (r === 60) {
        if (this.input.charCodeAt(e + 2) === 61) {
          this.finishOp(30, 3);
          return;
        }
        this.finishOp(51, 2);
        return;
      }
      if (r === 61) {
        this.finishOp(49, 2);
        return;
      }
      this.finishOp(47, 1);
    }
    readToken_gt() {
      let {
        pos: e
      } = this.state, r = this.input.charCodeAt(e + 1);
      if (r === 62) {
        let i = this.input.charCodeAt(e + 2) === 62 ? 3 : 2;
        if (this.input.charCodeAt(e + i) === 61) {
          this.finishOp(30, i + 1);
          return;
        }
        this.finishOp(52, i);
        return;
      }
      if (r === 61) {
        this.finishOp(49, 2);
        return;
      }
      this.finishOp(48, 1);
    }
    readToken_eq_excl(e) {
      let r = this.input.charCodeAt(this.state.pos + 1);
      if (r === 61) {
        this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
        return;
      }
      if (e === 61 && r === 62) {
        this.state.pos += 2, this.finishToken(19);
        return;
      }
      this.finishOp(e === 61 ? 29 : 35, 1);
    }
    readToken_question() {
      let e = this.input.charCodeAt(this.state.pos + 1), r = this.input.charCodeAt(this.state.pos + 2);
      e === 63 ? r === 61 ? this.finishOp(30, 3) : this.finishOp(40, 2) : e === 46 && !(r >= 48 && r <= 57) ? (this.state.pos += 2, this.finishToken(
      18)) : (++this.state.pos, this.finishToken(17));
    }
    getTokenFromCode(e) {
      switch (e) {
        case 46:
          this.readToken_dot();
          return;
        case 40:
          ++this.state.pos, this.finishToken(10);
          return;
        case 41:
          ++this.state.pos, this.finishToken(11);
          return;
        case 59:
          ++this.state.pos, this.finishToken(13);
          return;
        case 44:
          ++this.state.pos, this.finishToken(12);
          return;
        case 91:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
              throw this.raise(g.TupleExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
            this.state.pos += 2, this.finishToken(2);
          } else
            ++this.state.pos, this.finishToken(0);
          return;
        case 93:
          ++this.state.pos, this.finishToken(3);
          return;
        case 123:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
              throw this.raise(g.RecordExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
            this.state.pos += 2, this.finishToken(6);
          } else
            ++this.state.pos, this.finishToken(5);
          return;
        case 125:
          ++this.state.pos, this.finishToken(8);
          return;
        case 58:
          this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58 ? this.finishOp(15, 2) : (++this.state.pos, this.
          finishToken(14));
          return;
        case 63:
          this.readToken_question();
          return;
        case 96:
          this.readTemplateToken();
          return;
        case 48: {
          let r = this.input.charCodeAt(this.state.pos + 1);
          if (r === 120 || r === 88) {
            this.readRadixNumber(16);
            return;
          }
          if (r === 111 || r === 79) {
            this.readRadixNumber(8);
            return;
          }
          if (r === 98 || r === 66) {
            this.readRadixNumber(2);
            return;
          }
        }
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          this.readNumber(!1);
          return;
        case 34:
        case 39:
          this.readString(e);
          return;
        case 47:
          this.readToken_slash();
          return;
        case 37:
        case 42:
          this.readToken_mult_modulo(e);
          return;
        case 124:
        case 38:
          this.readToken_pipe_amp(e);
          return;
        case 94:
          this.readToken_caret();
          return;
        case 43:
        case 45:
          this.readToken_plus_min(e);
          return;
        case 60:
          this.readToken_lt();
          return;
        case 62:
          this.readToken_gt();
          return;
        case 61:
        case 33:
          this.readToken_eq_excl(e);
          return;
        case 126:
          this.finishOp(36, 1);
          return;
        case 64:
          this.readToken_atSign();
          return;
        case 35:
          this.readToken_numberSign();
          return;
        case 92:
          this.readWord();
          return;
        default:
          if (Ot(e)) {
            this.readWord(e);
            return;
          }
      }
      throw this.raise(g.InvalidOrUnexpectedToken, this.state.curPosition(), {
        unexpected: String.fromCodePoint(e)
      });
    }
    finishOp(e, r) {
      let i = this.input.slice(this.state.pos, this.state.pos + r);
      this.state.pos += r, this.finishToken(e, i);
    }
    readRegexp() {
      let e = this.state.startLoc, r = this.state.start + 1, i, n, {
        pos: a
      } = this.state;
      for (; ; ++a) {
        if (a >= this.length)
          throw this.raise(g.UnterminatedRegExp, Ze(e, 1));
        let p = this.input.charCodeAt(a);
        if (yr(p))
          throw this.raise(g.UnterminatedRegExp, Ze(e, 1));
        if (i)
          i = !1;
        else {
          if (p === 91)
            n = !0;
          else if (p === 93 && n)
            n = !1;
          else if (p === 47 && !n)
            break;
          i = p === 92;
        }
      }
      let o = this.input.slice(r, a);
      ++a;
      let l = "", u = /* @__PURE__ */ s(() => Ze(e, a + 2 - r), "nextPos");
      for (; a < this.length; ) {
        let p = this.codePointAtPos(a), h = String.fromCharCode(p);
        if (cB.has(p))
          p === 118 ? l.includes("u") && this.raise(g.IncompatibleRegExpUVFlags, u()) : p === 117 && l.includes("v") && this.raise(g.IncompatibleRegExpUVFlags,
          u()), l.includes(h) && this.raise(g.DuplicateRegExpFlags, u());
        else if (mr(p) || p === 92)
          this.raise(g.MalformedRegExpFlags, u());
        else
          break;
        ++a, l += h;
      }
      this.state.pos = a, this.finishToken(138, {
        pattern: o,
        flags: l
      });
    }
    readInt(e, r, i = !1, n = !0) {
      let {
        n: a,
        pos: o
      } = Pp(this.input, this.state.pos, this.state.lineStart, this.state.curLine, e, r, i, n, this.errorHandlers_readInt, !1);
      return this.state.pos = o, a;
    }
    readRadixNumber(e) {
      let r = this.state.pos, i = this.state.curPosition(), n = !1;
      this.state.pos += 2;
      let a = this.readInt(e);
      a == null && this.raise(g.InvalidDigit, Ze(i, 2), {
        radix: e
      });
      let o = this.input.charCodeAt(this.state.pos);
      if (o === 110)
        ++this.state.pos, n = !0;
      else if (o === 109)
        throw this.raise(g.InvalidDecimal, i);
      if (Ot(this.codePointAtPos(this.state.pos)))
        throw this.raise(g.NumberIdentifier, this.state.curPosition());
      if (n) {
        let l = this.input.slice(r, this.state.pos).replace(/[_n]/g, "");
        this.finishToken(136, l);
        return;
      }
      this.finishToken(135, a);
    }
    readNumber(e) {
      let r = this.state.pos, i = this.state.curPosition(), n = !1, a = !1, o = !1, l = !1;
      !e && this.readInt(10) === null && this.raise(g.InvalidNumber, this.state.curPosition());
      let u = this.state.pos - r >= 2 && this.input.charCodeAt(r) === 48;
      if (u) {
        let v = this.input.slice(r, this.state.pos);
        if (this.recordStrictModeErrors(g.StrictOctalLiteral, i), !this.state.strict) {
          let _ = v.indexOf("_");
          _ > 0 && this.raise(g.ZeroDigitNumericSeparator, Ze(i, _));
        }
        l = u && !/[89]/.test(v);
      }
      let p = this.input.charCodeAt(this.state.pos);
      if (p === 46 && !l && (++this.state.pos, this.readInt(10), n = !0, p = this.input.charCodeAt(this.state.pos)), (p === 69 || p === 101) &&
      !l && (p = this.input.charCodeAt(++this.state.pos), (p === 43 || p === 45) && ++this.state.pos, this.readInt(10) === null && this.raise(
      g.InvalidOrMissingExponent, i), n = !0, o = !0, p = this.input.charCodeAt(this.state.pos)), p === 110 && ((n || u) && this.raise(g.InvalidBigIntLiteral,
      i), ++this.state.pos, a = !0), p === 109) {
        this.expectPlugin("decimal", this.state.curPosition()), (o || u) && this.raise(g.InvalidDecimal, i), ++this.state.pos;
        var h = !0;
      }
      if (Ot(this.codePointAtPos(this.state.pos)))
        throw this.raise(g.NumberIdentifier, this.state.curPosition());
      let E = this.input.slice(r, this.state.pos).replace(/[_mn]/g, "");
      if (a) {
        this.finishToken(136, E);
        return;
      }
      if (h) {
        this.finishToken(137, E);
        return;
      }
      let I = l ? parseInt(E, 8) : parseFloat(E);
      this.finishToken(135, I);
    }
    readCodePoint(e) {
      let {
        code: r,
        pos: i
      } = Ap(this.input, this.state.pos, this.state.lineStart, this.state.curLine, e, this.errorHandlers_readCodePoint);
      return this.state.pos = i, r;
    }
    readString(e) {
      let {
        str: r,
        pos: i,
        curLine: n,
        lineStart: a
      } = op(e === 34 ? "double" : "single", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);
      this.state.pos = i + 1, this.state.lineStart = a, this.state.curLine = n, this.finishToken(134, r);
    }
    readTemplateContinuation() {
      this.match(8) || this.unexpected(null, 8), this.state.pos--, this.readTemplateToken();
    }
    readTemplateToken() {
      let e = this.input[this.state.pos], {
        str: r,
        firstInvalidLoc: i,
        pos: n,
        curLine: a,
        lineStart: o
      } = op("template", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);
      this.state.pos = n + 1, this.state.lineStart = o, this.state.curLine = a, i && (this.state.firstInvalidTemplateEscapePos = new Et(i.curLine,
      i.pos - i.lineStart, this.sourceToOffsetPos(i.pos))), this.input.codePointAt(n) === 96 ? this.finishToken(24, i ? null : e + r + "`") :
      (this.state.pos++, this.finishToken(25, i ? null : e + r + "${"));
    }
    recordStrictModeErrors(e, r) {
      let i = r.index;
      this.state.strict && !this.state.strictErrors.has(i) ? this.raise(e, r) : this.state.strictErrors.set(i, [e, r]);
    }
    readWord1(e) {
      this.state.containsEsc = !1;
      let r = "", i = this.state.pos, n = this.state.pos;
      for (e !== void 0 && (this.state.pos += e <= 65535 ? 1 : 2); this.state.pos < this.length; ) {
        let a = this.codePointAtPos(this.state.pos);
        if (mr(a))
          this.state.pos += a <= 65535 ? 1 : 2;
        else if (a === 92) {
          this.state.containsEsc = !0, r += this.input.slice(n, this.state.pos);
          let o = this.state.curPosition(), l = this.state.pos === i ? Ot : mr;
          if (this.input.charCodeAt(++this.state.pos) !== 117) {
            this.raise(g.MissingUnicodeEscape, this.state.curPosition()), n = this.state.pos - 1;
            continue;
          }
          ++this.state.pos;
          let u = this.readCodePoint(!0);
          u !== null && (l(u) || this.raise(g.EscapedCharNotAnIdentifier, o), r += String.fromCodePoint(u)), n = this.state.pos;
        } else
          break;
      }
      return r + this.input.slice(n, this.state.pos);
    }
    readWord(e) {
      let r = this.readWord1(e), i = Eo.get(r);
      i !== void 0 ? this.finishToken(i, Kt(i)) : this.finishToken(132, r);
    }
    checkKeywordEscapes() {
      let {
        type: e
      } = this.state;
      wo(e) && this.state.containsEsc && this.raise(g.InvalidEscapedReservedWord, this.state.startLoc, {
        reservedWord: Kt(e)
      });
    }
    raise(e, r, i = {}) {
      let n = r instanceof Et ? r : r.loc.start, a = e(n, i);
      if (!(this.optionFlags & 2048)) throw a;
      return this.isLookahead || this.state.errors.push(a), a;
    }
    raiseOverwrite(e, r, i = {}) {
      let n = r instanceof Et ? r : r.loc.start, a = n.index, o = this.state.errors;
      for (let l = o.length - 1; l >= 0; l--) {
        let u = o[l];
        if (u.loc.index === a)
          return o[l] = e(n, i);
        if (u.loc.index < a) break;
      }
      return this.raise(e, r, i);
    }
    updateContext(e) {
    }
    unexpected(e, r) {
      throw this.raise(g.UnexpectedToken, e ?? this.state.startLoc, {
        expected: r ? Kt(r) : null
      });
    }
    expectPlugin(e, r) {
      if (this.hasPlugin(e))
        return !0;
      throw this.raise(g.MissingPlugin, r ?? this.state.startLoc, {
        missingPlugin: [e]
      });
    }
    expectOnePlugin(e) {
      if (!e.some((r) => this.hasPlugin(r)))
        throw this.raise(g.MissingOneOfPlugins, this.state.startLoc, {
          missingPlugin: e
        });
    }
    errorBuilder(e) {
      return (r, i, n) => {
        this.raise(e, Wr(r, i, n));
      };
    }
  }, co = class {
    static {
      s(this, "ClassScope");
    }
    constructor() {
      this.privateNames = /* @__PURE__ */ new Set(), this.loneAccessors = /* @__PURE__ */ new Map(), this.undefinedPrivateNames = /* @__PURE__ */ new Map();
    }
  }, po = class {
    static {
      s(this, "ClassScopeHandler");
    }
    constructor(e) {
      this.parser = void 0, this.stack = [], this.undefinedPrivateNames = /* @__PURE__ */ new Map(), this.parser = e;
    }
    current() {
      return this.stack[this.stack.length - 1];
    }
    enter() {
      this.stack.push(new co());
    }
    exit() {
      let e = this.stack.pop(), r = this.current();
      for (let [i, n] of Array.from(e.undefinedPrivateNames))
        r ? r.undefinedPrivateNames.has(i) || r.undefinedPrivateNames.set(i, n) : this.parser.raise(g.InvalidPrivateFieldResolution, n, {
          identifierName: i
        });
    }
    declarePrivateName(e, r, i) {
      let {
        privateNames: n,
        loneAccessors: a,
        undefinedPrivateNames: o
      } = this.current(), l = n.has(e);
      if (r & 3) {
        let u = l && a.get(e);
        if (u) {
          let p = u & 4, h = r & 4, E = u & 3, I = r & 3;
          l = E === I || p !== h, l || a.delete(e);
        } else l || a.set(e, r);
      }
      l && this.parser.raise(g.PrivateNameRedeclaration, i, {
        identifierName: e
      }), n.add(e), o.delete(e);
    }
    usePrivateName(e, r) {
      let i;
      for (i of this.stack)
        if (i.privateNames.has(e)) return;
      i ? i.undefinedPrivateNames.set(e, r) : this.parser.raise(g.InvalidPrivateFieldResolution, r, {
        identifierName: e
      });
    }
  }, br = class {
    static {
      s(this, "ExpressionScope");
    }
    constructor(e = 0) {
      this.type = e;
    }
    canBeArrowParameterDeclaration() {
      return this.type === 2 || this.type === 1;
    }
    isCertainlyParameterDeclaration() {
      return this.type === 3;
    }
  }, ns = class extends br {
    static {
      s(this, "ArrowHeadParsingScope");
    }
    constructor(e) {
      super(e), this.declarationErrors = /* @__PURE__ */ new Map();
    }
    recordDeclarationError(e, r) {
      let i = r.index;
      this.declarationErrors.set(i, [e, r]);
    }
    clearDeclarationError(e) {
      this.declarationErrors.delete(e);
    }
    iterateErrors(e) {
      this.declarationErrors.forEach(e);
    }
  }, fo = class {
    static {
      s(this, "ExpressionScopeHandler");
    }
    constructor(e) {
      this.parser = void 0, this.stack = [new br()], this.parser = e;
    }
    enter(e) {
      this.stack.push(e);
    }
    exit() {
      this.stack.pop();
    }
    recordParameterInitializerError(e, r) {
      let i = r.loc.start, {
        stack: n
      } = this, a = n.length - 1, o = n[a];
      for (; !o.isCertainlyParameterDeclaration(); ) {
        if (o.canBeArrowParameterDeclaration())
          o.recordDeclarationError(e, i);
        else
          return;
        o = n[--a];
      }
      this.parser.raise(e, i);
    }
    recordArrowParameterBindingError(e, r) {
      let {
        stack: i
      } = this, n = i[i.length - 1], a = r.loc.start;
      if (n.isCertainlyParameterDeclaration())
        this.parser.raise(e, a);
      else if (n.canBeArrowParameterDeclaration())
        n.recordDeclarationError(e, a);
      else
        return;
    }
    recordAsyncArrowParametersError(e) {
      let {
        stack: r
      } = this, i = r.length - 1, n = r[i];
      for (; n.canBeArrowParameterDeclaration(); )
        n.type === 2 && n.recordDeclarationError(g.AwaitBindingIdentifier, e), n = r[--i];
    }
    validateAsPattern() {
      let {
        stack: e
      } = this, r = e[e.length - 1];
      r.canBeArrowParameterDeclaration() && r.iterateErrors(([i, n]) => {
        this.parser.raise(i, n);
        let a = e.length - 2, o = e[a];
        for (; o.canBeArrowParameterDeclaration(); )
          o.clearDeclarationError(n.index), o = e[--a];
      });
    }
  };
  function pB() {
    return new br(3);
  }
  s(pB, "newParameterDeclarationScope");
  function fB() {
    return new ns(1);
  }
  s(fB, "newArrowHeadScope");
  function hB() {
    return new ns(2);
  }
  s(hB, "newAsyncArrowScope");
  function Ip() {
    return new br();
  }
  s(Ip, "newExpressionScope");
  var ho = class {
    static {
      s(this, "ProductionParameterHandler");
    }
    constructor() {
      this.stacks = [];
    }
    enter(e) {
      this.stacks.push(e);
    }
    exit() {
      this.stacks.pop();
    }
    currentFlags() {
      return this.stacks[this.stacks.length - 1];
    }
    get hasAwait() {
      return (this.currentFlags() & 2) > 0;
    }
    get hasYield() {
      return (this.currentFlags() & 1) > 0;
    }
    get hasReturn() {
      return (this.currentFlags() & 4) > 0;
    }
    get hasIn() {
      return (this.currentFlags() & 8) > 0;
    }
  };
  function rs(t, e) {
    return (t ? 2 : 0) | (e ? 1 : 0);
  }
  s(rs, "functionFlags");
  var mo = class extends uo {
    static {
      s(this, "UtilParser");
    }
    addExtra(e, r, i, n = !0) {
      if (!e) return;
      let {
        extra: a
      } = e;
      a == null && (a = {}, e.extra = a), n ? a[r] = i : Object.defineProperty(a, r, {
        enumerable: n,
        value: i
      });
    }
    isContextual(e) {
      return this.state.type === e && !this.state.containsEsc;
    }
    isUnparsedContextual(e, r) {
      let i = e + r.length;
      if (this.input.slice(e, i) === r) {
        let n = this.input.charCodeAt(i);
        return !(mr(n) || (n & 64512) === 55296);
      }
      return !1;
    }
    isLookaheadContextual(e) {
      let r = this.nextTokenStart();
      return this.isUnparsedContextual(r, e);
    }
    eatContextual(e) {
      return this.isContextual(e) ? (this.next(), !0) : !1;
    }
    expectContextual(e, r) {
      if (!this.eatContextual(e)) {
        if (r != null)
          throw this.raise(r, this.state.startLoc);
        this.unexpected(null, e);
      }
    }
    canInsertSemicolon() {
      return this.match(140) || this.match(8) || this.hasPrecedingLineBreak();
    }
    hasPrecedingLineBreak() {
      return np(this.input, this.offsetToSourcePos(this.state.lastTokEndLoc.index), this.state.start);
    }
    hasFollowingLineBreak() {
      return np(this.input, this.state.end, this.nextTokenStart());
    }
    isLineTerminator() {
      return this.eat(13) || this.canInsertSemicolon();
    }
    semicolon(e = !0) {
      (e ? this.isLineTerminator() : this.eat(13)) || this.raise(g.MissingSemicolon, this.state.lastTokEndLoc);
    }
    expect(e, r) {
      this.eat(e) || this.unexpected(r, e);
    }
    tryParse(e, r = this.state.clone()) {
      let i = {
        node: null
      };
      try {
        let n = e((a = null) => {
          throw i.node = a, i;
        });
        if (this.state.errors.length > r.errors.length) {
          let a = this.state;
          return this.state = r, this.state.tokensLength = a.tokensLength, {
            node: n,
            error: a.errors[r.errors.length],
            thrown: !1,
            aborted: !1,
            failState: a
          };
        }
        return {
          node: n,
          error: null,
          thrown: !1,
          aborted: !1,
          failState: null
        };
      } catch (n) {
        let a = this.state;
        if (this.state = r, n instanceof SyntaxError)
          return {
            node: null,
            error: n,
            thrown: !0,
            aborted: !1,
            failState: a
          };
        if (n === i)
          return {
            node: i.node,
            error: null,
            thrown: !1,
            aborted: !0,
            failState: a
          };
        throw n;
      }
    }
    checkExpressionErrors(e, r) {
      if (!e) return !1;
      let {
        shorthandAssignLoc: i,
        doubleProtoLoc: n,
        privateKeyLoc: a,
        optionalParametersLoc: o
      } = e, l = !!i || !!n || !!o || !!a;
      if (!r)
        return l;
      i != null && this.raise(g.InvalidCoverInitializedName, i), n != null && this.raise(g.DuplicateProto, n), a != null && this.raise(g.UnexpectedPrivateField,
      a), o != null && this.unexpected(o);
    }
    isLiteralPropertyName() {
      return mp(this.state.type);
    }
    isPrivateName(e) {
      return e.type === "PrivateName";
    }
    getPrivateNameSV(e) {
      return e.id.name;
    }
    hasPropertyAsPrivateName(e) {
      return (e.type === "MemberExpression" || e.type === "OptionalMemberExpression") && this.isPrivateName(e.property);
    }
    isObjectProperty(e) {
      return e.type === "ObjectProperty";
    }
    isObjectMethod(e) {
      return e.type === "ObjectMethod";
    }
    initializeScopes(e = this.options.sourceType === "module") {
      let r = this.state.labels;
      this.state.labels = [];
      let i = this.exportedIdentifiers;
      this.exportedIdentifiers = /* @__PURE__ */ new Set();
      let n = this.inModule;
      this.inModule = e;
      let a = this.scope, o = this.getScopeHandler();
      this.scope = new o(this, e);
      let l = this.prodParam;
      this.prodParam = new ho();
      let u = this.classScope;
      this.classScope = new po(this);
      let p = this.expressionScope;
      return this.expressionScope = new fo(this), () => {
        this.state.labels = r, this.exportedIdentifiers = i, this.inModule = n, this.scope = a, this.prodParam = l, this.classScope = u, this.
        expressionScope = p;
      };
    }
    enterInitialScopes() {
      let e = 0;
      this.inModule && (e |= 2), this.optionFlags & 32 && (e |= 1), this.scope.enter(1), this.prodParam.enter(e);
    }
    checkDestructuringPrivate(e) {
      let {
        privateKeyLoc: r
      } = e;
      r !== null && this.expectPlugin("destructuringPrivate", r);
    }
  }, Tr = class {
    static {
      s(this, "ExpressionErrors");
    }
    constructor() {
      this.shorthandAssignLoc = null, this.doubleProtoLoc = null, this.privateKeyLoc = null, this.optionalParametersLoc = null;
    }
  }, xr = class {
    static {
      s(this, "Node");
    }
    constructor(e, r, i) {
      this.type = "", this.start = r, this.end = 0, this.loc = new Sr(i), e?.optionFlags & 128 && (this.range = [r, 0]), e != null && e.filename &&
      (this.loc.filename = e.filename);
    }
  }, _o = xr.prototype;
  _o.__clone = function() {
    let t = new xr(void 0, this.start, this.loc.start), e = Object.keys(this);
    for (let r = 0, i = e.length; r < i; r++) {
      let n = e[r];
      n !== "leadingComments" && n !== "trailingComments" && n !== "innerComments" && (t[n] = this[n]);
    }
    return t;
  };
  function dB(t) {
    return Dt(t);
  }
  s(dB, "clonePlaceholder");
  function Dt(t) {
    let {
      type: e,
      start: r,
      end: i,
      loc: n,
      range: a,
      extra: o,
      name: l
    } = t, u = Object.create(_o);
    return u.type = e, u.start = r, u.end = i, u.loc = n, u.range = a, u.extra = o, u.name = l, e === "Placeholder" && (u.expectedNode = t.expectedNode),
    u;
  }
  s(Dt, "cloneIdentifier");
  function mB(t) {
    let {
      type: e,
      start: r,
      end: i,
      loc: n,
      range: a,
      extra: o
    } = t;
    if (e === "Placeholder")
      return dB(t);
    let l = Object.create(_o);
    return l.type = e, l.start = r, l.end = i, l.loc = n, l.range = a, t.raw !== void 0 ? l.raw = t.raw : l.extra = o, l.value = t.value, l;
  }
  s(mB, "cloneStringLiteral");
  var yo = class extends mo {
    static {
      s(this, "NodeUtils");
    }
    startNode() {
      let e = this.state.startLoc;
      return new xr(this, e.index, e);
    }
    startNodeAt(e) {
      return new xr(this, e.index, e);
    }
    startNodeAtNode(e) {
      return this.startNodeAt(e.loc.start);
    }
    finishNode(e, r) {
      return this.finishNodeAt(e, r, this.state.lastTokEndLoc);
    }
    finishNodeAt(e, r, i) {
      return e.type = r, e.end = i.index, e.loc.end = i, this.optionFlags & 128 && (e.range[1] = i.index), this.optionFlags & 4096 && this.processComment(
      e), e;
    }
    resetStartLocation(e, r) {
      e.start = r.index, e.loc.start = r, this.optionFlags & 128 && (e.range[0] = r.index);
    }
    resetEndLocation(e, r = this.state.lastTokEndLoc) {
      e.end = r.index, e.loc.end = r, this.optionFlags & 128 && (e.range[1] = r.index);
    }
    resetStartLocationFromNode(e, r) {
      this.resetStartLocation(e, r.loc.start);
    }
  }, yB = /* @__PURE__ */ new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "stat\
ic", "string", "true", "typeof", "void"]), se = _t`flow`({
    AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",
    AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since \
they are either an ES module or they are a CommonJS module.",
    AssignReservedType: /* @__PURE__ */ s(({
      reservedType: t
    }) => `Cannot overwrite reserved type ${t}.`, "AssignReservedType"),
    DeclareClassElement: "The `declare` modifier can only appear on class fields.",
    DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.",
    DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.",
    EnumBooleanMemberNotInitialized: /* @__PURE__ */ s(({
      memberName: t,
      enumName: e
    }) => `Boolean enum members need to be initialized. Use either \`${t} = true,\` or \`${t} = false,\` in enum \`${e}\`.`, "EnumBooleanMem\
berNotInitialized"),
    EnumDuplicateMemberName: /* @__PURE__ */ s(({
      memberName: t,
      enumName: e
    }) => `Enum member names need to be unique, but the name \`${t}\` has already been used before in enum \`${e}\`.`, "EnumDuplicateMemberN\
ame"),
    EnumInconsistentMemberValues: /* @__PURE__ */ s(({
      enumName: t
    }) => `Enum \`${t}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, num\
bers, or strings) for all member initializers.`, "EnumInconsistentMemberValues"),
    EnumInvalidExplicitType: /* @__PURE__ */ s(({
      invalidEnumType: t,
      enumName: e
    }) => `Enum type \`${t}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${e}\`.`, "EnumInvalidEx\
plicitType"),
    EnumInvalidExplicitTypeUnknownSupplied: /* @__PURE__ */ s(({
      enumName: t
    }) => `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${t}\`.`, "EnumInvalidEx\
plicitTypeUnknownSupplied"),
    EnumInvalidMemberInitializerPrimaryType: /* @__PURE__ */ s(({
      enumName: t,
      memberName: e,
      explicitType: r
    }) => `Enum \`${t}\` has type \`${r}\`, so the initializer of \`${e}\` needs to be a ${r} literal.`, "EnumInvalidMemberInitializerPrimar\
yType"),
    EnumInvalidMemberInitializerSymbolType: /* @__PURE__ */ s(({
      enumName: t,
      memberName: e
    }) => `Symbol enum members cannot be initialized. Use \`${e},\` in enum \`${t}\`.`, "EnumInvalidMemberInitializerSymbolType"),
    EnumInvalidMemberInitializerUnknownType: /* @__PURE__ */ s(({
      enumName: t,
      memberName: e
    }) => `The enum member initializer for \`${e}\` needs to be a literal (either a boolean, number, or string) in enum \`${t}\`.`, "EnumInv\
alidMemberInitializerUnknownType"),
    EnumInvalidMemberName: /* @__PURE__ */ s(({
      enumName: t,
      memberName: e,
      suggestion: r
    }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${e}\`, consider using \`${r}\`, in enum \`${t}\
\`.`, "EnumInvalidMemberName"),
    EnumNumberMemberNotInitialized: /* @__PURE__ */ s(({
      enumName: t,
      memberName: e
    }) => `Number enum members need to be initialized, e.g. \`${e} = 1\` in enum \`${t}\`.`, "EnumNumberMemberNotInitialized"),
    EnumStringMemberInconsistentlyInitialized: /* @__PURE__ */ s(({
      enumName: t
    }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${t}\`.`, "EnumStringMemb\
erInconsistentlyInitialized"),
    GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.",
    ImportReflectionHasImportType: "An `import module` declaration can not use `type` or `typeof` keyword.",
    ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements.\
 It cannot be used with `import type` or `import typeof` statements.",
    InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.",
    InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.",
    InexactVariance: "Explicit inexact syntax cannot have variance.",
    InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.",
    MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",
    NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.",
    NestedFlowComment: "Cannot have a flow comment inside another flow comment.",
    PatternIsOptional: Object.assign({
      message: "A binding pattern parameter cannot be optional in an implementation signature."
    }, {
      reasonCode: "OptionalBindingPattern"
    }),
    SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.",
    SpreadVariance: "Spread properties cannot have variance.",
    ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.",
    ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.",
    ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.",
    ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.",
    ThisParamNoDefault: "The `this` parameter may not have a default value.",
    TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`\
.",
    TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.",
    UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.",
    UnexpectedReservedType: /* @__PURE__ */ s(({
      reservedType: t
    }) => `Unexpected reserved type ${t}.`, "UnexpectedReservedType"),
    UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.",
    UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.",
    UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.",
    UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".',
    UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.",
    UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}\
`, use `async <T>() => {}`.",
    UnsupportedDeclareExportKind: /* @__PURE__ */ s(({
      unsupportedExportKind: t,
      suggestion: e
    }) => `\`declare export ${t}\` is not supported. Use \`${e}\` instead.`, "UnsupportedDeclareExportKind"),
    UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.",
    UnterminatedFlowComment: "Unterminated flow-comment."
  });
  function TB(t) {
    return t.type === "DeclareExportAllDeclaration" || t.type === "DeclareExportDeclaration" && (!t.declaration || t.declaration.type !== "T\
ypeAlias" && t.declaration.type !== "InterfaceDeclaration");
  }
  s(TB, "isEsModuleType");
  function lp(t) {
    return t.importKind === "type" || t.importKind === "typeof";
  }
  s(lp, "hasTypeImportKind");
  var SB = {
    const: "declare export var",
    let: "declare export var",
    type: "export type",
    interface: "export interface"
  };
  function bB(t, e) {
    let r = [], i = [];
    for (let n = 0; n < t.length; n++)
      (e(t[n], n, t) ? r : i).push(t[n]);
    return [r, i];
  }
  s(bB, "partition");
  var xB = /\*?\s*@((?:no)?flow)\b/, gB = /* @__PURE__ */ s((t) => class extends t {
    static {
      s(this, "FlowParserMixin");
    }
    constructor(...r) {
      super(...r), this.flowPragma = void 0;
    }
    getScopeHandler() {
      return so;
    }
    shouldParseTypes() {
      return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
    }
    finishToken(r, i) {
      r !== 134 && r !== 13 && r !== 28 && this.flowPragma === void 0 && (this.flowPragma = null), super.finishToken(r, i);
    }
    addComment(r) {
      if (this.flowPragma === void 0) {
        let i = xB.exec(r.value);
        if (i) if (i[1] === "flow")
          this.flowPragma = "flow";
        else if (i[1] === "noflow")
          this.flowPragma = "noflow";
        else
          throw new Error("Unexpected flow pragma");
      }
      super.addComment(r);
    }
    flowParseTypeInitialiser(r) {
      let i = this.state.inType;
      this.state.inType = !0, this.expect(r || 14);
      let n = this.flowParseType();
      return this.state.inType = i, n;
    }
    flowParsePredicate() {
      let r = this.startNode(), i = this.state.startLoc;
      return this.next(), this.expectContextual(110), this.state.lastTokStartLoc.index > i.index + 1 && this.raise(se.UnexpectedSpaceBetweenModuloChecks,
      i), this.eat(10) ? (r.value = super.parseExpression(), this.expect(11), this.finishNode(r, "DeclaredPredicate")) : this.finishNode(r, "\
InferredPredicate");
    }
    flowParseTypeAndPredicateInitialiser() {
      let r = this.state.inType;
      this.state.inType = !0, this.expect(14);
      let i = null, n = null;
      return this.match(54) ? (this.state.inType = r, n = this.flowParsePredicate()) : (i = this.flowParseType(), this.state.inType = r, this.
      match(54) && (n = this.flowParsePredicate())), [i, n];
    }
    flowParseDeclareClass(r) {
      return this.next(), this.flowParseInterfaceish(r, !0), this.finishNode(r, "DeclareClass");
    }
    flowParseDeclareFunction(r) {
      this.next();
      let i = r.id = this.parseIdentifier(), n = this.startNode(), a = this.startNode();
      this.match(47) ? n.typeParameters = this.flowParseTypeParameterDeclaration() : n.typeParameters = null, this.expect(10);
      let o = this.flowParseFunctionTypeParams();
      return n.params = o.params, n.rest = o.rest, n.this = o._this, this.expect(11), [n.returnType, r.predicate] = this.flowParseTypeAndPredicateInitialiser(),
      a.typeAnnotation = this.finishNode(n, "FunctionTypeAnnotation"), i.typeAnnotation = this.finishNode(a, "TypeAnnotation"), this.resetEndLocation(
      i), this.semicolon(), this.scope.declareName(r.id.name, 2048, r.id.loc.start), this.finishNode(r, "DeclareFunction");
    }
    flowParseDeclare(r, i) {
      if (this.match(80))
        return this.flowParseDeclareClass(r);
      if (this.match(68))
        return this.flowParseDeclareFunction(r);
      if (this.match(74))
        return this.flowParseDeclareVariable(r);
      if (this.eatContextual(127))
        return this.match(16) ? this.flowParseDeclareModuleExports(r) : (i && this.raise(se.NestedDeclareModule, this.state.lastTokStartLoc),
        this.flowParseDeclareModule(r));
      if (this.isContextual(130))
        return this.flowParseDeclareTypeAlias(r);
      if (this.isContextual(131))
        return this.flowParseDeclareOpaqueType(r);
      if (this.isContextual(129))
        return this.flowParseDeclareInterface(r);
      if (this.match(82))
        return this.flowParseDeclareExportDeclaration(r, i);
      this.unexpected();
    }
    flowParseDeclareVariable(r) {
      return this.next(), r.id = this.flowParseTypeAnnotatableIdentifier(!0), this.scope.declareName(r.id.name, 5, r.id.loc.start), this.semicolon(),
      this.finishNode(r, "DeclareVariable");
    }
    flowParseDeclareModule(r) {
      this.scope.enter(0), this.match(134) ? r.id = super.parseExprAtom() : r.id = this.parseIdentifier();
      let i = r.body = this.startNode(), n = i.body = [];
      for (this.expect(5); !this.match(8); ) {
        let l = this.startNode();
        this.match(83) ? (this.next(), !this.isContextual(130) && !this.match(87) && this.raise(se.InvalidNonTypeImportInDeclareModule, this.
        state.lastTokStartLoc), super.parseImport(l)) : (this.expectContextual(125, se.UnsupportedStatementInDeclareModule), l = this.flowParseDeclare(
        l, !0)), n.push(l);
      }
      this.scope.exit(), this.expect(8), this.finishNode(i, "BlockStatement");
      let a = null, o = !1;
      return n.forEach((l) => {
        TB(l) ? (a === "CommonJS" && this.raise(se.AmbiguousDeclareModuleKind, l), a = "ES") : l.type === "DeclareModuleExports" && (o && this.
        raise(se.DuplicateDeclareModuleExports, l), a === "ES" && this.raise(se.AmbiguousDeclareModuleKind, l), a = "CommonJS", o = !0);
      }), r.kind = a || "CommonJS", this.finishNode(r, "DeclareModule");
    }
    flowParseDeclareExportDeclaration(r, i) {
      if (this.expect(82), this.eat(65))
        return this.match(68) || this.match(80) ? r.declaration = this.flowParseDeclare(this.startNode()) : (r.declaration = this.flowParseType(),
        this.semicolon()), r.default = !0, this.finishNode(r, "DeclareExportDeclaration");
      if (this.match(75) || this.isLet() || (this.isContextual(130) || this.isContextual(129)) && !i) {
        let n = this.state.value;
        throw this.raise(se.UnsupportedDeclareExportKind, this.state.startLoc, {
          unsupportedExportKind: n,
          suggestion: SB[n]
        });
      }
      if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(131))
        return r.declaration = this.flowParseDeclare(this.startNode()), r.default = !1, this.finishNode(r, "DeclareExportDeclaration");
      if (this.match(55) || this.match(5) || this.isContextual(129) || this.isContextual(130) || this.isContextual(131))
        return r = this.parseExport(r, null), r.type === "ExportNamedDeclaration" && (r.type = "ExportDeclaration", r.default = !1, delete r.
        exportKind), r.type = "Declare" + r.type, r;
      this.unexpected();
    }
    flowParseDeclareModuleExports(r) {
      return this.next(), this.expectContextual(111), r.typeAnnotation = this.flowParseTypeAnnotation(), this.semicolon(), this.finishNode(r,
      "DeclareModuleExports");
    }
    flowParseDeclareTypeAlias(r) {
      this.next();
      let i = this.flowParseTypeAlias(r);
      return i.type = "DeclareTypeAlias", i;
    }
    flowParseDeclareOpaqueType(r) {
      this.next();
      let i = this.flowParseOpaqueType(r, !0);
      return i.type = "DeclareOpaqueType", i;
    }
    flowParseDeclareInterface(r) {
      return this.next(), this.flowParseInterfaceish(r, !1), this.finishNode(r, "DeclareInterface");
    }
    flowParseInterfaceish(r, i) {
      if (r.id = this.flowParseRestrictedIdentifier(!i, !0), this.scope.declareName(r.id.name, i ? 17 : 8201, r.id.loc.start), this.match(47) ?
      r.typeParameters = this.flowParseTypeParameterDeclaration() : r.typeParameters = null, r.extends = [], this.eat(81))
        do
          r.extends.push(this.flowParseInterfaceExtends());
        while (!i && this.eat(12));
      if (i) {
        if (r.implements = [], r.mixins = [], this.eatContextual(117))
          do
            r.mixins.push(this.flowParseInterfaceExtends());
          while (this.eat(12));
        if (this.eatContextual(113))
          do
            r.implements.push(this.flowParseInterfaceExtends());
          while (this.eat(12));
      }
      r.body = this.flowParseObjectType({
        allowStatic: i,
        allowExact: !1,
        allowSpread: !1,
        allowProto: i,
        allowInexact: !1
      });
    }
    flowParseInterfaceExtends() {
      let r = this.startNode();
      return r.id = this.flowParseQualifiedTypeIdentifier(), this.match(47) ? r.typeParameters = this.flowParseTypeParameterInstantiation() :
      r.typeParameters = null, this.finishNode(r, "InterfaceExtends");
    }
    flowParseInterface(r) {
      return this.flowParseInterfaceish(r, !1), this.finishNode(r, "InterfaceDeclaration");
    }
    checkNotUnderscore(r) {
      r === "_" && this.raise(se.UnexpectedReservedUnderscore, this.state.startLoc);
    }
    checkReservedType(r, i, n) {
      yB.has(r) && this.raise(n ? se.AssignReservedType : se.UnexpectedReservedType, i, {
        reservedType: r
      });
    }
    flowParseRestrictedIdentifier(r, i) {
      return this.checkReservedType(this.state.value, this.state.startLoc, i), this.parseIdentifier(r);
    }
    flowParseTypeAlias(r) {
      return r.id = this.flowParseRestrictedIdentifier(!1, !0), this.scope.declareName(r.id.name, 8201, r.id.loc.start), this.match(47) ? r.
      typeParameters = this.flowParseTypeParameterDeclaration() : r.typeParameters = null, r.right = this.flowParseTypeInitialiser(29), this.
      semicolon(), this.finishNode(r, "TypeAlias");
    }
    flowParseOpaqueType(r, i) {
      return this.expectContextual(130), r.id = this.flowParseRestrictedIdentifier(!0, !0), this.scope.declareName(r.id.name, 8201, r.id.loc.
      start), this.match(47) ? r.typeParameters = this.flowParseTypeParameterDeclaration() : r.typeParameters = null, r.supertype = null, this.
      match(14) && (r.supertype = this.flowParseTypeInitialiser(14)), r.impltype = null, i || (r.impltype = this.flowParseTypeInitialiser(29)),
      this.semicolon(), this.finishNode(r, "OpaqueType");
    }
    flowParseTypeParameter(r = !1) {
      let i = this.state.startLoc, n = this.startNode(), a = this.flowParseVariance(), o = this.flowParseTypeAnnotatableIdentifier();
      return n.name = o.name, n.variance = a, n.bound = o.typeAnnotation, this.match(29) ? (this.eat(29), n.default = this.flowParseType()) :
      r && this.raise(se.MissingTypeParamDefault, i), this.finishNode(n, "TypeParameter");
    }
    flowParseTypeParameterDeclaration() {
      let r = this.state.inType, i = this.startNode();
      i.params = [], this.state.inType = !0, this.match(47) || this.match(143) ? this.next() : this.unexpected();
      let n = !1;
      do {
        let a = this.flowParseTypeParameter(n);
        i.params.push(a), a.default && (n = !0), this.match(48) || this.expect(12);
      } while (!this.match(48));
      return this.expect(48), this.state.inType = r, this.finishNode(i, "TypeParameterDeclaration");
    }
    flowInTopLevelContext(r) {
      if (this.curContext() !== Ie.brace) {
        let i = this.state.context;
        this.state.context = [i[0]];
        try {
          return r();
        } finally {
          this.state.context = i;
        }
      } else
        return r();
    }
    flowParseTypeParameterInstantiationInExpression() {
      if (this.reScan_lt() === 47)
        return this.flowParseTypeParameterInstantiation();
    }
    flowParseTypeParameterInstantiation() {
      let r = this.startNode(), i = this.state.inType;
      return this.state.inType = !0, r.params = [], this.flowInTopLevelContext(() => {
        this.expect(47);
        let n = this.state.noAnonFunctionType;
        for (this.state.noAnonFunctionType = !1; !this.match(48); )
          r.params.push(this.flowParseType()), this.match(48) || this.expect(12);
        this.state.noAnonFunctionType = n;
      }), this.state.inType = i, !this.state.inType && this.curContext() === Ie.brace && this.reScan_lt_gt(), this.expect(48), this.finishNode(
      r, "TypeParameterInstantiation");
    }
    flowParseTypeParameterInstantiationCallOrNew() {
      if (this.reScan_lt() !== 47) return;
      let r = this.startNode(), i = this.state.inType;
      for (r.params = [], this.state.inType = !0, this.expect(47); !this.match(48); )
        r.params.push(this.flowParseTypeOrImplicitInstantiation()), this.match(48) || this.expect(12);
      return this.expect(48), this.state.inType = i, this.finishNode(r, "TypeParameterInstantiation");
    }
    flowParseInterfaceType() {
      let r = this.startNode();
      if (this.expectContextual(129), r.extends = [], this.eat(81))
        do
          r.extends.push(this.flowParseInterfaceExtends());
        while (this.eat(12));
      return r.body = this.flowParseObjectType({
        allowStatic: !1,
        allowExact: !1,
        allowSpread: !1,
        allowProto: !1,
        allowInexact: !1
      }), this.finishNode(r, "InterfaceTypeAnnotation");
    }
    flowParseObjectPropertyKey() {
      return this.match(135) || this.match(134) ? super.parseExprAtom() : this.parseIdentifier(!0);
    }
    flowParseObjectTypeIndexer(r, i, n) {
      return r.static = i, this.lookahead().type === 14 ? (r.id = this.flowParseObjectPropertyKey(), r.key = this.flowParseTypeInitialiser()) :
      (r.id = null, r.key = this.flowParseType()), this.expect(3), r.value = this.flowParseTypeInitialiser(), r.variance = n, this.finishNode(
      r, "ObjectTypeIndexer");
    }
    flowParseObjectTypeInternalSlot(r, i) {
      return r.static = i, r.id = this.flowParseObjectPropertyKey(), this.expect(3), this.expect(3), this.match(47) || this.match(10) ? (r.method =
      !0, r.optional = !1, r.value = this.flowParseObjectTypeMethodish(this.startNodeAt(r.loc.start))) : (r.method = !1, this.eat(17) && (r.
      optional = !0), r.value = this.flowParseTypeInitialiser()), this.finishNode(r, "ObjectTypeInternalSlot");
    }
    flowParseObjectTypeMethodish(r) {
      for (r.params = [], r.rest = null, r.typeParameters = null, r.this = null, this.match(47) && (r.typeParameters = this.flowParseTypeParameterDeclaration()),
      this.expect(10), this.match(78) && (r.this = this.flowParseFunctionTypeParam(!0), r.this.name = null, this.match(11) || this.expect(12)); !this.
      match(11) && !this.match(21); )
        r.params.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
      return this.eat(21) && (r.rest = this.flowParseFunctionTypeParam(!1)), this.expect(11), r.returnType = this.flowParseTypeInitialiser(),
      this.finishNode(r, "FunctionTypeAnnotation");
    }
    flowParseObjectTypeCallProperty(r, i) {
      let n = this.startNode();
      return r.static = i, r.value = this.flowParseObjectTypeMethodish(n), this.finishNode(r, "ObjectTypeCallProperty");
    }
    flowParseObjectType({
      allowStatic: r,
      allowExact: i,
      allowSpread: n,
      allowProto: a,
      allowInexact: o
    }) {
      let l = this.state.inType;
      this.state.inType = !0;
      let u = this.startNode();
      u.callProperties = [], u.properties = [], u.indexers = [], u.internalSlots = [];
      let p, h, E = !1;
      for (i && this.match(6) ? (this.expect(6), p = 9, h = !0) : (this.expect(5), p = 8, h = !1), u.exact = h; !this.match(p); ) {
        let v = !1, _ = null, j = null, O = this.startNode();
        if (a && this.isContextual(118)) {
          let B = this.lookahead();
          B.type !== 14 && B.type !== 17 && (this.next(), _ = this.state.startLoc, r = !1);
        }
        if (r && this.isContextual(106)) {
          let B = this.lookahead();
          B.type !== 14 && B.type !== 17 && (this.next(), v = !0);
        }
        let k = this.flowParseVariance();
        if (this.eat(0))
          _ != null && this.unexpected(_), this.eat(0) ? (k && this.unexpected(k.loc.start), u.internalSlots.push(this.flowParseObjectTypeInternalSlot(
          O, v))) : u.indexers.push(this.flowParseObjectTypeIndexer(O, v, k));
        else if (this.match(10) || this.match(47))
          _ != null && this.unexpected(_), k && this.unexpected(k.loc.start), u.callProperties.push(this.flowParseObjectTypeCallProperty(O, v));
        else {
          let B = "init";
          if (this.isContextual(99) || this.isContextual(104)) {
            let K = this.lookahead();
            mp(K.type) && (B = this.state.value, this.next());
          }
          let ue = this.flowParseObjectTypeProperty(O, v, _, k, B, n, o ?? !h);
          ue === null ? (E = !0, j = this.state.lastTokStartLoc) : u.properties.push(ue);
        }
        this.flowObjectTypeSemicolon(), j && !this.match(8) && !this.match(9) && this.raise(se.UnexpectedExplicitInexactInObject, j);
      }
      this.expect(p), n && (u.inexact = E);
      let I = this.finishNode(u, "ObjectTypeAnnotation");
      return this.state.inType = l, I;
    }
    flowParseObjectTypeProperty(r, i, n, a, o, l, u) {
      if (this.eat(21))
        return this.match(12) || this.match(13) || this.match(8) || this.match(9) ? (l ? u || this.raise(se.InexactInsideExact, this.state.lastTokStartLoc) :
        this.raise(se.InexactInsideNonObject, this.state.lastTokStartLoc), a && this.raise(se.InexactVariance, a), null) : (l || this.raise(
        se.UnexpectedSpreadType, this.state.lastTokStartLoc), n != null && this.unexpected(n), a && this.raise(se.SpreadVariance, a), r.argument =
        this.flowParseType(), this.finishNode(r, "ObjectTypeSpreadProperty"));
      {
        r.key = this.flowParseObjectPropertyKey(), r.static = i, r.proto = n != null, r.kind = o;
        let p = !1;
        return this.match(47) || this.match(10) ? (r.method = !0, n != null && this.unexpected(n), a && this.unexpected(a.loc.start), r.value =
        this.flowParseObjectTypeMethodish(this.startNodeAt(r.loc.start)), (o === "get" || o === "set") && this.flowCheckGetterSetterParams(r),
        !l && r.key.name === "constructor" && r.value.this && this.raise(se.ThisParamBannedInConstructor, r.value.this)) : (o !== "init" && this.
        unexpected(), r.method = !1, this.eat(17) && (p = !0), r.value = this.flowParseTypeInitialiser(), r.variance = a), r.optional = p, this.
        finishNode(r, "ObjectTypeProperty");
      }
    }
    flowCheckGetterSetterParams(r) {
      let i = r.kind === "get" ? 0 : 1, n = r.value.params.length + (r.value.rest ? 1 : 0);
      r.value.this && this.raise(r.kind === "get" ? se.GetterMayNotHaveThisParam : se.SetterMayNotHaveThisParam, r.value.this), n !== i && this.
      raise(r.kind === "get" ? g.BadGetterArity : g.BadSetterArity, r), r.kind === "set" && r.value.rest && this.raise(g.BadSetterRestParameter,
      r);
    }
    flowObjectTypeSemicolon() {
      !this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9) && this.unexpected();
    }
    flowParseQualifiedTypeIdentifier(r, i) {
      r ?? (r = this.state.startLoc);
      let n = i || this.flowParseRestrictedIdentifier(!0);
      for (; this.eat(16); ) {
        let a = this.startNodeAt(r);
        a.qualification = n, a.id = this.flowParseRestrictedIdentifier(!0), n = this.finishNode(a, "QualifiedTypeIdentifier");
      }
      return n;
    }
    flowParseGenericType(r, i) {
      let n = this.startNodeAt(r);
      return n.typeParameters = null, n.id = this.flowParseQualifiedTypeIdentifier(r, i), this.match(47) && (n.typeParameters = this.flowParseTypeParameterInstantiation()),
      this.finishNode(n, "GenericTypeAnnotation");
    }
    flowParseTypeofType() {
      let r = this.startNode();
      return this.expect(87), r.argument = this.flowParsePrimaryType(), this.finishNode(r, "TypeofTypeAnnotation");
    }
    flowParseTupleType() {
      let r = this.startNode();
      for (r.types = [], this.expect(0); this.state.pos < this.length && !this.match(3) && (r.types.push(this.flowParseType()), !this.match(
      3)); )
        this.expect(12);
      return this.expect(3), this.finishNode(r, "TupleTypeAnnotation");
    }
    flowParseFunctionTypeParam(r) {
      let i = null, n = !1, a = null, o = this.startNode(), l = this.lookahead(), u = this.state.type === 78;
      return l.type === 14 || l.type === 17 ? (u && !r && this.raise(se.ThisParamMustBeFirst, o), i = this.parseIdentifier(u), this.eat(17) &&
      (n = !0, u && this.raise(se.ThisParamMayNotBeOptional, o)), a = this.flowParseTypeInitialiser()) : a = this.flowParseType(), o.name = i,
      o.optional = n, o.typeAnnotation = a, this.finishNode(o, "FunctionTypeParam");
    }
    reinterpretTypeAsFunctionTypeParam(r) {
      let i = this.startNodeAt(r.loc.start);
      return i.name = null, i.optional = !1, i.typeAnnotation = r, this.finishNode(i, "FunctionTypeParam");
    }
    flowParseFunctionTypeParams(r = []) {
      let i = null, n = null;
      for (this.match(78) && (n = this.flowParseFunctionTypeParam(!0), n.name = null, this.match(11) || this.expect(12)); !this.match(11) &&
      !this.match(21); )
        r.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
      return this.eat(21) && (i = this.flowParseFunctionTypeParam(!1)), {
        params: r,
        rest: i,
        _this: n
      };
    }
    flowIdentToTypeAnnotation(r, i, n) {
      switch (n.name) {
        case "any":
          return this.finishNode(i, "AnyTypeAnnotation");
        case "bool":
        case "boolean":
          return this.finishNode(i, "BooleanTypeAnnotation");
        case "mixed":
          return this.finishNode(i, "MixedTypeAnnotation");
        case "empty":
          return this.finishNode(i, "EmptyTypeAnnotation");
        case "number":
          return this.finishNode(i, "NumberTypeAnnotation");
        case "string":
          return this.finishNode(i, "StringTypeAnnotation");
        case "symbol":
          return this.finishNode(i, "SymbolTypeAnnotation");
        default:
          return this.checkNotUnderscore(n.name), this.flowParseGenericType(r, n);
      }
    }
    flowParsePrimaryType() {
      let r = this.state.startLoc, i = this.startNode(), n, a, o = !1, l = this.state.noAnonFunctionType;
      switch (this.state.type) {
        case 5:
          return this.flowParseObjectType({
            allowStatic: !1,
            allowExact: !1,
            allowSpread: !0,
            allowProto: !1,
            allowInexact: !0
          });
        case 6:
          return this.flowParseObjectType({
            allowStatic: !1,
            allowExact: !0,
            allowSpread: !0,
            allowProto: !1,
            allowInexact: !1
          });
        case 0:
          return this.state.noAnonFunctionType = !1, a = this.flowParseTupleType(), this.state.noAnonFunctionType = l, a;
        case 47: {
          let u = this.startNode();
          return u.typeParameters = this.flowParseTypeParameterDeclaration(), this.expect(10), n = this.flowParseFunctionTypeParams(), u.params =
          n.params, u.rest = n.rest, u.this = n._this, this.expect(11), this.expect(19), u.returnType = this.flowParseType(), this.finishNode(
          u, "FunctionTypeAnnotation");
        }
        case 10: {
          let u = this.startNode();
          if (this.next(), !this.match(11) && !this.match(21))
            if (ve(this.state.type) || this.match(78)) {
              let p = this.lookahead().type;
              o = p !== 17 && p !== 14;
            } else
              o = !0;
          if (o) {
            if (this.state.noAnonFunctionType = !1, a = this.flowParseType(), this.state.noAnonFunctionType = l, this.state.noAnonFunctionType ||
            !(this.match(12) || this.match(11) && this.lookahead().type === 19))
              return this.expect(11), a;
            this.eat(12);
          }
          return a ? n = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(a)]) : n = this.flowParseFunctionTypeParams(),
          u.params = n.params, u.rest = n.rest, u.this = n._this, this.expect(11), this.expect(19), u.returnType = this.flowParseType(), u.typeParameters =
          null, this.finishNode(u, "FunctionTypeAnnotation");
        }
        case 134:
          return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
        case 85:
        case 86:
          return i.value = this.match(85), this.next(), this.finishNode(i, "BooleanLiteralTypeAnnotation");
        case 53:
          if (this.state.value === "-") {
            if (this.next(), this.match(135))
              return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", i);
            if (this.match(136))
              return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", i);
            throw this.raise(se.UnexpectedSubtractionOperand, this.state.startLoc);
          }
          this.unexpected();
          return;
        case 135:
          return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
        case 136:
          return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
        case 88:
          return this.next(), this.finishNode(i, "VoidTypeAnnotation");
        case 84:
          return this.next(), this.finishNode(i, "NullLiteralTypeAnnotation");
        case 78:
          return this.next(), this.finishNode(i, "ThisTypeAnnotation");
        case 55:
          return this.next(), this.finishNode(i, "ExistsTypeAnnotation");
        case 87:
          return this.flowParseTypeofType();
        default:
          if (wo(this.state.type)) {
            let u = Kt(this.state.type);
            return this.next(), super.createIdentifier(i, u);
          } else if (ve(this.state.type))
            return this.isContextual(129) ? this.flowParseInterfaceType() : this.flowIdentToTypeAnnotation(r, i, this.parseIdentifier());
      }
      this.unexpected();
    }
    flowParsePostfixType() {
      let r = this.state.startLoc, i = this.flowParsePrimaryType(), n = !1;
      for (; (this.match(0) || this.match(18)) && !this.canInsertSemicolon(); ) {
        let a = this.startNodeAt(r), o = this.eat(18);
        n = n || o, this.expect(0), !o && this.match(3) ? (a.elementType = i, this.next(), i = this.finishNode(a, "ArrayTypeAnnotation")) : (a.
        objectType = i, a.indexType = this.flowParseType(), this.expect(3), n ? (a.optional = o, i = this.finishNode(a, "OptionalIndexedAcce\
ssType")) : i = this.finishNode(a, "IndexedAccessType"));
      }
      return i;
    }
    flowParsePrefixType() {
      let r = this.startNode();
      return this.eat(17) ? (r.typeAnnotation = this.flowParsePrefixType(), this.finishNode(r, "NullableTypeAnnotation")) : this.flowParsePostfixType();
    }
    flowParseAnonFunctionWithoutParens() {
      let r = this.flowParsePrefixType();
      if (!this.state.noAnonFunctionType && this.eat(19)) {
        let i = this.startNodeAt(r.loc.start);
        return i.params = [this.reinterpretTypeAsFunctionTypeParam(r)], i.rest = null, i.this = null, i.returnType = this.flowParseType(), i.
        typeParameters = null, this.finishNode(i, "FunctionTypeAnnotation");
      }
      return r;
    }
    flowParseIntersectionType() {
      let r = this.startNode();
      this.eat(45);
      let i = this.flowParseAnonFunctionWithoutParens();
      for (r.types = [i]; this.eat(45); )
        r.types.push(this.flowParseAnonFunctionWithoutParens());
      return r.types.length === 1 ? i : this.finishNode(r, "IntersectionTypeAnnotation");
    }
    flowParseUnionType() {
      let r = this.startNode();
      this.eat(43);
      let i = this.flowParseIntersectionType();
      for (r.types = [i]; this.eat(43); )
        r.types.push(this.flowParseIntersectionType());
      return r.types.length === 1 ? i : this.finishNode(r, "UnionTypeAnnotation");
    }
    flowParseType() {
      let r = this.state.inType;
      this.state.inType = !0;
      let i = this.flowParseUnionType();
      return this.state.inType = r, i;
    }
    flowParseTypeOrImplicitInstantiation() {
      if (this.state.type === 132 && this.state.value === "_") {
        let r = this.state.startLoc, i = this.parseIdentifier();
        return this.flowParseGenericType(r, i);
      } else
        return this.flowParseType();
    }
    flowParseTypeAnnotation() {
      let r = this.startNode();
      return r.typeAnnotation = this.flowParseTypeInitialiser(), this.finishNode(r, "TypeAnnotation");
    }
    flowParseTypeAnnotatableIdentifier(r) {
      let i = r ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
      return this.match(14) && (i.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(i)), i;
    }
    typeCastToParameter(r) {
      return r.expression.typeAnnotation = r.typeAnnotation, this.resetEndLocation(r.expression, r.typeAnnotation.loc.end), r.expression;
    }
    flowParseVariance() {
      let r = null;
      return this.match(53) ? (r = this.startNode(), this.state.value === "+" ? r.kind = "plus" : r.kind = "minus", this.next(), this.finishNode(
      r, "Variance")) : r;
    }
    parseFunctionBody(r, i, n = !1) {
      if (i) {
        this.forwardNoArrowParamsConversionAt(r, () => super.parseFunctionBody(r, !0, n));
        return;
      }
      super.parseFunctionBody(r, !1, n);
    }
    parseFunctionBodyAndFinish(r, i, n = !1) {
      if (this.match(14)) {
        let a = this.startNode();
        [a.typeAnnotation, r.predicate] = this.flowParseTypeAndPredicateInitialiser(), r.returnType = a.typeAnnotation ? this.finishNode(a, "\
TypeAnnotation") : null;
      }
      return super.parseFunctionBodyAndFinish(r, i, n);
    }
    parseStatementLike(r) {
      if (this.state.strict && this.isContextual(129)) {
        let n = this.lookahead();
        if (mt(n.type)) {
          let a = this.startNode();
          return this.next(), this.flowParseInterface(a);
        }
      } else if (this.isContextual(126)) {
        let n = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(n);
      }
      let i = super.parseStatementLike(r);
      return this.flowPragma === void 0 && !this.isValidDirective(i) && (this.flowPragma = null), i;
    }
    parseExpressionStatement(r, i, n) {
      if (i.type === "Identifier") {
        if (i.name === "declare") {
          if (this.match(80) || ve(this.state.type) || this.match(68) || this.match(74) || this.match(82))
            return this.flowParseDeclare(r);
        } else if (ve(this.state.type)) {
          if (i.name === "interface")
            return this.flowParseInterface(r);
          if (i.name === "type")
            return this.flowParseTypeAlias(r);
          if (i.name === "opaque")
            return this.flowParseOpaqueType(r, !1);
        }
      }
      return super.parseExpressionStatement(r, i, n);
    }
    shouldParseExportDeclaration() {
      let {
        type: r
      } = this.state;
      return r === 126 || sp(r) ? !this.state.containsEsc : super.shouldParseExportDeclaration();
    }
    isExportDefaultSpecifier() {
      let {
        type: r
      } = this.state;
      return r === 126 || sp(r) ? this.state.containsEsc : super.isExportDefaultSpecifier();
    }
    parseExportDefaultExpression() {
      if (this.isContextual(126)) {
        let r = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(r);
      }
      return super.parseExportDefaultExpression();
    }
    parseConditional(r, i, n) {
      if (!this.match(17)) return r;
      if (this.state.maybeInArrowParameters) {
        let I = this.lookaheadCharCode();
        if (I === 44 || I === 61 || I === 58 || I === 41)
          return this.setOptionalParametersError(n), r;
      }
      this.expect(17);
      let a = this.state.clone(), o = this.state.noArrowAt, l = this.startNodeAt(i), {
        consequent: u,
        failed: p
      } = this.tryParseConditionalConsequent(), [h, E] = this.getArrowLikeExpressions(u);
      if (p || E.length > 0) {
        let I = [...o];
        if (E.length > 0) {
          this.state = a, this.state.noArrowAt = I;
          for (let v = 0; v < E.length; v++)
            I.push(E[v].start);
          ({
            consequent: u,
            failed: p
          } = this.tryParseConditionalConsequent()), [h, E] = this.getArrowLikeExpressions(u);
        }
        p && h.length > 1 && this.raise(se.AmbiguousConditionalArrow, a.startLoc), p && h.length === 1 && (this.state = a, I.push(h[0].start),
        this.state.noArrowAt = I, {
          consequent: u,
          failed: p
        } = this.tryParseConditionalConsequent());
      }
      return this.getArrowLikeExpressions(u, !0), this.state.noArrowAt = o, this.expect(14), l.test = r, l.consequent = u, l.alternate = this.
      forwardNoArrowParamsConversionAt(l, () => this.parseMaybeAssign(void 0, void 0)), this.finishNode(l, "ConditionalExpression");
    }
    tryParseConditionalConsequent() {
      this.state.noArrowParamsConversionAt.push(this.state.start);
      let r = this.parseMaybeAssignAllowIn(), i = !this.match(14);
      return this.state.noArrowParamsConversionAt.pop(), {
        consequent: r,
        failed: i
      };
    }
    getArrowLikeExpressions(r, i) {
      let n = [r], a = [];
      for (; n.length !== 0; ) {
        let o = n.pop();
        o.type === "ArrowFunctionExpression" && o.body.type !== "BlockStatement" ? (o.typeParameters || !o.returnType ? this.finishArrowValidation(
        o) : a.push(o), n.push(o.body)) : o.type === "ConditionalExpression" && (n.push(o.consequent), n.push(o.alternate));
      }
      return i ? (a.forEach((o) => this.finishArrowValidation(o)), [a, []]) : bB(a, (o) => o.params.every((l) => this.isAssignable(l, !0)));
    }
    finishArrowValidation(r) {
      var i;
      this.toAssignableList(r.params, (i = r.extra) == null ? void 0 : i.trailingCommaLoc, !1), this.scope.enter(6), super.checkParams(r, !1,
      !0), this.scope.exit();
    }
    forwardNoArrowParamsConversionAt(r, i) {
      let n;
      return this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(r.start)) ? (this.state.noArrowParamsConversionAt.push(this.
      state.start), n = i(), this.state.noArrowParamsConversionAt.pop()) : n = i(), n;
    }
    parseParenItem(r, i) {
      let n = super.parseParenItem(r, i);
      if (this.eat(17) && (n.optional = !0, this.resetEndLocation(r)), this.match(14)) {
        let a = this.startNodeAt(i);
        return a.expression = n, a.typeAnnotation = this.flowParseTypeAnnotation(), this.finishNode(a, "TypeCastExpression");
      }
      return n;
    }
    assertModuleNodeAllowed(r) {
      r.type === "ImportDeclaration" && (r.importKind === "type" || r.importKind === "typeof") || r.type === "ExportNamedDeclaration" && r.exportKind ===
      "type" || r.type === "ExportAllDeclaration" && r.exportKind === "type" || super.assertModuleNodeAllowed(r);
    }
    parseExportDeclaration(r) {
      if (this.isContextual(130)) {
        r.exportKind = "type";
        let i = this.startNode();
        return this.next(), this.match(5) ? (r.specifiers = this.parseExportSpecifiers(!0), super.parseExportFrom(r), null) : this.flowParseTypeAlias(
        i);
      } else if (this.isContextual(131)) {
        r.exportKind = "type";
        let i = this.startNode();
        return this.next(), this.flowParseOpaqueType(i, !1);
      } else if (this.isContextual(129)) {
        r.exportKind = "type";
        let i = this.startNode();
        return this.next(), this.flowParseInterface(i);
      } else if (this.isContextual(126)) {
        r.exportKind = "value";
        let i = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(i);
      } else
        return super.parseExportDeclaration(r);
    }
    eatExportStar(r) {
      return super.eatExportStar(r) ? !0 : this.isContextual(130) && this.lookahead().type === 55 ? (r.exportKind = "type", this.next(), this.
      next(), !0) : !1;
    }
    maybeParseExportNamespaceSpecifier(r) {
      let {
        startLoc: i
      } = this.state, n = super.maybeParseExportNamespaceSpecifier(r);
      return n && r.exportKind === "type" && this.unexpected(i), n;
    }
    parseClassId(r, i, n) {
      super.parseClassId(r, i, n), this.match(47) && (r.typeParameters = this.flowParseTypeParameterDeclaration());
    }
    parseClassMember(r, i, n) {
      let {
        startLoc: a
      } = this.state;
      if (this.isContextual(125)) {
        if (super.parseClassMemberFromModifier(r, i))
          return;
        i.declare = !0;
      }
      super.parseClassMember(r, i, n), i.declare && (i.type !== "ClassProperty" && i.type !== "ClassPrivateProperty" && i.type !== "Property\
Definition" ? this.raise(se.DeclareClassElement, a) : i.value && this.raise(se.DeclareClassFieldInitializer, i.value));
    }
    isIterator(r) {
      return r === "iterator" || r === "asyncIterator";
    }
    readIterator() {
      let r = super.readWord1(), i = "@@" + r;
      (!this.isIterator(r) || !this.state.inType) && this.raise(g.InvalidIdentifier, this.state.curPosition(), {
        identifierName: i
      }), this.finishToken(132, i);
    }
    getTokenFromCode(r) {
      let i = this.input.charCodeAt(this.state.pos + 1);
      r === 123 && i === 124 ? this.finishOp(6, 2) : this.state.inType && (r === 62 || r === 60) ? this.finishOp(r === 62 ? 48 : 47, 1) : this.
      state.inType && r === 63 ? i === 46 ? this.finishOp(18, 2) : this.finishOp(17, 1) : tB(r, i, this.input.charCodeAt(this.state.pos + 2)) ?
      (this.state.pos += 2, this.readIterator()) : super.getTokenFromCode(r);
    }
    isAssignable(r, i) {
      return r.type === "TypeCastExpression" ? this.isAssignable(r.expression, i) : super.isAssignable(r, i);
    }
    toAssignable(r, i = !1) {
      !i && r.type === "AssignmentExpression" && r.left.type === "TypeCastExpression" && (r.left = this.typeCastToParameter(r.left)), super.
      toAssignable(r, i);
    }
    toAssignableList(r, i, n) {
      for (let a = 0; a < r.length; a++) {
        let o = r[a];
        o?.type === "TypeCastExpression" && (r[a] = this.typeCastToParameter(o));
      }
      super.toAssignableList(r, i, n);
    }
    toReferencedList(r, i) {
      for (let a = 0; a < r.length; a++) {
        var n;
        let o = r[a];
        o && o.type === "TypeCastExpression" && !((n = o.extra) != null && n.parenthesized) && (r.length > 1 || !i) && this.raise(se.TypeCastInPattern,
        o.typeAnnotation);
      }
      return r;
    }
    parseArrayLike(r, i, n, a) {
      let o = super.parseArrayLike(r, i, n, a);
      return i && !this.state.maybeInArrowParameters && this.toReferencedList(o.elements), o;
    }
    isValidLVal(r, i, n) {
      return r === "TypeCastExpression" || super.isValidLVal(r, i, n);
    }
    parseClassProperty(r) {
      return this.match(14) && (r.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassProperty(r);
    }
    parseClassPrivateProperty(r) {
      return this.match(14) && (r.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassPrivateProperty(r);
    }
    isClassMethod() {
      return this.match(47) || super.isClassMethod();
    }
    isClassProperty() {
      return this.match(14) || super.isClassProperty();
    }
    isNonstaticConstructor(r) {
      return !this.match(14) && super.isNonstaticConstructor(r);
    }
    pushClassMethod(r, i, n, a, o, l) {
      if (i.variance && this.unexpected(i.variance.loc.start), delete i.variance, this.match(47) && (i.typeParameters = this.flowParseTypeParameterDeclaration()),
      super.pushClassMethod(r, i, n, a, o, l), i.params && o) {
        let u = i.params;
        u.length > 0 && this.isThisParam(u[0]) && this.raise(se.ThisParamBannedInConstructor, i);
      } else if (i.type === "MethodDefinition" && o && i.value.params) {
        let u = i.value.params;
        u.length > 0 && this.isThisParam(u[0]) && this.raise(se.ThisParamBannedInConstructor, i);
      }
    }
    pushClassPrivateMethod(r, i, n, a) {
      i.variance && this.unexpected(i.variance.loc.start), delete i.variance, this.match(47) && (i.typeParameters = this.flowParseTypeParameterDeclaration()),
      super.pushClassPrivateMethod(r, i, n, a);
    }
    parseClassSuper(r) {
      if (super.parseClassSuper(r), r.superClass && (this.match(47) || this.match(51)) && (r.superTypeParameters = this.flowParseTypeParameterInstantiationInExpression()),
      this.isContextual(113)) {
        this.next();
        let i = r.implements = [];
        do {
          let n = this.startNode();
          n.id = this.flowParseRestrictedIdentifier(!0), this.match(47) ? n.typeParameters = this.flowParseTypeParameterInstantiation() : n.
          typeParameters = null, i.push(this.finishNode(n, "ClassImplements"));
        } while (this.eat(12));
      }
    }
    checkGetterSetterParams(r) {
      super.checkGetterSetterParams(r);
      let i = this.getObjectOrClassMethodParams(r);
      if (i.length > 0) {
        let n = i[0];
        this.isThisParam(n) && r.kind === "get" ? this.raise(se.GetterMayNotHaveThisParam, n) : this.isThisParam(n) && this.raise(se.SetterMayNotHaveThisParam,
        n);
      }
    }
    parsePropertyNamePrefixOperator(r) {
      r.variance = this.flowParseVariance();
    }
    parseObjPropValue(r, i, n, a, o, l, u) {
      r.variance && this.unexpected(r.variance.loc.start), delete r.variance;
      let p;
      this.match(47) && !l && (p = this.flowParseTypeParameterDeclaration(), this.match(10) || this.unexpected());
      let h = super.parseObjPropValue(r, i, n, a, o, l, u);
      return p && ((h.value || h).typeParameters = p), h;
    }
    parseFunctionParamType(r) {
      return this.eat(17) && (r.type !== "Identifier" && this.raise(se.PatternIsOptional, r), this.isThisParam(r) && this.raise(se.ThisParamMayNotBeOptional,
      r), r.optional = !0), this.match(14) ? r.typeAnnotation = this.flowParseTypeAnnotation() : this.isThisParam(r) && this.raise(se.ThisParamAnnotationRequired,
      r), this.match(29) && this.isThisParam(r) && this.raise(se.ThisParamNoDefault, r), this.resetEndLocation(r), r;
    }
    parseMaybeDefault(r, i) {
      let n = super.parseMaybeDefault(r, i);
      return n.type === "AssignmentPattern" && n.typeAnnotation && n.right.start < n.typeAnnotation.start && this.raise(se.TypeBeforeInitializer,
      n.typeAnnotation), n;
    }
    checkImportReflection(r) {
      super.checkImportReflection(r), r.module && r.importKind !== "value" && this.raise(se.ImportReflectionHasImportType, r.specifiers[0].loc.
      start);
    }
    parseImportSpecifierLocal(r, i, n) {
      i.local = lp(r) ? this.flowParseRestrictedIdentifier(!0, !0) : this.parseIdentifier(), r.specifiers.push(this.finishImportSpecifier(i,
      n));
    }
    isPotentialImportPhase(r) {
      if (super.isPotentialImportPhase(r)) return !0;
      if (this.isContextual(130)) {
        if (!r) return !0;
        let i = this.lookaheadCharCode();
        return i === 123 || i === 42;
      }
      return !r && this.isContextual(87);
    }
    applyImportPhase(r, i, n, a) {
      if (super.applyImportPhase(r, i, n, a), i) {
        if (!n && this.match(65))
          return;
        r.exportKind = n === "type" ? n : "value";
      } else
        n === "type" && this.match(55) && this.unexpected(), r.importKind = n === "type" || n === "typeof" ? n : "value";
    }
    parseImportSpecifier(r, i, n, a, o) {
      let l = r.imported, u = null;
      l.type === "Identifier" && (l.name === "type" ? u = "type" : l.name === "typeof" && (u = "typeof"));
      let p = !1;
      if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
        let E = this.parseIdentifier(!0);
        u !== null && !mt(this.state.type) ? (r.imported = E, r.importKind = u, r.local = Dt(E)) : (r.imported = l, r.importKind = null, r.local =
        this.parseIdentifier());
      } else {
        if (u !== null && mt(this.state.type))
          r.imported = this.parseIdentifier(!0), r.importKind = u;
        else {
          if (i)
            throw this.raise(g.ImportBindingIsString, r, {
              importName: l.value
            });
          r.imported = l, r.importKind = null;
        }
        this.eatContextual(93) ? r.local = this.parseIdentifier() : (p = !0, r.local = Dt(r.imported));
      }
      let h = lp(r);
      return n && h && this.raise(se.ImportTypeShorthandOnlyInPureImport, r), (n || h) && this.checkReservedType(r.local.name, r.local.loc.start,
      !0), p && !n && !h && this.checkReservedWord(r.local.name, r.loc.start, !0, !0), this.finishImportSpecifier(r, "ImportSpecifier");
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case 78:
          return this.parseIdentifier(!0);
        default:
          return super.parseBindingAtom();
      }
    }
    parseFunctionParams(r, i) {
      let n = r.kind;
      n !== "get" && n !== "set" && this.match(47) && (r.typeParameters = this.flowParseTypeParameterDeclaration()), super.parseFunctionParams(
      r, i);
    }
    parseVarId(r, i) {
      super.parseVarId(r, i), this.match(14) && (r.id.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(r.id));
    }
    parseAsyncArrowFromCallExpression(r, i) {
      if (this.match(14)) {
        let n = this.state.noAnonFunctionType;
        this.state.noAnonFunctionType = !0, r.returnType = this.flowParseTypeAnnotation(), this.state.noAnonFunctionType = n;
      }
      return super.parseAsyncArrowFromCallExpression(r, i);
    }
    shouldParseAsyncArrow() {
      return this.match(14) || super.shouldParseAsyncArrow();
    }
    parseMaybeAssign(r, i) {
      var n;
      let a = null, o;
      if (this.hasPlugin("jsx") && (this.match(143) || this.match(47))) {
        if (a = this.state.clone(), o = this.tryParse(() => super.parseMaybeAssign(r, i), a), !o.error) return o.node;
        let {
          context: p
        } = this.state, h = p[p.length - 1];
        (h === Ie.j_oTag || h === Ie.j_expr) && p.pop();
      }
      if ((n = o) != null && n.error || this.match(47)) {
        var l, u;
        a = a || this.state.clone();
        let p, h = this.tryParse((I) => {
          var v;
          p = this.flowParseTypeParameterDeclaration();
          let _ = this.forwardNoArrowParamsConversionAt(p, () => {
            let O = super.parseMaybeAssign(r, i);
            return this.resetStartLocationFromNode(O, p), O;
          });
          (v = _.extra) != null && v.parenthesized && I();
          let j = this.maybeUnwrapTypeCastExpression(_);
          return j.type !== "ArrowFunctionExpression" && I(), j.typeParameters = p, this.resetStartLocationFromNode(j, p), _;
        }, a), E = null;
        if (h.node && this.maybeUnwrapTypeCastExpression(h.node).type === "ArrowFunctionExpression") {
          if (!h.error && !h.aborted)
            return h.node.async && this.raise(se.UnexpectedTypeParameterBeforeAsyncArrowFunction, p), h.node;
          E = h.node;
        }
        if ((l = o) != null && l.node)
          return this.state = o.failState, o.node;
        if (E)
          return this.state = h.failState, E;
        throw (u = o) != null && u.thrown ? o.error : h.thrown ? h.error : this.raise(se.UnexpectedTokenAfterTypeParameter, p);
      }
      return super.parseMaybeAssign(r, i);
    }
    parseArrow(r) {
      if (this.match(14)) {
        let i = this.tryParse(() => {
          let n = this.state.noAnonFunctionType;
          this.state.noAnonFunctionType = !0;
          let a = this.startNode();
          return [a.typeAnnotation, r.predicate] = this.flowParseTypeAndPredicateInitialiser(), this.state.noAnonFunctionType = n, this.canInsertSemicolon() &&
          this.unexpected(), this.match(19) || this.unexpected(), a;
        });
        if (i.thrown) return null;
        i.error && (this.state = i.failState), r.returnType = i.node.typeAnnotation ? this.finishNode(i.node, "TypeAnnotation") : null;
      }
      return super.parseArrow(r);
    }
    shouldParseArrow(r) {
      return this.match(14) || super.shouldParseArrow(r);
    }
    setArrowFunctionParameters(r, i) {
      this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(r.start)) ? r.params = i : super.setArrowFunctionParameters(r, i);
    }
    checkParams(r, i, n, a = !0) {
      if (!(n && this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(r.start)))) {
        for (let o = 0; o < r.params.length; o++)
          this.isThisParam(r.params[o]) && o > 0 && this.raise(se.ThisParamMustBeFirst, r.params[o]);
        super.checkParams(r, i, n, a);
      }
    }
    parseParenAndDistinguishExpression(r) {
      return super.parseParenAndDistinguishExpression(r && !this.state.noArrowAt.includes(this.sourceToOffsetPos(this.state.start)));
    }
    parseSubscripts(r, i, n) {
      if (r.type === "Identifier" && r.name === "async" && this.state.noArrowAt.includes(i.index)) {
        this.next();
        let a = this.startNodeAt(i);
        a.callee = r, a.arguments = super.parseCallExpressionArguments(11), r = this.finishNode(a, "CallExpression");
      } else if (r.type === "Identifier" && r.name === "async" && this.match(47)) {
        let a = this.state.clone(), o = this.tryParse((u) => this.parseAsyncArrowWithTypeParameters(i) || u(), a);
        if (!o.error && !o.aborted) return o.node;
        let l = this.tryParse(() => super.parseSubscripts(r, i, n), a);
        if (l.node && !l.error) return l.node;
        if (o.node)
          return this.state = o.failState, o.node;
        if (l.node)
          return this.state = l.failState, l.node;
        throw o.error || l.error;
      }
      return super.parseSubscripts(r, i, n);
    }
    parseSubscript(r, i, n, a) {
      if (this.match(18) && this.isLookaheadToken_lt()) {
        if (a.optionalChainMember = !0, n)
          return a.stop = !0, r;
        this.next();
        let o = this.startNodeAt(i);
        return o.callee = r, o.typeArguments = this.flowParseTypeParameterInstantiationInExpression(), this.expect(10), o.arguments = this.parseCallExpressionArguments(
        11), o.optional = !0, this.finishCallExpression(o, !0);
      } else if (!n && this.shouldParseTypes() && (this.match(47) || this.match(51))) {
        let o = this.startNodeAt(i);
        o.callee = r;
        let l = this.tryParse(() => (o.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew(), this.expect(10), o.arguments = super.
        parseCallExpressionArguments(11), a.optionalChainMember && (o.optional = !1), this.finishCallExpression(o, a.optionalChainMember)));
        if (l.node)
          return l.error && (this.state = l.failState), l.node;
      }
      return super.parseSubscript(r, i, n, a);
    }
    parseNewCallee(r) {
      super.parseNewCallee(r);
      let i = null;
      this.shouldParseTypes() && this.match(47) && (i = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node), r.typeArguments =
      i;
    }
    parseAsyncArrowWithTypeParameters(r) {
      let i = this.startNodeAt(r);
      if (this.parseFunctionParams(i, !1), !!this.parseArrow(i))
        return super.parseArrowExpression(i, void 0, !0);
    }
    readToken_mult_modulo(r) {
      let i = this.input.charCodeAt(this.state.pos + 1);
      if (r === 42 && i === 47 && this.state.hasFlowComment) {
        this.state.hasFlowComment = !1, this.state.pos += 2, this.nextToken();
        return;
      }
      super.readToken_mult_modulo(r);
    }
    readToken_pipe_amp(r) {
      let i = this.input.charCodeAt(this.state.pos + 1);
      if (r === 124 && i === 125) {
        this.finishOp(9, 2);
        return;
      }
      super.readToken_pipe_amp(r);
    }
    parseTopLevel(r, i) {
      let n = super.parseTopLevel(r, i);
      return this.state.hasFlowComment && this.raise(se.UnterminatedFlowComment, this.state.curPosition()), n;
    }
    skipBlockComment() {
      if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
        if (this.state.hasFlowComment)
          throw this.raise(se.NestedFlowComment, this.state.startLoc);
        this.hasFlowCommentCompletion();
        let r = this.skipFlowComment();
        r && (this.state.pos += r, this.state.hasFlowComment = !0);
        return;
      }
      return super.skipBlockComment(this.state.hasFlowComment ? "*-/" : "*/");
    }
    skipFlowComment() {
      let {
        pos: r
      } = this.state, i = 2;
      for (; [32, 9].includes(this.input.charCodeAt(r + i)); )
        i++;
      let n = this.input.charCodeAt(i + r), a = this.input.charCodeAt(i + r + 1);
      return n === 58 && a === 58 ? i + 2 : this.input.slice(i + r, i + r + 12) === "flow-include" ? i + 12 : n === 58 && a !== 58 ? i : !1;
    }
    hasFlowCommentCompletion() {
      if (this.input.indexOf("*/", this.state.pos) === -1)
        throw this.raise(g.UnterminatedComment, this.state.curPosition());
    }
    flowEnumErrorBooleanMemberNotInitialized(r, {
      enumName: i,
      memberName: n
    }) {
      this.raise(se.EnumBooleanMemberNotInitialized, r, {
        memberName: n,
        enumName: i
      });
    }
    flowEnumErrorInvalidMemberInitializer(r, i) {
      return this.raise(i.explicitType ? i.explicitType === "symbol" ? se.EnumInvalidMemberInitializerSymbolType : se.EnumInvalidMemberInitializerPrimaryType :
      se.EnumInvalidMemberInitializerUnknownType, r, i);
    }
    flowEnumErrorNumberMemberNotInitialized(r, i) {
      this.raise(se.EnumNumberMemberNotInitialized, r, i);
    }
    flowEnumErrorStringMemberInconsistentlyInitialized(r, i) {
      this.raise(se.EnumStringMemberInconsistentlyInitialized, r, i);
    }
    flowEnumMemberInit() {
      let r = this.state.startLoc, i = /* @__PURE__ */ s(() => this.match(12) || this.match(8), "endOfInit");
      switch (this.state.type) {
        case 135: {
          let n = this.parseNumericLiteral(this.state.value);
          return i() ? {
            type: "number",
            loc: n.loc.start,
            value: n
          } : {
            type: "invalid",
            loc: r
          };
        }
        case 134: {
          let n = this.parseStringLiteral(this.state.value);
          return i() ? {
            type: "string",
            loc: n.loc.start,
            value: n
          } : {
            type: "invalid",
            loc: r
          };
        }
        case 85:
        case 86: {
          let n = this.parseBooleanLiteral(this.match(85));
          return i() ? {
            type: "boolean",
            loc: n.loc.start,
            value: n
          } : {
            type: "invalid",
            loc: r
          };
        }
        default:
          return {
            type: "invalid",
            loc: r
          };
      }
    }
    flowEnumMemberRaw() {
      let r = this.state.startLoc, i = this.parseIdentifier(!0), n = this.eat(29) ? this.flowEnumMemberInit() : {
        type: "none",
        loc: r
      };
      return {
        id: i,
        init: n
      };
    }
    flowEnumCheckExplicitTypeMismatch(r, i, n) {
      let {
        explicitType: a
      } = i;
      a !== null && a !== n && this.flowEnumErrorInvalidMemberInitializer(r, i);
    }
    flowEnumMembers({
      enumName: r,
      explicitType: i
    }) {
      let n = /* @__PURE__ */ new Set(), a = {
        booleanMembers: [],
        numberMembers: [],
        stringMembers: [],
        defaultedMembers: []
      }, o = !1;
      for (; !this.match(8); ) {
        if (this.eat(21)) {
          o = !0;
          break;
        }
        let l = this.startNode(), {
          id: u,
          init: p
        } = this.flowEnumMemberRaw(), h = u.name;
        if (h === "")
          continue;
        /^[a-z]/.test(h) && this.raise(se.EnumInvalidMemberName, u, {
          memberName: h,
          suggestion: h[0].toUpperCase() + h.slice(1),
          enumName: r
        }), n.has(h) && this.raise(se.EnumDuplicateMemberName, u, {
          memberName: h,
          enumName: r
        }), n.add(h);
        let E = {
          enumName: r,
          explicitType: i,
          memberName: h
        };
        switch (l.id = u, p.type) {
          case "boolean": {
            this.flowEnumCheckExplicitTypeMismatch(p.loc, E, "boolean"), l.init = p.value, a.booleanMembers.push(this.finishNode(l, "EnumBoo\
leanMember"));
            break;
          }
          case "number": {
            this.flowEnumCheckExplicitTypeMismatch(p.loc, E, "number"), l.init = p.value, a.numberMembers.push(this.finishNode(l, "EnumNumbe\
rMember"));
            break;
          }
          case "string": {
            this.flowEnumCheckExplicitTypeMismatch(p.loc, E, "string"), l.init = p.value, a.stringMembers.push(this.finishNode(l, "EnumStrin\
gMember"));
            break;
          }
          case "invalid":
            throw this.flowEnumErrorInvalidMemberInitializer(p.loc, E);
          case "none":
            switch (i) {
              case "boolean":
                this.flowEnumErrorBooleanMemberNotInitialized(p.loc, E);
                break;
              case "number":
                this.flowEnumErrorNumberMemberNotInitialized(p.loc, E);
                break;
              default:
                a.defaultedMembers.push(this.finishNode(l, "EnumDefaultedMember"));
            }
        }
        this.match(8) || this.expect(12);
      }
      return {
        members: a,
        hasUnknownMembers: o
      };
    }
    flowEnumStringMembers(r, i, {
      enumName: n
    }) {
      if (r.length === 0)
        return i;
      if (i.length === 0)
        return r;
      if (i.length > r.length) {
        for (let a of r)
          this.flowEnumErrorStringMemberInconsistentlyInitialized(a, {
            enumName: n
          });
        return i;
      } else {
        for (let a of i)
          this.flowEnumErrorStringMemberInconsistentlyInitialized(a, {
            enumName: n
          });
        return r;
      }
    }
    flowEnumParseExplicitType({
      enumName: r
    }) {
      if (!this.eatContextual(102)) return null;
      if (!ve(this.state.type))
        throw this.raise(se.EnumInvalidExplicitTypeUnknownSupplied, this.state.startLoc, {
          enumName: r
        });
      let {
        value: i
      } = this.state;
      return this.next(), i !== "boolean" && i !== "number" && i !== "string" && i !== "symbol" && this.raise(se.EnumInvalidExplicitType, this.
      state.startLoc, {
        enumName: r,
        invalidEnumType: i
      }), i;
    }
    flowEnumBody(r, i) {
      let n = i.name, a = i.loc.start, o = this.flowEnumParseExplicitType({
        enumName: n
      });
      this.expect(5);
      let {
        members: l,
        hasUnknownMembers: u
      } = this.flowEnumMembers({
        enumName: n,
        explicitType: o
      });
      switch (r.hasUnknownMembers = u, o) {
        case "boolean":
          return r.explicitType = !0, r.members = l.booleanMembers, this.expect(8), this.finishNode(r, "EnumBooleanBody");
        case "number":
          return r.explicitType = !0, r.members = l.numberMembers, this.expect(8), this.finishNode(r, "EnumNumberBody");
        case "string":
          return r.explicitType = !0, r.members = this.flowEnumStringMembers(l.stringMembers, l.defaultedMembers, {
            enumName: n
          }), this.expect(8), this.finishNode(r, "EnumStringBody");
        case "symbol":
          return r.members = l.defaultedMembers, this.expect(8), this.finishNode(r, "EnumSymbolBody");
        default: {
          let p = /* @__PURE__ */ s(() => (r.members = [], this.expect(8), this.finishNode(r, "EnumStringBody")), "empty");
          r.explicitType = !1;
          let h = l.booleanMembers.length, E = l.numberMembers.length, I = l.stringMembers.length, v = l.defaultedMembers.length;
          if (!h && !E && !I && !v)
            return p();
          if (!h && !E)
            return r.members = this.flowEnumStringMembers(l.stringMembers, l.defaultedMembers, {
              enumName: n
            }), this.expect(8), this.finishNode(r, "EnumStringBody");
          if (!E && !I && h >= v) {
            for (let _ of l.defaultedMembers)
              this.flowEnumErrorBooleanMemberNotInitialized(_.loc.start, {
                enumName: n,
                memberName: _.id.name
              });
            return r.members = l.booleanMembers, this.expect(8), this.finishNode(r, "EnumBooleanBody");
          } else if (!h && !I && E >= v) {
            for (let _ of l.defaultedMembers)
              this.flowEnumErrorNumberMemberNotInitialized(_.loc.start, {
                enumName: n,
                memberName: _.id.name
              });
            return r.members = l.numberMembers, this.expect(8), this.finishNode(r, "EnumNumberBody");
          } else
            return this.raise(se.EnumInconsistentMemberValues, a, {
              enumName: n
            }), p();
        }
      }
    }
    flowParseEnumDeclaration(r) {
      let i = this.parseIdentifier();
      return r.id = i, r.body = this.flowEnumBody(this.startNode(), i), this.finishNode(r, "EnumDeclaration");
    }
    jsxParseOpeningElementAfterName(r) {
      return this.shouldParseTypes() && (this.match(47) || this.match(51)) && (r.typeArguments = this.flowParseTypeParameterInstantiationInExpression()),
      super.jsxParseOpeningElementAfterName(r);
    }
    isLookaheadToken_lt() {
      let r = this.nextTokenStart();
      if (this.input.charCodeAt(r) === 60) {
        let i = this.input.charCodeAt(r + 1);
        return i !== 60 && i !== 61;
      }
      return !1;
    }
    reScan_lt_gt() {
      let {
        type: r
      } = this.state;
      r === 47 ? (this.state.pos -= 1, this.readToken_lt()) : r === 48 && (this.state.pos -= 1, this.readToken_gt());
    }
    reScan_lt() {
      let {
        type: r
      } = this.state;
      return r === 51 ? (this.state.pos -= 2, this.finishOp(47, 1), 47) : r;
    }
    maybeUnwrapTypeCastExpression(r) {
      return r.type === "TypeCastExpression" ? r.expression : r;
    }
  }, "flow"), EB = {
    __proto__: null,
    quot: '"',
    amp: "&",
    apos: "'",
    lt: "<",
    gt: ">",
    nbsp: "\xA0",
    iexcl: "\xA1",
    cent: "\xA2",
    pound: "\xA3",
    curren: "\xA4",
    yen: "\xA5",
    brvbar: "\xA6",
    sect: "\xA7",
    uml: "\xA8",
    copy: "\xA9",
    ordf: "\xAA",
    laquo: "\xAB",
    not: "\xAC",
    shy: "\xAD",
    reg: "\xAE",
    macr: "\xAF",
    deg: "\xB0",
    plusmn: "\xB1",
    sup2: "\xB2",
    sup3: "\xB3",
    acute: "\xB4",
    micro: "\xB5",
    para: "\xB6",
    middot: "\xB7",
    cedil: "\xB8",
    sup1: "\xB9",
    ordm: "\xBA",
    raquo: "\xBB",
    frac14: "\xBC",
    frac12: "\xBD",
    frac34: "\xBE",
    iquest: "\xBF",
    Agrave: "\xC0",
    Aacute: "\xC1",
    Acirc: "\xC2",
    Atilde: "\xC3",
    Auml: "\xC4",
    Aring: "\xC5",
    AElig: "\xC6",
    Ccedil: "\xC7",
    Egrave: "\xC8",
    Eacute: "\xC9",
    Ecirc: "\xCA",
    Euml: "\xCB",
    Igrave: "\xCC",
    Iacute: "\xCD",
    Icirc: "\xCE",
    Iuml: "\xCF",
    ETH: "\xD0",
    Ntilde: "\xD1",
    Ograve: "\xD2",
    Oacute: "\xD3",
    Ocirc: "\xD4",
    Otilde: "\xD5",
    Ouml: "\xD6",
    times: "\xD7",
    Oslash: "\xD8",
    Ugrave: "\xD9",
    Uacute: "\xDA",
    Ucirc: "\xDB",
    Uuml: "\xDC",
    Yacute: "\xDD",
    THORN: "\xDE",
    szlig: "\xDF",
    agrave: "\xE0",
    aacute: "\xE1",
    acirc: "\xE2",
    atilde: "\xE3",
    auml: "\xE4",
    aring: "\xE5",
    aelig: "\xE6",
    ccedil: "\xE7",
    egrave: "\xE8",
    eacute: "\xE9",
    ecirc: "\xEA",
    euml: "\xEB",
    igrave: "\xEC",
    iacute: "\xED",
    icirc: "\xEE",
    iuml: "\xEF",
    eth: "\xF0",
    ntilde: "\xF1",
    ograve: "\xF2",
    oacute: "\xF3",
    ocirc: "\xF4",
    otilde: "\xF5",
    ouml: "\xF6",
    divide: "\xF7",
    oslash: "\xF8",
    ugrave: "\xF9",
    uacute: "\xFA",
    ucirc: "\xFB",
    uuml: "\xFC",
    yacute: "\xFD",
    thorn: "\xFE",
    yuml: "\xFF",
    OElig: "\u0152",
    oelig: "\u0153",
    Scaron: "\u0160",
    scaron: "\u0161",
    Yuml: "\u0178",
    fnof: "\u0192",
    circ: "\u02C6",
    tilde: "\u02DC",
    Alpha: "\u0391",
    Beta: "\u0392",
    Gamma: "\u0393",
    Delta: "\u0394",
    Epsilon: "\u0395",
    Zeta: "\u0396",
    Eta: "\u0397",
    Theta: "\u0398",
    Iota: "\u0399",
    Kappa: "\u039A",
    Lambda: "\u039B",
    Mu: "\u039C",
    Nu: "\u039D",
    Xi: "\u039E",
    Omicron: "\u039F",
    Pi: "\u03A0",
    Rho: "\u03A1",
    Sigma: "\u03A3",
    Tau: "\u03A4",
    Upsilon: "\u03A5",
    Phi: "\u03A6",
    Chi: "\u03A7",
    Psi: "\u03A8",
    Omega: "\u03A9",
    alpha: "\u03B1",
    beta: "\u03B2",
    gamma: "\u03B3",
    delta: "\u03B4",
    epsilon: "\u03B5",
    zeta: "\u03B6",
    eta: "\u03B7",
    theta: "\u03B8",
    iota: "\u03B9",
    kappa: "\u03BA",
    lambda: "\u03BB",
    mu: "\u03BC",
    nu: "\u03BD",
    xi: "\u03BE",
    omicron: "\u03BF",
    pi: "\u03C0",
    rho: "\u03C1",
    sigmaf: "\u03C2",
    sigma: "\u03C3",
    tau: "\u03C4",
    upsilon: "\u03C5",
    phi: "\u03C6",
    chi: "\u03C7",
    psi: "\u03C8",
    omega: "\u03C9",
    thetasym: "\u03D1",
    upsih: "\u03D2",
    piv: "\u03D6",
    ensp: "\u2002",
    emsp: "\u2003",
    thinsp: "\u2009",
    zwnj: "\u200C",
    zwj: "\u200D",
    lrm: "\u200E",
    rlm: "\u200F",
    ndash: "\u2013",
    mdash: "\u2014",
    lsquo: "\u2018",
    rsquo: "\u2019",
    sbquo: "\u201A",
    ldquo: "\u201C",
    rdquo: "\u201D",
    bdquo: "\u201E",
    dagger: "\u2020",
    Dagger: "\u2021",
    bull: "\u2022",
    hellip: "\u2026",
    permil: "\u2030",
    prime: "\u2032",
    Prime: "\u2033",
    lsaquo: "\u2039",
    rsaquo: "\u203A",
    oline: "\u203E",
    frasl: "\u2044",
    euro: "\u20AC",
    image: "\u2111",
    weierp: "\u2118",
    real: "\u211C",
    trade: "\u2122",
    alefsym: "\u2135",
    larr: "\u2190",
    uarr: "\u2191",
    rarr: "\u2192",
    darr: "\u2193",
    harr: "\u2194",
    crarr: "\u21B5",
    lArr: "\u21D0",
    uArr: "\u21D1",
    rArr: "\u21D2",
    dArr: "\u21D3",
    hArr: "\u21D4",
    forall: "\u2200",
    part: "\u2202",
    exist: "\u2203",
    empty: "\u2205",
    nabla: "\u2207",
    isin: "\u2208",
    notin: "\u2209",
    ni: "\u220B",
    prod: "\u220F",
    sum: "\u2211",
    minus: "\u2212",
    lowast: "\u2217",
    radic: "\u221A",
    prop: "\u221D",
    infin: "\u221E",
    ang: "\u2220",
    and: "\u2227",
    or: "\u2228",
    cap: "\u2229",
    cup: "\u222A",
    int: "\u222B",
    there4: "\u2234",
    sim: "\u223C",
    cong: "\u2245",
    asymp: "\u2248",
    ne: "\u2260",
    equiv: "\u2261",
    le: "\u2264",
    ge: "\u2265",
    sub: "\u2282",
    sup: "\u2283",
    nsub: "\u2284",
    sube: "\u2286",
    supe: "\u2287",
    oplus: "\u2295",
    otimes: "\u2297",
    perp: "\u22A5",
    sdot: "\u22C5",
    lceil: "\u2308",
    rceil: "\u2309",
    lfloor: "\u230A",
    rfloor: "\u230B",
    lang: "\u2329",
    rang: "\u232A",
    loz: "\u25CA",
    spades: "\u2660",
    clubs: "\u2663",
    hearts: "\u2665",
    diams: "\u2666"
  }, Zt = _t`jsx`({
    AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.",
    MissingClosingTagElement: /* @__PURE__ */ s(({
      openingTagName: t
    }) => `Expected corresponding JSX closing tag for <${t}>.`, "MissingClosingTagElement"),
    MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.",
    UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?",
    UnexpectedToken: /* @__PURE__ */ s(({
      unexpected: t,
      HTMLEntity: e
    }) => `Unexpected token \`${t}\`. Did you mean \`${e}\` or \`{'${t}'}\`?`, "UnexpectedToken"),
    UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.",
    UnterminatedJsxContent: "Unterminated JSX contents.",
    UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"
  });
  function Ut(t) {
    return t ? t.type === "JSXOpeningFragment" || t.type === "JSXClosingFragment" : !1;
  }
  s(Ut, "isFragment");
  function dr(t) {
    if (t.type === "JSXIdentifier")
      return t.name;
    if (t.type === "JSXNamespacedName")
      return t.namespace.name + ":" + t.name.name;
    if (t.type === "JSXMemberExpression")
      return dr(t.object) + "." + dr(t.property);
    throw new Error("Node had unexpected type: " + t.type);
  }
  s(dr, "getQualifiedJSXName");
  var PB = /* @__PURE__ */ s((t) => class extends t {
    static {
      s(this, "JSXParserMixin");
    }
    jsxReadToken() {
      let r = "", i = this.state.pos;
      for (; ; ) {
        if (this.state.pos >= this.length)
          throw this.raise(Zt.UnterminatedJsxContent, this.state.startLoc);
        let n = this.input.charCodeAt(this.state.pos);
        switch (n) {
          case 60:
          case 123:
            if (this.state.pos === this.state.start) {
              n === 60 && this.state.canStartJSXElement ? (++this.state.pos, this.finishToken(143)) : super.getTokenFromCode(n);
              return;
            }
            r += this.input.slice(i, this.state.pos), this.finishToken(142, r);
            return;
          case 38:
            r += this.input.slice(i, this.state.pos), r += this.jsxReadEntity(), i = this.state.pos;
            break;
          case 62:
          case 125:
          default:
            yr(n) ? (r += this.input.slice(i, this.state.pos), r += this.jsxReadNewLine(!0), i = this.state.pos) : ++this.state.pos;
        }
      }
    }
    jsxReadNewLine(r) {
      let i = this.input.charCodeAt(this.state.pos), n;
      return ++this.state.pos, i === 13 && this.input.charCodeAt(this.state.pos) === 10 ? (++this.state.pos, n = r ? `
` : `\r
`) : n = String.fromCharCode(i), ++this.state.curLine, this.state.lineStart = this.state.pos, n;
    }
    jsxReadString(r) {
      let i = "", n = ++this.state.pos;
      for (; ; ) {
        if (this.state.pos >= this.length)
          throw this.raise(g.UnterminatedString, this.state.startLoc);
        let a = this.input.charCodeAt(this.state.pos);
        if (a === r) break;
        a === 38 ? (i += this.input.slice(n, this.state.pos), i += this.jsxReadEntity(), n = this.state.pos) : yr(a) ? (i += this.input.slice(
        n, this.state.pos), i += this.jsxReadNewLine(!1), n = this.state.pos) : ++this.state.pos;
      }
      i += this.input.slice(n, this.state.pos++), this.finishToken(134, i);
    }
    jsxReadEntity() {
      let r = ++this.state.pos;
      if (this.codePointAtPos(this.state.pos) === 35) {
        ++this.state.pos;
        let i = 10;
        this.codePointAtPos(this.state.pos) === 120 && (i = 16, ++this.state.pos);
        let n = this.readInt(i, void 0, !1, "bail");
        if (n !== null && this.codePointAtPos(this.state.pos) === 59)
          return ++this.state.pos, String.fromCodePoint(n);
      } else {
        let i = 0, n = !1;
        for (; i++ < 10 && this.state.pos < this.length && !(n = this.codePointAtPos(this.state.pos) === 59); )
          ++this.state.pos;
        if (n) {
          let a = this.input.slice(r, this.state.pos), o = EB[a];
          if (++this.state.pos, o)
            return o;
        }
      }
      return this.state.pos = r, "&";
    }
    jsxReadWord() {
      let r, i = this.state.pos;
      do
        r = this.input.charCodeAt(++this.state.pos);
      while (mr(r) || r === 45);
      this.finishToken(141, this.input.slice(i, this.state.pos));
    }
    jsxParseIdentifier() {
      let r = this.startNode();
      return this.match(141) ? r.name = this.state.value : wo(this.state.type) ? r.name = Kt(this.state.type) : this.unexpected(), this.next(),
      this.finishNode(r, "JSXIdentifier");
    }
    jsxParseNamespacedName() {
      let r = this.state.startLoc, i = this.jsxParseIdentifier();
      if (!this.eat(14)) return i;
      let n = this.startNodeAt(r);
      return n.namespace = i, n.name = this.jsxParseIdentifier(), this.finishNode(n, "JSXNamespacedName");
    }
    jsxParseElementName() {
      let r = this.state.startLoc, i = this.jsxParseNamespacedName();
      if (i.type === "JSXNamespacedName")
        return i;
      for (; this.eat(16); ) {
        let n = this.startNodeAt(r);
        n.object = i, n.property = this.jsxParseIdentifier(), i = this.finishNode(n, "JSXMemberExpression");
      }
      return i;
    }
    jsxParseAttributeValue() {
      let r;
      switch (this.state.type) {
        case 5:
          return r = this.startNode(), this.setContext(Ie.brace), this.next(), r = this.jsxParseExpressionContainer(r, Ie.j_oTag), r.expression.
          type === "JSXEmptyExpression" && this.raise(Zt.AttributeIsEmpty, r), r;
        case 143:
        case 134:
          return this.parseExprAtom();
        default:
          throw this.raise(Zt.UnsupportedJsxValue, this.state.startLoc);
      }
    }
    jsxParseEmptyExpression() {
      let r = this.startNodeAt(this.state.lastTokEndLoc);
      return this.finishNodeAt(r, "JSXEmptyExpression", this.state.startLoc);
    }
    jsxParseSpreadChild(r) {
      return this.next(), r.expression = this.parseExpression(), this.setContext(Ie.j_expr), this.state.canStartJSXElement = !0, this.expect(
      8), this.finishNode(r, "JSXSpreadChild");
    }
    jsxParseExpressionContainer(r, i) {
      if (this.match(8))
        r.expression = this.jsxParseEmptyExpression();
      else {
        let n = this.parseExpression();
        r.expression = n;
      }
      return this.setContext(i), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(r, "JSXExpressionContainer");
    }
    jsxParseAttribute() {
      let r = this.startNode();
      return this.match(5) ? (this.setContext(Ie.brace), this.next(), this.expect(21), r.argument = this.parseMaybeAssignAllowIn(), this.setContext(
      Ie.j_oTag), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(r, "JSXSpreadAttribute")) : (r.name = this.jsxParseNamespacedName(),
      r.value = this.eat(29) ? this.jsxParseAttributeValue() : null, this.finishNode(r, "JSXAttribute"));
    }
    jsxParseOpeningElementAt(r) {
      let i = this.startNodeAt(r);
      return this.eat(144) ? this.finishNode(i, "JSXOpeningFragment") : (i.name = this.jsxParseElementName(), this.jsxParseOpeningElementAfterName(
      i));
    }
    jsxParseOpeningElementAfterName(r) {
      let i = [];
      for (; !this.match(56) && !this.match(144); )
        i.push(this.jsxParseAttribute());
      return r.attributes = i, r.selfClosing = this.eat(56), this.expect(144), this.finishNode(r, "JSXOpeningElement");
    }
    jsxParseClosingElementAt(r) {
      let i = this.startNodeAt(r);
      return this.eat(144) ? this.finishNode(i, "JSXClosingFragment") : (i.name = this.jsxParseElementName(), this.expect(144), this.finishNode(
      i, "JSXClosingElement"));
    }
    jsxParseElementAt(r) {
      let i = this.startNodeAt(r), n = [], a = this.jsxParseOpeningElementAt(r), o = null;
      if (!a.selfClosing) {
        e: for (; ; )
          switch (this.state.type) {
            case 143:
              if (r = this.state.startLoc, this.next(), this.eat(56)) {
                o = this.jsxParseClosingElementAt(r);
                break e;
              }
              n.push(this.jsxParseElementAt(r));
              break;
            case 142:
              n.push(this.parseLiteral(this.state.value, "JSXText"));
              break;
            case 5: {
              let l = this.startNode();
              this.setContext(Ie.brace), this.next(), this.match(21) ? n.push(this.jsxParseSpreadChild(l)) : n.push(this.jsxParseExpressionContainer(
              l, Ie.j_expr));
              break;
            }
            default:
              this.unexpected();
          }
        Ut(a) && !Ut(o) && o !== null ? this.raise(Zt.MissingClosingTagFragment, o) : !Ut(a) && Ut(o) ? this.raise(Zt.MissingClosingTagElement,
        o, {
          openingTagName: dr(a.name)
        }) : !Ut(a) && !Ut(o) && dr(o.name) !== dr(a.name) && this.raise(Zt.MissingClosingTagElement, o, {
          openingTagName: dr(a.name)
        });
      }
      if (Ut(a) ? (i.openingFragment = a, i.closingFragment = o) : (i.openingElement = a, i.closingElement = o), i.children = n, this.match(
      47))
        throw this.raise(Zt.UnwrappedAdjacentJSXElements, this.state.startLoc);
      return Ut(a) ? this.finishNode(i, "JSXFragment") : this.finishNode(i, "JSXElement");
    }
    jsxParseElement() {
      let r = this.state.startLoc;
      return this.next(), this.jsxParseElementAt(r);
    }
    setContext(r) {
      let {
        context: i
      } = this.state;
      i[i.length - 1] = r;
    }
    parseExprAtom(r) {
      return this.match(143) ? this.jsxParseElement() : this.match(47) && this.input.charCodeAt(this.state.pos) !== 33 ? (this.replaceToken(
      143), this.jsxParseElement()) : super.parseExprAtom(r);
    }
    skipSpace() {
      this.curContext().preserveSpace || super.skipSpace();
    }
    getTokenFromCode(r) {
      let i = this.curContext();
      if (i === Ie.j_expr) {
        this.jsxReadToken();
        return;
      }
      if (i === Ie.j_oTag || i === Ie.j_cTag) {
        if (Ot(r)) {
          this.jsxReadWord();
          return;
        }
        if (r === 62) {
          ++this.state.pos, this.finishToken(144);
          return;
        }
        if ((r === 34 || r === 39) && i === Ie.j_oTag) {
          this.jsxReadString(r);
          return;
        }
      }
      if (r === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {
        ++this.state.pos, this.finishToken(143);
        return;
      }
      super.getTokenFromCode(r);
    }
    updateContext(r) {
      let {
        context: i,
        type: n
      } = this.state;
      if (n === 56 && r === 143)
        i.splice(-2, 2, Ie.j_cTag), this.state.canStartJSXElement = !1;
      else if (n === 143)
        i.push(Ie.j_oTag);
      else if (n === 144) {
        let a = i[i.length - 1];
        a === Ie.j_oTag && r === 56 || a === Ie.j_cTag ? (i.pop(), this.state.canStartJSXElement = i[i.length - 1] === Ie.j_expr) : (this.setContext(
        Ie.j_expr), this.state.canStartJSXElement = !0);
      } else
        this.state.canStartJSXElement = R3(n);
    }
  }, "jsx"), To = class extends Gr {
    static {
      s(this, "TypeScriptScope");
    }
    constructor(...e) {
      super(...e), this.tsNames = /* @__PURE__ */ new Map();
    }
  }, So = class extends Qr {
    static {
      s(this, "TypeScriptScopeHandler");
    }
    constructor(...e) {
      super(...e), this.importsStack = [];
    }
    createScope(e) {
      return this.importsStack.push(/* @__PURE__ */ new Set()), new To(e);
    }
    enter(e) {
      e === 256 && this.importsStack.push(/* @__PURE__ */ new Set()), super.enter(e);
    }
    exit() {
      let e = super.exit();
      return e === 256 && this.importsStack.pop(), e;
    }
    hasImport(e, r) {
      let i = this.importsStack.length;
      if (this.importsStack[i - 1].has(e))
        return !0;
      if (!r && i > 1) {
        for (let n = 0; n < i - 1; n++)
          if (this.importsStack[n].has(e)) return !0;
      }
      return !1;
    }
    declareName(e, r, i) {
      if (r & 4096) {
        this.hasImport(e, !0) && this.parser.raise(g.VarRedeclaration, i, {
          identifierName: e
        }), this.importsStack[this.importsStack.length - 1].add(e);
        return;
      }
      let n = this.currentScope(), a = n.tsNames.get(e) || 0;
      if (r & 1024) {
        this.maybeExportDefined(n, e), n.tsNames.set(e, a | 16);
        return;
      }
      super.declareName(e, r, i), r & 2 && (r & 1 || (this.checkRedeclarationInScope(n, e, r, i), this.maybeExportDefined(n, e)), a = a | 1),
      r & 256 && (a = a | 2), r & 512 && (a = a | 4), r & 128 && (a = a | 8), a && n.tsNames.set(e, a);
    }
    isRedeclaredInScope(e, r, i) {
      let n = e.tsNames.get(r);
      if ((n & 2) > 0) {
        if (i & 256) {
          let a = !!(i & 512), o = (n & 4) > 0;
          return a !== o;
        }
        return !0;
      }
      return i & 128 && (n & 8) > 0 ? e.names.get(r) & 2 ? !!(i & 1) : !1 : i & 2 && (n & 1) > 0 ? !0 : super.isRedeclaredInScope(e, r, i);
    }
    checkLocalExport(e) {
      let {
        name: r
      } = e;
      if (this.hasImport(r)) return;
      let i = this.scopeStack.length;
      for (let n = i - 1; n >= 0; n--) {
        let o = this.scopeStack[n].tsNames.get(r);
        if ((o & 1) > 0 || (o & 16) > 0)
          return;
      }
      super.checkLocalExport(e);
    }
  }, vp = /* @__PURE__ */ s((t) => t.type === "ParenthesizedExpression" ? vp(t.expression) : t, "unwrapParenthesizedExpression"), bo = class extends yo {
    static {
      s(this, "LValParser");
    }
    toAssignable(e, r = !1) {
      var i, n;
      let a;
      switch ((e.type === "ParenthesizedExpression" || (i = e.extra) != null && i.parenthesized) && (a = vp(e), r ? a.type === "Identifier" ?
      this.expressionScope.recordArrowParameterBindingError(g.InvalidParenthesizedAssignment, e) : a.type !== "MemberExpression" && !this.isOptionalMemberExpression(
      a) && this.raise(g.InvalidParenthesizedAssignment, e) : this.raise(g.InvalidParenthesizedAssignment, e)), e.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
          break;
        case "ObjectExpression":
          e.type = "ObjectPattern";
          for (let l = 0, u = e.properties.length, p = u - 1; l < u; l++) {
            var o;
            let h = e.properties[l], E = l === p;
            this.toAssignableObjectExpressionProp(h, E, r), E && h.type === "RestElement" && (o = e.extra) != null && o.trailingCommaLoc && this.
            raise(g.RestTrailingComma, e.extra.trailingCommaLoc);
          }
          break;
        case "ObjectProperty": {
          let {
            key: l,
            value: u
          } = e;
          this.isPrivateName(l) && this.classScope.usePrivateName(this.getPrivateNameSV(l), l.loc.start), this.toAssignable(u, r);
          break;
        }
        case "SpreadElement":
          throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignabl\
e's caller.");
        case "ArrayExpression":
          e.type = "ArrayPattern", this.toAssignableList(e.elements, (n = e.extra) == null ? void 0 : n.trailingCommaLoc, r);
          break;
        case "AssignmentExpression":
          e.operator !== "=" && this.raise(g.MissingEqInAssignment, e.left.loc.end), e.type = "AssignmentPattern", delete e.operator, this.toAssignable(
          e.left, r);
          break;
        case "ParenthesizedExpression":
          this.toAssignable(a, r);
          break;
      }
    }
    toAssignableObjectExpressionProp(e, r, i) {
      if (e.type === "ObjectMethod")
        this.raise(e.kind === "get" || e.kind === "set" ? g.PatternHasAccessor : g.PatternHasMethod, e.key);
      else if (e.type === "SpreadElement") {
        e.type = "RestElement";
        let n = e.argument;
        this.checkToRestConversion(n, !1), this.toAssignable(n, i), r || this.raise(g.RestTrailingComma, e);
      } else
        this.toAssignable(e, i);
    }
    toAssignableList(e, r, i) {
      let n = e.length - 1;
      for (let a = 0; a <= n; a++) {
        let o = e[a];
        o && (this.toAssignableListItem(e, a, i), o.type === "RestElement" && (a < n ? this.raise(g.RestTrailingComma, o) : r && this.raise(
        g.RestTrailingComma, r)));
      }
    }
    toAssignableListItem(e, r, i) {
      let n = e[r];
      if (n.type === "SpreadElement") {
        n.type = "RestElement";
        let a = n.argument;
        this.checkToRestConversion(a, !0), this.toAssignable(a, i);
      } else
        this.toAssignable(n, i);
    }
    isAssignable(e, r) {
      switch (e.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
          return !0;
        case "ObjectExpression": {
          let i = e.properties.length - 1;
          return e.properties.every((n, a) => n.type !== "ObjectMethod" && (a === i || n.type !== "SpreadElement") && this.isAssignable(n));
        }
        case "ObjectProperty":
          return this.isAssignable(e.value);
        case "SpreadElement":
          return this.isAssignable(e.argument);
        case "ArrayExpression":
          return e.elements.every((i) => i === null || this.isAssignable(i));
        case "AssignmentExpression":
          return e.operator === "=";
        case "ParenthesizedExpression":
          return this.isAssignable(e.expression);
        case "MemberExpression":
        case "OptionalMemberExpression":
          return !r;
        default:
          return !1;
      }
    }
    toReferencedList(e, r) {
      return e;
    }
    toReferencedListDeep(e, r) {
      this.toReferencedList(e, r);
      for (let i of e)
        i?.type === "ArrayExpression" && this.toReferencedListDeep(i.elements);
    }
    parseSpread(e) {
      let r = this.startNode();
      return this.next(), r.argument = this.parseMaybeAssignAllowIn(e, void 0), this.finishNode(r, "SpreadElement");
    }
    parseRestBinding() {
      let e = this.startNode();
      return this.next(), e.argument = this.parseBindingAtom(), this.finishNode(e, "RestElement");
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case 0: {
          let e = this.startNode();
          return this.next(), e.elements = this.parseBindingList(3, 93, 1), this.finishNode(e, "ArrayPattern");
        }
        case 5:
          return this.parseObjectLike(8, !0);
      }
      return this.parseIdentifier();
    }
    parseBindingList(e, r, i) {
      let n = i & 1, a = [], o = !0;
      for (; !this.eat(e); )
        if (o ? o = !1 : this.expect(12), n && this.match(12))
          a.push(null);
        else {
          if (this.eat(e))
            break;
          if (this.match(21)) {
            let l = this.parseRestBinding();
            if ((this.hasPlugin("flow") || i & 2) && (l = this.parseFunctionParamType(l)), a.push(l), !this.checkCommaAfterRest(r)) {
              this.expect(e);
              break;
            }
          } else {
            let l = [];
            if (i & 2)
              for (this.match(26) && this.hasPlugin("decorators") && this.raise(g.UnsupportedParameterDecorator, this.state.startLoc); this.
              match(26); )
                l.push(this.parseDecorator());
            a.push(this.parseBindingElement(i, l));
          }
        }
      return a;
    }
    parseBindingRestProperty(e) {
      return this.next(), e.argument = this.parseIdentifier(), this.checkCommaAfterRest(125), this.finishNode(e, "RestElement");
    }
    parseBindingProperty() {
      let {
        type: e,
        startLoc: r
      } = this.state;
      if (e === 21)
        return this.parseBindingRestProperty(this.startNode());
      let i = this.startNode();
      return e === 139 ? (this.expectPlugin("destructuringPrivate", r), this.classScope.usePrivateName(this.state.value, r), i.key = this.parsePrivateName()) :
      this.parsePropertyName(i), i.method = !1, this.parseObjPropValue(i, r, !1, !1, !0, !1);
    }
    parseBindingElement(e, r) {
      let i = this.parseMaybeDefault();
      (this.hasPlugin("flow") || e & 2) && this.parseFunctionParamType(i);
      let n = this.parseMaybeDefault(i.loc.start, i);
      return r.length && (i.decorators = r), n;
    }
    parseFunctionParamType(e) {
      return e;
    }
    parseMaybeDefault(e, r) {
      if (e ?? (e = this.state.startLoc), r = r ?? this.parseBindingAtom(), !this.eat(29)) return r;
      let i = this.startNodeAt(e);
      return i.left = r, i.right = this.parseMaybeAssignAllowIn(), this.finishNode(i, "AssignmentPattern");
    }
    isValidLVal(e, r, i) {
      switch (e) {
        case "AssignmentPattern":
          return "left";
        case "RestElement":
          return "argument";
        case "ObjectProperty":
          return "value";
        case "ParenthesizedExpression":
          return "expression";
        case "ArrayPattern":
          return "elements";
        case "ObjectPattern":
          return "properties";
      }
      return !1;
    }
    isOptionalMemberExpression(e) {
      return e.type === "OptionalMemberExpression";
    }
    checkLVal(e, r, i = 64, n = !1, a = !1, o = !1) {
      var l;
      let u = e.type;
      if (this.isObjectMethod(e)) return;
      let p = this.isOptionalMemberExpression(e);
      if (p || u === "MemberExpression") {
        p && (this.expectPlugin("optionalChainingAssign", e.loc.start), r.type !== "AssignmentExpression" && this.raise(g.InvalidLhsOptionalChaining,
        e, {
          ancestor: r
        })), i !== 64 && this.raise(g.InvalidPropertyBindingPattern, e);
        return;
      }
      if (u === "Identifier") {
        this.checkIdentifier(e, i, a);
        let {
          name: j
        } = e;
        n && (n.has(j) ? this.raise(g.ParamDupe, e) : n.add(j));
        return;
      }
      let h = this.isValidLVal(u, !(o || (l = e.extra) != null && l.parenthesized) && r.type === "AssignmentExpression", i);
      if (h === !0) return;
      if (h === !1) {
        let j = i === 64 ? g.InvalidLhs : g.InvalidLhsBinding;
        this.raise(j, e, {
          ancestor: r
        });
        return;
      }
      let E, I;
      typeof h == "string" ? (E = h, I = u === "ParenthesizedExpression") : [E, I] = h;
      let v = u === "ArrayPattern" || u === "ObjectPattern" ? {
        type: u
      } : r, _ = e[E];
      if (Array.isArray(_))
        for (let j of _)
          j && this.checkLVal(j, v, i, n, a, I);
      else _ && this.checkLVal(_, v, i, n, a, I);
    }
    checkIdentifier(e, r, i = !1) {
      this.state.strict && (i ? gp(e.name, this.inModule) : xp(e.name)) && (r === 64 ? this.raise(g.StrictEvalArguments, e, {
        referenceName: e.name
      }) : this.raise(g.StrictEvalArgumentsBinding, e, {
        bindingName: e.name
      })), r & 8192 && e.name === "let" && this.raise(g.LetInLexicalBinding, e), r & 64 || this.declareNameFromIdentifier(e, r);
    }
    declareNameFromIdentifier(e, r) {
      this.scope.declareName(e.name, r, e.loc.start);
    }
    checkToRestConversion(e, r) {
      switch (e.type) {
        case "ParenthesizedExpression":
          this.checkToRestConversion(e.expression, r);
          break;
        case "Identifier":
        case "MemberExpression":
          break;
        case "ArrayExpression":
        case "ObjectExpression":
          if (r) break;
        default:
          this.raise(g.InvalidRestAssignmentPattern, e);
      }
    }
    checkCommaAfterRest(e) {
      return this.match(12) ? (this.raise(this.lookaheadCharCode() === e ? g.RestTrailingComma : g.ElementAfterRest, this.state.startLoc), !0) :
      !1;
    }
  };
  function AB(t) {
    if (t == null)
      throw new Error(`Unexpected ${t} value.`);
    return t;
  }
  s(AB, "nonNull");
  function up(t) {
    if (!t)
      throw new Error("Assert fail");
  }
  s(up, "assert");
  var Z = _t`typescript`({
    AbstractMethodHasImplementation: /* @__PURE__ */ s(({
      methodName: t
    }) => `Method '${t}' cannot have an implementation because it is marked abstract.`, "AbstractMethodHasImplementation"),
    AbstractPropertyHasInitializer: /* @__PURE__ */ s(({
      propertyName: t
    }) => `Property '${t}' cannot have an initializer because it is marked abstract.`, "AbstractPropertyHasInitializer"),
    AccessorCannotBeOptional: "An 'accessor' property cannot be declared optional.",
    AccessorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.",
    AccessorCannotHaveTypeParameters: "An accessor cannot have type parameters.",
    ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.",
    ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.",
    ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or num\
eric literal or literal enum reference.",
    ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.",
    DeclareAccessor: /* @__PURE__ */ s(({
      kind: t
    }) => `'declare' is not allowed in ${t}ters.`, "DeclareAccessor"),
    DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.",
    DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.",
    DuplicateAccessibilityModifier: /* @__PURE__ */ s(({
      modifier: t
    }) => "Accessibility modifier already seen.", "DuplicateAccessibilityModifier"),
    DuplicateModifier: /* @__PURE__ */ s(({
      modifier: t
    }) => `Duplicate modifier: '${t}'.`, "DuplicateModifier"),
    EmptyHeritageClauseType: /* @__PURE__ */ s(({
      token: t
    }) => `'${t}' list cannot be empty.`, "EmptyHeritageClauseType"),
    EmptyTypeArguments: "Type argument list cannot be empty.",
    EmptyTypeParameters: "Type parameter list cannot be empty.",
    ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.",
    ImportAliasHasImportType: "An import alias can not use 'import type'.",
    ImportReflectionHasImportType: "An `import module` declaration can not use `type` modifier",
    IncompatibleModifiers: /* @__PURE__ */ s(({
      modifiers: t
    }) => `'${t[0]}' modifier cannot be used with '${t[1]}' modifier.`, "IncompatibleModifiers"),
    IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.",
    IndexSignatureHasAccessibility: /* @__PURE__ */ s(({
      modifier: t
    }) => `Index signatures cannot have an accessibility modifier ('${t}').`, "IndexSignatureHasAccessibility"),
    IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.",
    IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.",
    IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.",
    InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.",
    InvalidHeritageClauseType: /* @__PURE__ */ s(({
      token: t
    }) => `'${t}' list can only include identifiers or qualified-names with optional type arguments.`, "InvalidHeritageClauseType"),
    InvalidModifierOnTypeMember: /* @__PURE__ */ s(({
      modifier: t
    }) => `'${t}' modifier cannot appear on a type member.`, "InvalidModifierOnTypeMember"),
    InvalidModifierOnTypeParameter: /* @__PURE__ */ s(({
      modifier: t
    }) => `'${t}' modifier cannot appear on a type parameter.`, "InvalidModifierOnTypeParameter"),
    InvalidModifierOnTypeParameterPositions: /* @__PURE__ */ s(({
      modifier: t
    }) => `'${t}' modifier can only appear on a type parameter of a class, interface or type alias.`, "InvalidModifierOnTypeParameterPositio\
ns"),
    InvalidModifiersOrder: /* @__PURE__ */ s(({
      orderedModifiers: t
    }) => `'${t[0]}' modifier must precede '${t[1]}' modifier.`, "InvalidModifiersOrder"),
    InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. You can either wrap the i\
nstantiation expression in parentheses, or delete the type arguments.",
    InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.",
    MissingInterfaceName: "'interface' declarations must be followed by an identifier.",
    NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.",
    NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.",
    OptionalTypeBeforeRequired: "A required element cannot follow an optional element.",
    OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.",
    PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
    PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
    PrivateElementHasAccessibility: /* @__PURE__ */ s(({
      modifier: t
    }) => `Private elements cannot have an accessibility modifier ('${t}').`, "PrivateElementHasAccessibility"),
    ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.",
    ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.",
    ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.",
    SetAccessorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.",
    SetAccessorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.",
    SetAccessorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.",
    SingleTypeParameterWithoutTrailingComma: /* @__PURE__ */ s(({
      typeParameterName: t
    }) => `Single type parameter ${t} should have a trailing comma. Example usage: <${t},>.`, "SingleTypeParameterWithoutTrailingComma"),
    StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.",
    TupleOptionalAfterType: "A labeled tuple optional element must be declared using a question mark after the name and before the colon (`n\
ame?: type`), rather than after the type (`name: type?`).",
    TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number =\
 25`.",
    TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.",
    TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statemen\
t.",
    TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statemen\
t.",
    UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.",
    UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
    UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
    UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",
    UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.",
    UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.",
    UnsupportedSignatureParameterKind: /* @__PURE__ */ s(({
      type: t
    }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${t}.`, "UnsupportedSignatureParameterKind")
  });
  function IB(t) {
    switch (t) {
      case "any":
        return "TSAnyKeyword";
      case "boolean":
        return "TSBooleanKeyword";
      case "bigint":
        return "TSBigIntKeyword";
      case "never":
        return "TSNeverKeyword";
      case "number":
        return "TSNumberKeyword";
      case "object":
        return "TSObjectKeyword";
      case "string":
        return "TSStringKeyword";
      case "symbol":
        return "TSSymbolKeyword";
      case "undefined":
        return "TSUndefinedKeyword";
      case "unknown":
        return "TSUnknownKeyword";
      default:
        return;
    }
  }
  s(IB, "keywordTypeFromName");
  function cp(t) {
    return t === "private" || t === "public" || t === "protected";
  }
  s(cp, "tsIsAccessModifier");
  function vB(t) {
    return t === "in" || t === "out";
  }
  s(vB, "tsIsVarianceAnnotations");
  var CB = /* @__PURE__ */ s((t) => class extends t {
    static {
      s(this, "TypeScriptParserMixin");
    }
    constructor(...r) {
      super(...r), this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, {
        allowedModifiers: ["in", "out"],
        disallowedModifiers: ["const", "public", "private", "protected", "readonly", "declare", "abstract", "override"],
        errorTemplate: Z.InvalidModifierOnTypeParameter
      }), this.tsParseConstModifier = this.tsParseModifiers.bind(this, {
        allowedModifiers: ["const"],
        disallowedModifiers: ["in", "out"],
        errorTemplate: Z.InvalidModifierOnTypeParameterPositions
      }), this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, {
        allowedModifiers: ["in", "out", "const"],
        disallowedModifiers: ["public", "private", "protected", "readonly", "declare", "abstract", "override"],
        errorTemplate: Z.InvalidModifierOnTypeParameter
      });
    }
    getScopeHandler() {
      return So;
    }
    tsIsIdentifier() {
      return ve(this.state.type);
    }
    tsTokenCanFollowModifier() {
      return this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(139) || this.isLiteralPropertyName();
    }
    tsNextTokenOnSameLineAndCanFollowModifier() {
      return this.next(), this.hasPrecedingLineBreak() ? !1 : this.tsTokenCanFollowModifier();
    }
    tsNextTokenCanFollowModifier() {
      return this.match(106) ? (this.next(), this.tsTokenCanFollowModifier()) : this.tsNextTokenOnSameLineAndCanFollowModifier();
    }
    tsParseModifier(r, i) {
      if (!ve(this.state.type) && this.state.type !== 58 && this.state.type !== 75)
        return;
      let n = this.state.value;
      if (r.includes(n)) {
        if (i && this.tsIsStartOfStaticBlocks())
          return;
        if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this)))
          return n;
      }
    }
    tsParseModifiers({
      allowedModifiers: r,
      disallowedModifiers: i,
      stopOnStartOfClassStaticBlock: n,
      errorTemplate: a = Z.InvalidModifierOnTypeMember
    }, o) {
      let l = /* @__PURE__ */ s((p, h, E, I) => {
        h === E && o[I] && this.raise(Z.InvalidModifiersOrder, p, {
          orderedModifiers: [E, I]
        });
      }, "enforceOrder"), u = /* @__PURE__ */ s((p, h, E, I) => {
        (o[E] && h === I || o[I] && h === E) && this.raise(Z.IncompatibleModifiers, p, {
          modifiers: [E, I]
        });
      }, "incompatible");
      for (; ; ) {
        let {
          startLoc: p
        } = this.state, h = this.tsParseModifier(r.concat(i ?? []), n);
        if (!h) break;
        cp(h) ? o.accessibility ? this.raise(Z.DuplicateAccessibilityModifier, p, {
          modifier: h
        }) : (l(p, h, h, "override"), l(p, h, h, "static"), l(p, h, h, "readonly"), o.accessibility = h) : vB(h) ? (o[h] && this.raise(Z.DuplicateModifier,
        p, {
          modifier: h
        }), o[h] = !0, l(p, h, "in", "out")) : (hasOwnProperty.call(o, h) ? this.raise(Z.DuplicateModifier, p, {
          modifier: h
        }) : (l(p, h, "static", "readonly"), l(p, h, "static", "override"), l(p, h, "override", "readonly"), l(p, h, "abstract", "override"),
        u(p, h, "declare", "override"), u(p, h, "static", "abstract")), o[h] = !0), i != null && i.includes(h) && this.raise(a, p, {
          modifier: h
        });
      }
    }
    tsIsListTerminator(r) {
      switch (r) {
        case "EnumMembers":
        case "TypeMembers":
          return this.match(8);
        case "HeritageClauseElement":
          return this.match(5);
        case "TupleElementTypes":
          return this.match(3);
        case "TypeParametersOrArguments":
          return this.match(48);
      }
    }
    tsParseList(r, i) {
      let n = [];
      for (; !this.tsIsListTerminator(r); )
        n.push(i());
      return n;
    }
    tsParseDelimitedList(r, i, n) {
      return AB(this.tsParseDelimitedListWorker(r, i, !0, n));
    }
    tsParseDelimitedListWorker(r, i, n, a) {
      let o = [], l = -1;
      for (; !this.tsIsListTerminator(r); ) {
        l = -1;
        let u = i();
        if (u == null)
          return;
        if (o.push(u), this.eat(12)) {
          l = this.state.lastTokStartLoc.index;
          continue;
        }
        if (this.tsIsListTerminator(r))
          break;
        n && this.expect(12);
        return;
      }
      return a && (a.value = l), o;
    }
    tsParseBracketedList(r, i, n, a, o) {
      a || (n ? this.expect(0) : this.expect(47));
      let l = this.tsParseDelimitedList(r, i, o);
      return n ? this.expect(3) : this.expect(48), l;
    }
    tsParseImportType() {
      let r = this.startNode();
      return this.expect(83), this.expect(10), this.match(134) ? r.argument = this.parseStringLiteral(this.state.value) : (this.raise(Z.UnsupportedImportTypeArgument,
      this.state.startLoc), r.argument = super.parseExprAtom()), this.eat(12) && !this.match(11) ? (r.options = super.parseMaybeAssignAllowIn(),
      this.eat(12)) : r.options = null, this.expect(11), this.eat(16) && (r.qualifier = this.tsParseEntityName(3)), this.match(47) && (r.typeParameters =
      this.tsParseTypeArguments()), this.finishNode(r, "TSImportType");
    }
    tsParseEntityName(r) {
      let i;
      if (r & 1 && this.match(78))
        if (r & 2)
          i = this.parseIdentifier(!0);
        else {
          let n = this.startNode();
          this.next(), i = this.finishNode(n, "ThisExpression");
        }
      else
        i = this.parseIdentifier(!!(r & 1));
      for (; this.eat(16); ) {
        let n = this.startNodeAtNode(i);
        n.left = i, n.right = this.parseIdentifier(!!(r & 1)), i = this.finishNode(n, "TSQualifiedName");
      }
      return i;
    }
    tsParseTypeReference() {
      let r = this.startNode();
      return r.typeName = this.tsParseEntityName(1), !this.hasPrecedingLineBreak() && this.match(47) && (r.typeParameters = this.tsParseTypeArguments()),
      this.finishNode(r, "TSTypeReference");
    }
    tsParseThisTypePredicate(r) {
      this.next();
      let i = this.startNodeAtNode(r);
      return i.parameterName = r, i.typeAnnotation = this.tsParseTypeAnnotation(!1), i.asserts = !1, this.finishNode(i, "TSTypePredicate");
    }
    tsParseThisTypeNode() {
      let r = this.startNode();
      return this.next(), this.finishNode(r, "TSThisType");
    }
    tsParseTypeQuery() {
      let r = this.startNode();
      return this.expect(87), this.match(83) ? r.exprName = this.tsParseImportType() : r.exprName = this.tsParseEntityName(3), !this.hasPrecedingLineBreak() &&
      this.match(47) && (r.typeParameters = this.tsParseTypeArguments()), this.finishNode(r, "TSTypeQuery");
    }
    tsParseTypeParameter(r) {
      let i = this.startNode();
      return r(i), i.name = this.tsParseTypeParameterName(), i.constraint = this.tsEatThenParseType(81), i.default = this.tsEatThenParseType(
      29), this.finishNode(i, "TSTypeParameter");
    }
    tsTryParseTypeParameters(r) {
      if (this.match(47))
        return this.tsParseTypeParameters(r);
    }
    tsParseTypeParameters(r) {
      let i = this.startNode();
      this.match(47) || this.match(143) ? this.next() : this.unexpected();
      let n = {
        value: -1
      };
      return i.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, r), !1, !0, n), i.params.
      length === 0 && this.raise(Z.EmptyTypeParameters, i), n.value !== -1 && this.addExtra(i, "trailingComma", n.value), this.finishNode(i,
      "TSTypeParameterDeclaration");
    }
    tsFillSignature(r, i) {
      let n = r === 19, a = "parameters", o = "typeAnnotation";
      i.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier), this.expect(10), i[a] = this.tsParseBindingListForSignature(),
      n ? i[o] = this.tsParseTypeOrTypePredicateAnnotation(r) : this.match(r) && (i[o] = this.tsParseTypeOrTypePredicateAnnotation(r));
    }
    tsParseBindingListForSignature() {
      let r = super.parseBindingList(11, 41, 2);
      for (let i of r) {
        let {
          type: n
        } = i;
        (n === "AssignmentPattern" || n === "TSParameterProperty") && this.raise(Z.UnsupportedSignatureParameterKind, i, {
          type: n
        });
      }
      return r;
    }
    tsParseTypeMemberSemicolon() {
      !this.eat(12) && !this.isLineTerminator() && this.expect(13);
    }
    tsParseSignatureMember(r, i) {
      return this.tsFillSignature(14, i), this.tsParseTypeMemberSemicolon(), this.finishNode(i, r);
    }
    tsIsUnambiguouslyIndexSignature() {
      return this.next(), ve(this.state.type) ? (this.next(), this.match(14)) : !1;
    }
    tsTryParseIndexSignature(r) {
      if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this))))
        return;
      this.expect(0);
      let i = this.parseIdentifier();
      i.typeAnnotation = this.tsParseTypeAnnotation(), this.resetEndLocation(i), this.expect(3), r.parameters = [i];
      let n = this.tsTryParseTypeAnnotation();
      return n && (r.typeAnnotation = n), this.tsParseTypeMemberSemicolon(), this.finishNode(r, "TSIndexSignature");
    }
    tsParsePropertyOrMethodSignature(r, i) {
      this.eat(17) && (r.optional = !0);
      let n = r;
      if (this.match(10) || this.match(47)) {
        i && this.raise(Z.ReadonlyForMethodSignature, r);
        let a = n;
        a.kind && this.match(47) && this.raise(Z.AccessorCannotHaveTypeParameters, this.state.curPosition()), this.tsFillSignature(14, a), this.
        tsParseTypeMemberSemicolon();
        let o = "parameters", l = "typeAnnotation";
        if (a.kind === "get")
          a[o].length > 0 && (this.raise(g.BadGetterArity, this.state.curPosition()), this.isThisParam(a[o][0]) && this.raise(Z.AccessorCannotDeclareThisParameter,
          this.state.curPosition()));
        else if (a.kind === "set") {
          if (a[o].length !== 1)
            this.raise(g.BadSetterArity, this.state.curPosition());
          else {
            let u = a[o][0];
            this.isThisParam(u) && this.raise(Z.AccessorCannotDeclareThisParameter, this.state.curPosition()), u.type === "Identifier" && u.
            optional && this.raise(Z.SetAccessorCannotHaveOptionalParameter, this.state.curPosition()), u.type === "RestElement" && this.raise(
            Z.SetAccessorCannotHaveRestParameter, this.state.curPosition());
          }
          a[l] && this.raise(Z.SetAccessorCannotHaveReturnType, a[l]);
        } else
          a.kind = "method";
        return this.finishNode(a, "TSMethodSignature");
      } else {
        let a = n;
        i && (a.readonly = !0);
        let o = this.tsTryParseTypeAnnotation();
        return o && (a.typeAnnotation = o), this.tsParseTypeMemberSemicolon(), this.finishNode(a, "TSPropertySignature");
      }
    }
    tsParseTypeMember() {
      let r = this.startNode();
      if (this.match(10) || this.match(47))
        return this.tsParseSignatureMember("TSCallSignatureDeclaration", r);
      if (this.match(77)) {
        let n = this.startNode();
        return this.next(), this.match(10) || this.match(47) ? this.tsParseSignatureMember("TSConstructSignatureDeclaration", r) : (r.key = this.
        createIdentifier(n, "new"), this.tsParsePropertyOrMethodSignature(r, !1));
      }
      this.tsParseModifiers({
        allowedModifiers: ["readonly"],
        disallowedModifiers: ["declare", "abstract", "private", "protected", "public", "static", "override"]
      }, r);
      let i = this.tsTryParseIndexSignature(r);
      return i || (super.parsePropertyName(r), !r.computed && r.key.type === "Identifier" && (r.key.name === "get" || r.key.name === "set") &&
      this.tsTokenCanFollowModifier() && (r.kind = r.key.name, super.parsePropertyName(r)), this.tsParsePropertyOrMethodSignature(r, !!r.readonly));
    }
    tsParseTypeLiteral() {
      let r = this.startNode();
      return r.members = this.tsParseObjectTypeMembers(), this.finishNode(r, "TSTypeLiteral");
    }
    tsParseObjectTypeMembers() {
      this.expect(5);
      let r = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
      return this.expect(8), r;
    }
    tsIsStartOfMappedType() {
      return this.next(), this.eat(53) ? this.isContextual(122) : (this.isContextual(122) && this.next(), !this.match(0) || (this.next(), !this.
      tsIsIdentifier()) ? !1 : (this.next(), this.match(58)));
    }
    tsParseMappedType() {
      let r = this.startNode();
      this.expect(5), this.match(53) ? (r.readonly = this.state.value, this.next(), this.expectContextual(122)) : this.eatContextual(122) &&
      (r.readonly = !0), this.expect(0);
      {
        let i = this.startNode();
        i.name = this.tsParseTypeParameterName(), i.constraint = this.tsExpectThenParseType(58), r.typeParameter = this.finishNode(i, "TSTyp\
eParameter");
      }
      return r.nameType = this.eatContextual(93) ? this.tsParseType() : null, this.expect(3), this.match(53) ? (r.optional = this.state.value,
      this.next(), this.expect(17)) : this.eat(17) && (r.optional = !0), r.typeAnnotation = this.tsTryParseType(), this.semicolon(), this.expect(
      8), this.finishNode(r, "TSMappedType");
    }
    tsParseTupleType() {
      let r = this.startNode();
      r.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), !0, !1);
      let i = !1;
      return r.elementTypes.forEach((n) => {
        let {
          type: a
        } = n;
        i && a !== "TSRestType" && a !== "TSOptionalType" && !(a === "TSNamedTupleMember" && n.optional) && this.raise(Z.OptionalTypeBeforeRequired,
        n), i || (i = a === "TSNamedTupleMember" && n.optional || a === "TSOptionalType");
      }), this.finishNode(r, "TSTupleType");
    }
    tsParseTupleElementType() {
      let r = this.state.startLoc, i = this.eat(21), {
        startLoc: n
      } = this.state, a, o, l, u, h = mt(this.state.type) ? this.lookaheadCharCode() : null;
      if (h === 58)
        a = !0, l = !1, o = this.parseIdentifier(!0), this.expect(14), u = this.tsParseType();
      else if (h === 63) {
        l = !0;
        let E = this.state.value, I = this.tsParseNonArrayType();
        this.lookaheadCharCode() === 58 ? (a = !0, o = this.createIdentifier(this.startNodeAt(n), E), this.expect(17), this.expect(14), u = this.
        tsParseType()) : (a = !1, u = I, this.expect(17));
      } else
        u = this.tsParseType(), l = this.eat(17), a = this.eat(14);
      if (a) {
        let E;
        o ? (E = this.startNodeAt(n), E.optional = l, E.label = o, E.elementType = u, this.eat(17) && (E.optional = !0, this.raise(Z.TupleOptionalAfterType,
        this.state.lastTokStartLoc))) : (E = this.startNodeAt(n), E.optional = l, this.raise(Z.InvalidTupleMemberLabel, u), E.label = u, E.elementType =
        this.tsParseType()), u = this.finishNode(E, "TSNamedTupleMember");
      } else if (l) {
        let E = this.startNodeAt(n);
        E.typeAnnotation = u, u = this.finishNode(E, "TSOptionalType");
      }
      if (i) {
        let E = this.startNodeAt(r);
        E.typeAnnotation = u, u = this.finishNode(E, "TSRestType");
      }
      return u;
    }
    tsParseParenthesizedType() {
      let r = this.startNode();
      return this.expect(10), r.typeAnnotation = this.tsParseType(), this.expect(11), this.finishNode(r, "TSParenthesizedType");
    }
    tsParseFunctionOrConstructorType(r, i) {
      let n = this.startNode();
      return r === "TSConstructorType" && (n.abstract = !!i, i && this.next(), this.next()), this.tsInAllowConditionalTypesContext(() => this.
      tsFillSignature(19, n)), this.finishNode(n, r);
    }
    tsParseLiteralTypeNode() {
      let r = this.startNode();
      switch (this.state.type) {
        case 135:
        case 136:
        case 134:
        case 85:
        case 86:
          r.literal = super.parseExprAtom();
          break;
        default:
          this.unexpected();
      }
      return this.finishNode(r, "TSLiteralType");
    }
    tsParseTemplateLiteralType() {
      {
        let r = this.startNode();
        return r.literal = super.parseTemplate(!1), this.finishNode(r, "TSLiteralType");
      }
    }
    parseTemplateSubstitution() {
      return this.state.inType ? this.tsParseType() : super.parseTemplateSubstitution();
    }
    tsParseThisTypeOrThisTypePredicate() {
      let r = this.tsParseThisTypeNode();
      return this.isContextual(116) && !this.hasPrecedingLineBreak() ? this.tsParseThisTypePredicate(r) : r;
    }
    tsParseNonArrayType() {
      switch (this.state.type) {
        case 134:
        case 135:
        case 136:
        case 85:
        case 86:
          return this.tsParseLiteralTypeNode();
        case 53:
          if (this.state.value === "-") {
            let r = this.startNode(), i = this.lookahead();
            return i.type !== 135 && i.type !== 136 && this.unexpected(), r.literal = this.parseMaybeUnary(), this.finishNode(r, "TSLiteralT\
ype");
          }
          break;
        case 78:
          return this.tsParseThisTypeOrThisTypePredicate();
        case 87:
          return this.tsParseTypeQuery();
        case 83:
          return this.tsParseImportType();
        case 5:
          return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
        case 0:
          return this.tsParseTupleType();
        case 10:
          return this.tsParseParenthesizedType();
        case 25:
        case 24:
          return this.tsParseTemplateLiteralType();
        default: {
          let {
            type: r
          } = this.state;
          if (ve(r) || r === 88 || r === 84) {
            let i = r === 88 ? "TSVoidKeyword" : r === 84 ? "TSNullKeyword" : IB(this.state.value);
            if (i !== void 0 && this.lookaheadCharCode() !== 46) {
              let n = this.startNode();
              return this.next(), this.finishNode(n, i);
            }
            return this.tsParseTypeReference();
          }
        }
      }
      this.unexpected();
    }
    tsParseArrayTypeOrHigher() {
      let {
        startLoc: r
      } = this.state, i = this.tsParseNonArrayType();
      for (; !this.hasPrecedingLineBreak() && this.eat(0); )
        if (this.match(3)) {
          let n = this.startNodeAt(r);
          n.elementType = i, this.expect(3), i = this.finishNode(n, "TSArrayType");
        } else {
          let n = this.startNodeAt(r);
          n.objectType = i, n.indexType = this.tsParseType(), this.expect(3), i = this.finishNode(n, "TSIndexedAccessType");
        }
      return i;
    }
    tsParseTypeOperator() {
      let r = this.startNode(), i = this.state.value;
      return this.next(), r.operator = i, r.typeAnnotation = this.tsParseTypeOperatorOrHigher(), i === "readonly" && this.tsCheckTypeAnnotationForReadOnly(
      r), this.finishNode(r, "TSTypeOperator");
    }
    tsCheckTypeAnnotationForReadOnly(r) {
      switch (r.typeAnnotation.type) {
        case "TSTupleType":
        case "TSArrayType":
          return;
        default:
          this.raise(Z.UnexpectedReadonly, r);
      }
    }
    tsParseInferType() {
      let r = this.startNode();
      this.expectContextual(115);
      let i = this.startNode();
      return i.name = this.tsParseTypeParameterName(), i.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType()), r.typeParameter =
      this.finishNode(i, "TSTypeParameter"), this.finishNode(r, "TSInferType");
    }
    tsParseConstraintForInferType() {
      if (this.eat(81)) {
        let r = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
        if (this.state.inDisallowConditionalTypesContext || !this.match(17))
          return r;
      }
    }
    tsParseTypeOperatorOrHigher() {
      return J3(this.state.type) && !this.state.containsEsc ? this.tsParseTypeOperator() : this.isContextual(115) ? this.tsParseInferType() :
      this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
    }
    tsParseUnionOrIntersectionType(r, i, n) {
      let a = this.startNode(), o = this.eat(n), l = [];
      do
        l.push(i());
      while (this.eat(n));
      return l.length === 1 && !o ? l[0] : (a.types = l, this.finishNode(a, r));
    }
    tsParseIntersectionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
    }
    tsParseUnionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
    }
    tsIsStartOfFunctionType() {
      return this.match(47) ? !0 : this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
    }
    tsSkipParameterStart() {
      if (ve(this.state.type) || this.match(78))
        return this.next(), !0;
      if (this.match(5)) {
        let {
          errors: r
        } = this.state, i = r.length;
        try {
          return this.parseObjectLike(8, !0), r.length === i;
        } catch {
          return !1;
        }
      }
      if (this.match(0)) {
        this.next();
        let {
          errors: r
        } = this.state, i = r.length;
        try {
          return super.parseBindingList(3, 93, 1), r.length === i;
        } catch {
          return !1;
        }
      }
      return !1;
    }
    tsIsUnambiguouslyStartOfFunctionType() {
      return this.next(), !!(this.match(11) || this.match(21) || this.tsSkipParameterStart() && (this.match(14) || this.match(12) || this.match(
      17) || this.match(29) || this.match(11) && (this.next(), this.match(19))));
    }
    tsParseTypeOrTypePredicateAnnotation(r) {
      return this.tsInType(() => {
        let i = this.startNode();
        this.expect(r);
        let n = this.startNode(), a = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
        if (a && this.match(78)) {
          let u = this.tsParseThisTypeOrThisTypePredicate();
          return u.type === "TSThisType" ? (n.parameterName = u, n.asserts = !0, n.typeAnnotation = null, u = this.finishNode(n, "TSTypePred\
icate")) : (this.resetStartLocationFromNode(u, n), u.asserts = !0), i.typeAnnotation = u, this.finishNode(i, "TSTypeAnnotation");
        }
        let o = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
        if (!o)
          return a ? (n.parameterName = this.parseIdentifier(), n.asserts = a, n.typeAnnotation = null, i.typeAnnotation = this.finishNode(n,
          "TSTypePredicate"), this.finishNode(i, "TSTypeAnnotation")) : this.tsParseTypeAnnotation(!1, i);
        let l = this.tsParseTypeAnnotation(!1);
        return n.parameterName = o, n.typeAnnotation = l, n.asserts = a, i.typeAnnotation = this.finishNode(n, "TSTypePredicate"), this.finishNode(
        i, "TSTypeAnnotation");
      });
    }
    tsTryParseTypeOrTypePredicateAnnotation() {
      if (this.match(14))
        return this.tsParseTypeOrTypePredicateAnnotation(14);
    }
    tsTryParseTypeAnnotation() {
      if (this.match(14))
        return this.tsParseTypeAnnotation();
    }
    tsTryParseType() {
      return this.tsEatThenParseType(14);
    }
    tsParseTypePredicatePrefix() {
      let r = this.parseIdentifier();
      if (this.isContextual(116) && !this.hasPrecedingLineBreak())
        return this.next(), r;
    }
    tsParseTypePredicateAsserts() {
      if (this.state.type !== 109)
        return !1;
      let r = this.state.containsEsc;
      return this.next(), !ve(this.state.type) && !this.match(78) ? !1 : (r && this.raise(g.InvalidEscapedReservedWord, this.state.lastTokStartLoc,
      {
        reservedWord: "asserts"
      }), !0);
    }
    tsParseTypeAnnotation(r = !0, i = this.startNode()) {
      return this.tsInType(() => {
        r && this.expect(14), i.typeAnnotation = this.tsParseType();
      }), this.finishNode(i, "TSTypeAnnotation");
    }
    tsParseType() {
      up(this.state.inType);
      let r = this.tsParseNonConditionalType();
      if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81))
        return r;
      let i = this.startNodeAtNode(r);
      return i.checkType = r, i.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType()), this.expect(
      17), i.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.expect(14), i.falseType = this.tsInAllowConditionalTypesContext(
      () => this.tsParseType()), this.finishNode(i, "TSConditionalType");
    }
    isAbstractConstructorSignature() {
      return this.isContextual(124) && this.lookahead().type === 77;
    }
    tsParseNonConditionalType() {
      return this.tsIsStartOfFunctionType() ? this.tsParseFunctionOrConstructorType("TSFunctionType") : this.match(77) ? this.tsParseFunctionOrConstructorType(
      "TSConstructorType") : this.isAbstractConstructorSignature() ? this.tsParseFunctionOrConstructorType("TSConstructorType", !0) : this.tsParseUnionTypeOrHigher();
    }
    tsParseTypeAssertion() {
      this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(Z.ReservedTypeAssertion, this.state.startLoc);
      let r = this.startNode();
      return r.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? this.tsParseTypeReference() : this.tsParseType())), this.
      expect(48), r.expression = this.parseMaybeUnary(), this.finishNode(r, "TSTypeAssertion");
    }
    tsParseHeritageClause(r) {
      let i = this.state.startLoc, n = this.tsParseDelimitedList("HeritageClauseElement", () => {
        {
          let a = this.startNode();
          return a.expression = this.tsParseEntityName(3), this.match(47) && (a.typeParameters = this.tsParseTypeArguments()), this.finishNode(
          a, "TSExpressionWithTypeArguments");
        }
      });
      return n.length || this.raise(Z.EmptyHeritageClauseType, i, {
        token: r
      }), n;
    }
    tsParseInterfaceDeclaration(r, i = {}) {
      if (this.hasFollowingLineBreak()) return null;
      this.expectContextual(129), i.declare && (r.declare = !0), ve(this.state.type) ? (r.id = this.parseIdentifier(), this.checkIdentifier(
      r.id, 130)) : (r.id = null, this.raise(Z.MissingInterfaceName, this.state.startLoc)), r.typeParameters = this.tsTryParseTypeParameters(
      this.tsParseInOutConstModifiers), this.eat(81) && (r.extends = this.tsParseHeritageClause("extends"));
      let n = this.startNode();
      return n.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this)), r.body = this.finishNode(n, "TSInterfaceBody"), this.finishNode(
      r, "TSInterfaceDeclaration");
    }
    tsParseTypeAliasDeclaration(r) {
      return r.id = this.parseIdentifier(), this.checkIdentifier(r.id, 2), r.typeAnnotation = this.tsInType(() => {
        if (r.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers), this.expect(29), this.isContextual(114) && this.lookahead().
        type !== 16) {
          let i = this.startNode();
          return this.next(), this.finishNode(i, "TSIntrinsicKeyword");
        }
        return this.tsParseType();
      }), this.semicolon(), this.finishNode(r, "TSTypeAliasDeclaration");
    }
    tsInTopLevelContext(r) {
      if (this.curContext() !== Ie.brace) {
        let i = this.state.context;
        this.state.context = [i[0]];
        try {
          return r();
        } finally {
          this.state.context = i;
        }
      } else
        return r();
    }
    tsInType(r) {
      let i = this.state.inType;
      this.state.inType = !0;
      try {
        return r();
      } finally {
        this.state.inType = i;
      }
    }
    tsInDisallowConditionalTypesContext(r) {
      let i = this.state.inDisallowConditionalTypesContext;
      this.state.inDisallowConditionalTypesContext = !0;
      try {
        return r();
      } finally {
        this.state.inDisallowConditionalTypesContext = i;
      }
    }
    tsInAllowConditionalTypesContext(r) {
      let i = this.state.inDisallowConditionalTypesContext;
      this.state.inDisallowConditionalTypesContext = !1;
      try {
        return r();
      } finally {
        this.state.inDisallowConditionalTypesContext = i;
      }
    }
    tsEatThenParseType(r) {
      if (this.match(r))
        return this.tsNextThenParseType();
    }
    tsExpectThenParseType(r) {
      return this.tsInType(() => (this.expect(r), this.tsParseType()));
    }
    tsNextThenParseType() {
      return this.tsInType(() => (this.next(), this.tsParseType()));
    }
    tsParseEnumMember() {
      let r = this.startNode();
      return r.id = this.match(134) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(!0), this.eat(29) && (r.initializer =
      super.parseMaybeAssignAllowIn()), this.finishNode(r, "TSEnumMember");
    }
    tsParseEnumDeclaration(r, i = {}) {
      return i.const && (r.const = !0), i.declare && (r.declare = !0), this.expectContextual(126), r.id = this.parseIdentifier(), this.checkIdentifier(
      r.id, r.const ? 8971 : 8459), this.expect(5), r.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)),
      this.expect(8), this.finishNode(r, "TSEnumDeclaration");
    }
    tsParseEnumBody() {
      let r = this.startNode();
      return this.expect(5), r.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)), this.expect(8), this.finishNode(
      r, "TSEnumBody");
    }
    tsParseModuleBlock() {
      let r = this.startNode();
      return this.scope.enter(0), this.expect(5), super.parseBlockOrModuleBlockBody(r.body = [], void 0, !0, 8), this.scope.exit(), this.finishNode(
      r, "TSModuleBlock");
    }
    tsParseModuleOrNamespaceDeclaration(r, i = !1) {
      if (r.id = this.parseIdentifier(), i || this.checkIdentifier(r.id, 1024), this.eat(16)) {
        let n = this.startNode();
        this.tsParseModuleOrNamespaceDeclaration(n, !0), r.body = n;
      } else
        this.scope.enter(256), this.prodParam.enter(0), r.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit();
      return this.finishNode(r, "TSModuleDeclaration");
    }
    tsParseAmbientExternalModuleDeclaration(r) {
      return this.isContextual(112) ? (r.kind = "global", r.global = !0, r.id = this.parseIdentifier()) : this.match(134) ? (r.kind = "modul\
e", r.id = super.parseStringLiteral(this.state.value)) : this.unexpected(), this.match(5) ? (this.scope.enter(256), this.prodParam.enter(0),
      r.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit()) : this.semicolon(), this.finishNode(r, "TSModuleDeclarat\
ion");
    }
    tsParseImportEqualsDeclaration(r, i, n) {
      r.isExport = n || !1, r.id = i || this.parseIdentifier(), this.checkIdentifier(r.id, 4096), this.expect(29);
      let a = this.tsParseModuleReference();
      return r.importKind === "type" && a.type !== "TSExternalModuleReference" && this.raise(Z.ImportAliasHasImportType, a), r.moduleReference =
      a, this.semicolon(), this.finishNode(r, "TSImportEqualsDeclaration");
    }
    tsIsExternalModuleReference() {
      return this.isContextual(119) && this.lookaheadCharCode() === 40;
    }
    tsParseModuleReference() {
      return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(0);
    }
    tsParseExternalModuleReference() {
      let r = this.startNode();
      return this.expectContextual(119), this.expect(10), this.match(134) || this.unexpected(), r.expression = super.parseExprAtom(), this.expect(
      11), this.sawUnambiguousESM = !0, this.finishNode(r, "TSExternalModuleReference");
    }
    tsLookAhead(r) {
      let i = this.state.clone(), n = r();
      return this.state = i, n;
    }
    tsTryParseAndCatch(r) {
      let i = this.tryParse((n) => r() || n());
      if (!(i.aborted || !i.node))
        return i.error && (this.state = i.failState), i.node;
    }
    tsTryParse(r) {
      let i = this.state.clone(), n = r();
      if (n !== void 0 && n !== !1)
        return n;
      this.state = i;
    }
    tsTryParseDeclare(r) {
      if (this.isLineTerminator())
        return;
      let i = this.state.type, n;
      return this.isContextual(100) && (i = 74, n = "let"), this.tsInAmbientContext(() => {
        switch (i) {
          case 68:
            return r.declare = !0, super.parseFunctionStatement(r, !1, !1);
          case 80:
            return r.declare = !0, this.parseClass(r, !0, !1);
          case 126:
            return this.tsParseEnumDeclaration(r, {
              declare: !0
            });
          case 112:
            return this.tsParseAmbientExternalModuleDeclaration(r);
          case 75:
          case 74:
            return !this.match(75) || !this.isLookaheadContextual("enum") ? (r.declare = !0, this.parseVarStatement(r, n || this.state.value,
            !0)) : (this.expect(75), this.tsParseEnumDeclaration(r, {
              const: !0,
              declare: !0
            }));
          case 129: {
            let a = this.tsParseInterfaceDeclaration(r, {
              declare: !0
            });
            if (a) return a;
          }
          default:
            if (ve(i))
              return this.tsParseDeclaration(r, this.state.value, !0, null);
        }
      });
    }
    tsTryParseExportDeclaration() {
      return this.tsParseDeclaration(this.startNode(), this.state.value, !0, null);
    }
    tsParseExpressionStatement(r, i, n) {
      switch (i.name) {
        case "declare": {
          let a = this.tsTryParseDeclare(r);
          return a && (a.declare = !0), a;
        }
        case "global":
          if (this.match(5)) {
            this.scope.enter(256), this.prodParam.enter(0);
            let a = r;
            return a.kind = "global", r.global = !0, a.id = i, a.body = this.tsParseModuleBlock(), this.scope.exit(), this.prodParam.exit(),
            this.finishNode(a, "TSModuleDeclaration");
          }
          break;
        default:
          return this.tsParseDeclaration(r, i.name, !1, n);
      }
    }
    tsParseDeclaration(r, i, n, a) {
      switch (i) {
        case "abstract":
          if (this.tsCheckLineTerminator(n) && (this.match(80) || ve(this.state.type)))
            return this.tsParseAbstractDeclaration(r, a);
          break;
        case "module":
          if (this.tsCheckLineTerminator(n)) {
            if (this.match(134))
              return this.tsParseAmbientExternalModuleDeclaration(r);
            if (ve(this.state.type))
              return r.kind = "module", this.tsParseModuleOrNamespaceDeclaration(r);
          }
          break;
        case "namespace":
          if (this.tsCheckLineTerminator(n) && ve(this.state.type))
            return r.kind = "namespace", this.tsParseModuleOrNamespaceDeclaration(r);
          break;
        case "type":
          if (this.tsCheckLineTerminator(n) && ve(this.state.type))
            return this.tsParseTypeAliasDeclaration(r);
          break;
      }
    }
    tsCheckLineTerminator(r) {
      return r ? this.hasFollowingLineBreak() ? !1 : (this.next(), !0) : !this.isLineTerminator();
    }
    tsTryParseGenericAsyncArrowFunction(r) {
      if (!this.match(47)) return;
      let i = this.state.maybeInArrowParameters;
      this.state.maybeInArrowParameters = !0;
      let n = this.tsTryParseAndCatch(() => {
        let a = this.startNodeAt(r);
        return a.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier), super.parseFunctionParams(a), a.returnType = this.tsTryParseTypeOrTypePredicateAnnotation(),
        this.expect(19), a;
      });
      if (this.state.maybeInArrowParameters = i, !!n)
        return super.parseArrowExpression(n, null, !0);
    }
    tsParseTypeArgumentsInExpression() {
      if (this.reScan_lt() === 47)
        return this.tsParseTypeArguments();
    }
    tsParseTypeArguments() {
      let r = this.startNode();
      return r.params = this.tsInType(() => this.tsInTopLevelContext(() => (this.expect(47), this.tsParseDelimitedList("TypeParametersOrArgu\
ments", this.tsParseType.bind(this))))), r.params.length === 0 ? this.raise(Z.EmptyTypeArguments, r) : !this.state.inType && this.curContext() ===
      Ie.brace && this.reScan_lt_gt(), this.expect(48), this.finishNode(r, "TSTypeParameterInstantiation");
    }
    tsIsDeclarationStart() {
      return X3(this.state.type);
    }
    isExportDefaultSpecifier() {
      return this.tsIsDeclarationStart() ? !1 : super.isExportDefaultSpecifier();
    }
    parseBindingElement(r, i) {
      let n = this.state.startLoc, a = {};
      this.tsParseModifiers({
        allowedModifiers: ["public", "private", "protected", "override", "readonly"]
      }, a);
      let o = a.accessibility, l = a.override, u = a.readonly;
      !(r & 4) && (o || u || l) && this.raise(Z.UnexpectedParameterModifier, n);
      let p = this.parseMaybeDefault();
      r & 2 && this.parseFunctionParamType(p);
      let h = this.parseMaybeDefault(p.loc.start, p);
      if (o || u || l) {
        let E = this.startNodeAt(n);
        return i.length && (E.decorators = i), o && (E.accessibility = o), u && (E.readonly = u), l && (E.override = l), h.type !== "Identif\
ier" && h.type !== "AssignmentPattern" && this.raise(Z.UnsupportedParameterPropertyKind, E), E.parameter = h, this.finishNode(E, "TSParamete\
rProperty");
      }
      return i.length && (p.decorators = i), h;
    }
    isSimpleParameter(r) {
      return r.type === "TSParameterProperty" && super.isSimpleParameter(r.parameter) || super.isSimpleParameter(r);
    }
    tsDisallowOptionalPattern(r) {
      for (let i of r.params)
        i.type !== "Identifier" && i.optional && !this.state.isAmbientContext && this.raise(Z.PatternIsOptional, i);
    }
    setArrowFunctionParameters(r, i, n) {
      super.setArrowFunctionParameters(r, i, n), this.tsDisallowOptionalPattern(r);
    }
    parseFunctionBodyAndFinish(r, i, n = !1) {
      this.match(14) && (r.returnType = this.tsParseTypeOrTypePredicateAnnotation(14));
      let a = i === "FunctionDeclaration" ? "TSDeclareFunction" : i === "ClassMethod" || i === "ClassPrivateMethod" ? "TSDeclareMethod" : void 0;
      return a && !this.match(5) && this.isLineTerminator() ? this.finishNode(r, a) : a === "TSDeclareFunction" && this.state.isAmbientContext &&
      (this.raise(Z.DeclareFunctionHasImplementation, r), r.declare) ? super.parseFunctionBodyAndFinish(r, a, n) : (this.tsDisallowOptionalPattern(
      r), super.parseFunctionBodyAndFinish(r, i, n));
    }
    registerFunctionStatementId(r) {
      !r.body && r.id ? this.checkIdentifier(r.id, 1024) : super.registerFunctionStatementId(r);
    }
    tsCheckForInvalidTypeCasts(r) {
      r.forEach((i) => {
        i?.type === "TSTypeCastExpression" && this.raise(Z.UnexpectedTypeAnnotation, i.typeAnnotation);
      });
    }
    toReferencedList(r, i) {
      return this.tsCheckForInvalidTypeCasts(r), r;
    }
    parseArrayLike(r, i, n, a) {
      let o = super.parseArrayLike(r, i, n, a);
      return o.type === "ArrayExpression" && this.tsCheckForInvalidTypeCasts(o.elements), o;
    }
    parseSubscript(r, i, n, a) {
      if (!this.hasPrecedingLineBreak() && this.match(35)) {
        this.state.canStartJSXElement = !1, this.next();
        let l = this.startNodeAt(i);
        return l.expression = r, this.finishNode(l, "TSNonNullExpression");
      }
      let o = !1;
      if (this.match(18) && this.lookaheadCharCode() === 60) {
        if (n)
          return a.stop = !0, r;
        a.optionalChainMember = o = !0, this.next();
      }
      if (this.match(47) || this.match(51)) {
        let l, u = this.tsTryParseAndCatch(() => {
          if (!n && this.atPossibleAsyncArrow(r)) {
            let I = this.tsTryParseGenericAsyncArrowFunction(i);
            if (I)
              return I;
          }
          let p = this.tsParseTypeArgumentsInExpression();
          if (!p) return;
          if (o && !this.match(10)) {
            l = this.state.curPosition();
            return;
          }
          if (ss(this.state.type)) {
            let I = super.parseTaggedTemplateExpression(r, i, a);
            return I.typeParameters = p, I;
          }
          if (!n && this.eat(10)) {
            let I = this.startNodeAt(i);
            return I.callee = r, I.arguments = this.parseCallExpressionArguments(11), this.tsCheckForInvalidTypeCasts(I.arguments), I.typeParameters =
            p, a.optionalChainMember && (I.optional = o), this.finishCallExpression(I, a.optionalChainMember);
          }
          let h = this.state.type;
          if (h === 48 || h === 52 || h !== 10 && $r(h) && !this.hasPrecedingLineBreak())
            return;
          let E = this.startNodeAt(i);
          return E.expression = r, E.typeParameters = p, this.finishNode(E, "TSInstantiationExpression");
        });
        if (l && this.unexpected(l, 10), u)
          return u.type === "TSInstantiationExpression" && (this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40) && this.raise(
          Z.InvalidPropertyAccessAfterInstantiationExpression, this.state.startLoc), u;
      }
      return super.parseSubscript(r, i, n, a);
    }
    parseNewCallee(r) {
      var i;
      super.parseNewCallee(r);
      let {
        callee: n
      } = r;
      n.type === "TSInstantiationExpression" && !((i = n.extra) != null && i.parenthesized) && (r.typeParameters = n.typeParameters, r.callee =
      n.expression);
    }
    parseExprOp(r, i, n) {
      let a;
      if (ts(58) > n && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (a = this.isContextual(120)))) {
        let o = this.startNodeAt(i);
        return o.expression = r, o.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? (a && this.raise(g.UnexpectedKeyword,
        this.state.startLoc, {
          keyword: "const"
        }), this.tsParseTypeReference()) : this.tsParseType())), this.finishNode(o, a ? "TSSatisfiesExpression" : "TSAsExpression"), this.reScan_lt_gt(),
        this.parseExprOp(o, i, n);
      }
      return super.parseExprOp(r, i, n);
    }
    checkReservedWord(r, i, n, a) {
      this.state.isAmbientContext || super.checkReservedWord(r, i, n, a);
    }
    checkImportReflection(r) {
      super.checkImportReflection(r), r.module && r.importKind !== "value" && this.raise(Z.ImportReflectionHasImportType, r.specifiers[0].loc.
      start);
    }
    checkDuplicateExports() {
    }
    isPotentialImportPhase(r) {
      if (super.isPotentialImportPhase(r)) return !0;
      if (this.isContextual(130)) {
        let i = this.lookaheadCharCode();
        return r ? i === 123 || i === 42 : i !== 61;
      }
      return !r && this.isContextual(87);
    }
    applyImportPhase(r, i, n, a) {
      super.applyImportPhase(r, i, n, a), i ? r.exportKind = n === "type" ? "type" : "value" : r.importKind = n === "type" || n === "typeof" ?
      n : "value";
    }
    parseImport(r) {
      if (this.match(134))
        return r.importKind = "value", super.parseImport(r);
      let i;
      if (ve(this.state.type) && this.lookaheadCharCode() === 61)
        return r.importKind = "value", this.tsParseImportEqualsDeclaration(r);
      if (this.isContextual(130)) {
        let n = this.parseMaybeImportPhase(r, !1);
        if (this.lookaheadCharCode() === 61)
          return this.tsParseImportEqualsDeclaration(r, n);
        i = super.parseImportSpecifiersAndAfter(r, n);
      } else
        i = super.parseImport(r);
      return i.importKind === "type" && i.specifiers.length > 1 && i.specifiers[0].type === "ImportDefaultSpecifier" && this.raise(Z.TypeImportCannotSpecifyDefaultAndNamed,
      i), i;
    }
    parseExport(r, i) {
      if (this.match(83)) {
        let n = r;
        this.next();
        let a = null;
        return this.isContextual(130) && this.isPotentialImportPhase(!1) ? a = this.parseMaybeImportPhase(n, !1) : n.importKind = "value", this.
        tsParseImportEqualsDeclaration(n, a, !0);
      } else if (this.eat(29)) {
        let n = r;
        return n.expression = super.parseExpression(), this.semicolon(), this.sawUnambiguousESM = !0, this.finishNode(n, "TSExportAssignment");
      } else if (this.eatContextual(93)) {
        let n = r;
        return this.expectContextual(128), n.id = this.parseIdentifier(), this.semicolon(), this.finishNode(n, "TSNamespaceExportDeclaration");
      } else
        return super.parseExport(r, i);
    }
    isAbstractClass() {
      return this.isContextual(124) && this.lookahead().type === 80;
    }
    parseExportDefaultExpression() {
      if (this.isAbstractClass()) {
        let r = this.startNode();
        return this.next(), r.abstract = !0, this.parseClass(r, !0, !0);
      }
      if (this.match(129)) {
        let r = this.tsParseInterfaceDeclaration(this.startNode());
        if (r) return r;
      }
      return super.parseExportDefaultExpression();
    }
    parseVarStatement(r, i, n = !1) {
      let {
        isAmbientContext: a
      } = this.state, o = super.parseVarStatement(r, i, n || a);
      if (!a) return o;
      for (let {
        id: l,
        init: u
      } of o.declarations)
        u && (i !== "const" || l.typeAnnotation ? this.raise(Z.InitializerNotAllowedInAmbientContext, u) : NB(u, this.hasPlugin("estree")) ||
        this.raise(Z.ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference, u));
      return o;
    }
    parseStatementContent(r, i) {
      if (this.match(75) && this.isLookaheadContextual("enum")) {
        let n = this.startNode();
        return this.expect(75), this.tsParseEnumDeclaration(n, {
          const: !0
        });
      }
      if (this.isContextual(126))
        return this.tsParseEnumDeclaration(this.startNode());
      if (this.isContextual(129)) {
        let n = this.tsParseInterfaceDeclaration(this.startNode());
        if (n) return n;
      }
      return super.parseStatementContent(r, i);
    }
    parseAccessModifier() {
      return this.tsParseModifier(["public", "protected", "private"]);
    }
    tsHasSomeModifiers(r, i) {
      return i.some((n) => cp(n) ? r.accessibility === n : !!r[n]);
    }
    tsIsStartOfStaticBlocks() {
      return this.isContextual(106) && this.lookaheadCharCode() === 123;
    }
    parseClassMember(r, i, n) {
      let a = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
      this.tsParseModifiers({
        allowedModifiers: a,
        disallowedModifiers: ["in", "out"],
        stopOnStartOfClassStaticBlock: !0,
        errorTemplate: Z.InvalidModifierOnTypeParameterPositions
      }, i);
      let o = /* @__PURE__ */ s(() => {
        this.tsIsStartOfStaticBlocks() ? (this.next(), this.next(), this.tsHasSomeModifiers(i, a) && this.raise(Z.StaticBlockCannotHaveModifier,
        this.state.curPosition()), super.parseClassStaticBlock(r, i)) : this.parseClassMemberWithIsStatic(r, i, n, !!i.static);
      }, "callParseClassMemberWithIsStatic");
      i.declare ? this.tsInAmbientContext(o) : o();
    }
    parseClassMemberWithIsStatic(r, i, n, a) {
      let o = this.tsTryParseIndexSignature(i);
      if (o) {
        r.body.push(o), i.abstract && this.raise(Z.IndexSignatureHasAbstract, i), i.accessibility && this.raise(Z.IndexSignatureHasAccessibility,
        i, {
          modifier: i.accessibility
        }), i.declare && this.raise(Z.IndexSignatureHasDeclare, i), i.override && this.raise(Z.IndexSignatureHasOverride, i);
        return;
      }
      !this.state.inAbstractClass && i.abstract && this.raise(Z.NonAbstractClassHasAbstractMethod, i), i.override && (n.hadSuperClass || this.
      raise(Z.OverrideNotInSubClass, i)), super.parseClassMemberWithIsStatic(r, i, n, a);
    }
    parsePostMemberNameModifiers(r) {
      this.eat(17) && (r.optional = !0), r.readonly && this.match(10) && this.raise(Z.ClassMethodHasReadonly, r), r.declare && this.match(10) &&
      this.raise(Z.ClassMethodHasDeclare, r);
    }
    parseExpressionStatement(r, i, n) {
      return (i.type === "Identifier" ? this.tsParseExpressionStatement(r, i, n) : void 0) || super.parseExpressionStatement(r, i, n);
    }
    shouldParseExportDeclaration() {
      return this.tsIsDeclarationStart() ? !0 : super.shouldParseExportDeclaration();
    }
    parseConditional(r, i, n) {
      if (!this.match(17)) return r;
      if (this.state.maybeInArrowParameters) {
        let a = this.lookaheadCharCode();
        if (a === 44 || a === 61 || a === 58 || a === 41)
          return this.setOptionalParametersError(n), r;
      }
      return super.parseConditional(r, i, n);
    }
    parseParenItem(r, i) {
      let n = super.parseParenItem(r, i);
      if (this.eat(17) && (n.optional = !0, this.resetEndLocation(r)), this.match(14)) {
        let a = this.startNodeAt(i);
        return a.expression = r, a.typeAnnotation = this.tsParseTypeAnnotation(), this.finishNode(a, "TSTypeCastExpression");
      }
      return r;
    }
    parseExportDeclaration(r) {
      if (!this.state.isAmbientContext && this.isContextual(125))
        return this.tsInAmbientContext(() => this.parseExportDeclaration(r));
      let i = this.state.startLoc, n = this.eatContextual(125);
      if (n && (this.isContextual(125) || !this.shouldParseExportDeclaration()))
        throw this.raise(Z.ExpectedAmbientAfterExportDeclare, this.state.startLoc);
      let o = ve(this.state.type) && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(r);
      return o ? ((o.type === "TSInterfaceDeclaration" || o.type === "TSTypeAliasDeclaration" || n) && (r.exportKind = "type"), n && o.type !==
      "TSImportEqualsDeclaration" && (this.resetStartLocation(o, i), o.declare = !0), o) : null;
    }
    parseClassId(r, i, n, a) {
      if ((!i || n) && this.isContextual(113))
        return;
      super.parseClassId(r, i, n, r.declare ? 1024 : 8331);
      let o = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
      o && (r.typeParameters = o);
    }
    parseClassPropertyAnnotation(r) {
      r.optional || (this.eat(35) ? r.definite = !0 : this.eat(17) && (r.optional = !0));
      let i = this.tsTryParseTypeAnnotation();
      i && (r.typeAnnotation = i);
    }
    parseClassProperty(r) {
      if (this.parseClassPropertyAnnotation(r), this.state.isAmbientContext && !(r.readonly && !r.typeAnnotation) && this.match(29) && this.
      raise(Z.DeclareClassFieldHasInitializer, this.state.startLoc), r.abstract && this.match(29)) {
        let {
          key: i
        } = r;
        this.raise(Z.AbstractPropertyHasInitializer, this.state.startLoc, {
          propertyName: i.type === "Identifier" && !r.computed ? i.name : `[${this.input.slice(this.offsetToSourcePos(i.start), this.offsetToSourcePos(
          i.end))}]`
        });
      }
      return super.parseClassProperty(r);
    }
    parseClassPrivateProperty(r) {
      return r.abstract && this.raise(Z.PrivateElementHasAbstract, r), r.accessibility && this.raise(Z.PrivateElementHasAccessibility, r, {
        modifier: r.accessibility
      }), this.parseClassPropertyAnnotation(r), super.parseClassPrivateProperty(r);
    }
    parseClassAccessorProperty(r) {
      return this.parseClassPropertyAnnotation(r), r.optional && this.raise(Z.AccessorCannotBeOptional, r), super.parseClassAccessorProperty(
      r);
    }
    pushClassMethod(r, i, n, a, o, l) {
      let u = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      u && o && this.raise(Z.ConstructorHasTypeParameters, u);
      let {
        declare: p = !1,
        kind: h
      } = i;
      p && (h === "get" || h === "set") && this.raise(Z.DeclareAccessor, i, {
        kind: h
      }), u && (i.typeParameters = u), super.pushClassMethod(r, i, n, a, o, l);
    }
    pushClassPrivateMethod(r, i, n, a) {
      let o = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      o && (i.typeParameters = o), super.pushClassPrivateMethod(r, i, n, a);
    }
    declareClassPrivateMethodInScope(r, i) {
      r.type !== "TSDeclareMethod" && (r.type === "MethodDefinition" && !hasOwnProperty.call(r.value, "body") || super.declareClassPrivateMethodInScope(
      r, i));
    }
    parseClassSuper(r) {
      super.parseClassSuper(r), r.superClass && (this.match(47) || this.match(51)) && (r.superTypeParameters = this.tsParseTypeArgumentsInExpression()),
      this.eatContextual(113) && (r.implements = this.tsParseHeritageClause("implements"));
    }
    parseObjPropValue(r, i, n, a, o, l, u) {
      let p = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      return p && (r.typeParameters = p), super.parseObjPropValue(r, i, n, a, o, l, u);
    }
    parseFunctionParams(r, i) {
      let n = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      n && (r.typeParameters = n), super.parseFunctionParams(r, i);
    }
    parseVarId(r, i) {
      super.parseVarId(r, i), r.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.eat(35) && (r.definite = !0);
      let n = this.tsTryParseTypeAnnotation();
      n && (r.id.typeAnnotation = n, this.resetEndLocation(r.id));
    }
    parseAsyncArrowFromCallExpression(r, i) {
      return this.match(14) && (r.returnType = this.tsParseTypeAnnotation()), super.parseAsyncArrowFromCallExpression(r, i);
    }
    parseMaybeAssign(r, i) {
      var n, a, o, l, u;
      let p, h, E;
      if (this.hasPlugin("jsx") && (this.match(143) || this.match(47))) {
        if (p = this.state.clone(), h = this.tryParse(() => super.parseMaybeAssign(r, i), p), !h.error) return h.node;
        let {
          context: _
        } = this.state, j = _[_.length - 1];
        (j === Ie.j_oTag || j === Ie.j_expr) && _.pop();
      }
      if (!((n = h) != null && n.error) && !this.match(47))
        return super.parseMaybeAssign(r, i);
      (!p || p === this.state) && (p = this.state.clone());
      let I, v = this.tryParse((_) => {
        var j, O;
        I = this.tsParseTypeParameters(this.tsParseConstModifier);
        let k = super.parseMaybeAssign(r, i);
        return (k.type !== "ArrowFunctionExpression" || (j = k.extra) != null && j.parenthesized) && _(), ((O = I) == null ? void 0 : O.params.
        length) !== 0 && this.resetStartLocationFromNode(k, I), k.typeParameters = I, k;
      }, p);
      if (!v.error && !v.aborted)
        return I && this.reportReservedArrowTypeParam(I), v.node;
      if (!h && (up(!this.hasPlugin("jsx")), E = this.tryParse(() => super.parseMaybeAssign(r, i), p), !E.error))
        return E.node;
      if ((a = h) != null && a.node)
        return this.state = h.failState, h.node;
      if (v.node)
        return this.state = v.failState, I && this.reportReservedArrowTypeParam(I), v.node;
      if ((o = E) != null && o.node)
        return this.state = E.failState, E.node;
      throw ((l = h) == null ? void 0 : l.error) || v.error || ((u = E) == null ? void 0 : u.error);
    }
    reportReservedArrowTypeParam(r) {
      var i;
      r.params.length === 1 && !r.params[0].constraint && !((i = r.extra) != null && i.trailingComma) && this.getPluginOption("typescript", "\
disallowAmbiguousJSXLike") && this.raise(Z.ReservedArrowTypeParam, r);
    }
    parseMaybeUnary(r, i) {
      return !this.hasPlugin("jsx") && this.match(47) ? this.tsParseTypeAssertion() : super.parseMaybeUnary(r, i);
    }
    parseArrow(r) {
      if (this.match(14)) {
        let i = this.tryParse((n) => {
          let a = this.tsParseTypeOrTypePredicateAnnotation(14);
          return (this.canInsertSemicolon() || !this.match(19)) && n(), a;
        });
        if (i.aborted) return;
        i.thrown || (i.error && (this.state = i.failState), r.returnType = i.node);
      }
      return super.parseArrow(r);
    }
    parseFunctionParamType(r) {
      this.eat(17) && (r.optional = !0);
      let i = this.tsTryParseTypeAnnotation();
      return i && (r.typeAnnotation = i), this.resetEndLocation(r), r;
    }
    isAssignable(r, i) {
      switch (r.type) {
        case "TSTypeCastExpression":
          return this.isAssignable(r.expression, i);
        case "TSParameterProperty":
          return !0;
        default:
          return super.isAssignable(r, i);
      }
    }
    toAssignable(r, i = !1) {
      switch (r.type) {
        case "ParenthesizedExpression":
          this.toAssignableParenthesizedExpression(r, i);
          break;
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
          i ? this.expressionScope.recordArrowParameterBindingError(Z.UnexpectedTypeCastInParameter, r) : this.raise(Z.UnexpectedTypeCastInParameter,
          r), this.toAssignable(r.expression, i);
          break;
        case "AssignmentExpression":
          !i && r.left.type === "TSTypeCastExpression" && (r.left = this.typeCastToParameter(r.left));
        default:
          super.toAssignable(r, i);
      }
    }
    toAssignableParenthesizedExpression(r, i) {
      switch (r.expression.type) {
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
        case "ParenthesizedExpression":
          this.toAssignable(r.expression, i);
          break;
        default:
          super.toAssignable(r, i);
      }
    }
    checkToRestConversion(r, i) {
      switch (r.type) {
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
        case "TSNonNullExpression":
          this.checkToRestConversion(r.expression, !1);
          break;
        default:
          super.checkToRestConversion(r, i);
      }
    }
    isValidLVal(r, i, n) {
      switch (r) {
        case "TSTypeCastExpression":
          return !0;
        case "TSParameterProperty":
          return "parameter";
        case "TSNonNullExpression":
          return "expression";
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
          return (n !== 64 || !i) && ["expression", !0];
        default:
          return super.isValidLVal(r, i, n);
      }
    }
    parseBindingAtom() {
      return this.state.type === 78 ? this.parseIdentifier(!0) : super.parseBindingAtom();
    }
    parseMaybeDecoratorArguments(r, i) {
      if (this.match(47) || this.match(51)) {
        let n = this.tsParseTypeArgumentsInExpression();
        if (this.match(10)) {
          let a = super.parseMaybeDecoratorArguments(r, i);
          return a.typeParameters = n, a;
        }
        this.unexpected(null, 10);
      }
      return super.parseMaybeDecoratorArguments(r, i);
    }
    checkCommaAfterRest(r) {
      return this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === r ? (this.next(), !1) : super.checkCommaAfterRest(
      r);
    }
    isClassMethod() {
      return this.match(47) || super.isClassMethod();
    }
    isClassProperty() {
      return this.match(35) || this.match(14) || super.isClassProperty();
    }
    parseMaybeDefault(r, i) {
      let n = super.parseMaybeDefault(r, i);
      return n.type === "AssignmentPattern" && n.typeAnnotation && n.right.start < n.typeAnnotation.start && this.raise(Z.TypeAnnotationAfterAssign,
      n.typeAnnotation), n;
    }
    getTokenFromCode(r) {
      if (this.state.inType) {
        if (r === 62) {
          this.finishOp(48, 1);
          return;
        }
        if (r === 60) {
          this.finishOp(47, 1);
          return;
        }
      }
      super.getTokenFromCode(r);
    }
    reScan_lt_gt() {
      let {
        type: r
      } = this.state;
      r === 47 ? (this.state.pos -= 1, this.readToken_lt()) : r === 48 && (this.state.pos -= 1, this.readToken_gt());
    }
    reScan_lt() {
      let {
        type: r
      } = this.state;
      return r === 51 ? (this.state.pos -= 2, this.finishOp(47, 1), 47) : r;
    }
    toAssignableListItem(r, i, n) {
      let a = r[i];
      a.type === "TSTypeCastExpression" && (r[i] = this.typeCastToParameter(a)), super.toAssignableListItem(r, i, n);
    }
    typeCastToParameter(r) {
      return r.expression.typeAnnotation = r.typeAnnotation, this.resetEndLocation(r.expression, r.typeAnnotation.loc.end), r.expression;
    }
    shouldParseArrow(r) {
      return this.match(14) ? r.every((i) => this.isAssignable(i, !0)) : super.shouldParseArrow(r);
    }
    shouldParseAsyncArrow() {
      return this.match(14) || super.shouldParseAsyncArrow();
    }
    canHaveLeadingDecorator() {
      return super.canHaveLeadingDecorator() || this.isAbstractClass();
    }
    jsxParseOpeningElementAfterName(r) {
      if (this.match(47) || this.match(51)) {
        let i = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
        i && (r.typeParameters = i);
      }
      return super.jsxParseOpeningElementAfterName(r);
    }
    getGetterSetterExpectedParamCount(r) {
      let i = super.getGetterSetterExpectedParamCount(r), a = this.getObjectOrClassMethodParams(r)[0];
      return a && this.isThisParam(a) ? i + 1 : i;
    }
    parseCatchClauseParam() {
      let r = super.parseCatchClauseParam(), i = this.tsTryParseTypeAnnotation();
      return i && (r.typeAnnotation = i, this.resetEndLocation(r)), r;
    }
    tsInAmbientContext(r) {
      let {
        isAmbientContext: i,
        strict: n
      } = this.state;
      this.state.isAmbientContext = !0, this.state.strict = !1;
      try {
        return r();
      } finally {
        this.state.isAmbientContext = i, this.state.strict = n;
      }
    }
    parseClass(r, i, n) {
      let a = this.state.inAbstractClass;
      this.state.inAbstractClass = !!r.abstract;
      try {
        return super.parseClass(r, i, n);
      } finally {
        this.state.inAbstractClass = a;
      }
    }
    tsParseAbstractDeclaration(r, i) {
      if (this.match(80))
        return r.abstract = !0, this.maybeTakeDecorators(i, this.parseClass(r, !0, !1));
      if (this.isContextual(129)) {
        if (!this.hasFollowingLineBreak())
          return r.abstract = !0, this.raise(Z.NonClassMethodPropertyHasAbstractModifer, r), this.tsParseInterfaceDeclaration(r);
      } else
        this.unexpected(null, 80);
    }
    parseMethod(r, i, n, a, o, l, u) {
      let p = super.parseMethod(r, i, n, a, o, l, u);
      if (p.abstract && (this.hasPlugin("estree") ? p.value : p).body) {
        let {
          key: I
        } = p;
        this.raise(Z.AbstractMethodHasImplementation, p, {
          methodName: I.type === "Identifier" && !p.computed ? I.name : `[${this.input.slice(this.offsetToSourcePos(I.start), this.offsetToSourcePos(
          I.end))}]`
        });
      }
      return p;
    }
    tsParseTypeParameterName() {
      return this.parseIdentifier().name;
    }
    shouldParseAsAmbientContext() {
      return !!this.getPluginOption("typescript", "dts");
    }
    parse() {
      return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.parse();
    }
    getExpression() {
      return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.getExpression();
    }
    parseExportSpecifier(r, i, n, a) {
      return !i && a ? (this.parseTypeOnlyImportExportSpecifier(r, !1, n), this.finishNode(r, "ExportSpecifier")) : (r.exportKind = "value",
      super.parseExportSpecifier(r, i, n, a));
    }
    parseImportSpecifier(r, i, n, a, o) {
      return !i && a ? (this.parseTypeOnlyImportExportSpecifier(r, !0, n), this.finishNode(r, "ImportSpecifier")) : (r.importKind = "value",
      super.parseImportSpecifier(r, i, n, a, n ? 4098 : 4096));
    }
    parseTypeOnlyImportExportSpecifier(r, i, n) {
      let a = i ? "imported" : "local", o = i ? "local" : "exported", l = r[a], u, p = !1, h = !0, E = l.loc.start;
      if (this.isContextual(93)) {
        let v = this.parseIdentifier();
        if (this.isContextual(93)) {
          let _ = this.parseIdentifier();
          mt(this.state.type) ? (p = !0, l = v, u = i ? this.parseIdentifier() : this.parseModuleExportName(), h = !1) : (u = _, h = !1);
        } else mt(this.state.type) ? (h = !1, u = i ? this.parseIdentifier() : this.parseModuleExportName()) : (p = !0, l = v);
      } else mt(this.state.type) && (p = !0, i ? (l = this.parseIdentifier(!0), this.isContextual(93) || this.checkReservedWord(l.name, l.loc.
      start, !0, !0)) : l = this.parseModuleExportName());
      p && n && this.raise(i ? Z.TypeModifierIsUsedInTypeImports : Z.TypeModifierIsUsedInTypeExports, E), r[a] = l, r[o] = u;
      let I = i ? "importKind" : "exportKind";
      r[I] = p ? "type" : "value", h && this.eatContextual(93) && (r[o] = i ? this.parseIdentifier() : this.parseModuleExportName()), r[o] ||
      (r[o] = Dt(r[a])), i && this.checkIdentifier(r[o], p ? 4098 : 4096);
    }
  }, "typescript");
  function wB(t) {
    if (t.type !== "MemberExpression") return !1;
    let {
      computed: e,
      property: r
    } = t;
    return e && r.type !== "StringLiteral" && (r.type !== "TemplateLiteral" || r.expressions.length > 0) ? !1 : wp(t.object);
  }
  s(wB, "isPossiblyLiteralEnum");
  function NB(t, e) {
    var r;
    let {
      type: i
    } = t;
    if ((r = t.extra) != null && r.parenthesized)
      return !1;
    if (e) {
      if (i === "Literal") {
        let {
          value: n
        } = t;
        if (typeof n == "string" || typeof n == "boolean")
          return !0;
      }
    } else if (i === "StringLiteral" || i === "BooleanLiteral")
      return !0;
    return !!(Cp(t, e) || OB(t, e) || i === "TemplateLiteral" && t.expressions.length === 0 || wB(t));
  }
  s(NB, "isValidAmbientConstInitializer");
  function Cp(t, e) {
    return e ? t.type === "Literal" && (typeof t.value == "number" || "bigint" in t) : t.type === "NumericLiteral" || t.type === "BigIntLite\
ral";
  }
  s(Cp, "isNumber");
  function OB(t, e) {
    if (t.type === "UnaryExpression") {
      let {
        operator: r,
        argument: i
      } = t;
      if (r === "-" && Cp(i, e))
        return !0;
    }
    return !1;
  }
  s(OB, "isNegativeNumber");
  function wp(t) {
    return t.type === "Identifier" ? !0 : t.type !== "MemberExpression" || t.computed ? !1 : wp(t.object);
  }
  s(wp, "isUncomputedMemberExpressionChain");
  var pp = _t`placeholders`({
    ClassNameIsRequired: "A class name is required.",
    UnexpectedSpace: "Unexpected space in placeholder."
  }), _B = /* @__PURE__ */ s((t) => class extends t {
    static {
      s(this, "PlaceholdersParserMixin");
    }
    parsePlaceholder(r) {
      if (this.match(133)) {
        let i = this.startNode();
        return this.next(), this.assertNoSpace(), i.name = super.parseIdentifier(!0), this.assertNoSpace(), this.expect(133), this.finishPlaceholder(
        i, r);
      }
    }
    finishPlaceholder(r, i) {
      let n = r;
      return (!n.expectedNode || !n.type) && (n = this.finishNode(n, "Placeholder")), n.expectedNode = i, n;
    }
    getTokenFromCode(r) {
      r === 37 && this.input.charCodeAt(this.state.pos + 1) === 37 ? this.finishOp(133, 2) : super.getTokenFromCode(r);
    }
    parseExprAtom(r) {
      return this.parsePlaceholder("Expression") || super.parseExprAtom(r);
    }
    parseIdentifier(r) {
      return this.parsePlaceholder("Identifier") || super.parseIdentifier(r);
    }
    checkReservedWord(r, i, n, a) {
      r !== void 0 && super.checkReservedWord(r, i, n, a);
    }
    parseBindingAtom() {
      return this.parsePlaceholder("Pattern") || super.parseBindingAtom();
    }
    isValidLVal(r, i, n) {
      return r === "Placeholder" || super.isValidLVal(r, i, n);
    }
    toAssignable(r, i) {
      r && r.type === "Placeholder" && r.expectedNode === "Expression" ? r.expectedNode = "Pattern" : super.toAssignable(r, i);
    }
    chStartsBindingIdentifier(r, i) {
      return !!(super.chStartsBindingIdentifier(r, i) || this.lookahead().type === 133);
    }
    verifyBreakContinue(r, i) {
      r.label && r.label.type === "Placeholder" || super.verifyBreakContinue(r, i);
    }
    parseExpressionStatement(r, i) {
      var n;
      if (i.type !== "Placeholder" || (n = i.extra) != null && n.parenthesized)
        return super.parseExpressionStatement(r, i);
      if (this.match(14)) {
        let o = r;
        return o.label = this.finishPlaceholder(i, "Identifier"), this.next(), o.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration(),
        this.finishNode(o, "LabeledStatement");
      }
      this.semicolon();
      let a = r;
      return a.name = i.name, this.finishPlaceholder(a, "Statement");
    }
    parseBlock(r, i, n) {
      return this.parsePlaceholder("BlockStatement") || super.parseBlock(r, i, n);
    }
    parseFunctionId(r) {
      return this.parsePlaceholder("Identifier") || super.parseFunctionId(r);
    }
    parseClass(r, i, n) {
      let a = i ? "ClassDeclaration" : "ClassExpression";
      this.next();
      let o = this.state.strict, l = this.parsePlaceholder("Identifier");
      if (l)
        if (this.match(81) || this.match(133) || this.match(5))
          r.id = l;
        else {
          if (n || !i)
            return r.id = null, r.body = this.finishPlaceholder(l, "ClassBody"), this.finishNode(r, a);
          throw this.raise(pp.ClassNameIsRequired, this.state.startLoc);
        }
      else
        this.parseClassId(r, i, n);
      return super.parseClassSuper(r), r.body = this.parsePlaceholder("ClassBody") || super.parseClassBody(!!r.superClass, o), this.finishNode(
      r, a);
    }
    parseExport(r, i) {
      let n = this.parsePlaceholder("Identifier");
      if (!n) return super.parseExport(r, i);
      let a = r;
      if (!this.isContextual(98) && !this.match(12))
        return a.specifiers = [], a.source = null, a.declaration = this.finishPlaceholder(n, "Declaration"), this.finishNode(a, "ExportNamed\
Declaration");
      this.expectPlugin("exportDefaultFrom");
      let o = this.startNode();
      return o.exported = n, a.specifiers = [this.finishNode(o, "ExportDefaultSpecifier")], super.parseExport(a, i);
    }
    isExportDefaultSpecifier() {
      if (this.match(65)) {
        let r = this.nextTokenStart();
        if (this.isUnparsedContextual(r, "from") && this.input.startsWith(Kt(133), this.nextTokenStartSince(r + 4)))
          return !0;
      }
      return super.isExportDefaultSpecifier();
    }
    maybeParseExportDefaultSpecifier(r, i) {
      var n;
      return (n = r.specifiers) != null && n.length ? !0 : super.maybeParseExportDefaultSpecifier(r, i);
    }
    checkExport(r) {
      let {
        specifiers: i
      } = r;
      i != null && i.length && (r.specifiers = i.filter((n) => n.exported.type === "Placeholder")), super.checkExport(r), r.specifiers = i;
    }
    parseImport(r) {
      let i = this.parsePlaceholder("Identifier");
      if (!i) return super.parseImport(r);
      if (r.specifiers = [], !this.isContextual(98) && !this.match(12))
        return r.source = this.finishPlaceholder(i, "StringLiteral"), this.semicolon(), this.finishNode(r, "ImportDeclaration");
      let n = this.startNodeAtNode(i);
      return n.local = i, r.specifiers.push(this.finishNode(n, "ImportDefaultSpecifier")), this.eat(12) && (this.maybeParseStarImportSpecifier(
      r) || this.parseNamedImportSpecifiers(r)), this.expectContextual(98), r.source = this.parseImportSource(), this.semicolon(), this.finishNode(
      r, "ImportDeclaration");
    }
    parseImportSource() {
      return this.parsePlaceholder("StringLiteral") || super.parseImportSource();
    }
    assertNoSpace() {
      this.state.start > this.offsetToSourcePos(this.state.lastTokEndLoc.index) && this.raise(pp.UnexpectedSpace, this.state.lastTokEndLoc);
    }
  }, "placeholders"), DB = /* @__PURE__ */ s((t) => class extends t {
    static {
      s(this, "V8IntrinsicMixin");
    }
    parseV8Intrinsic() {
      if (this.match(54)) {
        let r = this.state.startLoc, i = this.startNode();
        if (this.next(), ve(this.state.type)) {
          let n = this.parseIdentifierName(), a = this.createIdentifier(i, n);
          if (a.type = "V8IntrinsicIdentifier", this.match(10))
            return a;
        }
        this.unexpected(r);
      }
    }
    parseExprAtom(r) {
      return this.parseV8Intrinsic() || super.parseExprAtom(r);
    }
  }, "v8intrinsic"), fp = ["minimal", "fsharp", "hack", "smart"], hp = ["^^", "@@", "^", "%", "#"];
  function kB(t) {
    if (t.has("decorators")) {
      if (t.has("decorators-legacy"))
        throw new Error("Cannot use the decorators and decorators-legacy plugin together");
      let r = t.get("decorators").decoratorsBeforeExport;
      if (r != null && typeof r != "boolean")
        throw new Error("'decoratorsBeforeExport' must be a boolean, if specified.");
      let i = t.get("decorators").allowCallParenthesized;
      if (i != null && typeof i != "boolean")
        throw new Error("'allowCallParenthesized' must be a boolean.");
    }
    if (t.has("flow") && t.has("typescript"))
      throw new Error("Cannot combine flow and typescript plugins.");
    if (t.has("placeholders") && t.has("v8intrinsic"))
      throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
    if (t.has("pipelineOperator")) {
      var e;
      let r = t.get("pipelineOperator").proposal;
      if (!fp.includes(r)) {
        let n = fp.map((a) => `"${a}"`).join(", ");
        throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${n}.`);
      }
      let i = ((e = t.get("recordAndTuple")) == null ? void 0 : e.syntaxType) === "hash";
      if (r === "hack") {
        if (t.has("placeholders"))
          throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
        if (t.has("v8intrinsic"))
          throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
        let n = t.get("pipelineOperator").topicToken;
        if (!hp.includes(n)) {
          let a = hp.map((o) => `"${o}"`).join(", ");
          throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${a}\
.`);
        }
        if (n === "#" && i)
          throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "hack", topicToken: "#" }]\` and \`${JSON.stringify(["\
recordAndTuple", t.get("recordAndTuple")])}\`.`);
      } else if (r === "smart" && i)
        throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "smart" }]\` and \`${JSON.stringify(["recordAndTuple", t.
        get("recordAndTuple")])}\`.`);
    }
    if (t.has("moduleAttributes")) {
      if (t.has("deprecatedImportAssert") || t.has("importAssertions"))
        throw new Error("Cannot combine importAssertions, deprecatedImportAssert and moduleAttributes plugins.");
      if (t.get("moduleAttributes").version !== "may-2020")
        throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the on\
ly supported value is 'may-2020'.");
    }
    if (t.has("importAssertions") && t.has("deprecatedImportAssert"))
      throw new Error("Cannot combine importAssertions and deprecatedImportAssert plugins.");
    if (!t.has("deprecatedImportAssert") && t.has("importAttributes") && t.get("importAttributes").deprecatedAssertSyntax && t.set("deprecat\
edImportAssert", {}), t.has("recordAndTuple")) {
      let r = t.get("recordAndTuple").syntaxType;
      if (r != null) {
        let i = ["hash", "bar"];
        if (!i.includes(r))
          throw new Error("The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " + i.map((n) => `'${n}'`).join(", "));
      }
    }
    if (t.has("asyncDoExpressions") && !t.has("doExpressions")) {
      let r = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
      throw r.missingPlugins = "doExpressions", r;
    }
    if (t.has("optionalChainingAssign") && t.get("optionalChainingAssign").version !== "2023-07")
      throw new Error("The 'optionalChainingAssign' plugin requires a 'version' option, representing the last proposal update. Currently, th\
e only supported value is '2023-07'.");
  }
  s(kB, "validatePlugins");
  var Np = {
    estree: M3,
    jsx: PB,
    flow: gB,
    typescript: CB,
    v8intrinsic: DB,
    placeholders: _B
  }, LB = Object.keys(Np), xo = class extends bo {
    static {
      s(this, "ExpressionParser");
    }
    checkProto(e, r, i, n) {
      if (e.type === "SpreadElement" || this.isObjectMethod(e) || e.computed || e.shorthand)
        return i;
      let a = e.key;
      return (a.type === "Identifier" ? a.name : a.value) === "__proto__" ? r ? (this.raise(g.RecordNoProto, a), !0) : (i && (n ? n.doubleProtoLoc ===
      null && (n.doubleProtoLoc = a.loc.start) : this.raise(g.DuplicateProto, a)), !0) : i;
    }
    shouldExitDescending(e, r) {
      return e.type === "ArrowFunctionExpression" && this.offsetToSourcePos(e.start) === r;
    }
    getExpression() {
      this.enterInitialScopes(), this.nextToken();
      let e = this.parseExpression();
      return this.match(140) || this.unexpected(), this.finalizeRemainingComments(), e.comments = this.comments, e.errors = this.state.errors,
      this.optionFlags & 256 && (e.tokens = this.tokens), e;
    }
    parseExpression(e, r) {
      return e ? this.disallowInAnd(() => this.parseExpressionBase(r)) : this.allowInAnd(() => this.parseExpressionBase(r));
    }
    parseExpressionBase(e) {
      let r = this.state.startLoc, i = this.parseMaybeAssign(e);
      if (this.match(12)) {
        let n = this.startNodeAt(r);
        for (n.expressions = [i]; this.eat(12); )
          n.expressions.push(this.parseMaybeAssign(e));
        return this.toReferencedList(n.expressions), this.finishNode(n, "SequenceExpression");
      }
      return i;
    }
    parseMaybeAssignDisallowIn(e, r) {
      return this.disallowInAnd(() => this.parseMaybeAssign(e, r));
    }
    parseMaybeAssignAllowIn(e, r) {
      return this.allowInAnd(() => this.parseMaybeAssign(e, r));
    }
    setOptionalParametersError(e) {
      e.optionalParametersLoc = this.state.startLoc;
    }
    parseMaybeAssign(e, r) {
      let i = this.state.startLoc, n = this.isContextual(108);
      if (n && this.prodParam.hasYield) {
        this.next();
        let u = this.parseYield(i);
        return r && (u = r.call(this, u, i)), u;
      }
      let a;
      e ? a = !1 : (e = new Tr(), a = !0);
      let {
        type: o
      } = this.state;
      (o === 10 || ve(o)) && (this.state.potentialArrowAt = this.state.start);
      let l = this.parseMaybeConditional(e);
      if (r && (l = r.call(this, l, i)), q3(this.state.type)) {
        let u = this.startNodeAt(i), p = this.state.value;
        if (u.operator = p, this.match(29)) {
          this.toAssignable(l, !0), u.left = l;
          let h = i.index;
          e.doubleProtoLoc != null && e.doubleProtoLoc.index >= h && (e.doubleProtoLoc = null), e.shorthandAssignLoc != null && e.shorthandAssignLoc.
          index >= h && (e.shorthandAssignLoc = null), e.privateKeyLoc != null && e.privateKeyLoc.index >= h && (this.checkDestructuringPrivate(
          e), e.privateKeyLoc = null);
        } else
          u.left = l;
        return this.next(), u.right = this.parseMaybeAssign(), this.checkLVal(l, this.finishNode(u, "AssignmentExpression")), u;
      } else a && this.checkExpressionErrors(e, !0);
      if (n) {
        let {
          type: u
        } = this.state;
        if ((this.hasPlugin("v8intrinsic") ? $r(u) : $r(u) && !this.match(54)) && !this.isAmbiguousPrefixOrIdentifier())
          return this.raiseOverwrite(g.YieldNotInGeneratorFunction, i), this.parseYield(i);
      }
      return l;
    }
    parseMaybeConditional(e) {
      let r = this.state.startLoc, i = this.state.potentialArrowAt, n = this.parseExprOps(e);
      return this.shouldExitDescending(n, i) ? n : this.parseConditional(n, r, e);
    }
    parseConditional(e, r, i) {
      if (this.eat(17)) {
        let n = this.startNodeAt(r);
        return n.test = e, n.consequent = this.parseMaybeAssignAllowIn(), this.expect(14), n.alternate = this.parseMaybeAssign(), this.finishNode(
        n, "ConditionalExpression");
      }
      return e;
    }
    parseMaybeUnaryOrPrivate(e) {
      return this.match(139) ? this.parsePrivateName() : this.parseMaybeUnary(e);
    }
    parseExprOps(e) {
      let r = this.state.startLoc, i = this.state.potentialArrowAt, n = this.parseMaybeUnaryOrPrivate(e);
      return this.shouldExitDescending(n, i) ? n : this.parseExprOp(n, r, -1);
    }
    parseExprOp(e, r, i) {
      if (this.isPrivateName(e)) {
        let a = this.getPrivateNameSV(e);
        (i >= ts(58) || !this.prodParam.hasIn || !this.match(58)) && this.raise(g.PrivateInExpectedIn, e, {
          identifierName: a
        }), this.classScope.usePrivateName(a, e.loc.start);
      }
      let n = this.state.type;
      if (K3(n) && (this.prodParam.hasIn || !this.match(58))) {
        let a = ts(n);
        if (a > i) {
          if (n === 39) {
            if (this.expectPlugin("pipelineOperator"), this.state.inFSharpPipelineDirectBody)
              return e;
            this.checkPipelineAtInfixOperator(e, r);
          }
          let o = this.startNodeAt(r);
          o.left = e, o.operator = this.state.value;
          let l = n === 41 || n === 42, u = n === 40;
          if (u && (a = ts(42)), this.next(), n === 39 && this.hasPlugin(["pipelineOperator", {
            proposal: "minimal"
          }]) && this.state.type === 96 && this.prodParam.hasAwait)
            throw this.raise(g.UnexpectedAwaitAfterPipelineBody, this.state.startLoc);
          o.right = this.parseExprOpRightExpr(n, a);
          let p = this.finishNode(o, l || u ? "LogicalExpression" : "BinaryExpression"), h = this.state.type;
          if (u && (h === 41 || h === 42) || l && h === 40)
            throw this.raise(g.MixingCoalesceWithLogical, this.state.startLoc);
          return this.parseExprOp(p, r, i);
        }
      }
      return e;
    }
    parseExprOpRightExpr(e, r) {
      let i = this.state.startLoc;
      switch (e) {
        case 39:
          switch (this.getPluginOption("pipelineOperator", "proposal")) {
            case "hack":
              return this.withTopicBindingContext(() => this.parseHackPipeBody());
            case "fsharp":
              return this.withSoloAwaitPermittingContext(() => this.parseFSharpPipelineBody(r));
          }
          if (this.getPluginOption("pipelineOperator", "proposal") === "smart")
            return this.withTopicBindingContext(() => {
              if (this.prodParam.hasYield && this.isContextual(108))
                throw this.raise(g.PipeBodyIsTighter, this.state.startLoc);
              return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(e, r), i);
            });
        default:
          return this.parseExprOpBaseRightExpr(e, r);
      }
    }
    parseExprOpBaseRightExpr(e, r) {
      let i = this.state.startLoc;
      return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), i, W3(e) ? r - 1 : r);
    }
    parseHackPipeBody() {
      var e;
      let {
        startLoc: r
      } = this.state, i = this.parseMaybeAssign();
      return w3.has(i.type) && !((e = i.extra) != null && e.parenthesized) && this.raise(g.PipeUnparenthesizedBody, r, {
        type: i.type
      }), this.topicReferenceWasUsedInCurrentContext() || this.raise(g.PipeTopicUnused, r), i;
    }
    checkExponentialAfterUnary(e) {
      this.match(57) && this.raise(g.UnexpectedTokenUnaryExponentiation, e.argument);
    }
    parseMaybeUnary(e, r) {
      let i = this.state.startLoc, n = this.isContextual(96);
      if (n && this.recordAwaitIfAllowed()) {
        this.next();
        let u = this.parseAwait(i);
        return r || this.checkExponentialAfterUnary(u), u;
      }
      let a = this.match(34), o = this.startNode();
      if (Y3(this.state.type)) {
        o.operator = this.state.value, o.prefix = !0, this.match(72) && this.expectPlugin("throwExpressions");
        let u = this.match(89);
        if (this.next(), o.argument = this.parseMaybeUnary(null, !0), this.checkExpressionErrors(e, !0), this.state.strict && u) {
          let p = o.argument;
          p.type === "Identifier" ? this.raise(g.StrictDelete, o) : this.hasPropertyAsPrivateName(p) && this.raise(g.DeletePrivateField, o);
        }
        if (!a)
          return r || this.checkExponentialAfterUnary(o), this.finishNode(o, "UnaryExpression");
      }
      let l = this.parseUpdate(o, a, e);
      if (n) {
        let {
          type: u
        } = this.state;
        if ((this.hasPlugin("v8intrinsic") ? $r(u) : $r(u) && !this.match(54)) && !this.isAmbiguousPrefixOrIdentifier())
          return this.raiseOverwrite(g.AwaitNotInAsyncContext, i), this.parseAwait(i);
      }
      return l;
    }
    parseUpdate(e, r, i) {
      if (r) {
        let o = e;
        return this.checkLVal(o.argument, this.finishNode(o, "UpdateExpression")), e;
      }
      let n = this.state.startLoc, a = this.parseExprSubscripts(i);
      if (this.checkExpressionErrors(i, !1)) return a;
      for (; V3(this.state.type) && !this.canInsertSemicolon(); ) {
        let o = this.startNodeAt(n);
        o.operator = this.state.value, o.prefix = !1, o.argument = a, this.next(), this.checkLVal(a, a = this.finishNode(o, "UpdateExpressio\
n"));
      }
      return a;
    }
    parseExprSubscripts(e) {
      let r = this.state.startLoc, i = this.state.potentialArrowAt, n = this.parseExprAtom(e);
      return this.shouldExitDescending(n, i) ? n : this.parseSubscripts(n, r);
    }
    parseSubscripts(e, r, i) {
      let n = {
        optionalChainMember: !1,
        maybeAsyncArrow: this.atPossibleAsyncArrow(e),
        stop: !1
      };
      do
        e = this.parseSubscript(e, r, i, n), n.maybeAsyncArrow = !1;
      while (!n.stop);
      return e;
    }
    parseSubscript(e, r, i, n) {
      let {
        type: a
      } = this.state;
      if (!i && a === 15)
        return this.parseBind(e, r, i, n);
      if (ss(a))
        return this.parseTaggedTemplateExpression(e, r, n);
      let o = !1;
      if (a === 18) {
        if (i && (this.raise(g.OptionalChainingNoNew, this.state.startLoc), this.lookaheadCharCode() === 40))
          return n.stop = !0, e;
        n.optionalChainMember = o = !0, this.next();
      }
      if (!i && this.match(10))
        return this.parseCoverCallAndAsyncArrowHead(e, r, n, o);
      {
        let l = this.eat(0);
        return l || o || this.eat(16) ? this.parseMember(e, r, n, l, o) : (n.stop = !0, e);
      }
    }
    parseMember(e, r, i, n, a) {
      let o = this.startNodeAt(r);
      return o.object = e, o.computed = n, n ? (o.property = this.parseExpression(), this.expect(3)) : this.match(139) ? (e.type === "Super" &&
      this.raise(g.SuperPrivateField, r), this.classScope.usePrivateName(this.state.value, this.state.startLoc), o.property = this.parsePrivateName()) :
      o.property = this.parseIdentifier(!0), i.optionalChainMember ? (o.optional = a, this.finishNode(o, "OptionalMemberExpression")) : this.
      finishNode(o, "MemberExpression");
    }
    parseBind(e, r, i, n) {
      let a = this.startNodeAt(r);
      return a.object = e, this.next(), a.callee = this.parseNoCallExpr(), n.stop = !0, this.parseSubscripts(this.finishNode(a, "BindExpress\
ion"), r, i);
    }
    parseCoverCallAndAsyncArrowHead(e, r, i, n) {
      let a = this.state.maybeInArrowParameters, o = null;
      this.state.maybeInArrowParameters = !0, this.next();
      let l = this.startNodeAt(r);
      l.callee = e;
      let {
        maybeAsyncArrow: u,
        optionalChainMember: p
      } = i;
      u && (this.expressionScope.enter(hB()), o = new Tr()), p && (l.optional = n), n ? l.arguments = this.parseCallExpressionArguments(11) :
      l.arguments = this.parseCallExpressionArguments(11, e.type !== "Super", l, o);
      let h = this.finishCallExpression(l, p);
      return u && this.shouldParseAsyncArrow() && !n ? (i.stop = !0, this.checkDestructuringPrivate(o), this.expressionScope.validateAsPattern(),
      this.expressionScope.exit(), h = this.parseAsyncArrowFromCallExpression(this.startNodeAt(r), h)) : (u && (this.checkExpressionErrors(o,
      !0), this.expressionScope.exit()), this.toReferencedArguments(h)), this.state.maybeInArrowParameters = a, h;
    }
    toReferencedArguments(e, r) {
      this.toReferencedListDeep(e.arguments, r);
    }
    parseTaggedTemplateExpression(e, r, i) {
      let n = this.startNodeAt(r);
      return n.tag = e, n.quasi = this.parseTemplate(!0), i.optionalChainMember && this.raise(g.OptionalChainingNoTemplate, r), this.finishNode(
      n, "TaggedTemplateExpression");
    }
    atPossibleAsyncArrow(e) {
      return e.type === "Identifier" && e.name === "async" && this.state.lastTokEndLoc.index === e.end && !this.canInsertSemicolon() && e.end -
      e.start === 5 && this.offsetToSourcePos(e.start) === this.state.potentialArrowAt;
    }
    finishCallExpression(e, r) {
      if (e.callee.type === "Import")
        if (e.arguments.length === 0 || e.arguments.length > 2)
          this.raise(g.ImportCallArity, e);
        else
          for (let i of e.arguments)
            i.type === "SpreadElement" && this.raise(g.ImportCallSpreadArgument, i);
      return this.finishNode(e, r ? "OptionalCallExpression" : "CallExpression");
    }
    parseCallExpressionArguments(e, r, i, n) {
      let a = [], o = !0, l = this.state.inFSharpPipelineDirectBody;
      for (this.state.inFSharpPipelineDirectBody = !1; !this.eat(e); ) {
        if (o)
          o = !1;
        else if (this.expect(12), this.match(e)) {
          i && this.addTrailingCommaExtraToNode(i), this.next();
          break;
        }
        a.push(this.parseExprListItem(!1, n, r));
      }
      return this.state.inFSharpPipelineDirectBody = l, a;
    }
    shouldParseAsyncArrow() {
      return this.match(19) && !this.canInsertSemicolon();
    }
    parseAsyncArrowFromCallExpression(e, r) {
      var i;
      return this.resetPreviousNodeTrailingComments(r), this.expect(19), this.parseArrowExpression(e, r.arguments, !0, (i = r.extra) == null ?
      void 0 : i.trailingCommaLoc), r.innerComments && Zr(e, r.innerComments), r.callee.trailingComments && Zr(e, r.callee.trailingComments),
      e;
    }
    parseNoCallExpr() {
      let e = this.state.startLoc;
      return this.parseSubscripts(this.parseExprAtom(), e, !0);
    }
    parseExprAtom(e) {
      let r, i = null, {
        type: n
      } = this.state;
      switch (n) {
        case 79:
          return this.parseSuper();
        case 83:
          return r = this.startNode(), this.next(), this.match(16) ? this.parseImportMetaProperty(r) : this.match(10) ? this.optionFlags & 512 ?
          this.parseImportCall(r) : this.finishNode(r, "Import") : (this.raise(g.UnsupportedImport, this.state.lastTokStartLoc), this.finishNode(
          r, "Import"));
        case 78:
          return r = this.startNode(), this.next(), this.finishNode(r, "ThisExpression");
        case 90:
          return this.parseDo(this.startNode(), !1);
        case 56:
        case 31:
          return this.readRegexp(), this.parseRegExpLiteral(this.state.value);
        case 135:
          return this.parseNumericLiteral(this.state.value);
        case 136:
          return this.parseBigIntLiteral(this.state.value);
        case 134:
          return this.parseStringLiteral(this.state.value);
        case 84:
          return this.parseNullLiteral();
        case 85:
          return this.parseBooleanLiteral(!0);
        case 86:
          return this.parseBooleanLiteral(!1);
        case 10: {
          let a = this.state.potentialArrowAt === this.state.start;
          return this.parseParenAndDistinguishExpression(a);
        }
        case 2:
        case 1:
          return this.parseArrayLike(this.state.type === 2 ? 4 : 3, !1, !0);
        case 0:
          return this.parseArrayLike(3, !0, !1, e);
        case 6:
        case 7:
          return this.parseObjectLike(this.state.type === 6 ? 9 : 8, !1, !0);
        case 5:
          return this.parseObjectLike(8, !1, !1, e);
        case 68:
          return this.parseFunctionOrFunctionSent();
        case 26:
          i = this.parseDecorators();
        case 80:
          return this.parseClass(this.maybeTakeDecorators(i, this.startNode()), !1);
        case 77:
          return this.parseNewOrNewTarget();
        case 25:
        case 24:
          return this.parseTemplate(!1);
        case 15: {
          r = this.startNode(), this.next(), r.object = null;
          let a = r.callee = this.parseNoCallExpr();
          if (a.type === "MemberExpression")
            return this.finishNode(r, "BindExpression");
          throw this.raise(g.UnsupportedBind, a);
        }
        case 139:
          return this.raise(g.PrivateInExpectedIn, this.state.startLoc, {
            identifierName: this.state.value
          }), this.parsePrivateName();
        case 33:
          return this.parseTopicReferenceThenEqualsSign(54, "%");
        case 32:
          return this.parseTopicReferenceThenEqualsSign(44, "^");
        case 37:
        case 38:
          return this.parseTopicReference("hack");
        case 44:
        case 54:
        case 27: {
          let a = this.getPluginOption("pipelineOperator", "proposal");
          if (a)
            return this.parseTopicReference(a);
          this.unexpected();
          break;
        }
        case 47: {
          let a = this.input.codePointAt(this.nextTokenStart());
          Ot(a) || a === 62 ? this.expectOnePlugin(["jsx", "flow", "typescript"]) : this.unexpected();
          break;
        }
        default:
          if (n === 137)
            return this.parseDecimalLiteral(this.state.value);
          if (ve(n)) {
            if (this.isContextual(127) && this.lookaheadInLineCharCode() === 123)
              return this.parseModuleExpression();
            let a = this.state.potentialArrowAt === this.state.start, o = this.state.containsEsc, l = this.parseIdentifier();
            if (!o && l.name === "async" && !this.canInsertSemicolon()) {
              let {
                type: u
              } = this.state;
              if (u === 68)
                return this.resetPreviousNodeTrailingComments(l), this.next(), this.parseAsyncFunctionExpression(this.startNodeAtNode(l));
              if (ve(u))
                return this.lookaheadCharCode() === 61 ? this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(l)) : l;
              if (u === 90)
                return this.resetPreviousNodeTrailingComments(l), this.parseDo(this.startNodeAtNode(l), !0);
            }
            return a && this.match(19) && !this.canInsertSemicolon() ? (this.next(), this.parseArrowExpression(this.startNodeAtNode(l), [l],
            !1)) : l;
          } else
            this.unexpected();
      }
    }
    parseTopicReferenceThenEqualsSign(e, r) {
      let i = this.getPluginOption("pipelineOperator", "proposal");
      if (i)
        return this.state.type = e, this.state.value = r, this.state.pos--, this.state.end--, this.state.endLoc = Ze(this.state.endLoc, -1),
        this.parseTopicReference(i);
      this.unexpected();
    }
    parseTopicReference(e) {
      let r = this.startNode(), i = this.state.startLoc, n = this.state.type;
      return this.next(), this.finishTopicReference(r, i, e, n);
    }
    finishTopicReference(e, r, i, n) {
      if (this.testTopicReferenceConfiguration(i, r, n))
        return i === "hack" ? (this.topicReferenceIsAllowedInCurrentContext() || this.raise(g.PipeTopicUnbound, r), this.registerTopicReference(),
        this.finishNode(e, "TopicReference")) : (this.topicReferenceIsAllowedInCurrentContext() || this.raise(g.PrimaryTopicNotAllowed, r), this.
        registerTopicReference(), this.finishNode(e, "PipelinePrimaryTopicReference"));
      throw this.raise(g.PipeTopicUnconfiguredToken, r, {
        token: Kt(n)
      });
    }
    testTopicReferenceConfiguration(e, r, i) {
      switch (e) {
        case "hack":
          return this.hasPlugin(["pipelineOperator", {
            topicToken: Kt(i)
          }]);
        case "smart":
          return i === 27;
        default:
          throw this.raise(g.PipeTopicRequiresHackPipes, r);
      }
    }
    parseAsyncArrowUnaryFunction(e) {
      this.prodParam.enter(rs(!0, this.prodParam.hasYield));
      let r = [this.parseIdentifier()];
      return this.prodParam.exit(), this.hasPrecedingLineBreak() && this.raise(g.LineTerminatorBeforeArrow, this.state.curPosition()), this.
      expect(19), this.parseArrowExpression(e, r, !0);
    }
    parseDo(e, r) {
      this.expectPlugin("doExpressions"), r && this.expectPlugin("asyncDoExpressions"), e.async = r, this.next();
      let i = this.state.labels;
      return this.state.labels = [], r ? (this.prodParam.enter(2), e.body = this.parseBlock(), this.prodParam.exit()) : e.body = this.parseBlock(),
      this.state.labels = i, this.finishNode(e, "DoExpression");
    }
    parseSuper() {
      let e = this.startNode();
      return this.next(), this.match(10) && !this.scope.allowDirectSuper && !(this.optionFlags & 16) ? this.raise(g.SuperNotAllowed, e) : !this.
      scope.allowSuper && !(this.optionFlags & 16) && this.raise(g.UnexpectedSuper, e), !this.match(10) && !this.match(0) && !this.match(16) &&
      this.raise(g.UnsupportedSuper, e), this.finishNode(e, "Super");
    }
    parsePrivateName() {
      let e = this.startNode(), r = this.startNodeAt(Ze(this.state.startLoc, 1)), i = this.state.value;
      return this.next(), e.id = this.createIdentifier(r, i), this.finishNode(e, "PrivateName");
    }
    parseFunctionOrFunctionSent() {
      let e = this.startNode();
      if (this.next(), this.prodParam.hasYield && this.match(16)) {
        let r = this.createIdentifier(this.startNodeAtNode(e), "function");
        return this.next(), this.match(103) ? this.expectPlugin("functionSent") : this.hasPlugin("functionSent") || this.unexpected(), this.
        parseMetaProperty(e, r, "sent");
      }
      return this.parseFunction(e);
    }
    parseMetaProperty(e, r, i) {
      e.meta = r;
      let n = this.state.containsEsc;
      return e.property = this.parseIdentifier(!0), (e.property.name !== i || n) && this.raise(g.UnsupportedMetaProperty, e.property, {
        target: r.name,
        onlyValidPropertyName: i
      }), this.finishNode(e, "MetaProperty");
    }
    parseImportMetaProperty(e) {
      let r = this.createIdentifier(this.startNodeAtNode(e), "import");
      if (this.next(), this.isContextual(101))
        this.inModule || this.raise(g.ImportMetaOutsideModule, r), this.sawUnambiguousESM = !0;
      else if (this.isContextual(105) || this.isContextual(97)) {
        let i = this.isContextual(105);
        if (this.expectPlugin(i ? "sourcePhaseImports" : "deferredImportEvaluation"), !(this.optionFlags & 512))
          throw this.raise(g.DynamicImportPhaseRequiresImportExpressions, this.state.startLoc, {
            phase: this.state.value
          });
        return this.next(), e.phase = i ? "source" : "defer", this.parseImportCall(e);
      }
      return this.parseMetaProperty(e, r, "meta");
    }
    parseLiteralAtNode(e, r, i) {
      return this.addExtra(i, "rawValue", e), this.addExtra(i, "raw", this.input.slice(this.offsetToSourcePos(i.start), this.state.end)), i.
      value = e, this.next(), this.finishNode(i, r);
    }
    parseLiteral(e, r) {
      let i = this.startNode();
      return this.parseLiteralAtNode(e, r, i);
    }
    parseStringLiteral(e) {
      return this.parseLiteral(e, "StringLiteral");
    }
    parseNumericLiteral(e) {
      return this.parseLiteral(e, "NumericLiteral");
    }
    parseBigIntLiteral(e) {
      return this.parseLiteral(e, "BigIntLiteral");
    }
    parseDecimalLiteral(e) {
      return this.parseLiteral(e, "DecimalLiteral");
    }
    parseRegExpLiteral(e) {
      let r = this.startNode();
      return this.addExtra(r, "raw", this.input.slice(this.offsetToSourcePos(r.start), this.state.end)), r.pattern = e.pattern, r.flags = e.
      flags, this.next(), this.finishNode(r, "RegExpLiteral");
    }
    parseBooleanLiteral(e) {
      let r = this.startNode();
      return r.value = e, this.next(), this.finishNode(r, "BooleanLiteral");
    }
    parseNullLiteral() {
      let e = this.startNode();
      return this.next(), this.finishNode(e, "NullLiteral");
    }
    parseParenAndDistinguishExpression(e) {
      let r = this.state.startLoc, i;
      this.next(), this.expressionScope.enter(fB());
      let n = this.state.maybeInArrowParameters, a = this.state.inFSharpPipelineDirectBody;
      this.state.maybeInArrowParameters = !0, this.state.inFSharpPipelineDirectBody = !1;
      let o = this.state.startLoc, l = [], u = new Tr(), p = !0, h, E;
      for (; !this.match(11); ) {
        if (p)
          p = !1;
        else if (this.expect(12, u.optionalParametersLoc === null ? null : u.optionalParametersLoc), this.match(11)) {
          E = this.state.startLoc;
          break;
        }
        if (this.match(21)) {
          let _ = this.state.startLoc;
          if (h = this.state.startLoc, l.push(this.parseParenItem(this.parseRestBinding(), _)), !this.checkCommaAfterRest(41))
            break;
        } else
          l.push(this.parseMaybeAssignAllowIn(u, this.parseParenItem));
      }
      let I = this.state.lastTokEndLoc;
      this.expect(11), this.state.maybeInArrowParameters = n, this.state.inFSharpPipelineDirectBody = a;
      let v = this.startNodeAt(r);
      return e && this.shouldParseArrow(l) && (v = this.parseArrow(v)) ? (this.checkDestructuringPrivate(u), this.expressionScope.validateAsPattern(),
      this.expressionScope.exit(), this.parseArrowExpression(v, l, !1), v) : (this.expressionScope.exit(), l.length || this.unexpected(this.
      state.lastTokStartLoc), E && this.unexpected(E), h && this.unexpected(h), this.checkExpressionErrors(u, !0), this.toReferencedListDeep(
      l, !0), l.length > 1 ? (i = this.startNodeAt(o), i.expressions = l, this.finishNode(i, "SequenceExpression"), this.resetEndLocation(i,
      I)) : i = l[0], this.wrapParenthesis(r, i));
    }
    wrapParenthesis(e, r) {
      if (!(this.optionFlags & 1024))
        return this.addExtra(r, "parenthesized", !0), this.addExtra(r, "parenStart", e.index), this.takeSurroundingComments(r, e.index, this.
        state.lastTokEndLoc.index), r;
      let i = this.startNodeAt(e);
      return i.expression = r, this.finishNode(i, "ParenthesizedExpression");
    }
    shouldParseArrow(e) {
      return !this.canInsertSemicolon();
    }
    parseArrow(e) {
      if (this.eat(19))
        return e;
    }
    parseParenItem(e, r) {
      return e;
    }
    parseNewOrNewTarget() {
      let e = this.startNode();
      if (this.next(), this.match(16)) {
        let r = this.createIdentifier(this.startNodeAtNode(e), "new");
        this.next();
        let i = this.parseMetaProperty(e, r, "target");
        return !this.scope.inNonArrowFunction && !this.scope.inClass && !(this.optionFlags & 4) && this.raise(g.UnexpectedNewTarget, i), i;
      }
      return this.parseNew(e);
    }
    parseNew(e) {
      if (this.parseNewCallee(e), this.eat(10)) {
        let r = this.parseExprList(11);
        this.toReferencedList(r), e.arguments = r;
      } else
        e.arguments = [];
      return this.finishNode(e, "NewExpression");
    }
    parseNewCallee(e) {
      let r = this.match(83), i = this.parseNoCallExpr();
      e.callee = i, r && (i.type === "Import" || i.type === "ImportExpression") && this.raise(g.ImportCallNotNewExpression, i);
    }
    parseTemplateElement(e) {
      let {
        start: r,
        startLoc: i,
        end: n,
        value: a
      } = this.state, o = r + 1, l = this.startNodeAt(Ze(i, 1));
      a === null && (e || this.raise(g.InvalidEscapeSequenceTemplate, Ze(this.state.firstInvalidTemplateEscapePos, 1)));
      let u = this.match(24), p = u ? -1 : -2, h = n + p;
      l.value = {
        raw: this.input.slice(o, h).replace(/\r\n?/g, `
`),
        cooked: a === null ? null : a.slice(1, p)
      }, l.tail = u, this.next();
      let E = this.finishNode(l, "TemplateElement");
      return this.resetEndLocation(E, Ze(this.state.lastTokEndLoc, p)), E;
    }
    parseTemplate(e) {
      let r = this.startNode(), i = this.parseTemplateElement(e), n = [i], a = [];
      for (; !i.tail; )
        a.push(this.parseTemplateSubstitution()), this.readTemplateContinuation(), n.push(i = this.parseTemplateElement(e));
      return r.expressions = a, r.quasis = n, this.finishNode(r, "TemplateLiteral");
    }
    parseTemplateSubstitution() {
      return this.parseExpression();
    }
    parseObjectLike(e, r, i, n) {
      i && this.expectPlugin("recordAndTuple");
      let a = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !1;
      let o = !1, l = !0, u = this.startNode();
      for (u.properties = [], this.next(); !this.match(e); ) {
        if (l)
          l = !1;
        else if (this.expect(12), this.match(e)) {
          this.addTrailingCommaExtraToNode(u);
          break;
        }
        let h;
        r ? h = this.parseBindingProperty() : (h = this.parsePropertyDefinition(n), o = this.checkProto(h, i, o, n)), i && !this.isObjectProperty(
        h) && h.type !== "SpreadElement" && this.raise(g.InvalidRecordProperty, h), h.shorthand && this.addExtra(h, "shorthand", !0), u.properties.
        push(h);
      }
      this.next(), this.state.inFSharpPipelineDirectBody = a;
      let p = "ObjectExpression";
      return r ? p = "ObjectPattern" : i && (p = "RecordExpression"), this.finishNode(u, p);
    }
    addTrailingCommaExtraToNode(e) {
      this.addExtra(e, "trailingComma", this.state.lastTokStartLoc.index), this.addExtra(e, "trailingCommaLoc", this.state.lastTokStartLoc, !1);
    }
    maybeAsyncOrAccessorProp(e) {
      return !e.computed && e.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
    }
    parsePropertyDefinition(e) {
      let r = [];
      if (this.match(26))
        for (this.hasPlugin("decorators") && this.raise(g.UnsupportedPropertyDecorator, this.state.startLoc); this.match(26); )
          r.push(this.parseDecorator());
      let i = this.startNode(), n = !1, a = !1, o;
      if (this.match(21))
        return r.length && this.unexpected(), this.parseSpread();
      r.length && (i.decorators = r, r = []), i.method = !1, e && (o = this.state.startLoc);
      let l = this.eat(55);
      this.parsePropertyNamePrefixOperator(i);
      let u = this.state.containsEsc;
      if (this.parsePropertyName(i, e), !l && !u && this.maybeAsyncOrAccessorProp(i)) {
        let {
          key: p
        } = i, h = p.name;
        h === "async" && !this.hasPrecedingLineBreak() && (n = !0, this.resetPreviousNodeTrailingComments(p), l = this.eat(55), this.parsePropertyName(
        i)), (h === "get" || h === "set") && (a = !0, this.resetPreviousNodeTrailingComments(p), i.kind = h, this.match(55) && (l = !0, this.
        raise(g.AccessorIsGenerator, this.state.curPosition(), {
          kind: h
        }), this.next()), this.parsePropertyName(i));
      }
      return this.parseObjPropValue(i, o, l, n, !1, a, e);
    }
    getGetterSetterExpectedParamCount(e) {
      return e.kind === "get" ? 0 : 1;
    }
    getObjectOrClassMethodParams(e) {
      return e.params;
    }
    checkGetterSetterParams(e) {
      var r;
      let i = this.getGetterSetterExpectedParamCount(e), n = this.getObjectOrClassMethodParams(e);
      n.length !== i && this.raise(e.kind === "get" ? g.BadGetterArity : g.BadSetterArity, e), e.kind === "set" && ((r = n[n.length - 1]) ==
      null ? void 0 : r.type) === "RestElement" && this.raise(g.BadSetterRestParameter, e);
    }
    parseObjectMethod(e, r, i, n, a) {
      if (a) {
        let o = this.parseMethod(e, r, !1, !1, !1, "ObjectMethod");
        return this.checkGetterSetterParams(o), o;
      }
      if (i || r || this.match(10))
        return n && this.unexpected(), e.kind = "method", e.method = !0, this.parseMethod(e, r, i, !1, !1, "ObjectMethod");
    }
    parseObjectProperty(e, r, i, n) {
      if (e.shorthand = !1, this.eat(14))
        return e.value = i ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowIn(n), this.finishNode(e, "ObjectProper\
ty");
      if (!e.computed && e.key.type === "Identifier") {
        if (this.checkReservedWord(e.key.name, e.key.loc.start, !0, !1), i)
          e.value = this.parseMaybeDefault(r, Dt(e.key));
        else if (this.match(29)) {
          let a = this.state.startLoc;
          n != null ? n.shorthandAssignLoc === null && (n.shorthandAssignLoc = a) : this.raise(g.InvalidCoverInitializedName, a), e.value = this.
          parseMaybeDefault(r, Dt(e.key));
        } else
          e.value = Dt(e.key);
        return e.shorthand = !0, this.finishNode(e, "ObjectProperty");
      }
    }
    parseObjPropValue(e, r, i, n, a, o, l) {
      let u = this.parseObjectMethod(e, i, n, a, o) || this.parseObjectProperty(e, r, a, l);
      return u || this.unexpected(), u;
    }
    parsePropertyName(e, r) {
      if (this.eat(0))
        e.computed = !0, e.key = this.parseMaybeAssignAllowIn(), this.expect(3);
      else {
        let {
          type: i,
          value: n
        } = this.state, a;
        if (mt(i))
          a = this.parseIdentifier(!0);
        else
          switch (i) {
            case 135:
              a = this.parseNumericLiteral(n);
              break;
            case 134:
              a = this.parseStringLiteral(n);
              break;
            case 136:
              a = this.parseBigIntLiteral(n);
              break;
            case 139: {
              let o = this.state.startLoc;
              r != null ? r.privateKeyLoc === null && (r.privateKeyLoc = o) : this.raise(g.UnexpectedPrivateField, o), a = this.parsePrivateName();
              break;
            }
            default:
              if (i === 137) {
                a = this.parseDecimalLiteral(n);
                break;
              }
              this.unexpected();
          }
        e.key = a, i !== 139 && (e.computed = !1);
      }
    }
    initFunction(e, r) {
      e.id = null, e.generator = !1, e.async = r;
    }
    parseMethod(e, r, i, n, a, o, l = !1) {
      this.initFunction(e, i), e.generator = r, this.scope.enter(18 | (l ? 64 : 0) | (a ? 32 : 0)), this.prodParam.enter(rs(i, e.generator)),
      this.parseFunctionParams(e, n);
      let u = this.parseFunctionBodyAndFinish(e, o, !0);
      return this.prodParam.exit(), this.scope.exit(), u;
    }
    parseArrayLike(e, r, i, n) {
      i && this.expectPlugin("recordAndTuple");
      let a = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !1;
      let o = this.startNode();
      return this.next(), o.elements = this.parseExprList(e, !i, n, o), this.state.inFSharpPipelineDirectBody = a, this.finishNode(o, i ? "T\
upleExpression" : "ArrayExpression");
    }
    parseArrowExpression(e, r, i, n) {
      this.scope.enter(6);
      let a = rs(i, !1);
      !this.match(5) && this.prodParam.hasIn && (a |= 8), this.prodParam.enter(a), this.initFunction(e, i);
      let o = this.state.maybeInArrowParameters;
      return r && (this.state.maybeInArrowParameters = !0, this.setArrowFunctionParameters(e, r, n)), this.state.maybeInArrowParameters = !1,
      this.parseFunctionBody(e, !0), this.prodParam.exit(), this.scope.exit(), this.state.maybeInArrowParameters = o, this.finishNode(e, "Ar\
rowFunctionExpression");
    }
    setArrowFunctionParameters(e, r, i) {
      this.toAssignableList(r, i, !1), e.params = r;
    }
    parseFunctionBodyAndFinish(e, r, i = !1) {
      return this.parseFunctionBody(e, !1, i), this.finishNode(e, r);
    }
    parseFunctionBody(e, r, i = !1) {
      let n = r && !this.match(5);
      if (this.expressionScope.enter(Ip()), n)
        e.body = this.parseMaybeAssign(), this.checkParams(e, !1, r, !1);
      else {
        let a = this.state.strict, o = this.state.labels;
        this.state.labels = [], this.prodParam.enter(this.prodParam.currentFlags() | 4), e.body = this.parseBlock(!0, !1, (l) => {
          let u = !this.isSimpleParamList(e.params);
          l && u && this.raise(g.IllegalLanguageModeDirective, (e.kind === "method" || e.kind === "constructor") && e.key ? e.key.loc.end : e);
          let p = !a && this.state.strict;
          this.checkParams(e, !this.state.strict && !r && !i && !u, r, p), this.state.strict && e.id && this.checkIdentifier(e.id, 65, p);
        }), this.prodParam.exit(), this.state.labels = o;
      }
      this.expressionScope.exit();
    }
    isSimpleParameter(e) {
      return e.type === "Identifier";
    }
    isSimpleParamList(e) {
      for (let r = 0, i = e.length; r < i; r++)
        if (!this.isSimpleParameter(e[r])) return !1;
      return !0;
    }
    checkParams(e, r, i, n = !0) {
      let a = !r && /* @__PURE__ */ new Set(), o = {
        type: "FormalParameters"
      };
      for (let l of e.params)
        this.checkLVal(l, o, 5, a, n);
    }
    parseExprList(e, r, i, n) {
      let a = [], o = !0;
      for (; !this.eat(e); ) {
        if (o)
          o = !1;
        else if (this.expect(12), this.match(e)) {
          n && this.addTrailingCommaExtraToNode(n), this.next();
          break;
        }
        a.push(this.parseExprListItem(r, i));
      }
      return a;
    }
    parseExprListItem(e, r, i) {
      let n;
      if (this.match(12))
        e || this.raise(g.UnexpectedToken, this.state.curPosition(), {
          unexpected: ","
        }), n = null;
      else if (this.match(21)) {
        let a = this.state.startLoc;
        n = this.parseParenItem(this.parseSpread(r), a);
      } else if (this.match(17)) {
        this.expectPlugin("partialApplication"), i || this.raise(g.UnexpectedArgumentPlaceholder, this.state.startLoc);
        let a = this.startNode();
        this.next(), n = this.finishNode(a, "ArgumentPlaceholder");
      } else
        n = this.parseMaybeAssignAllowIn(r, this.parseParenItem);
      return n;
    }
    parseIdentifier(e) {
      let r = this.startNode(), i = this.parseIdentifierName(e);
      return this.createIdentifier(r, i);
    }
    createIdentifier(e, r) {
      return e.name = r, e.loc.identifierName = r, this.finishNode(e, "Identifier");
    }
    parseIdentifierName(e) {
      let r, {
        startLoc: i,
        type: n
      } = this.state;
      mt(n) ? r = this.state.value : this.unexpected();
      let a = F3(n);
      return e ? a && this.replaceToken(132) : this.checkReservedWord(r, i, a, !1), this.next(), r;
    }
    checkReservedWord(e, r, i, n) {
      if (e.length > 10 || !iB(e))
        return;
      if (i && eB(e)) {
        this.raise(g.UnexpectedKeyword, r, {
          keyword: e
        });
        return;
      }
      if ((this.state.strict ? n ? gp : bp : Sp)(e, this.inModule)) {
        this.raise(g.UnexpectedReservedWord, r, {
          reservedWord: e
        });
        return;
      } else if (e === "yield") {
        if (this.prodParam.hasYield) {
          this.raise(g.YieldBindingIdentifier, r);
          return;
        }
      } else if (e === "await") {
        if (this.prodParam.hasAwait) {
          this.raise(g.AwaitBindingIdentifier, r);
          return;
        }
        if (this.scope.inStaticBlock) {
          this.raise(g.AwaitBindingIdentifierInStaticBlock, r);
          return;
        }
        this.expressionScope.recordAsyncArrowParametersError(r);
      } else if (e === "arguments" && this.scope.inClassAndNotInNonArrowFunction) {
        this.raise(g.ArgumentsInClass, r);
        return;
      }
    }
    recordAwaitIfAllowed() {
      let e = this.prodParam.hasAwait || this.optionFlags & 1 && !this.scope.inFunction;
      return e && !this.scope.inFunction && (this.state.hasTopLevelAwait = !0), e;
    }
    parseAwait(e) {
      let r = this.startNodeAt(e);
      return this.expressionScope.recordParameterInitializerError(g.AwaitExpressionFormalParameter, r), this.eat(55) && this.raise(g.ObsoleteAwaitStar,
      r), !this.scope.inFunction && !(this.optionFlags & 1) && (this.isAmbiguousPrefixOrIdentifier() ? this.ambiguousScriptDifferentAst = !0 :
      this.sawUnambiguousESM = !0), this.state.soloAwait || (r.argument = this.parseMaybeUnary(null, !0)), this.finishNode(r, "AwaitExpressi\
on");
    }
    isAmbiguousPrefixOrIdentifier() {
      if (this.hasPrecedingLineBreak()) return !0;
      let {
        type: e
      } = this.state;
      return e === 53 || e === 10 || e === 0 || ss(e) || e === 102 && !this.state.containsEsc || e === 138 || e === 56 || this.hasPlugin("v8\
intrinsic") && e === 54;
    }
    parseYield(e) {
      let r = this.startNodeAt(e);
      this.expressionScope.recordParameterInitializerError(g.YieldInParameter, r);
      let i = !1, n = null;
      if (!this.hasPrecedingLineBreak())
        switch (i = this.eat(55), this.state.type) {
          case 13:
          case 140:
          case 8:
          case 11:
          case 3:
          case 9:
          case 14:
          case 12:
            if (!i) break;
          default:
            n = this.parseMaybeAssign();
        }
      return r.delegate = i, r.argument = n, this.finishNode(r, "YieldExpression");
    }
    parseImportCall(e) {
      if (this.next(), e.source = this.parseMaybeAssignAllowIn(), e.options = null, this.eat(12) && !this.match(11) && (e.options = this.parseMaybeAssignAllowIn(),
      this.eat(12) && !this.match(11))) {
        do
          this.parseMaybeAssignAllowIn();
        while (this.eat(12) && !this.match(11));
        this.raise(g.ImportCallArity, e);
      }
      return this.expect(11), this.finishNode(e, "ImportExpression");
    }
    checkPipelineAtInfixOperator(e, r) {
      this.hasPlugin(["pipelineOperator", {
        proposal: "smart"
      }]) && e.type === "SequenceExpression" && this.raise(g.PipelineHeadSequenceExpression, r);
    }
    parseSmartPipelineBodyInStyle(e, r) {
      if (this.isSimpleReference(e)) {
        let i = this.startNodeAt(r);
        return i.callee = e, this.finishNode(i, "PipelineBareFunction");
      } else {
        let i = this.startNodeAt(r);
        return this.checkSmartPipeTopicBodyEarlyErrors(r), i.expression = e, this.finishNode(i, "PipelineTopicExpression");
      }
    }
    isSimpleReference(e) {
      switch (e.type) {
        case "MemberExpression":
          return !e.computed && this.isSimpleReference(e.object);
        case "Identifier":
          return !0;
        default:
          return !1;
      }
    }
    checkSmartPipeTopicBodyEarlyErrors(e) {
      if (this.match(19))
        throw this.raise(g.PipelineBodyNoArrow, this.state.startLoc);
      this.topicReferenceWasUsedInCurrentContext() || this.raise(g.PipelineTopicUnused, e);
    }
    withTopicBindingContext(e) {
      let r = this.state.topicContext;
      this.state.topicContext = {
        maxNumOfResolvableTopics: 1,
        maxTopicIndex: null
      };
      try {
        return e();
      } finally {
        this.state.topicContext = r;
      }
    }
    withSmartMixTopicForbiddingContext(e) {
      if (this.hasPlugin(["pipelineOperator", {
        proposal: "smart"
      }])) {
        let r = this.state.topicContext;
        this.state.topicContext = {
          maxNumOfResolvableTopics: 0,
          maxTopicIndex: null
        };
        try {
          return e();
        } finally {
          this.state.topicContext = r;
        }
      } else
        return e();
    }
    withSoloAwaitPermittingContext(e) {
      let r = this.state.soloAwait;
      this.state.soloAwait = !0;
      try {
        return e();
      } finally {
        this.state.soloAwait = r;
      }
    }
    allowInAnd(e) {
      let r = this.prodParam.currentFlags();
      if (8 & ~r) {
        this.prodParam.enter(r | 8);
        try {
          return e();
        } finally {
          this.prodParam.exit();
        }
      }
      return e();
    }
    disallowInAnd(e) {
      let r = this.prodParam.currentFlags();
      if (8 & r) {
        this.prodParam.enter(r & -9);
        try {
          return e();
        } finally {
          this.prodParam.exit();
        }
      }
      return e();
    }
    registerTopicReference() {
      this.state.topicContext.maxTopicIndex = 0;
    }
    topicReferenceIsAllowedInCurrentContext() {
      return this.state.topicContext.maxNumOfResolvableTopics >= 1;
    }
    topicReferenceWasUsedInCurrentContext() {
      return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
    }
    parseFSharpPipelineBody(e) {
      let r = this.state.startLoc;
      this.state.potentialArrowAt = this.state.start;
      let i = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !0;
      let n = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), r, e);
      return this.state.inFSharpPipelineDirectBody = i, n;
    }
    parseModuleExpression() {
      this.expectPlugin("moduleBlocks");
      let e = this.startNode();
      this.next(), this.match(5) || this.unexpected(null, 5);
      let r = this.startNodeAt(this.state.endLoc);
      this.next();
      let i = this.initializeScopes(!0);
      this.enterInitialScopes();
      try {
        e.body = this.parseProgram(r, 8, "module");
      } finally {
        i();
      }
      return this.finishNode(e, "ModuleExpression");
    }
    parsePropertyNamePrefixOperator(e) {
    }
  }, eo = {
    kind: 1
  }, MB = {
    kind: 2
  }, BB = /[\uD800-\uDFFF]/u, to = /in(?:stanceof)?/y;
  function jB(t, e, r) {
    for (let i = 0; i < t.length; i++) {
      let n = t[i], {
        type: a
      } = n;
      if (typeof a == "number") {
        {
          if (a === 139) {
            let {
              loc: o,
              start: l,
              value: u,
              end: p
            } = n, h = l + 1, E = Ze(o.start, 1);
            t.splice(i, 1, new gt({
              type: wt(27),
              value: "#",
              start: l,
              end: h,
              startLoc: o.start,
              endLoc: E
            }), new gt({
              type: wt(132),
              value: u,
              start: h,
              end: p,
              startLoc: E,
              endLoc: o.end
            })), i++;
            continue;
          }
          if (ss(a)) {
            let {
              loc: o,
              start: l,
              value: u,
              end: p
            } = n, h = l + 1, E = Ze(o.start, 1), I;
            e.charCodeAt(l - r) === 96 ? I = new gt({
              type: wt(22),
              value: "`",
              start: l,
              end: h,
              startLoc: o.start,
              endLoc: E
            }) : I = new gt({
              type: wt(8),
              value: "}",
              start: l,
              end: h,
              startLoc: o.start,
              endLoc: E
            });
            let v, _, j, O;
            a === 24 ? (_ = p - 1, j = Ze(o.end, -1), v = u === null ? null : u.slice(1, -1), O = new gt({
              type: wt(22),
              value: "`",
              start: _,
              end: p,
              startLoc: j,
              endLoc: o.end
            })) : (_ = p - 2, j = Ze(o.end, -2), v = u === null ? null : u.slice(1, -2), O = new gt({
              type: wt(23),
              value: "${",
              start: _,
              end: p,
              startLoc: j,
              endLoc: o.end
            })), t.splice(i, 1, I, new gt({
              type: wt(20),
              value: v,
              start: h,
              end: _,
              startLoc: E,
              endLoc: j
            }), O), i += 2;
            continue;
          }
        }
        n.type = wt(a);
      }
    }
    return t;
  }
  s(jB, "babel7CompatTokens");
  var go = class extends xo {
    static {
      s(this, "StatementParser");
    }
    parseTopLevel(e, r) {
      return e.program = this.parseProgram(r), e.comments = this.comments, this.optionFlags & 256 && (e.tokens = jB(this.tokens, this.input,
      this.startIndex)), this.finishNode(e, "File");
    }
    parseProgram(e, r = 140, i = this.options.sourceType) {
      if (e.sourceType = i, e.interpreter = this.parseInterpreterDirective(), this.parseBlockBody(e, !0, !0, r), this.inModule) {
        if (!(this.optionFlags & 64) && this.scope.undefinedExports.size > 0)
          for (let [a, o] of Array.from(this.scope.undefinedExports))
            this.raise(g.ModuleExportUndefined, o, {
              localName: a
            });
        this.addExtra(e, "topLevelAwait", this.state.hasTopLevelAwait);
      }
      let n;
      return r === 140 ? n = this.finishNode(e, "Program") : n = this.finishNodeAt(e, "Program", Ze(this.state.startLoc, -1)), n;
    }
    stmtToDirective(e) {
      let r = e;
      r.type = "Directive", r.value = r.expression, delete r.expression;
      let i = r.value, n = i.value, a = this.input.slice(this.offsetToSourcePos(i.start), this.offsetToSourcePos(i.end)), o = i.value = a.slice(
      1, -1);
      return this.addExtra(i, "raw", a), this.addExtra(i, "rawValue", o), this.addExtra(i, "expressionValue", n), i.type = "DirectiveLiteral",
      r;
    }
    parseInterpreterDirective() {
      if (!this.match(28))
        return null;
      let e = this.startNode();
      return e.value = this.state.value, this.next(), this.finishNode(e, "InterpreterDirective");
    }
    isLet() {
      return this.isContextual(100) ? this.hasFollowingBindingAtom() : !1;
    }
    chStartsBindingIdentifier(e, r) {
      if (Ot(e)) {
        if (to.lastIndex = r, to.test(this.input)) {
          let i = this.codePointAtPos(to.lastIndex);
          if (!mr(i) && i !== 92)
            return !1;
        }
        return !0;
      } else return e === 92;
    }
    chStartsBindingPattern(e) {
      return e === 91 || e === 123;
    }
    hasFollowingBindingAtom() {
      let e = this.nextTokenStart(), r = this.codePointAtPos(e);
      return this.chStartsBindingPattern(r) || this.chStartsBindingIdentifier(r, e);
    }
    hasInLineFollowingBindingIdentifierOrBrace() {
      let e = this.nextTokenInLineStart(), r = this.codePointAtPos(e);
      return r === 123 || this.chStartsBindingIdentifier(r, e);
    }
    startsUsingForOf() {
      let {
        type: e,
        containsEsc: r
      } = this.lookahead();
      if (e === 102 && !r)
        return !1;
      if (ve(e) && !this.hasFollowingLineBreak())
        return this.expectPlugin("explicitResourceManagement"), !0;
    }
    startsAwaitUsing() {
      let e = this.nextTokenInLineStart();
      if (this.isUnparsedContextual(e, "using")) {
        e = this.nextTokenInLineStartSince(e + 5);
        let r = this.codePointAtPos(e);
        if (this.chStartsBindingIdentifier(r, e))
          return this.expectPlugin("explicitResourceManagement"), !0;
      }
      return !1;
    }
    parseModuleItem() {
      return this.parseStatementLike(15);
    }
    parseStatementListItem() {
      return this.parseStatementLike(6 | (!this.options.annexB || this.state.strict ? 0 : 8));
    }
    parseStatementOrSloppyAnnexBFunctionDeclaration(e = !1) {
      let r = 0;
      return this.options.annexB && !this.state.strict && (r |= 4, e && (r |= 8)), this.parseStatementLike(r);
    }
    parseStatement() {
      return this.parseStatementLike(0);
    }
    parseStatementLike(e) {
      let r = null;
      return this.match(26) && (r = this.parseDecorators(!0)), this.parseStatementContent(e, r);
    }
    parseStatementContent(e, r) {
      let i = this.state.type, n = this.startNode(), a = !!(e & 2), o = !!(e & 4), l = e & 1;
      switch (i) {
        case 60:
          return this.parseBreakContinueStatement(n, !0);
        case 63:
          return this.parseBreakContinueStatement(n, !1);
        case 64:
          return this.parseDebuggerStatement(n);
        case 90:
          return this.parseDoWhileStatement(n);
        case 91:
          return this.parseForStatement(n);
        case 68:
          if (this.lookaheadCharCode() === 46) break;
          return o || this.raise(this.state.strict ? g.StrictFunction : this.options.annexB ? g.SloppyFunctionAnnexB : g.SloppyFunction, this.
          state.startLoc), this.parseFunctionStatement(n, !1, !a && o);
        case 80:
          return a || this.unexpected(), this.parseClass(this.maybeTakeDecorators(r, n), !0);
        case 69:
          return this.parseIfStatement(n);
        case 70:
          return this.parseReturnStatement(n);
        case 71:
          return this.parseSwitchStatement(n);
        case 72:
          return this.parseThrowStatement(n);
        case 73:
          return this.parseTryStatement(n);
        case 96:
          if (!this.state.containsEsc && this.startsAwaitUsing())
            return this.recordAwaitIfAllowed() ? a || this.raise(g.UnexpectedLexicalDeclaration, n) : this.raise(g.AwaitUsingNotInAsyncContext,
            n), this.next(), this.parseVarStatement(n, "await using");
          break;
        case 107:
          if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifierOrBrace())
            break;
          return this.expectPlugin("explicitResourceManagement"), !this.scope.inModule && this.scope.inTopLevel ? this.raise(g.UnexpectedUsingDeclaration,
          this.state.startLoc) : a || this.raise(g.UnexpectedLexicalDeclaration, this.state.startLoc), this.parseVarStatement(n, "using");
        case 100: {
          if (this.state.containsEsc)
            break;
          let h = this.nextTokenStart(), E = this.codePointAtPos(h);
          if (E !== 91 && (!a && this.hasFollowingLineBreak() || !this.chStartsBindingIdentifier(E, h) && E !== 123))
            break;
        }
        case 75:
          a || this.raise(g.UnexpectedLexicalDeclaration, this.state.startLoc);
        case 74: {
          let h = this.state.value;
          return this.parseVarStatement(n, h);
        }
        case 92:
          return this.parseWhileStatement(n);
        case 76:
          return this.parseWithStatement(n);
        case 5:
          return this.parseBlock();
        case 13:
          return this.parseEmptyStatement(n);
        case 83: {
          let h = this.lookaheadCharCode();
          if (h === 40 || h === 46)
            break;
        }
        case 82: {
          !(this.optionFlags & 8) && !l && this.raise(g.UnexpectedImportExport, this.state.startLoc), this.next();
          let h;
          return i === 83 ? h = this.parseImport(n) : h = this.parseExport(n, r), this.assertModuleNodeAllowed(h), h;
        }
        default:
          if (this.isAsyncFunction())
            return a || this.raise(g.AsyncFunctionInSingleStatementContext, this.state.startLoc), this.next(), this.parseFunctionStatement(n,
            !0, !a && o);
      }
      let u = this.state.value, p = this.parseExpression();
      return ve(i) && p.type === "Identifier" && this.eat(14) ? this.parseLabeledStatement(n, u, p, e) : this.parseExpressionStatement(n, p,
      r);
    }
    assertModuleNodeAllowed(e) {
      !(this.optionFlags & 8) && !this.inModule && this.raise(g.ImportOutsideModule, e);
    }
    decoratorsEnabledBeforeExport() {
      return this.hasPlugin("decorators-legacy") ? !0 : this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBefore\
Export") !== !1;
    }
    maybeTakeDecorators(e, r, i) {
      if (e) {
        var n;
        (n = r.decorators) != null && n.length ? (typeof this.getPluginOption("decorators", "decoratorsBeforeExport") != "boolean" && this.raise(
        g.DecoratorsBeforeAfterExport, r.decorators[0]), r.decorators.unshift(...e)) : r.decorators = e, this.resetStartLocationFromNode(r, e[0]),
        i && this.resetStartLocationFromNode(i, r);
      }
      return r;
    }
    canHaveLeadingDecorator() {
      return this.match(80);
    }
    parseDecorators(e) {
      let r = [];
      do
        r.push(this.parseDecorator());
      while (this.match(26));
      if (this.match(82))
        e || this.unexpected(), this.decoratorsEnabledBeforeExport() || this.raise(g.DecoratorExportClass, this.state.startLoc);
      else if (!this.canHaveLeadingDecorator())
        throw this.raise(g.UnexpectedLeadingDecorator, this.state.startLoc);
      return r;
    }
    parseDecorator() {
      this.expectOnePlugin(["decorators", "decorators-legacy"]);
      let e = this.startNode();
      if (this.next(), this.hasPlugin("decorators")) {
        let r = this.state.startLoc, i;
        if (this.match(10)) {
          let n = this.state.startLoc;
          this.next(), i = this.parseExpression(), this.expect(11), i = this.wrapParenthesis(n, i);
          let a = this.state.startLoc;
          e.expression = this.parseMaybeDecoratorArguments(i, n), this.getPluginOption("decorators", "allowCallParenthesized") === !1 && e.expression !==
          i && this.raise(g.DecoratorArgumentsOutsideParentheses, a);
        } else {
          for (i = this.parseIdentifier(!1); this.eat(16); ) {
            let n = this.startNodeAt(r);
            n.object = i, this.match(139) ? (this.classScope.usePrivateName(this.state.value, this.state.startLoc), n.property = this.parsePrivateName()) :
            n.property = this.parseIdentifier(!0), n.computed = !1, i = this.finishNode(n, "MemberExpression");
          }
          e.expression = this.parseMaybeDecoratorArguments(i, r);
        }
      } else
        e.expression = this.parseExprSubscripts();
      return this.finishNode(e, "Decorator");
    }
    parseMaybeDecoratorArguments(e, r) {
      if (this.eat(10)) {
        let i = this.startNodeAt(r);
        return i.callee = e, i.arguments = this.parseCallExpressionArguments(11), this.toReferencedList(i.arguments), this.finishNode(i, "Ca\
llExpression");
      }
      return e;
    }
    parseBreakContinueStatement(e, r) {
      return this.next(), this.isLineTerminator() ? e.label = null : (e.label = this.parseIdentifier(), this.semicolon()), this.verifyBreakContinue(
      e, r), this.finishNode(e, r ? "BreakStatement" : "ContinueStatement");
    }
    verifyBreakContinue(e, r) {
      let i;
      for (i = 0; i < this.state.labels.length; ++i) {
        let n = this.state.labels[i];
        if ((e.label == null || n.name === e.label.name) && (n.kind != null && (r || n.kind === 1) || e.label && r))
          break;
      }
      if (i === this.state.labels.length) {
        let n = r ? "BreakStatement" : "ContinueStatement";
        this.raise(g.IllegalBreakContinue, e, {
          type: n
        });
      }
    }
    parseDebuggerStatement(e) {
      return this.next(), this.semicolon(), this.finishNode(e, "DebuggerStatement");
    }
    parseHeaderExpression() {
      this.expect(10);
      let e = this.parseExpression();
      return this.expect(11), e;
    }
    parseDoWhileStatement(e) {
      return this.next(), this.state.labels.push(eo), e.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.
      labels.pop(), this.expect(92), e.test = this.parseHeaderExpression(), this.eat(13), this.finishNode(e, "DoWhileStatement");
    }
    parseForStatement(e) {
      this.next(), this.state.labels.push(eo);
      let r = null;
      if (this.isContextual(96) && this.recordAwaitIfAllowed() && (r = this.state.startLoc, this.next()), this.scope.enter(0), this.expect(10),
      this.match(13))
        return r !== null && this.unexpected(r), this.parseFor(e, null);
      let i = this.isContextual(100);
      {
        let u = this.isContextual(96) && this.startsAwaitUsing(), p = u || this.isContextual(107) && this.startsUsingForOf(), h = i && this.
        hasFollowingBindingAtom() || p;
        if (this.match(74) || this.match(75) || h) {
          let E = this.startNode(), I;
          u ? (I = "await using", this.recordAwaitIfAllowed() || this.raise(g.AwaitUsingNotInAsyncContext, this.state.startLoc), this.next()) :
          I = this.state.value, this.next(), this.parseVar(E, !0, I);
          let v = this.finishNode(E, "VariableDeclaration"), _ = this.match(58);
          return _ && p && this.raise(g.ForInUsing, v), (_ || this.isContextual(102)) && v.declarations.length === 1 ? this.parseForIn(e, v,
          r) : (r !== null && this.unexpected(r), this.parseFor(e, v));
        }
      }
      let n = this.isContextual(95), a = new Tr(), o = this.parseExpression(!0, a), l = this.isContextual(102);
      if (l && (i && this.raise(g.ForOfLet, o), r === null && n && o.type === "Identifier" && this.raise(g.ForOfAsync, o)), l || this.match(
      58)) {
        this.checkDestructuringPrivate(a), this.toAssignable(o, !0);
        let u = l ? "ForOfStatement" : "ForInStatement";
        return this.checkLVal(o, {
          type: u
        }), this.parseForIn(e, o, r);
      } else
        this.checkExpressionErrors(a, !0);
      return r !== null && this.unexpected(r), this.parseFor(e, o);
    }
    parseFunctionStatement(e, r, i) {
      return this.next(), this.parseFunction(e, 1 | (i ? 2 : 0) | (r ? 8 : 0));
    }
    parseIfStatement(e) {
      return this.next(), e.test = this.parseHeaderExpression(), e.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration(), e.alternate =
      this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null, this.finishNode(e, "IfStatement");
    }
    parseReturnStatement(e) {
      return !this.prodParam.hasReturn && !(this.optionFlags & 2) && this.raise(g.IllegalReturn, this.state.startLoc), this.next(), this.isLineTerminator() ?
      e.argument = null : (e.argument = this.parseExpression(), this.semicolon()), this.finishNode(e, "ReturnStatement");
    }
    parseSwitchStatement(e) {
      this.next(), e.discriminant = this.parseHeaderExpression();
      let r = e.cases = [];
      this.expect(5), this.state.labels.push(MB), this.scope.enter(0);
      let i;
      for (let n; !this.match(8); )
        if (this.match(61) || this.match(65)) {
          let a = this.match(61);
          i && this.finishNode(i, "SwitchCase"), r.push(i = this.startNode()), i.consequent = [], this.next(), a ? i.test = this.parseExpression() :
          (n && this.raise(g.MultipleDefaultsInSwitch, this.state.lastTokStartLoc), n = !0, i.test = null), this.expect(14);
        } else
          i ? i.consequent.push(this.parseStatementListItem()) : this.unexpected();
      return this.scope.exit(), i && this.finishNode(i, "SwitchCase"), this.next(), this.state.labels.pop(), this.finishNode(e, "SwitchState\
ment");
    }
    parseThrowStatement(e) {
      return this.next(), this.hasPrecedingLineBreak() && this.raise(g.NewlineAfterThrow, this.state.lastTokEndLoc), e.argument = this.parseExpression(),
      this.semicolon(), this.finishNode(e, "ThrowStatement");
    }
    parseCatchClauseParam() {
      let e = this.parseBindingAtom();
      return this.scope.enter(this.options.annexB && e.type === "Identifier" ? 8 : 0), this.checkLVal(e, {
        type: "CatchClause"
      }, 9), e;
    }
    parseTryStatement(e) {
      if (this.next(), e.block = this.parseBlock(), e.handler = null, this.match(62)) {
        let r = this.startNode();
        this.next(), this.match(10) ? (this.expect(10), r.param = this.parseCatchClauseParam(), this.expect(11)) : (r.param = null, this.scope.
        enter(0)), r.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(!1, !1)), this.scope.exit(), e.handler = this.finishNode(
        r, "CatchClause");
      }
      return e.finalizer = this.eat(67) ? this.parseBlock() : null, !e.handler && !e.finalizer && this.raise(g.NoCatchOrFinally, e), this.finishNode(
      e, "TryStatement");
    }
    parseVarStatement(e, r, i = !1) {
      return this.next(), this.parseVar(e, !1, r, i), this.semicolon(), this.finishNode(e, "VariableDeclaration");
    }
    parseWhileStatement(e) {
      return this.next(), e.test = this.parseHeaderExpression(), this.state.labels.push(eo), e.body = this.withSmartMixTopicForbiddingContext(
      () => this.parseStatement()), this.state.labels.pop(), this.finishNode(e, "WhileStatement");
    }
    parseWithStatement(e) {
      return this.state.strict && this.raise(g.StrictWith, this.state.startLoc), this.next(), e.object = this.parseHeaderExpression(), e.body =
      this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.finishNode(e, "WithStatement");
    }
    parseEmptyStatement(e) {
      return this.next(), this.finishNode(e, "EmptyStatement");
    }
    parseLabeledStatement(e, r, i, n) {
      for (let o of this.state.labels)
        o.name === r && this.raise(g.LabelRedeclaration, i, {
          labelName: r
        });
      let a = U3(this.state.type) ? 1 : this.match(71) ? 2 : null;
      for (let o = this.state.labels.length - 1; o >= 0; o--) {
        let l = this.state.labels[o];
        if (l.statementStart === e.start)
          l.statementStart = this.sourceToOffsetPos(this.state.start), l.kind = a;
        else
          break;
      }
      return this.state.labels.push({
        name: r,
        kind: a,
        statementStart: this.sourceToOffsetPos(this.state.start)
      }), e.body = n & 8 ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(!0) : this.parseStatement(), this.state.labels.pop(), e.label =
      i, this.finishNode(e, "LabeledStatement");
    }
    parseExpressionStatement(e, r, i) {
      return e.expression = r, this.semicolon(), this.finishNode(e, "ExpressionStatement");
    }
    parseBlock(e = !1, r = !0, i) {
      let n = this.startNode();
      return e && this.state.strictErrors.clear(), this.expect(5), r && this.scope.enter(0), this.parseBlockBody(n, e, !1, 8, i), r && this.
      scope.exit(), this.finishNode(n, "BlockStatement");
    }
    isValidDirective(e) {
      return e.type === "ExpressionStatement" && e.expression.type === "StringLiteral" && !e.expression.extra.parenthesized;
    }
    parseBlockBody(e, r, i, n, a) {
      let o = e.body = [], l = e.directives = [];
      this.parseBlockOrModuleBlockBody(o, r ? l : void 0, i, n, a);
    }
    parseBlockOrModuleBlockBody(e, r, i, n, a) {
      let o = this.state.strict, l = !1, u = !1;
      for (; !this.match(n); ) {
        let p = i ? this.parseModuleItem() : this.parseStatementListItem();
        if (r && !u) {
          if (this.isValidDirective(p)) {
            let h = this.stmtToDirective(p);
            r.push(h), !l && h.value.value === "use strict" && (l = !0, this.setStrict(!0));
            continue;
          }
          u = !0, this.state.strictErrors.clear();
        }
        e.push(p);
      }
      a?.call(this, l), o || this.setStrict(!1), this.next();
    }
    parseFor(e, r) {
      return e.init = r, this.semicolon(!1), e.test = this.match(13) ? null : this.parseExpression(), this.semicolon(!1), e.update = this.match(
      11) ? null : this.parseExpression(), this.expect(11), e.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.
      scope.exit(), this.state.labels.pop(), this.finishNode(e, "ForStatement");
    }
    parseForIn(e, r, i) {
      let n = this.match(58);
      return this.next(), n ? i !== null && this.unexpected(i) : e.await = i !== null, r.type === "VariableDeclaration" && r.declarations[0].
      init != null && (!n || !this.options.annexB || this.state.strict || r.kind !== "var" || r.declarations[0].id.type !== "Identifier") &&
      this.raise(g.ForInOfLoopInitializer, r, {
        type: n ? "ForInStatement" : "ForOfStatement"
      }), r.type === "AssignmentPattern" && this.raise(g.InvalidLhs, r, {
        ancestor: {
          type: "ForStatement"
        }
      }), e.left = r, e.right = n ? this.parseExpression() : this.parseMaybeAssignAllowIn(), this.expect(11), e.body = this.withSmartMixTopicForbiddingContext(
      () => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(e, n ? "ForInStatement" : "ForOfStatement");
    }
    parseVar(e, r, i, n = !1) {
      let a = e.declarations = [];
      for (e.kind = i; ; ) {
        let o = this.startNode();
        if (this.parseVarId(o, i), o.init = this.eat(29) ? r ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn() : null, o.
        init === null && !n && (o.id.type !== "Identifier" && !(r && (this.match(58) || this.isContextual(102))) ? this.raise(g.DeclarationMissingInitializer,
        this.state.lastTokEndLoc, {
          kind: "destructuring"
        }) : (i === "const" || i === "using" || i === "await using") && !(this.match(58) || this.isContextual(102)) && this.raise(g.DeclarationMissingInitializer,
        this.state.lastTokEndLoc, {
          kind: i
        })), a.push(this.finishNode(o, "VariableDeclarator")), !this.eat(12)) break;
      }
      return e;
    }
    parseVarId(e, r) {
      let i = this.parseBindingAtom();
      (r === "using" || r === "await using") && (i.type === "ArrayPattern" || i.type === "ObjectPattern") && this.raise(g.UsingDeclarationHasBindingPattern,
      i.loc.start), this.checkLVal(i, {
        type: "VariableDeclarator"
      }, r === "var" ? 5 : 8201), e.id = i;
    }
    parseAsyncFunctionExpression(e) {
      return this.parseFunction(e, 8);
    }
    parseFunction(e, r = 0) {
      let i = r & 2, n = !!(r & 1), a = n && !(r & 4), o = !!(r & 8);
      this.initFunction(e, o), this.match(55) && (i && this.raise(g.GeneratorInSingleStatementContext, this.state.startLoc), this.next(), e.
      generator = !0), n && (e.id = this.parseFunctionId(a));
      let l = this.state.maybeInArrowParameters;
      return this.state.maybeInArrowParameters = !1, this.scope.enter(2), this.prodParam.enter(rs(o, e.generator)), n || (e.id = this.parseFunctionId()),
      this.parseFunctionParams(e, !1), this.withSmartMixTopicForbiddingContext(() => {
        this.parseFunctionBodyAndFinish(e, n ? "FunctionDeclaration" : "FunctionExpression");
      }), this.prodParam.exit(), this.scope.exit(), n && !i && this.registerFunctionStatementId(e), this.state.maybeInArrowParameters = l, e;
    }
    parseFunctionId(e) {
      return e || ve(this.state.type) ? this.parseIdentifier() : null;
    }
    parseFunctionParams(e, r) {
      this.expect(10), this.expressionScope.enter(pB()), e.params = this.parseBindingList(11, 41, 2 | (r ? 4 : 0)), this.expressionScope.exit();
    }
    registerFunctionStatementId(e) {
      e.id && this.scope.declareName(e.id.name, !this.options.annexB || this.state.strict || e.generator || e.async ? this.scope.treatFunctionsAsVar ?
      5 : 8201 : 17, e.id.loc.start);
    }
    parseClass(e, r, i) {
      this.next();
      let n = this.state.strict;
      return this.state.strict = !0, this.parseClassId(e, r, i), this.parseClassSuper(e), e.body = this.parseClassBody(!!e.superClass, n), this.
      finishNode(e, r ? "ClassDeclaration" : "ClassExpression");
    }
    isClassProperty() {
      return this.match(29) || this.match(13) || this.match(8);
    }
    isClassMethod() {
      return this.match(10);
    }
    nameIsConstructor(e) {
      return e.type === "Identifier" && e.name === "constructor" || e.type === "StringLiteral" && e.value === "constructor";
    }
    isNonstaticConstructor(e) {
      return !e.computed && !e.static && this.nameIsConstructor(e.key);
    }
    parseClassBody(e, r) {
      this.classScope.enter();
      let i = {
        hadConstructor: !1,
        hadSuperClass: e
      }, n = [], a = this.startNode();
      if (a.body = [], this.expect(5), this.withSmartMixTopicForbiddingContext(() => {
        for (; !this.match(8); ) {
          if (this.eat(13)) {
            if (n.length > 0)
              throw this.raise(g.DecoratorSemicolon, this.state.lastTokEndLoc);
            continue;
          }
          if (this.match(26)) {
            n.push(this.parseDecorator());
            continue;
          }
          let o = this.startNode();
          n.length && (o.decorators = n, this.resetStartLocationFromNode(o, n[0]), n = []), this.parseClassMember(a, o, i), o.kind === "cons\
tructor" && o.decorators && o.decorators.length > 0 && this.raise(g.DecoratorConstructor, o);
        }
      }), this.state.strict = r, this.next(), n.length)
        throw this.raise(g.TrailingDecorator, this.state.startLoc);
      return this.classScope.exit(), this.finishNode(a, "ClassBody");
    }
    parseClassMemberFromModifier(e, r) {
      let i = this.parseIdentifier(!0);
      if (this.isClassMethod()) {
        let n = r;
        return n.kind = "method", n.computed = !1, n.key = i, n.static = !1, this.pushClassMethod(e, n, !1, !1, !1, !1), !0;
      } else if (this.isClassProperty()) {
        let n = r;
        return n.computed = !1, n.key = i, n.static = !1, e.body.push(this.parseClassProperty(n)), !0;
      }
      return this.resetPreviousNodeTrailingComments(i), !1;
    }
    parseClassMember(e, r, i) {
      let n = this.isContextual(106);
      if (n) {
        if (this.parseClassMemberFromModifier(e, r))
          return;
        if (this.eat(5)) {
          this.parseClassStaticBlock(e, r);
          return;
        }
      }
      this.parseClassMemberWithIsStatic(e, r, i, n);
    }
    parseClassMemberWithIsStatic(e, r, i, n) {
      let a = r, o = r, l = r, u = r, p = r, h = a, E = a;
      if (r.static = n, this.parsePropertyNamePrefixOperator(r), this.eat(55)) {
        h.kind = "method";
        let k = this.match(139);
        if (this.parseClassElementName(h), k) {
          this.pushClassPrivateMethod(e, o, !0, !1);
          return;
        }
        this.isNonstaticConstructor(a) && this.raise(g.ConstructorIsGenerator, a.key), this.pushClassMethod(e, a, !0, !1, !1, !1);
        return;
      }
      let I = !this.state.containsEsc && ve(this.state.type), v = this.parseClassElementName(r), _ = I ? v.name : null, j = this.isPrivateName(
      v), O = this.state.startLoc;
      if (this.parsePostMemberNameModifiers(E), this.isClassMethod()) {
        if (h.kind = "method", j) {
          this.pushClassPrivateMethod(e, o, !1, !1);
          return;
        }
        let k = this.isNonstaticConstructor(a), B = !1;
        k && (a.kind = "constructor", i.hadConstructor && !this.hasPlugin("typescript") && this.raise(g.DuplicateConstructor, v), k && this.
        hasPlugin("typescript") && r.override && this.raise(g.OverrideOnConstructor, v), i.hadConstructor = !0, B = i.hadSuperClass), this.pushClassMethod(
        e, a, !1, !1, k, B);
      } else if (this.isClassProperty())
        j ? this.pushClassPrivateProperty(e, u) : this.pushClassProperty(e, l);
      else if (_ === "async" && !this.isLineTerminator()) {
        this.resetPreviousNodeTrailingComments(v);
        let k = this.eat(55);
        E.optional && this.unexpected(O), h.kind = "method";
        let B = this.match(139);
        this.parseClassElementName(h), this.parsePostMemberNameModifiers(E), B ? this.pushClassPrivateMethod(e, o, k, !0) : (this.isNonstaticConstructor(
        a) && this.raise(g.ConstructorIsAsync, a.key), this.pushClassMethod(e, a, k, !0, !1, !1));
      } else if ((_ === "get" || _ === "set") && !(this.match(55) && this.isLineTerminator())) {
        this.resetPreviousNodeTrailingComments(v), h.kind = _;
        let k = this.match(139);
        this.parseClassElementName(a), k ? this.pushClassPrivateMethod(e, o, !1, !1) : (this.isNonstaticConstructor(a) && this.raise(g.ConstructorIsAccessor,
        a.key), this.pushClassMethod(e, a, !1, !1, !1, !1)), this.checkGetterSetterParams(a);
      } else if (_ === "accessor" && !this.isLineTerminator()) {
        this.expectPlugin("decoratorAutoAccessors"), this.resetPreviousNodeTrailingComments(v);
        let k = this.match(139);
        this.parseClassElementName(l), this.pushClassAccessorProperty(e, p, k);
      } else this.isLineTerminator() ? j ? this.pushClassPrivateProperty(e, u) : this.pushClassProperty(e, l) : this.unexpected();
    }
    parseClassElementName(e) {
      let {
        type: r,
        value: i
      } = this.state;
      if ((r === 132 || r === 134) && e.static && i === "prototype" && this.raise(g.StaticPrototype, this.state.startLoc), r === 139) {
        i === "constructor" && this.raise(g.ConstructorClassPrivateField, this.state.startLoc);
        let n = this.parsePrivateName();
        return e.key = n, n;
      }
      return this.parsePropertyName(e), e.key;
    }
    parseClassStaticBlock(e, r) {
      var i;
      this.scope.enter(208);
      let n = this.state.labels;
      this.state.labels = [], this.prodParam.enter(0);
      let a = r.body = [];
      this.parseBlockOrModuleBlockBody(a, void 0, !1, 8), this.prodParam.exit(), this.scope.exit(), this.state.labels = n, e.body.push(this.
      finishNode(r, "StaticBlock")), (i = r.decorators) != null && i.length && this.raise(g.DecoratorStaticBlock, r);
    }
    pushClassProperty(e, r) {
      !r.computed && this.nameIsConstructor(r.key) && this.raise(g.ConstructorClassField, r.key), e.body.push(this.parseClassProperty(r));
    }
    pushClassPrivateProperty(e, r) {
      let i = this.parseClassPrivateProperty(r);
      e.body.push(i), this.classScope.declarePrivateName(this.getPrivateNameSV(i.key), 0, i.key.loc.start);
    }
    pushClassAccessorProperty(e, r, i) {
      !i && !r.computed && this.nameIsConstructor(r.key) && this.raise(g.ConstructorClassField, r.key);
      let n = this.parseClassAccessorProperty(r);
      e.body.push(n), i && this.classScope.declarePrivateName(this.getPrivateNameSV(n.key), 0, n.key.loc.start);
    }
    pushClassMethod(e, r, i, n, a, o) {
      e.body.push(this.parseMethod(r, i, n, a, o, "ClassMethod", !0));
    }
    pushClassPrivateMethod(e, r, i, n) {
      let a = this.parseMethod(r, i, n, !1, !1, "ClassPrivateMethod", !0);
      e.body.push(a);
      let o = a.kind === "get" ? a.static ? 6 : 2 : a.kind === "set" ? a.static ? 5 : 1 : 0;
      this.declareClassPrivateMethodInScope(a, o);
    }
    declareClassPrivateMethodInScope(e, r) {
      this.classScope.declarePrivateName(this.getPrivateNameSV(e.key), r, e.key.loc.start);
    }
    parsePostMemberNameModifiers(e) {
    }
    parseClassPrivateProperty(e) {
      return this.parseInitializer(e), this.semicolon(), this.finishNode(e, "ClassPrivateProperty");
    }
    parseClassProperty(e) {
      return this.parseInitializer(e), this.semicolon(), this.finishNode(e, "ClassProperty");
    }
    parseClassAccessorProperty(e) {
      return this.parseInitializer(e), this.semicolon(), this.finishNode(e, "ClassAccessorProperty");
    }
    parseInitializer(e) {
      this.scope.enter(80), this.expressionScope.enter(Ip()), this.prodParam.enter(0), e.value = this.eat(29) ? this.parseMaybeAssignAllowIn() :
      null, this.expressionScope.exit(), this.prodParam.exit(), this.scope.exit();
    }
    parseClassId(e, r, i, n = 8331) {
      if (ve(this.state.type))
        e.id = this.parseIdentifier(), r && this.declareNameFromIdentifier(e.id, n);
      else if (i || !r)
        e.id = null;
      else
        throw this.raise(g.MissingClassName, this.state.startLoc);
    }
    parseClassSuper(e) {
      e.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
    }
    parseExport(e, r) {
      let i = this.parseMaybeImportPhase(e, !0), n = this.maybeParseExportDefaultSpecifier(e, i), a = !n || this.eat(12), o = a && this.eatExportStar(
      e), l = o && this.maybeParseExportNamespaceSpecifier(e), u = a && (!l || this.eat(12)), p = n || o;
      if (o && !l) {
        if (n && this.unexpected(), r)
          throw this.raise(g.UnsupportedDecoratorExport, e);
        return this.parseExportFrom(e, !0), this.sawUnambiguousESM = !0, this.finishNode(e, "ExportAllDeclaration");
      }
      let h = this.maybeParseExportNamedSpecifiers(e);
      n && a && !o && !h && this.unexpected(null, 5), l && u && this.unexpected(null, 98);
      let E;
      if (p || h) {
        if (E = !1, r)
          throw this.raise(g.UnsupportedDecoratorExport, e);
        this.parseExportFrom(e, p);
      } else
        E = this.maybeParseExportDeclaration(e);
      if (p || h || E) {
        var I;
        let v = e;
        if (this.checkExport(v, !0, !1, !!v.source), ((I = v.declaration) == null ? void 0 : I.type) === "ClassDeclaration")
          this.maybeTakeDecorators(r, v.declaration, v);
        else if (r)
          throw this.raise(g.UnsupportedDecoratorExport, e);
        return this.sawUnambiguousESM = !0, this.finishNode(v, "ExportNamedDeclaration");
      }
      if (this.eat(65)) {
        let v = e, _ = this.parseExportDefaultExpression();
        if (v.declaration = _, _.type === "ClassDeclaration")
          this.maybeTakeDecorators(r, _, v);
        else if (r)
          throw this.raise(g.UnsupportedDecoratorExport, e);
        return this.checkExport(v, !0, !0), this.sawUnambiguousESM = !0, this.finishNode(v, "ExportDefaultDeclaration");
      }
      this.unexpected(null, 5);
    }
    eatExportStar(e) {
      return this.eat(55);
    }
    maybeParseExportDefaultSpecifier(e, r) {
      if (r || this.isExportDefaultSpecifier()) {
        this.expectPlugin("exportDefaultFrom", r?.loc.start);
        let i = r || this.parseIdentifier(!0), n = this.startNodeAtNode(i);
        return n.exported = i, e.specifiers = [this.finishNode(n, "ExportDefaultSpecifier")], !0;
      }
      return !1;
    }
    maybeParseExportNamespaceSpecifier(e) {
      if (this.isContextual(93)) {
        var r, i;
        (i = (r = e).specifiers) != null || (r.specifiers = []);
        let n = this.startNodeAt(this.state.lastTokStartLoc);
        return this.next(), n.exported = this.parseModuleExportName(), e.specifiers.push(this.finishNode(n, "ExportNamespaceSpecifier")), !0;
      }
      return !1;
    }
    maybeParseExportNamedSpecifiers(e) {
      if (this.match(5)) {
        let r = e;
        r.specifiers || (r.specifiers = []);
        let i = r.exportKind === "type";
        return r.specifiers.push(...this.parseExportSpecifiers(i)), r.source = null, this.hasPlugin("importAssertions") ? r.assertions = [] :
        r.attributes = [], r.declaration = null, !0;
      }
      return !1;
    }
    maybeParseExportDeclaration(e) {
      return this.shouldParseExportDeclaration() ? (e.specifiers = [], e.source = null, this.hasPlugin("importAssertions") ? e.assertions = [] :
      e.attributes = [], e.declaration = this.parseExportDeclaration(e), !0) : !1;
    }
    isAsyncFunction() {
      if (!this.isContextual(95)) return !1;
      let e = this.nextTokenInLineStart();
      return this.isUnparsedContextual(e, "function");
    }
    parseExportDefaultExpression() {
      let e = this.startNode();
      if (this.match(68))
        return this.next(), this.parseFunction(e, 5);
      if (this.isAsyncFunction())
        return this.next(), this.next(), this.parseFunction(e, 13);
      if (this.match(80))
        return this.parseClass(e, !0, !0);
      if (this.match(26))
        return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") === !0 && this.raise(g.DecoratorBeforeExport,
        this.state.startLoc), this.parseClass(this.maybeTakeDecorators(this.parseDecorators(!1), this.startNode()), !0, !0);
      if (this.match(75) || this.match(74) || this.isLet())
        throw this.raise(g.UnsupportedDefaultExport, this.state.startLoc);
      let r = this.parseMaybeAssignAllowIn();
      return this.semicolon(), r;
    }
    parseExportDeclaration(e) {
      return this.match(80) ? this.parseClass(this.startNode(), !0, !1) : this.parseStatementListItem();
    }
    isExportDefaultSpecifier() {
      let {
        type: e
      } = this.state;
      if (ve(e)) {
        if (e === 95 && !this.state.containsEsc || e === 100)
          return !1;
        if ((e === 130 || e === 129) && !this.state.containsEsc) {
          let {
            type: n
          } = this.lookahead();
          if (ve(n) && n !== 98 || n === 5)
            return this.expectOnePlugin(["flow", "typescript"]), !1;
        }
      } else if (!this.match(65))
        return !1;
      let r = this.nextTokenStart(), i = this.isUnparsedContextual(r, "from");
      if (this.input.charCodeAt(r) === 44 || ve(this.state.type) && i)
        return !0;
      if (this.match(65) && i) {
        let n = this.input.charCodeAt(this.nextTokenStartSince(r + 4));
        return n === 34 || n === 39;
      }
      return !1;
    }
    parseExportFrom(e, r) {
      this.eatContextual(98) ? (e.source = this.parseImportSource(), this.checkExport(e), this.maybeParseImportAttributes(e), this.checkJSONModuleImport(
      e)) : r && this.unexpected(), this.semicolon();
    }
    shouldParseExportDeclaration() {
      let {
        type: e
      } = this.state;
      return e === 26 && (this.expectOnePlugin(["decorators", "decorators-legacy"]), this.hasPlugin("decorators")) ? (this.getPluginOption("\
decorators", "decoratorsBeforeExport") === !0 && this.raise(g.DecoratorBeforeExport, this.state.startLoc), !0) : this.isContextual(107) ? (this.
      raise(g.UsingDeclarationExport, this.state.startLoc), !0) : this.isContextual(96) && this.startsAwaitUsing() ? (this.raise(g.UsingDeclarationExport,
      this.state.startLoc), !0) : e === 74 || e === 75 || e === 68 || e === 80 || this.isLet() || this.isAsyncFunction();
    }
    checkExport(e, r, i, n) {
      if (r) {
        var a;
        if (i) {
          if (this.checkDuplicateExports(e, "default"), this.hasPlugin("exportDefaultFrom")) {
            var o;
            let l = e.declaration;
            l.type === "Identifier" && l.name === "from" && l.end - l.start === 4 && !((o = l.extra) != null && o.parenthesized) && this.raise(
            g.ExportDefaultFromAsIdentifier, l);
          }
        } else if ((a = e.specifiers) != null && a.length)
          for (let l of e.specifiers) {
            let {
              exported: u
            } = l, p = u.type === "Identifier" ? u.name : u.value;
            if (this.checkDuplicateExports(l, p), !n && l.local) {
              let {
                local: h
              } = l;
              h.type !== "Identifier" ? this.raise(g.ExportBindingIsString, l, {
                localName: h.value,
                exportName: p
              }) : (this.checkReservedWord(h.name, h.loc.start, !0, !1), this.scope.checkLocalExport(h));
            }
          }
        else if (e.declaration) {
          let l = e.declaration;
          if (l.type === "FunctionDeclaration" || l.type === "ClassDeclaration") {
            let {
              id: u
            } = l;
            if (!u) throw new Error("Assertion failure");
            this.checkDuplicateExports(e, u.name);
          } else if (l.type === "VariableDeclaration")
            for (let u of l.declarations)
              this.checkDeclaration(u.id);
        }
      }
    }
    checkDeclaration(e) {
      if (e.type === "Identifier")
        this.checkDuplicateExports(e, e.name);
      else if (e.type === "ObjectPattern")
        for (let r of e.properties)
          this.checkDeclaration(r);
      else if (e.type === "ArrayPattern")
        for (let r of e.elements)
          r && this.checkDeclaration(r);
      else e.type === "ObjectProperty" ? this.checkDeclaration(e.value) : e.type === "RestElement" ? this.checkDeclaration(e.argument) : e.type ===
      "AssignmentPattern" && this.checkDeclaration(e.left);
    }
    checkDuplicateExports(e, r) {
      this.exportedIdentifiers.has(r) && (r === "default" ? this.raise(g.DuplicateDefaultExport, e) : this.raise(g.DuplicateExport, e, {
        exportName: r
      })), this.exportedIdentifiers.add(r);
    }
    parseExportSpecifiers(e) {
      let r = [], i = !0;
      for (this.expect(5); !this.eat(8); ) {
        if (i)
          i = !1;
        else if (this.expect(12), this.eat(8)) break;
        let n = this.isContextual(130), a = this.match(134), o = this.startNode();
        o.local = this.parseModuleExportName(), r.push(this.parseExportSpecifier(o, a, e, n));
      }
      return r;
    }
    parseExportSpecifier(e, r, i, n) {
      return this.eatContextual(93) ? e.exported = this.parseModuleExportName() : r ? e.exported = mB(e.local) : e.exported || (e.exported =
      Dt(e.local)), this.finishNode(e, "ExportSpecifier");
    }
    parseModuleExportName() {
      if (this.match(134)) {
        let e = this.parseStringLiteral(this.state.value), r = BB.exec(e.value);
        return r && this.raise(g.ModuleExportNameHasLoneSurrogate, e, {
          surrogateCharCode: r[0].charCodeAt(0)
        }), e;
      }
      return this.parseIdentifier(!0);
    }
    isJSONModuleImport(e) {
      return e.assertions != null ? e.assertions.some(({
        key: r,
        value: i
      }) => i.value === "json" && (r.type === "Identifier" ? r.name === "type" : r.value === "type")) : !1;
    }
    checkImportReflection(e) {
      let {
        specifiers: r
      } = e, i = r.length === 1 ? r[0].type : null;
      if (e.phase === "source")
        i !== "ImportDefaultSpecifier" && this.raise(g.SourcePhaseImportRequiresDefault, r[0].loc.start);
      else if (e.phase === "defer")
        i !== "ImportNamespaceSpecifier" && this.raise(g.DeferImportRequiresNamespace, r[0].loc.start);
      else if (e.module) {
        var n;
        i !== "ImportDefaultSpecifier" && this.raise(g.ImportReflectionNotBinding, r[0].loc.start), ((n = e.assertions) == null ? void 0 : n.
        length) > 0 && this.raise(g.ImportReflectionHasAssertion, r[0].loc.start);
      }
    }
    checkJSONModuleImport(e) {
      if (this.isJSONModuleImport(e) && e.type !== "ExportAllDeclaration") {
        let {
          specifiers: r
        } = e;
        if (r != null) {
          let i = r.find((n) => {
            let a;
            if (n.type === "ExportSpecifier" ? a = n.local : n.type === "ImportSpecifier" && (a = n.imported), a !== void 0)
              return a.type === "Identifier" ? a.name !== "default" : a.value !== "default";
          });
          i !== void 0 && this.raise(g.ImportJSONBindingNotDefault, i.loc.start);
        }
      }
    }
    isPotentialImportPhase(e) {
      return e ? !1 : this.isContextual(105) || this.isContextual(97) || this.isContextual(127);
    }
    applyImportPhase(e, r, i, n) {
      r || (i === "module" ? (this.expectPlugin("importReflection", n), e.module = !0) : this.hasPlugin("importReflection") && (e.module = !1),
      i === "source" ? (this.expectPlugin("sourcePhaseImports", n), e.phase = "source") : i === "defer" ? (this.expectPlugin("deferredImport\
Evaluation", n), e.phase = "defer") : this.hasPlugin("sourcePhaseImports") && (e.phase = null));
    }
    parseMaybeImportPhase(e, r) {
      if (!this.isPotentialImportPhase(r))
        return this.applyImportPhase(e, r, null), null;
      let i = this.parseIdentifier(!0), {
        type: n
      } = this.state;
      return (mt(n) ? n !== 98 || this.lookaheadCharCode() === 102 : n !== 12) ? (this.resetPreviousIdentifierLeadingComments(i), this.applyImportPhase(
      e, r, i.name, i.loc.start), null) : (this.applyImportPhase(e, r, null), i);
    }
    isPrecedingIdImportPhase(e) {
      let {
        type: r
      } = this.state;
      return ve(r) ? r !== 98 || this.lookaheadCharCode() === 102 : r !== 12;
    }
    parseImport(e) {
      return this.match(134) ? this.parseImportSourceAndAttributes(e) : this.parseImportSpecifiersAndAfter(e, this.parseMaybeImportPhase(e, !1));
    }
    parseImportSpecifiersAndAfter(e, r) {
      e.specifiers = [];
      let n = !this.maybeParseDefaultImportSpecifier(e, r) || this.eat(12), a = n && this.maybeParseStarImportSpecifier(e);
      return n && !a && this.parseNamedImportSpecifiers(e), this.expectContextual(98), this.parseImportSourceAndAttributes(e);
    }
    parseImportSourceAndAttributes(e) {
      var r;
      return (r = e.specifiers) != null || (e.specifiers = []), e.source = this.parseImportSource(), this.maybeParseImportAttributes(e), this.
      checkImportReflection(e), this.checkJSONModuleImport(e), this.semicolon(), this.sawUnambiguousESM = !0, this.finishNode(e, "ImportDecl\
aration");
    }
    parseImportSource() {
      return this.match(134) || this.unexpected(), this.parseExprAtom();
    }
    parseImportSpecifierLocal(e, r, i) {
      r.local = this.parseIdentifier(), e.specifiers.push(this.finishImportSpecifier(r, i));
    }
    finishImportSpecifier(e, r, i = 8201) {
      return this.checkLVal(e.local, {
        type: r
      }, i), this.finishNode(e, r);
    }
    parseImportAttributes() {
      this.expect(5);
      let e = [], r = /* @__PURE__ */ new Set();
      do {
        if (this.match(8))
          break;
        let i = this.startNode(), n = this.state.value;
        if (r.has(n) && this.raise(g.ModuleAttributesWithDuplicateKeys, this.state.startLoc, {
          key: n
        }), r.add(n), this.match(134) ? i.key = this.parseStringLiteral(n) : i.key = this.parseIdentifier(!0), this.expect(14), !this.match(
        134))
          throw this.raise(g.ModuleAttributeInvalidValue, this.state.startLoc);
        i.value = this.parseStringLiteral(this.state.value), e.push(this.finishNode(i, "ImportAttribute"));
      } while (this.eat(12));
      return this.expect(8), e;
    }
    parseModuleAttributes() {
      let e = [], r = /* @__PURE__ */ new Set();
      do {
        let i = this.startNode();
        if (i.key = this.parseIdentifier(!0), i.key.name !== "type" && this.raise(g.ModuleAttributeDifferentFromType, i.key), r.has(i.key.name) &&
        this.raise(g.ModuleAttributesWithDuplicateKeys, i.key, {
          key: i.key.name
        }), r.add(i.key.name), this.expect(14), !this.match(134))
          throw this.raise(g.ModuleAttributeInvalidValue, this.state.startLoc);
        i.value = this.parseStringLiteral(this.state.value), e.push(this.finishNode(i, "ImportAttribute"));
      } while (this.eat(12));
      return e;
    }
    maybeParseImportAttributes(e) {
      let r;
      var i = !1;
      if (this.match(76)) {
        if (this.hasPrecedingLineBreak() && this.lookaheadCharCode() === 40)
          return;
        this.next(), this.hasPlugin("moduleAttributes") ? (r = this.parseModuleAttributes(), this.addExtra(e, "deprecatedWithLegacySyntax", !0)) :
        r = this.parseImportAttributes(), i = !0;
      } else this.isContextual(94) && !this.hasPrecedingLineBreak() ? (!this.hasPlugin("deprecatedImportAssert") && !this.hasPlugin("importA\
ssertions") && this.raise(g.ImportAttributesUseAssert, this.state.startLoc), this.hasPlugin("importAssertions") || this.addExtra(e, "depreca\
tedAssertSyntax", !0), this.next(), r = this.parseImportAttributes()) : r = [];
      !i && this.hasPlugin("importAssertions") ? e.assertions = r : e.attributes = r;
    }
    maybeParseDefaultImportSpecifier(e, r) {
      if (r) {
        let i = this.startNodeAtNode(r);
        return i.local = r, e.specifiers.push(this.finishImportSpecifier(i, "ImportDefaultSpecifier")), !0;
      } else if (mt(this.state.type))
        return this.parseImportSpecifierLocal(e, this.startNode(), "ImportDefaultSpecifier"), !0;
      return !1;
    }
    maybeParseStarImportSpecifier(e) {
      if (this.match(55)) {
        let r = this.startNode();
        return this.next(), this.expectContextual(93), this.parseImportSpecifierLocal(e, r, "ImportNamespaceSpecifier"), !0;
      }
      return !1;
    }
    parseNamedImportSpecifiers(e) {
      let r = !0;
      for (this.expect(5); !this.eat(8); ) {
        if (r)
          r = !1;
        else {
          if (this.eat(14))
            throw this.raise(g.DestructureNamedImport, this.state.startLoc);
          if (this.expect(12), this.eat(8)) break;
        }
        let i = this.startNode(), n = this.match(134), a = this.isContextual(130);
        i.imported = this.parseModuleExportName();
        let o = this.parseImportSpecifier(i, n, e.importKind === "type" || e.importKind === "typeof", a, void 0);
        e.specifiers.push(o);
      }
    }
    parseImportSpecifier(e, r, i, n, a) {
      if (this.eatContextual(93))
        e.local = this.parseIdentifier();
      else {
        let {
          imported: o
        } = e;
        if (r)
          throw this.raise(g.ImportBindingIsString, e, {
            importName: o.value
          });
        this.checkReservedWord(o.name, e.loc.start, !0, !0), e.local || (e.local = Dt(o));
      }
      return this.finishImportSpecifier(e, "ImportSpecifier", a);
    }
    isThisParam(e) {
      return e.type === "Identifier" && e.name === "this";
    }
  }, as = class extends go {
    static {
      s(this, "Parser");
    }
    constructor(e, r, i) {
      e = k3(e), super(e, r), this.options = e, this.initializeScopes(), this.plugins = i, this.filename = e.sourceFilename, this.startIndex =
      e.startIndex;
      let n = 0;
      e.allowAwaitOutsideFunction && (n |= 1), e.allowReturnOutsideFunction && (n |= 2), e.allowImportExportEverywhere && (n |= 8), e.allowSuperOutsideMethod &&
      (n |= 16), e.allowUndeclaredExports && (n |= 64), e.allowNewTargetOutsideFunction && (n |= 4), e.allowYieldOutsideFunction && (n |= 32),
      e.ranges && (n |= 128), e.tokens && (n |= 256), e.createImportExpressions && (n |= 512), e.createParenthesizedExpressions && (n |= 1024),
      e.errorRecovery && (n |= 2048), e.attachComment && (n |= 4096), e.annexB && (n |= 8192), this.optionFlags = n;
    }
    getScopeHandler() {
      return Qr;
    }
    parse() {
      this.enterInitialScopes();
      let e = this.startNode(), r = this.startNode();
      return this.nextToken(), e.errors = null, this.parseTopLevel(e, r), e.errors = this.state.errors, e.comments.length = this.state.commentsLen,
      e;
    }
  };
  function FB(t, e) {
    var r;
    if (((r = e) == null ? void 0 : r.sourceType) === "unambiguous") {
      e = Object.assign({}, e);
      try {
        e.sourceType = "module";
        let i = zr(e, t), n = i.parse();
        if (i.sawUnambiguousESM)
          return n;
        if (i.ambiguousScriptDifferentAst)
          try {
            return e.sourceType = "script", zr(e, t).parse();
          } catch {
          }
        else
          n.program.sourceType = "script";
        return n;
      } catch (i) {
        try {
          return e.sourceType = "script", zr(e, t).parse();
        } catch {
        }
        throw i;
      }
    } else
      return zr(e, t).parse();
  }
  s(FB, "parse");
  function RB(t, e) {
    let r = zr(e, t);
    return r.options.strictMode && (r.state.strict = !0), r.getExpression();
  }
  s(RB, "parseExpression");
  function qB(t) {
    let e = {};
    for (let r of Object.keys(t))
      e[r] = wt(t[r]);
    return e;
  }
  s(qB, "generateExportedTokenTypes");
  var UB = qB(j3);
  function zr(t, e) {
    let r = as, i = /* @__PURE__ */ new Map();
    if (t != null && t.plugins) {
      for (let n of t.plugins) {
        let a, o;
        typeof n == "string" ? a = n : [a, o] = n, i.has(a) || i.set(a, o || {});
      }
      kB(i), r = KB(i);
    }
    return new r(t, e, i);
  }
  s(zr, "getParser");
  var dp = /* @__PURE__ */ new Map();
  function KB(t) {
    let e = [];
    for (let n of LB)
      t.has(n) && e.push(n);
    let r = e.join("|"), i = dp.get(r);
    if (!i) {
      i = as;
      for (let n of e)
        i = Np[n](i);
      dp.set(r, i);
    }
    return i;
  }
  s(KB, "getParserClass");
  ei.parse = FB;
  ei.parseExpression = RB;
  ei.tokTypes = UB;
});

// ../node_modules/magic-string/dist/magic-string.es.mjs
var qo = si(ai(), 1);
var oi = class t {
  static {
    s(this, "BitSet");
  }
  constructor(e) {
    this.bits = e instanceof t ? e.bits.slice() : [];
  }
  add(e) {
    this.bits[e >> 5] |= 1 << (e & 31);
  }
  has(e) {
    return !!(this.bits[e >> 5] & 1 << (e & 31));
  }
}, li = class t {
  static {
    s(this, "Chunk");
  }
  constructor(e, r, i) {
    this.start = e, this.end = r, this.original = i, this.intro = "", this.outro = "", this.content = i, this.storeName = !1, this.edited = !1,
    this.previous = null, this.next = null;
  }
  appendLeft(e) {
    this.outro += e;
  }
  appendRight(e) {
    this.intro = this.intro + e;
  }
  clone() {
    let e = new t(this.start, this.end, this.original);
    return e.intro = this.intro, e.outro = this.outro, e.content = this.content, e.storeName = this.storeName, e.edited = this.edited, e;
  }
  contains(e) {
    return this.start < e && e < this.end;
  }
  eachNext(e) {
    let r = this;
    for (; r; )
      e(r), r = r.next;
  }
  eachPrevious(e) {
    let r = this;
    for (; r; )
      e(r), r = r.previous;
  }
  edit(e, r, i) {
    return this.content = e, i || (this.intro = "", this.outro = ""), this.storeName = r, this.edited = !0, this;
  }
  prependLeft(e) {
    this.outro = e + this.outro;
  }
  prependRight(e) {
    this.intro = e + this.intro;
  }
  reset() {
    this.intro = "", this.outro = "", this.edited && (this.content = this.original, this.storeName = !1, this.edited = !1);
  }
  split(e) {
    let r = e - this.start, i = this.original.slice(0, r), n = this.original.slice(r);
    this.original = i;
    let a = new t(e, this.end, n);
    return a.outro = this.outro, this.outro = "", this.end = e, this.edited ? (a.edit("", !1), this.content = "") : this.content = i, a.next =
    this.next, a.next && (a.next.previous = a), a.previous = this, this.next = a, a;
  }
  toString() {
    return this.intro + this.content + this.outro;
  }
  trimEnd(e) {
    if (this.outro = this.outro.replace(e, ""), this.outro.length) return !0;
    let r = this.content.replace(e, "");
    if (r.length)
      return r !== this.content && (this.split(this.start + r.length).edit("", void 0, !0), this.edited && this.edit(r, this.storeName, !0)),
      !0;
    if (this.edit("", void 0, !0), this.intro = this.intro.replace(e, ""), this.intro.length) return !0;
  }
  trimStart(e) {
    if (this.intro = this.intro.replace(e, ""), this.intro.length) return !0;
    let r = this.content.replace(e, "");
    if (r.length) {
      if (r !== this.content) {
        let i = this.split(this.end - r.length);
        this.edited && i.edit(r, this.storeName, !0), this.edit("", void 0, !0);
      }
      return !0;
    } else if (this.edit("", void 0, !0), this.outro = this.outro.replace(e, ""), this.outro.length) return !0;
  }
};
function Up() {
  return typeof globalThis < "u" && typeof globalThis.btoa == "function" ? (t) => globalThis.btoa(unescape(encodeURIComponent(t))) : typeof Buffer ==
  "function" ? (t) => Buffer.from(t, "utf-8").toString("base64") : () => {
    throw new Error("Unsupported environment: `window.btoa` or `Buffer` should be supported.");
  };
}
s(Up, "getBtoa");
var Kp = /* @__PURE__ */ Up(), fs = class {
  static {
    s(this, "SourceMap");
  }
  constructor(e) {
    this.version = 3, this.file = e.file, this.sources = e.sources, this.sourcesContent = e.sourcesContent, this.names = e.names, this.mappings =
    (0, qo.encode)(e.mappings), typeof e.x_google_ignoreList < "u" && (this.x_google_ignoreList = e.x_google_ignoreList), typeof e.debugId <
    "u" && (this.debugId = e.debugId);
  }
  toString() {
    return JSON.stringify(this);
  }
  toUrl() {
    return "data:application/json;charset=utf-8;base64," + Kp(this.toString());
  }
};
function Vp(t) {
  let e = t.split(`
`), r = e.filter((a) => /^\t+/.test(a)), i = e.filter((a) => /^ {2,}/.test(a));
  if (r.length === 0 && i.length === 0)
    return null;
  if (r.length >= i.length)
    return "	";
  let n = i.reduce((a, o) => {
    let l = /^ +/.exec(o)[0].length;
    return Math.min(l, a);
  }, 1 / 0);
  return new Array(n + 1).join(" ");
}
s(Vp, "guessIndent");
function Yp(t, e) {
  let r = t.split(/[/\\]/), i = e.split(/[/\\]/);
  for (r.pop(); r[0] === i[0]; )
    r.shift(), i.shift();
  if (r.length) {
    let n = r.length;
    for (; n--; ) r[n] = "..";
  }
  return r.concat(i).join("/");
}
s(Yp, "getRelativePath");
var Jp = Object.prototype.toString;
function Xp(t) {
  return Jp.call(t) === "[object Object]";
}
s(Xp, "isObject");
function Ro(t) {
  let e = t.split(`
`), r = [];
  for (let i = 0, n = 0; i < e.length; i++)
    r.push(n), n += e[i].length + 1;
  return /* @__PURE__ */ s(function(n) {
    let a = 0, o = r.length;
    for (; a < o; ) {
      let p = a + o >> 1;
      n < r[p] ? o = p : a = p + 1;
    }
    let l = a - 1, u = n - r[l];
    return { line: l, column: u };
  }, "locate");
}
s(Ro, "getLocator");
var Wp = /\w/, hs = class {
  static {
    s(this, "Mappings");
  }
  constructor(e) {
    this.hires = e, this.generatedCodeLine = 0, this.generatedCodeColumn = 0, this.raw = [], this.rawSegments = this.raw[this.generatedCodeLine] =
    [], this.pending = null;
  }
  addEdit(e, r, i, n) {
    if (r.length) {
      let a = r.length - 1, o = r.indexOf(`
`, 0), l = -1;
      for (; o >= 0 && a > o; ) {
        let p = [this.generatedCodeColumn, e, i.line, i.column];
        n >= 0 && p.push(n), this.rawSegments.push(p), this.generatedCodeLine += 1, this.raw[this.generatedCodeLine] = this.rawSegments = [],
        this.generatedCodeColumn = 0, l = o, o = r.indexOf(`
`, o + 1);
      }
      let u = [this.generatedCodeColumn, e, i.line, i.column];
      n >= 0 && u.push(n), this.rawSegments.push(u), this.advance(r.slice(l + 1));
    } else this.pending && (this.rawSegments.push(this.pending), this.advance(r));
    this.pending = null;
  }
  addUneditedChunk(e, r, i, n, a) {
    let o = r.start, l = !0, u = !1;
    for (; o < r.end; ) {
      if (i[o] === `
`)
        n.line += 1, n.column = 0, this.generatedCodeLine += 1, this.raw[this.generatedCodeLine] = this.rawSegments = [], this.generatedCodeColumn =
        0, l = !0, u = !1;
      else {
        if (this.hires || l || a.has(o)) {
          let p = [this.generatedCodeColumn, e, n.line, n.column];
          this.hires === "boundary" ? Wp.test(i[o]) ? u || (this.rawSegments.push(p), u = !0) : (this.rawSegments.push(p), u = !1) : this.rawSegments.
          push(p);
        }
        n.column += 1, this.generatedCodeColumn += 1, l = !1;
      }
      o += 1;
    }
    this.pending = null;
  }
  advance(e) {
    if (!e) return;
    let r = e.split(`
`);
    if (r.length > 1) {
      for (let i = 0; i < r.length - 1; i++)
        this.generatedCodeLine++, this.raw[this.generatedCodeLine] = this.rawSegments = [];
      this.generatedCodeColumn = 0;
    }
    this.generatedCodeColumn += r[r.length - 1].length;
  }
}, Pr = `
`, ir = {
  insertLeft: !1,
  insertRight: !1,
  storeName: !1
}, ui = class t {
  static {
    s(this, "MagicString");
  }
  constructor(e, r = {}) {
    let i = new li(0, e.length, e);
    Object.defineProperties(this, {
      original: { writable: !0, value: e },
      outro: { writable: !0, value: "" },
      intro: { writable: !0, value: "" },
      firstChunk: { writable: !0, value: i },
      lastChunk: { writable: !0, value: i },
      lastSearchedChunk: { writable: !0, value: i },
      byStart: { writable: !0, value: {} },
      byEnd: { writable: !0, value: {} },
      filename: { writable: !0, value: r.filename },
      indentExclusionRanges: { writable: !0, value: r.indentExclusionRanges },
      sourcemapLocations: { writable: !0, value: new oi() },
      storedNames: { writable: !0, value: {} },
      indentStr: { writable: !0, value: void 0 },
      ignoreList: { writable: !0, value: r.ignoreList },
      offset: { writable: !0, value: r.offset || 0 }
    }), this.byStart[0] = i, this.byEnd[e.length] = i;
  }
  addSourcemapLocation(e) {
    this.sourcemapLocations.add(e);
  }
  append(e) {
    if (typeof e != "string") throw new TypeError("outro content must be a string");
    return this.outro += e, this;
  }
  appendLeft(e, r) {
    if (e = e + this.offset, typeof r != "string") throw new TypeError("inserted content must be a string");
    this._split(e);
    let i = this.byEnd[e];
    return i ? i.appendLeft(r) : this.intro += r, this;
  }
  appendRight(e, r) {
    if (e = e + this.offset, typeof r != "string") throw new TypeError("inserted content must be a string");
    this._split(e);
    let i = this.byStart[e];
    return i ? i.appendRight(r) : this.outro += r, this;
  }
  clone() {
    let e = new t(this.original, { filename: this.filename, offset: this.offset }), r = this.firstChunk, i = e.firstChunk = e.lastSearchedChunk =
    r.clone();
    for (; r; ) {
      e.byStart[i.start] = i, e.byEnd[i.end] = i;
      let n = r.next, a = n && n.clone();
      a && (i.next = a, a.previous = i, i = a), r = n;
    }
    return e.lastChunk = i, this.indentExclusionRanges && (e.indentExclusionRanges = this.indentExclusionRanges.slice()), e.sourcemapLocations =
    new oi(this.sourcemapLocations), e.intro = this.intro, e.outro = this.outro, e;
  }
  generateDecodedMap(e) {
    e = e || {};
    let r = 0, i = Object.keys(this.storedNames), n = new hs(e.hires), a = Ro(this.original);
    return this.intro && n.advance(this.intro), this.firstChunk.eachNext((o) => {
      let l = a(o.start);
      o.intro.length && n.advance(o.intro), o.edited ? n.addEdit(
        r,
        o.content,
        l,
        o.storeName ? i.indexOf(o.original) : -1
      ) : n.addUneditedChunk(r, o, this.original, l, this.sourcemapLocations), o.outro.length && n.advance(o.outro);
    }), {
      file: e.file ? e.file.split(/[/\\]/).pop() : void 0,
      sources: [
        e.source ? Yp(e.file || "", e.source) : e.file || ""
      ],
      sourcesContent: e.includeContent ? [this.original] : void 0,
      names: i,
      mappings: n.raw,
      x_google_ignoreList: this.ignoreList ? [r] : void 0
    };
  }
  generateMap(e) {
    return new fs(this.generateDecodedMap(e));
  }
  _ensureindentStr() {
    this.indentStr === void 0 && (this.indentStr = Vp(this.original));
  }
  _getRawIndentString() {
    return this._ensureindentStr(), this.indentStr;
  }
  getIndentString() {
    return this._ensureindentStr(), this.indentStr === null ? "	" : this.indentStr;
  }
  indent(e, r) {
    let i = /^[^\r\n]/gm;
    if (Xp(e) && (r = e, e = void 0), e === void 0 && (this._ensureindentStr(), e = this.indentStr || "	"), e === "") return this;
    r = r || {};
    let n = {};
    r.exclude && (typeof r.exclude[0] == "number" ? [r.exclude] : r.exclude).forEach((h) => {
      for (let E = h[0]; E < h[1]; E += 1)
        n[E] = !0;
    });
    let a = r.indentStart !== !1, o = /* @__PURE__ */ s((p) => a ? `${e}${p}` : (a = !0, p), "replacer");
    this.intro = this.intro.replace(i, o);
    let l = 0, u = this.firstChunk;
    for (; u; ) {
      let p = u.end;
      if (u.edited)
        n[l] || (u.content = u.content.replace(i, o), u.content.length && (a = u.content[u.content.length - 1] === `
`));
      else
        for (l = u.start; l < p; ) {
          if (!n[l]) {
            let h = this.original[l];
            h === `
` ? a = !0 : h !== "\r" && a && (a = !1, l === u.start || (this._splitChunk(u, l), u = u.next), u.prependRight(e));
          }
          l += 1;
        }
      l = u.end, u = u.next;
    }
    return this.outro = this.outro.replace(i, o), this;
  }
  insert() {
    throw new Error(
      "magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)"
    );
  }
  insertLeft(e, r) {
    return ir.insertLeft || (console.warn(
      "magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead"
    ), ir.insertLeft = !0), this.appendLeft(e, r);
  }
  insertRight(e, r) {
    return ir.insertRight || (console.warn(
      "magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead"
    ), ir.insertRight = !0), this.prependRight(e, r);
  }
  move(e, r, i) {
    if (e = e + this.offset, r = r + this.offset, i = i + this.offset, i >= e && i <= r) throw new Error("Cannot move a selection inside its\
elf");
    this._split(e), this._split(r), this._split(i);
    let n = this.byStart[e], a = this.byEnd[r], o = n.previous, l = a.next, u = this.byStart[i];
    if (!u && a === this.lastChunk) return this;
    let p = u ? u.previous : this.lastChunk;
    return o && (o.next = l), l && (l.previous = o), p && (p.next = n), u && (u.previous = a), n.previous || (this.firstChunk = a.next), a.next ||
    (this.lastChunk = n.previous, this.lastChunk.next = null), n.previous = p, a.next = u || null, p || (this.firstChunk = n), u || (this.lastChunk =
    a), this;
  }
  overwrite(e, r, i, n) {
    return n = n || {}, this.update(e, r, i, { ...n, overwrite: !n.contentOnly });
  }
  update(e, r, i, n) {
    if (e = e + this.offset, r = r + this.offset, typeof i != "string") throw new TypeError("replacement content must be a string");
    if (this.original.length !== 0) {
      for (; e < 0; ) e += this.original.length;
      for (; r < 0; ) r += this.original.length;
    }
    if (r > this.original.length) throw new Error("end is out of bounds");
    if (e === r)
      throw new Error(
        "Cannot overwrite a zero-length range \u2013 use appendLeft or prependRight instead"
      );
    this._split(e), this._split(r), n === !0 && (ir.storeName || (console.warn(
      "The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string"
    ), ir.storeName = !0), n = { storeName: !0 });
    let a = n !== void 0 ? n.storeName : !1, o = n !== void 0 ? n.overwrite : !1;
    if (a) {
      let p = this.original.slice(e, r);
      Object.defineProperty(this.storedNames, p, {
        writable: !0,
        value: !0,
        enumerable: !0
      });
    }
    let l = this.byStart[e], u = this.byEnd[r];
    if (l) {
      let p = l;
      for (; p !== u; ) {
        if (p.next !== this.byStart[p.end])
          throw new Error("Cannot overwrite across a split point");
        p = p.next, p.edit("", !1);
      }
      l.edit(i, a, !o);
    } else {
      let p = new li(e, r, "").edit(i, a);
      u.next = p, p.previous = u;
    }
    return this;
  }
  prepend(e) {
    if (typeof e != "string") throw new TypeError("outro content must be a string");
    return this.intro = e + this.intro, this;
  }
  prependLeft(e, r) {
    if (e = e + this.offset, typeof r != "string") throw new TypeError("inserted content must be a string");
    this._split(e);
    let i = this.byEnd[e];
    return i ? i.prependLeft(r) : this.intro = r + this.intro, this;
  }
  prependRight(e, r) {
    if (e = e + this.offset, typeof r != "string") throw new TypeError("inserted content must be a string");
    this._split(e);
    let i = this.byStart[e];
    return i ? i.prependRight(r) : this.outro = r + this.outro, this;
  }
  remove(e, r) {
    if (e = e + this.offset, r = r + this.offset, this.original.length !== 0) {
      for (; e < 0; ) e += this.original.length;
      for (; r < 0; ) r += this.original.length;
    }
    if (e === r) return this;
    if (e < 0 || r > this.original.length) throw new Error("Character is out of bounds");
    if (e > r) throw new Error("end must be greater than start");
    this._split(e), this._split(r);
    let i = this.byStart[e];
    for (; i; )
      i.intro = "", i.outro = "", i.edit(""), i = r > i.end ? this.byStart[i.end] : null;
    return this;
  }
  reset(e, r) {
    if (e = e + this.offset, r = r + this.offset, this.original.length !== 0) {
      for (; e < 0; ) e += this.original.length;
      for (; r < 0; ) r += this.original.length;
    }
    if (e === r) return this;
    if (e < 0 || r > this.original.length) throw new Error("Character is out of bounds");
    if (e > r) throw new Error("end must be greater than start");
    this._split(e), this._split(r);
    let i = this.byStart[e];
    for (; i; )
      i.reset(), i = r > i.end ? this.byStart[i.end] : null;
    return this;
  }
  lastChar() {
    if (this.outro.length) return this.outro[this.outro.length - 1];
    let e = this.lastChunk;
    do {
      if (e.outro.length) return e.outro[e.outro.length - 1];
      if (e.content.length) return e.content[e.content.length - 1];
      if (e.intro.length) return e.intro[e.intro.length - 1];
    } while (e = e.previous);
    return this.intro.length ? this.intro[this.intro.length - 1] : "";
  }
  lastLine() {
    let e = this.outro.lastIndexOf(Pr);
    if (e !== -1) return this.outro.substr(e + 1);
    let r = this.outro, i = this.lastChunk;
    do {
      if (i.outro.length > 0) {
        if (e = i.outro.lastIndexOf(Pr), e !== -1) return i.outro.substr(e + 1) + r;
        r = i.outro + r;
      }
      if (i.content.length > 0) {
        if (e = i.content.lastIndexOf(Pr), e !== -1) return i.content.substr(e + 1) + r;
        r = i.content + r;
      }
      if (i.intro.length > 0) {
        if (e = i.intro.lastIndexOf(Pr), e !== -1) return i.intro.substr(e + 1) + r;
        r = i.intro + r;
      }
    } while (i = i.previous);
    return e = this.intro.lastIndexOf(Pr), e !== -1 ? this.intro.substr(e + 1) + r : this.intro + r;
  }
  slice(e = 0, r = this.original.length - this.offset) {
    if (e = e + this.offset, r = r + this.offset, this.original.length !== 0) {
      for (; e < 0; ) e += this.original.length;
      for (; r < 0; ) r += this.original.length;
    }
    let i = "", n = this.firstChunk;
    for (; n && (n.start > e || n.end <= e); ) {
      if (n.start < r && n.end >= r)
        return i;
      n = n.next;
    }
    if (n && n.edited && n.start !== e)
      throw new Error(`Cannot use replaced character ${e} as slice start anchor.`);
    let a = n;
    for (; n; ) {
      n.intro && (a !== n || n.start === e) && (i += n.intro);
      let o = n.start < r && n.end >= r;
      if (o && n.edited && n.end !== r)
        throw new Error(`Cannot use replaced character ${r} as slice end anchor.`);
      let l = a === n ? e - n.start : 0, u = o ? n.content.length + r - n.end : n.content.length;
      if (i += n.content.slice(l, u), n.outro && (!o || n.end === r) && (i += n.outro), o)
        break;
      n = n.next;
    }
    return i;
  }
  // TODO deprecate this? not really very useful
  snip(e, r) {
    let i = this.clone();
    return i.remove(0, e), i.remove(r, i.original.length), i;
  }
  _split(e) {
    if (this.byStart[e] || this.byEnd[e]) return;
    let r = this.lastSearchedChunk, i = e > r.end;
    for (; r; ) {
      if (r.contains(e)) return this._splitChunk(r, e);
      r = i ? this.byStart[r.end] : this.byEnd[r.start];
    }
  }
  _splitChunk(e, r) {
    if (e.edited && e.content.length) {
      let n = Ro(this.original)(r);
      throw new Error(
        `Cannot split a chunk that has already been edited (${n.line}:${n.column} \u2013 "${e.original}")`
      );
    }
    let i = e.split(r);
    return this.byEnd[r] = e, this.byStart[r] = i, this.byEnd[i.end] = i, e === this.lastChunk && (this.lastChunk = i), this.lastSearchedChunk =
    e, !0;
  }
  toString() {
    let e = this.intro, r = this.firstChunk;
    for (; r; )
      e += r.toString(), r = r.next;
    return e + this.outro;
  }
  isEmpty() {
    let e = this.firstChunk;
    do
      if (e.intro.length && e.intro.trim() || e.content.length && e.content.trim() || e.outro.length && e.outro.trim())
        return !1;
    while (e = e.next);
    return !0;
  }
  length() {
    let e = this.firstChunk, r = 0;
    do
      r += e.intro.length + e.content.length + e.outro.length;
    while (e = e.next);
    return r;
  }
  trimLines() {
    return this.trim("[\\r\\n]");
  }
  trim(e) {
    return this.trimStart(e).trimEnd(e);
  }
  trimEndAborted(e) {
    let r = new RegExp((e || "\\s") + "+$");
    if (this.outro = this.outro.replace(r, ""), this.outro.length) return !0;
    let i = this.lastChunk;
    do {
      let n = i.end, a = i.trimEnd(r);
      if (i.end !== n && (this.lastChunk === i && (this.lastChunk = i.next), this.byEnd[i.end] = i, this.byStart[i.next.start] = i.next, this.
      byEnd[i.next.end] = i.next), a) return !0;
      i = i.previous;
    } while (i);
    return !1;
  }
  trimEnd(e) {
    return this.trimEndAborted(e), this;
  }
  trimStartAborted(e) {
    let r = new RegExp("^" + (e || "\\s") + "+");
    if (this.intro = this.intro.replace(r, ""), this.intro.length) return !0;
    let i = this.firstChunk;
    do {
      let n = i.end, a = i.trimStart(r);
      if (i.end !== n && (i === this.lastChunk && (this.lastChunk = i.next), this.byEnd[i.end] = i, this.byStart[i.next.start] = i.next, this.
      byEnd[i.next.end] = i.next), a) return !0;
      i = i.next;
    } while (i);
    return !1;
  }
  trimStart(e) {
    return this.trimStartAborted(e), this;
  }
  hasChanged() {
    return this.original !== this.toString();
  }
  _replaceRegexp(e, r) {
    function i(a, o) {
      return typeof r == "string" ? r.replace(/\$(\$|&|\d+)/g, (l, u) => u === "$" ? "$" : u === "&" ? a[0] : +u < a.length ? a[+u] : `$${u}`) :
      r(...a, a.index, o, a.groups);
    }
    s(i, "getReplacement");
    function n(a, o) {
      let l, u = [];
      for (; l = a.exec(o); )
        u.push(l);
      return u;
    }
    if (s(n, "matchAll"), e.global)
      n(e, this.original).forEach((o) => {
        if (o.index != null) {
          let l = i(o, this.original);
          l !== o[0] && this.overwrite(o.index, o.index + o[0].length, l);
        }
      });
    else {
      let a = this.original.match(e);
      if (a && a.index != null) {
        let o = i(a, this.original);
        o !== a[0] && this.overwrite(a.index, a.index + a[0].length, o);
      }
    }
    return this;
  }
  _replaceString(e, r) {
    let { original: i } = this, n = i.indexOf(e);
    return n !== -1 && this.overwrite(n, n + e.length, r), this;
  }
  replace(e, r) {
    return typeof e == "string" ? this._replaceString(e, r) : this._replaceRegexp(e, r);
  }
  _replaceAllString(e, r) {
    let { original: i } = this, n = e.length;
    for (let a = i.indexOf(e); a !== -1; a = i.indexOf(e, a + n))
      i.slice(a, a + n) !== r && this.overwrite(a, a + n, r);
    return this;
  }
  replaceAll(e, r) {
    if (typeof e == "string")
      return this._replaceAllString(e, r);
    if (!e.global)
      throw new TypeError(
        "MagicString.prototype.replaceAll called with a non-global RegExp argument"
      );
    return this._replaceRegexp(e, r);
  }
};

// src/core-server/presets/vitePlugins/vite-inject-mocker/constants.ts
var Uo = "__vitest_mocker__";

// src/core-server/mocking-utils/esmWalker.ts
function Ar(t) {
  return t.type === "Identifier" ? t.name : t.raw;
}
s(Ar, "getArbitraryModuleIdentifier");

// src/core-server/mocking-utils/automock.ts
function Ko(t, e, r) {
  return Hp(t, e ? "autospy" : "automock", r, {
    globalThisAccessor: JSON.stringify(Uo)
  });
}
s(Ko, "getAutomockCode");
function Hp(t, e, r, i = {}) {
  let n = i.globalThisAccessor || '"__vitest_mocker__"', a = r(t), o = new ui(t), l = [], u = 0;
  for (let _ of a.body) {
    if (_.type === "ExportAllDeclaration")
      throw new Error(
        "automocking files with `export *` is not supported in browser mode because it cannot be statically analysed"
      );
    if (_.type === "ExportNamedDeclaration") {
      let k = function(K) {
        if (K.type === "Identifier")
          l.push({ name: K.name });
        else if (K.type === "ArrayPattern")
          K.elements.forEach((oe) => {
            oe && k(oe);
          });
        else if (K.type === "ObjectPattern")
          K.properties.forEach((oe) => {
            oe.type === "RestElement" ? k(oe) : oe.type === "Property" && k(oe.value);
          });
        else if (K.type === "RestElement")
          k(K.argument);
        else {
          if (K.type === "AssignmentPattern")
            throw new Error("AssignmentPattern is not supported. Please open a new bug report.");
          if (K.type === "MemberExpression")
            throw new Error("MemberExpression is not supported. Please open a new bug report.");
        }
      };
      var v = k;
      s(k, "traversePattern");
      let j = _, O = j.declaration;
      O && (O.type === "FunctionDeclaration" ? l.push({ name: O.id.name }) : O.type === "VariableDeclaration" ? O.declarations.forEach((K) => {
        k(K.id);
      }) : O.type === "ClassDeclaration" && l.push({ name: O.id.name }), o.remove(j.start, O.start));
      let B = j.specifiers || [], ue = j.source;
      if (!ue && B.length)
        B.forEach((K) => {
          l.push({
            alias: Ar(K.exported),
            name: Ar(K.local)
          });
        }), o.remove(j.start, j.end);
      else if (ue && B.length) {
        let K = [];
        B.forEach((we) => {
          let je = `__vitest_imported_${u++}__`;
          K.push([Ar(we.local), je]), l.push({
            name: je,
            alias: Ar(we.exported)
          });
        });
        let oe = `import { ${K.map(([we, je]) => `${we} as ${je}`).join(", ")} } from '${ue.value}'`;
        o.overwrite(j.start, j.end, oe);
      }
    }
    if (_.type === "ExportDefaultDeclaration") {
      let j = _, O = j.declaration;
      l.push({ name: "__vitest_default", alias: "default" }), o.overwrite(j.start, O.start, "const __vitest_default = ");
    }
  }
  let p = `
const __vitest_current_es_module__ = {
  __esModule: true,
  ${l.map(({ name: _ }) => `["${_}"]: ${_},`).join(`
  `)}
}
const __vitest_mocked_module__ = globalThis[${n}].mockObject(__vitest_current_es_module__, "${e}")
`, h = l.map(({ name: _ }, j) => `const __vitest_mocked_${j}__ = __vitest_mocked_module__["${_}"]`).join(`
`), I = `
export {
${l.map(({ name: _, alias: j }, O) => `  __vitest_mocked_${O}__ as ${j || _},`).join(`
`)}
}
`;
  return o.append(p + h + I), o;
}
s(Hp, "automockModule");

// src/core-server/mocking-utils/extract.ts
var VB = si(Zc(), 1), _p = si(Op(), 1), YB = si(Ye(), 1);
import { logger as Q6 } from "storybook/internal/node-logger";
import { telemetry as e9 } from "storybook/internal/telemetry";
import { transformSync as r9 } from "esbuild";
import { readFileSync as n9 } from "fs";
var Dp = /* @__PURE__ */ s((t) => (0, _p.parse)(t, {
  sourceType: "module",
  // Enable plugins to handle modern JavaScript features, including TSX.
  plugins: ["typescript", "jsx", "classProperties", "objectRestSpread"],
  errorRecovery: !0
}).program, "babelParser");

// src/core-server/presets/webpack/loaders/webpack-automock-loader.ts
function JB(t) {
  let r = this.getOptions().spy === "true";
  return Ko(t, r, Dp).toString();
}
s(JB, "webpackAutomockLoader");
export {
  JB as default
};
