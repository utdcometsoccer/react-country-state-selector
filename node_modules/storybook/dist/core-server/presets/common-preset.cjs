"use strict";
var rae = Object.create;
var vh = Object.defineProperty;
var iae = Object.getOwnPropertyDescriptor;
var nae = Object.getOwnPropertyNames;
var sae = Object.getPrototypeOf, aae = Object.prototype.hasOwnProperty;
var s = (e, t) => vh(e, "name", { value: t, configurable: !0 });
var at = (e, t) => () => (e && (t = e(e = 0)), t);
var b = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports), da = (e, t) => {
  for (var r in t)
    vh(e, r, { get: t[r], enumerable: !0 });
}, _I = (e, t, r, i) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let n of nae(t))
      !aae.call(e, n) && n !== r && vh(e, n, { get: () => t[n], enumerable: !(i = iae(t, n)) || i.enumerable });
  return e;
};
var Gt = (e, t, r) => (r = e != null ? rae(sae(e)) : {}, _I(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  t || !e || !e.__esModule ? vh(r, "default", { value: e, enumerable: !0 }) : r,
  e
)), vf = (e) => _I(vh({}, "__esModule", { value: !0 }), e);

// ../node_modules/ts-dedent/dist/index.js
var Gu = b((Sh) => {
  "use strict";
  Object.defineProperty(Sh, "__esModule", { value: !0 });
  Sh.dedent = void 0;
  function bI(e) {
    for (var t = [], r = 1; r < arguments.length; r++)
      t[r - 1] = arguments[r];
    var i = Array.from(typeof e == "string" ? [e] : e);
    i[i.length - 1] = i[i.length - 1].replace(/\r?\n([\t ]*)$/, "");
    var n = i.reduce(function(u, l) {
      var c = l.match(/\n([\t ]+|(?!\s).)/g);
      return c ? u.concat(c.map(function(p) {
        var h, y;
        return (y = (h = p.match(/[\t ]/g)) === null || h === void 0 ? void 0 : h.length) !== null && y !== void 0 ? y : 0;
      })) : u;
    }, []);
    if (n.length) {
      var a = new RegExp(`
[	 ]{` + Math.min.apply(Math, n) + "}", "g");
      i = i.map(function(u) {
        return u.replace(a, `
`);
      });
    }
    i[0] = i[0].replace(/^\r?\n/, "");
    var o = i[0];
    return t.forEach(function(u, l) {
      var c = o.match(/(?:^|\n)( *)$/), p = c ? c[1] : "", h = u;
      typeof u == "string" && u.includes(`
`) && (h = String(u).split(`
`).map(function(y, _) {
        return _ === 0 ? y : "" + p + y;
      }).join(`
`)), o += h + i[l + 1];
    }), o;
  }
  s(bI, "dedent");
  Sh.dedent = bI;
  Sh.default = bI;
});

// ../node_modules/camelcase/index.js
var OI = {};
da(OI, {
  default: () => wI
});
function wI(e, t) {
  if (!(typeof e == "string" || Array.isArray(e)))
    throw new TypeError("Expected the input to be `string | string[]`");
  if (t = {
    pascalCase: !1,
    preserveConsecutiveUppercase: !1,
    ...t
  }, Array.isArray(e) ? e = e.map((a) => a.trim()).filter((a) => a.length).join("-") : e = e.trim(), e.length === 0)
    return "";
  let r = t.locale === !1 ? (a) => a.toLowerCase() : (a) => a.toLocaleLowerCase(t.locale), i = t.locale === !1 ? (a) => a.toUpperCase() : (a) => a.
  toLocaleUpperCase(t.locale);
  return e.length === 1 ? L0.test(e) ? "" : t.pascalCase ? i(e) : r(e) : (e !== r(e) && (e = cae(e, r, i, t.preserveConsecutiveUppercase)), e =
  e.replace(lae, ""), e = t.preserveConsecutiveUppercase ? fae(e, r) : r(e), t.pascalCase && (e = i(e.charAt(0)) + e.slice(1)), pae(e, i));
}
var oae, uae, xI, DI, L0, lae, CI, PI, cae, fae, pae, kI = at(() => {
  oae = /[\p{Lu}]/u, uae = /[\p{Ll}]/u, xI = /^[\p{Lu}](?![\p{Lu}])/gu, DI = /([\p{Alpha}\p{N}_]|$)/u, L0 = /[_.\- ]+/, lae = new RegExp("^" +
  L0.source), CI = new RegExp(L0.source + DI.source, "gu"), PI = new RegExp("\\d+" + DI.source, "gu"), cae = /* @__PURE__ */ s((e, t, r, i) => {
    let n = !1, a = !1, o = !1, u = !1;
    for (let l = 0; l < e.length; l++) {
      let c = e[l];
      u = l > 2 ? e[l - 3] === "-" : !0, n && oae.test(c) ? (e = e.slice(0, l) + "-" + e.slice(l), n = !1, o = a, a = !0, l++) : a && o && uae.
      test(c) && (!u || i) ? (e = e.slice(0, l - 1) + "-" + e.slice(l - 1), o = a, a = !1, n = !0) : (n = t(c) === c && r(c) !== c, o = a, a =
      r(c) === c && t(c) !== c);
    }
    return e;
  }, "preserveCamelCase"), fae = /* @__PURE__ */ s((e, t) => (xI.lastIndex = 0, e.replaceAll(xI, (r) => t(r))), "preserveConsecutiveUppercas\
e"), pae = /* @__PURE__ */ s((e, t) => (CI.lastIndex = 0, PI.lastIndex = 0, e.replaceAll(PI, (r, i, n) => ["_", "-"].includes(e.charAt(n + r.
  length)) ? r : t(r)).replaceAll(CI, (r, i) => t(i))), "postProcess");
  s(wI, "camelCase");
});

// ../node_modules/globby/node_modules/@sindresorhus/merge-streams/index.js
function K0(e) {
  if (!Array.isArray(e))
    throw new TypeError(`Expected an array, got \`${typeof e}\`.`);
  for (let n of e)
    U0(n);
  let t = e.some(({ readableObjectMode: n }) => n), r = hae(e, t), i = new q0({
    objectMode: t,
    writableHighWaterMark: r,
    readableHighWaterMark: r
  });
  for (let n of e)
    i.add(n);
  return e.length === 0 && JI(i), i;
}
var Dy, $I, V0, hae, q0, dae, mae, yae, U0, gae, XI, _ae, bae, vae, YI, JI, j0, QI, Sae, Py, GI, WI, ZI = at(() => {
  Dy = require("node:events"), $I = require("node:stream"), V0 = require("node:stream/promises");
  s(K0, "mergeStreams");
  hae = /* @__PURE__ */ s((e, t) => {
    if (e.length === 0)
      return 16384;
    let r = e.filter(({ readableObjectMode: i }) => i === t).map(({ readableHighWaterMark: i }) => i);
    return Math.max(...r);
  }, "getHighWaterMark"), q0 = class extends $I.PassThrough {
    static {
      s(this, "MergedStream");
    }
    #e = /* @__PURE__ */ new Set([]);
    #r = /* @__PURE__ */ new Set([]);
    #i = /* @__PURE__ */ new Set([]);
    #t;
    add(t) {
      U0(t), !this.#e.has(t) && (this.#e.add(t), this.#t ??= dae(this, this.#e), gae({
        passThroughStream: this,
        stream: t,
        streams: this.#e,
        ended: this.#r,
        aborted: this.#i,
        onFinished: this.#t
      }), t.pipe(this, { end: !1 }));
    }
    remove(t) {
      return U0(t), this.#e.has(t) ? (t.unpipe(this), !0) : !1;
    }
  }, dae = /* @__PURE__ */ s(async (e, t) => {
    Py(e, GI);
    let r = new AbortController();
    try {
      await Promise.race([
        mae(e, r),
        yae(e, t, r)
      ]);
    } finally {
      r.abort(), Py(e, -GI);
    }
  }, "onMergedStreamFinished"), mae = /* @__PURE__ */ s(async (e, { signal: t }) => {
    await (0, V0.finished)(e, { signal: t, cleanup: !0 });
  }, "onMergedStreamEnd"), yae = /* @__PURE__ */ s(async (e, t, { signal: r }) => {
    for await (let [i] of (0, Dy.on)(e, "unpipe", { signal: r }))
      t.has(i) && i.emit(YI);
  }, "onInputStreamsUnpipe"), U0 = /* @__PURE__ */ s((e) => {
    if (typeof e?.pipe != "function")
      throw new TypeError(`Expected a readable stream, got: \`${typeof e}\`.`);
  }, "validateStream"), gae = /* @__PURE__ */ s(async ({ passThroughStream: e, stream: t, streams: r, ended: i, aborted: n, onFinished: a }) => {
    Py(e, WI);
    let o = new AbortController();
    try {
      await Promise.race([
        _ae(a, t),
        bae({ passThroughStream: e, stream: t, streams: r, ended: i, aborted: n, controller: o }),
        vae({ stream: t, streams: r, ended: i, aborted: n, controller: o })
      ]);
    } finally {
      o.abort(), Py(e, -WI);
    }
    r.size === i.size + n.size && (i.size === 0 && n.size > 0 ? j0(e) : JI(e));
  }, "endWhenStreamsDone"), XI = /* @__PURE__ */ s((e) => e?.code === "ERR_STREAM_PREMATURE_CLOSE", "isAbortError"), _ae = /* @__PURE__ */ s(
  async (e, t) => {
    try {
      await e, j0(t);
    } catch (r) {
      XI(r) ? j0(t) : QI(t, r);
    }
  }, "afterMergedStreamFinished"), bae = /* @__PURE__ */ s(async ({ passThroughStream: e, stream: t, streams: r, ended: i, aborted: n, controller: {
  signal: a } }) => {
    try {
      await (0, V0.finished)(t, { signal: a, cleanup: !0, readable: !0, writable: !1 }), r.has(t) && i.add(t);
    } catch (o) {
      if (a.aborted || !r.has(t))
        return;
      XI(o) ? n.add(t) : QI(e, o);
    }
  }, "onInputStreamEnd"), vae = /* @__PURE__ */ s(async ({ stream: e, streams: t, ended: r, aborted: i, controller: { signal: n } }) => {
    await (0, Dy.once)(e, YI, { signal: n }), t.delete(e), r.delete(e), i.delete(e);
  }, "onInputStreamUnpipe"), YI = Symbol("unpipe"), JI = /* @__PURE__ */ s((e) => {
    e.writable && e.end();
  }, "endStream"), j0 = /* @__PURE__ */ s((e) => {
    (e.readable || e.writable) && e.destroy();
  }, "abortStream"), QI = /* @__PURE__ */ s((e, t) => {
    e.destroyed || (e.once("error", Sae), e.destroy(t));
  }, "errorStream"), Sae = /* @__PURE__ */ s(() => {
  }, "noop"), Py = /* @__PURE__ */ s((e, t) => {
    let r = e.getMaxListeners();
    r !== 0 && r !== Number.POSITIVE_INFINITY && e.setMaxListeners(r + t);
  }, "updateMaxListeners"), GI = 2, WI = 1;
});

// ../node_modules/fast-glob/out/utils/array.js
var eR = b((xf) => {
  "use strict";
  Object.defineProperty(xf, "__esModule", { value: !0 });
  xf.splitWhen = xf.flatten = void 0;
  function Tae(e) {
    return e.reduce((t, r) => [].concat(t, r), []);
  }
  s(Tae, "flatten");
  xf.flatten = Tae;
  function Eae(e, t) {
    let r = [[]], i = 0;
    for (let n of e)
      t(n) ? (i++, r[i] = []) : r[i].push(n);
    return r;
  }
  s(Eae, "splitWhen");
  xf.splitWhen = Eae;
});

// ../node_modules/fast-glob/out/utils/errno.js
var tR = b((wy) => {
  "use strict";
  Object.defineProperty(wy, "__esModule", { value: !0 });
  wy.isEnoentCodeError = void 0;
  function Aae(e) {
    return e.code === "ENOENT";
  }
  s(Aae, "isEnoentCodeError");
  wy.isEnoentCodeError = Aae;
});

// ../node_modules/fast-glob/out/utils/fs.js
var rR = b((Oy) => {
  "use strict";
  Object.defineProperty(Oy, "__esModule", { value: !0 });
  Oy.createDirentFromStats = void 0;
  var H0 = class {
    static {
      s(this, "DirentFromStats");
    }
    constructor(t, r) {
      this.name = t, this.isBlockDevice = r.isBlockDevice.bind(r), this.isCharacterDevice = r.isCharacterDevice.bind(r), this.isDirectory = r.
      isDirectory.bind(r), this.isFIFO = r.isFIFO.bind(r), this.isFile = r.isFile.bind(r), this.isSocket = r.isSocket.bind(r), this.isSymbolicLink =
      r.isSymbolicLink.bind(r);
    }
  };
  function xae(e, t) {
    return new H0(e, t);
  }
  s(xae, "createDirentFromStats");
  Oy.createDirentFromStats = xae;
});

// ../node_modules/fast-glob/out/utils/path.js
var aR = b((Ji) => {
  "use strict";
  Object.defineProperty(Ji, "__esModule", { value: !0 });
  Ji.convertPosixPathToPattern = Ji.convertWindowsPathToPattern = Ji.convertPathToPattern = Ji.escapePosixPath = Ji.escapeWindowsPath = Ji.escape =
  Ji.removeLeadingDotSegment = Ji.makeAbsolute = Ji.unixify = void 0;
  var Cae = require("os"), Pae = require("path"), iR = Cae.platform() === "win32", Dae = 2, wae = /(\\?)([()*?[\]{|}]|^!|[!+@](?=\()|\\(?![!()*+?@[\]{|}]))/g,
  Oae = /(\\?)([()[\]{}]|^!|[!+@](?=\())/g, kae = /^\\\\([.?])/, Iae = /\\(?![!()+@[\]{}])/g;
  function Rae(e) {
    return e.replace(/\\/g, "/");
  }
  s(Rae, "unixify");
  Ji.unixify = Rae;
  function Nae(e, t) {
    return Pae.resolve(e, t);
  }
  s(Nae, "makeAbsolute");
  Ji.makeAbsolute = Nae;
  function Lae(e) {
    if (e.charAt(0) === ".") {
      let t = e.charAt(1);
      if (t === "/" || t === "\\")
        return e.slice(Dae);
    }
    return e;
  }
  s(Lae, "removeLeadingDotSegment");
  Ji.removeLeadingDotSegment = Lae;
  Ji.escape = iR ? z0 : G0;
  function z0(e) {
    return e.replace(Oae, "\\$2");
  }
  s(z0, "escapeWindowsPath");
  Ji.escapeWindowsPath = z0;
  function G0(e) {
    return e.replace(wae, "\\$2");
  }
  s(G0, "escapePosixPath");
  Ji.escapePosixPath = G0;
  Ji.convertPathToPattern = iR ? nR : sR;
  function nR(e) {
    return z0(e).replace(kae, "//$1").replace(Iae, "/");
  }
  s(nR, "convertWindowsPathToPattern");
  Ji.convertWindowsPathToPattern = nR;
  function sR(e) {
    return G0(e);
  }
  s(sR, "convertPosixPathToPattern");
  Ji.convertPosixPathToPattern = sR;
});

// ../node_modules/is-extglob/index.js
var uR = b((Fmt, oR) => {
  oR.exports = /* @__PURE__ */ s(function(t) {
    if (typeof t != "string" || t === "")
      return !1;
    for (var r; r = /(\\).|([@?!+*]\(.*\))/g.exec(t); ) {
      if (r[2]) return !0;
      t = t.slice(r.index + r[0].length);
    }
    return !1;
  }, "isExtglob");
});

// ../node_modules/is-glob/index.js
var fR = b((Bmt, cR) => {
  var Fae = uR(), lR = { "{": "}", "(": ")", "[": "]" }, Mae = /* @__PURE__ */ s(function(e) {
    if (e[0] === "!")
      return !0;
    for (var t = 0, r = -2, i = -2, n = -2, a = -2, o = -2; t < e.length; ) {
      if (e[t] === "*" || e[t + 1] === "?" && /[\].+)]/.test(e[t]) || i !== -1 && e[t] === "[" && e[t + 1] !== "]" && (i < t && (i = e.indexOf(
      "]", t)), i > t && (o === -1 || o > i || (o = e.indexOf("\\", t), o === -1 || o > i))) || n !== -1 && e[t] === "{" && e[t + 1] !== "}" &&
      (n = e.indexOf("}", t), n > t && (o = e.indexOf("\\", t), o === -1 || o > n)) || a !== -1 && e[t] === "(" && e[t + 1] === "?" && /[:!=]/.
      test(e[t + 2]) && e[t + 3] !== ")" && (a = e.indexOf(")", t), a > t && (o = e.indexOf("\\", t), o === -1 || o > a)) || r !== -1 && e[t] ===
      "(" && e[t + 1] !== "|" && (r < t && (r = e.indexOf("|", t)), r !== -1 && e[r + 1] !== ")" && (a = e.indexOf(")", r), a > r && (o = e.
      indexOf("\\", r), o === -1 || o > a))))
        return !0;
      if (e[t] === "\\") {
        var u = e[t + 1];
        t += 2;
        var l = lR[u];
        if (l) {
          var c = e.indexOf(l, t);
          c !== -1 && (t = c + 1);
        }
        if (e[t] === "!")
          return !0;
      } else
        t++;
    }
    return !1;
  }, "strictCheck"), Bae = /* @__PURE__ */ s(function(e) {
    if (e[0] === "!")
      return !0;
    for (var t = 0; t < e.length; ) {
      if (/[*?{}()[\]]/.test(e[t]))
        return !0;
      if (e[t] === "\\") {
        var r = e[t + 1];
        t += 2;
        var i = lR[r];
        if (i) {
          var n = e.indexOf(i, t);
          n !== -1 && (t = n + 1);
        }
        if (e[t] === "!")
          return !0;
      } else
        t++;
    }
    return !1;
  }, "relaxedCheck");
  cR.exports = /* @__PURE__ */ s(function(t, r) {
    if (typeof t != "string" || t === "")
      return !1;
    if (Fae(t))
      return !0;
    var i = Mae;
    return r && r.strict === !1 && (i = Bae), i(t);
  }, "isGlob");
});

// ../node_modules/fast-glob/node_modules/glob-parent/index.js
var hR = b((Umt, pR) => {
  "use strict";
  var qae = fR(), Uae = require("path").posix.dirname, jae = require("os").platform() === "win32", W0 = "/", Vae = /\\/g, Kae = /[\{\[].*[\}\]]$/,
  Hae = /(^|[^\\])([\{\[]|\([^\)]+$)/, zae = /\\([\!\*\?\|\[\]\(\)\{\}])/g;
  pR.exports = /* @__PURE__ */ s(function(t, r) {
    var i = Object.assign({ flipBackslashes: !0 }, r);
    i.flipBackslashes && jae && t.indexOf(W0) < 0 && (t = t.replace(Vae, W0)), Kae.test(t) && (t += W0), t += "a";
    do
      t = Uae(t);
    while (qae(t) || Hae.test(t));
    return t.replace(zae, "$1");
  }, "globParent");
});

// ../node_modules/braces/lib/utils.js
var ky = b((ma) => {
  "use strict";
  ma.isInteger = (e) => typeof e == "number" ? Number.isInteger(e) : typeof e == "string" && e.trim() !== "" ? Number.isInteger(Number(e)) :
  !1;
  ma.find = (e, t) => e.nodes.find((r) => r.type === t);
  ma.exceedsLimit = (e, t, r = 1, i) => i === !1 || !ma.isInteger(e) || !ma.isInteger(t) ? !1 : (Number(t) - Number(e)) / Number(r) >= i;
  ma.escapeNode = (e, t = 0, r) => {
    let i = e.nodes[t];
    i && (r && i.type === r || i.type === "open" || i.type === "close") && i.escaped !== !0 && (i.value = "\\" + i.value, i.escaped = !0);
  };
  ma.encloseBrace = (e) => e.type !== "brace" ? !1 : e.commas >> 0 + e.ranges >> 0 === 0 ? (e.invalid = !0, !0) : !1;
  ma.isInvalidBrace = (e) => e.type !== "brace" ? !1 : e.invalid === !0 || e.dollar ? !0 : e.commas >> 0 + e.ranges >> 0 === 0 || e.open !==
  !0 || e.close !== !0 ? (e.invalid = !0, !0) : !1;
  ma.isOpenOrClose = (e) => e.type === "open" || e.type === "close" ? !0 : e.open === !0 || e.close === !0;
  ma.reduce = (e) => e.reduce((t, r) => (r.type === "text" && t.push(r.value), r.type === "range" && (r.type = "text"), t), []);
  ma.flatten = (...e) => {
    let t = [], r = /* @__PURE__ */ s((i) => {
      for (let n = 0; n < i.length; n++) {
        let a = i[n];
        if (Array.isArray(a)) {
          r(a);
          continue;
        }
        a !== void 0 && t.push(a);
      }
      return t;
    }, "flat");
    return r(e), t;
  };
});

// ../node_modules/braces/lib/stringify.js
var Iy = b((Hmt, mR) => {
  "use strict";
  var dR = ky();
  mR.exports = (e, t = {}) => {
    let r = /* @__PURE__ */ s((i, n = {}) => {
      let a = t.escapeInvalid && dR.isInvalidBrace(n), o = i.invalid === !0 && t.escapeInvalid === !0, u = "";
      if (i.value)
        return (a || o) && dR.isOpenOrClose(i) ? "\\" + i.value : i.value;
      if (i.value)
        return i.value;
      if (i.nodes)
        for (let l of i.nodes)
          u += r(l);
      return u;
    }, "stringify");
    return r(e);
  };
});

// ../node_modules/is-number/index.js
var gR = b((Gmt, yR) => {
  "use strict";
  yR.exports = function(e) {
    return typeof e == "number" ? e - e === 0 : typeof e == "string" && e.trim() !== "" ? Number.isFinite ? Number.isFinite(+e) : isFinite(+e) :
    !1;
  };
});

// ../node_modules/to-regex-range/index.js
var CR = b((Wmt, xR) => {
  "use strict";
  var _R = gR(), ec = /* @__PURE__ */ s((e, t, r) => {
    if (_R(e) === !1)
      throw new TypeError("toRegexRange: expected the first argument to be a number");
    if (t === void 0 || e === t)
      return String(e);
    if (_R(t) === !1)
      throw new TypeError("toRegexRange: expected the second argument to be a number.");
    let i = { relaxZeros: !0, ...r };
    typeof i.strictZeros == "boolean" && (i.relaxZeros = i.strictZeros === !1);
    let n = String(i.relaxZeros), a = String(i.shorthand), o = String(i.capture), u = String(i.wrap), l = e + ":" + t + "=" + n + a + o + u;
    if (ec.cache.hasOwnProperty(l))
      return ec.cache[l].result;
    let c = Math.min(e, t), p = Math.max(e, t);
    if (Math.abs(c - p) === 1) {
      let m = e + "|" + t;
      return i.capture ? `(${m})` : i.wrap === !1 ? m : `(?:${m})`;
    }
    let h = AR(e) || AR(t), y = { min: e, max: t, a: c, b: p }, _ = [], g = [];
    if (h && (y.isPadded = h, y.maxLen = String(y.max).length), c < 0) {
      let m = p < 0 ? Math.abs(p) : 1;
      g = bR(m, Math.abs(c), y, i), c = y.a = 0;
    }
    return p >= 0 && (_ = bR(c, p, y, i)), y.negatives = g, y.positives = _, y.result = Gae(g, _, i), i.capture === !0 ? y.result = `(${y.result}\
)` : i.wrap !== !1 && _.length + g.length > 1 && (y.result = `(?:${y.result})`), ec.cache[l] = y, y.result;
  }, "toRegexRange");
  function Gae(e, t, r) {
    let i = $0(e, t, "-", !1, r) || [], n = $0(t, e, "", !1, r) || [], a = $0(e, t, "-?", !0, r) || [];
    return i.concat(a).concat(n).join("|");
  }
  s(Gae, "collatePatterns");
  function Wae(e, t) {
    let r = 1, i = 1, n = SR(e, r), a = /* @__PURE__ */ new Set([t]);
    for (; e <= n && n <= t; )
      a.add(n), r += 1, n = SR(e, r);
    for (n = TR(t + 1, i) - 1; e < n && n <= t; )
      a.add(n), i += 1, n = TR(t + 1, i) - 1;
    return a = [...a], a.sort(Yae), a;
  }
  s(Wae, "splitToRanges");
  function $ae(e, t, r) {
    if (e === t)
      return { pattern: e, count: [], digits: 0 };
    let i = Xae(e, t), n = i.length, a = "", o = 0;
    for (let u = 0; u < n; u++) {
      let [l, c] = i[u];
      l === c ? a += l : l !== "0" || c !== "9" ? a += Jae(l, c, r) : o++;
    }
    return o && (a += r.shorthand === !0 ? "\\d" : "[0-9]"), { pattern: a, count: [o], digits: n };
  }
  s($ae, "rangeToPattern");
  function bR(e, t, r, i) {
    let n = Wae(e, t), a = [], o = e, u;
    for (let l = 0; l < n.length; l++) {
      let c = n[l], p = $ae(String(o), String(c), i), h = "";
      if (!r.isPadded && u && u.pattern === p.pattern) {
        u.count.length > 1 && u.count.pop(), u.count.push(p.count[0]), u.string = u.pattern + ER(u.count), o = c + 1;
        continue;
      }
      r.isPadded && (h = Qae(c, r, i)), p.string = h + p.pattern + ER(p.count), a.push(p), o = c + 1, u = p;
    }
    return a;
  }
  s(bR, "splitToPatterns");
  function $0(e, t, r, i, n) {
    let a = [];
    for (let o of e) {
      let { string: u } = o;
      !i && !vR(t, "string", u) && a.push(r + u), i && vR(t, "string", u) && a.push(r + u);
    }
    return a;
  }
  s($0, "filterPatterns");
  function Xae(e, t) {
    let r = [];
    for (let i = 0; i < e.length; i++) r.push([e[i], t[i]]);
    return r;
  }
  s(Xae, "zip");
  function Yae(e, t) {
    return e > t ? 1 : t > e ? -1 : 0;
  }
  s(Yae, "compare");
  function vR(e, t, r) {
    return e.some((i) => i[t] === r);
  }
  s(vR, "contains");
  function SR(e, t) {
    return Number(String(e).slice(0, -t) + "9".repeat(t));
  }
  s(SR, "countNines");
  function TR(e, t) {
    return e - e % Math.pow(10, t);
  }
  s(TR, "countZeros");
  function ER(e) {
    let [t = 0, r = ""] = e;
    return r || t > 1 ? `{${t + (r ? "," + r : "")}}` : "";
  }
  s(ER, "toQuantifier");
  function Jae(e, t, r) {
    return `[${e}${t - e === 1 ? "" : "-"}${t}]`;
  }
  s(Jae, "toCharacterClass");
  function AR(e) {
    return /^-?(0+)\d/.test(e);
  }
  s(AR, "hasPadding");
  function Qae(e, t, r) {
    if (!t.isPadded)
      return e;
    let i = Math.abs(t.maxLen - String(e).length), n = r.relaxZeros !== !1;
    switch (i) {
      case 0:
        return "";
      case 1:
        return n ? "0?" : "0";
      case 2:
        return n ? "0{0,2}" : "00";
      default:
        return n ? `0{0,${i}}` : `0{${i}}`;
    }
  }
  s(Qae, "padZeros");
  ec.cache = {};
  ec.clearCache = () => ec.cache = {};
  xR.exports = ec;
});

// ../node_modules/fill-range/index.js
var J0 = b((Xmt, RR) => {
  "use strict";
  var Zae = require("util"), DR = CR(), PR = /* @__PURE__ */ s((e) => e !== null && typeof e == "object" && !Array.isArray(e), "isObject"), eoe = /* @__PURE__ */ s(
  (e) => (t) => e === !0 ? Number(t) : String(t), "transform"), X0 = /* @__PURE__ */ s((e) => typeof e == "number" || typeof e == "string" &&
  e !== "", "isValidValue"), xh = /* @__PURE__ */ s((e) => Number.isInteger(+e), "isNumber"), Y0 = /* @__PURE__ */ s((e) => {
    let t = `${e}`, r = -1;
    if (t[0] === "-" && (t = t.slice(1)), t === "0") return !1;
    for (; t[++r] === "0"; ) ;
    return r > 0;
  }, "zeros"), toe = /* @__PURE__ */ s((e, t, r) => typeof e == "string" || typeof t == "string" ? !0 : r.stringify === !0, "stringify"), roe = /* @__PURE__ */ s(
  (e, t, r) => {
    if (t > 0) {
      let i = e[0] === "-" ? "-" : "";
      i && (e = e.slice(1)), e = i + e.padStart(i ? t - 1 : t, "0");
    }
    return r === !1 ? String(e) : e;
  }, "pad"), Ny = /* @__PURE__ */ s((e, t) => {
    let r = e[0] === "-" ? "-" : "";
    for (r && (e = e.slice(1), t--); e.length < t; ) e = "0" + e;
    return r ? "-" + e : e;
  }, "toMaxLen"), ioe = /* @__PURE__ */ s((e, t, r) => {
    e.negatives.sort((u, l) => u < l ? -1 : u > l ? 1 : 0), e.positives.sort((u, l) => u < l ? -1 : u > l ? 1 : 0);
    let i = t.capture ? "" : "?:", n = "", a = "", o;
    return e.positives.length && (n = e.positives.map((u) => Ny(String(u), r)).join("|")), e.negatives.length && (a = `-(${i}${e.negatives.map(
    (u) => Ny(String(u), r)).join("|")})`), n && a ? o = `${n}|${a}` : o = n || a, t.wrap ? `(${i}${o})` : o;
  }, "toSequence"), wR = /* @__PURE__ */ s((e, t, r, i) => {
    if (r)
      return DR(e, t, { wrap: !1, ...i });
    let n = String.fromCharCode(e);
    if (e === t) return n;
    let a = String.fromCharCode(t);
    return `[${n}-${a}]`;
  }, "toRange"), OR = /* @__PURE__ */ s((e, t, r) => {
    if (Array.isArray(e)) {
      let i = r.wrap === !0, n = r.capture ? "" : "?:";
      return i ? `(${n}${e.join("|")})` : e.join("|");
    }
    return DR(e, t, r);
  }, "toRegex"), kR = /* @__PURE__ */ s((...e) => new RangeError("Invalid range arguments: " + Zae.inspect(...e)), "rangeError"), IR = /* @__PURE__ */ s(
  (e, t, r) => {
    if (r.strictRanges === !0) throw kR([e, t]);
    return [];
  }, "invalidRange"), noe = /* @__PURE__ */ s((e, t) => {
    if (t.strictRanges === !0)
      throw new TypeError(`Expected step "${e}" to be a number`);
    return [];
  }, "invalidStep"), soe = /* @__PURE__ */ s((e, t, r = 1, i = {}) => {
    let n = Number(e), a = Number(t);
    if (!Number.isInteger(n) || !Number.isInteger(a)) {
      if (i.strictRanges === !0) throw kR([e, t]);
      return [];
    }
    n === 0 && (n = 0), a === 0 && (a = 0);
    let o = n > a, u = String(e), l = String(t), c = String(r);
    r = Math.max(Math.abs(r), 1);
    let p = Y0(u) || Y0(l) || Y0(c), h = p ? Math.max(u.length, l.length, c.length) : 0, y = p === !1 && toe(e, t, i) === !1, _ = i.transform ||
    eoe(y);
    if (i.toRegex && r === 1)
      return wR(Ny(e, h), Ny(t, h), !0, i);
    let g = { negatives: [], positives: [] }, m = /* @__PURE__ */ s((v) => g[v < 0 ? "negatives" : "positives"].push(Math.abs(v)), "push"), f = [],
    d = 0;
    for (; o ? n >= a : n <= a; )
      i.toRegex === !0 && r > 1 ? m(n) : f.push(roe(_(n, d), h, y)), n = o ? n - r : n + r, d++;
    return i.toRegex === !0 ? r > 1 ? ioe(g, i, h) : OR(f, null, { wrap: !1, ...i }) : f;
  }, "fillNumbers"), aoe = /* @__PURE__ */ s((e, t, r = 1, i = {}) => {
    if (!xh(e) && e.length > 1 || !xh(t) && t.length > 1)
      return IR(e, t, i);
    let n = i.transform || ((y) => String.fromCharCode(y)), a = `${e}`.charCodeAt(0), o = `${t}`.charCodeAt(0), u = a > o, l = Math.min(a, o),
    c = Math.max(a, o);
    if (i.toRegex && r === 1)
      return wR(l, c, !1, i);
    let p = [], h = 0;
    for (; u ? a >= o : a <= o; )
      p.push(n(a, h)), a = u ? a - r : a + r, h++;
    return i.toRegex === !0 ? OR(p, null, { wrap: !1, options: i }) : p;
  }, "fillLetters"), Ry = /* @__PURE__ */ s((e, t, r, i = {}) => {
    if (t == null && X0(e))
      return [e];
    if (!X0(e) || !X0(t))
      return IR(e, t, i);
    if (typeof r == "function")
      return Ry(e, t, 1, { transform: r });
    if (PR(r))
      return Ry(e, t, 0, r);
    let n = { ...i };
    return n.capture === !0 && (n.wrap = !0), r = r || n.step || 1, xh(r) ? xh(e) && xh(t) ? soe(e, t, r, n) : aoe(e, t, Math.max(Math.abs(r),
    1), n) : r != null && !PR(r) ? noe(r, n) : Ry(e, t, 1, r);
  }, "fill");
  RR.exports = Ry;
});

// ../node_modules/braces/lib/compile.js
var FR = b((Jmt, LR) => {
  "use strict";
  var ooe = J0(), NR = ky(), uoe = /* @__PURE__ */ s((e, t = {}) => {
    let r = /* @__PURE__ */ s((i, n = {}) => {
      let a = NR.isInvalidBrace(n), o = i.invalid === !0 && t.escapeInvalid === !0, u = a === !0 || o === !0, l = t.escapeInvalid === !0 ? "\
\\" : "", c = "";
      if (i.isOpen === !0)
        return l + i.value;
      if (i.isClose === !0)
        return console.log("node.isClose", l, i.value), l + i.value;
      if (i.type === "open")
        return u ? l + i.value : "(";
      if (i.type === "close")
        return u ? l + i.value : ")";
      if (i.type === "comma")
        return i.prev.type === "comma" ? "" : u ? i.value : "|";
      if (i.value)
        return i.value;
      if (i.nodes && i.ranges > 0) {
        let p = NR.reduce(i.nodes), h = ooe(...p, { ...t, wrap: !1, toRegex: !0, strictZeros: !0 });
        if (h.length !== 0)
          return p.length > 1 && h.length > 1 ? `(${h})` : h;
      }
      if (i.nodes)
        for (let p of i.nodes)
          c += r(p, i);
      return c;
    }, "walk");
    return r(e);
  }, "compile");
  LR.exports = uoe;
});

// ../node_modules/braces/lib/expand.js
var qR = b((Zmt, BR) => {
  "use strict";
  var loe = J0(), MR = Iy(), Cf = ky(), tc = /* @__PURE__ */ s((e = "", t = "", r = !1) => {
    let i = [];
    if (e = [].concat(e), t = [].concat(t), !t.length) return e;
    if (!e.length)
      return r ? Cf.flatten(t).map((n) => `{${n}}`) : t;
    for (let n of e)
      if (Array.isArray(n))
        for (let a of n)
          i.push(tc(a, t, r));
      else
        for (let a of t)
          r === !0 && typeof a == "string" && (a = `{${a}}`), i.push(Array.isArray(a) ? tc(n, a, r) : n + a);
    return Cf.flatten(i);
  }, "append"), coe = /* @__PURE__ */ s((e, t = {}) => {
    let r = t.rangeLimit === void 0 ? 1e3 : t.rangeLimit, i = /* @__PURE__ */ s((n, a = {}) => {
      n.queue = [];
      let o = a, u = a.queue;
      for (; o.type !== "brace" && o.type !== "root" && o.parent; )
        o = o.parent, u = o.queue;
      if (n.invalid || n.dollar) {
        u.push(tc(u.pop(), MR(n, t)));
        return;
      }
      if (n.type === "brace" && n.invalid !== !0 && n.nodes.length === 2) {
        u.push(tc(u.pop(), ["{}"]));
        return;
      }
      if (n.nodes && n.ranges > 0) {
        let h = Cf.reduce(n.nodes);
        if (Cf.exceedsLimit(...h, t.step, r))
          throw new RangeError("expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.");
        let y = loe(...h, t);
        y.length === 0 && (y = MR(n, t)), u.push(tc(u.pop(), y)), n.nodes = [];
        return;
      }
      let l = Cf.encloseBrace(n), c = n.queue, p = n;
      for (; p.type !== "brace" && p.type !== "root" && p.parent; )
        p = p.parent, c = p.queue;
      for (let h = 0; h < n.nodes.length; h++) {
        let y = n.nodes[h];
        if (y.type === "comma" && n.type === "brace") {
          h === 1 && c.push(""), c.push("");
          continue;
        }
        if (y.type === "close") {
          u.push(tc(u.pop(), c, l));
          continue;
        }
        if (y.value && y.type !== "open") {
          c.push(tc(c.pop(), y.value));
          continue;
        }
        y.nodes && i(y, n);
      }
      return c;
    }, "walk");
    return Cf.flatten(i(e));
  }, "expand");
  BR.exports = coe;
});

// ../node_modules/braces/lib/constants.js
var jR = b((tyt, UR) => {
  "use strict";
  UR.exports = {
    MAX_LENGTH: 1e4,
    // Digits
    CHAR_0: "0",
    /* 0 */
    CHAR_9: "9",
    /* 9 */
    // Alphabet chars.
    CHAR_UPPERCASE_A: "A",
    /* A */
    CHAR_LOWERCASE_A: "a",
    /* a */
    CHAR_UPPERCASE_Z: "Z",
    /* Z */
    CHAR_LOWERCASE_Z: "z",
    /* z */
    CHAR_LEFT_PARENTHESES: "(",
    /* ( */
    CHAR_RIGHT_PARENTHESES: ")",
    /* ) */
    CHAR_ASTERISK: "*",
    /* * */
    // Non-alphabetic chars.
    CHAR_AMPERSAND: "&",
    /* & */
    CHAR_AT: "@",
    /* @ */
    CHAR_BACKSLASH: "\\",
    /* \ */
    CHAR_BACKTICK: "`",
    /* ` */
    CHAR_CARRIAGE_RETURN: "\r",
    /* \r */
    CHAR_CIRCUMFLEX_ACCENT: "^",
    /* ^ */
    CHAR_COLON: ":",
    /* : */
    CHAR_COMMA: ",",
    /* , */
    CHAR_DOLLAR: "$",
    /* . */
    CHAR_DOT: ".",
    /* . */
    CHAR_DOUBLE_QUOTE: '"',
    /* " */
    CHAR_EQUAL: "=",
    /* = */
    CHAR_EXCLAMATION_MARK: "!",
    /* ! */
    CHAR_FORM_FEED: "\f",
    /* \f */
    CHAR_FORWARD_SLASH: "/",
    /* / */
    CHAR_HASH: "#",
    /* # */
    CHAR_HYPHEN_MINUS: "-",
    /* - */
    CHAR_LEFT_ANGLE_BRACKET: "<",
    /* < */
    CHAR_LEFT_CURLY_BRACE: "{",
    /* { */
    CHAR_LEFT_SQUARE_BRACKET: "[",
    /* [ */
    CHAR_LINE_FEED: `
`,
    /* \n */
    CHAR_NO_BREAK_SPACE: "\xA0",
    /* \u00A0 */
    CHAR_PERCENT: "%",
    /* % */
    CHAR_PLUS: "+",
    /* + */
    CHAR_QUESTION_MARK: "?",
    /* ? */
    CHAR_RIGHT_ANGLE_BRACKET: ">",
    /* > */
    CHAR_RIGHT_CURLY_BRACE: "}",
    /* } */
    CHAR_RIGHT_SQUARE_BRACKET: "]",
    /* ] */
    CHAR_SEMICOLON: ";",
    /* ; */
    CHAR_SINGLE_QUOTE: "'",
    /* ' */
    CHAR_SPACE: " ",
    /*   */
    CHAR_TAB: "	",
    /* \t */
    CHAR_UNDERSCORE: "_",
    /* _ */
    CHAR_VERTICAL_LINE: "|",
    /* | */
    CHAR_ZERO_WIDTH_NOBREAK_SPACE: "\uFEFF"
    /* \uFEFF */
  };
});

// ../node_modules/braces/lib/parse.js
var GR = b((ryt, zR) => {
  "use strict";
  var foe = Iy(), {
    MAX_LENGTH: VR,
    CHAR_BACKSLASH: Q0,
    /* \ */
    CHAR_BACKTICK: poe,
    /* ` */
    CHAR_COMMA: hoe,
    /* , */
    CHAR_DOT: doe,
    /* . */
    CHAR_LEFT_PARENTHESES: moe,
    /* ( */
    CHAR_RIGHT_PARENTHESES: yoe,
    /* ) */
    CHAR_LEFT_CURLY_BRACE: goe,
    /* { */
    CHAR_RIGHT_CURLY_BRACE: _oe,
    /* } */
    CHAR_LEFT_SQUARE_BRACKET: KR,
    /* [ */
    CHAR_RIGHT_SQUARE_BRACKET: HR,
    /* ] */
    CHAR_DOUBLE_QUOTE: boe,
    /* " */
    CHAR_SINGLE_QUOTE: voe,
    /* ' */
    CHAR_NO_BREAK_SPACE: Soe,
    CHAR_ZERO_WIDTH_NOBREAK_SPACE: Toe
  } = jR(), Eoe = /* @__PURE__ */ s((e, t = {}) => {
    if (typeof e != "string")
      throw new TypeError("Expected a string");
    let r = t || {}, i = typeof r.maxLength == "number" ? Math.min(VR, r.maxLength) : VR;
    if (e.length > i)
      throw new SyntaxError(`Input length (${e.length}), exceeds max characters (${i})`);
    let n = { type: "root", input: e, nodes: [] }, a = [n], o = n, u = n, l = 0, c = e.length, p = 0, h = 0, y, _ = /* @__PURE__ */ s(() => e[p++],
    "advance"), g = /* @__PURE__ */ s((m) => {
      if (m.type === "text" && u.type === "dot" && (u.type = "text"), u && u.type === "text" && m.type === "text") {
        u.value += m.value;
        return;
      }
      return o.nodes.push(m), m.parent = o, m.prev = u, u = m, m;
    }, "push");
    for (g({ type: "bos" }); p < c; )
      if (o = a[a.length - 1], y = _(), !(y === Toe || y === Soe)) {
        if (y === Q0) {
          g({ type: "text", value: (t.keepEscaping ? y : "") + _() });
          continue;
        }
        if (y === HR) {
          g({ type: "text", value: "\\" + y });
          continue;
        }
        if (y === KR) {
          l++;
          let m;
          for (; p < c && (m = _()); ) {
            if (y += m, m === KR) {
              l++;
              continue;
            }
            if (m === Q0) {
              y += _();
              continue;
            }
            if (m === HR && (l--, l === 0))
              break;
          }
          g({ type: "text", value: y });
          continue;
        }
        if (y === moe) {
          o = g({ type: "paren", nodes: [] }), a.push(o), g({ type: "text", value: y });
          continue;
        }
        if (y === yoe) {
          if (o.type !== "paren") {
            g({ type: "text", value: y });
            continue;
          }
          o = a.pop(), g({ type: "text", value: y }), o = a[a.length - 1];
          continue;
        }
        if (y === boe || y === voe || y === poe) {
          let m = y, f;
          for (t.keepQuotes !== !0 && (y = ""); p < c && (f = _()); ) {
            if (f === Q0) {
              y += f + _();
              continue;
            }
            if (f === m) {
              t.keepQuotes === !0 && (y += f);
              break;
            }
            y += f;
          }
          g({ type: "text", value: y });
          continue;
        }
        if (y === goe) {
          h++;
          let f = {
            type: "brace",
            open: !0,
            close: !1,
            dollar: u.value && u.value.slice(-1) === "$" || o.dollar === !0,
            depth: h,
            commas: 0,
            ranges: 0,
            nodes: []
          };
          o = g(f), a.push(o), g({ type: "open", value: y });
          continue;
        }
        if (y === _oe) {
          if (o.type !== "brace") {
            g({ type: "text", value: y });
            continue;
          }
          let m = "close";
          o = a.pop(), o.close = !0, g({ type: m, value: y }), h--, o = a[a.length - 1];
          continue;
        }
        if (y === hoe && h > 0) {
          if (o.ranges > 0) {
            o.ranges = 0;
            let m = o.nodes.shift();
            o.nodes = [m, { type: "text", value: foe(o) }];
          }
          g({ type: "comma", value: y }), o.commas++;
          continue;
        }
        if (y === doe && h > 0 && o.commas === 0) {
          let m = o.nodes;
          if (h === 0 || m.length === 0) {
            g({ type: "text", value: y });
            continue;
          }
          if (u.type === "dot") {
            if (o.range = [], u.value += y, u.type = "range", o.nodes.length !== 3 && o.nodes.length !== 5) {
              o.invalid = !0, o.ranges = 0, u.type = "text";
              continue;
            }
            o.ranges++, o.args = [];
            continue;
          }
          if (u.type === "range") {
            m.pop();
            let f = m[m.length - 1];
            f.value += u.value + y, u = f, o.ranges--;
            continue;
          }
          g({ type: "dot", value: y });
          continue;
        }
        g({ type: "text", value: y });
      }
    do
      if (o = a.pop(), o.type !== "root") {
        o.nodes.forEach((d) => {
          d.nodes || (d.type === "open" && (d.isOpen = !0), d.type === "close" && (d.isClose = !0), d.nodes || (d.type = "text"), d.invalid =
          !0);
        });
        let m = a[a.length - 1], f = m.nodes.indexOf(o);
        m.nodes.splice(f, 1, ...o.nodes);
      }
    while (a.length > 0);
    return g({ type: "eos" }), n;
  }, "parse");
  zR.exports = Eoe;
});

// ../node_modules/braces/index.js
var XR = b((nyt, $R) => {
  "use strict";
  var WR = Iy(), Aoe = FR(), xoe = qR(), Coe = GR(), $s = /* @__PURE__ */ s((e, t = {}) => {
    let r = [];
    if (Array.isArray(e))
      for (let i of e) {
        let n = $s.create(i, t);
        Array.isArray(n) ? r.push(...n) : r.push(n);
      }
    else
      r = [].concat($s.create(e, t));
    return t && t.expand === !0 && t.nodupes === !0 && (r = [...new Set(r)]), r;
  }, "braces");
  $s.parse = (e, t = {}) => Coe(e, t);
  $s.stringify = (e, t = {}) => WR(typeof e == "string" ? $s.parse(e, t) : e, t);
  $s.compile = (e, t = {}) => (typeof e == "string" && (e = $s.parse(e, t)), Aoe(e, t));
  $s.expand = (e, t = {}) => {
    typeof e == "string" && (e = $s.parse(e, t));
    let r = xoe(e, t);
    return t.noempty === !0 && (r = r.filter(Boolean)), t.nodupes === !0 && (r = [...new Set(r)]), r;
  };
  $s.create = (e, t = {}) => e === "" || e.length < 3 ? [e] : t.expand !== !0 ? $s.compile(e, t) : $s.expand(e, t);
  $R.exports = $s;
});

// ../node_modules/picomatch/lib/constants.js
var Ch = b((ayt, eN) => {
  "use strict";
  var Poe = require("path"), So = "\\\\/", YR = `[^${So}]`, nu = "\\.", Doe = "\\+", woe = "\\?", Ly = "\\/", Ooe = "(?=.)", JR = "[^/]", Z0 = `\
(?:${Ly}|$)`, QR = `(?:^|${Ly})`, eT = `${nu}{1,2}${Z0}`, koe = `(?!${nu})`, Ioe = `(?!${QR}${eT})`, Roe = `(?!${nu}{0,1}${Z0})`, Noe = `(?!${eT}\
)`, Loe = `[^.${Ly}]`, Foe = `${JR}*?`, ZR = {
    DOT_LITERAL: nu,
    PLUS_LITERAL: Doe,
    QMARK_LITERAL: woe,
    SLASH_LITERAL: Ly,
    ONE_CHAR: Ooe,
    QMARK: JR,
    END_ANCHOR: Z0,
    DOTS_SLASH: eT,
    NO_DOT: koe,
    NO_DOTS: Ioe,
    NO_DOT_SLASH: Roe,
    NO_DOTS_SLASH: Noe,
    QMARK_NO_DOT: Loe,
    STAR: Foe,
    START_ANCHOR: QR
  }, Moe = {
    ...ZR,
    SLASH_LITERAL: `[${So}]`,
    QMARK: YR,
    STAR: `${YR}*?`,
    DOTS_SLASH: `${nu}{1,2}(?:[${So}]|$)`,
    NO_DOT: `(?!${nu})`,
    NO_DOTS: `(?!(?:^|[${So}])${nu}{1,2}(?:[${So}]|$))`,
    NO_DOT_SLASH: `(?!${nu}{0,1}(?:[${So}]|$))`,
    NO_DOTS_SLASH: `(?!${nu}{1,2}(?:[${So}]|$))`,
    QMARK_NO_DOT: `[^.${So}]`,
    START_ANCHOR: `(?:^|[${So}])`,
    END_ANCHOR: `(?:[${So}]|$)`
  }, Boe = {
    alnum: "a-zA-Z0-9",
    alpha: "a-zA-Z",
    ascii: "\\x00-\\x7F",
    blank: " \\t",
    cntrl: "\\x00-\\x1F\\x7F",
    digit: "0-9",
    graph: "\\x21-\\x7E",
    lower: "a-z",
    print: "\\x20-\\x7E ",
    punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
    space: " \\t\\r\\n\\v\\f",
    upper: "A-Z",
    word: "A-Za-z0-9_",
    xdigit: "A-Fa-f0-9"
  };
  eN.exports = {
    MAX_LENGTH: 1024 * 64,
    POSIX_REGEX_SOURCE: Boe,
    // regular expressions
    REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
    REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
    REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
    REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
    REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
    REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
    // Replace globs with equivalent patterns to reduce parsing time.
    REPLACEMENTS: {
      "***": "*",
      "**/**": "**",
      "**/**/**": "**"
    },
    // Digits
    CHAR_0: 48,
    /* 0 */
    CHAR_9: 57,
    /* 9 */
    // Alphabet chars.
    CHAR_UPPERCASE_A: 65,
    /* A */
    CHAR_LOWERCASE_A: 97,
    /* a */
    CHAR_UPPERCASE_Z: 90,
    /* Z */
    CHAR_LOWERCASE_Z: 122,
    /* z */
    CHAR_LEFT_PARENTHESES: 40,
    /* ( */
    CHAR_RIGHT_PARENTHESES: 41,
    /* ) */
    CHAR_ASTERISK: 42,
    /* * */
    // Non-alphabetic chars.
    CHAR_AMPERSAND: 38,
    /* & */
    CHAR_AT: 64,
    /* @ */
    CHAR_BACKWARD_SLASH: 92,
    /* \ */
    CHAR_CARRIAGE_RETURN: 13,
    /* \r */
    CHAR_CIRCUMFLEX_ACCENT: 94,
    /* ^ */
    CHAR_COLON: 58,
    /* : */
    CHAR_COMMA: 44,
    /* , */
    CHAR_DOT: 46,
    /* . */
    CHAR_DOUBLE_QUOTE: 34,
    /* " */
    CHAR_EQUAL: 61,
    /* = */
    CHAR_EXCLAMATION_MARK: 33,
    /* ! */
    CHAR_FORM_FEED: 12,
    /* \f */
    CHAR_FORWARD_SLASH: 47,
    /* / */
    CHAR_GRAVE_ACCENT: 96,
    /* ` */
    CHAR_HASH: 35,
    /* # */
    CHAR_HYPHEN_MINUS: 45,
    /* - */
    CHAR_LEFT_ANGLE_BRACKET: 60,
    /* < */
    CHAR_LEFT_CURLY_BRACE: 123,
    /* { */
    CHAR_LEFT_SQUARE_BRACKET: 91,
    /* [ */
    CHAR_LINE_FEED: 10,
    /* \n */
    CHAR_NO_BREAK_SPACE: 160,
    /* \u00A0 */
    CHAR_PERCENT: 37,
    /* % */
    CHAR_PLUS: 43,
    /* + */
    CHAR_QUESTION_MARK: 63,
    /* ? */
    CHAR_RIGHT_ANGLE_BRACKET: 62,
    /* > */
    CHAR_RIGHT_CURLY_BRACE: 125,
    /* } */
    CHAR_RIGHT_SQUARE_BRACKET: 93,
    /* ] */
    CHAR_SEMICOLON: 59,
    /* ; */
    CHAR_SINGLE_QUOTE: 39,
    /* ' */
    CHAR_SPACE: 32,
    /*   */
    CHAR_TAB: 9,
    /* \t */
    CHAR_UNDERSCORE: 95,
    /* _ */
    CHAR_VERTICAL_LINE: 124,
    /* | */
    CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
    /* \uFEFF */
    SEP: Poe.sep,
    /**
     * Create EXTGLOB_CHARS
     */
    extglobChars(e) {
      return {
        "!": { type: "negate", open: "(?:(?!(?:", close: `))${e.STAR})` },
        "?": { type: "qmark", open: "(?:", close: ")?" },
        "+": { type: "plus", open: "(?:", close: ")+" },
        "*": { type: "star", open: "(?:", close: ")*" },
        "@": { type: "at", open: "(?:", close: ")" }
      };
    },
    /**
     * Create GLOB_CHARS
     */
    globChars(e) {
      return e === !0 ? Moe : ZR;
    }
  };
});

// ../node_modules/picomatch/lib/utils.js
var Ph = b((ws) => {
  "use strict";
  var qoe = require("path"), Uoe = process.platform === "win32", {
    REGEX_BACKSLASH: joe,
    REGEX_REMOVE_BACKSLASH: Voe,
    REGEX_SPECIAL_CHARS: Koe,
    REGEX_SPECIAL_CHARS_GLOBAL: Hoe
  } = Ch();
  ws.isObject = (e) => e !== null && typeof e == "object" && !Array.isArray(e);
  ws.hasRegexChars = (e) => Koe.test(e);
  ws.isRegexChar = (e) => e.length === 1 && ws.hasRegexChars(e);
  ws.escapeRegex = (e) => e.replace(Hoe, "\\$1");
  ws.toPosixSlashes = (e) => e.replace(joe, "/");
  ws.removeBackslashes = (e) => e.replace(Voe, (t) => t === "\\" ? "" : t);
  ws.supportsLookbehinds = () => {
    let e = process.version.slice(1).split(".").map(Number);
    return e.length === 3 && e[0] >= 9 || e[0] === 8 && e[1] >= 10;
  };
  ws.isWindows = (e) => e && typeof e.windows == "boolean" ? e.windows : Uoe === !0 || qoe.sep === "\\";
  ws.escapeLast = (e, t, r) => {
    let i = e.lastIndexOf(t, r);
    return i === -1 ? e : e[i - 1] === "\\" ? ws.escapeLast(e, t, i - 1) : `${e.slice(0, i)}\\${e.slice(i)}`;
  };
  ws.removePrefix = (e, t = {}) => {
    let r = e;
    return r.startsWith("./") && (r = r.slice(2), t.prefix = "./"), r;
  };
  ws.wrapOutput = (e, t = {}, r = {}) => {
    let i = r.contains ? "" : "^", n = r.contains ? "" : "$", a = `${i}(?:${e})${n}`;
    return t.negated === !0 && (a = `(?:^(?!${a}).*$)`), a;
  };
});

// ../node_modules/picomatch/lib/scan.js
var uN = b((uyt, oN) => {
  "use strict";
  var tN = Ph(), {
    CHAR_ASTERISK: tT,
    /* * */
    CHAR_AT: zoe,
    /* @ */
    CHAR_BACKWARD_SLASH: Dh,
    /* \ */
    CHAR_COMMA: Goe,
    /* , */
    CHAR_DOT: rT,
    /* . */
    CHAR_EXCLAMATION_MARK: iT,
    /* ! */
    CHAR_FORWARD_SLASH: aN,
    /* / */
    CHAR_LEFT_CURLY_BRACE: nT,
    /* { */
    CHAR_LEFT_PARENTHESES: sT,
    /* ( */
    CHAR_LEFT_SQUARE_BRACKET: Woe,
    /* [ */
    CHAR_PLUS: $oe,
    /* + */
    CHAR_QUESTION_MARK: rN,
    /* ? */
    CHAR_RIGHT_CURLY_BRACE: Xoe,
    /* } */
    CHAR_RIGHT_PARENTHESES: iN,
    /* ) */
    CHAR_RIGHT_SQUARE_BRACKET: Yoe
    /* ] */
  } = Ch(), nN = /* @__PURE__ */ s((e) => e === aN || e === Dh, "isPathSeparator"), sN = /* @__PURE__ */ s((e) => {
    e.isPrefix !== !0 && (e.depth = e.isGlobstar ? 1 / 0 : 1);
  }, "depth"), Joe = /* @__PURE__ */ s((e, t) => {
    let r = t || {}, i = e.length - 1, n = r.parts === !0 || r.scanToEnd === !0, a = [], o = [], u = [], l = e, c = -1, p = 0, h = 0, y = !1,
    _ = !1, g = !1, m = !1, f = !1, d = !1, v = !1, E = !1, S = !1, x = !1, C = 0, z, w, D = { value: "", depth: 0, isGlob: !1 }, N = /* @__PURE__ */ s(
    () => c >= i, "eos"), T = /* @__PURE__ */ s(() => l.charCodeAt(c + 1), "peek"), R = /* @__PURE__ */ s(() => (z = w, l.charCodeAt(++c)), "\
advance");
    for (; c < i; ) {
      w = R();
      let re;
      if (w === Dh) {
        v = D.backslashes = !0, w = R(), w === nT && (d = !0);
        continue;
      }
      if (d === !0 || w === nT) {
        for (C++; N() !== !0 && (w = R()); ) {
          if (w === Dh) {
            v = D.backslashes = !0, R();
            continue;
          }
          if (w === nT) {
            C++;
            continue;
          }
          if (d !== !0 && w === rT && (w = R()) === rT) {
            if (y = D.isBrace = !0, g = D.isGlob = !0, x = !0, n === !0)
              continue;
            break;
          }
          if (d !== !0 && w === Goe) {
            if (y = D.isBrace = !0, g = D.isGlob = !0, x = !0, n === !0)
              continue;
            break;
          }
          if (w === Xoe && (C--, C === 0)) {
            d = !1, y = D.isBrace = !0, x = !0;
            break;
          }
        }
        if (n === !0)
          continue;
        break;
      }
      if (w === aN) {
        if (a.push(c), o.push(D), D = { value: "", depth: 0, isGlob: !1 }, x === !0) continue;
        if (z === rT && c === p + 1) {
          p += 2;
          continue;
        }
        h = c + 1;
        continue;
      }
      if (r.noext !== !0 && (w === $oe || w === zoe || w === tT || w === rN || w === iT) === !0 && T() === sT) {
        if (g = D.isGlob = !0, m = D.isExtglob = !0, x = !0, w === iT && c === p && (S = !0), n === !0) {
          for (; N() !== !0 && (w = R()); ) {
            if (w === Dh) {
              v = D.backslashes = !0, w = R();
              continue;
            }
            if (w === iN) {
              g = D.isGlob = !0, x = !0;
              break;
            }
          }
          continue;
        }
        break;
      }
      if (w === tT) {
        if (z === tT && (f = D.isGlobstar = !0), g = D.isGlob = !0, x = !0, n === !0)
          continue;
        break;
      }
      if (w === rN) {
        if (g = D.isGlob = !0, x = !0, n === !0)
          continue;
        break;
      }
      if (w === Woe) {
        for (; N() !== !0 && (re = R()); ) {
          if (re === Dh) {
            v = D.backslashes = !0, R();
            continue;
          }
          if (re === Yoe) {
            _ = D.isBracket = !0, g = D.isGlob = !0, x = !0;
            break;
          }
        }
        if (n === !0)
          continue;
        break;
      }
      if (r.nonegate !== !0 && w === iT && c === p) {
        E = D.negated = !0, p++;
        continue;
      }
      if (r.noparen !== !0 && w === sT) {
        if (g = D.isGlob = !0, n === !0) {
          for (; N() !== !0 && (w = R()); ) {
            if (w === sT) {
              v = D.backslashes = !0, w = R();
              continue;
            }
            if (w === iN) {
              x = !0;
              break;
            }
          }
          continue;
        }
        break;
      }
      if (g === !0) {
        if (x = !0, n === !0)
          continue;
        break;
      }
    }
    r.noext === !0 && (m = !1, g = !1);
    let j = l, J = "", H = "";
    p > 0 && (J = l.slice(0, p), l = l.slice(p), h -= p), j && g === !0 && h > 0 ? (j = l.slice(0, h), H = l.slice(h)) : g === !0 ? (j = "",
    H = l) : j = l, j && j !== "" && j !== "/" && j !== l && nN(j.charCodeAt(j.length - 1)) && (j = j.slice(0, -1)), r.unescape === !0 && (H &&
    (H = tN.removeBackslashes(H)), j && v === !0 && (j = tN.removeBackslashes(j)));
    let F = {
      prefix: J,
      input: e,
      start: p,
      base: j,
      glob: H,
      isBrace: y,
      isBracket: _,
      isGlob: g,
      isExtglob: m,
      isGlobstar: f,
      negated: E,
      negatedExtglob: S
    };
    if (r.tokens === !0 && (F.maxDepth = 0, nN(w) || o.push(D), F.tokens = o), r.parts === !0 || r.tokens === !0) {
      let re;
      for (let se = 0; se < a.length; se++) {
        let de = re ? re + 1 : p, he = a[se], xe = e.slice(de, he);
        r.tokens && (se === 0 && p !== 0 ? (o[se].isPrefix = !0, o[se].value = J) : o[se].value = xe, sN(o[se]), F.maxDepth += o[se].depth),
        (se !== 0 || xe !== "") && u.push(xe), re = he;
      }
      if (re && re + 1 < e.length) {
        let se = e.slice(re + 1);
        u.push(se), r.tokens && (o[o.length - 1].value = se, sN(o[o.length - 1]), F.maxDepth += o[o.length - 1].depth);
      }
      F.slashes = a, F.parts = u;
    }
    return F;
  }, "scan");
  oN.exports = Joe;
});

// ../node_modules/picomatch/lib/parse.js
var fN = b((cyt, cN) => {
  "use strict";
  var Fy = Ch(), Xs = Ph(), {
    MAX_LENGTH: My,
    POSIX_REGEX_SOURCE: Qoe,
    REGEX_NON_SPECIAL_CHARS: Zoe,
    REGEX_SPECIAL_CHARS_BACKREF: eue,
    REPLACEMENTS: lN
  } = Fy, tue = /* @__PURE__ */ s((e, t) => {
    if (typeof t.expandRange == "function")
      return t.expandRange(...e, t);
    e.sort();
    let r = `[${e.join("-")}]`;
    try {
      new RegExp(r);
    } catch {
      return e.map((n) => Xs.escapeRegex(n)).join("..");
    }
    return r;
  }, "expandRange"), Pf = /* @__PURE__ */ s((e, t) => `Missing ${e}: "${t}" - use "\\\\${t}" to match literal characters`, "syntaxError"), aT = /* @__PURE__ */ s(
  (e, t) => {
    if (typeof e != "string")
      throw new TypeError("Expected a string");
    e = lN[e] || e;
    let r = { ...t }, i = typeof r.maxLength == "number" ? Math.min(My, r.maxLength) : My, n = e.length;
    if (n > i)
      throw new SyntaxError(`Input length: ${n}, exceeds maximum allowed length: ${i}`);
    let a = { type: "bos", value: "", output: r.prepend || "" }, o = [a], u = r.capture ? "" : "?:", l = Xs.isWindows(t), c = Fy.globChars(l),
    p = Fy.extglobChars(c), {
      DOT_LITERAL: h,
      PLUS_LITERAL: y,
      SLASH_LITERAL: _,
      ONE_CHAR: g,
      DOTS_SLASH: m,
      NO_DOT: f,
      NO_DOT_SLASH: d,
      NO_DOTS_SLASH: v,
      QMARK: E,
      QMARK_NO_DOT: S,
      STAR: x,
      START_ANCHOR: C
    } = c, z = /* @__PURE__ */ s((Ee) => `(${u}(?:(?!${C}${Ee.dot ? m : h}).)*?)`, "globstar"), w = r.dot ? "" : f, D = r.dot ? E : S, N = r.
    bash === !0 ? z(r) : x;
    r.capture && (N = `(${N})`), typeof r.noext == "boolean" && (r.noextglob = r.noext);
    let T = {
      input: e,
      index: -1,
      start: 0,
      dot: r.dot === !0,
      consumed: "",
      output: "",
      prefix: "",
      backtrack: !1,
      negated: !1,
      brackets: 0,
      braces: 0,
      parens: 0,
      quotes: 0,
      globstar: !1,
      tokens: o
    };
    e = Xs.removePrefix(e, T), n = e.length;
    let R = [], j = [], J = [], H = a, F, re = /* @__PURE__ */ s(() => T.index === n - 1, "eos"), se = T.peek = (Ee = 1) => e[T.index + Ee],
    de = T.advance = () => e[++T.index] || "", he = /* @__PURE__ */ s(() => e.slice(T.index + 1), "remaining"), xe = /* @__PURE__ */ s((Ee = "", st = 0) => {
      T.consumed += Ee, T.index += st;
    }, "consume"), G = /* @__PURE__ */ s((Ee) => {
      T.output += Ee.output != null ? Ee.output : Ee.value, xe(Ee.value);
    }, "append"), ie = /* @__PURE__ */ s(() => {
      let Ee = 1;
      for (; se() === "!" && (se(2) !== "(" || se(3) === "?"); )
        de(), T.start++, Ee++;
      return Ee % 2 === 0 ? !1 : (T.negated = !0, T.start++, !0);
    }, "negate"), X = /* @__PURE__ */ s((Ee) => {
      T[Ee]++, J.push(Ee);
    }, "increment"), ye = /* @__PURE__ */ s((Ee) => {
      T[Ee]--, J.pop();
    }, "decrement"), Oe = /* @__PURE__ */ s((Ee) => {
      if (H.type === "globstar") {
        let st = T.braces > 0 && (Ee.type === "comma" || Ee.type === "brace"), oe = Ee.extglob === !0 || R.length && (Ee.type === "pipe" || Ee.
        type === "paren");
        Ee.type !== "slash" && Ee.type !== "paren" && !st && !oe && (T.output = T.output.slice(0, -H.output.length), H.type = "star", H.value =
        "*", H.output = N, T.output += H.output);
      }
      if (R.length && Ee.type !== "paren" && (R[R.length - 1].inner += Ee.value), (Ee.value || Ee.output) && G(Ee), H && H.type === "text" &&
      Ee.type === "text") {
        H.value += Ee.value, H.output = (H.output || "") + Ee.value;
        return;
      }
      Ee.prev = H, o.push(Ee), H = Ee;
    }, "push"), Pt = /* @__PURE__ */ s((Ee, st) => {
      let oe = { ...p[st], conditions: 1, inner: "" };
      oe.prev = H, oe.parens = T.parens, oe.output = T.output;
      let Ae = (r.capture ? "(" : "") + oe.open;
      X("parens"), Oe({ type: Ee, value: st, output: T.output ? "" : g }), Oe({ type: "paren", extglob: !0, value: de(), output: Ae }), R.push(
      oe);
    }, "extglobOpen"), Vt = /* @__PURE__ */ s((Ee) => {
      let st = Ee.close + (r.capture ? ")" : ""), oe;
      if (Ee.type === "negate") {
        let Ae = N;
        if (Ee.inner && Ee.inner.length > 1 && Ee.inner.includes("/") && (Ae = z(r)), (Ae !== N || re() || /^\)+$/.test(he())) && (st = Ee.close =
        `)$))${Ae}`), Ee.inner.includes("*") && (oe = he()) && /^\.[^\\/.]+$/.test(oe)) {
          let Ie = aT(oe, { ...t, fastpaths: !1 }).output;
          st = Ee.close = `)${Ie})${Ae})`;
        }
        Ee.prev.type === "bos" && (T.negatedExtglob = !0);
      }
      Oe({ type: "paren", extglob: !0, value: F, output: st }), ye("parens");
    }, "extglobClose");
    if (r.fastpaths !== !1 && !/(^[*!]|[/()[\]{}"])/.test(e)) {
      let Ee = !1, st = e.replace(eue, (oe, Ae, Ie, te, pe, we) => te === "\\" ? (Ee = !0, oe) : te === "?" ? Ae ? Ae + te + (pe ? E.repeat(
      pe.length) : "") : we === 0 ? D + (pe ? E.repeat(pe.length) : "") : E.repeat(Ie.length) : te === "." ? h.repeat(Ie.length) : te === "*" ?
      Ae ? Ae + te + (pe ? N : "") : N : Ae ? oe : `\\${oe}`);
      return Ee === !0 && (r.unescape === !0 ? st = st.replace(/\\/g, "") : st = st.replace(/\\+/g, (oe) => oe.length % 2 === 0 ? "\\\\" : oe ?
      "\\" : "")), st === e && r.contains === !0 ? (T.output = e, T) : (T.output = Xs.wrapOutput(st, T, t), T);
    }
    for (; !re(); ) {
      if (F = de(), F === "\0")
        continue;
      if (F === "\\") {
        let oe = se();
        if (oe === "/" && r.bash !== !0 || oe === "." || oe === ";")
          continue;
        if (!oe) {
          F += "\\", Oe({ type: "text", value: F });
          continue;
        }
        let Ae = /^\\+/.exec(he()), Ie = 0;
        if (Ae && Ae[0].length > 2 && (Ie = Ae[0].length, T.index += Ie, Ie % 2 !== 0 && (F += "\\")), r.unescape === !0 ? F = de() : F += de(),
        T.brackets === 0) {
          Oe({ type: "text", value: F });
          continue;
        }
      }
      if (T.brackets > 0 && (F !== "]" || H.value === "[" || H.value === "[^")) {
        if (r.posix !== !1 && F === ":") {
          let oe = H.value.slice(1);
          if (oe.includes("[") && (H.posix = !0, oe.includes(":"))) {
            let Ae = H.value.lastIndexOf("["), Ie = H.value.slice(0, Ae), te = H.value.slice(Ae + 2), pe = Qoe[te];
            if (pe) {
              H.value = Ie + pe, T.backtrack = !0, de(), !a.output && o.indexOf(H) === 1 && (a.output = g);
              continue;
            }
          }
        }
        (F === "[" && se() !== ":" || F === "-" && se() === "]") && (F = `\\${F}`), F === "]" && (H.value === "[" || H.value === "[^") && (F =
        `\\${F}`), r.posix === !0 && F === "!" && H.value === "[" && (F = "^"), H.value += F, G({ value: F });
        continue;
      }
      if (T.quotes === 1 && F !== '"') {
        F = Xs.escapeRegex(F), H.value += F, G({ value: F });
        continue;
      }
      if (F === '"') {
        T.quotes = T.quotes === 1 ? 0 : 1, r.keepQuotes === !0 && Oe({ type: "text", value: F });
        continue;
      }
      if (F === "(") {
        X("parens"), Oe({ type: "paren", value: F });
        continue;
      }
      if (F === ")") {
        if (T.parens === 0 && r.strictBrackets === !0)
          throw new SyntaxError(Pf("opening", "("));
        let oe = R[R.length - 1];
        if (oe && T.parens === oe.parens + 1) {
          Vt(R.pop());
          continue;
        }
        Oe({ type: "paren", value: F, output: T.parens ? ")" : "\\)" }), ye("parens");
        continue;
      }
      if (F === "[") {
        if (r.nobracket === !0 || !he().includes("]")) {
          if (r.nobracket !== !0 && r.strictBrackets === !0)
            throw new SyntaxError(Pf("closing", "]"));
          F = `\\${F}`;
        } else
          X("brackets");
        Oe({ type: "bracket", value: F });
        continue;
      }
      if (F === "]") {
        if (r.nobracket === !0 || H && H.type === "bracket" && H.value.length === 1) {
          Oe({ type: "text", value: F, output: `\\${F}` });
          continue;
        }
        if (T.brackets === 0) {
          if (r.strictBrackets === !0)
            throw new SyntaxError(Pf("opening", "["));
          Oe({ type: "text", value: F, output: `\\${F}` });
          continue;
        }
        ye("brackets");
        let oe = H.value.slice(1);
        if (H.posix !== !0 && oe[0] === "^" && !oe.includes("/") && (F = `/${F}`), H.value += F, G({ value: F }), r.literalBrackets === !1 ||
        Xs.hasRegexChars(oe))
          continue;
        let Ae = Xs.escapeRegex(H.value);
        if (T.output = T.output.slice(0, -H.value.length), r.literalBrackets === !0) {
          T.output += Ae, H.value = Ae;
          continue;
        }
        H.value = `(${u}${Ae}|${H.value})`, T.output += H.value;
        continue;
      }
      if (F === "{" && r.nobrace !== !0) {
        X("braces");
        let oe = {
          type: "brace",
          value: F,
          output: "(",
          outputIndex: T.output.length,
          tokensIndex: T.tokens.length
        };
        j.push(oe), Oe(oe);
        continue;
      }
      if (F === "}") {
        let oe = j[j.length - 1];
        if (r.nobrace === !0 || !oe) {
          Oe({ type: "text", value: F, output: F });
          continue;
        }
        let Ae = ")";
        if (oe.dots === !0) {
          let Ie = o.slice(), te = [];
          for (let pe = Ie.length - 1; pe >= 0 && (o.pop(), Ie[pe].type !== "brace"); pe--)
            Ie[pe].type !== "dots" && te.unshift(Ie[pe].value);
          Ae = tue(te, r), T.backtrack = !0;
        }
        if (oe.comma !== !0 && oe.dots !== !0) {
          let Ie = T.output.slice(0, oe.outputIndex), te = T.tokens.slice(oe.tokensIndex);
          oe.value = oe.output = "\\{", F = Ae = "\\}", T.output = Ie;
          for (let pe of te)
            T.output += pe.output || pe.value;
        }
        Oe({ type: "brace", value: F, output: Ae }), ye("braces"), j.pop();
        continue;
      }
      if (F === "|") {
        R.length > 0 && R[R.length - 1].conditions++, Oe({ type: "text", value: F });
        continue;
      }
      if (F === ",") {
        let oe = F, Ae = j[j.length - 1];
        Ae && J[J.length - 1] === "braces" && (Ae.comma = !0, oe = "|"), Oe({ type: "comma", value: F, output: oe });
        continue;
      }
      if (F === "/") {
        if (H.type === "dot" && T.index === T.start + 1) {
          T.start = T.index + 1, T.consumed = "", T.output = "", o.pop(), H = a;
          continue;
        }
        Oe({ type: "slash", value: F, output: _ });
        continue;
      }
      if (F === ".") {
        if (T.braces > 0 && H.type === "dot") {
          H.value === "." && (H.output = h);
          let oe = j[j.length - 1];
          H.type = "dots", H.output += F, H.value += F, oe.dots = !0;
          continue;
        }
        if (T.braces + T.parens === 0 && H.type !== "bos" && H.type !== "slash") {
          Oe({ type: "text", value: F, output: h });
          continue;
        }
        Oe({ type: "dot", value: F, output: h });
        continue;
      }
      if (F === "?") {
        if (!(H && H.value === "(") && r.noextglob !== !0 && se() === "(" && se(2) !== "?") {
          Pt("qmark", F);
          continue;
        }
        if (H && H.type === "paren") {
          let Ae = se(), Ie = F;
          if (Ae === "<" && !Xs.supportsLookbehinds())
            throw new Error("Node.js v10 or higher is required for regex lookbehinds");
          (H.value === "(" && !/[!=<:]/.test(Ae) || Ae === "<" && !/<([!=]|\w+>)/.test(he())) && (Ie = `\\${F}`), Oe({ type: "text", value: F,
          output: Ie });
          continue;
        }
        if (r.dot !== !0 && (H.type === "slash" || H.type === "bos")) {
          Oe({ type: "qmark", value: F, output: S });
          continue;
        }
        Oe({ type: "qmark", value: F, output: E });
        continue;
      }
      if (F === "!") {
        if (r.noextglob !== !0 && se() === "(" && (se(2) !== "?" || !/[!=<:]/.test(se(3)))) {
          Pt("negate", F);
          continue;
        }
        if (r.nonegate !== !0 && T.index === 0) {
          ie();
          continue;
        }
      }
      if (F === "+") {
        if (r.noextglob !== !0 && se() === "(" && se(2) !== "?") {
          Pt("plus", F);
          continue;
        }
        if (H && H.value === "(" || r.regex === !1) {
          Oe({ type: "plus", value: F, output: y });
          continue;
        }
        if (H && (H.type === "bracket" || H.type === "paren" || H.type === "brace") || T.parens > 0) {
          Oe({ type: "plus", value: F });
          continue;
        }
        Oe({ type: "plus", value: y });
        continue;
      }
      if (F === "@") {
        if (r.noextglob !== !0 && se() === "(" && se(2) !== "?") {
          Oe({ type: "at", extglob: !0, value: F, output: "" });
          continue;
        }
        Oe({ type: "text", value: F });
        continue;
      }
      if (F !== "*") {
        (F === "$" || F === "^") && (F = `\\${F}`);
        let oe = Zoe.exec(he());
        oe && (F += oe[0], T.index += oe[0].length), Oe({ type: "text", value: F });
        continue;
      }
      if (H && (H.type === "globstar" || H.star === !0)) {
        H.type = "star", H.star = !0, H.value += F, H.output = N, T.backtrack = !0, T.globstar = !0, xe(F);
        continue;
      }
      let Ee = he();
      if (r.noextglob !== !0 && /^\([^?]/.test(Ee)) {
        Pt("star", F);
        continue;
      }
      if (H.type === "star") {
        if (r.noglobstar === !0) {
          xe(F);
          continue;
        }
        let oe = H.prev, Ae = oe.prev, Ie = oe.type === "slash" || oe.type === "bos", te = Ae && (Ae.type === "star" || Ae.type === "globsta\
r");
        if (r.bash === !0 && (!Ie || Ee[0] && Ee[0] !== "/")) {
          Oe({ type: "star", value: F, output: "" });
          continue;
        }
        let pe = T.braces > 0 && (oe.type === "comma" || oe.type === "brace"), we = R.length && (oe.type === "pipe" || oe.type === "paren");
        if (!Ie && oe.type !== "paren" && !pe && !we) {
          Oe({ type: "star", value: F, output: "" });
          continue;
        }
        for (; Ee.slice(0, 3) === "/**"; ) {
          let He = e[T.index + 4];
          if (He && He !== "/")
            break;
          Ee = Ee.slice(3), xe("/**", 3);
        }
        if (oe.type === "bos" && re()) {
          H.type = "globstar", H.value += F, H.output = z(r), T.output = H.output, T.globstar = !0, xe(F);
          continue;
        }
        if (oe.type === "slash" && oe.prev.type !== "bos" && !te && re()) {
          T.output = T.output.slice(0, -(oe.output + H.output).length), oe.output = `(?:${oe.output}`, H.type = "globstar", H.output = z(r) +
          (r.strictSlashes ? ")" : "|$)"), H.value += F, T.globstar = !0, T.output += oe.output + H.output, xe(F);
          continue;
        }
        if (oe.type === "slash" && oe.prev.type !== "bos" && Ee[0] === "/") {
          let He = Ee[1] !== void 0 ? "|$" : "";
          T.output = T.output.slice(0, -(oe.output + H.output).length), oe.output = `(?:${oe.output}`, H.type = "globstar", H.output = `${z(
          r)}${_}|${_}${He})`, H.value += F, T.output += oe.output + H.output, T.globstar = !0, xe(F + de()), Oe({ type: "slash", value: "/",
          output: "" });
          continue;
        }
        if (oe.type === "bos" && Ee[0] === "/") {
          H.type = "globstar", H.value += F, H.output = `(?:^|${_}|${z(r)}${_})`, T.output = H.output, T.globstar = !0, xe(F + de()), Oe({ type: "\
slash", value: "/", output: "" });
          continue;
        }
        T.output = T.output.slice(0, -H.output.length), H.type = "globstar", H.output = z(r), H.value += F, T.output += H.output, T.globstar =
        !0, xe(F);
        continue;
      }
      let st = { type: "star", value: F, output: N };
      if (r.bash === !0) {
        st.output = ".*?", (H.type === "bos" || H.type === "slash") && (st.output = w + st.output), Oe(st);
        continue;
      }
      if (H && (H.type === "bracket" || H.type === "paren") && r.regex === !0) {
        st.output = F, Oe(st);
        continue;
      }
      (T.index === T.start || H.type === "slash" || H.type === "dot") && (H.type === "dot" ? (T.output += d, H.output += d) : r.dot === !0 ?
      (T.output += v, H.output += v) : (T.output += w, H.output += w), se() !== "*" && (T.output += g, H.output += g)), Oe(st);
    }
    for (; T.brackets > 0; ) {
      if (r.strictBrackets === !0) throw new SyntaxError(Pf("closing", "]"));
      T.output = Xs.escapeLast(T.output, "["), ye("brackets");
    }
    for (; T.parens > 0; ) {
      if (r.strictBrackets === !0) throw new SyntaxError(Pf("closing", ")"));
      T.output = Xs.escapeLast(T.output, "("), ye("parens");
    }
    for (; T.braces > 0; ) {
      if (r.strictBrackets === !0) throw new SyntaxError(Pf("closing", "}"));
      T.output = Xs.escapeLast(T.output, "{"), ye("braces");
    }
    if (r.strictSlashes !== !0 && (H.type === "star" || H.type === "bracket") && Oe({ type: "maybe_slash", value: "", output: `${_}?` }), T.
    backtrack === !0) {
      T.output = "";
      for (let Ee of T.tokens)
        T.output += Ee.output != null ? Ee.output : Ee.value, Ee.suffix && (T.output += Ee.suffix);
    }
    return T;
  }, "parse");
  aT.fastpaths = (e, t) => {
    let r = { ...t }, i = typeof r.maxLength == "number" ? Math.min(My, r.maxLength) : My, n = e.length;
    if (n > i)
      throw new SyntaxError(`Input length: ${n}, exceeds maximum allowed length: ${i}`);
    e = lN[e] || e;
    let a = Xs.isWindows(t), {
      DOT_LITERAL: o,
      SLASH_LITERAL: u,
      ONE_CHAR: l,
      DOTS_SLASH: c,
      NO_DOT: p,
      NO_DOTS: h,
      NO_DOTS_SLASH: y,
      STAR: _,
      START_ANCHOR: g
    } = Fy.globChars(a), m = r.dot ? h : p, f = r.dot ? y : p, d = r.capture ? "" : "?:", v = { negated: !1, prefix: "" }, E = r.bash === !0 ?
    ".*?" : _;
    r.capture && (E = `(${E})`);
    let S = /* @__PURE__ */ s((w) => w.noglobstar === !0 ? E : `(${d}(?:(?!${g}${w.dot ? c : o}).)*?)`, "globstar"), x = /* @__PURE__ */ s((w) => {
      switch (w) {
        case "*":
          return `${m}${l}${E}`;
        case ".*":
          return `${o}${l}${E}`;
        case "*.*":
          return `${m}${E}${o}${l}${E}`;
        case "*/*":
          return `${m}${E}${u}${l}${f}${E}`;
        case "**":
          return m + S(r);
        case "**/*":
          return `(?:${m}${S(r)}${u})?${f}${l}${E}`;
        case "**/*.*":
          return `(?:${m}${S(r)}${u})?${f}${E}${o}${l}${E}`;
        case "**/.*":
          return `(?:${m}${S(r)}${u})?${o}${l}${E}`;
        default: {
          let D = /^(.*?)\.(\w+)$/.exec(w);
          if (!D) return;
          let N = x(D[1]);
          return N ? N + o + D[2] : void 0;
        }
      }
    }, "create"), C = Xs.removePrefix(e, v), z = x(C);
    return z && r.strictSlashes !== !0 && (z += `${u}?`), z;
  };
  cN.exports = aT;
});

// ../node_modules/picomatch/lib/picomatch.js
var hN = b((pyt, pN) => {
  "use strict";
  var rue = require("path"), iue = uN(), oT = fN(), uT = Ph(), nue = Ch(), sue = /* @__PURE__ */ s((e) => e && typeof e == "object" && !Array.
  isArray(e), "isObject"), Vi = /* @__PURE__ */ s((e, t, r = !1) => {
    if (Array.isArray(e)) {
      let p = e.map((y) => Vi(y, t, r));
      return /* @__PURE__ */ s((y) => {
        for (let _ of p) {
          let g = _(y);
          if (g) return g;
        }
        return !1;
      }, "arrayMatcher");
    }
    let i = sue(e) && e.tokens && e.input;
    if (e === "" || typeof e != "string" && !i)
      throw new TypeError("Expected pattern to be a non-empty string");
    let n = t || {}, a = uT.isWindows(t), o = i ? Vi.compileRe(e, t) : Vi.makeRe(e, t, !1, !0), u = o.state;
    delete o.state;
    let l = /* @__PURE__ */ s(() => !1, "isIgnored");
    if (n.ignore) {
      let p = { ...t, ignore: null, onMatch: null, onResult: null };
      l = Vi(n.ignore, p, r);
    }
    let c = /* @__PURE__ */ s((p, h = !1) => {
      let { isMatch: y, match: _, output: g } = Vi.test(p, o, t, { glob: e, posix: a }), m = { glob: e, state: u, regex: o, posix: a, input: p,
      output: g, match: _, isMatch: y };
      return typeof n.onResult == "function" && n.onResult(m), y === !1 ? (m.isMatch = !1, h ? m : !1) : l(p) ? (typeof n.onIgnore == "funct\
ion" && n.onIgnore(m), m.isMatch = !1, h ? m : !1) : (typeof n.onMatch == "function" && n.onMatch(m), h ? m : !0);
    }, "matcher");
    return r && (c.state = u), c;
  }, "picomatch");
  Vi.test = (e, t, r, { glob: i, posix: n } = {}) => {
    if (typeof e != "string")
      throw new TypeError("Expected input to be a string");
    if (e === "")
      return { isMatch: !1, output: "" };
    let a = r || {}, o = a.format || (n ? uT.toPosixSlashes : null), u = e === i, l = u && o ? o(e) : e;
    return u === !1 && (l = o ? o(e) : e, u = l === i), (u === !1 || a.capture === !0) && (a.matchBase === !0 || a.basename === !0 ? u = Vi.
    matchBase(e, t, r, n) : u = t.exec(l)), { isMatch: !!u, match: u, output: l };
  };
  Vi.matchBase = (e, t, r, i = uT.isWindows(r)) => (t instanceof RegExp ? t : Vi.makeRe(t, r)).test(rue.basename(e));
  Vi.isMatch = (e, t, r) => Vi(t, r)(e);
  Vi.parse = (e, t) => Array.isArray(e) ? e.map((r) => Vi.parse(r, t)) : oT(e, { ...t, fastpaths: !1 });
  Vi.scan = (e, t) => iue(e, t);
  Vi.compileRe = (e, t, r = !1, i = !1) => {
    if (r === !0)
      return e.output;
    let n = t || {}, a = n.contains ? "" : "^", o = n.contains ? "" : "$", u = `${a}(?:${e.output})${o}`;
    e && e.negated === !0 && (u = `^(?!${u}).*$`);
    let l = Vi.toRegex(u, t);
    return i === !0 && (l.state = e), l;
  };
  Vi.makeRe = (e, t = {}, r = !1, i = !1) => {
    if (!e || typeof e != "string")
      throw new TypeError("Expected a non-empty string");
    let n = { negated: !1, fastpaths: !0 };
    return t.fastpaths !== !1 && (e[0] === "." || e[0] === "*") && (n.output = oT.fastpaths(e, t)), n.output || (n = oT(e, t)), Vi.compileRe(
    n, t, r, i);
  };
  Vi.toRegex = (e, t) => {
    try {
      let r = t || {};
      return new RegExp(e, r.flags || (r.nocase ? "i" : ""));
    } catch (r) {
      if (t && t.debug === !0) throw r;
      return /$^/;
    }
  };
  Vi.constants = nue;
  pN.exports = Vi;
});

// ../node_modules/picomatch/index.js
var mN = b((dyt, dN) => {
  "use strict";
  dN.exports = hN();
});

// ../node_modules/micromatch/index.js
var SN = b((myt, vN) => {
  "use strict";
  var gN = require("util"), _N = XR(), To = mN(), lT = Ph(), yN = /* @__PURE__ */ s((e) => e === "" || e === "./", "isEmptyString"), bN = /* @__PURE__ */ s(
  (e) => {
    let t = e.indexOf("{");
    return t > -1 && e.indexOf("}", t) > -1;
  }, "hasBraces"), ti = /* @__PURE__ */ s((e, t, r) => {
    t = [].concat(t), e = [].concat(e);
    let i = /* @__PURE__ */ new Set(), n = /* @__PURE__ */ new Set(), a = /* @__PURE__ */ new Set(), o = 0, u = /* @__PURE__ */ s((p) => {
      a.add(p.output), r && r.onResult && r.onResult(p);
    }, "onResult");
    for (let p = 0; p < t.length; p++) {
      let h = To(String(t[p]), { ...r, onResult: u }, !0), y = h.state.negated || h.state.negatedExtglob;
      y && o++;
      for (let _ of e) {
        let g = h(_, !0);
        (y ? !g.isMatch : g.isMatch) && (y ? i.add(g.output) : (i.delete(g.output), n.add(g.output)));
      }
    }
    let c = (o === t.length ? [...a] : [...n]).filter((p) => !i.has(p));
    if (r && c.length === 0) {
      if (r.failglob === !0)
        throw new Error(`No matches found for "${t.join(", ")}"`);
      if (r.nonull === !0 || r.nullglob === !0)
        return r.unescape ? t.map((p) => p.replace(/\\/g, "")) : t;
    }
    return c;
  }, "micromatch");
  ti.match = ti;
  ti.matcher = (e, t) => To(e, t);
  ti.isMatch = (e, t, r) => To(t, r)(e);
  ti.any = ti.isMatch;
  ti.not = (e, t, r = {}) => {
    t = [].concat(t).map(String);
    let i = /* @__PURE__ */ new Set(), n = [], a = /* @__PURE__ */ s((u) => {
      r.onResult && r.onResult(u), n.push(u.output);
    }, "onResult"), o = new Set(ti(e, t, { ...r, onResult: a }));
    for (let u of n)
      o.has(u) || i.add(u);
    return [...i];
  };
  ti.contains = (e, t, r) => {
    if (typeof e != "string")
      throw new TypeError(`Expected a string: "${gN.inspect(e)}"`);
    if (Array.isArray(t))
      return t.some((i) => ti.contains(e, i, r));
    if (typeof t == "string") {
      if (yN(e) || yN(t))
        return !1;
      if (e.includes(t) || e.startsWith("./") && e.slice(2).includes(t))
        return !0;
    }
    return ti.isMatch(e, t, { ...r, contains: !0 });
  };
  ti.matchKeys = (e, t, r) => {
    if (!lT.isObject(e))
      throw new TypeError("Expected the first argument to be an object");
    let i = ti(Object.keys(e), t, r), n = {};
    for (let a of i) n[a] = e[a];
    return n;
  };
  ti.some = (e, t, r) => {
    let i = [].concat(e);
    for (let n of [].concat(t)) {
      let a = To(String(n), r);
      if (i.some((o) => a(o)))
        return !0;
    }
    return !1;
  };
  ti.every = (e, t, r) => {
    let i = [].concat(e);
    for (let n of [].concat(t)) {
      let a = To(String(n), r);
      if (!i.every((o) => a(o)))
        return !1;
    }
    return !0;
  };
  ti.all = (e, t, r) => {
    if (typeof e != "string")
      throw new TypeError(`Expected a string: "${gN.inspect(e)}"`);
    return [].concat(t).every((i) => To(i, r)(e));
  };
  ti.capture = (e, t, r) => {
    let i = lT.isWindows(r), a = To.makeRe(String(e), { ...r, capture: !0 }).exec(i ? lT.toPosixSlashes(t) : t);
    if (a)
      return a.slice(1).map((o) => o === void 0 ? "" : o);
  };
  ti.makeRe = (...e) => To.makeRe(...e);
  ti.scan = (...e) => To.scan(...e);
  ti.parse = (e, t) => {
    let r = [];
    for (let i of [].concat(e || []))
      for (let n of _N(String(i), t))
        r.push(To.parse(n, t));
    return r;
  };
  ti.braces = (e, t) => {
    if (typeof e != "string") throw new TypeError("Expected a string");
    return t && t.nobrace === !0 || !bN(e) ? [e] : _N(e, t);
  };
  ti.braceExpand = (e, t) => {
    if (typeof e != "string") throw new TypeError("Expected a string");
    return ti.braces(e, { ...t, expand: !0 });
  };
  ti.hasBraces = bN;
  vN.exports = ti;
});

// ../node_modules/fast-glob/out/utils/pattern.js
var kN = b((Et) => {
  "use strict";
  Object.defineProperty(Et, "__esModule", { value: !0 });
  Et.isAbsolute = Et.partitionAbsoluteAndRelative = Et.removeDuplicateSlashes = Et.matchAny = Et.convertPatternsToRe = Et.makeRe = Et.getPatternParts =
  Et.expandBraceExpansion = Et.expandPatternsWithBraceExpansion = Et.isAffectDepthOfReadingPattern = Et.endsWithSlashGlobStar = Et.hasGlobStar =
  Et.getBaseDirectory = Et.isPatternRelatedToParentDirectory = Et.getPatternsOutsideCurrentDirectory = Et.getPatternsInsideCurrentDirectory =
  Et.getPositivePatterns = Et.getNegativePatterns = Et.isPositivePattern = Et.isNegativePattern = Et.convertToNegativePattern = Et.convertToPositivePattern =
  Et.isDynamicPattern = Et.isStaticPattern = void 0;
  var TN = require("path"), aue = hR(), cT = SN(), EN = "**", oue = "\\", uue = /[*?]|^!/, lue = /\[[^[]*]/, cue = /(?:^|[^!*+?@])\([^(]*\|[^|]*\)/,
  fue = /[!*+?@]\([^(]*\)/, pue = /,|\.\./, hue = /(?!^)\/{2,}/g;
  function AN(e, t = {}) {
    return !xN(e, t);
  }
  s(AN, "isStaticPattern");
  Et.isStaticPattern = AN;
  function xN(e, t = {}) {
    return e === "" ? !1 : !!(t.caseSensitiveMatch === !1 || e.includes(oue) || uue.test(e) || lue.test(e) || cue.test(e) || t.extglob !== !1 &&
    fue.test(e) || t.braceExpansion !== !1 && due(e));
  }
  s(xN, "isDynamicPattern");
  Et.isDynamicPattern = xN;
  function due(e) {
    let t = e.indexOf("{");
    if (t === -1)
      return !1;
    let r = e.indexOf("}", t + 1);
    if (r === -1)
      return !1;
    let i = e.slice(t, r);
    return pue.test(i);
  }
  s(due, "hasBraceExpansion");
  function mue(e) {
    return By(e) ? e.slice(1) : e;
  }
  s(mue, "convertToPositivePattern");
  Et.convertToPositivePattern = mue;
  function yue(e) {
    return "!" + e;
  }
  s(yue, "convertToNegativePattern");
  Et.convertToNegativePattern = yue;
  function By(e) {
    return e.startsWith("!") && e[1] !== "(";
  }
  s(By, "isNegativePattern");
  Et.isNegativePattern = By;
  function CN(e) {
    return !By(e);
  }
  s(CN, "isPositivePattern");
  Et.isPositivePattern = CN;
  function gue(e) {
    return e.filter(By);
  }
  s(gue, "getNegativePatterns");
  Et.getNegativePatterns = gue;
  function _ue(e) {
    return e.filter(CN);
  }
  s(_ue, "getPositivePatterns");
  Et.getPositivePatterns = _ue;
  function bue(e) {
    return e.filter((t) => !fT(t));
  }
  s(bue, "getPatternsInsideCurrentDirectory");
  Et.getPatternsInsideCurrentDirectory = bue;
  function vue(e) {
    return e.filter(fT);
  }
  s(vue, "getPatternsOutsideCurrentDirectory");
  Et.getPatternsOutsideCurrentDirectory = vue;
  function fT(e) {
    return e.startsWith("..") || e.startsWith("./..");
  }
  s(fT, "isPatternRelatedToParentDirectory");
  Et.isPatternRelatedToParentDirectory = fT;
  function Sue(e) {
    return aue(e, { flipBackslashes: !1 });
  }
  s(Sue, "getBaseDirectory");
  Et.getBaseDirectory = Sue;
  function Tue(e) {
    return e.includes(EN);
  }
  s(Tue, "hasGlobStar");
  Et.hasGlobStar = Tue;
  function PN(e) {
    return e.endsWith("/" + EN);
  }
  s(PN, "endsWithSlashGlobStar");
  Et.endsWithSlashGlobStar = PN;
  function Eue(e) {
    let t = TN.basename(e);
    return PN(e) || AN(t);
  }
  s(Eue, "isAffectDepthOfReadingPattern");
  Et.isAffectDepthOfReadingPattern = Eue;
  function Aue(e) {
    return e.reduce((t, r) => t.concat(DN(r)), []);
  }
  s(Aue, "expandPatternsWithBraceExpansion");
  Et.expandPatternsWithBraceExpansion = Aue;
  function DN(e) {
    let t = cT.braces(e, { expand: !0, nodupes: !0, keepEscaping: !0 });
    return t.sort((r, i) => r.length - i.length), t.filter((r) => r !== "");
  }
  s(DN, "expandBraceExpansion");
  Et.expandBraceExpansion = DN;
  function xue(e, t) {
    let { parts: r } = cT.scan(e, Object.assign(Object.assign({}, t), { parts: !0 }));
    return r.length === 0 && (r = [e]), r[0].startsWith("/") && (r[0] = r[0].slice(1), r.unshift("")), r;
  }
  s(xue, "getPatternParts");
  Et.getPatternParts = xue;
  function wN(e, t) {
    return cT.makeRe(e, t);
  }
  s(wN, "makeRe");
  Et.makeRe = wN;
  function Cue(e, t) {
    return e.map((r) => wN(r, t));
  }
  s(Cue, "convertPatternsToRe");
  Et.convertPatternsToRe = Cue;
  function Pue(e, t) {
    return t.some((r) => r.test(e));
  }
  s(Pue, "matchAny");
  Et.matchAny = Pue;
  function Due(e) {
    return e.replace(hue, "/");
  }
  s(Due, "removeDuplicateSlashes");
  Et.removeDuplicateSlashes = Due;
  function wue(e) {
    let t = [], r = [];
    for (let i of e)
      ON(i) ? t.push(i) : r.push(i);
    return [t, r];
  }
  s(wue, "partitionAbsoluteAndRelative");
  Et.partitionAbsoluteAndRelative = wue;
  function ON(e) {
    return TN.isAbsolute(e);
  }
  s(ON, "isAbsolute");
  Et.isAbsolute = ON;
});

// ../node_modules/merge2/index.js
var LN = b((byt, NN) => {
  "use strict";
  var Oue = require("stream"), IN = Oue.PassThrough, kue = Array.prototype.slice;
  NN.exports = Iue;
  function Iue() {
    let e = [], t = kue.call(arguments), r = !1, i = t[t.length - 1];
    i && !Array.isArray(i) && i.pipe == null ? t.pop() : i = {};
    let n = i.end !== !1, a = i.pipeError === !0;
    i.objectMode == null && (i.objectMode = !0), i.highWaterMark == null && (i.highWaterMark = 64 * 1024);
    let o = IN(i);
    function u() {
      for (let p = 0, h = arguments.length; p < h; p++)
        e.push(RN(arguments[p], i));
      return l(), this;
    }
    s(u, "addStream");
    function l() {
      if (r)
        return;
      r = !0;
      let p = e.shift();
      if (!p) {
        process.nextTick(c);
        return;
      }
      Array.isArray(p) || (p = [p]);
      let h = p.length + 1;
      function y() {
        --h > 0 || (r = !1, l());
      }
      s(y, "next");
      function _(g) {
        function m() {
          g.removeListener("merge2UnpipeEnd", m), g.removeListener("end", m), a && g.removeListener("error", f), y();
        }
        s(m, "onend");
        function f(d) {
          o.emit("error", d);
        }
        if (s(f, "onerror"), g._readableState.endEmitted)
          return y();
        g.on("merge2UnpipeEnd", m), g.on("end", m), a && g.on("error", f), g.pipe(o, { end: !1 }), g.resume();
      }
      s(_, "pipe");
      for (let g = 0; g < p.length; g++)
        _(p[g]);
      y();
    }
    s(l, "mergeStream");
    function c() {
      r = !1, o.emit("queueDrain"), n && o.end();
    }
    return s(c, "endStream"), o.setMaxListeners(0), o.add = u, o.on("unpipe", function(p) {
      p.emit("merge2UnpipeEnd");
    }), t.length && u.apply(null, t), o;
  }
  s(Iue, "merge2");
  function RN(e, t) {
    if (Array.isArray(e))
      for (let r = 0, i = e.length; r < i; r++)
        e[r] = RN(e[r], t);
    else {
      if (!e._readableState && e.pipe && (e = e.pipe(IN(t))), !e._readableState || !e.pause || !e.pipe)
        throw new Error("Only readable stream can be merged.");
      e.pause();
    }
    return e;
  }
  s(RN, "pauseStreams");
});

// ../node_modules/fast-glob/out/utils/stream.js
var MN = b((qy) => {
  "use strict";
  Object.defineProperty(qy, "__esModule", { value: !0 });
  qy.merge = void 0;
  var Rue = LN();
  function Nue(e) {
    let t = Rue(e);
    return e.forEach((r) => {
      r.once("error", (i) => t.emit("error", i));
    }), t.once("close", () => FN(e)), t.once("end", () => FN(e)), t;
  }
  s(Nue, "merge");
  qy.merge = Nue;
  function FN(e) {
    e.forEach((t) => t.emit("close"));
  }
  s(FN, "propagateCloseEventToSources");
});

// ../node_modules/fast-glob/out/utils/string.js
var BN = b((Df) => {
  "use strict";
  Object.defineProperty(Df, "__esModule", { value: !0 });
  Df.isEmpty = Df.isString = void 0;
  function Lue(e) {
    return typeof e == "string";
  }
  s(Lue, "isString");
  Df.isString = Lue;
  function Fue(e) {
    return e === "";
  }
  s(Fue, "isEmpty");
  Df.isEmpty = Fue;
});

// ../node_modules/fast-glob/out/utils/index.js
var su = b((zn) => {
  "use strict";
  Object.defineProperty(zn, "__esModule", { value: !0 });
  zn.string = zn.stream = zn.pattern = zn.path = zn.fs = zn.errno = zn.array = void 0;
  var Mue = eR();
  zn.array = Mue;
  var Bue = tR();
  zn.errno = Bue;
  var que = rR();
  zn.fs = que;
  var Uue = aR();
  zn.path = Uue;
  var jue = kN();
  zn.pattern = jue;
  var Vue = MN();
  zn.stream = Vue;
  var Kue = BN();
  zn.string = Kue;
});

// ../node_modules/fast-glob/out/managers/tasks.js
var VN = b((Gn) => {
  "use strict";
  Object.defineProperty(Gn, "__esModule", { value: !0 });
  Gn.convertPatternGroupToTask = Gn.convertPatternGroupsToTasks = Gn.groupPatternsByBaseDirectory = Gn.getNegativePatternsAsPositive = Gn.getPositivePatterns =
  Gn.convertPatternsToTasks = Gn.generate = void 0;
  var Ua = su();
  function Hue(e, t) {
    let r = qN(e, t), i = qN(t.ignore, t), n = UN(r), a = jN(r, i), o = n.filter((p) => Ua.pattern.isStaticPattern(p, t)), u = n.filter((p) => Ua.
    pattern.isDynamicPattern(p, t)), l = pT(
      o,
      a,
      /* dynamic */
      !1
    ), c = pT(
      u,
      a,
      /* dynamic */
      !0
    );
    return l.concat(c);
  }
  s(Hue, "generate");
  Gn.generate = Hue;
  function qN(e, t) {
    let r = e;
    return t.braceExpansion && (r = Ua.pattern.expandPatternsWithBraceExpansion(r)), t.baseNameMatch && (r = r.map((i) => i.includes("/") ? i :
    `**/${i}`)), r.map((i) => Ua.pattern.removeDuplicateSlashes(i));
  }
  s(qN, "processPatterns");
  function pT(e, t, r) {
    let i = [], n = Ua.pattern.getPatternsOutsideCurrentDirectory(e), a = Ua.pattern.getPatternsInsideCurrentDirectory(e), o = hT(n), u = hT(
    a);
    return i.push(...dT(o, t, r)), "." in u ? i.push(mT(".", a, t, r)) : i.push(...dT(u, t, r)), i;
  }
  s(pT, "convertPatternsToTasks");
  Gn.convertPatternsToTasks = pT;
  function UN(e) {
    return Ua.pattern.getPositivePatterns(e);
  }
  s(UN, "getPositivePatterns");
  Gn.getPositivePatterns = UN;
  function jN(e, t) {
    return Ua.pattern.getNegativePatterns(e).concat(t).map(Ua.pattern.convertToPositivePattern);
  }
  s(jN, "getNegativePatternsAsPositive");
  Gn.getNegativePatternsAsPositive = jN;
  function hT(e) {
    let t = {};
    return e.reduce((r, i) => {
      let n = Ua.pattern.getBaseDirectory(i);
      return n in r ? r[n].push(i) : r[n] = [i], r;
    }, t);
  }
  s(hT, "groupPatternsByBaseDirectory");
  Gn.groupPatternsByBaseDirectory = hT;
  function dT(e, t, r) {
    return Object.keys(e).map((i) => mT(i, e[i], t, r));
  }
  s(dT, "convertPatternGroupsToTasks");
  Gn.convertPatternGroupsToTasks = dT;
  function mT(e, t, r, i) {
    return {
      dynamic: i,
      positive: t,
      negative: r,
      base: e,
      patterns: [].concat(t, r.map(Ua.pattern.convertToNegativePattern))
    };
  }
  s(mT, "convertPatternGroupToTask");
  Gn.convertPatternGroupToTask = mT;
});

// ../node_modules/@nodelib/fs.stat/out/providers/async.js
var HN = b((Uy) => {
  "use strict";
  Object.defineProperty(Uy, "__esModule", { value: !0 });
  Uy.read = void 0;
  function zue(e, t, r) {
    t.fs.lstat(e, (i, n) => {
      if (i !== null) {
        KN(r, i);
        return;
      }
      if (!n.isSymbolicLink() || !t.followSymbolicLink) {
        yT(r, n);
        return;
      }
      t.fs.stat(e, (a, o) => {
        if (a !== null) {
          if (t.throwErrorOnBrokenSymbolicLink) {
            KN(r, a);
            return;
          }
          yT(r, n);
          return;
        }
        t.markSymbolicLink && (o.isSymbolicLink = () => !0), yT(r, o);
      });
    });
  }
  s(zue, "read");
  Uy.read = zue;
  function KN(e, t) {
    e(t);
  }
  s(KN, "callFailureCallback");
  function yT(e, t) {
    e(null, t);
  }
  s(yT, "callSuccessCallback");
});

// ../node_modules/@nodelib/fs.stat/out/providers/sync.js
var zN = b((jy) => {
  "use strict";
  Object.defineProperty(jy, "__esModule", { value: !0 });
  jy.read = void 0;
  function Gue(e, t) {
    let r = t.fs.lstatSync(e);
    if (!r.isSymbolicLink() || !t.followSymbolicLink)
      return r;
    try {
      let i = t.fs.statSync(e);
      return t.markSymbolicLink && (i.isSymbolicLink = () => !0), i;
    } catch (i) {
      if (!t.throwErrorOnBrokenSymbolicLink)
        return r;
      throw i;
    }
  }
  s(Gue, "read");
  jy.read = Gue;
});

// ../node_modules/@nodelib/fs.stat/out/adapters/fs.js
var GN = b((Wu) => {
  "use strict";
  Object.defineProperty(Wu, "__esModule", { value: !0 });
  Wu.createFileSystemAdapter = Wu.FILE_SYSTEM_ADAPTER = void 0;
  var Vy = require("fs");
  Wu.FILE_SYSTEM_ADAPTER = {
    lstat: Vy.lstat,
    stat: Vy.stat,
    lstatSync: Vy.lstatSync,
    statSync: Vy.statSync
  };
  function Wue(e) {
    return e === void 0 ? Wu.FILE_SYSTEM_ADAPTER : Object.assign(Object.assign({}, Wu.FILE_SYSTEM_ADAPTER), e);
  }
  s(Wue, "createFileSystemAdapter");
  Wu.createFileSystemAdapter = Wue;
});

// ../node_modules/@nodelib/fs.stat/out/settings.js
var WN = b((_T) => {
  "use strict";
  Object.defineProperty(_T, "__esModule", { value: !0 });
  var $ue = GN(), gT = class {
    static {
      s(this, "Settings");
    }
    constructor(t = {}) {
      this._options = t, this.followSymbolicLink = this._getValue(this._options.followSymbolicLink, !0), this.fs = $ue.createFileSystemAdapter(
      this._options.fs), this.markSymbolicLink = this._getValue(this._options.markSymbolicLink, !1), this.throwErrorOnBrokenSymbolicLink = this.
      _getValue(this._options.throwErrorOnBrokenSymbolicLink, !0);
    }
    _getValue(t, r) {
      return t ?? r;
    }
  };
  _T.default = gT;
});

// ../node_modules/@nodelib/fs.stat/out/index.js
var rc = b(($u) => {
  "use strict";
  Object.defineProperty($u, "__esModule", { value: !0 });
  $u.statSync = $u.stat = $u.Settings = void 0;
  var $N = HN(), Xue = zN(), bT = WN();
  $u.Settings = bT.default;
  function Yue(e, t, r) {
    if (typeof t == "function") {
      $N.read(e, vT(), t);
      return;
    }
    $N.read(e, vT(t), r);
  }
  s(Yue, "stat");
  $u.stat = Yue;
  function Jue(e, t) {
    let r = vT(t);
    return Xue.read(e, r);
  }
  s(Jue, "statSync");
  $u.statSync = Jue;
  function vT(e = {}) {
    return e instanceof bT.default ? e : new bT.default(e);
  }
  s(vT, "getSettings");
});

// ../node_modules/queue-microtask/index.js
var JN = b((Byt, YN) => {
  var XN;
  YN.exports = typeof queueMicrotask == "function" ? queueMicrotask.bind(typeof window < "u" ? window : global) : (e) => (XN || (XN = Promise.
  resolve())).then(e).catch((t) => setTimeout(() => {
    throw t;
  }, 0));
});

// ../node_modules/run-parallel/index.js
var ZN = b((qyt, QN) => {
  QN.exports = Zue;
  var Que = JN();
  function Zue(e, t) {
    let r, i, n, a = !0;
    Array.isArray(e) ? (r = [], i = e.length) : (n = Object.keys(e), r = {}, i = n.length);
    function o(l) {
      function c() {
        t && t(l, r), t = null;
      }
      s(c, "end"), a ? Que(c) : c();
    }
    s(o, "done");
    function u(l, c, p) {
      r[l] = p, (--i === 0 || c) && o(c);
    }
    s(u, "each"), i ? n ? n.forEach(function(l) {
      e[l](function(c, p) {
        u(l, c, p);
      });
    }) : e.forEach(function(l, c) {
      l(function(p, h) {
        u(c, p, h);
      });
    }) : o(null), a = !1;
  }
  s(Zue, "runParallel");
});

// ../node_modules/@nodelib/fs.scandir/out/constants.js
var ST = b((Hy) => {
  "use strict";
  Object.defineProperty(Hy, "__esModule", { value: !0 });
  Hy.IS_SUPPORT_READDIR_WITH_FILE_TYPES = void 0;
  var Ky = process.versions.node.split(".");
  if (Ky[0] === void 0 || Ky[1] === void 0)
    throw new Error(`Unexpected behavior. The 'process.versions.node' variable has invalid value: ${process.versions.node}`);
  var eL = Number.parseInt(Ky[0], 10), ele = Number.parseInt(Ky[1], 10), tL = 10, tle = 10, rle = eL > tL, ile = eL === tL && ele >= tle;
  Hy.IS_SUPPORT_READDIR_WITH_FILE_TYPES = rle || ile;
});

// ../node_modules/@nodelib/fs.scandir/out/utils/fs.js
var rL = b((zy) => {
  "use strict";
  Object.defineProperty(zy, "__esModule", { value: !0 });
  zy.createDirentFromStats = void 0;
  var TT = class {
    static {
      s(this, "DirentFromStats");
    }
    constructor(t, r) {
      this.name = t, this.isBlockDevice = r.isBlockDevice.bind(r), this.isCharacterDevice = r.isCharacterDevice.bind(r), this.isDirectory = r.
      isDirectory.bind(r), this.isFIFO = r.isFIFO.bind(r), this.isFile = r.isFile.bind(r), this.isSocket = r.isSocket.bind(r), this.isSymbolicLink =
      r.isSymbolicLink.bind(r);
    }
  };
  function nle(e, t) {
    return new TT(e, t);
  }
  s(nle, "createDirentFromStats");
  zy.createDirentFromStats = nle;
});

// ../node_modules/@nodelib/fs.scandir/out/utils/index.js
var ET = b((Gy) => {
  "use strict";
  Object.defineProperty(Gy, "__esModule", { value: !0 });
  Gy.fs = void 0;
  var sle = rL();
  Gy.fs = sle;
});

// ../node_modules/@nodelib/fs.scandir/out/providers/common.js
var AT = b((Wy) => {
  "use strict";
  Object.defineProperty(Wy, "__esModule", { value: !0 });
  Wy.joinPathSegments = void 0;
  function ale(e, t, r) {
    return e.endsWith(r) ? e + t : e + r + t;
  }
  s(ale, "joinPathSegments");
  Wy.joinPathSegments = ale;
});

// ../node_modules/@nodelib/fs.scandir/out/providers/async.js
var uL = b((Xu) => {
  "use strict";
  Object.defineProperty(Xu, "__esModule", { value: !0 });
  Xu.readdir = Xu.readdirWithFileTypes = Xu.read = void 0;
  var ole = rc(), iL = ZN(), ule = ST(), nL = ET(), sL = AT();
  function lle(e, t, r) {
    if (!t.stats && ule.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
      aL(e, t, r);
      return;
    }
    oL(e, t, r);
  }
  s(lle, "read");
  Xu.read = lle;
  function aL(e, t, r) {
    t.fs.readdir(e, { withFileTypes: !0 }, (i, n) => {
      if (i !== null) {
        $y(r, i);
        return;
      }
      let a = n.map((u) => ({
        dirent: u,
        name: u.name,
        path: sL.joinPathSegments(e, u.name, t.pathSegmentSeparator)
      }));
      if (!t.followSymbolicLinks) {
        xT(r, a);
        return;
      }
      let o = a.map((u) => cle(u, t));
      iL(o, (u, l) => {
        if (u !== null) {
          $y(r, u);
          return;
        }
        xT(r, l);
      });
    });
  }
  s(aL, "readdirWithFileTypes");
  Xu.readdirWithFileTypes = aL;
  function cle(e, t) {
    return (r) => {
      if (!e.dirent.isSymbolicLink()) {
        r(null, e);
        return;
      }
      t.fs.stat(e.path, (i, n) => {
        if (i !== null) {
          if (t.throwErrorOnBrokenSymbolicLink) {
            r(i);
            return;
          }
          r(null, e);
          return;
        }
        e.dirent = nL.fs.createDirentFromStats(e.name, n), r(null, e);
      });
    };
  }
  s(cle, "makeRplTaskEntry");
  function oL(e, t, r) {
    t.fs.readdir(e, (i, n) => {
      if (i !== null) {
        $y(r, i);
        return;
      }
      let a = n.map((o) => {
        let u = sL.joinPathSegments(e, o, t.pathSegmentSeparator);
        return (l) => {
          ole.stat(u, t.fsStatSettings, (c, p) => {
            if (c !== null) {
              l(c);
              return;
            }
            let h = {
              name: o,
              path: u,
              dirent: nL.fs.createDirentFromStats(o, p)
            };
            t.stats && (h.stats = p), l(null, h);
          });
        };
      });
      iL(a, (o, u) => {
        if (o !== null) {
          $y(r, o);
          return;
        }
        xT(r, u);
      });
    });
  }
  s(oL, "readdir");
  Xu.readdir = oL;
  function $y(e, t) {
    e(t);
  }
  s($y, "callFailureCallback");
  function xT(e, t) {
    e(null, t);
  }
  s(xT, "callSuccessCallback");
});

// ../node_modules/@nodelib/fs.scandir/out/providers/sync.js
var hL = b((Yu) => {
  "use strict";
  Object.defineProperty(Yu, "__esModule", { value: !0 });
  Yu.readdir = Yu.readdirWithFileTypes = Yu.read = void 0;
  var fle = rc(), ple = ST(), lL = ET(), cL = AT();
  function hle(e, t) {
    return !t.stats && ple.IS_SUPPORT_READDIR_WITH_FILE_TYPES ? fL(e, t) : pL(e, t);
  }
  s(hle, "read");
  Yu.read = hle;
  function fL(e, t) {
    return t.fs.readdirSync(e, { withFileTypes: !0 }).map((i) => {
      let n = {
        dirent: i,
        name: i.name,
        path: cL.joinPathSegments(e, i.name, t.pathSegmentSeparator)
      };
      if (n.dirent.isSymbolicLink() && t.followSymbolicLinks)
        try {
          let a = t.fs.statSync(n.path);
          n.dirent = lL.fs.createDirentFromStats(n.name, a);
        } catch (a) {
          if (t.throwErrorOnBrokenSymbolicLink)
            throw a;
        }
      return n;
    });
  }
  s(fL, "readdirWithFileTypes");
  Yu.readdirWithFileTypes = fL;
  function pL(e, t) {
    return t.fs.readdirSync(e).map((i) => {
      let n = cL.joinPathSegments(e, i, t.pathSegmentSeparator), a = fle.statSync(n, t.fsStatSettings), o = {
        name: i,
        path: n,
        dirent: lL.fs.createDirentFromStats(i, a)
      };
      return t.stats && (o.stats = a), o;
    });
  }
  s(pL, "readdir");
  Yu.readdir = pL;
});

// ../node_modules/@nodelib/fs.scandir/out/adapters/fs.js
var dL = b((Ju) => {
  "use strict";
  Object.defineProperty(Ju, "__esModule", { value: !0 });
  Ju.createFileSystemAdapter = Ju.FILE_SYSTEM_ADAPTER = void 0;
  var wf = require("fs");
  Ju.FILE_SYSTEM_ADAPTER = {
    lstat: wf.lstat,
    stat: wf.stat,
    lstatSync: wf.lstatSync,
    statSync: wf.statSync,
    readdir: wf.readdir,
    readdirSync: wf.readdirSync
  };
  function dle(e) {
    return e === void 0 ? Ju.FILE_SYSTEM_ADAPTER : Object.assign(Object.assign({}, Ju.FILE_SYSTEM_ADAPTER), e);
  }
  s(dle, "createFileSystemAdapter");
  Ju.createFileSystemAdapter = dle;
});

// ../node_modules/@nodelib/fs.scandir/out/settings.js
var mL = b((PT) => {
  "use strict";
  Object.defineProperty(PT, "__esModule", { value: !0 });
  var mle = require("path"), yle = rc(), gle = dL(), CT = class {
    static {
      s(this, "Settings");
    }
    constructor(t = {}) {
      this._options = t, this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, !1), this.fs = gle.createFileSystemAdapter(
      this._options.fs), this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, mle.sep), this.stats = this._getValue(
      this._options.stats, !1), this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, !0), this.
      fsStatSettings = new yle.Settings({
        followSymbolicLink: this.followSymbolicLinks,
        fs: this.fs,
        throwErrorOnBrokenSymbolicLink: this.throwErrorOnBrokenSymbolicLink
      });
    }
    _getValue(t, r) {
      return t ?? r;
    }
  };
  PT.default = CT;
});

// ../node_modules/@nodelib/fs.scandir/out/index.js
var Xy = b((Qu) => {
  "use strict";
  Object.defineProperty(Qu, "__esModule", { value: !0 });
  Qu.Settings = Qu.scandirSync = Qu.scandir = void 0;
  var yL = uL(), _le = hL(), DT = mL();
  Qu.Settings = DT.default;
  function ble(e, t, r) {
    if (typeof t == "function") {
      yL.read(e, wT(), t);
      return;
    }
    yL.read(e, wT(t), r);
  }
  s(ble, "scandir");
  Qu.scandir = ble;
  function vle(e, t) {
    let r = wT(t);
    return _le.read(e, r);
  }
  s(vle, "scandirSync");
  Qu.scandirSync = vle;
  function wT(e = {}) {
    return e instanceof DT.default ? e : new DT.default(e);
  }
  s(wT, "getSettings");
});

// ../node_modules/reusify/reusify.js
var _L = b((igt, gL) => {
  "use strict";
  function Sle(e) {
    var t = new e(), r = t;
    function i() {
      var a = t;
      return a.next ? t = a.next : (t = new e(), r = t), a.next = null, a;
    }
    s(i, "get");
    function n(a) {
      r.next = a, r = a;
    }
    return s(n, "release"), {
      get: i,
      release: n
    };
  }
  s(Sle, "reusify");
  gL.exports = Sle;
});

// ../node_modules/fastq/queue.js
var vL = b((sgt, OT) => {
  "use strict";
  var Tle = _L();
  function bL(e, t, r) {
    if (typeof e == "function" && (r = t, t = e, e = null), !(r >= 1))
      throw new Error("fastqueue concurrency must be equal to or greater than 1");
    var i = Tle(Ele), n = null, a = null, o = 0, u = null, l = {
      push: m,
      drain: ya,
      saturated: ya,
      pause: p,
      paused: !1,
      get concurrency() {
        return r;
      },
      set concurrency(x) {
        if (!(x >= 1))
          throw new Error("fastqueue concurrency must be equal to or greater than 1");
        if (r = x, !l.paused)
          for (; n && o < r; )
            o++, d();
      },
      running: c,
      resume: _,
      idle: g,
      length: h,
      getQueue: y,
      unshift: f,
      empty: ya,
      kill: v,
      killAndDrain: E,
      error: S
    };
    return l;
    function c() {
      return o;
    }
    function p() {
      l.paused = !0;
    }
    function h() {
      for (var x = n, C = 0; x; )
        x = x.next, C++;
      return C;
    }
    function y() {
      for (var x = n, C = []; x; )
        C.push(x.value), x = x.next;
      return C;
    }
    function _() {
      if (l.paused) {
        if (l.paused = !1, n === null) {
          o++, d();
          return;
        }
        for (; n && o < r; )
          o++, d();
      }
    }
    function g() {
      return o === 0 && l.length() === 0;
    }
    function m(x, C) {
      var z = i.get();
      z.context = e, z.release = d, z.value = x, z.callback = C || ya, z.errorHandler = u, o >= r || l.paused ? a ? (a.next = z, a = z) : (n =
      z, a = z, l.saturated()) : (o++, t.call(e, z.value, z.worked));
    }
    function f(x, C) {
      var z = i.get();
      z.context = e, z.release = d, z.value = x, z.callback = C || ya, z.errorHandler = u, o >= r || l.paused ? n ? (z.next = n, n = z) : (n =
      z, a = z, l.saturated()) : (o++, t.call(e, z.value, z.worked));
    }
    function d(x) {
      x && i.release(x);
      var C = n;
      C && o <= r ? l.paused ? o-- : (a === n && (a = null), n = C.next, C.next = null, t.call(e, C.value, C.worked), a === null && l.empty()) :
      --o === 0 && l.drain();
    }
    function v() {
      n = null, a = null, l.drain = ya;
    }
    function E() {
      n = null, a = null, l.drain(), l.drain = ya;
    }
    function S(x) {
      u = x;
    }
  }
  s(bL, "fastqueue");
  function ya() {
  }
  s(ya, "noop");
  function Ele() {
    this.value = null, this.callback = ya, this.next = null, this.release = ya, this.context = null, this.errorHandler = null;
    var e = this;
    this.worked = /* @__PURE__ */ s(function(r, i) {
      var n = e.callback, a = e.errorHandler, o = e.value;
      e.value = null, e.callback = ya, e.errorHandler && a(r, o), n.call(e.context, r, i), e.release(e);
    }, "worked");
  }
  s(Ele, "Task");
  function Ale(e, t, r) {
    typeof e == "function" && (r = t, t = e, e = null);
    function i(p, h) {
      t.call(this, p).then(function(y) {
        h(null, y);
      }, h);
    }
    s(i, "asyncWrapper");
    var n = bL(e, i, r), a = n.push, o = n.unshift;
    return n.push = u, n.unshift = l, n.drained = c, n;
    function u(p) {
      var h = new Promise(function(y, _) {
        a(p, function(g, m) {
          if (g) {
            _(g);
            return;
          }
          y(m);
        });
      });
      return h.catch(ya), h;
    }
    s(u, "push");
    function l(p) {
      var h = new Promise(function(y, _) {
        o(p, function(g, m) {
          if (g) {
            _(g);
            return;
          }
          y(m);
        });
      });
      return h.catch(ya), h;
    }
    s(l, "unshift");
    function c() {
      var p = new Promise(function(h) {
        process.nextTick(function() {
          if (n.idle())
            h();
          else {
            var y = n.drain;
            n.drain = function() {
              typeof y == "function" && y(), h(), n.drain = y;
            };
          }
        });
      });
      return p;
    }
    s(c, "drained");
  }
  s(Ale, "queueAsPromised");
  OT.exports = bL;
  OT.exports.promise = Ale;
});

// ../node_modules/@nodelib/fs.walk/out/readers/common.js
var Yy = b((Eo) => {
  "use strict";
  Object.defineProperty(Eo, "__esModule", { value: !0 });
  Eo.joinPathSegments = Eo.replacePathSegmentSeparator = Eo.isAppliedFilter = Eo.isFatalError = void 0;
  function xle(e, t) {
    return e.errorFilter === null ? !0 : !e.errorFilter(t);
  }
  s(xle, "isFatalError");
  Eo.isFatalError = xle;
  function Cle(e, t) {
    return e === null || e(t);
  }
  s(Cle, "isAppliedFilter");
  Eo.isAppliedFilter = Cle;
  function Ple(e, t) {
    return e.split(/[/\\]/).join(t);
  }
  s(Ple, "replacePathSegmentSeparator");
  Eo.replacePathSegmentSeparator = Ple;
  function Dle(e, t, r) {
    return e === "" ? t : e.endsWith(r) ? e + t : e + r + t;
  }
  s(Dle, "joinPathSegments");
  Eo.joinPathSegments = Dle;
});

// ../node_modules/@nodelib/fs.walk/out/readers/reader.js
var RT = b((IT) => {
  "use strict";
  Object.defineProperty(IT, "__esModule", { value: !0 });
  var wle = Yy(), kT = class {
    static {
      s(this, "Reader");
    }
    constructor(t, r) {
      this._root = t, this._settings = r, this._root = wle.replacePathSegmentSeparator(t, r.pathSegmentSeparator);
    }
  };
  IT.default = kT;
});

// ../node_modules/@nodelib/fs.walk/out/readers/async.js
var FT = b((LT) => {
  "use strict";
  Object.defineProperty(LT, "__esModule", { value: !0 });
  var Ole = require("events"), kle = Xy(), Ile = vL(), Jy = Yy(), Rle = RT(), NT = class extends Rle.default {
    static {
      s(this, "AsyncReader");
    }
    constructor(t, r) {
      super(t, r), this._settings = r, this._scandir = kle.scandir, this._emitter = new Ole.EventEmitter(), this._queue = Ile(this._worker.bind(
      this), this._settings.concurrency), this._isFatalError = !1, this._isDestroyed = !1, this._queue.drain = () => {
        this._isFatalError || this._emitter.emit("end");
      };
    }
    read() {
      return this._isFatalError = !1, this._isDestroyed = !1, setImmediate(() => {
        this._pushToQueue(this._root, this._settings.basePath);
      }), this._emitter;
    }
    get isDestroyed() {
      return this._isDestroyed;
    }
    destroy() {
      if (this._isDestroyed)
        throw new Error("The reader is already destroyed");
      this._isDestroyed = !0, this._queue.killAndDrain();
    }
    onEntry(t) {
      this._emitter.on("entry", t);
    }
    onError(t) {
      this._emitter.once("error", t);
    }
    onEnd(t) {
      this._emitter.once("end", t);
    }
    _pushToQueue(t, r) {
      let i = { directory: t, base: r };
      this._queue.push(i, (n) => {
        n !== null && this._handleError(n);
      });
    }
    _worker(t, r) {
      this._scandir(t.directory, this._settings.fsScandirSettings, (i, n) => {
        if (i !== null) {
          r(i, void 0);
          return;
        }
        for (let a of n)
          this._handleEntry(a, t.base);
        r(null, void 0);
      });
    }
    _handleError(t) {
      this._isDestroyed || !Jy.isFatalError(this._settings, t) || (this._isFatalError = !0, this._isDestroyed = !0, this._emitter.emit("erro\
r", t));
    }
    _handleEntry(t, r) {
      if (this._isDestroyed || this._isFatalError)
        return;
      let i = t.path;
      r !== void 0 && (t.path = Jy.joinPathSegments(r, t.name, this._settings.pathSegmentSeparator)), Jy.isAppliedFilter(this._settings.entryFilter,
      t) && this._emitEntry(t), t.dirent.isDirectory() && Jy.isAppliedFilter(this._settings.deepFilter, t) && this._pushToQueue(i, r === void 0 ?
      void 0 : t.path);
    }
    _emitEntry(t) {
      this._emitter.emit("entry", t);
    }
  };
  LT.default = NT;
});

// ../node_modules/@nodelib/fs.walk/out/providers/async.js
var SL = b((BT) => {
  "use strict";
  Object.defineProperty(BT, "__esModule", { value: !0 });
  var Nle = FT(), MT = class {
    static {
      s(this, "AsyncProvider");
    }
    constructor(t, r) {
      this._root = t, this._settings = r, this._reader = new Nle.default(this._root, this._settings), this._storage = [];
    }
    read(t) {
      this._reader.onError((r) => {
        Lle(t, r);
      }), this._reader.onEntry((r) => {
        this._storage.push(r);
      }), this._reader.onEnd(() => {
        Fle(t, this._storage);
      }), this._reader.read();
    }
  };
  BT.default = MT;
  function Lle(e, t) {
    e(t);
  }
  s(Lle, "callFailureCallback");
  function Fle(e, t) {
    e(null, t);
  }
  s(Fle, "callSuccessCallback");
});

// ../node_modules/@nodelib/fs.walk/out/providers/stream.js
var TL = b((UT) => {
  "use strict";
  Object.defineProperty(UT, "__esModule", { value: !0 });
  var Mle = require("stream"), Ble = FT(), qT = class {
    static {
      s(this, "StreamProvider");
    }
    constructor(t, r) {
      this._root = t, this._settings = r, this._reader = new Ble.default(this._root, this._settings), this._stream = new Mle.Readable({
        objectMode: !0,
        read: /* @__PURE__ */ s(() => {
        }, "read"),
        destroy: /* @__PURE__ */ s(() => {
          this._reader.isDestroyed || this._reader.destroy();
        }, "destroy")
      });
    }
    read() {
      return this._reader.onError((t) => {
        this._stream.emit("error", t);
      }), this._reader.onEntry((t) => {
        this._stream.push(t);
      }), this._reader.onEnd(() => {
        this._stream.push(null);
      }), this._reader.read(), this._stream;
    }
  };
  UT.default = qT;
});

// ../node_modules/@nodelib/fs.walk/out/readers/sync.js
var EL = b((VT) => {
  "use strict";
  Object.defineProperty(VT, "__esModule", { value: !0 });
  var qle = Xy(), Qy = Yy(), Ule = RT(), jT = class extends Ule.default {
    static {
      s(this, "SyncReader");
    }
    constructor() {
      super(...arguments), this._scandir = qle.scandirSync, this._storage = [], this._queue = /* @__PURE__ */ new Set();
    }
    read() {
      return this._pushToQueue(this._root, this._settings.basePath), this._handleQueue(), this._storage;
    }
    _pushToQueue(t, r) {
      this._queue.add({ directory: t, base: r });
    }
    _handleQueue() {
      for (let t of this._queue.values())
        this._handleDirectory(t.directory, t.base);
    }
    _handleDirectory(t, r) {
      try {
        let i = this._scandir(t, this._settings.fsScandirSettings);
        for (let n of i)
          this._handleEntry(n, r);
      } catch (i) {
        this._handleError(i);
      }
    }
    _handleError(t) {
      if (Qy.isFatalError(this._settings, t))
        throw t;
    }
    _handleEntry(t, r) {
      let i = t.path;
      r !== void 0 && (t.path = Qy.joinPathSegments(r, t.name, this._settings.pathSegmentSeparator)), Qy.isAppliedFilter(this._settings.entryFilter,
      t) && this._pushToStorage(t), t.dirent.isDirectory() && Qy.isAppliedFilter(this._settings.deepFilter, t) && this._pushToQueue(i, r ===
      void 0 ? void 0 : t.path);
    }
    _pushToStorage(t) {
      this._storage.push(t);
    }
  };
  VT.default = jT;
});

// ../node_modules/@nodelib/fs.walk/out/providers/sync.js
var AL = b((HT) => {
  "use strict";
  Object.defineProperty(HT, "__esModule", { value: !0 });
  var jle = EL(), KT = class {
    static {
      s(this, "SyncProvider");
    }
    constructor(t, r) {
      this._root = t, this._settings = r, this._reader = new jle.default(this._root, this._settings);
    }
    read() {
      return this._reader.read();
    }
  };
  HT.default = KT;
});

// ../node_modules/@nodelib/fs.walk/out/settings.js
var xL = b((GT) => {
  "use strict";
  Object.defineProperty(GT, "__esModule", { value: !0 });
  var Vle = require("path"), Kle = Xy(), zT = class {
    static {
      s(this, "Settings");
    }
    constructor(t = {}) {
      this._options = t, this.basePath = this._getValue(this._options.basePath, void 0), this.concurrency = this._getValue(this._options.concurrency,
      Number.POSITIVE_INFINITY), this.deepFilter = this._getValue(this._options.deepFilter, null), this.entryFilter = this._getValue(this._options.
      entryFilter, null), this.errorFilter = this._getValue(this._options.errorFilter, null), this.pathSegmentSeparator = this._getValue(this.
      _options.pathSegmentSeparator, Vle.sep), this.fsScandirSettings = new Kle.Settings({
        followSymbolicLinks: this._options.followSymbolicLinks,
        fs: this._options.fs,
        pathSegmentSeparator: this._options.pathSegmentSeparator,
        stats: this._options.stats,
        throwErrorOnBrokenSymbolicLink: this._options.throwErrorOnBrokenSymbolicLink
      });
    }
    _getValue(t, r) {
      return t ?? r;
    }
  };
  GT.default = zT;
});

// ../node_modules/@nodelib/fs.walk/out/index.js
var eg = b((Ao) => {
  "use strict";
  Object.defineProperty(Ao, "__esModule", { value: !0 });
  Ao.Settings = Ao.walkStream = Ao.walkSync = Ao.walk = void 0;
  var CL = SL(), Hle = TL(), zle = AL(), WT = xL();
  Ao.Settings = WT.default;
  function Gle(e, t, r) {
    if (typeof t == "function") {
      new CL.default(e, Zy()).read(t);
      return;
    }
    new CL.default(e, Zy(t)).read(r);
  }
  s(Gle, "walk");
  Ao.walk = Gle;
  function Wle(e, t) {
    let r = Zy(t);
    return new zle.default(e, r).read();
  }
  s(Wle, "walkSync");
  Ao.walkSync = Wle;
  function $le(e, t) {
    let r = Zy(t);
    return new Hle.default(e, r).read();
  }
  s($le, "walkStream");
  Ao.walkStream = $le;
  function Zy(e = {}) {
    return e instanceof WT.default ? e : new WT.default(e);
  }
  s(Zy, "getSettings");
});

// ../node_modules/fast-glob/out/readers/reader.js
var tg = b((XT) => {
  "use strict";
  Object.defineProperty(XT, "__esModule", { value: !0 });
  var Xle = require("path"), Yle = rc(), PL = su(), $T = class {
    static {
      s(this, "Reader");
    }
    constructor(t) {
      this._settings = t, this._fsStatSettings = new Yle.Settings({
        followSymbolicLink: this._settings.followSymbolicLinks,
        fs: this._settings.fs,
        throwErrorOnBrokenSymbolicLink: this._settings.followSymbolicLinks
      });
    }
    _getFullEntryPath(t) {
      return Xle.resolve(this._settings.cwd, t);
    }
    _makeEntry(t, r) {
      let i = {
        name: r,
        path: r,
        dirent: PL.fs.createDirentFromStats(r, t)
      };
      return this._settings.stats && (i.stats = t), i;
    }
    _isFatalError(t) {
      return !PL.errno.isEnoentCodeError(t) && !this._settings.suppressErrors;
    }
  };
  XT.default = $T;
});

// ../node_modules/fast-glob/out/readers/stream.js
var QT = b((JT) => {
  "use strict";
  Object.defineProperty(JT, "__esModule", { value: !0 });
  var Jle = require("stream"), Qle = rc(), Zle = eg(), ece = tg(), YT = class extends ece.default {
    static {
      s(this, "ReaderStream");
    }
    constructor() {
      super(...arguments), this._walkStream = Zle.walkStream, this._stat = Qle.stat;
    }
    dynamic(t, r) {
      return this._walkStream(t, r);
    }
    static(t, r) {
      let i = t.map(this._getFullEntryPath, this), n = new Jle.PassThrough({ objectMode: !0 });
      n._write = (a, o, u) => this._getEntry(i[a], t[a], r).then((l) => {
        l !== null && r.entryFilter(l) && n.push(l), a === i.length - 1 && n.end(), u();
      }).catch(u);
      for (let a = 0; a < i.length; a++)
        n.write(a);
      return n;
    }
    _getEntry(t, r, i) {
      return this._getStat(t).then((n) => this._makeEntry(n, r)).catch((n) => {
        if (i.errorFilter(n))
          return null;
        throw n;
      });
    }
    _getStat(t) {
      return new Promise((r, i) => {
        this._stat(t, this._fsStatSettings, (n, a) => n === null ? r(a) : i(n));
      });
    }
  };
  JT.default = YT;
});

// ../node_modules/fast-glob/out/readers/async.js
var DL = b((eE) => {
  "use strict";
  Object.defineProperty(eE, "__esModule", { value: !0 });
  var tce = eg(), rce = tg(), ice = QT(), ZT = class extends rce.default {
    static {
      s(this, "ReaderAsync");
    }
    constructor() {
      super(...arguments), this._walkAsync = tce.walk, this._readerStream = new ice.default(this._settings);
    }
    dynamic(t, r) {
      return new Promise((i, n) => {
        this._walkAsync(t, r, (a, o) => {
          a === null ? i(o) : n(a);
        });
      });
    }
    async static(t, r) {
      let i = [], n = this._readerStream.static(t, r);
      return new Promise((a, o) => {
        n.once("error", o), n.on("data", (u) => i.push(u)), n.once("end", () => a(i));
      });
    }
  };
  eE.default = ZT;
});

// ../node_modules/fast-glob/out/providers/matchers/matcher.js
var wL = b((rE) => {
  "use strict";
  Object.defineProperty(rE, "__esModule", { value: !0 });
  var wh = su(), tE = class {
    static {
      s(this, "Matcher");
    }
    constructor(t, r, i) {
      this._patterns = t, this._settings = r, this._micromatchOptions = i, this._storage = [], this._fillStorage();
    }
    _fillStorage() {
      for (let t of this._patterns) {
        let r = this._getPatternSegments(t), i = this._splitSegmentsIntoSections(r);
        this._storage.push({
          complete: i.length <= 1,
          pattern: t,
          segments: r,
          sections: i
        });
      }
    }
    _getPatternSegments(t) {
      return wh.pattern.getPatternParts(t, this._micromatchOptions).map((i) => wh.pattern.isDynamicPattern(i, this._settings) ? {
        dynamic: !0,
        pattern: i,
        patternRe: wh.pattern.makeRe(i, this._micromatchOptions)
      } : {
        dynamic: !1,
        pattern: i
      });
    }
    _splitSegmentsIntoSections(t) {
      return wh.array.splitWhen(t, (r) => r.dynamic && wh.pattern.hasGlobStar(r.pattern));
    }
  };
  rE.default = tE;
});

// ../node_modules/fast-glob/out/providers/matchers/partial.js
var OL = b((nE) => {
  "use strict";
  Object.defineProperty(nE, "__esModule", { value: !0 });
  var nce = wL(), iE = class extends nce.default {
    static {
      s(this, "PartialMatcher");
    }
    match(t) {
      let r = t.split("/"), i = r.length, n = this._storage.filter((a) => !a.complete || a.segments.length > i);
      for (let a of n) {
        let o = a.sections[0];
        if (!a.complete && i > o.length || r.every((l, c) => {
          let p = a.segments[c];
          return !!(p.dynamic && p.patternRe.test(l) || !p.dynamic && p.pattern === l);
        }))
          return !0;
      }
      return !1;
    }
  };
  nE.default = iE;
});

// ../node_modules/fast-glob/out/providers/filters/deep.js
var kL = b((aE) => {
  "use strict";
  Object.defineProperty(aE, "__esModule", { value: !0 });
  var rg = su(), sce = OL(), sE = class {
    static {
      s(this, "DeepFilter");
    }
    constructor(t, r) {
      this._settings = t, this._micromatchOptions = r;
    }
    getFilter(t, r, i) {
      let n = this._getMatcher(r), a = this._getNegativePatternsRe(i);
      return (o) => this._filter(t, o, n, a);
    }
    _getMatcher(t) {
      return new sce.default(t, this._settings, this._micromatchOptions);
    }
    _getNegativePatternsRe(t) {
      let r = t.filter(rg.pattern.isAffectDepthOfReadingPattern);
      return rg.pattern.convertPatternsToRe(r, this._micromatchOptions);
    }
    _filter(t, r, i, n) {
      if (this._isSkippedByDeep(t, r.path) || this._isSkippedSymbolicLink(r))
        return !1;
      let a = rg.path.removeLeadingDotSegment(r.path);
      return this._isSkippedByPositivePatterns(a, i) ? !1 : this._isSkippedByNegativePatterns(a, n);
    }
    _isSkippedByDeep(t, r) {
      return this._settings.deep === 1 / 0 ? !1 : this._getEntryLevel(t, r) >= this._settings.deep;
    }
    _getEntryLevel(t, r) {
      let i = r.split("/").length;
      if (t === "")
        return i;
      let n = t.split("/").length;
      return i - n;
    }
    _isSkippedSymbolicLink(t) {
      return !this._settings.followSymbolicLinks && t.dirent.isSymbolicLink();
    }
    _isSkippedByPositivePatterns(t, r) {
      return !this._settings.baseNameMatch && !r.match(t);
    }
    _isSkippedByNegativePatterns(t, r) {
      return !rg.pattern.matchAny(t, r);
    }
  };
  aE.default = sE;
});

// ../node_modules/fast-glob/out/providers/filters/entry.js
var IL = b((uE) => {
  "use strict";
  Object.defineProperty(uE, "__esModule", { value: !0 });
  var Zu = su(), oE = class {
    static {
      s(this, "EntryFilter");
    }
    constructor(t, r) {
      this._settings = t, this._micromatchOptions = r, this.index = /* @__PURE__ */ new Map();
    }
    getFilter(t, r) {
      let [i, n] = Zu.pattern.partitionAbsoluteAndRelative(r), a = {
        positive: {
          all: Zu.pattern.convertPatternsToRe(t, this._micromatchOptions)
        },
        negative: {
          absolute: Zu.pattern.convertPatternsToRe(i, Object.assign(Object.assign({}, this._micromatchOptions), { dot: !0 })),
          relative: Zu.pattern.convertPatternsToRe(n, Object.assign(Object.assign({}, this._micromatchOptions), { dot: !0 }))
        }
      };
      return (o) => this._filter(o, a);
    }
    _filter(t, r) {
      let i = Zu.path.removeLeadingDotSegment(t.path);
      if (this._settings.unique && this._isDuplicateEntry(i) || this._onlyFileFilter(t) || this._onlyDirectoryFilter(t))
        return !1;
      let n = this._isMatchToPatternsSet(i, r, t.dirent.isDirectory());
      return this._settings.unique && n && this._createIndexRecord(i), n;
    }
    _isDuplicateEntry(t) {
      return this.index.has(t);
    }
    _createIndexRecord(t) {
      this.index.set(t, void 0);
    }
    _onlyFileFilter(t) {
      return this._settings.onlyFiles && !t.dirent.isFile();
    }
    _onlyDirectoryFilter(t) {
      return this._settings.onlyDirectories && !t.dirent.isDirectory();
    }
    _isMatchToPatternsSet(t, r, i) {
      return !(!this._isMatchToPatterns(t, r.positive.all, i) || this._isMatchToPatterns(t, r.negative.relative, i) || this._isMatchToAbsoluteNegative(
      t, r.negative.absolute, i));
    }
    _isMatchToAbsoluteNegative(t, r, i) {
      if (r.length === 0)
        return !1;
      let n = Zu.path.makeAbsolute(this._settings.cwd, t);
      return this._isMatchToPatterns(n, r, i);
    }
    _isMatchToPatterns(t, r, i) {
      if (r.length === 0)
        return !1;
      let n = Zu.pattern.matchAny(t, r);
      return !n && i ? Zu.pattern.matchAny(t + "/", r) : n;
    }
  };
  uE.default = oE;
});

// ../node_modules/fast-glob/out/providers/filters/error.js
var RL = b((cE) => {
  "use strict";
  Object.defineProperty(cE, "__esModule", { value: !0 });
  var ace = su(), lE = class {
    static {
      s(this, "ErrorFilter");
    }
    constructor(t) {
      this._settings = t;
    }
    getFilter() {
      return (t) => this._isNonFatalError(t);
    }
    _isNonFatalError(t) {
      return ace.errno.isEnoentCodeError(t) || this._settings.suppressErrors;
    }
  };
  cE.default = lE;
});

// ../node_modules/fast-glob/out/providers/transformers/entry.js
var LL = b((pE) => {
  "use strict";
  Object.defineProperty(pE, "__esModule", { value: !0 });
  var NL = su(), fE = class {
    static {
      s(this, "EntryTransformer");
    }
    constructor(t) {
      this._settings = t;
    }
    getTransformer() {
      return (t) => this._transform(t);
    }
    _transform(t) {
      let r = t.path;
      return this._settings.absolute && (r = NL.path.makeAbsolute(this._settings.cwd, r), r = NL.path.unixify(r)), this._settings.markDirectories &&
      t.dirent.isDirectory() && (r += "/"), this._settings.objectMode ? Object.assign(Object.assign({}, t), { path: r }) : r;
    }
  };
  pE.default = fE;
});

// ../node_modules/fast-glob/out/providers/provider.js
var ig = b((dE) => {
  "use strict";
  Object.defineProperty(dE, "__esModule", { value: !0 });
  var oce = require("path"), uce = kL(), lce = IL(), cce = RL(), fce = LL(), hE = class {
    static {
      s(this, "Provider");
    }
    constructor(t) {
      this._settings = t, this.errorFilter = new cce.default(this._settings), this.entryFilter = new lce.default(this._settings, this._getMicromatchOptions()),
      this.deepFilter = new uce.default(this._settings, this._getMicromatchOptions()), this.entryTransformer = new fce.default(this._settings);
    }
    _getRootDirectory(t) {
      return oce.resolve(this._settings.cwd, t.base);
    }
    _getReaderOptions(t) {
      let r = t.base === "." ? "" : t.base;
      return {
        basePath: r,
        pathSegmentSeparator: "/",
        concurrency: this._settings.concurrency,
        deepFilter: this.deepFilter.getFilter(r, t.positive, t.negative),
        entryFilter: this.entryFilter.getFilter(t.positive, t.negative),
        errorFilter: this.errorFilter.getFilter(),
        followSymbolicLinks: this._settings.followSymbolicLinks,
        fs: this._settings.fs,
        stats: this._settings.stats,
        throwErrorOnBrokenSymbolicLink: this._settings.throwErrorOnBrokenSymbolicLink,
        transform: this.entryTransformer.getTransformer()
      };
    }
    _getMicromatchOptions() {
      return {
        dot: this._settings.dot,
        matchBase: this._settings.baseNameMatch,
        nobrace: !this._settings.braceExpansion,
        nocase: !this._settings.caseSensitiveMatch,
        noext: !this._settings.extglob,
        noglobstar: !this._settings.globstar,
        posix: !0,
        strictSlashes: !1
      };
    }
  };
  dE.default = hE;
});

// ../node_modules/fast-glob/out/providers/async.js
var FL = b((yE) => {
  "use strict";
  Object.defineProperty(yE, "__esModule", { value: !0 });
  var pce = DL(), hce = ig(), mE = class extends hce.default {
    static {
      s(this, "ProviderAsync");
    }
    constructor() {
      super(...arguments), this._reader = new pce.default(this._settings);
    }
    async read(t) {
      let r = this._getRootDirectory(t), i = this._getReaderOptions(t);
      return (await this.api(r, t, i)).map((a) => i.transform(a));
    }
    api(t, r, i) {
      return r.dynamic ? this._reader.dynamic(t, i) : this._reader.static(r.patterns, i);
    }
  };
  yE.default = mE;
});

// ../node_modules/fast-glob/out/providers/stream.js
var ML = b((_E) => {
  "use strict";
  Object.defineProperty(_E, "__esModule", { value: !0 });
  var dce = require("stream"), mce = QT(), yce = ig(), gE = class extends yce.default {
    static {
      s(this, "ProviderStream");
    }
    constructor() {
      super(...arguments), this._reader = new mce.default(this._settings);
    }
    read(t) {
      let r = this._getRootDirectory(t), i = this._getReaderOptions(t), n = this.api(r, t, i), a = new dce.Readable({ objectMode: !0, read: /* @__PURE__ */ s(
      () => {
      }, "read") });
      return n.once("error", (o) => a.emit("error", o)).on("data", (o) => a.emit("data", i.transform(o))).once("end", () => a.emit("end")), a.
      once("close", () => n.destroy()), a;
    }
    api(t, r, i) {
      return r.dynamic ? this._reader.dynamic(t, i) : this._reader.static(r.patterns, i);
    }
  };
  _E.default = gE;
});

// ../node_modules/fast-glob/out/readers/sync.js
var BL = b((vE) => {
  "use strict";
  Object.defineProperty(vE, "__esModule", { value: !0 });
  var gce = rc(), _ce = eg(), bce = tg(), bE = class extends bce.default {
    static {
      s(this, "ReaderSync");
    }
    constructor() {
      super(...arguments), this._walkSync = _ce.walkSync, this._statSync = gce.statSync;
    }
    dynamic(t, r) {
      return this._walkSync(t, r);
    }
    static(t, r) {
      let i = [];
      for (let n of t) {
        let a = this._getFullEntryPath(n), o = this._getEntry(a, n, r);
        o === null || !r.entryFilter(o) || i.push(o);
      }
      return i;
    }
    _getEntry(t, r, i) {
      try {
        let n = this._getStat(t);
        return this._makeEntry(n, r);
      } catch (n) {
        if (i.errorFilter(n))
          return null;
        throw n;
      }
    }
    _getStat(t) {
      return this._statSync(t, this._fsStatSettings);
    }
  };
  vE.default = bE;
});

// ../node_modules/fast-glob/out/providers/sync.js
var qL = b((TE) => {
  "use strict";
  Object.defineProperty(TE, "__esModule", { value: !0 });
  var vce = BL(), Sce = ig(), SE = class extends Sce.default {
    static {
      s(this, "ProviderSync");
    }
    constructor() {
      super(...arguments), this._reader = new vce.default(this._settings);
    }
    read(t) {
      let r = this._getRootDirectory(t), i = this._getReaderOptions(t);
      return this.api(r, t, i).map(i.transform);
    }
    api(t, r, i) {
      return r.dynamic ? this._reader.dynamic(t, i) : this._reader.static(r.patterns, i);
    }
  };
  TE.default = SE;
});

// ../node_modules/fast-glob/out/settings.js
var UL = b((kf) => {
  "use strict";
  Object.defineProperty(kf, "__esModule", { value: !0 });
  kf.DEFAULT_FILE_SYSTEM_ADAPTER = void 0;
  var Of = require("fs"), Tce = require("os"), Ece = Math.max(Tce.cpus().length, 1);
  kf.DEFAULT_FILE_SYSTEM_ADAPTER = {
    lstat: Of.lstat,
    lstatSync: Of.lstatSync,
    stat: Of.stat,
    statSync: Of.statSync,
    readdir: Of.readdir,
    readdirSync: Of.readdirSync
  };
  var EE = class {
    static {
      s(this, "Settings");
    }
    constructor(t = {}) {
      this._options = t, this.absolute = this._getValue(this._options.absolute, !1), this.baseNameMatch = this._getValue(this._options.baseNameMatch,
      !1), this.braceExpansion = this._getValue(this._options.braceExpansion, !0), this.caseSensitiveMatch = this._getValue(this._options.caseSensitiveMatch,
      !0), this.concurrency = this._getValue(this._options.concurrency, Ece), this.cwd = this._getValue(this._options.cwd, process.cwd()), this.
      deep = this._getValue(this._options.deep, 1 / 0), this.dot = this._getValue(this._options.dot, !1), this.extglob = this._getValue(this.
      _options.extglob, !0), this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, !0), this.fs = this._getFileSystemMethods(
      this._options.fs), this.globstar = this._getValue(this._options.globstar, !0), this.ignore = this._getValue(this._options.ignore, []),
      this.markDirectories = this._getValue(this._options.markDirectories, !1), this.objectMode = this._getValue(this._options.objectMode, !1),
      this.onlyDirectories = this._getValue(this._options.onlyDirectories, !1), this.onlyFiles = this._getValue(this._options.onlyFiles, !0),
      this.stats = this._getValue(this._options.stats, !1), this.suppressErrors = this._getValue(this._options.suppressErrors, !1), this.throwErrorOnBrokenSymbolicLink =
      this._getValue(this._options.throwErrorOnBrokenSymbolicLink, !1), this.unique = this._getValue(this._options.unique, !0), this.onlyDirectories &&
      (this.onlyFiles = !1), this.stats && (this.objectMode = !0), this.ignore = [].concat(this.ignore);
    }
    _getValue(t, r) {
      return t === void 0 ? r : t;
    }
    _getFileSystemMethods(t = {}) {
      return Object.assign(Object.assign({}, kf.DEFAULT_FILE_SYSTEM_ADAPTER), t);
    }
  };
  kf.default = EE;
});

// ../node_modules/fast-glob/out/index.js
var PE = b((t_t, VL) => {
  "use strict";
  var jL = VN(), Ace = FL(), xce = ML(), Cce = qL(), AE = UL(), ga = su();
  async function xE(e, t) {
    ja(e);
    let r = CE(e, Ace.default, t), i = await Promise.all(r);
    return ga.array.flatten(i);
  }
  s(xE, "FastGlob");
  (function(e) {
    e.glob = e, e.globSync = t, e.globStream = r, e.async = e;
    function t(c, p) {
      ja(c);
      let h = CE(c, Cce.default, p);
      return ga.array.flatten(h);
    }
    s(t, "sync"), e.sync = t;
    function r(c, p) {
      ja(c);
      let h = CE(c, xce.default, p);
      return ga.stream.merge(h);
    }
    s(r, "stream"), e.stream = r;
    function i(c, p) {
      ja(c);
      let h = [].concat(c), y = new AE.default(p);
      return jL.generate(h, y);
    }
    s(i, "generateTasks"), e.generateTasks = i;
    function n(c, p) {
      ja(c);
      let h = new AE.default(p);
      return ga.pattern.isDynamicPattern(c, h);
    }
    s(n, "isDynamicPattern"), e.isDynamicPattern = n;
    function a(c) {
      return ja(c), ga.path.escape(c);
    }
    s(a, "escapePath"), e.escapePath = a;
    function o(c) {
      return ja(c), ga.path.convertPathToPattern(c);
    }
    s(o, "convertPathToPattern"), e.convertPathToPattern = o;
    let u;
    (function(c) {
      function p(y) {
        return ja(y), ga.path.escapePosixPath(y);
      }
      s(p, "escapePath"), c.escapePath = p;
      function h(y) {
        return ja(y), ga.path.convertPosixPathToPattern(y);
      }
      s(h, "convertPathToPattern"), c.convertPathToPattern = h;
    })(u = e.posix || (e.posix = {}));
    let l;
    (function(c) {
      function p(y) {
        return ja(y), ga.path.escapeWindowsPath(y);
      }
      s(p, "escapePath"), c.escapePath = p;
      function h(y) {
        return ja(y), ga.path.convertWindowsPathToPattern(y);
      }
      s(h, "convertPathToPattern"), c.convertPathToPattern = h;
    })(l = e.win32 || (e.win32 = {}));
  })(xE || (xE = {}));
  function CE(e, t, r) {
    let i = [].concat(e), n = new AE.default(r), a = jL.generate(i, n), o = new t(n);
    return a.map(o.read, o);
  }
  s(CE, "getWorks");
  function ja(e) {
    if (![].concat(e).every((i) => ga.string.isString(i) && !ga.string.isEmpty(i)))
      throw new TypeError("Patterns must be a string (non empty) or an array of strings");
  }
  s(ja, "assertPatternsInput");
  VL.exports = xE;
});

// ../node_modules/globby/node_modules/path-type/index.js
async function DE(e, t, r) {
  if (typeof r != "string")
    throw new TypeError(`Expected a string, got ${typeof r}`);
  try {
    return (await HL.default[e](r))[t]();
  } catch (i) {
    if (i.code === "ENOENT")
      return !1;
    throw i;
  }
}
function wE(e, t, r) {
  if (typeof r != "string")
    throw new TypeError(`Expected a string, got ${typeof r}`);
  try {
    return KL.default[e](r)[t]();
  } catch (i) {
    if (i.code === "ENOENT")
      return !1;
    throw i;
  }
}
var KL, HL, i_t, zL, n_t, s_t, GL, a_t, WL = at(() => {
  KL = Gt(require("node:fs"), 1), HL = Gt(require("node:fs/promises"), 1);
  s(DE, "isType");
  s(wE, "isTypeSync");
  i_t = DE.bind(void 0, "stat", "isFile"), zL = DE.bind(void 0, "stat", "isDirectory"), n_t = DE.bind(void 0, "lstat", "isSymbolicLink"), s_t =
  wE.bind(void 0, "statSync", "isFile"), GL = wE.bind(void 0, "statSync", "isDirectory"), a_t = wE.bind(void 0, "lstatSync", "isSymbolicLink");
});

// ../node_modules/unicorn-magic/default.js
var $L = at(() => {
});

// ../node_modules/unicorn-magic/node.js
function Oh(e) {
  return e instanceof URL ? (0, YL.fileURLToPath)(e) : e;
}
var XL, OE, Pce, YL, f_t, p_t, kE = at(() => {
  XL = require("node:util"), OE = require("node:child_process"), Pce = Gt(require("node:path"), 1), YL = require("node:url");
  $L();
  f_t = (0, XL.promisify)(OE.execFile);
  s(Oh, "toPath");
  p_t = 10 * 1024 * 1024;
});

// ../node_modules/globby/node_modules/ignore/index.js
var nF = b((y_t, BE) => {
  function ZL(e) {
    return Array.isArray(e) ? e : [e];
  }
  s(ZL, "makeArray");
  var Dce = void 0, RE = "", JL = " ", IE = "\\", wce = /^\s+$/, Oce = /(?:[^\\]|^)\\$/, kce = /^\\!/, Ice = /^\\#/, Rce = /\r?\n/g, Nce = /^\.{0,2}\/|^\.{1,2}$/,
  Lce = /\/$/, If = "/", eF = "node-ignore";
  typeof Symbol < "u" && (eF = Symbol.for("node-ignore"));
  var tF = eF, kh = /* @__PURE__ */ s((e, t, r) => (Object.defineProperty(e, t, { value: r }), r), "define"), Fce = /([0-z])-([0-z])/g, rF = /* @__PURE__ */ s(
  () => !1, "RETURN_FALSE"), Mce = /* @__PURE__ */ s((e) => e.replace(
    Fce,
    (t, r, i) => r.charCodeAt(0) <= i.charCodeAt(0) ? t : RE
  ), "sanitizeRange"), Bce = /* @__PURE__ */ s((e) => {
    let { length: t } = e;
    return e.slice(0, t - t % 2);
  }, "cleanRangeBackSlash"), qce = [
    [
      // Remove BOM
      // TODO:
      // Other similar zero-width characters?
      /^\uFEFF/,
      () => RE
    ],
    // > Trailing spaces are ignored unless they are quoted with backslash ("\")
    [
      // (a\ ) -> (a )
      // (a  ) -> (a)
      // (a ) -> (a)
      // (a \ ) -> (a  )
      /((?:\\\\)*?)(\\?\s+)$/,
      (e, t, r) => t + (r.indexOf("\\") === 0 ? JL : RE)
    ],
    // Replace (\ ) with ' '
    // (\ ) -> ' '
    // (\\ ) -> '\\ '
    // (\\\ ) -> '\\ '
    [
      /(\\+?)\s/g,
      (e, t) => {
        let { length: r } = t;
        return t.slice(0, r - r % 2) + JL;
      }
    ],
    // Escape metacharacters
    // which is written down by users but means special for regular expressions.
    // > There are 12 characters with special meanings:
    // > - the backslash \,
    // > - the caret ^,
    // > - the dollar sign $,
    // > - the period or dot .,
    // > - the vertical bar or pipe symbol |,
    // > - the question mark ?,
    // > - the asterisk or star *,
    // > - the plus sign +,
    // > - the opening parenthesis (,
    // > - the closing parenthesis ),
    // > - and the opening square bracket [,
    // > - the opening curly brace {,
    // > These special characters are often called "metacharacters".
    [
      /[\\$.|*+(){^]/g,
      (e) => `\\${e}`
    ],
    [
      // > a question mark (?) matches a single character
      /(?!\\)\?/g,
      () => "[^/]"
    ],
    // leading slash
    [
      // > A leading slash matches the beginning of the pathname.
      // > For example, "/*.c" matches "cat-file.c" but not "mozilla-sha1/sha1.c".
      // A leading slash matches the beginning of the pathname
      /^\//,
      () => "^"
    ],
    // replace special metacharacter slash after the leading slash
    [
      /\//g,
      () => "\\/"
    ],
    [
      // > A leading "**" followed by a slash means match in all directories.
      // > For example, "**/foo" matches file or directory "foo" anywhere,
      // > the same as pattern "foo".
      // > "**/foo/bar" matches file or directory "bar" anywhere that is directly
      // >   under directory "foo".
      // Notice that the '*'s have been replaced as '\\*'
      /^\^*\\\*\\\*\\\//,
      // '**/foo' <-> 'foo'
      () => "^(?:.*\\/)?"
    ],
    // starting
    [
      // there will be no leading '/'
      //   (which has been replaced by section "leading slash")
      // If starts with '**', adding a '^' to the regular expression also works
      /^(?=[^^])/,
      /* @__PURE__ */ s(function() {
        return /\/(?!$)/.test(this) ? "^" : "(?:^|\\/)";
      }, "startingReplacer")
    ],
    // two globstars
    [
      // Use lookahead assertions so that we could match more than one `'/**'`
      /\\\/\\\*\\\*(?=\\\/|$)/g,
      // Zero, one or several directories
      // should not use '*', or it will be replaced by the next replacer
      // Check if it is not the last `'/**'`
      (e, t, r) => t + 6 < r.length ? "(?:\\/[^\\/]+)*" : "\\/.+"
    ],
    // normal intermediate wildcards
    [
      // Never replace escaped '*'
      // ignore rule '\*' will match the path '*'
      // 'abc.*/' -> go
      // 'abc.*'  -> skip this rule,
      //    coz trailing single wildcard will be handed by [trailing wildcard]
      /(^|[^\\]+)(\\\*)+(?=.+)/g,
      // '*.js' matches '.js'
      // '*.js' doesn't match 'abc'
      (e, t, r) => {
        let i = r.replace(/\\\*/g, "[^\\/]*");
        return t + i;
      }
    ],
    [
      // unescape, revert step 3 except for back slash
      // For example, if a user escape a '\\*',
      // after step 3, the result will be '\\\\\\*'
      /\\\\\\(?=[$.|*+(){^])/g,
      () => IE
    ],
    [
      // '\\\\' -> '\\'
      /\\\\/g,
      () => IE
    ],
    [
      // > The range notation, e.g. [a-zA-Z],
      // > can be used to match one of the characters in a range.
      // `\` is escaped by step 3
      /(\\)?\[([^\]/]*?)(\\*)($|\])/g,
      (e, t, r, i, n) => t === IE ? `\\[${r}${Bce(i)}${n}` : n === "]" && i.length % 2 === 0 ? `[${Mce(r)}${i}]` : "[]"
    ],
    // ending
    [
      // 'js' will not match 'js.'
      // 'ab' will not match 'abc'
      /(?:[^*])$/,
      // WTF!
      // https://git-scm.com/docs/gitignore
      // changes in [2.22.1](https://git-scm.com/docs/gitignore/2.22.1)
      // which re-fixes #24, #38
      // > If there is a separator at the end of the pattern then the pattern
      // > will only match directories, otherwise the pattern can match both
      // > files and directories.
      // 'js*' will not match 'a.js'
      // 'js/' will not match 'a.js'
      // 'js' will match 'a.js' and 'a.js/'
      (e) => /\/$/.test(e) ? `${e}$` : `${e}(?=$|\\/$)`
    ]
  ], Uce = /(^|\\\/)?\\\*$/, Ih = "regex", ng = "checkRegex", QL = "_", jce = {
    [Ih](e, t) {
      return `${t ? `${t}[^/]+` : "[^/]*"}(?=$|\\/$)`;
    },
    [ng](e, t) {
      return `${t ? `${t}[^/]*` : "[^/]*"}(?=$|\\/$)`;
    }
  }, Vce = /* @__PURE__ */ s((e) => qce.reduce(
    (t, [r, i]) => t.replace(r, i.bind(e)),
    e
  ), "makeRegexPrefix"), sg = /* @__PURE__ */ s((e) => typeof e == "string", "isString"), Kce = /* @__PURE__ */ s((e) => e && sg(e) && !wce.
  test(e) && !Oce.test(e) && e.indexOf("#") !== 0, "checkPattern"), Hce = /* @__PURE__ */ s((e) => e.split(Rce).filter(Boolean), "splitPatte\
rn"), NE = class {
    static {
      s(this, "IgnoreRule");
    }
    constructor(t, r, i, n, a, o) {
      this.pattern = t, this.mark = r, this.negative = a, kh(this, "body", i), kh(this, "ignoreCase", n), kh(this, "regexPrefix", o);
    }
    get regex() {
      let t = QL + Ih;
      return this[t] ? this[t] : this._make(Ih, t);
    }
    get checkRegex() {
      let t = QL + ng;
      return this[t] ? this[t] : this._make(ng, t);
    }
    _make(t, r) {
      let i = this.regexPrefix.replace(
        Uce,
        // It does not need to bind pattern
        jce[t]
      ), n = this.ignoreCase ? new RegExp(i, "i") : new RegExp(i);
      return kh(this, r, n);
    }
  }, zce = /* @__PURE__ */ s(({
    pattern: e,
    mark: t
  }, r) => {
    let i = !1, n = e;
    n.indexOf("!") === 0 && (i = !0, n = n.substr(1)), n = n.replace(kce, "!").replace(Ice, "#");
    let a = Vce(n);
    return new NE(
      e,
      t,
      n,
      r,
      i,
      a
    );
  }, "createRule"), LE = class {
    static {
      s(this, "RuleManager");
    }
    constructor(t) {
      this._ignoreCase = t, this._rules = [];
    }
    _add(t) {
      if (t && t[tF]) {
        this._rules = this._rules.concat(t._rules._rules), this._added = !0;
        return;
      }
      if (sg(t) && (t = {
        pattern: t
      }), Kce(t.pattern)) {
        let r = zce(t, this._ignoreCase);
        this._added = !0, this._rules.push(r);
      }
    }
    // @param {Array<string> | string | Ignore} pattern
    add(t) {
      return this._added = !1, ZL(
        sg(t) ? Hce(t) : t
      ).forEach(this._add, this), this._added;
    }
    // Test one single path without recursively checking parent directories
    //
    // - checkUnignored `boolean` whether should check if the path is unignored,
    //   setting `checkUnignored` to `false` could reduce additional
    //   path matching.
    // - check `string` either `MODE_IGNORE` or `MODE_CHECK_IGNORE`
    // @returns {TestResult} true if a file is ignored
    test(t, r, i) {
      let n = !1, a = !1, o;
      this._rules.forEach((l) => {
        let { negative: c } = l;
        a === c && n !== a || c && !n && !a && !r || !l[i].test(t) || (n = !c, a = c, o = c ? Dce : l);
      });
      let u = {
        ignored: n,
        unignored: a
      };
      return o && (u.rule = o), u;
    }
  }, Gce = /* @__PURE__ */ s((e, t) => {
    throw new t(e);
  }, "throwError"), au = /* @__PURE__ */ s((e, t, r) => sg(e) ? e ? au.isNotRelative(e) ? r(
    `path should be a \`path.relative()\`d string, but got "${t}"`,
    RangeError
  ) : !0 : r("path must not be empty", TypeError) : r(
    `path must be a string, but got \`${t}\``,
    TypeError
  ), "checkPath"), iF = /* @__PURE__ */ s((e) => Nce.test(e), "isNotRelative");
  au.isNotRelative = iF;
  au.convert = (e) => e;
  var FE = class {
    static {
      s(this, "Ignore");
    }
    constructor({
      ignorecase: t = !0,
      ignoreCase: r = t,
      allowRelativePaths: i = !1
    } = {}) {
      kh(this, tF, !0), this._rules = new LE(r), this._strictPathCheck = !i, this._initCache();
    }
    _initCache() {
      this._ignoreCache = /* @__PURE__ */ Object.create(null), this._testCache = /* @__PURE__ */ Object.create(null);
    }
    add(t) {
      return this._rules.add(t) && this._initCache(), this;
    }
    // legacy
    addPattern(t) {
      return this.add(t);
    }
    // @returns {TestResult}
    _test(t, r, i, n) {
      let a = t && au.convert(t);
      return au(
        a,
        t,
        this._strictPathCheck ? Gce : rF
      ), this._t(a, r, i, n);
    }
    checkIgnore(t) {
      if (!Lce.test(t))
        return this.test(t);
      let r = t.split(If).filter(Boolean);
      if (r.pop(), r.length) {
        let i = this._t(
          r.join(If) + If,
          this._testCache,
          !0,
          r
        );
        if (i.ignored)
          return i;
      }
      return this._rules.test(t, !1, ng);
    }
    _t(t, r, i, n) {
      if (t in r)
        return r[t];
      if (n || (n = t.split(If).filter(Boolean)), n.pop(), !n.length)
        return r[t] = this._rules.test(t, i, Ih);
      let a = this._t(
        n.join(If) + If,
        r,
        i,
        n
      );
      return r[t] = a.ignored ? a : this._rules.test(t, i, Ih);
    }
    ignores(t) {
      return this._test(t, this._ignoreCache, !1).ignored;
    }
    createFilter() {
      return (t) => !this.ignores(t);
    }
    filter(t) {
      return ZL(t).filter(this.createFilter());
    }
    // @returns {TestResult}
    test(t) {
      return this._test(t, this._testCache, !0);
    }
  }, ME = /* @__PURE__ */ s((e) => new FE(e), "factory"), Wce = /* @__PURE__ */ s((e) => au(e && au.convert(e), e, rF), "isPathValid");
  if (
    // Detect `process` so that it can run in browsers.
    typeof process < "u" && (process.env && process.env.IGNORE_TEST_WIN32 || process.platform === "win32")
  ) {
    let e = /* @__PURE__ */ s((r) => /^\\\\\?\\/.test(r) || /["<>|\u0000-\u001F]+/u.test(r) ? r : r.replace(/\\/g, "/"), "makePosix");
    au.convert = e;
    let t = /^[a-z]:\//i;
    au.isNotRelative = (r) => t.test(r) || iF(r);
  }
  BE.exports = ME;
  ME.default = ME;
  BE.exports.isPathValid = Wce;
});

// ../node_modules/slash/index.js
function Rf(e) {
  return e.startsWith("\\\\?\\") ? e : e.replace(/\\/g, "/");
}
var sF = at(() => {
  s(Rf, "slash");
});

// ../node_modules/globby/utilities.js
var Rh, qE = at(() => {
  Rh = /* @__PURE__ */ s((e) => e[0] === "!", "isNegativePattern");
});

// ../node_modules/globby/ignore.js
var aF, oF, uF, ic, UE, lF, $ce, cF, ag, Xce, Yce, Jce, fF, pF, Nh, Lh, hF, dF, jE = at(() => {
  aF = Gt(require("node:process"), 1), oF = Gt(require("node:fs"), 1), uF = Gt(require("node:fs/promises"), 1), ic = Gt(require("node:path"), 1),
  UE = Gt(PE(), 1), lF = Gt(nF(), 1);
  sF();
  kE();
  qE();
  $ce = [
    "**/node_modules",
    "**/flow-typed",
    "**/coverage",
    "**/.git"
  ], cF = {
    absolute: !0,
    dot: !0
  }, ag = "**/.gitignore", Xce = /* @__PURE__ */ s((e, t) => Rh(e) ? "!" + ic.default.posix.join(t, e.slice(1)) : ic.default.posix.join(t, e),
  "applyBaseToPattern"), Yce = /* @__PURE__ */ s((e, t) => {
    let r = Rf(ic.default.relative(t, ic.default.dirname(e.filePath)));
    return e.content.split(/\r?\n/).filter((i) => i && !i.startsWith("#")).map((i) => Xce(i, r));
  }, "parseIgnoreFile"), Jce = /* @__PURE__ */ s((e, t) => {
    if (t = Rf(t), ic.default.isAbsolute(e)) {
      if (Rf(e).startsWith(t))
        return ic.default.relative(t, e);
      throw new Error(`Path ${e} is not in cwd ${t}`);
    }
    return e;
  }, "toRelativePath"), fF = /* @__PURE__ */ s((e, t) => {
    let r = e.flatMap((n) => Yce(n, t)), i = (0, lF.default)().add(r);
    return (n) => (n = Oh(n), n = Jce(n, t), n ? i.ignores(Rf(n)) : !1);
  }, "getIsIgnoredPredicate"), pF = /* @__PURE__ */ s((e = {}) => ({
    cwd: Oh(e.cwd) ?? aF.default.cwd(),
    suppressErrors: !!e.suppressErrors,
    deep: typeof e.deep == "number" ? e.deep : Number.POSITIVE_INFINITY,
    ignore: [...e.ignore ?? [], ...$ce]
  }), "normalizeOptions"), Nh = /* @__PURE__ */ s(async (e, t) => {
    let { cwd: r, suppressErrors: i, deep: n, ignore: a } = pF(t), o = await (0, UE.default)(e, {
      cwd: r,
      suppressErrors: i,
      deep: n,
      ignore: a,
      ...cF
    }), u = await Promise.all(
      o.map(async (l) => ({
        filePath: l,
        content: await uF.default.readFile(l, "utf8")
      }))
    );
    return fF(u, r);
  }, "isIgnoredByIgnoreFiles"), Lh = /* @__PURE__ */ s((e, t) => {
    let { cwd: r, suppressErrors: i, deep: n, ignore: a } = pF(t), u = UE.default.sync(e, {
      cwd: r,
      suppressErrors: i,
      deep: n,
      ignore: a,
      ...cF
    }).map((l) => ({
      filePath: l,
      content: oF.default.readFileSync(l, "utf8")
    }));
    return fF(u, r);
  }, "isIgnoredByIgnoreFilesSync"), hF = /* @__PURE__ */ s((e) => Nh(ag, e), "isGitIgnored"), dF = /* @__PURE__ */ s((e) => Lh(ag, e), "isGi\
tIgnoredSync");
});

// ../node_modules/globby/index.js
var wF = {};
da(wF, {
  convertPathToPattern: () => ofe,
  generateGlobTasks: () => sfe,
  generateGlobTasksSync: () => afe,
  globby: () => tfe,
  globbyStream: () => ife,
  globbySync: () => rfe,
  isDynamicPattern: () => nfe,
  isGitIgnored: () => hF,
  isGitIgnoredSync: () => dF,
  isIgnoredByIgnoreFiles: () => Nh,
  isIgnoredByIgnoreFilesSync: () => Lh
});
var VE, gF, nc, Nf, Qce, _F, bF, mF, yF, KE, Zce, vF, SF, og, TF, efe, EF, AF, xF, CF, PF, DF, HE, tfe, rfe, ife, nfe, sfe, afe, ofe, OF = at(
() => {
  VE = Gt(require("node:process"), 1), gF = Gt(require("node:fs"), 1), nc = Gt(require("node:path"), 1);
  ZI();
  Nf = Gt(PE(), 1);
  WL();
  kE();
  jE();
  qE();
  jE();
  Qce = /* @__PURE__ */ s((e) => {
    if (e.some((t) => typeof t != "string"))
      throw new TypeError("Patterns must be a string or an array of strings");
  }, "assertPatternsInput"), _F = /* @__PURE__ */ s((e, t) => {
    let r = Rh(e) ? e.slice(1) : e;
    return nc.default.isAbsolute(r) ? r : nc.default.join(t, r);
  }, "normalizePathForDirectoryGlob"), bF = /* @__PURE__ */ s(({ directoryPath: e, files: t, extensions: r }) => {
    let i = r?.length > 0 ? `.${r.length > 1 ? `{${r.join(",")}}` : r[0]}` : "";
    return t ? t.map((n) => nc.default.posix.join(e, `**/${nc.default.extname(n) ? n : `${n}${i}`}`)) : [nc.default.posix.join(e, `**${i ? `\
/*${i}` : ""}`)];
  }, "getDirectoryGlob"), mF = /* @__PURE__ */ s(async (e, {
    cwd: t = VE.default.cwd(),
    files: r,
    extensions: i
  } = {}) => (await Promise.all(
    e.map(async (a) => await zL(_F(a, t)) ? bF({ directoryPath: a, files: r, extensions: i }) : a)
  )).flat(), "directoryToGlob"), yF = /* @__PURE__ */ s((e, {
    cwd: t = VE.default.cwd(),
    files: r,
    extensions: i
  } = {}) => e.flatMap((n) => GL(_F(n, t)) ? bF({ directoryPath: n, files: r, extensions: i }) : n), "directoryToGlobSync"), KE = /* @__PURE__ */ s(
  (e) => (e = [...new Set([e].flat())], Qce(e), e), "toPatternsArray"), Zce = /* @__PURE__ */ s((e) => {
    if (!e)
      return;
    let t;
    try {
      t = gF.default.statSync(e);
    } catch {
      return;
    }
    if (!t.isDirectory())
      throw new Error("The `cwd` option must be a path to a directory");
  }, "checkCwdOption"), vF = /* @__PURE__ */ s((e = {}) => (e = {
    ...e,
    ignore: e.ignore ?? [],
    expandDirectories: e.expandDirectories ?? !0,
    cwd: Oh(e.cwd)
  }, Zce(e.cwd), e), "normalizeOptions"), SF = /* @__PURE__ */ s((e) => async (t, r) => e(KE(t), vF(r)), "normalizeArguments"), og = /* @__PURE__ */ s(
  (e) => (t, r) => e(KE(t), vF(r)), "normalizeArgumentsSync"), TF = /* @__PURE__ */ s((e) => {
    let { ignoreFiles: t, gitignore: r } = e, i = t ? KE(t) : [];
    return r && i.push(ag), i;
  }, "getIgnoreFilesPatterns"), efe = /* @__PURE__ */ s(async (e) => {
    let t = TF(e);
    return AF(
      t.length > 0 && await Nh(t, e)
    );
  }, "getFilter"), EF = /* @__PURE__ */ s((e) => {
    let t = TF(e);
    return AF(
      t.length > 0 && Lh(t, e)
    );
  }, "getFilterSync"), AF = /* @__PURE__ */ s((e) => {
    let t = /* @__PURE__ */ new Set();
    return (r) => {
      let i = nc.default.normalize(r.path ?? r);
      return t.has(i) || e && e(i) ? !1 : (t.add(i), !0);
    };
  }, "createFilterFunction"), xF = /* @__PURE__ */ s((e, t) => e.flat().filter((r) => t(r)), "unionFastGlobResults"), CF = /* @__PURE__ */ s(
  (e, t) => {
    let r = [];
    for (; e.length > 0; ) {
      let i = e.findIndex((a) => Rh(a));
      if (i === -1) {
        r.push({ patterns: e, options: t });
        break;
      }
      let n = e[i].slice(1);
      for (let a of r)
        a.options.ignore.push(n);
      i !== 0 && r.push({
        patterns: e.slice(0, i),
        options: {
          ...t,
          ignore: [
            ...t.ignore,
            n
          ]
        }
      }), e = e.slice(i + 1);
    }
    return r;
  }, "convertNegativePatterns"), PF = /* @__PURE__ */ s((e, t) => ({
    ...t ? { cwd: t } : {},
    ...Array.isArray(e) ? { files: e } : e
  }), "normalizeExpandDirectoriesOption"), DF = /* @__PURE__ */ s(async (e, t) => {
    let r = CF(e, t), { cwd: i, expandDirectories: n } = t;
    if (!n)
      return r;
    let a = PF(n, i);
    return Promise.all(
      r.map(async (o) => {
        let { patterns: u, options: l } = o;
        return [
          u,
          l.ignore
        ] = await Promise.all([
          mF(u, a),
          mF(l.ignore, { cwd: i })
        ]), { patterns: u, options: l };
      })
    );
  }, "generateTasks"), HE = /* @__PURE__ */ s((e, t) => {
    let r = CF(e, t), { cwd: i, expandDirectories: n } = t;
    if (!n)
      return r;
    let a = PF(n, i);
    return r.map((o) => {
      let { patterns: u, options: l } = o;
      return u = yF(u, a), l.ignore = yF(l.ignore, { cwd: i }), { patterns: u, options: l };
    });
  }, "generateTasksSync"), tfe = SF(async (e, t) => {
    let [
      r,
      i
    ] = await Promise.all([
      DF(e, t),
      efe(t)
    ]), n = await Promise.all(r.map((a) => (0, Nf.default)(a.patterns, a.options)));
    return xF(n, i);
  }), rfe = og((e, t) => {
    let r = HE(e, t), i = EF(t), n = r.map((a) => Nf.default.sync(a.patterns, a.options));
    return xF(n, i);
  }), ife = og((e, t) => {
    let r = HE(e, t), i = EF(t), n = r.map((o) => Nf.default.stream(o.patterns, o.options));
    return K0(n).filter((o) => i(o));
  }), nfe = og(
    (e, t) => e.some((r) => Nf.default.isDynamicPattern(r, t))
  ), sfe = SF(DF), afe = og(HE), { convertPathToPattern: ofe } = Nf.default;
});

// ../node_modules/picocolors/picocolors.js
var KF = b((nbt, zE) => {
  var dg = process || {}, jF = dg.argv || [], hg = dg.env || {}, pfe = !(hg.NO_COLOR || jF.includes("--no-color")) && (!!hg.FORCE_COLOR || jF.
  includes("--color") || dg.platform === "win32" || (dg.stdout || {}).isTTY && hg.TERM !== "dumb" || !!hg.CI), hfe = /* @__PURE__ */ s((e, t, r = e) => (i) => {
    let n = "" + i, a = n.indexOf(t, e.length);
    return ~a ? e + dfe(n, t, r, a) + t : e + n + t;
  }, "formatter"), dfe = /* @__PURE__ */ s((e, t, r, i) => {
    let n = "", a = 0;
    do
      n += e.substring(a, i) + r, a = i + t.length, i = e.indexOf(t, a);
    while (~i);
    return n + e.substring(a);
  }, "replaceClose"), VF = /* @__PURE__ */ s((e = pfe) => {
    let t = e ? hfe : () => String;
    return {
      isColorSupported: e,
      reset: t("\x1B[0m", "\x1B[0m"),
      bold: t("\x1B[1m", "\x1B[22m", "\x1B[22m\x1B[1m"),
      dim: t("\x1B[2m", "\x1B[22m", "\x1B[22m\x1B[2m"),
      italic: t("\x1B[3m", "\x1B[23m"),
      underline: t("\x1B[4m", "\x1B[24m"),
      inverse: t("\x1B[7m", "\x1B[27m"),
      hidden: t("\x1B[8m", "\x1B[28m"),
      strikethrough: t("\x1B[9m", "\x1B[29m"),
      black: t("\x1B[30m", "\x1B[39m"),
      red: t("\x1B[31m", "\x1B[39m"),
      green: t("\x1B[32m", "\x1B[39m"),
      yellow: t("\x1B[33m", "\x1B[39m"),
      blue: t("\x1B[34m", "\x1B[39m"),
      magenta: t("\x1B[35m", "\x1B[39m"),
      cyan: t("\x1B[36m", "\x1B[39m"),
      white: t("\x1B[37m", "\x1B[39m"),
      gray: t("\x1B[90m", "\x1B[39m"),
      bgBlack: t("\x1B[40m", "\x1B[49m"),
      bgRed: t("\x1B[41m", "\x1B[49m"),
      bgGreen: t("\x1B[42m", "\x1B[49m"),
      bgYellow: t("\x1B[43m", "\x1B[49m"),
      bgBlue: t("\x1B[44m", "\x1B[49m"),
      bgMagenta: t("\x1B[45m", "\x1B[49m"),
      bgCyan: t("\x1B[46m", "\x1B[49m"),
      bgWhite: t("\x1B[47m", "\x1B[49m"),
      blackBright: t("\x1B[90m", "\x1B[39m"),
      redBright: t("\x1B[91m", "\x1B[39m"),
      greenBright: t("\x1B[92m", "\x1B[39m"),
      yellowBright: t("\x1B[93m", "\x1B[39m"),
      blueBright: t("\x1B[94m", "\x1B[39m"),
      magentaBright: t("\x1B[95m", "\x1B[39m"),
      cyanBright: t("\x1B[96m", "\x1B[39m"),
      whiteBright: t("\x1B[97m", "\x1B[39m"),
      bgBlackBright: t("\x1B[100m", "\x1B[49m"),
      bgRedBright: t("\x1B[101m", "\x1B[49m"),
      bgGreenBright: t("\x1B[102m", "\x1B[49m"),
      bgYellowBright: t("\x1B[103m", "\x1B[49m"),
      bgBlueBright: t("\x1B[104m", "\x1B[49m"),
      bgMagentaBright: t("\x1B[105m", "\x1B[49m"),
      bgCyanBright: t("\x1B[106m", "\x1B[49m"),
      bgWhiteBright: t("\x1B[107m", "\x1B[49m")
    };
  }, "createColors");
  zE.exports = VF();
  zE.exports.createColors = VF;
});

// ../node_modules/totalist/sync/index.mjs
var zF = {};
da(zF, {
  totalist: () => HF
});
function HF(e, t, r = "") {
  e = (0, Ff.resolve)(".", e);
  let i = (0, mg.readdirSync)(e), n = 0, a, o;
  for (; n < i.length; n++)
    a = (0, Ff.join)(e, i[n]), o = (0, mg.statSync)(a), o.isDirectory() ? HF(a, t, (0, Ff.join)(r, i[n])) : t((0, Ff.join)(r, i[n]), a, o);
}
var Ff, mg, GF = at(() => {
  Ff = require("path"), mg = require("fs");
  s(HF, "totalist");
});

// ../node_modules/@polka/url/build.mjs
var $F = {};
da($F, {
  parse: () => mfe
});
function mfe(e) {
  let t = e.url;
  if (t == null) return;
  let r = e._parsedUrl;
  if (r && r.raw === t) return r;
  let i = t, n = "", a, o;
  if (t.length > 1) {
    let u = t.indexOf("#", 1);
    u !== -1 && (o = t.substring(u), i = t.substring(0, u)), u = i.indexOf("?", 1), u !== -1 && (n = i.substring(u), i = i.substring(0, u), n.
    length > 1 && (a = WF.parse(n.substring(1))));
  }
  return e._parsedUrl = { pathname: i, search: n, query: a, hash: o, raw: t };
}
var WF, XF = at(() => {
  WF = Gt(require("node:querystring"), 1);
  s(mfe, "parse");
});

// ../node_modules/mrmime/index.mjs
var JF = {};
da(JF, {
  lookup: () => yfe,
  mimes: () => YF
});
function yfe(e) {
  let t = ("" + e).trim().toLowerCase(), r = t.lastIndexOf(".");
  return YF[~r ? t.substring(++r) : t];
}
var YF, QF = at(() => {
  YF = {
    "3g2": "video/3gpp2",
    "3gp": "video/3gpp",
    "3gpp": "video/3gpp",
    "3mf": "model/3mf",
    aac: "audio/aac",
    ac: "application/pkix-attr-cert",
    adp: "audio/adpcm",
    adts: "audio/aac",
    ai: "application/postscript",
    aml: "application/automationml-aml+xml",
    amlx: "application/automationml-amlx+zip",
    amr: "audio/amr",
    apng: "image/apng",
    appcache: "text/cache-manifest",
    appinstaller: "application/appinstaller",
    appx: "application/appx",
    appxbundle: "application/appxbundle",
    asc: "application/pgp-keys",
    atom: "application/atom+xml",
    atomcat: "application/atomcat+xml",
    atomdeleted: "application/atomdeleted+xml",
    atomsvc: "application/atomsvc+xml",
    au: "audio/basic",
    avci: "image/avci",
    avcs: "image/avcs",
    avif: "image/avif",
    aw: "application/applixware",
    bdoc: "application/bdoc",
    bin: "application/octet-stream",
    bmp: "image/bmp",
    bpk: "application/octet-stream",
    btf: "image/prs.btif",
    btif: "image/prs.btif",
    buffer: "application/octet-stream",
    ccxml: "application/ccxml+xml",
    cdfx: "application/cdfx+xml",
    cdmia: "application/cdmi-capability",
    cdmic: "application/cdmi-container",
    cdmid: "application/cdmi-domain",
    cdmio: "application/cdmi-object",
    cdmiq: "application/cdmi-queue",
    cer: "application/pkix-cert",
    cgm: "image/cgm",
    cjs: "application/node",
    class: "application/java-vm",
    coffee: "text/coffeescript",
    conf: "text/plain",
    cpl: "application/cpl+xml",
    cpt: "application/mac-compactpro",
    crl: "application/pkix-crl",
    css: "text/css",
    csv: "text/csv",
    cu: "application/cu-seeme",
    cwl: "application/cwl",
    cww: "application/prs.cww",
    davmount: "application/davmount+xml",
    dbk: "application/docbook+xml",
    deb: "application/octet-stream",
    def: "text/plain",
    deploy: "application/octet-stream",
    dib: "image/bmp",
    "disposition-notification": "message/disposition-notification",
    dist: "application/octet-stream",
    distz: "application/octet-stream",
    dll: "application/octet-stream",
    dmg: "application/octet-stream",
    dms: "application/octet-stream",
    doc: "application/msword",
    dot: "application/msword",
    dpx: "image/dpx",
    drle: "image/dicom-rle",
    dsc: "text/prs.lines.tag",
    dssc: "application/dssc+der",
    dtd: "application/xml-dtd",
    dump: "application/octet-stream",
    dwd: "application/atsc-dwd+xml",
    ear: "application/java-archive",
    ecma: "application/ecmascript",
    elc: "application/octet-stream",
    emf: "image/emf",
    eml: "message/rfc822",
    emma: "application/emma+xml",
    emotionml: "application/emotionml+xml",
    eps: "application/postscript",
    epub: "application/epub+zip",
    exe: "application/octet-stream",
    exi: "application/exi",
    exp: "application/express",
    exr: "image/aces",
    ez: "application/andrew-inset",
    fdf: "application/fdf",
    fdt: "application/fdt+xml",
    fits: "image/fits",
    g3: "image/g3fax",
    gbr: "application/rpki-ghostbusters",
    geojson: "application/geo+json",
    gif: "image/gif",
    glb: "model/gltf-binary",
    gltf: "model/gltf+json",
    gml: "application/gml+xml",
    gpx: "application/gpx+xml",
    gram: "application/srgs",
    grxml: "application/srgs+xml",
    gxf: "application/gxf",
    gz: "application/gzip",
    h261: "video/h261",
    h263: "video/h263",
    h264: "video/h264",
    heic: "image/heic",
    heics: "image/heic-sequence",
    heif: "image/heif",
    heifs: "image/heif-sequence",
    hej2: "image/hej2k",
    held: "application/atsc-held+xml",
    hjson: "application/hjson",
    hlp: "application/winhlp",
    hqx: "application/mac-binhex40",
    hsj2: "image/hsj2",
    htm: "text/html",
    html: "text/html",
    ics: "text/calendar",
    ief: "image/ief",
    ifb: "text/calendar",
    iges: "model/iges",
    igs: "model/iges",
    img: "application/octet-stream",
    in: "text/plain",
    ini: "text/plain",
    ink: "application/inkml+xml",
    inkml: "application/inkml+xml",
    ipfix: "application/ipfix",
    iso: "application/octet-stream",
    its: "application/its+xml",
    jade: "text/jade",
    jar: "application/java-archive",
    jhc: "image/jphc",
    jls: "image/jls",
    jp2: "image/jp2",
    jpe: "image/jpeg",
    jpeg: "image/jpeg",
    jpf: "image/jpx",
    jpg: "image/jpeg",
    jpg2: "image/jp2",
    jpgm: "image/jpm",
    jpgv: "video/jpeg",
    jph: "image/jph",
    jpm: "image/jpm",
    jpx: "image/jpx",
    js: "text/javascript",
    json: "application/json",
    json5: "application/json5",
    jsonld: "application/ld+json",
    jsonml: "application/jsonml+json",
    jsx: "text/jsx",
    jt: "model/jt",
    jxl: "image/jxl",
    jxr: "image/jxr",
    jxra: "image/jxra",
    jxrs: "image/jxrs",
    jxs: "image/jxs",
    jxsc: "image/jxsc",
    jxsi: "image/jxsi",
    jxss: "image/jxss",
    kar: "audio/midi",
    ktx: "image/ktx",
    ktx2: "image/ktx2",
    less: "text/less",
    lgr: "application/lgr+xml",
    list: "text/plain",
    litcoffee: "text/coffeescript",
    log: "text/plain",
    lostxml: "application/lost+xml",
    lrf: "application/octet-stream",
    m1v: "video/mpeg",
    m21: "application/mp21",
    m2a: "audio/mpeg",
    m2t: "video/mp2t",
    m2ts: "video/mp2t",
    m2v: "video/mpeg",
    m3a: "audio/mpeg",
    m4a: "audio/mp4",
    m4p: "application/mp4",
    m4s: "video/iso.segment",
    ma: "application/mathematica",
    mads: "application/mads+xml",
    maei: "application/mmt-aei+xml",
    man: "text/troff",
    manifest: "text/cache-manifest",
    map: "application/json",
    mar: "application/octet-stream",
    markdown: "text/markdown",
    mathml: "application/mathml+xml",
    mb: "application/mathematica",
    mbox: "application/mbox",
    md: "text/markdown",
    mdx: "text/mdx",
    me: "text/troff",
    mesh: "model/mesh",
    meta4: "application/metalink4+xml",
    metalink: "application/metalink+xml",
    mets: "application/mets+xml",
    mft: "application/rpki-manifest",
    mid: "audio/midi",
    midi: "audio/midi",
    mime: "message/rfc822",
    mj2: "video/mj2",
    mjp2: "video/mj2",
    mjs: "text/javascript",
    mml: "text/mathml",
    mods: "application/mods+xml",
    mov: "video/quicktime",
    mp2: "audio/mpeg",
    mp21: "application/mp21",
    mp2a: "audio/mpeg",
    mp3: "audio/mpeg",
    mp4: "video/mp4",
    mp4a: "audio/mp4",
    mp4s: "application/mp4",
    mp4v: "video/mp4",
    mpd: "application/dash+xml",
    mpe: "video/mpeg",
    mpeg: "video/mpeg",
    mpf: "application/media-policy-dataset+xml",
    mpg: "video/mpeg",
    mpg4: "video/mp4",
    mpga: "audio/mpeg",
    mpp: "application/dash-patch+xml",
    mrc: "application/marc",
    mrcx: "application/marcxml+xml",
    ms: "text/troff",
    mscml: "application/mediaservercontrol+xml",
    msh: "model/mesh",
    msi: "application/octet-stream",
    msix: "application/msix",
    msixbundle: "application/msixbundle",
    msm: "application/octet-stream",
    msp: "application/octet-stream",
    mtl: "model/mtl",
    mts: "video/mp2t",
    musd: "application/mmt-usd+xml",
    mxf: "application/mxf",
    mxmf: "audio/mobile-xmf",
    mxml: "application/xv+xml",
    n3: "text/n3",
    nb: "application/mathematica",
    nq: "application/n-quads",
    nt: "application/n-triples",
    obj: "model/obj",
    oda: "application/oda",
    oga: "audio/ogg",
    ogg: "audio/ogg",
    ogv: "video/ogg",
    ogx: "application/ogg",
    omdoc: "application/omdoc+xml",
    onepkg: "application/onenote",
    onetmp: "application/onenote",
    onetoc: "application/onenote",
    onetoc2: "application/onenote",
    opf: "application/oebps-package+xml",
    opus: "audio/ogg",
    otf: "font/otf",
    owl: "application/rdf+xml",
    oxps: "application/oxps",
    p10: "application/pkcs10",
    p7c: "application/pkcs7-mime",
    p7m: "application/pkcs7-mime",
    p7s: "application/pkcs7-signature",
    p8: "application/pkcs8",
    pdf: "application/pdf",
    pfr: "application/font-tdpfr",
    pgp: "application/pgp-encrypted",
    pkg: "application/octet-stream",
    pki: "application/pkixcmp",
    pkipath: "application/pkix-pkipath",
    pls: "application/pls+xml",
    png: "image/png",
    prc: "model/prc",
    prf: "application/pics-rules",
    provx: "application/provenance+xml",
    ps: "application/postscript",
    pskcxml: "application/pskc+xml",
    pti: "image/prs.pti",
    qt: "video/quicktime",
    raml: "application/raml+yaml",
    rapd: "application/route-apd+xml",
    rdf: "application/rdf+xml",
    relo: "application/p2p-overlay+xml",
    rif: "application/reginfo+xml",
    rl: "application/resource-lists+xml",
    rld: "application/resource-lists-diff+xml",
    rmi: "audio/midi",
    rnc: "application/relax-ng-compact-syntax",
    rng: "application/xml",
    roa: "application/rpki-roa",
    roff: "text/troff",
    rq: "application/sparql-query",
    rs: "application/rls-services+xml",
    rsat: "application/atsc-rsat+xml",
    rsd: "application/rsd+xml",
    rsheet: "application/urc-ressheet+xml",
    rss: "application/rss+xml",
    rtf: "text/rtf",
    rtx: "text/richtext",
    rusd: "application/route-usd+xml",
    s3m: "audio/s3m",
    sbml: "application/sbml+xml",
    scq: "application/scvp-cv-request",
    scs: "application/scvp-cv-response",
    sdp: "application/sdp",
    senmlx: "application/senml+xml",
    sensmlx: "application/sensml+xml",
    ser: "application/java-serialized-object",
    setpay: "application/set-payment-initiation",
    setreg: "application/set-registration-initiation",
    sgi: "image/sgi",
    sgm: "text/sgml",
    sgml: "text/sgml",
    shex: "text/shex",
    shf: "application/shf+xml",
    shtml: "text/html",
    sieve: "application/sieve",
    sig: "application/pgp-signature",
    sil: "audio/silk",
    silo: "model/mesh",
    siv: "application/sieve",
    slim: "text/slim",
    slm: "text/slim",
    sls: "application/route-s-tsid+xml",
    smi: "application/smil+xml",
    smil: "application/smil+xml",
    snd: "audio/basic",
    so: "application/octet-stream",
    spdx: "text/spdx",
    spp: "application/scvp-vp-response",
    spq: "application/scvp-vp-request",
    spx: "audio/ogg",
    sql: "application/sql",
    sru: "application/sru+xml",
    srx: "application/sparql-results+xml",
    ssdl: "application/ssdl+xml",
    ssml: "application/ssml+xml",
    stk: "application/hyperstudio",
    stl: "model/stl",
    stpx: "model/step+xml",
    stpxz: "model/step-xml+zip",
    stpz: "model/step+zip",
    styl: "text/stylus",
    stylus: "text/stylus",
    svg: "image/svg+xml",
    svgz: "image/svg+xml",
    swidtag: "application/swid+xml",
    t: "text/troff",
    t38: "image/t38",
    td: "application/urc-targetdesc+xml",
    tei: "application/tei+xml",
    teicorpus: "application/tei+xml",
    text: "text/plain",
    tfi: "application/thraud+xml",
    tfx: "image/tiff-fx",
    tif: "image/tiff",
    tiff: "image/tiff",
    toml: "application/toml",
    tr: "text/troff",
    trig: "application/trig",
    ts: "video/mp2t",
    tsd: "application/timestamped-data",
    tsv: "text/tab-separated-values",
    ttc: "font/collection",
    ttf: "font/ttf",
    ttl: "text/turtle",
    ttml: "application/ttml+xml",
    txt: "text/plain",
    u3d: "model/u3d",
    u8dsn: "message/global-delivery-status",
    u8hdr: "message/global-headers",
    u8mdn: "message/global-disposition-notification",
    u8msg: "message/global",
    ubj: "application/ubjson",
    uri: "text/uri-list",
    uris: "text/uri-list",
    urls: "text/uri-list",
    vcard: "text/vcard",
    vrml: "model/vrml",
    vtt: "text/vtt",
    vxml: "application/voicexml+xml",
    war: "application/java-archive",
    wasm: "application/wasm",
    wav: "audio/wav",
    weba: "audio/webm",
    webm: "video/webm",
    webmanifest: "application/manifest+json",
    webp: "image/webp",
    wgsl: "text/wgsl",
    wgt: "application/widget",
    wif: "application/watcherinfo+xml",
    wmf: "image/wmf",
    woff: "font/woff",
    woff2: "font/woff2",
    wrl: "model/vrml",
    wsdl: "application/wsdl+xml",
    wspolicy: "application/wspolicy+xml",
    x3d: "model/x3d+xml",
    x3db: "model/x3d+fastinfoset",
    x3dbz: "model/x3d+binary",
    x3dv: "model/x3d-vrml",
    x3dvz: "model/x3d+vrml",
    x3dz: "model/x3d+xml",
    xaml: "application/xaml+xml",
    xav: "application/xcap-att+xml",
    xca: "application/xcap-caps+xml",
    xcs: "application/calendar+xml",
    xdf: "application/xcap-diff+xml",
    xdssc: "application/dssc+xml",
    xel: "application/xcap-el+xml",
    xenc: "application/xenc+xml",
    xer: "application/patch-ops-error+xml",
    xfdf: "application/xfdf",
    xht: "application/xhtml+xml",
    xhtml: "application/xhtml+xml",
    xhvml: "application/xv+xml",
    xlf: "application/xliff+xml",
    xm: "audio/xm",
    xml: "text/xml",
    xns: "application/xcap-ns+xml",
    xop: "application/xop+xml",
    xpl: "application/xproc+xml",
    xsd: "application/xml",
    xsf: "application/prs.xsf+xml",
    xsl: "application/xml",
    xslt: "application/xml",
    xspf: "application/xspf+xml",
    xvm: "application/xv+xml",
    xvml: "application/xv+xml",
    yaml: "text/yaml",
    yang: "application/yang",
    yin: "application/yin+xml",
    yml: "text/yaml",
    zip: "application/zip"
  };
  s(yfe, "lookup");
});

// ../node_modules/sirv/build.js
var rM = b((lbt, tM) => {
  var GE = require("fs"), { join: gfe, normalize: _fe, resolve: bfe } = require("path"), { totalist: vfe } = (GF(), vf(zF)), { parse: Sfe } = (XF(), vf($F)),
  { lookup: Tfe } = (QF(), vf(JF)), Efe = /* @__PURE__ */ s(() => {
  }, "noop");
  function Afe(e, t) {
    for (let r = 0; r < t.length; r++)
      if (t[r].test(e)) return !0;
  }
  s(Afe, "isMatch");
  function ZF(e, t) {
    let r = 0, i, n = e.length - 1;
    e.charCodeAt(n) === 47 && (e = e.substring(0, n));
    let a = [], o = `${e}/index`;
    for (; r < t.length; r++)
      i = t[r] ? `.${t[r]}` : "", e && a.push(e + i), a.push(o + i);
    return a;
  }
  s(ZF, "toAssume");
  function xfe(e, t, r) {
    let i = 0, n, a = ZF(t, r);
    for (; i < a.length; i++)
      if (n = e[a[i]]) return n;
  }
  s(xfe, "viaCache");
  function Cfe(e, t, r, i) {
    let n = 0, a = ZF(r, i), o, u, l, c;
    for (; n < a.length; n++)
      if (o = _fe(gfe(e, l = a[n])), o.startsWith(e) && GE.existsSync(o)) {
        if (u = GE.statSync(o), u.isDirectory()) continue;
        return c = eM(l, u, t), c["Cache-Control"] = t ? "no-cache" : "no-store", { abs: o, stats: u, headers: c };
      }
  }
  s(Cfe, "viaLocal");
  function Pfe(e, t) {
    return t.statusCode = 404, t.end();
  }
  s(Pfe, "is404");
  function Dfe(e, t, r, i, n) {
    let a = 200, o, u = {};
    n = { ...n };
    for (let l in n)
      o = t.getHeader(l), o && (n[l] = o);
    if ((o = t.getHeader("content-type")) && (n["Content-Type"] = o), e.headers.range) {
      a = 206;
      let [l, c] = e.headers.range.replace("bytes=", "").split("-"), p = u.end = parseInt(c, 10) || i.size - 1, h = u.start = parseInt(l, 10) ||
      0;
      if (p >= i.size && (p = i.size - 1), h >= i.size)
        return t.setHeader("Content-Range", `bytes */${i.size}`), t.statusCode = 416, t.end();
      n["Content-Range"] = `bytes ${h}-${p}/${i.size}`, n["Content-Length"] = p - h + 1, n["Accept-Ranges"] = "bytes";
    }
    t.writeHead(a, n), GE.createReadStream(r, u).pipe(t);
  }
  s(Dfe, "send");
  var wfe = {
    ".br": "br",
    ".gz": "gzip"
  };
  function eM(e, t, r) {
    let i = wfe[e.slice(-3)], n = Tfe(e.slice(0, i && -3)) || "";
    n === "text/html" && (n += ";charset=utf-8");
    let a = {
      "Content-Length": t.size,
      "Content-Type": n,
      "Last-Modified": t.mtime.toUTCString()
    };
    return i && (a["Content-Encoding"] = i), r && (a.ETag = `W/"${t.size}-${t.mtime.getTime()}"`), a;
  }
  s(eM, "toHeaders");
  tM.exports = function(e, t = {}) {
    e = bfe(e || ".");
    let r = t.onNoMatch || Pfe, i = t.setHeaders || Efe, n = t.extensions || ["html", "htm"], a = t.gzip && n.map((g) => `${g}.gz`).concat("\
gz"), o = t.brotli && n.map((g) => `${g}.br`).concat("br"), u = {}, l = "/", c = !!t.etag, p = !!t.single;
    if (typeof t.single == "string") {
      let g = t.single.lastIndexOf(".");
      l += ~g ? t.single.substring(0, g) : t.single;
    }
    let h = [];
    t.ignores !== !1 && (h.push(/[/]([A-Za-z\s\d~$._-]+\.\w+){1,}$/), t.dotfiles ? h.push(/\/\.\w/) : h.push(/\/\.well-known/), [].concat(t.
    ignores || []).forEach((g) => {
      h.push(new RegExp(g, "i"));
    }));
    let y = t.maxAge != null && `public,max-age=${t.maxAge}`;
    y && t.immutable ? y += ",immutable" : y && t.maxAge === 0 && (y += ",must-revalidate"), t.dev || vfe(e, (g, m, f) => {
      if (!/\.well-known[\\+\/]/.test(g)) {
        if (!t.dotfiles && /(^\.|[\\+|\/+]\.)/.test(g)) return;
      }
      let d = eM(g, f, c);
      y && (d["Cache-Control"] = y), u["/" + g.normalize().replace(/\\+/g, "/")] = { abs: m, stats: f, headers: d };
    });
    let _ = t.dev ? Cfe.bind(0, e, c) : xfe.bind(0, u);
    return function(g, m, f) {
      let d = [""], v = Sfe(g).pathname, E = g.headers["accept-encoding"] || "";
      if (a && E.includes("gzip") && d.unshift(...a), o && /(br|brotli)/i.test(E) && d.unshift(...o), d.push(...n), v.indexOf("%") !== -1)
        try {
          v = decodeURI(v);
        } catch {
        }
      let S = _(v, d) || p && !Afe(v, h) && _(l, d);
      if (!S) return f ? f() : r(g, m);
      if (c && g.headers["if-none-match"] === S.headers.ETag)
        return m.writeHead(304), m.end();
      (a || o) && m.setHeader("Vary", "Accept-Encoding"), i(m, v, S.stats), Dfe(g, m, S.abs, S.stats, S.headers);
    };
  };
});

// ../node_modules/kleur/index.js
var Ti = b((gbt, lM) => {
  "use strict";
  var { FORCE_COLOR: Ife, NODE_DISABLE_COLORS: Rfe, TERM: Nfe } = process.env, Rr = {
    enabled: !Rfe && Nfe !== "dumb" && Ife !== "0",
    // modifiers
    reset: Yr(0, 0),
    bold: Yr(1, 22),
    dim: Yr(2, 22),
    italic: Yr(3, 23),
    underline: Yr(4, 24),
    inverse: Yr(7, 27),
    hidden: Yr(8, 28),
    strikethrough: Yr(9, 29),
    // colors
    black: Yr(30, 39),
    red: Yr(31, 39),
    green: Yr(32, 39),
    yellow: Yr(33, 39),
    blue: Yr(34, 39),
    magenta: Yr(35, 39),
    cyan: Yr(36, 39),
    white: Yr(37, 39),
    gray: Yr(90, 39),
    grey: Yr(90, 39),
    // background colors
    bgBlack: Yr(40, 49),
    bgRed: Yr(41, 49),
    bgGreen: Yr(42, 49),
    bgYellow: Yr(43, 49),
    bgBlue: Yr(44, 49),
    bgMagenta: Yr(45, 49),
    bgCyan: Yr(46, 49),
    bgWhite: Yr(47, 49)
  };
  function uM(e, t) {
    let r = 0, i, n = "", a = "";
    for (; r < e.length; r++)
      i = e[r], n += i.open, a += i.close, t.includes(i.close) && (t = t.replace(i.rgx, i.close + i.open));
    return n + t + a;
  }
  s(uM, "run");
  function Lfe(e, t) {
    let r = { has: e, keys: t };
    return r.reset = Rr.reset.bind(r), r.bold = Rr.bold.bind(r), r.dim = Rr.dim.bind(r), r.italic = Rr.italic.bind(r), r.underline = Rr.underline.
    bind(r), r.inverse = Rr.inverse.bind(r), r.hidden = Rr.hidden.bind(r), r.strikethrough = Rr.strikethrough.bind(r), r.black = Rr.black.bind(
    r), r.red = Rr.red.bind(r), r.green = Rr.green.bind(r), r.yellow = Rr.yellow.bind(r), r.blue = Rr.blue.bind(r), r.magenta = Rr.magenta.bind(
    r), r.cyan = Rr.cyan.bind(r), r.white = Rr.white.bind(r), r.gray = Rr.gray.bind(r), r.grey = Rr.grey.bind(r), r.bgBlack = Rr.bgBlack.bind(
    r), r.bgRed = Rr.bgRed.bind(r), r.bgGreen = Rr.bgGreen.bind(r), r.bgYellow = Rr.bgYellow.bind(r), r.bgBlue = Rr.bgBlue.bind(r), r.bgMagenta =
    Rr.bgMagenta.bind(r), r.bgCyan = Rr.bgCyan.bind(r), r.bgWhite = Rr.bgWhite.bind(r), r;
  }
  s(Lfe, "chain");
  function Yr(e, t) {
    let r = {
      open: `\x1B[${e}m`,
      close: `\x1B[${t}m`,
      rgx: new RegExp(`\\x1b\\[${t}m`, "g")
    };
    return function(i) {
      return this !== void 0 && this.has !== void 0 ? (this.has.includes(e) || (this.has.push(e), this.keys.push(r)), i === void 0 ? this : Rr.
      enabled ? uM(this.keys, i + "") : i + "") : i === void 0 ? Lfe([e], [r]) : Rr.enabled ? uM([r], i + "") : i + "";
    };
  }
  s(Yr, "init");
  lM.exports = Rr;
});

// ../node_modules/prompts/dist/util/action.js
var fM = b((bbt, cM) => {
  "use strict";
  cM.exports = (e, t) => {
    if (!(e.meta && e.name !== "escape")) {
      if (e.ctrl) {
        if (e.name === "a") return "first";
        if (e.name === "c" || e.name === "d") return "abort";
        if (e.name === "e") return "last";
        if (e.name === "g") return "reset";
      }
      if (t) {
        if (e.name === "j") return "down";
        if (e.name === "k") return "up";
      }
      return e.name === "return" || e.name === "enter" ? "submit" : e.name === "backspace" ? "delete" : e.name === "delete" ? "deleteForward" :
      e.name === "abort" ? "abort" : e.name === "escape" ? "exit" : e.name === "tab" ? "next" : e.name === "pagedown" ? "nextPage" : e.name ===
      "pageup" ? "prevPage" : e.name === "home" ? "home" : e.name === "end" ? "end" : e.name === "up" ? "up" : e.name === "down" ? "down" : e.
      name === "right" ? "right" : e.name === "left" ? "left" : !1;
    }
  };
});

// ../node_modules/prompts/dist/util/strip.js
var gg = b((vbt, pM) => {
  "use strict";
  pM.exports = (e) => {
    let t = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
    "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PRZcf-ntqry=><~]))"].join("|"), r = new RegExp(t, "g");
    return typeof e == "string" ? e.replace(r, "") : e;
  };
});

// ../node_modules/sisteransi/src/index.js
var Ai = b((Sbt, hM) => {
  "use strict";
  var YE = "\x1B", Ei = `${YE}[`, Ffe = "\x07", JE = {
    to(e, t) {
      return t ? `${Ei}${t + 1};${e + 1}H` : `${Ei}${e + 1}G`;
    },
    move(e, t) {
      let r = "";
      return e < 0 ? r += `${Ei}${-e}D` : e > 0 && (r += `${Ei}${e}C`), t < 0 ? r += `${Ei}${-t}A` : t > 0 && (r += `${Ei}${t}B`), r;
    },
    up: /* @__PURE__ */ s((e = 1) => `${Ei}${e}A`, "up"),
    down: /* @__PURE__ */ s((e = 1) => `${Ei}${e}B`, "down"),
    forward: /* @__PURE__ */ s((e = 1) => `${Ei}${e}C`, "forward"),
    backward: /* @__PURE__ */ s((e = 1) => `${Ei}${e}D`, "backward"),
    nextLine: /* @__PURE__ */ s((e = 1) => `${Ei}E`.repeat(e), "nextLine"),
    prevLine: /* @__PURE__ */ s((e = 1) => `${Ei}F`.repeat(e), "prevLine"),
    left: `${Ei}G`,
    hide: `${Ei}?25l`,
    show: `${Ei}?25h`,
    save: `${YE}7`,
    restore: `${YE}8`
  }, Mfe = {
    up: /* @__PURE__ */ s((e = 1) => `${Ei}S`.repeat(e), "up"),
    down: /* @__PURE__ */ s((e = 1) => `${Ei}T`.repeat(e), "down")
  }, Bfe = {
    screen: `${Ei}2J`,
    up: /* @__PURE__ */ s((e = 1) => `${Ei}1J`.repeat(e), "up"),
    down: /* @__PURE__ */ s((e = 1) => `${Ei}J`.repeat(e), "down"),
    line: `${Ei}2K`,
    lineEnd: `${Ei}K`,
    lineStart: `${Ei}1K`,
    lines(e) {
      let t = "";
      for (let r = 0; r < e; r++)
        t += this.line + (r < e - 1 ? JE.up() : "");
      return e && (t += JE.left), t;
    }
  };
  hM.exports = { cursor: JE, scroll: Mfe, erase: Bfe, beep: Ffe };
});

// ../node_modules/prompts/dist/util/clear.js
var _M = b((Ebt, gM) => {
  "use strict";
  function qfe(e, t) {
    var r = typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
    if (!r) {
      if (Array.isArray(e) || (r = Ufe(e)) || t && e && typeof e.length == "number") {
        r && (e = r);
        var i = 0, n = /* @__PURE__ */ s(function() {
        }, "F");
        return { s: n, n: /* @__PURE__ */ s(function() {
          return i >= e.length ? { done: !0 } : { done: !1, value: e[i++] };
        }, "n"), e: /* @__PURE__ */ s(function(c) {
          throw c;
        }, "e"), f: n };
      }
      throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    var a = !0, o = !1, u;
    return { s: /* @__PURE__ */ s(function() {
      r = r.call(e);
    }, "s"), n: /* @__PURE__ */ s(function() {
      var c = r.next();
      return a = c.done, c;
    }, "n"), e: /* @__PURE__ */ s(function(c) {
      o = !0, u = c;
    }, "e"), f: /* @__PURE__ */ s(function() {
      try {
        !a && r.return != null && r.return();
      } finally {
        if (o) throw u;
      }
    }, "f") };
  }
  s(qfe, "_createForOfIteratorHelper");
  function Ufe(e, t) {
    if (e) {
      if (typeof e == "string") return dM(e, t);
      var r = Object.prototype.toString.call(e).slice(8, -1);
      if (r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set") return Array.from(e);
      if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return dM(e, t);
    }
  }
  s(Ufe, "_unsupportedIterableToArray");
  function dM(e, t) {
    (t == null || t > e.length) && (t = e.length);
    for (var r = 0, i = new Array(t); r < t; r++) i[r] = e[r];
    return i;
  }
  s(dM, "_arrayLikeToArray");
  var jfe = gg(), yM = Ai(), mM = yM.erase, Vfe = yM.cursor, Kfe = /* @__PURE__ */ s((e) => [...jfe(e)].length, "width");
  gM.exports = function(e, t) {
    if (!t) return mM.line + Vfe.to(0);
    let r = 0, i = e.split(/\r?\n/);
    var n = qfe(i), a;
    try {
      for (n.s(); !(a = n.n()).done; ) {
        let o = a.value;
        r += 1 + Math.floor(Math.max(Kfe(o) - 1, 0) / t);
      }
    } catch (o) {
      n.e(o);
    } finally {
      n.f();
    }
    return mM.lines(r);
  };
});

// ../node_modules/prompts/dist/util/figures.js
var QE = b((xbt, bM) => {
  "use strict";
  var qh = {
    arrowUp: "\u2191",
    arrowDown: "\u2193",
    arrowLeft: "\u2190",
    arrowRight: "\u2192",
    radioOn: "\u25C9",
    radioOff: "\u25EF",
    tick: "\u2714",
    cross: "\u2716",
    ellipsis: "\u2026",
    pointerSmall: "\u203A",
    line: "\u2500",
    pointer: "\u276F"
  }, Hfe = {
    arrowUp: qh.arrowUp,
    arrowDown: qh.arrowDown,
    arrowLeft: qh.arrowLeft,
    arrowRight: qh.arrowRight,
    radioOn: "(*)",
    radioOff: "( )",
    tick: "\u221A",
    cross: "\xD7",
    ellipsis: "...",
    pointerSmall: "\xBB",
    line: "\u2500",
    pointer: ">"
  }, zfe = process.platform === "win32" ? Hfe : qh;
  bM.exports = zfe;
});

// ../node_modules/prompts/dist/util/style.js
var SM = b((Cbt, vM) => {
  "use strict";
  var Mf = Ti(), sc = QE(), ZE = Object.freeze({
    password: {
      scale: 1,
      render: /* @__PURE__ */ s((e) => "*".repeat(e.length), "render")
    },
    emoji: {
      scale: 2,
      render: /* @__PURE__ */ s((e) => "\u{1F603}".repeat(e.length), "render")
    },
    invisible: {
      scale: 0,
      render: /* @__PURE__ */ s((e) => "", "render")
    },
    default: {
      scale: 1,
      render: /* @__PURE__ */ s((e) => `${e}`, "render")
    }
  }), Gfe = /* @__PURE__ */ s((e) => ZE[e] || ZE.default, "render"), Uh = Object.freeze({
    aborted: Mf.red(sc.cross),
    done: Mf.green(sc.tick),
    exited: Mf.yellow(sc.cross),
    default: Mf.cyan("?")
  }), Wfe = /* @__PURE__ */ s((e, t, r) => t ? Uh.aborted : r ? Uh.exited : e ? Uh.done : Uh.default, "symbol"), $fe = /* @__PURE__ */ s((e) => Mf.
  gray(e ? sc.ellipsis : sc.pointerSmall), "delimiter"), Xfe = /* @__PURE__ */ s((e, t) => Mf.gray(e ? t ? sc.pointerSmall : "+" : sc.line),
  "item");
  vM.exports = {
    styles: ZE,
    render: Gfe,
    symbols: Uh,
    symbol: Wfe,
    delimiter: $fe,
    item: Xfe
  };
});

// ../node_modules/prompts/dist/util/lines.js
var EM = b((Dbt, TM) => {
  "use strict";
  var Yfe = gg();
  TM.exports = function(e, t) {
    let r = String(Yfe(e) || "").split(/\r?\n/);
    return t ? r.map((i) => Math.ceil(i.length / t)).reduce((i, n) => i + n) : r.length;
  };
});

// ../node_modules/prompts/dist/util/wrap.js
var xM = b((wbt, AM) => {
  "use strict";
  AM.exports = (e, t = {}) => {
    let r = Number.isSafeInteger(parseInt(t.margin)) ? new Array(parseInt(t.margin)).fill(" ").join("") : t.margin || "", i = t.width;
    return (e || "").split(/\r?\n/g).map((n) => n.split(/\s+/g).reduce((a, o) => (o.length + r.length >= i || a[a.length - 1].length + o.length +
    1 < i ? a[a.length - 1] += ` ${o}` : a.push(`${r}${o}`), a), [r]).join(`
`)).join(`
`);
  };
});

// ../node_modules/prompts/dist/util/entriesToDisplay.js
var PM = b((Obt, CM) => {
  "use strict";
  CM.exports = (e, t, r) => {
    r = r || t;
    let i = Math.min(t - r, e - Math.floor(r / 2));
    i < 0 && (i = 0);
    let n = Math.min(i + r, t);
    return {
      startIndex: i,
      endIndex: n
    };
  };
});

// ../node_modules/prompts/dist/util/index.js
var Va = b((kbt, DM) => {
  "use strict";
  DM.exports = {
    action: fM(),
    clear: _M(),
    style: SM(),
    strip: gg(),
    figures: QE(),
    lines: EM(),
    wrap: xM(),
    entriesToDisplay: PM()
  };
});

// ../node_modules/prompts/dist/elements/prompt.js
var uu = b((Ibt, kM) => {
  "use strict";
  var wM = require("readline"), Jfe = Va(), Qfe = Jfe.action, Zfe = require("events"), OM = Ai(), epe = OM.beep, tpe = OM.cursor, rpe = Ti(),
  eA = class extends Zfe {
    static {
      s(this, "Prompt");
    }
    constructor(t = {}) {
      super(), this.firstRender = !0, this.in = t.stdin || process.stdin, this.out = t.stdout || process.stdout, this.onRender = (t.onRender ||
      (() => {
      })).bind(this);
      let r = wM.createInterface({
        input: this.in,
        escapeCodeTimeout: 50
      });
      wM.emitKeypressEvents(this.in, r), this.in.isTTY && this.in.setRawMode(!0);
      let i = ["SelectPrompt", "MultiselectPrompt"].indexOf(this.constructor.name) > -1, n = /* @__PURE__ */ s((a, o) => {
        let u = Qfe(o, i);
        u === !1 ? this._ && this._(a, o) : typeof this[u] == "function" ? this[u](o) : this.bell();
      }, "keypress");
      this.close = () => {
        this.out.write(tpe.show), this.in.removeListener("keypress", n), this.in.isTTY && this.in.setRawMode(!1), r.close(), this.emit(this.
        aborted ? "abort" : this.exited ? "exit" : "submit", this.value), this.closed = !0;
      }, this.in.on("keypress", n);
    }
    fire() {
      this.emit("state", {
        value: this.value,
        aborted: !!this.aborted,
        exited: !!this.exited
      });
    }
    bell() {
      this.out.write(epe);
    }
    render() {
      this.onRender(rpe), this.firstRender && (this.firstRender = !1);
    }
  };
  kM.exports = eA;
});

// ../node_modules/prompts/dist/elements/text.js
var FM = b((Nbt, LM) => {
  "use strict";
  function IM(e, t, r, i, n, a, o) {
    try {
      var u = e[a](o), l = u.value;
    } catch (c) {
      r(c);
      return;
    }
    u.done ? t(l) : Promise.resolve(l).then(i, n);
  }
  s(IM, "asyncGeneratorStep");
  function RM(e) {
    return function() {
      var t = this, r = arguments;
      return new Promise(function(i, n) {
        var a = e.apply(t, r);
        function o(l) {
          IM(a, i, n, o, u, "next", l);
        }
        s(o, "_next");
        function u(l) {
          IM(a, i, n, o, u, "throw", l);
        }
        s(u, "_throw"), o(void 0);
      });
    };
  }
  s(RM, "_asyncToGenerator");
  var _g = Ti(), ipe = uu(), NM = Ai(), npe = NM.erase, jh = NM.cursor, bg = Va(), tA = bg.style, rA = bg.clear, spe = bg.lines, ape = bg.figures,
  iA = class extends ipe {
    static {
      s(this, "TextPrompt");
    }
    constructor(t = {}) {
      super(t), this.transform = tA.render(t.style), this.scale = this.transform.scale, this.msg = t.message, this.initial = t.initial || "",
      this.validator = t.validate || (() => !0), this.value = "", this.errorMsg = t.error || "Please Enter A Valid Value", this.cursor = +!!this.
      initial, this.cursorOffset = 0, this.clear = rA("", this.out.columns), this.render();
    }
    set value(t) {
      !t && this.initial ? (this.placeholder = !0, this.rendered = _g.gray(this.transform.render(this.initial))) : (this.placeholder = !1, this.
      rendered = this.transform.render(t)), this._value = t, this.fire();
    }
    get value() {
      return this._value;
    }
    reset() {
      this.value = "", this.cursor = +!!this.initial, this.cursorOffset = 0, this.fire(), this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      this.value = this.value || this.initial, this.done = this.aborted = !0, this.error = !1, this.red = !1, this.fire(), this.render(), this.
      out.write(`
`), this.close();
    }
    validate() {
      var t = this;
      return RM(function* () {
        let r = yield t.validator(t.value);
        typeof r == "string" && (t.errorMsg = r, r = !1), t.error = !r;
      })();
    }
    submit() {
      var t = this;
      return RM(function* () {
        if (t.value = t.value || t.initial, t.cursorOffset = 0, t.cursor = t.rendered.length, yield t.validate(), t.error) {
          t.red = !0, t.fire(), t.render();
          return;
        }
        t.done = !0, t.aborted = !1, t.fire(), t.render(), t.out.write(`
`), t.close();
      })();
    }
    next() {
      if (!this.placeholder) return this.bell();
      this.value = this.initial, this.cursor = this.rendered.length, this.fire(), this.render();
    }
    moveCursor(t) {
      this.placeholder || (this.cursor = this.cursor + t, this.cursorOffset += t);
    }
    _(t, r) {
      let i = this.value.slice(0, this.cursor), n = this.value.slice(this.cursor);
      this.value = `${i}${t}${n}`, this.red = !1, this.cursor = this.placeholder ? 0 : i.length + 1, this.render();
    }
    delete() {
      if (this.isCursorAtStart()) return this.bell();
      let t = this.value.slice(0, this.cursor - 1), r = this.value.slice(this.cursor);
      this.value = `${t}${r}`, this.red = !1, this.isCursorAtStart() ? this.cursorOffset = 0 : (this.cursorOffset++, this.moveCursor(-1)), this.
      render();
    }
    deleteForward() {
      if (this.cursor * this.scale >= this.rendered.length || this.placeholder) return this.bell();
      let t = this.value.slice(0, this.cursor), r = this.value.slice(this.cursor + 1);
      this.value = `${t}${r}`, this.red = !1, this.isCursorAtEnd() ? this.cursorOffset = 0 : this.cursorOffset++, this.render();
    }
    first() {
      this.cursor = 0, this.render();
    }
    last() {
      this.cursor = this.value.length, this.render();
    }
    left() {
      if (this.cursor <= 0 || this.placeholder) return this.bell();
      this.moveCursor(-1), this.render();
    }
    right() {
      if (this.cursor * this.scale >= this.rendered.length || this.placeholder) return this.bell();
      this.moveCursor(1), this.render();
    }
    isCursorAtStart() {
      return this.cursor === 0 || this.placeholder && this.cursor === 1;
    }
    isCursorAtEnd() {
      return this.cursor === this.rendered.length || this.placeholder && this.cursor === this.rendered.length + 1;
    }
    render() {
      this.closed || (this.firstRender || (this.outputError && this.out.write(jh.down(spe(this.outputError, this.out.columns) - 1) + rA(this.
      outputError, this.out.columns)), this.out.write(rA(this.outputText, this.out.columns))), super.render(), this.outputError = "", this.outputText =
      [tA.symbol(this.done, this.aborted), _g.bold(this.msg), tA.delimiter(this.done), this.red ? _g.red(this.rendered) : this.rendered].join(
      " "), this.error && (this.outputError += this.errorMsg.split(`
`).reduce((t, r, i) => t + `
${i ? " " : ape.pointerSmall} ${_g.red().italic(r)}`, "")), this.out.write(npe.line + jh.to(0) + this.outputText + jh.save + this.outputError +
      jh.restore + jh.move(this.cursorOffset, 0)));
    }
  };
  LM.exports = iA;
});

// ../node_modules/prompts/dist/elements/select.js
var UM = b((Fbt, qM) => {
  "use strict";
  var lu = Ti(), ope = uu(), Vh = Va(), MM = Vh.style, BM = Vh.clear, vg = Vh.figures, upe = Vh.wrap, lpe = Vh.entriesToDisplay, cpe = Ai(),
  fpe = cpe.cursor, nA = class extends ope {
    static {
      s(this, "SelectPrompt");
    }
    constructor(t = {}) {
      super(t), this.msg = t.message, this.hint = t.hint || "- Use arrow-keys. Return to submit.", this.warn = t.warn || "- This option is d\
isabled", this.cursor = t.initial || 0, this.choices = t.choices.map((r, i) => (typeof r == "string" && (r = {
        title: r,
        value: i
      }), {
        title: r && (r.title || r.value || r),
        value: r && (r.value === void 0 ? i : r.value),
        description: r && r.description,
        selected: r && r.selected,
        disabled: r && r.disabled
      })), this.optionsPerPage = t.optionsPerPage || 10, this.value = (this.choices[this.cursor] || {}).value, this.clear = BM("", this.out.
      columns), this.render();
    }
    moveCursor(t) {
      this.cursor = t, this.value = this.choices[t].value, this.fire();
    }
    reset() {
      this.moveCursor(0), this.fire(), this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      this.done = this.aborted = !0, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    submit() {
      this.selection.disabled ? this.bell() : (this.done = !0, this.aborted = !1, this.fire(), this.render(), this.out.write(`
`), this.close());
    }
    first() {
      this.moveCursor(0), this.render();
    }
    last() {
      this.moveCursor(this.choices.length - 1), this.render();
    }
    up() {
      this.cursor === 0 ? this.moveCursor(this.choices.length - 1) : this.moveCursor(this.cursor - 1), this.render();
    }
    down() {
      this.cursor === this.choices.length - 1 ? this.moveCursor(0) : this.moveCursor(this.cursor + 1), this.render();
    }
    next() {
      this.moveCursor((this.cursor + 1) % this.choices.length), this.render();
    }
    _(t, r) {
      if (t === " ") return this.submit();
    }
    get selection() {
      return this.choices[this.cursor];
    }
    render() {
      if (this.closed) return;
      this.firstRender ? this.out.write(fpe.hide) : this.out.write(BM(this.outputText, this.out.columns)), super.render();
      let t = lpe(this.cursor, this.choices.length, this.optionsPerPage), r = t.startIndex, i = t.endIndex;
      if (this.outputText = [MM.symbol(this.done, this.aborted), lu.bold(this.msg), MM.delimiter(!1), this.done ? this.selection.title : this.
      selection.disabled ? lu.yellow(this.warn) : lu.gray(this.hint)].join(" "), !this.done) {
        this.outputText += `
`;
        for (let n = r; n < i; n++) {
          let a, o, u = "", l = this.choices[n];
          n === r && r > 0 ? o = vg.arrowUp : n === i - 1 && i < this.choices.length ? o = vg.arrowDown : o = " ", l.disabled ? (a = this.cursor ===
          n ? lu.gray().underline(l.title) : lu.strikethrough().gray(l.title), o = (this.cursor === n ? lu.bold().gray(vg.pointer) + " " : "\
  ") + o) : (a = this.cursor === n ? lu.cyan().underline(l.title) : l.title, o = (this.cursor === n ? lu.cyan(vg.pointer) + " " : "  ") + o,
          l.description && this.cursor === n && (u = ` - ${l.description}`, (o.length + a.length + u.length >= this.out.columns || l.description.
          split(/\r?\n/).length > 1) && (u = `
` + upe(l.description, {
            margin: 3,
            width: this.out.columns
          })))), this.outputText += `${o} ${a}${lu.gray(u)}
`;
        }
      }
      this.out.write(this.outputText);
    }
  };
  qM.exports = nA;
});

// ../node_modules/prompts/dist/elements/toggle.js
var GM = b((Bbt, zM) => {
  "use strict";
  var Sg = Ti(), ppe = uu(), KM = Va(), jM = KM.style, hpe = KM.clear, HM = Ai(), VM = HM.cursor, dpe = HM.erase, sA = class extends ppe {
    static {
      s(this, "TogglePrompt");
    }
    constructor(t = {}) {
      super(t), this.msg = t.message, this.value = !!t.initial, this.active = t.active || "on", this.inactive = t.inactive || "off", this.initialValue =
      this.value, this.render();
    }
    reset() {
      this.value = this.initialValue, this.fire(), this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      this.done = this.aborted = !0, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    submit() {
      this.done = !0, this.aborted = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    deactivate() {
      if (this.value === !1) return this.bell();
      this.value = !1, this.render();
    }
    activate() {
      if (this.value === !0) return this.bell();
      this.value = !0, this.render();
    }
    delete() {
      this.deactivate();
    }
    left() {
      this.deactivate();
    }
    right() {
      this.activate();
    }
    down() {
      this.deactivate();
    }
    up() {
      this.activate();
    }
    next() {
      this.value = !this.value, this.fire(), this.render();
    }
    _(t, r) {
      if (t === " ")
        this.value = !this.value;
      else if (t === "1")
        this.value = !0;
      else if (t === "0")
        this.value = !1;
      else return this.bell();
      this.render();
    }
    render() {
      this.closed || (this.firstRender ? this.out.write(VM.hide) : this.out.write(hpe(this.outputText, this.out.columns)), super.render(), this.
      outputText = [jM.symbol(this.done, this.aborted), Sg.bold(this.msg), jM.delimiter(this.done), this.value ? this.inactive : Sg.cyan().underline(
      this.inactive), Sg.gray("/"), this.value ? Sg.cyan().underline(this.active) : this.active].join(" "), this.out.write(dpe.line + VM.to(
      0) + this.outputText));
    }
  };
  zM.exports = sA;
});

// ../node_modules/prompts/dist/dateparts/datepart.js
var xo = b((Ubt, WM) => {
  "use strict";
  var aA = class e {
    static {
      s(this, "DatePart");
    }
    constructor({
      token: t,
      date: r,
      parts: i,
      locales: n
    }) {
      this.token = t, this.date = r || /* @__PURE__ */ new Date(), this.parts = i || [this], this.locales = n || {};
    }
    up() {
    }
    down() {
    }
    next() {
      let t = this.parts.indexOf(this);
      return this.parts.find((r, i) => i > t && r instanceof e);
    }
    setTo(t) {
    }
    prev() {
      let t = [].concat(this.parts).reverse(), r = t.indexOf(this);
      return t.find((i, n) => n > r && i instanceof e);
    }
    toString() {
      return String(this.date);
    }
  };
  WM.exports = aA;
});

// ../node_modules/prompts/dist/dateparts/meridiem.js
var XM = b((Vbt, $M) => {
  "use strict";
  var mpe = xo(), oA = class extends mpe {
    static {
      s(this, "Meridiem");
    }
    constructor(t = {}) {
      super(t);
    }
    up() {
      this.date.setHours((this.date.getHours() + 12) % 24);
    }
    down() {
      this.up();
    }
    toString() {
      let t = this.date.getHours() > 12 ? "pm" : "am";
      return /\A/.test(this.token) ? t.toUpperCase() : t;
    }
  };
  $M.exports = oA;
});

// ../node_modules/prompts/dist/dateparts/day.js
var JM = b((Hbt, YM) => {
  "use strict";
  var ype = xo(), gpe = /* @__PURE__ */ s((e) => (e = e % 10, e === 1 ? "st" : e === 2 ? "nd" : e === 3 ? "rd" : "th"), "pos"), uA = class extends ype {
    static {
      s(this, "Day");
    }
    constructor(t = {}) {
      super(t);
    }
    up() {
      this.date.setDate(this.date.getDate() + 1);
    }
    down() {
      this.date.setDate(this.date.getDate() - 1);
    }
    setTo(t) {
      this.date.setDate(parseInt(t.substr(-2)));
    }
    toString() {
      let t = this.date.getDate(), r = this.date.getDay();
      return this.token === "DD" ? String(t).padStart(2, "0") : this.token === "Do" ? t + gpe(t) : this.token === "d" ? r + 1 : this.token ===
      "ddd" ? this.locales.weekdaysShort[r] : this.token === "dddd" ? this.locales.weekdays[r] : t;
    }
  };
  YM.exports = uA;
});

// ../node_modules/prompts/dist/dateparts/hours.js
var ZM = b((Gbt, QM) => {
  "use strict";
  var _pe = xo(), lA = class extends _pe {
    static {
      s(this, "Hours");
    }
    constructor(t = {}) {
      super(t);
    }
    up() {
      this.date.setHours(this.date.getHours() + 1);
    }
    down() {
      this.date.setHours(this.date.getHours() - 1);
    }
    setTo(t) {
      this.date.setHours(parseInt(t.substr(-2)));
    }
    toString() {
      let t = this.date.getHours();
      return /h/.test(this.token) && (t = t % 12 || 12), this.token.length > 1 ? String(t).padStart(2, "0") : t;
    }
  };
  QM.exports = lA;
});

// ../node_modules/prompts/dist/dateparts/milliseconds.js
var tB = b(($bt, eB) => {
  "use strict";
  var bpe = xo(), cA = class extends bpe {
    static {
      s(this, "Milliseconds");
    }
    constructor(t = {}) {
      super(t);
    }
    up() {
      this.date.setMilliseconds(this.date.getMilliseconds() + 1);
    }
    down() {
      this.date.setMilliseconds(this.date.getMilliseconds() - 1);
    }
    setTo(t) {
      this.date.setMilliseconds(parseInt(t.substr(-this.token.length)));
    }
    toString() {
      return String(this.date.getMilliseconds()).padStart(4, "0").substr(0, this.token.length);
    }
  };
  eB.exports = cA;
});

// ../node_modules/prompts/dist/dateparts/minutes.js
var iB = b((Ybt, rB) => {
  "use strict";
  var vpe = xo(), fA = class extends vpe {
    static {
      s(this, "Minutes");
    }
    constructor(t = {}) {
      super(t);
    }
    up() {
      this.date.setMinutes(this.date.getMinutes() + 1);
    }
    down() {
      this.date.setMinutes(this.date.getMinutes() - 1);
    }
    setTo(t) {
      this.date.setMinutes(parseInt(t.substr(-2)));
    }
    toString() {
      let t = this.date.getMinutes();
      return this.token.length > 1 ? String(t).padStart(2, "0") : t;
    }
  };
  rB.exports = fA;
});

// ../node_modules/prompts/dist/dateparts/month.js
var sB = b((Qbt, nB) => {
  "use strict";
  var Spe = xo(), pA = class extends Spe {
    static {
      s(this, "Month");
    }
    constructor(t = {}) {
      super(t);
    }
    up() {
      this.date.setMonth(this.date.getMonth() + 1);
    }
    down() {
      this.date.setMonth(this.date.getMonth() - 1);
    }
    setTo(t) {
      t = parseInt(t.substr(-2)) - 1, this.date.setMonth(t < 0 ? 0 : t);
    }
    toString() {
      let t = this.date.getMonth(), r = this.token.length;
      return r === 2 ? String(t + 1).padStart(2, "0") : r === 3 ? this.locales.monthsShort[t] : r === 4 ? this.locales.months[t] : String(t +
      1);
    }
  };
  nB.exports = pA;
});

// ../node_modules/prompts/dist/dateparts/seconds.js
var oB = b((evt, aB) => {
  "use strict";
  var Tpe = xo(), hA = class extends Tpe {
    static {
      s(this, "Seconds");
    }
    constructor(t = {}) {
      super(t);
    }
    up() {
      this.date.setSeconds(this.date.getSeconds() + 1);
    }
    down() {
      this.date.setSeconds(this.date.getSeconds() - 1);
    }
    setTo(t) {
      this.date.setSeconds(parseInt(t.substr(-2)));
    }
    toString() {
      let t = this.date.getSeconds();
      return this.token.length > 1 ? String(t).padStart(2, "0") : t;
    }
  };
  aB.exports = hA;
});

// ../node_modules/prompts/dist/dateparts/year.js
var lB = b((rvt, uB) => {
  "use strict";
  var Epe = xo(), dA = class extends Epe {
    static {
      s(this, "Year");
    }
    constructor(t = {}) {
      super(t);
    }
    up() {
      this.date.setFullYear(this.date.getFullYear() + 1);
    }
    down() {
      this.date.setFullYear(this.date.getFullYear() - 1);
    }
    setTo(t) {
      this.date.setFullYear(t.substr(-4));
    }
    toString() {
      let t = String(this.date.getFullYear()).padStart(4, "0");
      return this.token.length === 2 ? t.substr(-2) : t;
    }
  };
  uB.exports = dA;
});

// ../node_modules/prompts/dist/dateparts/index.js
var fB = b((nvt, cB) => {
  "use strict";
  cB.exports = {
    DatePart: xo(),
    Meridiem: XM(),
    Day: JM(),
    Hours: ZM(),
    Milliseconds: tB(),
    Minutes: iB(),
    Month: sB(),
    Seconds: oB(),
    Year: lB()
  };
});

// ../node_modules/prompts/dist/elements/date.js
var SB = b((svt, vB) => {
  "use strict";
  function pB(e, t, r, i, n, a, o) {
    try {
      var u = e[a](o), l = u.value;
    } catch (c) {
      r(c);
      return;
    }
    u.done ? t(l) : Promise.resolve(l).then(i, n);
  }
  s(pB, "asyncGeneratorStep");
  function hB(e) {
    return function() {
      var t = this, r = arguments;
      return new Promise(function(i, n) {
        var a = e.apply(t, r);
        function o(l) {
          pB(a, i, n, o, u, "next", l);
        }
        s(o, "_next");
        function u(l) {
          pB(a, i, n, o, u, "throw", l);
        }
        s(u, "_throw"), o(void 0);
      });
    };
  }
  s(hB, "_asyncToGenerator");
  var mA = Ti(), Ape = uu(), gA = Va(), dB = gA.style, mB = gA.clear, xpe = gA.figures, bB = Ai(), Cpe = bB.erase, yB = bB.cursor, cu = fB(),
  gB = cu.DatePart, Ppe = cu.Meridiem, Dpe = cu.Day, wpe = cu.Hours, Ope = cu.Milliseconds, kpe = cu.Minutes, Ipe = cu.Month, Rpe = cu.Seconds,
  Npe = cu.Year, Lpe = /\\(.)|"((?:\\["\\]|[^"])+)"|(D[Do]?|d{3,4}|d)|(M{1,4})|(YY(?:YY)?)|([aA])|([Hh]{1,2})|(m{1,2})|(s{1,2})|(S{1,4})|./g,
  _B = {
    1: ({
      token: e
    }) => e.replace(/\\(.)/g, "$1"),
    2: (e) => new Dpe(e),
    // Day // TODO
    3: (e) => new Ipe(e),
    // Month
    4: (e) => new Npe(e),
    // Year
    5: (e) => new Ppe(e),
    // AM/PM // TODO (special)
    6: (e) => new wpe(e),
    // Hours
    7: (e) => new kpe(e),
    // Minutes
    8: (e) => new Rpe(e),
    // Seconds
    9: (e) => new Ope(e)
    // Fractional seconds
  }, Fpe = {
    months: "January,February,March,April,May,June,July,August,September,October,November,December".split(","),
    monthsShort: "Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec".split(","),
    weekdays: "Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday".split(","),
    weekdaysShort: "Sun,Mon,Tue,Wed,Thu,Fri,Sat".split(",")
  }, yA = class extends Ape {
    static {
      s(this, "DatePrompt");
    }
    constructor(t = {}) {
      super(t), this.msg = t.message, this.cursor = 0, this.typed = "", this.locales = Object.assign(Fpe, t.locales), this._date = t.initial ||
      /* @__PURE__ */ new Date(), this.errorMsg = t.error || "Please Enter A Valid Value", this.validator = t.validate || (() => !0), this.mask =
      t.mask || "YYYY-MM-DD HH:mm:ss", this.clear = mB("", this.out.columns), this.render();
    }
    get value() {
      return this.date;
    }
    get date() {
      return this._date;
    }
    set date(t) {
      t && this._date.setTime(t.getTime());
    }
    set mask(t) {
      let r;
      for (this.parts = []; r = Lpe.exec(t); ) {
        let n = r.shift(), a = r.findIndex((o) => o != null);
        this.parts.push(a in _B ? _B[a]({
          token: r[a] || n,
          date: this.date,
          parts: this.parts,
          locales: this.locales
        }) : r[a] || n);
      }
      let i = this.parts.reduce((n, a) => (typeof a == "string" && typeof n[n.length - 1] == "string" ? n[n.length - 1] += a : n.push(a), n),
      []);
      this.parts.splice(0), this.parts.push(...i), this.reset();
    }
    moveCursor(t) {
      this.typed = "", this.cursor = t, this.fire();
    }
    reset() {
      this.moveCursor(this.parts.findIndex((t) => t instanceof gB)), this.fire(), this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      this.done = this.aborted = !0, this.error = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    validate() {
      var t = this;
      return hB(function* () {
        let r = yield t.validator(t.value);
        typeof r == "string" && (t.errorMsg = r, r = !1), t.error = !r;
      })();
    }
    submit() {
      var t = this;
      return hB(function* () {
        if (yield t.validate(), t.error) {
          t.color = "red", t.fire(), t.render();
          return;
        }
        t.done = !0, t.aborted = !1, t.fire(), t.render(), t.out.write(`
`), t.close();
      })();
    }
    up() {
      this.typed = "", this.parts[this.cursor].up(), this.render();
    }
    down() {
      this.typed = "", this.parts[this.cursor].down(), this.render();
    }
    left() {
      let t = this.parts[this.cursor].prev();
      if (t == null) return this.bell();
      this.moveCursor(this.parts.indexOf(t)), this.render();
    }
    right() {
      let t = this.parts[this.cursor].next();
      if (t == null) return this.bell();
      this.moveCursor(this.parts.indexOf(t)), this.render();
    }
    next() {
      let t = this.parts[this.cursor].next();
      this.moveCursor(t ? this.parts.indexOf(t) : this.parts.findIndex((r) => r instanceof gB)), this.render();
    }
    _(t) {
      /\d/.test(t) && (this.typed += t, this.parts[this.cursor].setTo(this.typed), this.render());
    }
    render() {
      this.closed || (this.firstRender ? this.out.write(yB.hide) : this.out.write(mB(this.outputText, this.out.columns)), super.render(), this.
      outputText = [dB.symbol(this.done, this.aborted), mA.bold(this.msg), dB.delimiter(!1), this.parts.reduce((t, r, i) => t.concat(i === this.
      cursor && !this.done ? mA.cyan().underline(r.toString()) : r), []).join("")].join(" "), this.error && (this.outputText += this.errorMsg.
      split(`
`).reduce((t, r, i) => t + `
${i ? " " : xpe.pointerSmall} ${mA.red().italic(r)}`, "")), this.out.write(Cpe.line + yB.to(0) + this.outputText));
    }
  };
  vB.exports = yA;
});

// ../node_modules/prompts/dist/elements/number.js
var DB = b((ovt, PB) => {
  "use strict";
  function TB(e, t, r, i, n, a, o) {
    try {
      var u = e[a](o), l = u.value;
    } catch (c) {
      r(c);
      return;
    }
    u.done ? t(l) : Promise.resolve(l).then(i, n);
  }
  s(TB, "asyncGeneratorStep");
  function EB(e) {
    return function() {
      var t = this, r = arguments;
      return new Promise(function(i, n) {
        var a = e.apply(t, r);
        function o(l) {
          TB(a, i, n, o, u, "next", l);
        }
        s(o, "_next");
        function u(l) {
          TB(a, i, n, o, u, "throw", l);
        }
        s(u, "_throw"), o(void 0);
      });
    };
  }
  s(EB, "_asyncToGenerator");
  var Tg = Ti(), Mpe = uu(), CB = Ai(), Eg = CB.cursor, Bpe = CB.erase, Ag = Va(), _A = Ag.style, qpe = Ag.figures, AB = Ag.clear, Upe = Ag.
  lines, jpe = /[0-9]/, bA = /* @__PURE__ */ s((e) => e !== void 0, "isDef"), xB = /* @__PURE__ */ s((e, t) => {
    let r = Math.pow(10, t);
    return Math.round(e * r) / r;
  }, "round"), vA = class extends Mpe {
    static {
      s(this, "NumberPrompt");
    }
    constructor(t = {}) {
      super(t), this.transform = _A.render(t.style), this.msg = t.message, this.initial = bA(t.initial) ? t.initial : "", this.float = !!t.float,
      this.round = t.round || 2, this.inc = t.increment || 1, this.min = bA(t.min) ? t.min : -1 / 0, this.max = bA(t.max) ? t.max : 1 / 0, this.
      errorMsg = t.error || "Please Enter A Valid Value", this.validator = t.validate || (() => !0), this.color = "cyan", this.value = "", this.
      typed = "", this.lastHit = 0, this.render();
    }
    set value(t) {
      !t && t !== 0 ? (this.placeholder = !0, this.rendered = Tg.gray(this.transform.render(`${this.initial}`)), this._value = "") : (this.placeholder =
      !1, this.rendered = this.transform.render(`${xB(t, this.round)}`), this._value = xB(t, this.round)), this.fire();
    }
    get value() {
      return this._value;
    }
    parse(t) {
      return this.float ? parseFloat(t) : parseInt(t);
    }
    valid(t) {
      return t === "-" || t === "." && this.float || jpe.test(t);
    }
    reset() {
      this.typed = "", this.value = "", this.fire(), this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      let t = this.value;
      this.value = t !== "" ? t : this.initial, this.done = this.aborted = !0, this.error = !1, this.fire(), this.render(), this.out.write(`\

`), this.close();
    }
    validate() {
      var t = this;
      return EB(function* () {
        let r = yield t.validator(t.value);
        typeof r == "string" && (t.errorMsg = r, r = !1), t.error = !r;
      })();
    }
    submit() {
      var t = this;
      return EB(function* () {
        if (yield t.validate(), t.error) {
          t.color = "red", t.fire(), t.render();
          return;
        }
        let r = t.value;
        t.value = r !== "" ? r : t.initial, t.done = !0, t.aborted = !1, t.error = !1, t.fire(), t.render(), t.out.write(`
`), t.close();
      })();
    }
    up() {
      if (this.typed = "", this.value === "" && (this.value = this.min - this.inc), this.value >= this.max) return this.bell();
      this.value += this.inc, this.color = "cyan", this.fire(), this.render();
    }
    down() {
      if (this.typed = "", this.value === "" && (this.value = this.min + this.inc), this.value <= this.min) return this.bell();
      this.value -= this.inc, this.color = "cyan", this.fire(), this.render();
    }
    delete() {
      let t = this.value.toString();
      if (t.length === 0) return this.bell();
      this.value = this.parse(t = t.slice(0, -1)) || "", this.value !== "" && this.value < this.min && (this.value = this.min), this.color =
      "cyan", this.fire(), this.render();
    }
    next() {
      this.value = this.initial, this.fire(), this.render();
    }
    _(t, r) {
      if (!this.valid(t)) return this.bell();
      let i = Date.now();
      if (i - this.lastHit > 1e3 && (this.typed = ""), this.typed += t, this.lastHit = i, this.color = "cyan", t === ".") return this.fire();
      this.value = Math.min(this.parse(this.typed), this.max), this.value > this.max && (this.value = this.max), this.value < this.min && (this.
      value = this.min), this.fire(), this.render();
    }
    render() {
      this.closed || (this.firstRender || (this.outputError && this.out.write(Eg.down(Upe(this.outputError, this.out.columns) - 1) + AB(this.
      outputError, this.out.columns)), this.out.write(AB(this.outputText, this.out.columns))), super.render(), this.outputError = "", this.outputText =
      [_A.symbol(this.done, this.aborted), Tg.bold(this.msg), _A.delimiter(this.done), !this.done || !this.done && !this.placeholder ? Tg[this.
      color]().underline(this.rendered) : this.rendered].join(" "), this.error && (this.outputError += this.errorMsg.split(`
`).reduce((t, r, i) => t + `
${i ? " " : qpe.pointerSmall} ${Tg.red().italic(r)}`, "")), this.out.write(Bpe.line + Eg.to(0) + this.outputText + Eg.save + this.outputError +
      Eg.restore));
    }
  };
  PB.exports = vA;
});

// ../node_modules/prompts/dist/elements/multiselect.js
var TA = b((lvt, kB) => {
  "use strict";
  var Co = Ti(), Vpe = Ai(), Kpe = Vpe.cursor, Hpe = uu(), Kh = Va(), wB = Kh.clear, tl = Kh.figures, OB = Kh.style, zpe = Kh.wrap, Gpe = Kh.
  entriesToDisplay, SA = class extends Hpe {
    static {
      s(this, "MultiselectPrompt");
    }
    constructor(t = {}) {
      super(t), this.msg = t.message, this.cursor = t.cursor || 0, this.scrollIndex = t.cursor || 0, this.hint = t.hint || "", this.warn = t.
      warn || "- This option is disabled -", this.minSelected = t.min, this.showMinError = !1, this.maxChoices = t.max, this.instructions = t.
      instructions, this.optionsPerPage = t.optionsPerPage || 10, this.value = t.choices.map((r, i) => (typeof r == "string" && (r = {
        title: r,
        value: i
      }), {
        title: r && (r.title || r.value || r),
        description: r && r.description,
        value: r && (r.value === void 0 ? i : r.value),
        selected: r && r.selected,
        disabled: r && r.disabled
      })), this.clear = wB("", this.out.columns), t.overrideRender || this.render();
    }
    reset() {
      this.value.map((t) => !t.selected), this.cursor = 0, this.fire(), this.render();
    }
    selected() {
      return this.value.filter((t) => t.selected);
    }
    exit() {
      this.abort();
    }
    abort() {
      this.done = this.aborted = !0, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    submit() {
      let t = this.value.filter((r) => r.selected);
      this.minSelected && t.length < this.minSelected ? (this.showMinError = !0, this.render()) : (this.done = !0, this.aborted = !1, this.fire(),
      this.render(), this.out.write(`
`), this.close());
    }
    first() {
      this.cursor = 0, this.render();
    }
    last() {
      this.cursor = this.value.length - 1, this.render();
    }
    next() {
      this.cursor = (this.cursor + 1) % this.value.length, this.render();
    }
    up() {
      this.cursor === 0 ? this.cursor = this.value.length - 1 : this.cursor--, this.render();
    }
    down() {
      this.cursor === this.value.length - 1 ? this.cursor = 0 : this.cursor++, this.render();
    }
    left() {
      this.value[this.cursor].selected = !1, this.render();
    }
    right() {
      if (this.value.filter((t) => t.selected).length >= this.maxChoices) return this.bell();
      this.value[this.cursor].selected = !0, this.render();
    }
    handleSpaceToggle() {
      let t = this.value[this.cursor];
      if (t.selected)
        t.selected = !1, this.render();
      else {
        if (t.disabled || this.value.filter((r) => r.selected).length >= this.maxChoices)
          return this.bell();
        t.selected = !0, this.render();
      }
    }
    toggleAll() {
      if (this.maxChoices !== void 0 || this.value[this.cursor].disabled)
        return this.bell();
      let t = !this.value[this.cursor].selected;
      this.value.filter((r) => !r.disabled).forEach((r) => r.selected = t), this.render();
    }
    _(t, r) {
      if (t === " ")
        this.handleSpaceToggle();
      else if (t === "a")
        this.toggleAll();
      else
        return this.bell();
    }
    renderInstructions() {
      return this.instructions === void 0 || this.instructions ? typeof this.instructions == "string" ? this.instructions : `
Instructions:
    ${tl.arrowUp}/${tl.arrowDown}: Highlight option
    ${tl.arrowLeft}/${tl.arrowRight}/[space]: Toggle selection
` + (this.maxChoices === void 0 ? `    a: Toggle all
` : "") + "    enter/return: Complete answer" : "";
    }
    renderOption(t, r, i, n) {
      let a = (r.selected ? Co.green(tl.radioOn) : tl.radioOff) + " " + n + " ", o, u;
      return r.disabled ? o = t === i ? Co.gray().underline(r.title) : Co.strikethrough().gray(r.title) : (o = t === i ? Co.cyan().underline(
      r.title) : r.title, t === i && r.description && (u = ` - ${r.description}`, (a.length + o.length + u.length >= this.out.columns || r.description.
      split(/\r?\n/).length > 1) && (u = `
` + zpe(r.description, {
        margin: a.length,
        width: this.out.columns
      })))), a + o + Co.gray(u || "");
    }
    // shared with autocompleteMultiselect
    paginateOptions(t) {
      if (t.length === 0)
        return Co.red("No matches for this query.");
      let r = Gpe(this.cursor, t.length, this.optionsPerPage), i = r.startIndex, n = r.endIndex, a, o = [];
      for (let u = i; u < n; u++)
        u === i && i > 0 ? a = tl.arrowUp : u === n - 1 && n < t.length ? a = tl.arrowDown : a = " ", o.push(this.renderOption(this.cursor, t[u],
        u, a));
      return `
` + o.join(`
`);
    }
    // shared with autocomleteMultiselect
    renderOptions(t) {
      return this.done ? "" : this.paginateOptions(t);
    }
    renderDoneOrInstructions() {
      if (this.done)
        return this.value.filter((r) => r.selected).map((r) => r.title).join(", ");
      let t = [Co.gray(this.hint), this.renderInstructions()];
      return this.value[this.cursor].disabled && t.push(Co.yellow(this.warn)), t.join(" ");
    }
    render() {
      if (this.closed) return;
      this.firstRender && this.out.write(Kpe.hide), super.render();
      let t = [OB.symbol(this.done, this.aborted), Co.bold(this.msg), OB.delimiter(!1), this.renderDoneOrInstructions()].join(" ");
      this.showMinError && (t += Co.red(`You must select a minimum of ${this.minSelected} choices.`), this.showMinError = !1), t += this.renderOptions(
      this.value), this.out.write(this.clear + t), this.clear = wB(t, this.out.columns);
    }
  };
  kB.exports = SA;
});

// ../node_modules/prompts/dist/elements/autocomplete.js
var BB = b((fvt, MB) => {
  "use strict";
  function IB(e, t, r, i, n, a, o) {
    try {
      var u = e[a](o), l = u.value;
    } catch (c) {
      r(c);
      return;
    }
    u.done ? t(l) : Promise.resolve(l).then(i, n);
  }
  s(IB, "asyncGeneratorStep");
  function Wpe(e) {
    return function() {
      var t = this, r = arguments;
      return new Promise(function(i, n) {
        var a = e.apply(t, r);
        function o(l) {
          IB(a, i, n, o, u, "next", l);
        }
        s(o, "_next");
        function u(l) {
          IB(a, i, n, o, u, "throw", l);
        }
        s(u, "_throw"), o(void 0);
      });
    };
  }
  s(Wpe, "_asyncToGenerator");
  var Hh = Ti(), $pe = uu(), FB = Ai(), Xpe = FB.erase, RB = FB.cursor, zh = Va(), EA = zh.style, NB = zh.clear, AA = zh.figures, Ype = zh.wrap,
  Jpe = zh.entriesToDisplay, LB = /* @__PURE__ */ s((e, t) => e[t] && (e[t].value || e[t].title || e[t]), "getVal"), Qpe = /* @__PURE__ */ s(
  (e, t) => e[t] && (e[t].title || e[t].value || e[t]), "getTitle"), Zpe = /* @__PURE__ */ s((e, t) => {
    let r = e.findIndex((i) => i.value === t || i.title === t);
    return r > -1 ? r : void 0;
  }, "getIndex"), xA = class extends $pe {
    static {
      s(this, "AutocompletePrompt");
    }
    constructor(t = {}) {
      super(t), this.msg = t.message, this.suggest = t.suggest, this.choices = t.choices, this.initial = typeof t.initial == "number" ? t.initial :
      Zpe(t.choices, t.initial), this.select = this.initial || t.cursor || 0, this.i18n = {
        noMatches: t.noMatches || "no matches found"
      }, this.fallback = t.fallback || this.initial, this.clearFirst = t.clearFirst || !1, this.suggestions = [], this.input = "", this.limit =
      t.limit || 10, this.cursor = 0, this.transform = EA.render(t.style), this.scale = this.transform.scale, this.render = this.render.bind(
      this), this.complete = this.complete.bind(this), this.clear = NB("", this.out.columns), this.complete(this.render), this.render();
    }
    set fallback(t) {
      this._fb = Number.isSafeInteger(parseInt(t)) ? parseInt(t) : t;
    }
    get fallback() {
      let t;
      return typeof this._fb == "number" ? t = this.choices[this._fb] : typeof this._fb == "string" && (t = {
        title: this._fb
      }), t || this._fb || {
        title: this.i18n.noMatches
      };
    }
    moveSelect(t) {
      this.select = t, this.suggestions.length > 0 ? this.value = LB(this.suggestions, t) : this.value = this.fallback.value, this.fire();
    }
    complete(t) {
      var r = this;
      return Wpe(function* () {
        let i = r.completing = r.suggest(r.input, r.choices), n = yield i;
        if (r.completing !== i) return;
        r.suggestions = n.map((o, u, l) => ({
          title: Qpe(l, u),
          value: LB(l, u),
          description: o.description
        })), r.completing = !1;
        let a = Math.max(n.length - 1, 0);
        r.moveSelect(Math.min(a, r.select)), t && t();
      })();
    }
    reset() {
      this.input = "", this.complete(() => {
        this.moveSelect(this.initial !== void 0 ? this.initial : 0), this.render();
      }), this.render();
    }
    exit() {
      this.clearFirst && this.input.length > 0 ? this.reset() : (this.done = this.exited = !0, this.aborted = !1, this.fire(), this.render(),
      this.out.write(`
`), this.close());
    }
    abort() {
      this.done = this.aborted = !0, this.exited = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    submit() {
      this.done = !0, this.aborted = this.exited = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    _(t, r) {
      let i = this.input.slice(0, this.cursor), n = this.input.slice(this.cursor);
      this.input = `${i}${t}${n}`, this.cursor = i.length + 1, this.complete(this.render), this.render();
    }
    delete() {
      if (this.cursor === 0) return this.bell();
      let t = this.input.slice(0, this.cursor - 1), r = this.input.slice(this.cursor);
      this.input = `${t}${r}`, this.complete(this.render), this.cursor = this.cursor - 1, this.render();
    }
    deleteForward() {
      if (this.cursor * this.scale >= this.rendered.length) return this.bell();
      let t = this.input.slice(0, this.cursor), r = this.input.slice(this.cursor + 1);
      this.input = `${t}${r}`, this.complete(this.render), this.render();
    }
    first() {
      this.moveSelect(0), this.render();
    }
    last() {
      this.moveSelect(this.suggestions.length - 1), this.render();
    }
    up() {
      this.select === 0 ? this.moveSelect(this.suggestions.length - 1) : this.moveSelect(this.select - 1), this.render();
    }
    down() {
      this.select === this.suggestions.length - 1 ? this.moveSelect(0) : this.moveSelect(this.select + 1), this.render();
    }
    next() {
      this.select === this.suggestions.length - 1 ? this.moveSelect(0) : this.moveSelect(this.select + 1), this.render();
    }
    nextPage() {
      this.moveSelect(Math.min(this.select + this.limit, this.suggestions.length - 1)), this.render();
    }
    prevPage() {
      this.moveSelect(Math.max(this.select - this.limit, 0)), this.render();
    }
    left() {
      if (this.cursor <= 0) return this.bell();
      this.cursor = this.cursor - 1, this.render();
    }
    right() {
      if (this.cursor * this.scale >= this.rendered.length) return this.bell();
      this.cursor = this.cursor + 1, this.render();
    }
    renderOption(t, r, i, n) {
      let a, o = i ? AA.arrowUp : n ? AA.arrowDown : " ", u = r ? Hh.cyan().underline(t.title) : t.title;
      return o = (r ? Hh.cyan(AA.pointer) + " " : "  ") + o, t.description && (a = ` - ${t.description}`, (o.length + u.length + a.length >=
      this.out.columns || t.description.split(/\r?\n/).length > 1) && (a = `
` + Ype(t.description, {
        margin: 3,
        width: this.out.columns
      }))), o + " " + u + Hh.gray(a || "");
    }
    render() {
      if (this.closed) return;
      this.firstRender ? this.out.write(RB.hide) : this.out.write(NB(this.outputText, this.out.columns)), super.render();
      let t = Jpe(this.select, this.choices.length, this.limit), r = t.startIndex, i = t.endIndex;
      if (this.outputText = [EA.symbol(this.done, this.aborted, this.exited), Hh.bold(this.msg), EA.delimiter(this.completing), this.done &&
      this.suggestions[this.select] ? this.suggestions[this.select].title : this.rendered = this.transform.render(this.input)].join(" "), !this.
      done) {
        let n = this.suggestions.slice(r, i).map((a, o) => this.renderOption(a, this.select === o + r, o === 0 && r > 0, o + r === i - 1 && i <
        this.choices.length)).join(`
`);
        this.outputText += `
` + (n || Hh.gray(this.fallback.title));
      }
      this.out.write(Xpe.line + RB.to(0) + this.outputText);
    }
  };
  MB.exports = xA;
});

// ../node_modules/prompts/dist/elements/autocompleteMultiselect.js
var VB = b((hvt, jB) => {
  "use strict";
  var fu = Ti(), ehe = Ai(), the = ehe.cursor, rhe = TA(), PA = Va(), qB = PA.clear, UB = PA.style, Bf = PA.figures, CA = class extends rhe {
    static {
      s(this, "AutocompleteMultiselectPrompt");
    }
    constructor(t = {}) {
      t.overrideRender = !0, super(t), this.inputValue = "", this.clear = qB("", this.out.columns), this.filteredOptions = this.value, this.
      render();
    }
    last() {
      this.cursor = this.filteredOptions.length - 1, this.render();
    }
    next() {
      this.cursor = (this.cursor + 1) % this.filteredOptions.length, this.render();
    }
    up() {
      this.cursor === 0 ? this.cursor = this.filteredOptions.length - 1 : this.cursor--, this.render();
    }
    down() {
      this.cursor === this.filteredOptions.length - 1 ? this.cursor = 0 : this.cursor++, this.render();
    }
    left() {
      this.filteredOptions[this.cursor].selected = !1, this.render();
    }
    right() {
      if (this.value.filter((t) => t.selected).length >= this.maxChoices) return this.bell();
      this.filteredOptions[this.cursor].selected = !0, this.render();
    }
    delete() {
      this.inputValue.length && (this.inputValue = this.inputValue.substr(0, this.inputValue.length - 1), this.updateFilteredOptions());
    }
    updateFilteredOptions() {
      let t = this.filteredOptions[this.cursor];
      this.filteredOptions = this.value.filter((i) => this.inputValue ? !!(typeof i.title == "string" && i.title.toLowerCase().includes(this.
      inputValue.toLowerCase()) || typeof i.value == "string" && i.value.toLowerCase().includes(this.inputValue.toLowerCase())) : !0);
      let r = this.filteredOptions.findIndex((i) => i === t);
      this.cursor = r < 0 ? 0 : r, this.render();
    }
    handleSpaceToggle() {
      let t = this.filteredOptions[this.cursor];
      if (t.selected)
        t.selected = !1, this.render();
      else {
        if (t.disabled || this.value.filter((r) => r.selected).length >= this.maxChoices)
          return this.bell();
        t.selected = !0, this.render();
      }
    }
    handleInputChange(t) {
      this.inputValue = this.inputValue + t, this.updateFilteredOptions();
    }
    _(t, r) {
      t === " " ? this.handleSpaceToggle() : this.handleInputChange(t);
    }
    renderInstructions() {
      return this.instructions === void 0 || this.instructions ? typeof this.instructions == "string" ? this.instructions : `
Instructions:
    ${Bf.arrowUp}/${Bf.arrowDown}: Highlight option
    ${Bf.arrowLeft}/${Bf.arrowRight}/[space]: Toggle selection
    [a,b,c]/delete: Filter choices
    enter/return: Complete answer
` : "";
    }
    renderCurrentInput() {
      return `
Filtered results for: ${this.inputValue ? this.inputValue : fu.gray("Enter something to filter")}
`;
    }
    renderOption(t, r, i) {
      let n;
      return r.disabled ? n = t === i ? fu.gray().underline(r.title) : fu.strikethrough().gray(r.title) : n = t === i ? fu.cyan().underline(
      r.title) : r.title, (r.selected ? fu.green(Bf.radioOn) : Bf.radioOff) + "  " + n;
    }
    renderDoneOrInstructions() {
      if (this.done)
        return this.value.filter((r) => r.selected).map((r) => r.title).join(", ");
      let t = [fu.gray(this.hint), this.renderInstructions(), this.renderCurrentInput()];
      return this.filteredOptions.length && this.filteredOptions[this.cursor].disabled && t.push(fu.yellow(this.warn)), t.join(" ");
    }
    render() {
      if (this.closed) return;
      this.firstRender && this.out.write(the.hide), super.render();
      let t = [UB.symbol(this.done, this.aborted), fu.bold(this.msg), UB.delimiter(!1), this.renderDoneOrInstructions()].join(" ");
      this.showMinError && (t += fu.red(`You must select a minimum of ${this.minSelected} choices.`), this.showMinError = !1), t += this.renderOptions(
      this.filteredOptions), this.out.write(this.clear + t), this.clear = qB(t, this.out.columns);
    }
  };
  jB.exports = CA;
});

// ../node_modules/prompts/dist/elements/confirm.js
var XB = b((mvt, $B) => {
  "use strict";
  var KB = Ti(), ihe = uu(), GB = Va(), HB = GB.style, nhe = GB.clear, WB = Ai(), she = WB.erase, zB = WB.cursor, DA = class extends ihe {
    static {
      s(this, "ConfirmPrompt");
    }
    constructor(t = {}) {
      super(t), this.msg = t.message, this.value = t.initial, this.initialValue = !!t.initial, this.yesMsg = t.yes || "yes", this.yesOption =
      t.yesOption || "(Y/n)", this.noMsg = t.no || "no", this.noOption = t.noOption || "(y/N)", this.render();
    }
    reset() {
      this.value = this.initialValue, this.fire(), this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      this.done = this.aborted = !0, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    submit() {
      this.value = this.value || !1, this.done = !0, this.aborted = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    _(t, r) {
      return t.toLowerCase() === "y" ? (this.value = !0, this.submit()) : t.toLowerCase() === "n" ? (this.value = !1, this.submit()) : this.
      bell();
    }
    render() {
      this.closed || (this.firstRender ? this.out.write(zB.hide) : this.out.write(nhe(this.outputText, this.out.columns)), super.render(), this.
      outputText = [HB.symbol(this.done, this.aborted), KB.bold(this.msg), HB.delimiter(this.done), this.done ? this.value ? this.yesMsg : this.
      noMsg : KB.gray(this.initialValue ? this.yesOption : this.noOption)].join(" "), this.out.write(she.line + zB.to(0) + this.outputText));
    }
  };
  $B.exports = DA;
});

// ../node_modules/prompts/dist/elements/index.js
var JB = b((gvt, YB) => {
  "use strict";
  YB.exports = {
    TextPrompt: FM(),
    SelectPrompt: UM(),
    TogglePrompt: GM(),
    DatePrompt: SB(),
    NumberPrompt: DB(),
    MultiselectPrompt: TA(),
    AutocompletePrompt: BB(),
    AutocompleteMultiselectPrompt: VB(),
    ConfirmPrompt: XB()
  };
});

// ../node_modules/prompts/dist/prompts.js
var ZB = b((QB) => {
  "use strict";
  var Os = QB, ahe = JB(), xg = /* @__PURE__ */ s((e) => e, "noop");
  function Po(e, t, r = {}) {
    return new Promise((i, n) => {
      let a = new ahe[e](t), o = r.onAbort || xg, u = r.onSubmit || xg, l = r.onExit || xg;
      a.on("state", t.onState || xg), a.on("submit", (c) => i(u(c))), a.on("exit", (c) => i(l(c))), a.on("abort", (c) => n(o(c)));
    });
  }
  s(Po, "toPrompt");
  Os.text = (e) => Po("TextPrompt", e);
  Os.password = (e) => (e.style = "password", Os.text(e));
  Os.invisible = (e) => (e.style = "invisible", Os.text(e));
  Os.number = (e) => Po("NumberPrompt", e);
  Os.date = (e) => Po("DatePrompt", e);
  Os.confirm = (e) => Po("ConfirmPrompt", e);
  Os.list = (e) => {
    let t = e.separator || ",";
    return Po("TextPrompt", e, {
      onSubmit: /* @__PURE__ */ s((r) => r.split(t).map((i) => i.trim()), "onSubmit")
    });
  };
  Os.toggle = (e) => Po("TogglePrompt", e);
  Os.select = (e) => Po("SelectPrompt", e);
  Os.multiselect = (e) => {
    e.choices = [].concat(e.choices || []);
    let t = /* @__PURE__ */ s((r) => r.filter((i) => i.selected).map((i) => i.value), "toSelected");
    return Po("MultiselectPrompt", e, {
      onAbort: t,
      onSubmit: t
    });
  };
  Os.autocompleteMultiselect = (e) => {
    e.choices = [].concat(e.choices || []);
    let t = /* @__PURE__ */ s((r) => r.filter((i) => i.selected).map((i) => i.value), "toSelected");
    return Po("AutocompleteMultiselectPrompt", e, {
      onAbort: t,
      onSubmit: t
    });
  };
  var ohe = /* @__PURE__ */ s((e, t) => Promise.resolve(t.filter((r) => r.title.slice(0, e.length).toLowerCase() === e.toLowerCase())), "byT\
itle");
  Os.autocomplete = (e) => (e.suggest = e.suggest || ohe, e.choices = [].concat(e.choices || []), Po("AutocompletePrompt", e));
});

// ../node_modules/prompts/dist/index.js
var o3 = b((vvt, a3) => {
  "use strict";
  function e3(e, t) {
    var r = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var i = Object.getOwnPropertySymbols(e);
      t && (i = i.filter(function(n) {
        return Object.getOwnPropertyDescriptor(e, n).enumerable;
      })), r.push.apply(r, i);
    }
    return r;
  }
  s(e3, "ownKeys");
  function t3(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t] != null ? arguments[t] : {};
      t % 2 ? e3(Object(r), !0).forEach(function(i) {
        uhe(e, i, r[i]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : e3(Object(r)).forEach(function(i) {
        Object.defineProperty(e, i, Object.getOwnPropertyDescriptor(r, i));
      });
    }
    return e;
  }
  s(t3, "_objectSpread");
  function uhe(e, t, r) {
    return t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
  }
  s(uhe, "_defineProperty");
  function lhe(e, t) {
    var r = typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
    if (!r) {
      if (Array.isArray(e) || (r = che(e)) || t && e && typeof e.length == "number") {
        r && (e = r);
        var i = 0, n = /* @__PURE__ */ s(function() {
        }, "F");
        return { s: n, n: /* @__PURE__ */ s(function() {
          return i >= e.length ? { done: !0 } : { done: !1, value: e[i++] };
        }, "n"), e: /* @__PURE__ */ s(function(c) {
          throw c;
        }, "e"), f: n };
      }
      throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    var a = !0, o = !1, u;
    return { s: /* @__PURE__ */ s(function() {
      r = r.call(e);
    }, "s"), n: /* @__PURE__ */ s(function() {
      var c = r.next();
      return a = c.done, c;
    }, "n"), e: /* @__PURE__ */ s(function(c) {
      o = !0, u = c;
    }, "e"), f: /* @__PURE__ */ s(function() {
      try {
        !a && r.return != null && r.return();
      } finally {
        if (o) throw u;
      }
    }, "f") };
  }
  s(lhe, "_createForOfIteratorHelper");
  function che(e, t) {
    if (e) {
      if (typeof e == "string") return r3(e, t);
      var r = Object.prototype.toString.call(e).slice(8, -1);
      if (r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set") return Array.from(e);
      if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return r3(e, t);
    }
  }
  s(che, "_unsupportedIterableToArray");
  function r3(e, t) {
    (t == null || t > e.length) && (t = e.length);
    for (var r = 0, i = new Array(t); r < t; r++) i[r] = e[r];
    return i;
  }
  s(r3, "_arrayLikeToArray");
  function i3(e, t, r, i, n, a, o) {
    try {
      var u = e[a](o), l = u.value;
    } catch (c) {
      r(c);
      return;
    }
    u.done ? t(l) : Promise.resolve(l).then(i, n);
  }
  s(i3, "asyncGeneratorStep");
  function n3(e) {
    return function() {
      var t = this, r = arguments;
      return new Promise(function(i, n) {
        var a = e.apply(t, r);
        function o(l) {
          i3(a, i, n, o, u, "next", l);
        }
        s(o, "_next");
        function u(l) {
          i3(a, i, n, o, u, "throw", l);
        }
        s(u, "_throw"), o(void 0);
      });
    };
  }
  s(n3, "_asyncToGenerator");
  var wA = ZB(), fhe = ["suggest", "format", "onState", "validate", "onRender", "type"], s3 = /* @__PURE__ */ s(() => {
  }, "noop");
  function rl() {
    return OA.apply(this, arguments);
  }
  s(rl, "prompt");
  function OA() {
    return OA = n3(function* (e = [], {
      onSubmit: t = s3,
      onCancel: r = s3
    } = {}) {
      let i = {}, n = rl._override || {};
      e = [].concat(e);
      let a, o, u, l, c, p, h = /* @__PURE__ */ function() {
        var f = n3(function* (d, v, E = !1) {
          if (!(!E && d.validate && d.validate(v) !== !0))
            return d.format ? yield d.format(v, i) : v;
        });
        return /* @__PURE__ */ s(function(v, E) {
          return f.apply(this, arguments);
        }, "getFormattedAnswer");
      }();
      var y = lhe(e), _;
      try {
        for (y.s(); !(_ = y.n()).done; ) {
          o = _.value;
          var g = o;
          if (l = g.name, c = g.type, typeof c == "function" && (c = yield c(a, t3({}, i), o), o.type = c), !!c) {
            for (let f in o) {
              if (fhe.includes(f)) continue;
              let d = o[f];
              o[f] = typeof d == "function" ? yield d(a, t3({}, i), p) : d;
            }
            if (p = o, typeof o.message != "string")
              throw new Error("prompt message is required");
            var m = o;
            if (l = m.name, c = m.type, wA[c] === void 0)
              throw new Error(`prompt type (${c}) is not defined`);
            if (n[o.name] !== void 0 && (a = yield h(o, n[o.name]), a !== void 0)) {
              i[l] = a;
              continue;
            }
            try {
              a = rl._injected ? phe(rl._injected, o.initial) : yield wA[c](o), i[l] = a = yield h(o, a, !0), u = yield t(o, a, i);
            } catch {
              u = !(yield r(o, i));
            }
            if (u) return i;
          }
        }
      } catch (f) {
        y.e(f);
      } finally {
        y.f();
      }
      return i;
    }), OA.apply(this, arguments);
  }
  s(OA, "_prompt");
  function phe(e, t) {
    let r = e.shift();
    if (r instanceof Error)
      throw r;
    return r === void 0 ? t : r;
  }
  s(phe, "getInjectedAnswer");
  function hhe(e) {
    rl._injected = (rl._injected || []).concat(e);
  }
  s(hhe, "inject");
  function dhe(e) {
    rl._override = Object.assign({}, e);
  }
  s(dhe, "override");
  a3.exports = Object.assign(rl, {
    prompt: rl,
    prompts: wA,
    inject: hhe,
    override: dhe
  });
});

// ../node_modules/prompts/lib/util/action.js
var l3 = b((Tvt, u3) => {
  "use strict";
  u3.exports = (e, t) => {
    if (!(e.meta && e.name !== "escape")) {
      if (e.ctrl) {
        if (e.name === "a") return "first";
        if (e.name === "c" || e.name === "d") return "abort";
        if (e.name === "e") return "last";
        if (e.name === "g") return "reset";
      }
      if (t) {
        if (e.name === "j") return "down";
        if (e.name === "k") return "up";
      }
      return e.name === "return" || e.name === "enter" ? "submit" : e.name === "backspace" ? "delete" : e.name === "delete" ? "deleteForward" :
      e.name === "abort" ? "abort" : e.name === "escape" ? "exit" : e.name === "tab" ? "next" : e.name === "pagedown" ? "nextPage" : e.name ===
      "pageup" ? "prevPage" : e.name === "home" ? "home" : e.name === "end" ? "end" : e.name === "up" ? "up" : e.name === "down" ? "down" : e.
      name === "right" ? "right" : e.name === "left" ? "left" : !1;
    }
  };
});

// ../node_modules/prompts/lib/util/strip.js
var Cg = b((Evt, c3) => {
  "use strict";
  c3.exports = (e) => {
    let t = [
      "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
      "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PRZcf-ntqry=><~]))"
    ].join("|"), r = new RegExp(t, "g");
    return typeof e == "string" ? e.replace(r, "") : e;
  };
});

// ../node_modules/prompts/lib/util/clear.js
var h3 = b((Avt, p3) => {
  "use strict";
  var mhe = Cg(), { erase: f3, cursor: yhe } = Ai(), ghe = /* @__PURE__ */ s((e) => [...mhe(e)].length, "width");
  p3.exports = function(e, t) {
    if (!t) return f3.line + yhe.to(0);
    let r = 0, i = e.split(/\r?\n/);
    for (let n of i)
      r += 1 + Math.floor(Math.max(ghe(n) - 1, 0) / t);
    return f3.lines(r);
  };
});

// ../node_modules/prompts/lib/util/figures.js
var kA = b((Cvt, d3) => {
  "use strict";
  var Gh = {
    arrowUp: "\u2191",
    arrowDown: "\u2193",
    arrowLeft: "\u2190",
    arrowRight: "\u2192",
    radioOn: "\u25C9",
    radioOff: "\u25EF",
    tick: "\u2714",
    cross: "\u2716",
    ellipsis: "\u2026",
    pointerSmall: "\u203A",
    line: "\u2500",
    pointer: "\u276F"
  }, _he = {
    arrowUp: Gh.arrowUp,
    arrowDown: Gh.arrowDown,
    arrowLeft: Gh.arrowLeft,
    arrowRight: Gh.arrowRight,
    radioOn: "(*)",
    radioOff: "( )",
    tick: "\u221A",
    cross: "\xD7",
    ellipsis: "...",
    pointerSmall: "\xBB",
    line: "\u2500",
    pointer: ">"
  }, bhe = process.platform === "win32" ? _he : Gh;
  d3.exports = bhe;
});

// ../node_modules/prompts/lib/util/style.js
var y3 = b((Pvt, m3) => {
  "use strict";
  var qf = Ti(), ac = kA(), IA = Object.freeze({
    password: { scale: 1, render: /* @__PURE__ */ s((e) => "*".repeat(e.length), "render") },
    emoji: { scale: 2, render: /* @__PURE__ */ s((e) => "\u{1F603}".repeat(e.length), "render") },
    invisible: { scale: 0, render: /* @__PURE__ */ s((e) => "", "render") },
    default: { scale: 1, render: /* @__PURE__ */ s((e) => `${e}`, "render") }
  }), vhe = /* @__PURE__ */ s((e) => IA[e] || IA.default, "render"), Wh = Object.freeze({
    aborted: qf.red(ac.cross),
    done: qf.green(ac.tick),
    exited: qf.yellow(ac.cross),
    default: qf.cyan("?")
  }), She = /* @__PURE__ */ s((e, t, r) => t ? Wh.aborted : r ? Wh.exited : e ? Wh.done : Wh.default, "symbol"), The = /* @__PURE__ */ s((e) => qf.
  gray(e ? ac.ellipsis : ac.pointerSmall), "delimiter"), Ehe = /* @__PURE__ */ s((e, t) => qf.gray(e ? t ? ac.pointerSmall : "+" : ac.line),
  "item");
  m3.exports = {
    styles: IA,
    render: vhe,
    symbols: Wh,
    symbol: She,
    delimiter: The,
    item: Ehe
  };
});

// ../node_modules/prompts/lib/util/lines.js
var _3 = b((wvt, g3) => {
  "use strict";
  var Ahe = Cg();
  g3.exports = function(e, t) {
    let r = String(Ahe(e) || "").split(/\r?\n/);
    return t ? r.map((i) => Math.ceil(i.length / t)).reduce((i, n) => i + n) : r.length;
  };
});

// ../node_modules/prompts/lib/util/wrap.js
var v3 = b((Ovt, b3) => {
  "use strict";
  b3.exports = (e, t = {}) => {
    let r = Number.isSafeInteger(parseInt(t.margin)) ? new Array(parseInt(t.margin)).fill(" ").join("") : t.margin || "", i = t.width;
    return (e || "").split(/\r?\n/g).map((n) => n.split(/\s+/g).reduce((a, o) => (o.length + r.length >= i || a[a.length - 1].length + o.length +
    1 < i ? a[a.length - 1] += ` ${o}` : a.push(`${r}${o}`), a), [r]).join(`
`)).join(`
`);
  };
});

// ../node_modules/prompts/lib/util/entriesToDisplay.js
var T3 = b((kvt, S3) => {
  "use strict";
  S3.exports = (e, t, r) => {
    r = r || t;
    let i = Math.min(t - r, e - Math.floor(r / 2));
    i < 0 && (i = 0);
    let n = Math.min(i + r, t);
    return { startIndex: i, endIndex: n };
  };
});

// ../node_modules/prompts/lib/util/index.js
var Ka = b((Ivt, E3) => {
  "use strict";
  E3.exports = {
    action: l3(),
    clear: h3(),
    style: y3(),
    strip: Cg(),
    figures: kA(),
    lines: _3(),
    wrap: v3(),
    entriesToDisplay: T3()
  };
});

// ../node_modules/prompts/lib/elements/prompt.js
var pu = b((Rvt, x3) => {
  "use strict";
  var A3 = require("readline"), { action: xhe } = Ka(), Che = require("events"), { beep: Phe, cursor: Dhe } = Ai(), whe = Ti(), RA = class extends Che {
    static {
      s(this, "Prompt");
    }
    constructor(t = {}) {
      super(), this.firstRender = !0, this.in = t.stdin || process.stdin, this.out = t.stdout || process.stdout, this.onRender = (t.onRender ||
      (() => {
      })).bind(this);
      let r = A3.createInterface({ input: this.in, escapeCodeTimeout: 50 });
      A3.emitKeypressEvents(this.in, r), this.in.isTTY && this.in.setRawMode(!0);
      let i = ["SelectPrompt", "MultiselectPrompt"].indexOf(this.constructor.name) > -1, n = /* @__PURE__ */ s((a, o) => {
        let u = xhe(o, i);
        u === !1 ? this._ && this._(a, o) : typeof this[u] == "function" ? this[u](o) : this.bell();
      }, "keypress");
      this.close = () => {
        this.out.write(Dhe.show), this.in.removeListener("keypress", n), this.in.isTTY && this.in.setRawMode(!1), r.close(), this.emit(this.
        aborted ? "abort" : this.exited ? "exit" : "submit", this.value), this.closed = !0;
      }, this.in.on("keypress", n);
    }
    fire() {
      this.emit("state", {
        value: this.value,
        aborted: !!this.aborted,
        exited: !!this.exited
      });
    }
    bell() {
      this.out.write(Phe);
    }
    render() {
      this.onRender(whe), this.firstRender && (this.firstRender = !1);
    }
  };
  x3.exports = RA;
});

// ../node_modules/prompts/lib/elements/text.js
var P3 = b((Lvt, C3) => {
  var Pg = Ti(), Ohe = pu(), { erase: khe, cursor: $h } = Ai(), { style: NA, clear: LA, lines: Ihe, figures: Rhe } = Ka(), FA = class extends Ohe {
    static {
      s(this, "TextPrompt");
    }
    constructor(t = {}) {
      super(t), this.transform = NA.render(t.style), this.scale = this.transform.scale, this.msg = t.message, this.initial = t.initial || "",
      this.validator = t.validate || (() => !0), this.value = "", this.errorMsg = t.error || "Please Enter A Valid Value", this.cursor = +!!this.
      initial, this.cursorOffset = 0, this.clear = LA("", this.out.columns), this.render();
    }
    set value(t) {
      !t && this.initial ? (this.placeholder = !0, this.rendered = Pg.gray(this.transform.render(this.initial))) : (this.placeholder = !1, this.
      rendered = this.transform.render(t)), this._value = t, this.fire();
    }
    get value() {
      return this._value;
    }
    reset() {
      this.value = "", this.cursor = +!!this.initial, this.cursorOffset = 0, this.fire(), this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      this.value = this.value || this.initial, this.done = this.aborted = !0, this.error = !1, this.red = !1, this.fire(), this.render(), this.
      out.write(`
`), this.close();
    }
    async validate() {
      let t = await this.validator(this.value);
      typeof t == "string" && (this.errorMsg = t, t = !1), this.error = !t;
    }
    async submit() {
      if (this.value = this.value || this.initial, this.cursorOffset = 0, this.cursor = this.rendered.length, await this.validate(), this.error) {
        this.red = !0, this.fire(), this.render();
        return;
      }
      this.done = !0, this.aborted = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    next() {
      if (!this.placeholder) return this.bell();
      this.value = this.initial, this.cursor = this.rendered.length, this.fire(), this.render();
    }
    moveCursor(t) {
      this.placeholder || (this.cursor = this.cursor + t, this.cursorOffset += t);
    }
    _(t, r) {
      let i = this.value.slice(0, this.cursor), n = this.value.slice(this.cursor);
      this.value = `${i}${t}${n}`, this.red = !1, this.cursor = this.placeholder ? 0 : i.length + 1, this.render();
    }
    delete() {
      if (this.isCursorAtStart()) return this.bell();
      let t = this.value.slice(0, this.cursor - 1), r = this.value.slice(this.cursor);
      this.value = `${t}${r}`, this.red = !1, this.isCursorAtStart() ? this.cursorOffset = 0 : (this.cursorOffset++, this.moveCursor(-1)), this.
      render();
    }
    deleteForward() {
      if (this.cursor * this.scale >= this.rendered.length || this.placeholder) return this.bell();
      let t = this.value.slice(0, this.cursor), r = this.value.slice(this.cursor + 1);
      this.value = `${t}${r}`, this.red = !1, this.isCursorAtEnd() ? this.cursorOffset = 0 : this.cursorOffset++, this.render();
    }
    first() {
      this.cursor = 0, this.render();
    }
    last() {
      this.cursor = this.value.length, this.render();
    }
    left() {
      if (this.cursor <= 0 || this.placeholder) return this.bell();
      this.moveCursor(-1), this.render();
    }
    right() {
      if (this.cursor * this.scale >= this.rendered.length || this.placeholder) return this.bell();
      this.moveCursor(1), this.render();
    }
    isCursorAtStart() {
      return this.cursor === 0 || this.placeholder && this.cursor === 1;
    }
    isCursorAtEnd() {
      return this.cursor === this.rendered.length || this.placeholder && this.cursor === this.rendered.length + 1;
    }
    render() {
      this.closed || (this.firstRender || (this.outputError && this.out.write($h.down(Ihe(this.outputError, this.out.columns) - 1) + LA(this.
      outputError, this.out.columns)), this.out.write(LA(this.outputText, this.out.columns))), super.render(), this.outputError = "", this.outputText =
      [
        NA.symbol(this.done, this.aborted),
        Pg.bold(this.msg),
        NA.delimiter(this.done),
        this.red ? Pg.red(this.rendered) : this.rendered
      ].join(" "), this.error && (this.outputError += this.errorMsg.split(`
`).reduce((t, r, i) => t + `
${i ? " " : Rhe.pointerSmall} ${Pg.red().italic(r)}`, "")), this.out.write(khe.line + $h.to(0) + this.outputText + $h.save + this.outputError +
      $h.restore + $h.move(this.cursorOffset, 0)));
    }
  };
  C3.exports = FA;
});

// ../node_modules/prompts/lib/elements/select.js
var k3 = b((Mvt, O3) => {
  "use strict";
  var hu = Ti(), Nhe = pu(), { style: D3, clear: w3, figures: Dg, wrap: Lhe, entriesToDisplay: Fhe } = Ka(), { cursor: Mhe } = Ai(), MA = class extends Nhe {
    static {
      s(this, "SelectPrompt");
    }
    constructor(t = {}) {
      super(t), this.msg = t.message, this.hint = t.hint || "- Use arrow-keys. Return to submit.", this.warn = t.warn || "- This option is d\
isabled", this.cursor = t.initial || 0, this.choices = t.choices.map((r, i) => (typeof r == "string" && (r = { title: r, value: i }), {
        title: r && (r.title || r.value || r),
        value: r && (r.value === void 0 ? i : r.value),
        description: r && r.description,
        selected: r && r.selected,
        disabled: r && r.disabled
      })), this.optionsPerPage = t.optionsPerPage || 10, this.value = (this.choices[this.cursor] || {}).value, this.clear = w3("", this.out.
      columns), this.render();
    }
    moveCursor(t) {
      this.cursor = t, this.value = this.choices[t].value, this.fire();
    }
    reset() {
      this.moveCursor(0), this.fire(), this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      this.done = this.aborted = !0, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    submit() {
      this.selection.disabled ? this.bell() : (this.done = !0, this.aborted = !1, this.fire(), this.render(), this.out.write(`
`), this.close());
    }
    first() {
      this.moveCursor(0), this.render();
    }
    last() {
      this.moveCursor(this.choices.length - 1), this.render();
    }
    up() {
      this.cursor === 0 ? this.moveCursor(this.choices.length - 1) : this.moveCursor(this.cursor - 1), this.render();
    }
    down() {
      this.cursor === this.choices.length - 1 ? this.moveCursor(0) : this.moveCursor(this.cursor + 1), this.render();
    }
    next() {
      this.moveCursor((this.cursor + 1) % this.choices.length), this.render();
    }
    _(t, r) {
      if (t === " ") return this.submit();
    }
    get selection() {
      return this.choices[this.cursor];
    }
    render() {
      if (this.closed) return;
      this.firstRender ? this.out.write(Mhe.hide) : this.out.write(w3(this.outputText, this.out.columns)), super.render();
      let { startIndex: t, endIndex: r } = Fhe(this.cursor, this.choices.length, this.optionsPerPage);
      if (this.outputText = [
        D3.symbol(this.done, this.aborted),
        hu.bold(this.msg),
        D3.delimiter(!1),
        this.done ? this.selection.title : this.selection.disabled ? hu.yellow(this.warn) : hu.gray(this.hint)
      ].join(" "), !this.done) {
        this.outputText += `
`;
        for (let i = t; i < r; i++) {
          let n, a, o = "", u = this.choices[i];
          i === t && t > 0 ? a = Dg.arrowUp : i === r - 1 && r < this.choices.length ? a = Dg.arrowDown : a = " ", u.disabled ? (n = this.cursor ===
          i ? hu.gray().underline(u.title) : hu.strikethrough().gray(u.title), a = (this.cursor === i ? hu.bold().gray(Dg.pointer) + " " : "\
  ") + a) : (n = this.cursor === i ? hu.cyan().underline(u.title) : u.title, a = (this.cursor === i ? hu.cyan(Dg.pointer) + " " : "  ") + a,
          u.description && this.cursor === i && (o = ` - ${u.description}`, (a.length + n.length + o.length >= this.out.columns || u.description.
          split(/\r?\n/).length > 1) && (o = `
` + Lhe(u.description, { margin: 3, width: this.out.columns })))), this.outputText += `${a} ${n}${hu.gray(o)}
`;
        }
      }
      this.out.write(this.outputText);
    }
  };
  O3.exports = MA;
});

// ../node_modules/prompts/lib/elements/toggle.js
var L3 = b((qvt, N3) => {
  var wg = Ti(), Bhe = pu(), { style: I3, clear: qhe } = Ka(), { cursor: R3, erase: Uhe } = Ai(), BA = class extends Bhe {
    static {
      s(this, "TogglePrompt");
    }
    constructor(t = {}) {
      super(t), this.msg = t.message, this.value = !!t.initial, this.active = t.active || "on", this.inactive = t.inactive || "off", this.initialValue =
      this.value, this.render();
    }
    reset() {
      this.value = this.initialValue, this.fire(), this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      this.done = this.aborted = !0, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    submit() {
      this.done = !0, this.aborted = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    deactivate() {
      if (this.value === !1) return this.bell();
      this.value = !1, this.render();
    }
    activate() {
      if (this.value === !0) return this.bell();
      this.value = !0, this.render();
    }
    delete() {
      this.deactivate();
    }
    left() {
      this.deactivate();
    }
    right() {
      this.activate();
    }
    down() {
      this.deactivate();
    }
    up() {
      this.activate();
    }
    next() {
      this.value = !this.value, this.fire(), this.render();
    }
    _(t, r) {
      if (t === " ")
        this.value = !this.value;
      else if (t === "1")
        this.value = !0;
      else if (t === "0")
        this.value = !1;
      else return this.bell();
      this.render();
    }
    render() {
      this.closed || (this.firstRender ? this.out.write(R3.hide) : this.out.write(qhe(this.outputText, this.out.columns)), super.render(), this.
      outputText = [
        I3.symbol(this.done, this.aborted),
        wg.bold(this.msg),
        I3.delimiter(this.done),
        this.value ? this.inactive : wg.cyan().underline(this.inactive),
        wg.gray("/"),
        this.value ? wg.cyan().underline(this.active) : this.active
      ].join(" "), this.out.write(Uhe.line + R3.to(0) + this.outputText));
    }
  };
  N3.exports = BA;
});

// ../node_modules/prompts/lib/dateparts/datepart.js
var Do = b((jvt, F3) => {
  "use strict";
  var qA = class e {
    static {
      s(this, "DatePart");
    }
    constructor({ token: t, date: r, parts: i, locales: n }) {
      this.token = t, this.date = r || /* @__PURE__ */ new Date(), this.parts = i || [this], this.locales = n || {};
    }
    up() {
    }
    down() {
    }
    next() {
      let t = this.parts.indexOf(this);
      return this.parts.find((r, i) => i > t && r instanceof e);
    }
    setTo(t) {
    }
    prev() {
      let t = [].concat(this.parts).reverse(), r = t.indexOf(this);
      return t.find((i, n) => n > r && i instanceof e);
    }
    toString() {
      return String(this.date);
    }
  };
  F3.exports = qA;
});

// ../node_modules/prompts/lib/dateparts/meridiem.js
var B3 = b((Kvt, M3) => {
  "use strict";
  var jhe = Do(), UA = class extends jhe {
    static {
      s(this, "Meridiem");
    }
    constructor(t = {}) {
      super(t);
    }
    up() {
      this.date.setHours((this.date.getHours() + 12) % 24);
    }
    down() {
      this.up();
    }
    toString() {
      let t = this.date.getHours() > 12 ? "pm" : "am";
      return /\A/.test(this.token) ? t.toUpperCase() : t;
    }
  };
  M3.exports = UA;
});

// ../node_modules/prompts/lib/dateparts/day.js
var U3 = b((zvt, q3) => {
  "use strict";
  var Vhe = Do(), Khe = /* @__PURE__ */ s((e) => (e = e % 10, e === 1 ? "st" : e === 2 ? "nd" : e === 3 ? "rd" : "th"), "pos"), jA = class extends Vhe {
    static {
      s(this, "Day");
    }
    constructor(t = {}) {
      super(t);
    }
    up() {
      this.date.setDate(this.date.getDate() + 1);
    }
    down() {
      this.date.setDate(this.date.getDate() - 1);
    }
    setTo(t) {
      this.date.setDate(parseInt(t.substr(-2)));
    }
    toString() {
      let t = this.date.getDate(), r = this.date.getDay();
      return this.token === "DD" ? String(t).padStart(2, "0") : this.token === "Do" ? t + Khe(t) : this.token === "d" ? r + 1 : this.token ===
      "ddd" ? this.locales.weekdaysShort[r] : this.token === "dddd" ? this.locales.weekdays[r] : t;
    }
  };
  q3.exports = jA;
});

// ../node_modules/prompts/lib/dateparts/hours.js
var V3 = b((Wvt, j3) => {
  "use strict";
  var Hhe = Do(), VA = class extends Hhe {
    static {
      s(this, "Hours");
    }
    constructor(t = {}) {
      super(t);
    }
    up() {
      this.date.setHours(this.date.getHours() + 1);
    }
    down() {
      this.date.setHours(this.date.getHours() - 1);
    }
    setTo(t) {
      this.date.setHours(parseInt(t.substr(-2)));
    }
    toString() {
      let t = this.date.getHours();
      return /h/.test(this.token) && (t = t % 12 || 12), this.token.length > 1 ? String(t).padStart(2, "0") : t;
    }
  };
  j3.exports = VA;
});

// ../node_modules/prompts/lib/dateparts/milliseconds.js
var H3 = b((Xvt, K3) => {
  "use strict";
  var zhe = Do(), KA = class extends zhe {
    static {
      s(this, "Milliseconds");
    }
    constructor(t = {}) {
      super(t);
    }
    up() {
      this.date.setMilliseconds(this.date.getMilliseconds() + 1);
    }
    down() {
      this.date.setMilliseconds(this.date.getMilliseconds() - 1);
    }
    setTo(t) {
      this.date.setMilliseconds(parseInt(t.substr(-this.token.length)));
    }
    toString() {
      return String(this.date.getMilliseconds()).padStart(4, "0").substr(0, this.token.length);
    }
  };
  K3.exports = KA;
});

// ../node_modules/prompts/lib/dateparts/minutes.js
var G3 = b((Jvt, z3) => {
  "use strict";
  var Ghe = Do(), HA = class extends Ghe {
    static {
      s(this, "Minutes");
    }
    constructor(t = {}) {
      super(t);
    }
    up() {
      this.date.setMinutes(this.date.getMinutes() + 1);
    }
    down() {
      this.date.setMinutes(this.date.getMinutes() - 1);
    }
    setTo(t) {
      this.date.setMinutes(parseInt(t.substr(-2)));
    }
    toString() {
      let t = this.date.getMinutes();
      return this.token.length > 1 ? String(t).padStart(2, "0") : t;
    }
  };
  z3.exports = HA;
});

// ../node_modules/prompts/lib/dateparts/month.js
var $3 = b((Zvt, W3) => {
  "use strict";
  var Whe = Do(), zA = class extends Whe {
    static {
      s(this, "Month");
    }
    constructor(t = {}) {
      super(t);
    }
    up() {
      this.date.setMonth(this.date.getMonth() + 1);
    }
    down() {
      this.date.setMonth(this.date.getMonth() - 1);
    }
    setTo(t) {
      t = parseInt(t.substr(-2)) - 1, this.date.setMonth(t < 0 ? 0 : t);
    }
    toString() {
      let t = this.date.getMonth(), r = this.token.length;
      return r === 2 ? String(t + 1).padStart(2, "0") : r === 3 ? this.locales.monthsShort[t] : r === 4 ? this.locales.months[t] : String(t +
      1);
    }
  };
  W3.exports = zA;
});

// ../node_modules/prompts/lib/dateparts/seconds.js
var Y3 = b((tSt, X3) => {
  "use strict";
  var $he = Do(), GA = class extends $he {
    static {
      s(this, "Seconds");
    }
    constructor(t = {}) {
      super(t);
    }
    up() {
      this.date.setSeconds(this.date.getSeconds() + 1);
    }
    down() {
      this.date.setSeconds(this.date.getSeconds() - 1);
    }
    setTo(t) {
      this.date.setSeconds(parseInt(t.substr(-2)));
    }
    toString() {
      let t = this.date.getSeconds();
      return this.token.length > 1 ? String(t).padStart(2, "0") : t;
    }
  };
  X3.exports = GA;
});

// ../node_modules/prompts/lib/dateparts/year.js
var Q3 = b((iSt, J3) => {
  "use strict";
  var Xhe = Do(), WA = class extends Xhe {
    static {
      s(this, "Year");
    }
    constructor(t = {}) {
      super(t);
    }
    up() {
      this.date.setFullYear(this.date.getFullYear() + 1);
    }
    down() {
      this.date.setFullYear(this.date.getFullYear() - 1);
    }
    setTo(t) {
      this.date.setFullYear(t.substr(-4));
    }
    toString() {
      let t = String(this.date.getFullYear()).padStart(4, "0");
      return this.token.length === 2 ? t.substr(-2) : t;
    }
  };
  J3.exports = WA;
});

// ../node_modules/prompts/lib/dateparts/index.js
var eq = b((sSt, Z3) => {
  "use strict";
  Z3.exports = {
    DatePart: Do(),
    Meridiem: B3(),
    Day: U3(),
    Hours: V3(),
    Milliseconds: H3(),
    Minutes: G3(),
    Month: $3(),
    Seconds: Y3(),
    Year: Q3()
  };
});

// ../node_modules/prompts/lib/elements/date.js
var oq = b((aSt, aq) => {
  "use strict";
  var $A = Ti(), Yhe = pu(), { style: tq, clear: rq, figures: Jhe } = Ka(), { erase: Qhe, cursor: iq } = Ai(), { DatePart: nq, Meridiem: Zhe,
  Day: ede, Hours: tde, Milliseconds: rde, Minutes: ide, Month: nde, Seconds: sde, Year: ade } = eq(), ode = /\\(.)|"((?:\\["\\]|[^"])+)"|(D[Do]?|d{3,4}|d)|(M{1,4})|(YY(?:YY)?)|([aA])|([Hh]{1,2})|(m{1,2})|(s{1,2})|(S{1,4})|./g,
  sq = {
    1: ({ token: e }) => e.replace(/\\(.)/g, "$1"),
    2: (e) => new ede(e),
    // Day // TODO
    3: (e) => new nde(e),
    // Month
    4: (e) => new ade(e),
    // Year
    5: (e) => new Zhe(e),
    // AM/PM // TODO (special)
    6: (e) => new tde(e),
    // Hours
    7: (e) => new ide(e),
    // Minutes
    8: (e) => new sde(e),
    // Seconds
    9: (e) => new rde(e)
    // Fractional seconds
  }, ude = {
    months: "January,February,March,April,May,June,July,August,September,October,November,December".split(","),
    monthsShort: "Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec".split(","),
    weekdays: "Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday".split(","),
    weekdaysShort: "Sun,Mon,Tue,Wed,Thu,Fri,Sat".split(",")
  }, XA = class extends Yhe {
    static {
      s(this, "DatePrompt");
    }
    constructor(t = {}) {
      super(t), this.msg = t.message, this.cursor = 0, this.typed = "", this.locales = Object.assign(ude, t.locales), this._date = t.initial ||
      /* @__PURE__ */ new Date(), this.errorMsg = t.error || "Please Enter A Valid Value", this.validator = t.validate || (() => !0), this.mask =
      t.mask || "YYYY-MM-DD HH:mm:ss", this.clear = rq("", this.out.columns), this.render();
    }
    get value() {
      return this.date;
    }
    get date() {
      return this._date;
    }
    set date(t) {
      t && this._date.setTime(t.getTime());
    }
    set mask(t) {
      let r;
      for (this.parts = []; r = ode.exec(t); ) {
        let n = r.shift(), a = r.findIndex((o) => o != null);
        this.parts.push(a in sq ? sq[a]({ token: r[a] || n, date: this.date, parts: this.parts, locales: this.locales }) : r[a] || n);
      }
      let i = this.parts.reduce((n, a) => (typeof a == "string" && typeof n[n.length - 1] == "string" ? n[n.length - 1] += a : n.push(a), n),
      []);
      this.parts.splice(0), this.parts.push(...i), this.reset();
    }
    moveCursor(t) {
      this.typed = "", this.cursor = t, this.fire();
    }
    reset() {
      this.moveCursor(this.parts.findIndex((t) => t instanceof nq)), this.fire(), this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      this.done = this.aborted = !0, this.error = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    async validate() {
      let t = await this.validator(this.value);
      typeof t == "string" && (this.errorMsg = t, t = !1), this.error = !t;
    }
    async submit() {
      if (await this.validate(), this.error) {
        this.color = "red", this.fire(), this.render();
        return;
      }
      this.done = !0, this.aborted = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    up() {
      this.typed = "", this.parts[this.cursor].up(), this.render();
    }
    down() {
      this.typed = "", this.parts[this.cursor].down(), this.render();
    }
    left() {
      let t = this.parts[this.cursor].prev();
      if (t == null) return this.bell();
      this.moveCursor(this.parts.indexOf(t)), this.render();
    }
    right() {
      let t = this.parts[this.cursor].next();
      if (t == null) return this.bell();
      this.moveCursor(this.parts.indexOf(t)), this.render();
    }
    next() {
      let t = this.parts[this.cursor].next();
      this.moveCursor(t ? this.parts.indexOf(t) : this.parts.findIndex((r) => r instanceof nq)), this.render();
    }
    _(t) {
      /\d/.test(t) && (this.typed += t, this.parts[this.cursor].setTo(this.typed), this.render());
    }
    render() {
      this.closed || (this.firstRender ? this.out.write(iq.hide) : this.out.write(rq(this.outputText, this.out.columns)), super.render(), this.
      outputText = [
        tq.symbol(this.done, this.aborted),
        $A.bold(this.msg),
        tq.delimiter(!1),
        this.parts.reduce((t, r, i) => t.concat(i === this.cursor && !this.done ? $A.cyan().underline(r.toString()) : r), []).join("")
      ].join(" "), this.error && (this.outputText += this.errorMsg.split(`
`).reduce(
        (t, r, i) => t + `
${i ? " " : Jhe.pointerSmall} ${$A.red().italic(r)}`,
        ""
      )), this.out.write(Qhe.line + iq.to(0) + this.outputText));
    }
  };
  aq.exports = XA;
});

// ../node_modules/prompts/lib/elements/number.js
var fq = b((uSt, cq) => {
  var Og = Ti(), lde = pu(), { cursor: kg, erase: cde } = Ai(), { style: YA, figures: fde, clear: uq, lines: pde } = Ka(), hde = /[0-9]/, JA = /* @__PURE__ */ s(
  (e) => e !== void 0, "isDef"), lq = /* @__PURE__ */ s((e, t) => {
    let r = Math.pow(10, t);
    return Math.round(e * r) / r;
  }, "round"), QA = class extends lde {
    static {
      s(this, "NumberPrompt");
    }
    constructor(t = {}) {
      super(t), this.transform = YA.render(t.style), this.msg = t.message, this.initial = JA(t.initial) ? t.initial : "", this.float = !!t.float,
      this.round = t.round || 2, this.inc = t.increment || 1, this.min = JA(t.min) ? t.min : -1 / 0, this.max = JA(t.max) ? t.max : 1 / 0, this.
      errorMsg = t.error || "Please Enter A Valid Value", this.validator = t.validate || (() => !0), this.color = "cyan", this.value = "", this.
      typed = "", this.lastHit = 0, this.render();
    }
    set value(t) {
      !t && t !== 0 ? (this.placeholder = !0, this.rendered = Og.gray(this.transform.render(`${this.initial}`)), this._value = "") : (this.placeholder =
      !1, this.rendered = this.transform.render(`${lq(t, this.round)}`), this._value = lq(t, this.round)), this.fire();
    }
    get value() {
      return this._value;
    }
    parse(t) {
      return this.float ? parseFloat(t) : parseInt(t);
    }
    valid(t) {
      return t === "-" || t === "." && this.float || hde.test(t);
    }
    reset() {
      this.typed = "", this.value = "", this.fire(), this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      let t = this.value;
      this.value = t !== "" ? t : this.initial, this.done = this.aborted = !0, this.error = !1, this.fire(), this.render(), this.out.write(`\

`), this.close();
    }
    async validate() {
      let t = await this.validator(this.value);
      typeof t == "string" && (this.errorMsg = t, t = !1), this.error = !t;
    }
    async submit() {
      if (await this.validate(), this.error) {
        this.color = "red", this.fire(), this.render();
        return;
      }
      let t = this.value;
      this.value = t !== "" ? t : this.initial, this.done = !0, this.aborted = !1, this.error = !1, this.fire(), this.render(), this.out.write(
      `
`), this.close();
    }
    up() {
      if (this.typed = "", this.value === "" && (this.value = this.min - this.inc), this.value >= this.max) return this.bell();
      this.value += this.inc, this.color = "cyan", this.fire(), this.render();
    }
    down() {
      if (this.typed = "", this.value === "" && (this.value = this.min + this.inc), this.value <= this.min) return this.bell();
      this.value -= this.inc, this.color = "cyan", this.fire(), this.render();
    }
    delete() {
      let t = this.value.toString();
      if (t.length === 0) return this.bell();
      this.value = this.parse(t = t.slice(0, -1)) || "", this.value !== "" && this.value < this.min && (this.value = this.min), this.color =
      "cyan", this.fire(), this.render();
    }
    next() {
      this.value = this.initial, this.fire(), this.render();
    }
    _(t, r) {
      if (!this.valid(t)) return this.bell();
      let i = Date.now();
      if (i - this.lastHit > 1e3 && (this.typed = ""), this.typed += t, this.lastHit = i, this.color = "cyan", t === ".") return this.fire();
      this.value = Math.min(this.parse(this.typed), this.max), this.value > this.max && (this.value = this.max), this.value < this.min && (this.
      value = this.min), this.fire(), this.render();
    }
    render() {
      this.closed || (this.firstRender || (this.outputError && this.out.write(kg.down(pde(this.outputError, this.out.columns) - 1) + uq(this.
      outputError, this.out.columns)), this.out.write(uq(this.outputText, this.out.columns))), super.render(), this.outputError = "", this.outputText =
      [
        YA.symbol(this.done, this.aborted),
        Og.bold(this.msg),
        YA.delimiter(this.done),
        !this.done || !this.done && !this.placeholder ? Og[this.color]().underline(this.rendered) : this.rendered
      ].join(" "), this.error && (this.outputError += this.errorMsg.split(`
`).reduce((t, r, i) => t + `
${i ? " " : fde.pointerSmall} ${Og.red().italic(r)}`, "")), this.out.write(cde.line + kg.to(0) + this.outputText + kg.save + this.outputError +
      kg.restore));
    }
  };
  cq.exports = QA;
});

// ../node_modules/prompts/lib/elements/multiselect.js
var ex = b((cSt, dq) => {
  "use strict";
  var wo = Ti(), { cursor: dde } = Ai(), mde = pu(), { clear: pq, figures: il, style: hq, wrap: yde, entriesToDisplay: gde } = Ka(), ZA = class extends mde {
    static {
      s(this, "MultiselectPrompt");
    }
    constructor(t = {}) {
      super(t), this.msg = t.message, this.cursor = t.cursor || 0, this.scrollIndex = t.cursor || 0, this.hint = t.hint || "", this.warn = t.
      warn || "- This option is disabled -", this.minSelected = t.min, this.showMinError = !1, this.maxChoices = t.max, this.instructions = t.
      instructions, this.optionsPerPage = t.optionsPerPage || 10, this.value = t.choices.map((r, i) => (typeof r == "string" && (r = { title: r,
      value: i }), {
        title: r && (r.title || r.value || r),
        description: r && r.description,
        value: r && (r.value === void 0 ? i : r.value),
        selected: r && r.selected,
        disabled: r && r.disabled
      })), this.clear = pq("", this.out.columns), t.overrideRender || this.render();
    }
    reset() {
      this.value.map((t) => !t.selected), this.cursor = 0, this.fire(), this.render();
    }
    selected() {
      return this.value.filter((t) => t.selected);
    }
    exit() {
      this.abort();
    }
    abort() {
      this.done = this.aborted = !0, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    submit() {
      let t = this.value.filter((r) => r.selected);
      this.minSelected && t.length < this.minSelected ? (this.showMinError = !0, this.render()) : (this.done = !0, this.aborted = !1, this.fire(),
      this.render(), this.out.write(`
`), this.close());
    }
    first() {
      this.cursor = 0, this.render();
    }
    last() {
      this.cursor = this.value.length - 1, this.render();
    }
    next() {
      this.cursor = (this.cursor + 1) % this.value.length, this.render();
    }
    up() {
      this.cursor === 0 ? this.cursor = this.value.length - 1 : this.cursor--, this.render();
    }
    down() {
      this.cursor === this.value.length - 1 ? this.cursor = 0 : this.cursor++, this.render();
    }
    left() {
      this.value[this.cursor].selected = !1, this.render();
    }
    right() {
      if (this.value.filter((t) => t.selected).length >= this.maxChoices) return this.bell();
      this.value[this.cursor].selected = !0, this.render();
    }
    handleSpaceToggle() {
      let t = this.value[this.cursor];
      if (t.selected)
        t.selected = !1, this.render();
      else {
        if (t.disabled || this.value.filter((r) => r.selected).length >= this.maxChoices)
          return this.bell();
        t.selected = !0, this.render();
      }
    }
    toggleAll() {
      if (this.maxChoices !== void 0 || this.value[this.cursor].disabled)
        return this.bell();
      let t = !this.value[this.cursor].selected;
      this.value.filter((r) => !r.disabled).forEach((r) => r.selected = t), this.render();
    }
    _(t, r) {
      if (t === " ")
        this.handleSpaceToggle();
      else if (t === "a")
        this.toggleAll();
      else
        return this.bell();
    }
    renderInstructions() {
      return this.instructions === void 0 || this.instructions ? typeof this.instructions == "string" ? this.instructions : `
Instructions:
    ${il.arrowUp}/${il.arrowDown}: Highlight option
    ${il.arrowLeft}/${il.arrowRight}/[space]: Toggle selection
` + (this.maxChoices === void 0 ? `    a: Toggle all
` : "") + "    enter/return: Complete answer" : "";
    }
    renderOption(t, r, i, n) {
      let a = (r.selected ? wo.green(il.radioOn) : il.radioOff) + " " + n + " ", o, u;
      return r.disabled ? o = t === i ? wo.gray().underline(r.title) : wo.strikethrough().gray(r.title) : (o = t === i ? wo.cyan().underline(
      r.title) : r.title, t === i && r.description && (u = ` - ${r.description}`, (a.length + o.length + u.length >= this.out.columns || r.description.
      split(/\r?\n/).length > 1) && (u = `
` + yde(r.description, { margin: a.length, width: this.out.columns })))), a + o + wo.gray(u || "");
    }
    // shared with autocompleteMultiselect
    paginateOptions(t) {
      if (t.length === 0)
        return wo.red("No matches for this query.");
      let { startIndex: r, endIndex: i } = gde(this.cursor, t.length, this.optionsPerPage), n, a = [];
      for (let o = r; o < i; o++)
        o === r && r > 0 ? n = il.arrowUp : o === i - 1 && i < t.length ? n = il.arrowDown : n = " ", a.push(this.renderOption(this.cursor, t[o],
        o, n));
      return `
` + a.join(`
`);
    }
    // shared with autocomleteMultiselect
    renderOptions(t) {
      return this.done ? "" : this.paginateOptions(t);
    }
    renderDoneOrInstructions() {
      if (this.done)
        return this.value.filter((r) => r.selected).map((r) => r.title).join(", ");
      let t = [wo.gray(this.hint), this.renderInstructions()];
      return this.value[this.cursor].disabled && t.push(wo.yellow(this.warn)), t.join(" ");
    }
    render() {
      if (this.closed) return;
      this.firstRender && this.out.write(dde.hide), super.render();
      let t = [
        hq.symbol(this.done, this.aborted),
        wo.bold(this.msg),
        hq.delimiter(!1),
        this.renderDoneOrInstructions()
      ].join(" ");
      this.showMinError && (t += wo.red(`You must select a minimum of ${this.minSelected} choices.`), this.showMinError = !1), t += this.renderOptions(
      this.value), this.out.write(this.clear + t), this.clear = pq(t, this.out.columns);
    }
  };
  dq.exports = ZA;
});

// ../node_modules/prompts/lib/elements/autocomplete.js
var bq = b((pSt, _q) => {
  "use strict";
  var Xh = Ti(), _de = pu(), { erase: bde, cursor: mq } = Ai(), { style: tx, clear: yq, figures: rx, wrap: vde, entriesToDisplay: Sde } = Ka(),
  gq = /* @__PURE__ */ s((e, t) => e[t] && (e[t].value || e[t].title || e[t]), "getVal"), Tde = /* @__PURE__ */ s((e, t) => e[t] && (e[t].title ||
  e[t].value || e[t]), "getTitle"), Ede = /* @__PURE__ */ s((e, t) => {
    let r = e.findIndex((i) => i.value === t || i.title === t);
    return r > -1 ? r : void 0;
  }, "getIndex"), ix = class extends _de {
    static {
      s(this, "AutocompletePrompt");
    }
    constructor(t = {}) {
      super(t), this.msg = t.message, this.suggest = t.suggest, this.choices = t.choices, this.initial = typeof t.initial == "number" ? t.initial :
      Ede(t.choices, t.initial), this.select = this.initial || t.cursor || 0, this.i18n = { noMatches: t.noMatches || "no matches found" }, this.
      fallback = t.fallback || this.initial, this.clearFirst = t.clearFirst || !1, this.suggestions = [], this.input = "", this.limit = t.limit ||
      10, this.cursor = 0, this.transform = tx.render(t.style), this.scale = this.transform.scale, this.render = this.render.bind(this), this.
      complete = this.complete.bind(this), this.clear = yq("", this.out.columns), this.complete(this.render), this.render();
    }
    set fallback(t) {
      this._fb = Number.isSafeInteger(parseInt(t)) ? parseInt(t) : t;
    }
    get fallback() {
      let t;
      return typeof this._fb == "number" ? t = this.choices[this._fb] : typeof this._fb == "string" && (t = { title: this._fb }), t || this.
      _fb || { title: this.i18n.noMatches };
    }
    moveSelect(t) {
      this.select = t, this.suggestions.length > 0 ? this.value = gq(this.suggestions, t) : this.value = this.fallback.value, this.fire();
    }
    async complete(t) {
      let r = this.completing = this.suggest(this.input, this.choices), i = await r;
      if (this.completing !== r) return;
      this.suggestions = i.map((a, o, u) => ({ title: Tde(u, o), value: gq(u, o), description: a.description })), this.completing = !1;
      let n = Math.max(i.length - 1, 0);
      this.moveSelect(Math.min(n, this.select)), t && t();
    }
    reset() {
      this.input = "", this.complete(() => {
        this.moveSelect(this.initial !== void 0 ? this.initial : 0), this.render();
      }), this.render();
    }
    exit() {
      this.clearFirst && this.input.length > 0 ? this.reset() : (this.done = this.exited = !0, this.aborted = !1, this.fire(), this.render(),
      this.out.write(`
`), this.close());
    }
    abort() {
      this.done = this.aborted = !0, this.exited = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    submit() {
      this.done = !0, this.aborted = this.exited = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    _(t, r) {
      let i = this.input.slice(0, this.cursor), n = this.input.slice(this.cursor);
      this.input = `${i}${t}${n}`, this.cursor = i.length + 1, this.complete(this.render), this.render();
    }
    delete() {
      if (this.cursor === 0) return this.bell();
      let t = this.input.slice(0, this.cursor - 1), r = this.input.slice(this.cursor);
      this.input = `${t}${r}`, this.complete(this.render), this.cursor = this.cursor - 1, this.render();
    }
    deleteForward() {
      if (this.cursor * this.scale >= this.rendered.length) return this.bell();
      let t = this.input.slice(0, this.cursor), r = this.input.slice(this.cursor + 1);
      this.input = `${t}${r}`, this.complete(this.render), this.render();
    }
    first() {
      this.moveSelect(0), this.render();
    }
    last() {
      this.moveSelect(this.suggestions.length - 1), this.render();
    }
    up() {
      this.select === 0 ? this.moveSelect(this.suggestions.length - 1) : this.moveSelect(this.select - 1), this.render();
    }
    down() {
      this.select === this.suggestions.length - 1 ? this.moveSelect(0) : this.moveSelect(this.select + 1), this.render();
    }
    next() {
      this.select === this.suggestions.length - 1 ? this.moveSelect(0) : this.moveSelect(this.select + 1), this.render();
    }
    nextPage() {
      this.moveSelect(Math.min(this.select + this.limit, this.suggestions.length - 1)), this.render();
    }
    prevPage() {
      this.moveSelect(Math.max(this.select - this.limit, 0)), this.render();
    }
    left() {
      if (this.cursor <= 0) return this.bell();
      this.cursor = this.cursor - 1, this.render();
    }
    right() {
      if (this.cursor * this.scale >= this.rendered.length) return this.bell();
      this.cursor = this.cursor + 1, this.render();
    }
    renderOption(t, r, i, n) {
      let a, o = i ? rx.arrowUp : n ? rx.arrowDown : " ", u = r ? Xh.cyan().underline(t.title) : t.title;
      return o = (r ? Xh.cyan(rx.pointer) + " " : "  ") + o, t.description && (a = ` - ${t.description}`, (o.length + u.length + a.length >=
      this.out.columns || t.description.split(/\r?\n/).length > 1) && (a = `
` + vde(t.description, { margin: 3, width: this.out.columns }))), o + " " + u + Xh.gray(a || "");
    }
    render() {
      if (this.closed) return;
      this.firstRender ? this.out.write(mq.hide) : this.out.write(yq(this.outputText, this.out.columns)), super.render();
      let { startIndex: t, endIndex: r } = Sde(this.select, this.choices.length, this.limit);
      if (this.outputText = [
        tx.symbol(this.done, this.aborted, this.exited),
        Xh.bold(this.msg),
        tx.delimiter(this.completing),
        this.done && this.suggestions[this.select] ? this.suggestions[this.select].title : this.rendered = this.transform.render(this.input)
      ].join(" "), !this.done) {
        let i = this.suggestions.slice(t, r).map((n, a) => this.renderOption(
          n,
          this.select === a + t,
          a === 0 && t > 0,
          a + t === r - 1 && r < this.choices.length
        )).join(`
`);
        this.outputText += `
` + (i || Xh.gray(this.fallback.title));
      }
      this.out.write(bde.line + mq.to(0) + this.outputText);
    }
  };
  _q.exports = ix;
});

// ../node_modules/prompts/lib/elements/autocompleteMultiselect.js
var Eq = b((dSt, Tq) => {
  "use strict";
  var du = Ti(), { cursor: Ade } = Ai(), xde = ex(), { clear: vq, style: Sq, figures: Uf } = Ka(), nx = class extends xde {
    static {
      s(this, "AutocompleteMultiselectPrompt");
    }
    constructor(t = {}) {
      t.overrideRender = !0, super(t), this.inputValue = "", this.clear = vq("", this.out.columns), this.filteredOptions = this.value, this.
      render();
    }
    last() {
      this.cursor = this.filteredOptions.length - 1, this.render();
    }
    next() {
      this.cursor = (this.cursor + 1) % this.filteredOptions.length, this.render();
    }
    up() {
      this.cursor === 0 ? this.cursor = this.filteredOptions.length - 1 : this.cursor--, this.render();
    }
    down() {
      this.cursor === this.filteredOptions.length - 1 ? this.cursor = 0 : this.cursor++, this.render();
    }
    left() {
      this.filteredOptions[this.cursor].selected = !1, this.render();
    }
    right() {
      if (this.value.filter((t) => t.selected).length >= this.maxChoices) return this.bell();
      this.filteredOptions[this.cursor].selected = !0, this.render();
    }
    delete() {
      this.inputValue.length && (this.inputValue = this.inputValue.substr(0, this.inputValue.length - 1), this.updateFilteredOptions());
    }
    updateFilteredOptions() {
      let t = this.filteredOptions[this.cursor];
      this.filteredOptions = this.value.filter((i) => this.inputValue ? !!(typeof i.title == "string" && i.title.toLowerCase().includes(this.
      inputValue.toLowerCase()) || typeof i.value == "string" && i.value.toLowerCase().includes(this.inputValue.toLowerCase())) : !0);
      let r = this.filteredOptions.findIndex((i) => i === t);
      this.cursor = r < 0 ? 0 : r, this.render();
    }
    handleSpaceToggle() {
      let t = this.filteredOptions[this.cursor];
      if (t.selected)
        t.selected = !1, this.render();
      else {
        if (t.disabled || this.value.filter((r) => r.selected).length >= this.maxChoices)
          return this.bell();
        t.selected = !0, this.render();
      }
    }
    handleInputChange(t) {
      this.inputValue = this.inputValue + t, this.updateFilteredOptions();
    }
    _(t, r) {
      t === " " ? this.handleSpaceToggle() : this.handleInputChange(t);
    }
    renderInstructions() {
      return this.instructions === void 0 || this.instructions ? typeof this.instructions == "string" ? this.instructions : `
Instructions:
    ${Uf.arrowUp}/${Uf.arrowDown}: Highlight option
    ${Uf.arrowLeft}/${Uf.arrowRight}/[space]: Toggle selection
    [a,b,c]/delete: Filter choices
    enter/return: Complete answer
` : "";
    }
    renderCurrentInput() {
      return `
Filtered results for: ${this.inputValue ? this.inputValue : du.gray("Enter something to filter")}
`;
    }
    renderOption(t, r, i) {
      let n;
      return r.disabled ? n = t === i ? du.gray().underline(r.title) : du.strikethrough().gray(r.title) : n = t === i ? du.cyan().underline(
      r.title) : r.title, (r.selected ? du.green(Uf.radioOn) : Uf.radioOff) + "  " + n;
    }
    renderDoneOrInstructions() {
      if (this.done)
        return this.value.filter((r) => r.selected).map((r) => r.title).join(", ");
      let t = [du.gray(this.hint), this.renderInstructions(), this.renderCurrentInput()];
      return this.filteredOptions.length && this.filteredOptions[this.cursor].disabled && t.push(du.yellow(this.warn)), t.join(" ");
    }
    render() {
      if (this.closed) return;
      this.firstRender && this.out.write(Ade.hide), super.render();
      let t = [
        Sq.symbol(this.done, this.aborted),
        du.bold(this.msg),
        Sq.delimiter(!1),
        this.renderDoneOrInstructions()
      ].join(" ");
      this.showMinError && (t += du.red(`You must select a minimum of ${this.minSelected} choices.`), this.showMinError = !1), t += this.renderOptions(
      this.filteredOptions), this.out.write(this.clear + t), this.clear = vq(t, this.out.columns);
    }
  };
  Tq.exports = nx;
});

// ../node_modules/prompts/lib/elements/confirm.js
var Dq = b((ySt, Pq) => {
  var Aq = Ti(), Cde = pu(), { style: xq, clear: Pde } = Ka(), { erase: Dde, cursor: Cq } = Ai(), sx = class extends Cde {
    static {
      s(this, "ConfirmPrompt");
    }
    constructor(t = {}) {
      super(t), this.msg = t.message, this.value = t.initial, this.initialValue = !!t.initial, this.yesMsg = t.yes || "yes", this.yesOption =
      t.yesOption || "(Y/n)", this.noMsg = t.no || "no", this.noOption = t.noOption || "(y/N)", this.render();
    }
    reset() {
      this.value = this.initialValue, this.fire(), this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      this.done = this.aborted = !0, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    submit() {
      this.value = this.value || !1, this.done = !0, this.aborted = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    _(t, r) {
      return t.toLowerCase() === "y" ? (this.value = !0, this.submit()) : t.toLowerCase() === "n" ? (this.value = !1, this.submit()) : this.
      bell();
    }
    render() {
      this.closed || (this.firstRender ? this.out.write(Cq.hide) : this.out.write(Pde(this.outputText, this.out.columns)), super.render(), this.
      outputText = [
        xq.symbol(this.done, this.aborted),
        Aq.bold(this.msg),
        xq.delimiter(this.done),
        this.done ? this.value ? this.yesMsg : this.noMsg : Aq.gray(this.initialValue ? this.yesOption : this.noOption)
      ].join(" "), this.out.write(Dde.line + Cq.to(0) + this.outputText));
    }
  };
  Pq.exports = sx;
});

// ../node_modules/prompts/lib/elements/index.js
var Oq = b((_St, wq) => {
  "use strict";
  wq.exports = {
    TextPrompt: P3(),
    SelectPrompt: k3(),
    TogglePrompt: L3(),
    DatePrompt: oq(),
    NumberPrompt: fq(),
    MultiselectPrompt: ex(),
    AutocompletePrompt: bq(),
    AutocompleteMultiselectPrompt: Eq(),
    ConfirmPrompt: Dq()
  };
});

// ../node_modules/prompts/lib/prompts.js
var Iq = b((kq) => {
  "use strict";
  var ks = kq, wde = Oq(), Ig = /* @__PURE__ */ s((e) => e, "noop");
  function Oo(e, t, r = {}) {
    return new Promise((i, n) => {
      let a = new wde[e](t), o = r.onAbort || Ig, u = r.onSubmit || Ig, l = r.onExit || Ig;
      a.on("state", t.onState || Ig), a.on("submit", (c) => i(u(c))), a.on("exit", (c) => i(l(c))), a.on("abort", (c) => n(o(c)));
    });
  }
  s(Oo, "toPrompt");
  ks.text = (e) => Oo("TextPrompt", e);
  ks.password = (e) => (e.style = "password", ks.text(e));
  ks.invisible = (e) => (e.style = "invisible", ks.text(e));
  ks.number = (e) => Oo("NumberPrompt", e);
  ks.date = (e) => Oo("DatePrompt", e);
  ks.confirm = (e) => Oo("ConfirmPrompt", e);
  ks.list = (e) => {
    let t = e.separator || ",";
    return Oo("TextPrompt", e, {
      onSubmit: /* @__PURE__ */ s((r) => r.split(t).map((i) => i.trim()), "onSubmit")
    });
  };
  ks.toggle = (e) => Oo("TogglePrompt", e);
  ks.select = (e) => Oo("SelectPrompt", e);
  ks.multiselect = (e) => {
    e.choices = [].concat(e.choices || []);
    let t = /* @__PURE__ */ s((r) => r.filter((i) => i.selected).map((i) => i.value), "toSelected");
    return Oo("MultiselectPrompt", e, {
      onAbort: t,
      onSubmit: t
    });
  };
  ks.autocompleteMultiselect = (e) => {
    e.choices = [].concat(e.choices || []);
    let t = /* @__PURE__ */ s((r) => r.filter((i) => i.selected).map((i) => i.value), "toSelected");
    return Oo("AutocompleteMultiselectPrompt", e, {
      onAbort: t,
      onSubmit: t
    });
  };
  var Ode = /* @__PURE__ */ s((e, t) => Promise.resolve(
    t.filter((r) => r.title.slice(0, e.length).toLowerCase() === e.toLowerCase())
  ), "byTitle");
  ks.autocomplete = (e) => (e.suggest = e.suggest || Ode, e.choices = [].concat(e.choices || []), Oo("AutocompletePrompt", e));
});

// ../node_modules/prompts/lib/index.js
var Lq = b((SSt, Nq) => {
  "use strict";
  var ax = Iq(), kde = ["suggest", "format", "onState", "validate", "onRender", "type"], Rq = /* @__PURE__ */ s(() => {
  }, "noop");
  async function nl(e = [], { onSubmit: t = Rq, onCancel: r = Rq } = {}) {
    let i = {}, n = nl._override || {};
    e = [].concat(e);
    let a, o, u, l, c, p, h = /* @__PURE__ */ s(async (y, _, g = !1) => {
      if (!(!g && y.validate && y.validate(_) !== !0))
        return y.format ? await y.format(_, i) : _;
    }, "getFormattedAnswer");
    for (o of e)
      if ({ name: l, type: c } = o, typeof c == "function" && (c = await c(a, { ...i }, o), o.type = c), !!c) {
        for (let y in o) {
          if (kde.includes(y)) continue;
          let _ = o[y];
          o[y] = typeof _ == "function" ? await _(a, { ...i }, p) : _;
        }
        if (p = o, typeof o.message != "string")
          throw new Error("prompt message is required");
        if ({ name: l, type: c } = o, ax[c] === void 0)
          throw new Error(`prompt type (${c}) is not defined`);
        if (n[o.name] !== void 0 && (a = await h(o, n[o.name]), a !== void 0)) {
          i[l] = a;
          continue;
        }
        try {
          a = nl._injected ? Ide(nl._injected, o.initial) : await ax[c](o), i[l] = a = await h(o, a, !0), u = await t(o, a, i);
        } catch {
          u = !await r(o, i);
        }
        if (u) return i;
      }
    return i;
  }
  s(nl, "prompt");
  function Ide(e, t) {
    let r = e.shift();
    if (r instanceof Error)
      throw r;
    return r === void 0 ? t : r;
  }
  s(Ide, "getInjectedAnswer");
  function Rde(e) {
    nl._injected = (nl._injected || []).concat(e);
  }
  s(Rde, "inject");
  function Nde(e) {
    nl._override = Object.assign({}, e);
  }
  s(Nde, "override");
  Nq.exports = Object.assign(nl, { prompt: nl, prompts: ax, inject: Rde, override: Nde });
});

// ../node_modules/prompts/index.js
var Mq = b((ESt, Fq) => {
  function Lde(e) {
    e = (Array.isArray(e) ? e : e.split(".")).map(Number);
    let t = 0, r = process.versions.node.split(".").map(Number);
    for (; t < e.length; t++) {
      if (r[t] > e[t]) return !1;
      if (e[t] > r[t]) return !0;
    }
    return !1;
  }
  s(Lde, "isNodeLT");
  Fq.exports = Lde("8.6.0") ? o3() : Lq();
});

// ../node_modules/@rolldown/pluginutils/dist/index.js
function Lg(e, t) {
  return new RegExp(`^${jde(e)}$`, t);
}
function jde(e) {
  return e.replace(Ude, "\\$&");
}
var Ude, Vq = at(() => {
  s(Lg, "exactRegex");
  Ude = /[-/\\^$*+?.()|[\]{}]/g;
  s(jde, "escapeRegex");
});

// src/core-server/presets/vitePlugins/vite-inject-mocker/plugin.ts
var zq = {};
da(zq, {
  viteInjectMockerRuntime: () => Kde
});
var Kq, fx, Hq, Yh, Vde, cx, Kde, Gq = at(() => {
  "use strict";
  Kq = require("node:fs"), fx = require("node:path");
  Vq();
  Hq = Gt(Gu(), 1), Yh = "/vite-inject-mocker-entry.js", Vde = Hq.dedent`
    <script type="module" src="${Yh}"></script>
  `, Kde = /* @__PURE__ */ s((e) => {
    let t;
    return {
      name: "vite:storybook-inject-mocker-runtime",
      buildStart() {
        t.command === "build" && this.emitFile({
          type: "chunk",
          id: require.resolve((0, fx.join)(__dirname, "..", "..", "..", "templates", "mocker-runtime.template.js")),
          fileName: Yh.slice(1)
        });
      },
      config() {
        return {
          optimizeDeps: {
            include: ["@vitest/mocker", "@vitest/mocker/browser"]
          },
          resolve: {
            // Aliasing necessary for package managers like pnpm, since resolving modules from a virtual module
            // leads to errors, if the imported module is not a dependency of the project.
            // By resolving the module to the real path, we can avoid this issue.
            alias: {
              "@vitest/mocker/browser": require.resolve("@vitest/mocker/browser"),
              "@vitest/mocker": require.resolve("@vitest/mocker")
            }
          }
        };
      },
      configResolved(r) {
        t = r;
      },
      configureServer(r) {
        cx = r, e.previewConfigPath && cx.watcher.on("change", (i) => {
          i === e.previewConfigPath && cx.ws.send({
            type: "custom",
            event: "invalidate-mocker"
          });
        });
      },
      resolveId: {
        filter: {
          id: [Lg(Yh)]
        },
        handler(r) {
          return Lg(r).test(Yh) ? r : null;
        }
      },
      async load(r) {
        return Lg(r).test(Yh) ? (0, Kq.readFileSync)(
          require.resolve((0, fx.join)(__dirname, "..", "..", "..", "templates", "mocker-runtime.template.js")),
          "utf-8"
        ) : null;
      },
      transformIndexHtml(r) {
        let i = r.match(/<head[^>]*>/);
        if (i) {
          let n = r.indexOf(i[0]);
          return r.slice(0, n + i[0].length) + Vde + r.slice(n + i[0].length);
        }
      }
    };
  }, "viteInjectMockerRuntime");
});

// ../node_modules/pathe/dist/shared/pathe.ff20891b.mjs
function Fg(e = "") {
  return e && e.replace(/\\/g, "/").replace(Hde, (t) => t.toUpperCase());
}
function Wde() {
  return typeof process < "u" && typeof process.cwd == "function" ? process.cwd().replace(/\\/g, "/") : "/";
}
function dx(e, t) {
  let r = "", i = 0, n = -1, a = 0, o = null;
  for (let u = 0; u <= e.length; ++u) {
    if (u < e.length)
      o = e[u];
    else {
      if (o === "/")
        break;
      o = "/";
    }
    if (o === "/") {
      if (!(n === u - 1 || a === 1)) if (a === 2) {
        if (r.length < 2 || i !== 2 || r[r.length - 1] !== "." || r[r.length - 2] !== ".") {
          if (r.length > 2) {
            let l = r.lastIndexOf("/");
            l === -1 ? (r = "", i = 0) : (r = r.slice(0, l), i = r.length - 1 - r.lastIndexOf("/")), n = u, a = 0;
            continue;
          } else if (r.length > 0) {
            r = "", i = 0, n = u, a = 0;
            continue;
          }
        }
        t && (r += r.length > 0 ? "/.." : "..", i = 2);
      } else
        r.length > 0 ? r += `/${e.slice(n + 1, u)}` : r = e.slice(n + 1, u), i = u - n - 1;
      n = u, a = 0;
    } else o === "." && a !== -1 ? ++a : a = -1;
  }
  return r;
}
var Hde, zde, Gde, Wq, Vf, px, hx, sl, Mg, Bg, $q = at(() => {
  Hde = /^[A-Za-z]:\//;
  s(Fg, "normalizeWindowsPath");
  zde = /^[/\\]{2}/, Gde = /^[/\\](?![/\\])|^[/\\]{2}(?!\.)|^[A-Za-z]:[/\\]/, Wq = /^[A-Za-z]:$/, Vf = /* @__PURE__ */ s(function(e) {
    if (e.length === 0)
      return ".";
    e = Fg(e);
    let t = e.match(zde), r = sl(e), i = e[e.length - 1] === "/";
    return e = dx(e, !r), e.length === 0 ? r ? "/" : i ? "./" : "." : (i && (e += "/"), Wq.test(e) && (e += "/"), t ? r ? `//${e}` : `//./${e}` :
    r && !sl(e) ? `/${e}` : e);
  }, "normalize"), px = /* @__PURE__ */ s(function(...e) {
    if (e.length === 0)
      return ".";
    let t;
    for (let r of e)
      r && r.length > 0 && (t === void 0 ? t = r : t += `/${r}`);
    return t === void 0 ? "." : Vf(t.replace(/\/\/+/g, "/"));
  }, "join");
  s(Wde, "cwd");
  hx = /* @__PURE__ */ s(function(...e) {
    e = e.map((i) => Fg(i));
    let t = "", r = !1;
    for (let i = e.length - 1; i >= -1 && !r; i--) {
      let n = i >= 0 ? e[i] : Wde();
      !n || n.length === 0 || (t = `${n}/${t}`, r = sl(n));
    }
    return t = dx(t, !r), r && !sl(t) ? `/${t}` : t.length > 0 ? t : ".";
  }, "resolve");
  s(dx, "normalizeString");
  sl = /* @__PURE__ */ s(function(e) {
    return Gde.test(e);
  }, "isAbsolute"), Mg = /* @__PURE__ */ s(function(e) {
    let t = Fg(e).replace(/\/$/, "").split("/").slice(0, -1);
    return t.length === 1 && Wq.test(t[0]) && (t[0] += "/"), t.join("/") || (sl(e) ? "/" : ".");
  }, "dirname"), Bg = /* @__PURE__ */ s(function(e, t) {
    let r = Fg(e).split("/").pop();
    return t && r.endsWith(t) ? r.slice(0, -t.length) : r;
  }, "basename");
});

// ../node_modules/pathe/dist/index.mjs
var qg = at(() => {
  $q();
});

// ../node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.umd.js
var jg = b((Ug, Xq) => {
  (function(e, t) {
    typeof Ug == "object" && typeof Xq < "u" ? t(Ug) : typeof define == "function" && define.amd ? define(["exports"], t) : (e = typeof globalThis <
    "u" ? globalThis : e || self, t(e.sourcemapCodec = {}));
  })(Ug, function(e) {
    "use strict";
    let i = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", n = new Uint8Array(64), a = new Uint8Array(128);
    for (let D = 0; D < i.length; D++) {
      let N = i.charCodeAt(D);
      n[D] = N, a[N] = D;
    }
    function o(D, N) {
      let T = 0, R = 0, j = 0;
      do {
        let H = D.next();
        j = a[H], T |= (j & 31) << R, R += 5;
      } while (j & 32);
      let J = T & 1;
      return T >>>= 1, J && (T = -2147483648 | -T), N + T;
    }
    s(o, "decodeInteger");
    function u(D, N, T) {
      let R = N - T;
      R = R < 0 ? -R << 1 | 1 : R << 1;
      do {
        let j = R & 31;
        R >>>= 5, R > 0 && (j |= 32), D.write(n[j]);
      } while (R > 0);
      return N;
    }
    s(u, "encodeInteger");
    function l(D, N) {
      return D.pos >= N ? !1 : D.peek() !== 44;
    }
    s(l, "hasMoreVlq");
    let c = 1024 * 16, p = typeof TextDecoder < "u" ? /* @__PURE__ */ new TextDecoder() : typeof Buffer < "u" ? {
      decode(D) {
        return Buffer.from(D.buffer, D.byteOffset, D.byteLength).toString();
      }
    } : {
      decode(D) {
        let N = "";
        for (let T = 0; T < D.length; T++)
          N += String.fromCharCode(D[T]);
        return N;
      }
    };
    class h {
      static {
        s(this, "StringWriter");
      }
      constructor() {
        this.pos = 0, this.out = "", this.buffer = new Uint8Array(c);
      }
      write(N) {
        let { buffer: T } = this;
        T[this.pos++] = N, this.pos === c && (this.out += p.decode(T), this.pos = 0);
      }
      flush() {
        let { buffer: N, out: T, pos: R } = this;
        return R > 0 ? T + p.decode(N.subarray(0, R)) : T;
      }
    }
    class y {
      static {
        s(this, "StringReader");
      }
      constructor(N) {
        this.pos = 0, this.buffer = N;
      }
      next() {
        return this.buffer.charCodeAt(this.pos++);
      }
      peek() {
        return this.buffer.charCodeAt(this.pos);
      }
      indexOf(N) {
        let { buffer: T, pos: R } = this, j = T.indexOf(N, R);
        return j === -1 ? T.length : j;
      }
    }
    let _ = [];
    function g(D) {
      let { length: N } = D, T = new y(D), R = [], j = [], J = 0;
      for (; T.pos < N; T.pos++) {
        J = o(T, J);
        let H = o(T, 0);
        if (!l(T, N)) {
          let xe = j.pop();
          xe[2] = J, xe[3] = H;
          continue;
        }
        let F = o(T, 0), de = o(T, 0) & 1 ? [J, H, 0, 0, F, o(T, 0)] : [J, H, 0, 0, F], he = _;
        if (l(T, N)) {
          he = [];
          do {
            let xe = o(T, 0);
            he.push(xe);
          } while (l(T, N));
        }
        de.vars = he, R.push(de), j.push(de);
      }
      return R;
    }
    s(g, "decodeOriginalScopes");
    function m(D) {
      let N = new h();
      for (let T = 0; T < D.length; )
        T = f(D, T, N, [0]);
      return N.flush();
    }
    s(m, "encodeOriginalScopes");
    function f(D, N, T, R) {
      let j = D[N], { 0: J, 1: H, 2: F, 3: re, 4: se, vars: de } = j;
      N > 0 && T.write(44), R[0] = u(T, J, R[0]), u(T, H, 0), u(T, se, 0);
      let he = j.length === 6 ? 1 : 0;
      u(T, he, 0), j.length === 6 && u(T, j[5], 0);
      for (let xe of de)
        u(T, xe, 0);
      for (N++; N < D.length; ) {
        let xe = D[N], { 0: G, 1: ie } = xe;
        if (G > F || G === F && ie >= re)
          break;
        N = f(D, N, T, R);
      }
      return T.write(44), R[0] = u(T, F, R[0]), u(T, re, 0), N;
    }
    s(f, "_encodeOriginalScopes");
    function d(D) {
      let { length: N } = D, T = new y(D), R = [], j = [], J = 0, H = 0, F = 0, re = 0, se = 0, de = 0, he = 0, xe = 0;
      do {
        let G = T.indexOf(";"), ie = 0;
        for (; T.pos < G; T.pos++) {
          if (ie = o(T, ie), !l(T, G)) {
            let oe = j.pop();
            oe[2] = J, oe[3] = ie;
            continue;
          }
          let X = o(T, 0), ye = X & 1, Oe = X & 2, Pt = X & 4, Vt = null, Ee = _, st;
          if (ye) {
            let oe = o(T, H);
            F = o(T, H === oe ? F : 0), H = oe, st = [J, ie, 0, 0, oe, F];
          } else
            st = [J, ie, 0, 0];
          if (st.isScope = !!Pt, Oe) {
            let oe = re, Ae = se;
            re = o(T, re);
            let Ie = oe === re;
            se = o(T, Ie ? se : 0), de = o(T, Ie && Ae === se ? de : 0), Vt = [re, se, de];
          }
          if (st.callsite = Vt, l(T, G)) {
            Ee = [];
            do {
              he = J, xe = ie;
              let oe = o(T, 0), Ae;
              if (oe < -1) {
                Ae = [[o(T, 0)]];
                for (let Ie = -1; Ie > oe; Ie--) {
                  let te = he;
                  he = o(T, he), xe = o(T, he === te ? xe : 0);
                  let pe = o(T, 0);
                  Ae.push([pe, he, xe]);
                }
              } else
                Ae = [[oe]];
              Ee.push(Ae);
            } while (l(T, G));
          }
          st.bindings = Ee, R.push(st), j.push(st);
        }
        J++, T.pos = G + 1;
      } while (T.pos < N);
      return R;
    }
    s(d, "decodeGeneratedRanges");
    function v(D) {
      if (D.length === 0)
        return "";
      let N = new h();
      for (let T = 0; T < D.length; )
        T = E(D, T, N, [0, 0, 0, 0, 0, 0, 0]);
      return N.flush();
    }
    s(v, "encodeGeneratedRanges");
    function E(D, N, T, R) {
      let j = D[N], { 0: J, 1: H, 2: F, 3: re, isScope: se, callsite: de, bindings: he } = j;
      R[0] < J ? (S(T, R[0], J), R[0] = J, R[1] = 0) : N > 0 && T.write(44), R[1] = u(T, j[1], R[1]);
      let xe = (j.length === 6 ? 1 : 0) | (de ? 2 : 0) | (se ? 4 : 0);
      if (u(T, xe, 0), j.length === 6) {
        let { 4: G, 5: ie } = j;
        G !== R[2] && (R[3] = 0), R[2] = u(T, G, R[2]), R[3] = u(T, ie, R[3]);
      }
      if (de) {
        let { 0: G, 1: ie, 2: X } = j.callsite;
        G !== R[4] ? (R[5] = 0, R[6] = 0) : ie !== R[5] && (R[6] = 0), R[4] = u(T, G, R[4]), R[5] = u(T, ie, R[5]), R[6] = u(T, X, R[6]);
      }
      if (he)
        for (let G of he) {
          G.length > 1 && u(T, -G.length, 0);
          let ie = G[0][0];
          u(T, ie, 0);
          let X = J, ye = H;
          for (let Oe = 1; Oe < G.length; Oe++) {
            let Pt = G[Oe];
            X = u(T, Pt[1], X), ye = u(T, Pt[2], ye), u(T, Pt[0], 0);
          }
        }
      for (N++; N < D.length; ) {
        let G = D[N], { 0: ie, 1: X } = G;
        if (ie > F || ie === F && X >= re)
          break;
        N = E(D, N, T, R);
      }
      return R[0] < F ? (S(T, R[0], F), R[0] = F, R[1] = 0) : T.write(44), R[1] = u(T, re, R[1]), N;
    }
    s(E, "_encodeGeneratedRanges");
    function S(D, N, T) {
      do
        D.write(59);
      while (++N < T);
    }
    s(S, "catchupLine");
    function x(D) {
      let { length: N } = D, T = new y(D), R = [], j = 0, J = 0, H = 0, F = 0, re = 0;
      do {
        let se = T.indexOf(";"), de = [], he = !0, xe = 0;
        for (j = 0; T.pos < se; ) {
          let G;
          j = o(T, j), j < xe && (he = !1), xe = j, l(T, se) ? (J = o(T, J), H = o(T, H), F = o(T, F), l(T, se) ? (re = o(T, re), G = [j, J,
          H, F, re]) : G = [j, J, H, F]) : G = [j], de.push(G), T.pos++;
        }
        he || C(de), R.push(de), T.pos = se + 1;
      } while (T.pos <= N);
      return R;
    }
    s(x, "decode");
    function C(D) {
      D.sort(z);
    }
    s(C, "sort");
    function z(D, N) {
      return D[0] - N[0];
    }
    s(z, "sortComparator");
    function w(D) {
      let N = new h(), T = 0, R = 0, j = 0, J = 0;
      for (let H = 0; H < D.length; H++) {
        let F = D[H];
        if (H > 0 && N.write(59), F.length === 0)
          continue;
        let re = 0;
        for (let se = 0; se < F.length; se++) {
          let de = F[se];
          se > 0 && N.write(44), re = u(N, de[0], re), de.length !== 1 && (T = u(N, de[1], T), R = u(N, de[2], R), j = u(N, de[3], j), de.length !==
          4 && (J = u(N, de[4], J)));
        }
      }
      return N.flush();
    }
    s(w, "encode"), e.decode = x, e.decodeGeneratedRanges = d, e.decodeOriginalScopes = g, e.encode = w, e.encodeGeneratedRanges = v, e.encodeOriginalScopes =
    m, Object.defineProperty(e, "__esModule", { value: !0 });
  });
});

// ../node_modules/magic-string/dist/magic-string.es.mjs
function $de() {
  return typeof globalThis < "u" && typeof globalThis.btoa == "function" ? (e) => globalThis.btoa(unescape(encodeURIComponent(e))) : typeof Buffer ==
  "function" ? (e) => Buffer.from(e, "utf-8").toString("base64") : () => {
    throw new Error("Unsupported environment: `window.btoa` or `Buffer` should be supported.");
  };
}
function Yde(e) {
  let t = e.split(`
`), r = t.filter((a) => /^\t+/.test(a)), i = t.filter((a) => /^ {2,}/.test(a));
  if (r.length === 0 && i.length === 0)
    return null;
  if (r.length >= i.length)
    return "	";
  let n = i.reduce((a, o) => {
    let u = /^ +/.exec(o)[0].length;
    return Math.min(u, a);
  }, 1 / 0);
  return new Array(n + 1).join(" ");
}
function Jde(e, t) {
  let r = e.split(/[/\\]/), i = t.split(/[/\\]/);
  for (r.pop(); r[0] === i[0]; )
    r.shift(), i.shift();
  if (r.length) {
    let n = r.length;
    for (; n--; ) r[n] = "..";
  }
  return r.concat(i).join("/");
}
function Zde(e) {
  return Qde.call(e) === "[object Object]";
}
function Yq(e) {
  let t = e.split(`
`), r = [];
  for (let i = 0, n = 0; i < t.length; i++)
    r.push(n), n += t[i].length + 1;
  return /* @__PURE__ */ s(function(n) {
    let a = 0, o = r.length;
    for (; a < o; ) {
      let c = a + o >> 1;
      n < r[c] ? o = c : a = c + 1;
    }
    let u = a - 1, l = n - r[u];
    return { line: u, column: l };
  }, "locate");
}
var Jq, Vg, Kg, Xde, mx, Qde, eme, yx, Jh, Kf, Hg, Qq = at(() => {
  Jq = Gt(jg(), 1), Vg = class e {
    static {
      s(this, "BitSet");
    }
    constructor(t) {
      this.bits = t instanceof e ? t.bits.slice() : [];
    }
    add(t) {
      this.bits[t >> 5] |= 1 << (t & 31);
    }
    has(t) {
      return !!(this.bits[t >> 5] & 1 << (t & 31));
    }
  }, Kg = class e {
    static {
      s(this, "Chunk");
    }
    constructor(t, r, i) {
      this.start = t, this.end = r, this.original = i, this.intro = "", this.outro = "", this.content = i, this.storeName = !1, this.edited =
      !1, this.previous = null, this.next = null;
    }
    appendLeft(t) {
      this.outro += t;
    }
    appendRight(t) {
      this.intro = this.intro + t;
    }
    clone() {
      let t = new e(this.start, this.end, this.original);
      return t.intro = this.intro, t.outro = this.outro, t.content = this.content, t.storeName = this.storeName, t.edited = this.edited, t;
    }
    contains(t) {
      return this.start < t && t < this.end;
    }
    eachNext(t) {
      let r = this;
      for (; r; )
        t(r), r = r.next;
    }
    eachPrevious(t) {
      let r = this;
      for (; r; )
        t(r), r = r.previous;
    }
    edit(t, r, i) {
      return this.content = t, i || (this.intro = "", this.outro = ""), this.storeName = r, this.edited = !0, this;
    }
    prependLeft(t) {
      this.outro = t + this.outro;
    }
    prependRight(t) {
      this.intro = t + this.intro;
    }
    reset() {
      this.intro = "", this.outro = "", this.edited && (this.content = this.original, this.storeName = !1, this.edited = !1);
    }
    split(t) {
      let r = t - this.start, i = this.original.slice(0, r), n = this.original.slice(r);
      this.original = i;
      let a = new e(t, this.end, n);
      return a.outro = this.outro, this.outro = "", this.end = t, this.edited ? (a.edit("", !1), this.content = "") : this.content = i, a.next =
      this.next, a.next && (a.next.previous = a), a.previous = this, this.next = a, a;
    }
    toString() {
      return this.intro + this.content + this.outro;
    }
    trimEnd(t) {
      if (this.outro = this.outro.replace(t, ""), this.outro.length) return !0;
      let r = this.content.replace(t, "");
      if (r.length)
        return r !== this.content && (this.split(this.start + r.length).edit("", void 0, !0), this.edited && this.edit(r, this.storeName, !0)),
        !0;
      if (this.edit("", void 0, !0), this.intro = this.intro.replace(t, ""), this.intro.length) return !0;
    }
    trimStart(t) {
      if (this.intro = this.intro.replace(t, ""), this.intro.length) return !0;
      let r = this.content.replace(t, "");
      if (r.length) {
        if (r !== this.content) {
          let i = this.split(this.end - r.length);
          this.edited && i.edit(r, this.storeName, !0), this.edit("", void 0, !0);
        }
        return !0;
      } else if (this.edit("", void 0, !0), this.outro = this.outro.replace(t, ""), this.outro.length) return !0;
    }
  };
  s($de, "getBtoa");
  Xde = /* @__PURE__ */ $de(), mx = class {
    static {
      s(this, "SourceMap");
    }
    constructor(t) {
      this.version = 3, this.file = t.file, this.sources = t.sources, this.sourcesContent = t.sourcesContent, this.names = t.names, this.mappings =
      (0, Jq.encode)(t.mappings), typeof t.x_google_ignoreList < "u" && (this.x_google_ignoreList = t.x_google_ignoreList), typeof t.debugId <
      "u" && (this.debugId = t.debugId);
    }
    toString() {
      return JSON.stringify(this);
    }
    toUrl() {
      return "data:application/json;charset=utf-8;base64," + Xde(this.toString());
    }
  };
  s(Yde, "guessIndent");
  s(Jde, "getRelativePath");
  Qde = Object.prototype.toString;
  s(Zde, "isObject");
  s(Yq, "getLocator");
  eme = /\w/, yx = class {
    static {
      s(this, "Mappings");
    }
    constructor(t) {
      this.hires = t, this.generatedCodeLine = 0, this.generatedCodeColumn = 0, this.raw = [], this.rawSegments = this.raw[this.generatedCodeLine] =
      [], this.pending = null;
    }
    addEdit(t, r, i, n) {
      if (r.length) {
        let a = r.length - 1, o = r.indexOf(`
`, 0), u = -1;
        for (; o >= 0 && a > o; ) {
          let c = [this.generatedCodeColumn, t, i.line, i.column];
          n >= 0 && c.push(n), this.rawSegments.push(c), this.generatedCodeLine += 1, this.raw[this.generatedCodeLine] = this.rawSegments = [],
          this.generatedCodeColumn = 0, u = o, o = r.indexOf(`
`, o + 1);
        }
        let l = [this.generatedCodeColumn, t, i.line, i.column];
        n >= 0 && l.push(n), this.rawSegments.push(l), this.advance(r.slice(u + 1));
      } else this.pending && (this.rawSegments.push(this.pending), this.advance(r));
      this.pending = null;
    }
    addUneditedChunk(t, r, i, n, a) {
      let o = r.start, u = !0, l = !1;
      for (; o < r.end; ) {
        if (i[o] === `
`)
          n.line += 1, n.column = 0, this.generatedCodeLine += 1, this.raw[this.generatedCodeLine] = this.rawSegments = [], this.generatedCodeColumn =
          0, u = !0, l = !1;
        else {
          if (this.hires || u || a.has(o)) {
            let c = [this.generatedCodeColumn, t, n.line, n.column];
            this.hires === "boundary" ? eme.test(i[o]) ? l || (this.rawSegments.push(c), l = !0) : (this.rawSegments.push(c), l = !1) : this.
            rawSegments.push(c);
          }
          n.column += 1, this.generatedCodeColumn += 1, u = !1;
        }
        o += 1;
      }
      this.pending = null;
    }
    advance(t) {
      if (!t) return;
      let r = t.split(`
`);
      if (r.length > 1) {
        for (let i = 0; i < r.length - 1; i++)
          this.generatedCodeLine++, this.raw[this.generatedCodeLine] = this.rawSegments = [];
        this.generatedCodeColumn = 0;
      }
      this.generatedCodeColumn += r[r.length - 1].length;
    }
  }, Jh = `
`, Kf = {
    insertLeft: !1,
    insertRight: !1,
    storeName: !1
  }, Hg = class e {
    static {
      s(this, "MagicString");
    }
    constructor(t, r = {}) {
      let i = new Kg(0, t.length, t);
      Object.defineProperties(this, {
        original: { writable: !0, value: t },
        outro: { writable: !0, value: "" },
        intro: { writable: !0, value: "" },
        firstChunk: { writable: !0, value: i },
        lastChunk: { writable: !0, value: i },
        lastSearchedChunk: { writable: !0, value: i },
        byStart: { writable: !0, value: {} },
        byEnd: { writable: !0, value: {} },
        filename: { writable: !0, value: r.filename },
        indentExclusionRanges: { writable: !0, value: r.indentExclusionRanges },
        sourcemapLocations: { writable: !0, value: new Vg() },
        storedNames: { writable: !0, value: {} },
        indentStr: { writable: !0, value: void 0 },
        ignoreList: { writable: !0, value: r.ignoreList },
        offset: { writable: !0, value: r.offset || 0 }
      }), this.byStart[0] = i, this.byEnd[t.length] = i;
    }
    addSourcemapLocation(t) {
      this.sourcemapLocations.add(t);
    }
    append(t) {
      if (typeof t != "string") throw new TypeError("outro content must be a string");
      return this.outro += t, this;
    }
    appendLeft(t, r) {
      if (t = t + this.offset, typeof r != "string") throw new TypeError("inserted content must be a string");
      this._split(t);
      let i = this.byEnd[t];
      return i ? i.appendLeft(r) : this.intro += r, this;
    }
    appendRight(t, r) {
      if (t = t + this.offset, typeof r != "string") throw new TypeError("inserted content must be a string");
      this._split(t);
      let i = this.byStart[t];
      return i ? i.appendRight(r) : this.outro += r, this;
    }
    clone() {
      let t = new e(this.original, { filename: this.filename, offset: this.offset }), r = this.firstChunk, i = t.firstChunk = t.lastSearchedChunk =
      r.clone();
      for (; r; ) {
        t.byStart[i.start] = i, t.byEnd[i.end] = i;
        let n = r.next, a = n && n.clone();
        a && (i.next = a, a.previous = i, i = a), r = n;
      }
      return t.lastChunk = i, this.indentExclusionRanges && (t.indentExclusionRanges = this.indentExclusionRanges.slice()), t.sourcemapLocations =
      new Vg(this.sourcemapLocations), t.intro = this.intro, t.outro = this.outro, t;
    }
    generateDecodedMap(t) {
      t = t || {};
      let r = 0, i = Object.keys(this.storedNames), n = new yx(t.hires), a = Yq(this.original);
      return this.intro && n.advance(this.intro), this.firstChunk.eachNext((o) => {
        let u = a(o.start);
        o.intro.length && n.advance(o.intro), o.edited ? n.addEdit(
          r,
          o.content,
          u,
          o.storeName ? i.indexOf(o.original) : -1
        ) : n.addUneditedChunk(r, o, this.original, u, this.sourcemapLocations), o.outro.length && n.advance(o.outro);
      }), {
        file: t.file ? t.file.split(/[/\\]/).pop() : void 0,
        sources: [
          t.source ? Jde(t.file || "", t.source) : t.file || ""
        ],
        sourcesContent: t.includeContent ? [this.original] : void 0,
        names: i,
        mappings: n.raw,
        x_google_ignoreList: this.ignoreList ? [r] : void 0
      };
    }
    generateMap(t) {
      return new mx(this.generateDecodedMap(t));
    }
    _ensureindentStr() {
      this.indentStr === void 0 && (this.indentStr = Yde(this.original));
    }
    _getRawIndentString() {
      return this._ensureindentStr(), this.indentStr;
    }
    getIndentString() {
      return this._ensureindentStr(), this.indentStr === null ? "	" : this.indentStr;
    }
    indent(t, r) {
      let i = /^[^\r\n]/gm;
      if (Zde(t) && (r = t, t = void 0), t === void 0 && (this._ensureindentStr(), t = this.indentStr || "	"), t === "") return this;
      r = r || {};
      let n = {};
      r.exclude && (typeof r.exclude[0] == "number" ? [r.exclude] : r.exclude).forEach((p) => {
        for (let h = p[0]; h < p[1]; h += 1)
          n[h] = !0;
      });
      let a = r.indentStart !== !1, o = /* @__PURE__ */ s((c) => a ? `${t}${c}` : (a = !0, c), "replacer");
      this.intro = this.intro.replace(i, o);
      let u = 0, l = this.firstChunk;
      for (; l; ) {
        let c = l.end;
        if (l.edited)
          n[u] || (l.content = l.content.replace(i, o), l.content.length && (a = l.content[l.content.length - 1] === `
`));
        else
          for (u = l.start; u < c; ) {
            if (!n[u]) {
              let p = this.original[u];
              p === `
` ? a = !0 : p !== "\r" && a && (a = !1, u === l.start || (this._splitChunk(l, u), l = l.next), l.prependRight(t));
            }
            u += 1;
          }
        u = l.end, l = l.next;
      }
      return this.outro = this.outro.replace(i, o), this;
    }
    insert() {
      throw new Error(
        "magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)"
      );
    }
    insertLeft(t, r) {
      return Kf.insertLeft || (console.warn(
        "magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead"
      ), Kf.insertLeft = !0), this.appendLeft(t, r);
    }
    insertRight(t, r) {
      return Kf.insertRight || (console.warn(
        "magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead"
      ), Kf.insertRight = !0), this.prependRight(t, r);
    }
    move(t, r, i) {
      if (t = t + this.offset, r = r + this.offset, i = i + this.offset, i >= t && i <= r) throw new Error("Cannot move a selection inside i\
tself");
      this._split(t), this._split(r), this._split(i);
      let n = this.byStart[t], a = this.byEnd[r], o = n.previous, u = a.next, l = this.byStart[i];
      if (!l && a === this.lastChunk) return this;
      let c = l ? l.previous : this.lastChunk;
      return o && (o.next = u), u && (u.previous = o), c && (c.next = n), l && (l.previous = a), n.previous || (this.firstChunk = a.next), a.
      next || (this.lastChunk = n.previous, this.lastChunk.next = null), n.previous = c, a.next = l || null, c || (this.firstChunk = n), l ||
      (this.lastChunk = a), this;
    }
    overwrite(t, r, i, n) {
      return n = n || {}, this.update(t, r, i, { ...n, overwrite: !n.contentOnly });
    }
    update(t, r, i, n) {
      if (t = t + this.offset, r = r + this.offset, typeof i != "string") throw new TypeError("replacement content must be a string");
      if (this.original.length !== 0) {
        for (; t < 0; ) t += this.original.length;
        for (; r < 0; ) r += this.original.length;
      }
      if (r > this.original.length) throw new Error("end is out of bounds");
      if (t === r)
        throw new Error(
          "Cannot overwrite a zero-length range \u2013 use appendLeft or prependRight instead"
        );
      this._split(t), this._split(r), n === !0 && (Kf.storeName || (console.warn(
        "The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string"
      ), Kf.storeName = !0), n = { storeName: !0 });
      let a = n !== void 0 ? n.storeName : !1, o = n !== void 0 ? n.overwrite : !1;
      if (a) {
        let c = this.original.slice(t, r);
        Object.defineProperty(this.storedNames, c, {
          writable: !0,
          value: !0,
          enumerable: !0
        });
      }
      let u = this.byStart[t], l = this.byEnd[r];
      if (u) {
        let c = u;
        for (; c !== l; ) {
          if (c.next !== this.byStart[c.end])
            throw new Error("Cannot overwrite across a split point");
          c = c.next, c.edit("", !1);
        }
        u.edit(i, a, !o);
      } else {
        let c = new Kg(t, r, "").edit(i, a);
        l.next = c, c.previous = l;
      }
      return this;
    }
    prepend(t) {
      if (typeof t != "string") throw new TypeError("outro content must be a string");
      return this.intro = t + this.intro, this;
    }
    prependLeft(t, r) {
      if (t = t + this.offset, typeof r != "string") throw new TypeError("inserted content must be a string");
      this._split(t);
      let i = this.byEnd[t];
      return i ? i.prependLeft(r) : this.intro = r + this.intro, this;
    }
    prependRight(t, r) {
      if (t = t + this.offset, typeof r != "string") throw new TypeError("inserted content must be a string");
      this._split(t);
      let i = this.byStart[t];
      return i ? i.prependRight(r) : this.outro = r + this.outro, this;
    }
    remove(t, r) {
      if (t = t + this.offset, r = r + this.offset, this.original.length !== 0) {
        for (; t < 0; ) t += this.original.length;
        for (; r < 0; ) r += this.original.length;
      }
      if (t === r) return this;
      if (t < 0 || r > this.original.length) throw new Error("Character is out of bounds");
      if (t > r) throw new Error("end must be greater than start");
      this._split(t), this._split(r);
      let i = this.byStart[t];
      for (; i; )
        i.intro = "", i.outro = "", i.edit(""), i = r > i.end ? this.byStart[i.end] : null;
      return this;
    }
    reset(t, r) {
      if (t = t + this.offset, r = r + this.offset, this.original.length !== 0) {
        for (; t < 0; ) t += this.original.length;
        for (; r < 0; ) r += this.original.length;
      }
      if (t === r) return this;
      if (t < 0 || r > this.original.length) throw new Error("Character is out of bounds");
      if (t > r) throw new Error("end must be greater than start");
      this._split(t), this._split(r);
      let i = this.byStart[t];
      for (; i; )
        i.reset(), i = r > i.end ? this.byStart[i.end] : null;
      return this;
    }
    lastChar() {
      if (this.outro.length) return this.outro[this.outro.length - 1];
      let t = this.lastChunk;
      do {
        if (t.outro.length) return t.outro[t.outro.length - 1];
        if (t.content.length) return t.content[t.content.length - 1];
        if (t.intro.length) return t.intro[t.intro.length - 1];
      } while (t = t.previous);
      return this.intro.length ? this.intro[this.intro.length - 1] : "";
    }
    lastLine() {
      let t = this.outro.lastIndexOf(Jh);
      if (t !== -1) return this.outro.substr(t + 1);
      let r = this.outro, i = this.lastChunk;
      do {
        if (i.outro.length > 0) {
          if (t = i.outro.lastIndexOf(Jh), t !== -1) return i.outro.substr(t + 1) + r;
          r = i.outro + r;
        }
        if (i.content.length > 0) {
          if (t = i.content.lastIndexOf(Jh), t !== -1) return i.content.substr(t + 1) + r;
          r = i.content + r;
        }
        if (i.intro.length > 0) {
          if (t = i.intro.lastIndexOf(Jh), t !== -1) return i.intro.substr(t + 1) + r;
          r = i.intro + r;
        }
      } while (i = i.previous);
      return t = this.intro.lastIndexOf(Jh), t !== -1 ? this.intro.substr(t + 1) + r : this.intro + r;
    }
    slice(t = 0, r = this.original.length - this.offset) {
      if (t = t + this.offset, r = r + this.offset, this.original.length !== 0) {
        for (; t < 0; ) t += this.original.length;
        for (; r < 0; ) r += this.original.length;
      }
      let i = "", n = this.firstChunk;
      for (; n && (n.start > t || n.end <= t); ) {
        if (n.start < r && n.end >= r)
          return i;
        n = n.next;
      }
      if (n && n.edited && n.start !== t)
        throw new Error(`Cannot use replaced character ${t} as slice start anchor.`);
      let a = n;
      for (; n; ) {
        n.intro && (a !== n || n.start === t) && (i += n.intro);
        let o = n.start < r && n.end >= r;
        if (o && n.edited && n.end !== r)
          throw new Error(`Cannot use replaced character ${r} as slice end anchor.`);
        let u = a === n ? t - n.start : 0, l = o ? n.content.length + r - n.end : n.content.length;
        if (i += n.content.slice(u, l), n.outro && (!o || n.end === r) && (i += n.outro), o)
          break;
        n = n.next;
      }
      return i;
    }
    // TODO deprecate this? not really very useful
    snip(t, r) {
      let i = this.clone();
      return i.remove(0, t), i.remove(r, i.original.length), i;
    }
    _split(t) {
      if (this.byStart[t] || this.byEnd[t]) return;
      let r = this.lastSearchedChunk, i = t > r.end;
      for (; r; ) {
        if (r.contains(t)) return this._splitChunk(r, t);
        r = i ? this.byStart[r.end] : this.byEnd[r.start];
      }
    }
    _splitChunk(t, r) {
      if (t.edited && t.content.length) {
        let n = Yq(this.original)(r);
        throw new Error(
          `Cannot split a chunk that has already been edited (${n.line}:${n.column} \u2013 "${t.original}")`
        );
      }
      let i = t.split(r);
      return this.byEnd[r] = t, this.byStart[r] = i, this.byEnd[i.end] = i, t === this.lastChunk && (this.lastChunk = i), this.lastSearchedChunk =
      t, !0;
    }
    toString() {
      let t = this.intro, r = this.firstChunk;
      for (; r; )
        t += r.toString(), r = r.next;
      return t + this.outro;
    }
    isEmpty() {
      let t = this.firstChunk;
      do
        if (t.intro.length && t.intro.trim() || t.content.length && t.content.trim() || t.outro.length && t.outro.trim())
          return !1;
      while (t = t.next);
      return !0;
    }
    length() {
      let t = this.firstChunk, r = 0;
      do
        r += t.intro.length + t.content.length + t.outro.length;
      while (t = t.next);
      return r;
    }
    trimLines() {
      return this.trim("[\\r\\n]");
    }
    trim(t) {
      return this.trimStart(t).trimEnd(t);
    }
    trimEndAborted(t) {
      let r = new RegExp((t || "\\s") + "+$");
      if (this.outro = this.outro.replace(r, ""), this.outro.length) return !0;
      let i = this.lastChunk;
      do {
        let n = i.end, a = i.trimEnd(r);
        if (i.end !== n && (this.lastChunk === i && (this.lastChunk = i.next), this.byEnd[i.end] = i, this.byStart[i.next.start] = i.next, this.
        byEnd[i.next.end] = i.next), a) return !0;
        i = i.previous;
      } while (i);
      return !1;
    }
    trimEnd(t) {
      return this.trimEndAborted(t), this;
    }
    trimStartAborted(t) {
      let r = new RegExp("^" + (t || "\\s") + "+");
      if (this.intro = this.intro.replace(r, ""), this.intro.length) return !0;
      let i = this.firstChunk;
      do {
        let n = i.end, a = i.trimStart(r);
        if (i.end !== n && (i === this.lastChunk && (this.lastChunk = i.next), this.byEnd[i.end] = i, this.byStart[i.next.start] = i.next, this.
        byEnd[i.next.end] = i.next), a) return !0;
        i = i.next;
      } while (i);
      return !1;
    }
    trimStart(t) {
      return this.trimStartAborted(t), this;
    }
    hasChanged() {
      return this.original !== this.toString();
    }
    _replaceRegexp(t, r) {
      function i(a, o) {
        return typeof r == "string" ? r.replace(/\$(\$|&|\d+)/g, (u, l) => l === "$" ? "$" : l === "&" ? a[0] : +l < a.length ? a[+l] : `$${l}`) :
        r(...a, a.index, o, a.groups);
      }
      s(i, "getReplacement");
      function n(a, o) {
        let u, l = [];
        for (; u = a.exec(o); )
          l.push(u);
        return l;
      }
      if (s(n, "matchAll"), t.global)
        n(t, this.original).forEach((o) => {
          if (o.index != null) {
            let u = i(o, this.original);
            u !== o[0] && this.overwrite(o.index, o.index + o[0].length, u);
          }
        });
      else {
        let a = this.original.match(t);
        if (a && a.index != null) {
          let o = i(a, this.original);
          o !== a[0] && this.overwrite(a.index, a.index + a[0].length, o);
        }
      }
      return this;
    }
    _replaceString(t, r) {
      let { original: i } = this, n = i.indexOf(t);
      return n !== -1 && this.overwrite(n, n + t.length, r), this;
    }
    replace(t, r) {
      return typeof t == "string" ? this._replaceString(t, r) : this._replaceRegexp(t, r);
    }
    _replaceAllString(t, r) {
      let { original: i } = this, n = t.length;
      for (let a = i.indexOf(t); a !== -1; a = i.indexOf(t, a + n))
        i.slice(a, a + n) !== r && this.overwrite(a, a + n, r);
      return this;
    }
    replaceAll(t, r) {
      if (typeof t == "string")
        return this._replaceAllString(t, r);
      if (!t.global)
        throw new TypeError(
          "MagicString.prototype.replaceAll called with a non-global RegExp argument"
        );
      return this._replaceRegexp(t, r);
    }
  };
});

// src/core-server/presets/vitePlugins/vite-inject-mocker/constants.ts
var Zq, e8 = at(() => {
  "use strict";
  Zq = "__vitest_mocker__";
});

// ../node_modules/estree-walker/src/walker.js
var Qh, gx = at(() => {
  Qh = class {
    static {
      s(this, "WalkerBase");
    }
    constructor() {
      this.should_skip = !1, this.should_remove = !1, this.replacement = null, this.context = {
        skip: /* @__PURE__ */ s(() => this.should_skip = !0, "skip"),
        remove: /* @__PURE__ */ s(() => this.should_remove = !0, "remove"),
        replace: /* @__PURE__ */ s((t) => this.replacement = t, "replace")
      };
    }
    /**
     * @template {Node} Parent
     * @param {Parent | null | undefined} parent
     * @param {keyof Parent | null | undefined} prop
     * @param {number | null | undefined} index
     * @param {Node} node
     */
    replace(t, r, i, n) {
      t && r && (i != null ? t[r][i] = n : t[r] = n);
    }
    /**
     * @template {Node} Parent
     * @param {Parent | null | undefined} parent
     * @param {keyof Parent | null | undefined} prop
     * @param {number | null | undefined} index
     */
    remove(t, r, i) {
      t && r && (i != null ? t[r].splice(i, 1) : delete t[r]);
    }
  };
});

// ../node_modules/estree-walker/src/sync.js
function t8(e) {
  return e !== null && typeof e == "object" && "type" in e && typeof e.type == "string";
}
var zg, r8 = at(() => {
  gx();
  zg = class extends Qh {
    static {
      s(this, "SyncWalker");
    }
    /**
     *
     * @param {SyncHandler} [enter]
     * @param {SyncHandler} [leave]
     */
    constructor(t, r) {
      super(), this.should_skip = !1, this.should_remove = !1, this.replacement = null, this.context = {
        skip: /* @__PURE__ */ s(() => this.should_skip = !0, "skip"),
        remove: /* @__PURE__ */ s(() => this.should_remove = !0, "remove"),
        replace: /* @__PURE__ */ s((i) => this.replacement = i, "replace")
      }, this.enter = t, this.leave = r;
    }
    /**
     * @template {Node} Parent
     * @param {Node} node
     * @param {Parent | null} parent
     * @param {keyof Parent} [prop]
     * @param {number | null} [index]
     * @returns {Node | null}
     */
    visit(t, r, i, n) {
      if (t) {
        if (this.enter) {
          let o = this.should_skip, u = this.should_remove, l = this.replacement;
          this.should_skip = !1, this.should_remove = !1, this.replacement = null, this.enter.call(this.context, t, r, i, n), this.replacement &&
          (t = this.replacement, this.replace(r, i, n, t)), this.should_remove && this.remove(r, i, n);
          let c = this.should_skip, p = this.should_remove;
          if (this.should_skip = o, this.should_remove = u, this.replacement = l, c) return t;
          if (p) return null;
        }
        let a;
        for (a in t) {
          let o = t[a];
          if (o && typeof o == "object")
            if (Array.isArray(o)) {
              let u = (
                /** @type {Array<unknown>} */
                o
              );
              for (let l = 0; l < u.length; l += 1) {
                let c = u[l];
                t8(c) && (this.visit(c, t, a, l) || l--);
              }
            } else t8(o) && this.visit(o, t, a, null);
        }
        if (this.leave) {
          let o = this.replacement, u = this.should_remove;
          this.replacement = null, this.should_remove = !1, this.leave.call(this.context, t, r, i, n), this.replacement && (t = this.replacement,
          this.replace(r, i, n, t)), this.should_remove && this.remove(r, i, n);
          let l = this.should_remove;
          if (this.replacement = o, this.should_remove = u, l) return null;
        }
      }
      return t;
    }
  };
  s(t8, "isNode");
});

// ../node_modules/estree-walker/src/async.js
var i8 = at(() => {
  gx();
});

// ../node_modules/estree-walker/src/index.js
function Gg(e, { enter: t, leave: r }) {
  return new zg(t, r).visit(e, null);
}
var _x = at(() => {
  r8();
  i8();
  s(Gg, "walk");
});

// src/core-server/mocking-utils/esmWalker.ts
function Zh(e) {
  return e.type === "Identifier" ? e.name : e.raw;
}
var n8 = at(() => {
  "use strict";
  _x();
  s(Zh, "getArbitraryModuleIdentifier");
});

// src/core-server/mocking-utils/automock.ts
function s8(e, t, r) {
  return tme(e, t ? "autospy" : "automock", r, {
    globalThisAccessor: JSON.stringify(Zq)
  });
}
function tme(e, t, r, i = {}) {
  let n = i.globalThisAccessor || '"__vitest_mocker__"', a = r(e), o = new Hg(e), u = [], l = 0;
  for (let g of a.body) {
    if (g.type === "ExportAllDeclaration")
      throw new Error(
        "automocking files with `export *` is not supported in browser mode because it cannot be statically analysed"
      );
    if (g.type === "ExportNamedDeclaration") {
      let d = function(S) {
        if (S.type === "Identifier")
          u.push({ name: S.name });
        else if (S.type === "ArrayPattern")
          S.elements.forEach((x) => {
            x && d(x);
          });
        else if (S.type === "ObjectPattern")
          S.properties.forEach((x) => {
            x.type === "RestElement" ? d(x) : x.type === "Property" && d(x.value);
          });
        else if (S.type === "RestElement")
          d(S.argument);
        else {
          if (S.type === "AssignmentPattern")
            throw new Error("AssignmentPattern is not supported. Please open a new bug report.");
          if (S.type === "MemberExpression")
            throw new Error("MemberExpression is not supported. Please open a new bug report.");
        }
      };
      var _ = d;
      s(d, "traversePattern");
      let m = g, f = m.declaration;
      f && (f.type === "FunctionDeclaration" ? u.push({ name: f.id.name }) : f.type === "VariableDeclaration" ? f.declarations.forEach((S) => {
        d(S.id);
      }) : f.type === "ClassDeclaration" && u.push({ name: f.id.name }), o.remove(m.start, f.start));
      let v = m.specifiers || [], E = m.source;
      if (!E && v.length)
        v.forEach((S) => {
          u.push({
            alias: Zh(S.exported),
            name: Zh(S.local)
          });
        }), o.remove(m.start, m.end);
      else if (E && v.length) {
        let S = [];
        v.forEach((C) => {
          let z = `__vitest_imported_${l++}__`;
          S.push([Zh(C.local), z]), u.push({
            name: z,
            alias: Zh(C.exported)
          });
        });
        let x = `import { ${S.map(([C, z]) => `${C} as ${z}`).join(", ")} } from '${E.value}'`;
        o.overwrite(m.start, m.end, x);
      }
    }
    if (g.type === "ExportDefaultDeclaration") {
      let m = g, f = m.declaration;
      u.push({ name: "__vitest_default", alias: "default" }), o.overwrite(m.start, f.start, "const __vitest_default = ");
    }
  }
  let c = `
const __vitest_current_es_module__ = {
  __esModule: true,
  ${u.map(({ name: g }) => `["${g}"]: ${g},`).join(`
  `)}
}
const __vitest_mocked_module__ = globalThis[${n}].mockObject(__vitest_current_es_module__, "${t}")
`, p = u.map(({ name: g }, m) => `const __vitest_mocked_${m}__ = __vitest_mocked_module__["${g}"]`).join(`
`), y = `
export {
${u.map(({ name: g, alias: m }, f) => `  __vitest_mocked_${f}__ as ${m || g},`).join(`
`)}
}
`;
  return o.append(c + p + y), o;
}
var a8 = at(() => {
  "use strict";
  Qq();
  e8();
  n8();
  s(s8, "getAutomockCode");
  s(tme, "automockModule");
});

// ../node_modules/@jridgewell/set-array/dist/set-array.umd.js
var u8 = b((Wg, o8) => {
  (function(e, t) {
    typeof Wg == "object" && typeof o8 < "u" ? t(Wg) : typeof define == "function" && define.amd ? define(["exports"], t) : (e = typeof globalThis <
    "u" ? globalThis : e || self, t(e.setArray = {}));
  })(Wg, function(e) {
    "use strict";
    class t {
      static {
        s(this, "SetArray");
      }
      constructor() {
        this._indexes = { __proto__: null }, this.array = [];
      }
    }
    function r(u) {
      return u;
    }
    s(r, "cast");
    function i(u, l) {
      return u._indexes[l];
    }
    s(i, "get");
    function n(u, l) {
      let c = i(u, l);
      if (c !== void 0)
        return c;
      let { array: p, _indexes: h } = u, y = p.push(l);
      return h[l] = y - 1;
    }
    s(n, "put");
    function a(u) {
      let { array: l, _indexes: c } = u;
      if (l.length === 0)
        return;
      let p = l.pop();
      c[p] = void 0;
    }
    s(a, "pop");
    function o(u, l) {
      let c = i(u, l);
      if (c === void 0)
        return;
      let { array: p, _indexes: h } = u;
      for (let y = c + 1; y < p.length; y++) {
        let _ = p[y];
        p[y - 1] = _, h[_]--;
      }
      h[l] = void 0, p.pop();
    }
    s(o, "remove"), e.SetArray = t, e.get = i, e.pop = a, e.put = n, e.remove = o, Object.defineProperty(e, "__esModule", { value: !0 });
  });
});

// ../node_modules/@jridgewell/resolve-uri/dist/resolve-uri.umd.js
var l8 = b((bx, vx) => {
  (function(e, t) {
    typeof bx == "object" && typeof vx < "u" ? vx.exports = t() : typeof define == "function" && define.amd ? define(t) : (e = typeof globalThis <
    "u" ? globalThis : e || self, e.resolveURI = t());
  })(bx, function() {
    "use strict";
    let e = /^[\w+.-]+:\/\//, t = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/, r = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;
    function i(f) {
      return e.test(f);
    }
    s(i, "isAbsoluteUrl");
    function n(f) {
      return f.startsWith("//");
    }
    s(n, "isSchemeRelativeUrl");
    function a(f) {
      return f.startsWith("/");
    }
    s(a, "isAbsolutePath");
    function o(f) {
      return f.startsWith("file:");
    }
    s(o, "isFileUrl");
    function u(f) {
      return /^[.?#]/.test(f);
    }
    s(u, "isRelative");
    function l(f) {
      let d = t.exec(f);
      return p(d[1], d[2] || "", d[3], d[4] || "", d[5] || "/", d[6] || "", d[7] || "");
    }
    s(l, "parseAbsoluteUrl");
    function c(f) {
      let d = r.exec(f), v = d[2];
      return p("file:", "", d[1] || "", "", a(v) ? v : "/" + v, d[3] || "", d[4] || "");
    }
    s(c, "parseFileUrl");
    function p(f, d, v, E, S, x, C) {
      return {
        scheme: f,
        user: d,
        host: v,
        port: E,
        path: S,
        query: x,
        hash: C,
        type: 7
      };
    }
    s(p, "makeUrl");
    function h(f) {
      if (n(f)) {
        let v = l("http:" + f);
        return v.scheme = "", v.type = 6, v;
      }
      if (a(f)) {
        let v = l("http://foo.com" + f);
        return v.scheme = "", v.host = "", v.type = 5, v;
      }
      if (o(f))
        return c(f);
      if (i(f))
        return l(f);
      let d = l("http://foo.com/" + f);
      return d.scheme = "", d.host = "", d.type = f ? f.startsWith("?") ? 3 : f.startsWith("#") ? 2 : 4 : 1, d;
    }
    s(h, "parseUrl");
    function y(f) {
      if (f.endsWith("/.."))
        return f;
      let d = f.lastIndexOf("/");
      return f.slice(0, d + 1);
    }
    s(y, "stripPathFilename");
    function _(f, d) {
      g(d, d.type), f.path === "/" ? f.path = d.path : f.path = y(d.path) + f.path;
    }
    s(_, "mergePaths");
    function g(f, d) {
      let v = d <= 4, E = f.path.split("/"), S = 1, x = 0, C = !1;
      for (let w = 1; w < E.length; w++) {
        let D = E[w];
        if (!D) {
          C = !0;
          continue;
        }
        if (C = !1, D !== ".") {
          if (D === "..") {
            x ? (C = !0, x--, S--) : v && (E[S++] = D);
            continue;
          }
          E[S++] = D, x++;
        }
      }
      let z = "";
      for (let w = 1; w < S; w++)
        z += "/" + E[w];
      (!z || C && !z.endsWith("/..")) && (z += "/"), f.path = z;
    }
    s(g, "normalizePath");
    function m(f, d) {
      if (!f && !d)
        return "";
      let v = h(f), E = v.type;
      if (d && E !== 7) {
        let x = h(d), C = x.type;
        switch (E) {
          case 1:
            v.hash = x.hash;
          // fall through
          case 2:
            v.query = x.query;
          // fall through
          case 3:
          case 4:
            _(v, x);
          // fall through
          case 5:
            v.user = x.user, v.host = x.host, v.port = x.port;
          // fall through
          case 6:
            v.scheme = x.scheme;
        }
        C > E && (E = C);
      }
      g(v, E);
      let S = v.query + v.hash;
      switch (E) {
        // This is impossible, because of the empty checks at the start of the function.
        // case UrlType.Empty:
        case 2:
        case 3:
          return S;
        case 4: {
          let x = v.path.slice(1);
          return x ? u(d || f) && !u(x) ? "./" + x + S : x + S : S || ".";
        }
        case 5:
          return v.path + S;
        default:
          return v.scheme + "//" + v.user + v.host + v.port + v.path + S;
      }
    }
    return s(m, "resolve"), m;
  });
});

// ../node_modules/@jridgewell/trace-mapping/dist/trace-mapping.umd.js
var Xg = b(($g, c8) => {
  (function(e, t) {
    typeof $g == "object" && typeof c8 < "u" ? t($g, jg(), l8()) : typeof define == "function" && define.amd ? define(["exports", "@jridgewe\
ll/sourcemap-codec", "@jridgewell/resolve-uri"], t) : (e = typeof globalThis < "u" ? globalThis : e || self, t(e.traceMapping = {}, e.sourcemapCodec,
    e.resolveURI));
  })($g, function(e, t, r) {
    "use strict";
    function i(ae, _e) {
      return _e && !_e.endsWith("/") && (_e += "/"), r(ae, _e);
    }
    s(i, "resolve");
    function n(ae) {
      if (!ae)
        return "";
      let _e = ae.lastIndexOf("/");
      return ae.slice(0, _e + 1);
    }
    s(n, "stripFilename");
    let a = 0, o = 1, u = 2, l = 3, c = 4, p = 1, h = 2;
    function y(ae, _e) {
      let be = _(ae, 0);
      if (be === ae.length)
        return ae;
      _e || (ae = ae.slice());
      for (let Pe = be; Pe < ae.length; Pe = _(ae, Pe + 1))
        ae[Pe] = m(ae[Pe], _e);
      return ae;
    }
    s(y, "maybeSort");
    function _(ae, _e) {
      for (let be = _e; be < ae.length; be++)
        if (!g(ae[be]))
          return be;
      return ae.length;
    }
    s(_, "nextUnsortedSegmentLine");
    function g(ae) {
      for (let _e = 1; _e < ae.length; _e++)
        if (ae[_e][a] < ae[_e - 1][a])
          return !1;
      return !0;
    }
    s(g, "isSorted");
    function m(ae, _e) {
      return _e || (ae = ae.slice()), ae.sort(f);
    }
    s(m, "sortSegments");
    function f(ae, _e) {
      return ae[a] - _e[a];
    }
    s(f, "sortComparator");
    let d = !1;
    function v(ae, _e, be, Pe) {
      for (; be <= Pe; ) {
        let ze = be + (Pe - be >> 1), nt = ae[ze][a] - _e;
        if (nt === 0)
          return d = !0, ze;
        nt < 0 ? be = ze + 1 : Pe = ze - 1;
      }
      return d = !1, be - 1;
    }
    s(v, "binarySearch");
    function E(ae, _e, be) {
      for (let Pe = be + 1; Pe < ae.length && ae[Pe][a] === _e; be = Pe++)
        ;
      return be;
    }
    s(E, "upperBound");
    function S(ae, _e, be) {
      for (let Pe = be - 1; Pe >= 0 && ae[Pe][a] === _e; be = Pe--)
        ;
      return be;
    }
    s(S, "lowerBound");
    function x() {
      return {
        lastKey: -1,
        lastNeedle: -1,
        lastIndex: -1
      };
    }
    s(x, "memoizedState");
    function C(ae, _e, be, Pe) {
      let { lastKey: ze, lastNeedle: nt, lastIndex: V } = be, Ce = 0, ke = ae.length - 1;
      if (Pe === ze) {
        if (_e === nt)
          return d = V !== -1 && ae[V][a] === _e, V;
        _e >= nt ? Ce = V === -1 ? 0 : V : ke = V;
      }
      return be.lastKey = Pe, be.lastNeedle = _e, be.lastIndex = v(ae, _e, Ce, ke);
    }
    s(C, "memoizedBinarySearch");
    function z(ae, _e) {
      let be = _e.map(D);
      for (let Pe = 0; Pe < ae.length; Pe++) {
        let ze = ae[Pe];
        for (let nt = 0; nt < ze.length; nt++) {
          let V = ze[nt];
          if (V.length === 1)
            continue;
          let Ce = V[o], ke = V[u], Re = V[l], St = be[Ce], Mt = St[ke] || (St[ke] = []), yt = _e[Ce], rr = E(Mt, Re, C(Mt, Re, yt, ke));
          yt.lastIndex = ++rr, w(Mt, rr, [Re, Pe, V[a]]);
        }
      }
      return be;
    }
    s(z, "buildBySources");
    function w(ae, _e, be) {
      for (let Pe = ae.length; Pe > _e; Pe--)
        ae[Pe] = ae[Pe - 1];
      ae[_e] = be;
    }
    s(w, "insert");
    function D() {
      return { __proto__: null };
    }
    s(D, "buildNullArray");
    let N = /* @__PURE__ */ s(function(ae, _e) {
      let be = T(ae);
      if (!("sections" in be))
        return new he(be, _e);
      let Pe = [], ze = [], nt = [], V = [], Ce = [];
      R(be, _e, Pe, ze, nt, V, Ce, 0, 0, 1 / 0, 1 / 0);
      let ke = {
        version: 3,
        file: be.file,
        names: V,
        sources: ze,
        sourcesContent: nt,
        mappings: Pe,
        ignoreList: Ce
      };
      return Ae(ke);
    }, "AnyMap");
    function T(ae) {
      return typeof ae == "string" ? JSON.parse(ae) : ae;
    }
    s(T, "parse");
    function R(ae, _e, be, Pe, ze, nt, V, Ce, ke, Re, St) {
      let { sections: Mt } = ae;
      for (let yt = 0; yt < Mt.length; yt++) {
        let { map: rr, offset: qr } = Mt[yt], ha = Re, Si = St;
        if (yt + 1 < Mt.length) {
          let zr = Mt[yt + 1].offset;
          ha = Math.min(Re, Ce + zr.line), ha === Re ? Si = Math.min(St, ke + zr.column) : ha < Re && (Si = ke + zr.column);
        }
        j(rr, _e, be, Pe, ze, nt, V, Ce + qr.line, ke + qr.column, ha, Si);
      }
    }
    s(R, "recurse");
    function j(ae, _e, be, Pe, ze, nt, V, Ce, ke, Re, St) {
      let Mt = T(ae);
      if ("sections" in Mt)
        return R(...arguments);
      let yt = new he(Mt, _e), rr = Pe.length, qr = nt.length, ha = ie(yt), { resolvedSources: Si, sourcesContent: zr, ignoreList: gf } = yt;
      if (J(Pe, Si), J(nt, yt.names), zr)
        J(ze, zr);
      else
        for (let Hn = 0; Hn < Si.length; Hn++)
          ze.push(null);
      if (gf)
        for (let Hn = 0; Hn < gf.length; Hn++)
          V.push(gf[Hn] + rr);
      for (let Hn = 0; Hn < ha.length; Hn++) {
        let _f = Ce + Hn;
        if (_f > Re)
          return;
        let bf = H(be, _f), _h = Hn === 0 ? ke : 0, vy = ha[Hn];
        for (let Jl = 0; Jl < vy.length; Jl++) {
          let Cs = vy[Jl], Ql = _h + Cs[a];
          if (_f === Re && Ql >= St)
            return;
          if (Cs.length === 1) {
            bf.push([Ql]);
            continue;
          }
          let bh = rr + Cs[o], $t = Cs[u], iu = Cs[l];
          bf.push(Cs.length === 4 ? [Ql, bh, $t, iu] : [Ql, bh, $t, iu, qr + Cs[c]]);
        }
      }
    }
    s(j, "addSection");
    function J(ae, _e) {
      for (let be = 0; be < _e.length; be++)
        ae.push(_e[be]);
    }
    s(J, "append");
    function H(ae, _e) {
      for (let be = ae.length; be <= _e; be++)
        ae[be] = [];
      return ae[_e];
    }
    s(H, "getLine");
    let F = "`line` must be greater than 0 (lines start at line 1)", re = "`column` must be greater than or equal to 0 (columns start at col\
umn 0)", se = -1, de = 1;
    class he {
      static {
        s(this, "TraceMap");
      }
      constructor(_e, be) {
        let Pe = typeof _e == "string";
        if (!Pe && _e._decodedMemo)
          return _e;
        let ze = Pe ? JSON.parse(_e) : _e, { version: nt, file: V, names: Ce, sourceRoot: ke, sources: Re, sourcesContent: St } = ze;
        this.version = nt, this.file = V, this.names = Ce || [], this.sourceRoot = ke, this.sources = Re, this.sourcesContent = St, this.ignoreList =
        ze.ignoreList || ze.x_google_ignoreList || void 0;
        let Mt = i(ke || "", n(be));
        this.resolvedSources = Re.map((rr) => i(rr || "", Mt));
        let { mappings: yt } = ze;
        typeof yt == "string" ? (this._encoded = yt, this._decoded = void 0) : (this._encoded = void 0, this._decoded = y(yt, Pe)), this._decodedMemo =
        x(), this._bySources = void 0, this._bySourceMemos = void 0;
      }
    }
    function xe(ae) {
      return ae;
    }
    s(xe, "cast");
    function G(ae) {
      var _e, be;
      return (_e = (be = ae)._encoded) !== null && _e !== void 0 ? _e : be._encoded = t.encode(ae._decoded);
    }
    s(G, "encodedMappings");
    function ie(ae) {
      var _e;
      return (_e = ae)._decoded || (_e._decoded = t.decode(ae._encoded));
    }
    s(ie, "decodedMappings");
    function X(ae, _e, be) {
      let Pe = ie(ae);
      if (_e >= Pe.length)
        return null;
      let ze = Pe[_e], nt = vt(ze, ae._decodedMemo, _e, be, de);
      return nt === -1 ? null : ze[nt];
    }
    s(X, "traceSegment");
    function ye(ae, _e) {
      let { line: be, column: Pe, bias: ze } = _e;
      if (be--, be < 0)
        throw new Error(F);
      if (Pe < 0)
        throw new Error(re);
      let nt = ie(ae);
      if (be >= nt.length)
        return we(null, null, null, null);
      let V = nt[be], Ce = vt(V, ae._decodedMemo, be, Pe, ze || de);
      if (Ce === -1)
        return we(null, null, null, null);
      let ke = V[Ce];
      if (ke.length === 1)
        return we(null, null, null, null);
      let { names: Re, resolvedSources: St } = ae;
      return we(St[ke[o]], ke[u] + 1, ke[l], ke.length === 5 ? Re[ke[c]] : null);
    }
    s(ye, "originalPositionFor");
    function Oe(ae, _e) {
      let { source: be, line: Pe, column: ze, bias: nt } = _e;
      return xr(ae, be, Pe, ze, nt || de, !1);
    }
    s(Oe, "generatedPositionFor");
    function Pt(ae, _e) {
      let { source: be, line: Pe, column: ze, bias: nt } = _e;
      return xr(ae, be, Pe, ze, nt || se, !0);
    }
    s(Pt, "allGeneratedPositionsFor");
    function Vt(ae, _e) {
      let be = ie(ae), { names: Pe, resolvedSources: ze } = ae;
      for (let nt = 0; nt < be.length; nt++) {
        let V = be[nt];
        for (let Ce = 0; Ce < V.length; Ce++) {
          let ke = V[Ce], Re = nt + 1, St = ke[0], Mt = null, yt = null, rr = null, qr = null;
          ke.length !== 1 && (Mt = ze[ke[1]], yt = ke[2] + 1, rr = ke[3]), ke.length === 5 && (qr = Pe[ke[4]]), _e({
            generatedLine: Re,
            generatedColumn: St,
            source: Mt,
            originalLine: yt,
            originalColumn: rr,
            name: qr
          });
        }
      }
    }
    s(Vt, "eachMapping");
    function Ee(ae, _e) {
      let { sources: be, resolvedSources: Pe } = ae, ze = be.indexOf(_e);
      return ze === -1 && (ze = Pe.indexOf(_e)), ze;
    }
    s(Ee, "sourceIndex");
    function st(ae, _e) {
      let { sourcesContent: be } = ae;
      if (be == null)
        return null;
      let Pe = Ee(ae, _e);
      return Pe === -1 ? null : be[Pe];
    }
    s(st, "sourceContentFor");
    function oe(ae, _e) {
      let { ignoreList: be } = ae;
      if (be == null)
        return !1;
      let Pe = Ee(ae, _e);
      return Pe === -1 ? !1 : be.includes(Pe);
    }
    s(oe, "isIgnored");
    function Ae(ae, _e) {
      let be = new he(pe(ae, []), _e);
      return be._decoded = ae.mappings, be;
    }
    s(Ae, "presortedDecodedMap");
    function Ie(ae) {
      return pe(ae, ie(ae));
    }
    s(Ie, "decodedMap");
    function te(ae) {
      return pe(ae, G(ae));
    }
    s(te, "encodedMap");
    function pe(ae, _e) {
      return {
        version: ae.version,
        file: ae.file,
        names: ae.names,
        sourceRoot: ae.sourceRoot,
        sources: ae.sources,
        sourcesContent: ae.sourcesContent,
        mappings: _e,
        ignoreList: ae.ignoreList || ae.x_google_ignoreList
      };
    }
    s(pe, "clone");
    function we(ae, _e, be, Pe) {
      return { source: ae, line: _e, column: be, name: Pe };
    }
    s(we, "OMapping");
    function He(ae, _e) {
      return { line: ae, column: _e };
    }
    s(He, "GMapping");
    function vt(ae, _e, be, Pe, ze) {
      let nt = C(ae, Pe, _e, be);
      return d ? nt = (ze === se ? E : S)(ae, Pe, nt) : ze === se && nt++, nt === -1 || nt === ae.length ? -1 : nt;
    }
    s(vt, "traceSegmentInternal");
    function wt(ae, _e, be, Pe, ze) {
      let nt = vt(ae, _e, be, Pe, de);
      if (!d && ze === se && nt++, nt === -1 || nt === ae.length)
        return [];
      let V = d ? Pe : ae[nt][a];
      d || (nt = S(ae, V, nt));
      let Ce = E(ae, V, nt), ke = [];
      for (; nt <= Ce; nt++) {
        let Re = ae[nt];
        ke.push(He(Re[p] + 1, Re[h]));
      }
      return ke;
    }
    s(wt, "sliceGeneratedPositions");
    function xr(ae, _e, be, Pe, ze, nt) {
      var V;
      if (be--, be < 0)
        throw new Error(F);
      if (Pe < 0)
        throw new Error(re);
      let { sources: Ce, resolvedSources: ke } = ae, Re = Ce.indexOf(_e);
      if (Re === -1 && (Re = ke.indexOf(_e)), Re === -1)
        return nt ? [] : He(null, null);
      let Mt = ((V = ae)._bySources || (V._bySources = z(ie(ae), ae._bySourceMemos = Ce.map(x))))[Re][be];
      if (Mt == null)
        return nt ? [] : He(null, null);
      let yt = ae._bySourceMemos[Re];
      if (nt)
        return wt(Mt, yt, be, Pe, ze);
      let rr = vt(Mt, yt, be, Pe, ze);
      if (rr === -1)
        return He(null, null);
      let qr = Mt[rr];
      return He(qr[p] + 1, qr[h]);
    }
    s(xr, "generatedPosition"), e.AnyMap = N, e.GREATEST_LOWER_BOUND = de, e.LEAST_UPPER_BOUND = se, e.TraceMap = he, e.allGeneratedPositionsFor =
    Pt, e.decodedMap = Ie, e.decodedMappings = ie, e.eachMapping = Vt, e.encodedMap = te, e.encodedMappings = G, e.generatedPositionFor = Oe,
    e.isIgnored = oe, e.originalPositionFor = ye, e.presortedDecodedMap = Ae, e.sourceContentFor = st, e.traceSegment = X;
  });
});

// ../node_modules/@jridgewell/gen-mapping/dist/gen-mapping.umd.js
var Sx = b((Yg, f8) => {
  (function(e, t) {
    typeof Yg == "object" && typeof f8 < "u" ? t(Yg, u8(), jg(), Xg()) : typeof define == "function" && define.amd ? define(["exports", "@jr\
idgewell/set-array", "@jridgewell/sourcemap-codec", "@jridgewell/trace-mapping"], t) : (e = typeof globalThis < "u" ? globalThis : e || self,
    t(e.genMapping = {}, e.setArray, e.sourcemapCodec, e.traceMapping));
  })(Yg, function(e, t, r, i) {
    "use strict";
    class p {
      static {
        s(this, "GenMapping");
      }
      constructor({ file: F, sourceRoot: re } = {}) {
        this._names = new t.SetArray(), this._sources = new t.SetArray(), this._sourcesContent = [], this._mappings = [], this.file = F, this.
        sourceRoot = re, this._ignoreList = new t.SetArray();
      }
    }
    function h(H) {
      return H;
    }
    s(h, "cast");
    function y(H, F, re, se, de, he, xe, G) {
      return C(!1, H, F, re, se, de, he, xe, G);
    }
    s(y, "addSegment");
    function _(H, F) {
      return J(!1, H, F);
    }
    s(_, "addMapping");
    let g = /* @__PURE__ */ s((H, F, re, se, de, he, xe, G) => C(!0, H, F, re, se, de, he, xe, G), "maybeAddSegment"), m = /* @__PURE__ */ s(
    (H, F) => J(!0, H, F), "maybeAddMapping");
    function f(H, F, re) {
      let { _sources: se, _sourcesContent: de } = H, he = t.put(se, F);
      de[he] = re;
    }
    s(f, "setSourceContent");
    function d(H, F, re = !0) {
      let { _sources: se, _sourcesContent: de, _ignoreList: he } = H, xe = t.put(se, F);
      xe === de.length && (de[xe] = null), re ? t.put(he, xe) : t.remove(he, xe);
    }
    s(d, "setIgnore");
    function v(H) {
      let { _mappings: F, _sources: re, _sourcesContent: se, _names: de, _ignoreList: he } = H;
      return N(F), {
        version: 3,
        file: H.file || void 0,
        names: de.array,
        sourceRoot: H.sourceRoot || void 0,
        sources: re.array,
        sourcesContent: se,
        mappings: F,
        ignoreList: he.array
      };
    }
    s(v, "toDecodedMap");
    function E(H) {
      let F = v(H);
      return Object.assign(Object.assign({}, F), { mappings: r.encode(F.mappings) });
    }
    s(E, "toEncodedMap");
    function S(H) {
      let F = new i.TraceMap(H), re = new p({ file: F.file, sourceRoot: F.sourceRoot });
      return T(re._names, F.names), T(re._sources, F.sources), re._sourcesContent = F.sourcesContent || F.sources.map(() => null), re._mappings =
      i.decodedMappings(F), F.ignoreList && T(re._ignoreList, F.ignoreList), re;
    }
    s(S, "fromMap");
    function x(H) {
      let F = [], { _mappings: re, _sources: se, _names: de } = H;
      for (let he = 0; he < re.length; he++) {
        let xe = re[he];
        for (let G = 0; G < xe.length; G++) {
          let ie = xe[G], X = { line: he + 1, column: ie[0] }, ye, Oe, Pt;
          ie.length !== 1 && (ye = se.array[ie[1]], Oe = { line: ie[2] + 1, column: ie[3] }, ie.length === 5 && (Pt = de.array[ie[4]])), F.push(
          { generated: X, source: ye, original: Oe, name: Pt });
        }
      }
      return F;
    }
    s(x, "allMappings");
    function C(H, F, re, se, de, he, xe, G, ie) {
      let { _mappings: X, _sources: ye, _sourcesContent: Oe, _names: Pt } = F, Vt = z(X, re), Ee = w(Vt, se);
      if (!de)
        return H && R(Vt, Ee) ? void 0 : D(Vt, Ee, [se]);
      let st = t.put(ye, de), oe = G ? t.put(Pt, G) : -1;
      if (st === Oe.length && (Oe[st] = ie ?? null), !(H && j(Vt, Ee, st, he, xe, oe)))
        return D(Vt, Ee, G ? [se, st, he, xe, oe] : [se, st, he, xe]);
    }
    s(C, "addSegmentInternal");
    function z(H, F) {
      for (let re = H.length; re <= F; re++)
        H[re] = [];
      return H[F];
    }
    s(z, "getLine");
    function w(H, F) {
      let re = H.length;
      for (let se = re - 1; se >= 0; re = se--) {
        let de = H[se];
        if (F >= de[0])
          break;
      }
      return re;
    }
    s(w, "getColumnIndex");
    function D(H, F, re) {
      for (let se = H.length; se > F; se--)
        H[se] = H[se - 1];
      H[F] = re;
    }
    s(D, "insert");
    function N(H) {
      let { length: F } = H, re = F;
      for (let se = re - 1; se >= 0 && !(H[se].length > 0); re = se, se--)
        ;
      re < F && (H.length = re);
    }
    s(N, "removeEmptyFinalLines");
    function T(H, F) {
      for (let re = 0; re < F.length; re++)
        t.put(H, F[re]);
    }
    s(T, "putAll");
    function R(H, F) {
      return F === 0 ? !0 : H[F - 1].length === 1;
    }
    s(R, "skipSourceless");
    function j(H, F, re, se, de, he) {
      if (F === 0)
        return !1;
      let xe = H[F - 1];
      return xe.length === 1 ? !1 : re === xe[1] && se === xe[2] && de === xe[3] && he === (xe.length === 5 ? xe[4] : -1);
    }
    s(j, "skipSource");
    function J(H, F, re) {
      let { generated: se, source: de, original: he, name: xe, content: G } = re;
      return de ? C(H, F, se.line - 1, se.column, de, he.line - 1, he.column, xe, G) : C(H, F, se.line - 1, se.column, null, null, null, null,
      null);
    }
    s(J, "addMappingInternal"), e.GenMapping = p, e.addMapping = _, e.addSegment = y, e.allMappings = x, e.fromMap = S, e.maybeAddMapping = m,
    e.maybeAddSegment = g, e.setIgnore = d, e.setSourceContent = f, e.toDecodedMap = v, e.toEncodedMap = E, Object.defineProperty(e, "__esMo\
dule", { value: !0 });
  });
});

// ../node_modules/@babel/generator/lib/source-map.js
var p8 = b((Jg) => {
  "use strict";
  Object.defineProperty(Jg, "__esModule", {
    value: !0
  });
  Jg.default = void 0;
  var al = Sx(), Tx = Xg(), Ex = class {
    static {
      s(this, "SourceMap");
    }
    constructor(t, r) {
      var i;
      this._map = void 0, this._rawMappings = void 0, this._sourceFileName = void 0, this._lastGenLine = 0, this._lastSourceLine = 0, this._lastSourceColumn =
      0, this._inputMap = void 0;
      let n = this._map = new al.GenMapping({
        sourceRoot: t.sourceRoot
      });
      if (this._sourceFileName = (i = t.sourceFileName) == null ? void 0 : i.replace(/\\/g, "/"), this._rawMappings = void 0, t.inputSourceMap) {
        this._inputMap = new Tx.TraceMap(t.inputSourceMap);
        let o = this._inputMap.resolvedSources;
        if (o.length)
          for (let u = 0; u < o.length; u++) {
            var a;
            (0, al.setSourceContent)(n, o[u], (a = this._inputMap.sourcesContent) == null ? void 0 : a[u]);
          }
      }
      if (typeof r == "string" && !t.inputSourceMap)
        (0, al.setSourceContent)(n, this._sourceFileName, r);
      else if (typeof r == "object")
        for (let o of Object.keys(r))
          (0, al.setSourceContent)(n, o.replace(/\\/g, "/"), r[o]);
    }
    get() {
      return (0, al.toEncodedMap)(this._map);
    }
    getDecoded() {
      return (0, al.toDecodedMap)(this._map);
    }
    getRawMappings() {
      return this._rawMappings || (this._rawMappings = (0, al.allMappings)(this._map));
    }
    mark(t, r, i, n, a, o) {
      var u;
      this._rawMappings = void 0;
      let l;
      if (r != null)
        if (this._inputMap) {
          if (l = (0, Tx.originalPositionFor)(this._inputMap, {
            line: r,
            column: i
          }), !l.name && a) {
            let c = (0, Tx.originalPositionFor)(this._inputMap, a);
            c.name && (n = c.name);
          }
        } else
          l = {
            source: o?.replace(/\\/g, "/") || this._sourceFileName,
            line: r,
            column: i
          };
      (0, al.maybeAddMapping)(this._map, {
        name: n,
        generated: t,
        source: (u = l) == null ? void 0 : u.source,
        original: l
      });
    }
  };
  Jg.default = Ex;
});

// ../node_modules/@babel/generator/lib/buffer.js
var h8 = b((Qg) => {
  "use strict";
  Object.defineProperty(Qg, "__esModule", {
    value: !0
  });
  Qg.default = void 0;
  var Ax = class {
    static {
      s(this, "Buffer");
    }
    constructor(t, r) {
      this._map = null, this._buf = "", this._str = "", this._appendCount = 0, this._last = 0, this._queue = [], this._queueCursor = 0, this.
      _canMarkIdName = !0, this._indentChar = "", this._fastIndentations = [], this._position = {
        line: 1,
        column: 0
      }, this._sourcePosition = {
        identifierName: void 0,
        identifierNamePos: void 0,
        line: void 0,
        column: void 0,
        filename: void 0
      }, this._map = t, this._indentChar = r;
      for (let i = 0; i < 64; i++)
        this._fastIndentations.push(r.repeat(i));
      this._allocQueue();
    }
    _allocQueue() {
      let t = this._queue;
      for (let r = 0; r < 16; r++)
        t.push({
          char: 0,
          repeat: 1,
          line: void 0,
          column: void 0,
          identifierName: void 0,
          identifierNamePos: void 0,
          filename: ""
        });
    }
    _pushQueue(t, r, i, n, a) {
      let o = this._queueCursor;
      o === this._queue.length && this._allocQueue();
      let u = this._queue[o];
      u.char = t, u.repeat = r, u.line = i, u.column = n, u.filename = a, this._queueCursor++;
    }
    _popQueue() {
      if (this._queueCursor === 0)
        throw new Error("Cannot pop from empty queue");
      return this._queue[--this._queueCursor];
    }
    get() {
      this._flush();
      let t = this._map, r = {
        code: (this._buf + this._str).trimRight(),
        decodedMap: t?.getDecoded(),
        get __mergedMap() {
          return this.map;
        },
        get map() {
          let i = t ? t.get() : null;
          return r.map = i, i;
        },
        set map(i) {
          Object.defineProperty(r, "map", {
            value: i,
            writable: !0
          });
        },
        get rawMappings() {
          let i = t?.getRawMappings();
          return r.rawMappings = i, i;
        },
        set rawMappings(i) {
          Object.defineProperty(r, "rawMappings", {
            value: i,
            writable: !0
          });
        }
      };
      return r;
    }
    append(t, r) {
      this._flush(), this._append(t, this._sourcePosition, r);
    }
    appendChar(t) {
      this._flush(), this._appendChar(t, 1, this._sourcePosition);
    }
    queue(t) {
      if (t === 10)
        for (; this._queueCursor !== 0; ) {
          let i = this._queue[this._queueCursor - 1].char;
          if (i !== 32 && i !== 9)
            break;
          this._queueCursor--;
        }
      let r = this._sourcePosition;
      this._pushQueue(t, 1, r.line, r.column, r.filename);
    }
    queueIndentation(t) {
      t !== 0 && this._pushQueue(-1, t, void 0, void 0, void 0);
    }
    _flush() {
      let t = this._queueCursor, r = this._queue;
      for (let i = 0; i < t; i++) {
        let n = r[i];
        this._appendChar(n.char, n.repeat, n);
      }
      this._queueCursor = 0;
    }
    _appendChar(t, r, i) {
      if (this._last = t, t === -1) {
        let n = this._fastIndentations[r];
        n !== void 0 ? this._str += n : this._str += r > 1 ? this._indentChar.repeat(r) : this._indentChar;
      } else
        this._str += r > 1 ? String.fromCharCode(t).repeat(r) : String.fromCharCode(t);
      t !== 10 ? (this._mark(i.line, i.column, i.identifierName, i.identifierNamePos, i.filename), this._position.column += r) : (this._position.
      line++, this._position.column = 0), this._canMarkIdName && (i.identifierName = void 0, i.identifierNamePos = void 0);
    }
    _append(t, r, i) {
      let n = t.length, a = this._position;
      if (this._last = t.charCodeAt(n - 1), ++this._appendCount > 4096 ? (+this._str, this._buf += this._str, this._str = t, this._appendCount =
      0) : this._str += t, !i && !this._map) {
        a.column += n;
        return;
      }
      let {
        column: o,
        identifierName: u,
        identifierNamePos: l,
        filename: c
      } = r, p = r.line;
      (u != null || l != null) && this._canMarkIdName && (r.identifierName = void 0, r.identifierNamePos = void 0);
      let h = t.indexOf(`
`), y = 0;
      for (h !== 0 && this._mark(p, o, u, l, c); h !== -1; )
        a.line++, a.column = 0, y = h + 1, y < n && p !== void 0 && this._mark(++p, 0, null, null, c), h = t.indexOf(`
`, y);
      a.column += n - y;
    }
    _mark(t, r, i, n, a) {
      var o;
      (o = this._map) == null || o.mark(this._position, t, r, i, n, a);
    }
    removeTrailingNewline() {
      let t = this._queueCursor;
      t !== 0 && this._queue[t - 1].char === 10 && this._queueCursor--;
    }
    removeLastSemicolon() {
      let t = this._queueCursor;
      t !== 0 && this._queue[t - 1].char === 59 && this._queueCursor--;
    }
    getLastChar() {
      let t = this._queueCursor;
      return t !== 0 ? this._queue[t - 1].char : this._last;
    }
    getNewlineCount() {
      let t = this._queueCursor, r = 0;
      if (t === 0) return this._last === 10 ? 1 : 0;
      for (let i = t - 1; i >= 0 && this._queue[i].char === 10; i--)
        r++;
      return r === t && this._last === 10 ? r + 1 : r;
    }
    endsWithCharAndNewline() {
      let t = this._queue, r = this._queueCursor;
      if (r !== 0)
        return t[r - 1].char !== 10 ? void 0 : r > 1 ? t[r - 2].char : this._last;
    }
    hasContent() {
      return this._queueCursor !== 0 || !!this._last;
    }
    exactSource(t, r) {
      if (!this._map) {
        r();
        return;
      }
      this.source("start", t);
      let i = t.identifierName, n = this._sourcePosition;
      i && (this._canMarkIdName = !1, n.identifierName = i), r(), i && (this._canMarkIdName = !0, n.identifierName = void 0, n.identifierNamePos =
      void 0), this.source("end", t);
    }
    source(t, r) {
      this._map && this._normalizePosition(t, r, 0);
    }
    sourceWithOffset(t, r, i) {
      this._map && this._normalizePosition(t, r, i);
    }
    _normalizePosition(t, r, i) {
      let n = r[t], a = this._sourcePosition;
      n && (a.line = n.line, a.column = Math.max(n.column + i, 0), a.filename = r.filename);
    }
    getCurrentColumn() {
      let t = this._queue, r = this._queueCursor, i = -1, n = 0;
      for (let a = 0; a < r; a++) {
        let o = t[a];
        o.char === 10 && (i = n), n += o.repeat;
      }
      return i === -1 ? this._position.column + n : n - 1 - i;
    }
    getCurrentLine() {
      let t = 0, r = this._queue;
      for (let i = 0; i < this._queueCursor; i++)
        r[i].char === 10 && t++;
      return this._position.line + t;
    }
  };
  Qg.default = Ax;
});

// ../node_modules/@babel/types/lib/utils/shallowEqual.js
var Zg = b((xx) => {
  "use strict";
  Object.defineProperty(xx, "__esModule", {
    value: !0
  });
  xx.default = rme;
  function rme(e, t) {
    let r = Object.keys(t);
    for (let i of r)
      if (e[i] !== t[i])
        return !1;
    return !0;
  }
  s(rme, "shallowEqual");
});

// ../node_modules/@babel/types/lib/utils/deprecationWarning.js
var ed = b((Cx) => {
  "use strict";
  Object.defineProperty(Cx, "__esModule", {
    value: !0
  });
  Cx.default = ime;
  var d8 = /* @__PURE__ */ new Set();
  function ime(e, t, r = "") {
    if (d8.has(e)) return;
    d8.add(e);
    let {
      internal: i,
      trace: n
    } = nme(1, 2);
    i || console.warn(`${r}\`${e}\` has been deprecated, please migrate to \`${t}\`
${n}`);
  }
  s(ime, "deprecationWarning");
  function nme(e, t) {
    let {
      stackTraceLimit: r,
      prepareStackTrace: i
    } = Error, n;
    if (Error.stackTraceLimit = 1 + e + t, Error.prepareStackTrace = function(o, u) {
      n = u;
    }, new Error().stack, Error.stackTraceLimit = r, Error.prepareStackTrace = i, !n) return {
      internal: !1,
      trace: ""
    };
    let a = n.slice(1 + e, 1 + e + t);
    return {
      internal: /[\\/]@babel[\\/]/.test(a[1].getFileName()),
      trace: a.map((o) => `    at ${o}`).join(`
`)
    };
  }
  s(nme, "captureShortStackTrace");
});

// ../node_modules/@babel/types/lib/validators/generated/index.js
var Ri = b((M) => {
  "use strict";
  Object.defineProperty(M, "__esModule", {
    value: !0
  });
  M.isAccessor = vve;
  M.isAnyTypeAnnotation = Uye;
  M.isArgumentPlaceholder = m_e;
  M.isArrayExpression = sme;
  M.isArrayPattern = iye;
  M.isArrayTypeAnnotation = jye;
  M.isArrowFunctionExpression = nye;
  M.isAssignmentExpression = ame;
  M.isAssignmentPattern = rye;
  M.isAwaitExpression = Pye;
  M.isBigIntLiteral = wye;
  M.isBinary = Kbe;
  M.isBinaryExpression = ome;
  M.isBindExpression = y_e;
  M.isBlock = Gbe;
  M.isBlockParent = zbe;
  M.isBlockStatement = fme;
  M.isBooleanLiteral = Ime;
  M.isBooleanLiteralTypeAnnotation = Kye;
  M.isBooleanTypeAnnotation = Vye;
  M.isBreakStatement = pme;
  M.isCallExpression = hme;
  M.isCatchClause = dme;
  M.isClass = gve;
  M.isClassAccessorProperty = Nye;
  M.isClassBody = sye;
  M.isClassDeclaration = oye;
  M.isClassExpression = aye;
  M.isClassImplements = zye;
  M.isClassMethod = bye;
  M.isClassPrivateMethod = Fye;
  M.isClassPrivateProperty = Lye;
  M.isClassProperty = Rye;
  M.isCompletionStatement = Xbe;
  M.isConditional = Ybe;
  M.isConditionalExpression = mme;
  M.isContinueStatement = yme;
  M.isDebuggerStatement = gme;
  M.isDecimalLiteral = T_e;
  M.isDeclaration = sve;
  M.isDeclareClass = Gye;
  M.isDeclareExportAllDeclaration = tge;
  M.isDeclareExportDeclaration = ege;
  M.isDeclareFunction = Wye;
  M.isDeclareInterface = $ye;
  M.isDeclareModule = Xye;
  M.isDeclareModuleExports = Yye;
  M.isDeclareOpaqueType = Qye;
  M.isDeclareTypeAlias = Jye;
  M.isDeclareVariable = Zye;
  M.isDeclaredPredicate = rge;
  M.isDecorator = g_e;
  M.isDirective = lme;
  M.isDirectiveLiteral = cme;
  M.isDoExpression = __e;
  M.isDoWhileStatement = _me;
  M.isEmptyStatement = bme;
  M.isEmptyTypeAnnotation = hge;
  M.isEnumBody = Pve;
  M.isEnumBooleanBody = jge;
  M.isEnumBooleanMember = zge;
  M.isEnumDeclaration = Uge;
  M.isEnumDefaultedMember = $ge;
  M.isEnumMember = Dve;
  M.isEnumNumberBody = Vge;
  M.isEnumNumberMember = Gge;
  M.isEnumStringBody = Kge;
  M.isEnumStringMember = Wge;
  M.isEnumSymbolBody = Hge;
  M.isExistsTypeAnnotation = ige;
  M.isExportAllDeclaration = uye;
  M.isExportDeclaration = _ve;
  M.isExportDefaultDeclaration = lye;
  M.isExportDefaultSpecifier = b_e;
  M.isExportNamedDeclaration = cye;
  M.isExportNamespaceSpecifier = Oye;
  M.isExportSpecifier = fye;
  M.isExpression = Vbe;
  M.isExpressionStatement = vme;
  M.isExpressionWrapper = Zbe;
  M.isFile = Sme;
  M.isFlow = Tve;
  M.isFlowBaseAnnotation = Ave;
  M.isFlowDeclaration = xve;
  M.isFlowPredicate = Cve;
  M.isFlowType = Eve;
  M.isFor = eve;
  M.isForInStatement = Tme;
  M.isForOfStatement = pye;
  M.isForStatement = Eme;
  M.isForXStatement = tve;
  M.isFunction = rve;
  M.isFunctionDeclaration = Ame;
  M.isFunctionExpression = xme;
  M.isFunctionParent = ive;
  M.isFunctionTypeAnnotation = nge;
  M.isFunctionTypeParam = sge;
  M.isGenericTypeAnnotation = age;
  M.isIdentifier = Cme;
  M.isIfStatement = Pme;
  M.isImmutable = cve;
  M.isImport = Dye;
  M.isImportAttribute = qye;
  M.isImportDeclaration = hye;
  M.isImportDefaultSpecifier = dye;
  M.isImportExpression = gye;
  M.isImportNamespaceSpecifier = mye;
  M.isImportOrExportDeclaration = m8;
  M.isImportSpecifier = yye;
  M.isIndexedAccessType = Xge;
  M.isInferredPredicate = oge;
  M.isInterfaceDeclaration = lge;
  M.isInterfaceExtends = uge;
  M.isInterfaceTypeAnnotation = cge;
  M.isInterpreterDirective = ume;
  M.isIntersectionTypeAnnotation = fge;
  M.isJSX = wve;
  M.isJSXAttribute = Jge;
  M.isJSXClosingElement = Qge;
  M.isJSXClosingFragment = f_e;
  M.isJSXElement = Zge;
  M.isJSXEmptyExpression = e_e;
  M.isJSXExpressionContainer = t_e;
  M.isJSXFragment = l_e;
  M.isJSXIdentifier = i_e;
  M.isJSXMemberExpression = n_e;
  M.isJSXNamespacedName = s_e;
  M.isJSXOpeningElement = a_e;
  M.isJSXOpeningFragment = c_e;
  M.isJSXSpreadAttribute = o_e;
  M.isJSXSpreadChild = r_e;
  M.isJSXText = u_e;
  M.isLVal = ove;
  M.isLabeledStatement = Dme;
  M.isLiteral = lve;
  M.isLogicalExpression = Nme;
  M.isLoop = Jbe;
  M.isMemberExpression = Lme;
  M.isMetaProperty = _ye;
  M.isMethod = pve;
  M.isMiscellaneous = Ove;
  M.isMixedTypeAnnotation = pge;
  M.isModuleDeclaration = qve;
  M.isModuleExpression = E_e;
  M.isModuleSpecifier = bve;
  M.isNewExpression = Fme;
  M.isNoop = p_e;
  M.isNullLiteral = kme;
  M.isNullLiteralTypeAnnotation = Hye;
  M.isNullableTypeAnnotation = dge;
  M.isNumberLiteral = Lve;
  M.isNumberLiteralTypeAnnotation = mge;
  M.isNumberTypeAnnotation = yge;
  M.isNumericLiteral = Ome;
  M.isObjectExpression = Bme;
  M.isObjectMember = hve;
  M.isObjectMethod = qme;
  M.isObjectPattern = vye;
  M.isObjectProperty = Ume;
  M.isObjectTypeAnnotation = gge;
  M.isObjectTypeCallProperty = bge;
  M.isObjectTypeIndexer = vge;
  M.isObjectTypeInternalSlot = _ge;
  M.isObjectTypeProperty = Sge;
  M.isObjectTypeSpreadProperty = Tge;
  M.isOpaqueType = Ege;
  M.isOptionalCallExpression = Iye;
  M.isOptionalIndexedAccessType = Yge;
  M.isOptionalMemberExpression = kye;
  M.isParenthesizedExpression = Hme;
  M.isPattern = yve;
  M.isPatternLike = ave;
  M.isPipelineBareFunction = C_e;
  M.isPipelinePrimaryTopicReference = P_e;
  M.isPipelineTopicExpression = x_e;
  M.isPlaceholder = h_e;
  M.isPrivate = Sve;
  M.isPrivateName = Mye;
  M.isProgram = Mme;
  M.isProperty = dve;
  M.isPureish = nve;
  M.isQualifiedTypeIdentifier = Age;
  M.isRecordExpression = v_e;
  M.isRegExpLiteral = Rme;
  M.isRegexLiteral = Fve;
  M.isRestElement = jme;
  M.isRestProperty = Mve;
  M.isReturnStatement = Vme;
  M.isScopable = Hbe;
  M.isSequenceExpression = Kme;
  M.isSpreadElement = Sye;
  M.isSpreadProperty = Bve;
  M.isStandardized = jbe;
  M.isStatement = Wbe;
  M.isStaticBlock = Bye;
  M.isStringLiteral = wme;
  M.isStringLiteralTypeAnnotation = xge;
  M.isStringTypeAnnotation = Cge;
  M.isSuper = Tye;
  M.isSwitchCase = zme;
  M.isSwitchStatement = Gme;
  M.isSymbolTypeAnnotation = Pge;
  M.isTSAnyKeyword = M_e;
  M.isTSArrayType = ibe;
  M.isTSAsExpression = Ebe;
  M.isTSBaseType = Nve;
  M.isTSBigIntKeyword = q_e;
  M.isTSBooleanKeyword = B_e;
  M.isTSCallSignatureDeclaration = I_e;
  M.isTSConditionalType = cbe;
  M.isTSConstructSignatureDeclaration = R_e;
  M.isTSConstructorType = Q_e;
  M.isTSDeclareFunction = w_e;
  M.isTSDeclareMethod = O_e;
  M.isTSEntityName = uve;
  M.isTSEnumBody = Cbe;
  M.isTSEnumDeclaration = Pbe;
  M.isTSEnumMember = Dbe;
  M.isTSExportAssignment = Lbe;
  M.isTSExpressionWithTypeArguments = _be;
  M.isTSExternalModuleReference = Rbe;
  M.isTSFunctionType = J_e;
  M.isTSImportEqualsDeclaration = Ibe;
  M.isTSImportType = kbe;
  M.isTSIndexSignature = F_e;
  M.isTSIndexedAccessType = dbe;
  M.isTSInferType = fbe;
  M.isTSInstantiationExpression = Tbe;
  M.isTSInterfaceBody = vbe;
  M.isTSInterfaceDeclaration = bbe;
  M.isTSIntersectionType = lbe;
  M.isTSIntrinsicKeyword = U_e;
  M.isTSLiteralType = gbe;
  M.isTSMappedType = mbe;
  M.isTSMethodSignature = L_e;
  M.isTSModuleBlock = Obe;
  M.isTSModuleDeclaration = wbe;
  M.isTSNamedTupleMember = obe;
  M.isTSNamespaceExportDeclaration = Fbe;
  M.isTSNeverKeyword = j_e;
  M.isTSNonNullExpression = Nbe;
  M.isTSNullKeyword = V_e;
  M.isTSNumberKeyword = K_e;
  M.isTSObjectKeyword = H_e;
  M.isTSOptionalType = sbe;
  M.isTSParameterProperty = D_e;
  M.isTSParenthesizedType = pbe;
  M.isTSPropertySignature = N_e;
  M.isTSQualifiedName = k_e;
  M.isTSRestType = abe;
  M.isTSSatisfiesExpression = Abe;
  M.isTSStringKeyword = z_e;
  M.isTSSymbolKeyword = G_e;
  M.isTSTemplateLiteralType = ybe;
  M.isTSThisType = Y_e;
  M.isTSTupleType = nbe;
  M.isTSType = Rve;
  M.isTSTypeAliasDeclaration = Sbe;
  M.isTSTypeAnnotation = Mbe;
  M.isTSTypeAssertion = xbe;
  M.isTSTypeElement = Ive;
  M.isTSTypeLiteral = rbe;
  M.isTSTypeOperator = hbe;
  M.isTSTypeParameter = Ube;
  M.isTSTypeParameterDeclaration = qbe;
  M.isTSTypeParameterInstantiation = Bbe;
  M.isTSTypePredicate = ebe;
  M.isTSTypeQuery = tbe;
  M.isTSTypeReference = Z_e;
  M.isTSUndefinedKeyword = W_e;
  M.isTSUnionType = ube;
  M.isTSUnknownKeyword = $_e;
  M.isTSVoidKeyword = X_e;
  M.isTaggedTemplateExpression = Eye;
  M.isTemplateElement = Aye;
  M.isTemplateLiteral = xye;
  M.isTerminatorless = $be;
  M.isThisExpression = Wme;
  M.isThisTypeAnnotation = Dge;
  M.isThrowStatement = $me;
  M.isTopicReference = A_e;
  M.isTryStatement = Xme;
  M.isTupleExpression = S_e;
  M.isTupleTypeAnnotation = wge;
  M.isTypeAlias = kge;
  M.isTypeAnnotation = Ige;
  M.isTypeCastExpression = Rge;
  M.isTypeParameter = Nge;
  M.isTypeParameterDeclaration = Lge;
  M.isTypeParameterInstantiation = Fge;
  M.isTypeScript = kve;
  M.isTypeofTypeAnnotation = Oge;
  M.isUnaryExpression = Yme;
  M.isUnaryLike = mve;
  M.isUnionTypeAnnotation = Mge;
  M.isUpdateExpression = Jme;
  M.isUserWhitespacable = fve;
  M.isV8IntrinsicIdentifier = d_e;
  M.isVariableDeclaration = Qme;
  M.isVariableDeclarator = Zme;
  M.isVariance = Bge;
  M.isVoidTypeAnnotation = qge;
  M.isWhile = Qbe;
  M.isWhileStatement = eye;
  M.isWithStatement = tye;
  M.isYieldExpression = Cye;
  var U = Zg(), td = ed();
  function sme(e, t) {
    return !e || e.type !== "ArrayExpression" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(sme, "isArrayExpression");
  function ame(e, t) {
    return !e || e.type !== "AssignmentExpression" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(ame, "isAssignmentExpression");
  function ome(e, t) {
    return !e || e.type !== "BinaryExpression" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(ome, "isBinaryExpression");
  function ume(e, t) {
    return !e || e.type !== "InterpreterDirective" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(ume, "isInterpreterDirective");
  function lme(e, t) {
    return !e || e.type !== "Directive" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(lme, "isDirective");
  function cme(e, t) {
    return !e || e.type !== "DirectiveLiteral" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(cme, "isDirectiveLiteral");
  function fme(e, t) {
    return !e || e.type !== "BlockStatement" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(fme, "isBlockStatement");
  function pme(e, t) {
    return !e || e.type !== "BreakStatement" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(pme, "isBreakStatement");
  function hme(e, t) {
    return !e || e.type !== "CallExpression" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(hme, "isCallExpression");
  function dme(e, t) {
    return !e || e.type !== "CatchClause" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(dme, "isCatchClause");
  function mme(e, t) {
    return !e || e.type !== "ConditionalExpression" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(mme, "isConditionalExpression");
  function yme(e, t) {
    return !e || e.type !== "ContinueStatement" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(yme, "isContinueStatement");
  function gme(e, t) {
    return !e || e.type !== "DebuggerStatement" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(gme, "isDebuggerStatement");
  function _me(e, t) {
    return !e || e.type !== "DoWhileStatement" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(_me, "isDoWhileStatement");
  function bme(e, t) {
    return !e || e.type !== "EmptyStatement" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(bme, "isEmptyStatement");
  function vme(e, t) {
    return !e || e.type !== "ExpressionStatement" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(vme, "isExpressionStatement");
  function Sme(e, t) {
    return !e || e.type !== "File" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Sme, "isFile");
  function Tme(e, t) {
    return !e || e.type !== "ForInStatement" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Tme, "isForInStatement");
  function Eme(e, t) {
    return !e || e.type !== "ForStatement" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Eme, "isForStatement");
  function Ame(e, t) {
    return !e || e.type !== "FunctionDeclaration" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Ame, "isFunctionDeclaration");
  function xme(e, t) {
    return !e || e.type !== "FunctionExpression" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(xme, "isFunctionExpression");
  function Cme(e, t) {
    return !e || e.type !== "Identifier" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Cme, "isIdentifier");
  function Pme(e, t) {
    return !e || e.type !== "IfStatement" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Pme, "isIfStatement");
  function Dme(e, t) {
    return !e || e.type !== "LabeledStatement" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Dme, "isLabeledStatement");
  function wme(e, t) {
    return !e || e.type !== "StringLiteral" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(wme, "isStringLiteral");
  function Ome(e, t) {
    return !e || e.type !== "NumericLiteral" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Ome, "isNumericLiteral");
  function kme(e, t) {
    return !e || e.type !== "NullLiteral" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(kme, "isNullLiteral");
  function Ime(e, t) {
    return !e || e.type !== "BooleanLiteral" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Ime, "isBooleanLiteral");
  function Rme(e, t) {
    return !e || e.type !== "RegExpLiteral" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Rme, "isRegExpLiteral");
  function Nme(e, t) {
    return !e || e.type !== "LogicalExpression" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Nme, "isLogicalExpression");
  function Lme(e, t) {
    return !e || e.type !== "MemberExpression" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Lme, "isMemberExpression");
  function Fme(e, t) {
    return !e || e.type !== "NewExpression" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Fme, "isNewExpression");
  function Mme(e, t) {
    return !e || e.type !== "Program" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Mme, "isProgram");
  function Bme(e, t) {
    return !e || e.type !== "ObjectExpression" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Bme, "isObjectExpression");
  function qme(e, t) {
    return !e || e.type !== "ObjectMethod" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(qme, "isObjectMethod");
  function Ume(e, t) {
    return !e || e.type !== "ObjectProperty" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Ume, "isObjectProperty");
  function jme(e, t) {
    return !e || e.type !== "RestElement" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(jme, "isRestElement");
  function Vme(e, t) {
    return !e || e.type !== "ReturnStatement" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Vme, "isReturnStatement");
  function Kme(e, t) {
    return !e || e.type !== "SequenceExpression" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Kme, "isSequenceExpression");
  function Hme(e, t) {
    return !e || e.type !== "ParenthesizedExpression" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Hme, "isParenthesizedExpression");
  function zme(e, t) {
    return !e || e.type !== "SwitchCase" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(zme, "isSwitchCase");
  function Gme(e, t) {
    return !e || e.type !== "SwitchStatement" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Gme, "isSwitchStatement");
  function Wme(e, t) {
    return !e || e.type !== "ThisExpression" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Wme, "isThisExpression");
  function $me(e, t) {
    return !e || e.type !== "ThrowStatement" ? !1 : t == null || (0, U.default)(e, t);
  }
  s($me, "isThrowStatement");
  function Xme(e, t) {
    return !e || e.type !== "TryStatement" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Xme, "isTryStatement");
  function Yme(e, t) {
    return !e || e.type !== "UnaryExpression" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Yme, "isUnaryExpression");
  function Jme(e, t) {
    return !e || e.type !== "UpdateExpression" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Jme, "isUpdateExpression");
  function Qme(e, t) {
    return !e || e.type !== "VariableDeclaration" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Qme, "isVariableDeclaration");
  function Zme(e, t) {
    return !e || e.type !== "VariableDeclarator" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Zme, "isVariableDeclarator");
  function eye(e, t) {
    return !e || e.type !== "WhileStatement" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(eye, "isWhileStatement");
  function tye(e, t) {
    return !e || e.type !== "WithStatement" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(tye, "isWithStatement");
  function rye(e, t) {
    return !e || e.type !== "AssignmentPattern" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(rye, "isAssignmentPattern");
  function iye(e, t) {
    return !e || e.type !== "ArrayPattern" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(iye, "isArrayPattern");
  function nye(e, t) {
    return !e || e.type !== "ArrowFunctionExpression" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(nye, "isArrowFunctionExpression");
  function sye(e, t) {
    return !e || e.type !== "ClassBody" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(sye, "isClassBody");
  function aye(e, t) {
    return !e || e.type !== "ClassExpression" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(aye, "isClassExpression");
  function oye(e, t) {
    return !e || e.type !== "ClassDeclaration" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(oye, "isClassDeclaration");
  function uye(e, t) {
    return !e || e.type !== "ExportAllDeclaration" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(uye, "isExportAllDeclaration");
  function lye(e, t) {
    return !e || e.type !== "ExportDefaultDeclaration" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(lye, "isExportDefaultDeclaration");
  function cye(e, t) {
    return !e || e.type !== "ExportNamedDeclaration" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(cye, "isExportNamedDeclaration");
  function fye(e, t) {
    return !e || e.type !== "ExportSpecifier" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(fye, "isExportSpecifier");
  function pye(e, t) {
    return !e || e.type !== "ForOfStatement" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(pye, "isForOfStatement");
  function hye(e, t) {
    return !e || e.type !== "ImportDeclaration" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(hye, "isImportDeclaration");
  function dye(e, t) {
    return !e || e.type !== "ImportDefaultSpecifier" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(dye, "isImportDefaultSpecifier");
  function mye(e, t) {
    return !e || e.type !== "ImportNamespaceSpecifier" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(mye, "isImportNamespaceSpecifier");
  function yye(e, t) {
    return !e || e.type !== "ImportSpecifier" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(yye, "isImportSpecifier");
  function gye(e, t) {
    return !e || e.type !== "ImportExpression" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(gye, "isImportExpression");
  function _ye(e, t) {
    return !e || e.type !== "MetaProperty" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(_ye, "isMetaProperty");
  function bye(e, t) {
    return !e || e.type !== "ClassMethod" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(bye, "isClassMethod");
  function vye(e, t) {
    return !e || e.type !== "ObjectPattern" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(vye, "isObjectPattern");
  function Sye(e, t) {
    return !e || e.type !== "SpreadElement" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Sye, "isSpreadElement");
  function Tye(e, t) {
    return !e || e.type !== "Super" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Tye, "isSuper");
  function Eye(e, t) {
    return !e || e.type !== "TaggedTemplateExpression" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Eye, "isTaggedTemplateExpression");
  function Aye(e, t) {
    return !e || e.type !== "TemplateElement" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Aye, "isTemplateElement");
  function xye(e, t) {
    return !e || e.type !== "TemplateLiteral" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(xye, "isTemplateLiteral");
  function Cye(e, t) {
    return !e || e.type !== "YieldExpression" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Cye, "isYieldExpression");
  function Pye(e, t) {
    return !e || e.type !== "AwaitExpression" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Pye, "isAwaitExpression");
  function Dye(e, t) {
    return !e || e.type !== "Import" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Dye, "isImport");
  function wye(e, t) {
    return !e || e.type !== "BigIntLiteral" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(wye, "isBigIntLiteral");
  function Oye(e, t) {
    return !e || e.type !== "ExportNamespaceSpecifier" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Oye, "isExportNamespaceSpecifier");
  function kye(e, t) {
    return !e || e.type !== "OptionalMemberExpression" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(kye, "isOptionalMemberExpression");
  function Iye(e, t) {
    return !e || e.type !== "OptionalCallExpression" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Iye, "isOptionalCallExpression");
  function Rye(e, t) {
    return !e || e.type !== "ClassProperty" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Rye, "isClassProperty");
  function Nye(e, t) {
    return !e || e.type !== "ClassAccessorProperty" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Nye, "isClassAccessorProperty");
  function Lye(e, t) {
    return !e || e.type !== "ClassPrivateProperty" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Lye, "isClassPrivateProperty");
  function Fye(e, t) {
    return !e || e.type !== "ClassPrivateMethod" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Fye, "isClassPrivateMethod");
  function Mye(e, t) {
    return !e || e.type !== "PrivateName" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Mye, "isPrivateName");
  function Bye(e, t) {
    return !e || e.type !== "StaticBlock" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Bye, "isStaticBlock");
  function qye(e, t) {
    return !e || e.type !== "ImportAttribute" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(qye, "isImportAttribute");
  function Uye(e, t) {
    return !e || e.type !== "AnyTypeAnnotation" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Uye, "isAnyTypeAnnotation");
  function jye(e, t) {
    return !e || e.type !== "ArrayTypeAnnotation" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(jye, "isArrayTypeAnnotation");
  function Vye(e, t) {
    return !e || e.type !== "BooleanTypeAnnotation" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Vye, "isBooleanTypeAnnotation");
  function Kye(e, t) {
    return !e || e.type !== "BooleanLiteralTypeAnnotation" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Kye, "isBooleanLiteralTypeAnnotation");
  function Hye(e, t) {
    return !e || e.type !== "NullLiteralTypeAnnotation" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Hye, "isNullLiteralTypeAnnotation");
  function zye(e, t) {
    return !e || e.type !== "ClassImplements" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(zye, "isClassImplements");
  function Gye(e, t) {
    return !e || e.type !== "DeclareClass" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Gye, "isDeclareClass");
  function Wye(e, t) {
    return !e || e.type !== "DeclareFunction" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Wye, "isDeclareFunction");
  function $ye(e, t) {
    return !e || e.type !== "DeclareInterface" ? !1 : t == null || (0, U.default)(e, t);
  }
  s($ye, "isDeclareInterface");
  function Xye(e, t) {
    return !e || e.type !== "DeclareModule" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Xye, "isDeclareModule");
  function Yye(e, t) {
    return !e || e.type !== "DeclareModuleExports" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Yye, "isDeclareModuleExports");
  function Jye(e, t) {
    return !e || e.type !== "DeclareTypeAlias" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Jye, "isDeclareTypeAlias");
  function Qye(e, t) {
    return !e || e.type !== "DeclareOpaqueType" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Qye, "isDeclareOpaqueType");
  function Zye(e, t) {
    return !e || e.type !== "DeclareVariable" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Zye, "isDeclareVariable");
  function ege(e, t) {
    return !e || e.type !== "DeclareExportDeclaration" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(ege, "isDeclareExportDeclaration");
  function tge(e, t) {
    return !e || e.type !== "DeclareExportAllDeclaration" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(tge, "isDeclareExportAllDeclaration");
  function rge(e, t) {
    return !e || e.type !== "DeclaredPredicate" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(rge, "isDeclaredPredicate");
  function ige(e, t) {
    return !e || e.type !== "ExistsTypeAnnotation" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(ige, "isExistsTypeAnnotation");
  function nge(e, t) {
    return !e || e.type !== "FunctionTypeAnnotation" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(nge, "isFunctionTypeAnnotation");
  function sge(e, t) {
    return !e || e.type !== "FunctionTypeParam" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(sge, "isFunctionTypeParam");
  function age(e, t) {
    return !e || e.type !== "GenericTypeAnnotation" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(age, "isGenericTypeAnnotation");
  function oge(e, t) {
    return !e || e.type !== "InferredPredicate" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(oge, "isInferredPredicate");
  function uge(e, t) {
    return !e || e.type !== "InterfaceExtends" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(uge, "isInterfaceExtends");
  function lge(e, t) {
    return !e || e.type !== "InterfaceDeclaration" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(lge, "isInterfaceDeclaration");
  function cge(e, t) {
    return !e || e.type !== "InterfaceTypeAnnotation" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(cge, "isInterfaceTypeAnnotation");
  function fge(e, t) {
    return !e || e.type !== "IntersectionTypeAnnotation" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(fge, "isIntersectionTypeAnnotation");
  function pge(e, t) {
    return !e || e.type !== "MixedTypeAnnotation" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(pge, "isMixedTypeAnnotation");
  function hge(e, t) {
    return !e || e.type !== "EmptyTypeAnnotation" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(hge, "isEmptyTypeAnnotation");
  function dge(e, t) {
    return !e || e.type !== "NullableTypeAnnotation" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(dge, "isNullableTypeAnnotation");
  function mge(e, t) {
    return !e || e.type !== "NumberLiteralTypeAnnotation" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(mge, "isNumberLiteralTypeAnnotation");
  function yge(e, t) {
    return !e || e.type !== "NumberTypeAnnotation" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(yge, "isNumberTypeAnnotation");
  function gge(e, t) {
    return !e || e.type !== "ObjectTypeAnnotation" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(gge, "isObjectTypeAnnotation");
  function _ge(e, t) {
    return !e || e.type !== "ObjectTypeInternalSlot" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(_ge, "isObjectTypeInternalSlot");
  function bge(e, t) {
    return !e || e.type !== "ObjectTypeCallProperty" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(bge, "isObjectTypeCallProperty");
  function vge(e, t) {
    return !e || e.type !== "ObjectTypeIndexer" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(vge, "isObjectTypeIndexer");
  function Sge(e, t) {
    return !e || e.type !== "ObjectTypeProperty" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Sge, "isObjectTypeProperty");
  function Tge(e, t) {
    return !e || e.type !== "ObjectTypeSpreadProperty" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Tge, "isObjectTypeSpreadProperty");
  function Ege(e, t) {
    return !e || e.type !== "OpaqueType" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Ege, "isOpaqueType");
  function Age(e, t) {
    return !e || e.type !== "QualifiedTypeIdentifier" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Age, "isQualifiedTypeIdentifier");
  function xge(e, t) {
    return !e || e.type !== "StringLiteralTypeAnnotation" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(xge, "isStringLiteralTypeAnnotation");
  function Cge(e, t) {
    return !e || e.type !== "StringTypeAnnotation" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Cge, "isStringTypeAnnotation");
  function Pge(e, t) {
    return !e || e.type !== "SymbolTypeAnnotation" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Pge, "isSymbolTypeAnnotation");
  function Dge(e, t) {
    return !e || e.type !== "ThisTypeAnnotation" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Dge, "isThisTypeAnnotation");
  function wge(e, t) {
    return !e || e.type !== "TupleTypeAnnotation" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(wge, "isTupleTypeAnnotation");
  function Oge(e, t) {
    return !e || e.type !== "TypeofTypeAnnotation" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Oge, "isTypeofTypeAnnotation");
  function kge(e, t) {
    return !e || e.type !== "TypeAlias" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(kge, "isTypeAlias");
  function Ige(e, t) {
    return !e || e.type !== "TypeAnnotation" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Ige, "isTypeAnnotation");
  function Rge(e, t) {
    return !e || e.type !== "TypeCastExpression" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Rge, "isTypeCastExpression");
  function Nge(e, t) {
    return !e || e.type !== "TypeParameter" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Nge, "isTypeParameter");
  function Lge(e, t) {
    return !e || e.type !== "TypeParameterDeclaration" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Lge, "isTypeParameterDeclaration");
  function Fge(e, t) {
    return !e || e.type !== "TypeParameterInstantiation" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Fge, "isTypeParameterInstantiation");
  function Mge(e, t) {
    return !e || e.type !== "UnionTypeAnnotation" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Mge, "isUnionTypeAnnotation");
  function Bge(e, t) {
    return !e || e.type !== "Variance" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Bge, "isVariance");
  function qge(e, t) {
    return !e || e.type !== "VoidTypeAnnotation" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(qge, "isVoidTypeAnnotation");
  function Uge(e, t) {
    return !e || e.type !== "EnumDeclaration" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Uge, "isEnumDeclaration");
  function jge(e, t) {
    return !e || e.type !== "EnumBooleanBody" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(jge, "isEnumBooleanBody");
  function Vge(e, t) {
    return !e || e.type !== "EnumNumberBody" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Vge, "isEnumNumberBody");
  function Kge(e, t) {
    return !e || e.type !== "EnumStringBody" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Kge, "isEnumStringBody");
  function Hge(e, t) {
    return !e || e.type !== "EnumSymbolBody" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Hge, "isEnumSymbolBody");
  function zge(e, t) {
    return !e || e.type !== "EnumBooleanMember" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(zge, "isEnumBooleanMember");
  function Gge(e, t) {
    return !e || e.type !== "EnumNumberMember" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Gge, "isEnumNumberMember");
  function Wge(e, t) {
    return !e || e.type !== "EnumStringMember" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Wge, "isEnumStringMember");
  function $ge(e, t) {
    return !e || e.type !== "EnumDefaultedMember" ? !1 : t == null || (0, U.default)(e, t);
  }
  s($ge, "isEnumDefaultedMember");
  function Xge(e, t) {
    return !e || e.type !== "IndexedAccessType" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Xge, "isIndexedAccessType");
  function Yge(e, t) {
    return !e || e.type !== "OptionalIndexedAccessType" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Yge, "isOptionalIndexedAccessType");
  function Jge(e, t) {
    return !e || e.type !== "JSXAttribute" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Jge, "isJSXAttribute");
  function Qge(e, t) {
    return !e || e.type !== "JSXClosingElement" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Qge, "isJSXClosingElement");
  function Zge(e, t) {
    return !e || e.type !== "JSXElement" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Zge, "isJSXElement");
  function e_e(e, t) {
    return !e || e.type !== "JSXEmptyExpression" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(e_e, "isJSXEmptyExpression");
  function t_e(e, t) {
    return !e || e.type !== "JSXExpressionContainer" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(t_e, "isJSXExpressionContainer");
  function r_e(e, t) {
    return !e || e.type !== "JSXSpreadChild" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(r_e, "isJSXSpreadChild");
  function i_e(e, t) {
    return !e || e.type !== "JSXIdentifier" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(i_e, "isJSXIdentifier");
  function n_e(e, t) {
    return !e || e.type !== "JSXMemberExpression" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(n_e, "isJSXMemberExpression");
  function s_e(e, t) {
    return !e || e.type !== "JSXNamespacedName" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(s_e, "isJSXNamespacedName");
  function a_e(e, t) {
    return !e || e.type !== "JSXOpeningElement" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(a_e, "isJSXOpeningElement");
  function o_e(e, t) {
    return !e || e.type !== "JSXSpreadAttribute" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(o_e, "isJSXSpreadAttribute");
  function u_e(e, t) {
    return !e || e.type !== "JSXText" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(u_e, "isJSXText");
  function l_e(e, t) {
    return !e || e.type !== "JSXFragment" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(l_e, "isJSXFragment");
  function c_e(e, t) {
    return !e || e.type !== "JSXOpeningFragment" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(c_e, "isJSXOpeningFragment");
  function f_e(e, t) {
    return !e || e.type !== "JSXClosingFragment" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(f_e, "isJSXClosingFragment");
  function p_e(e, t) {
    return !e || e.type !== "Noop" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(p_e, "isNoop");
  function h_e(e, t) {
    return !e || e.type !== "Placeholder" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(h_e, "isPlaceholder");
  function d_e(e, t) {
    return !e || e.type !== "V8IntrinsicIdentifier" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(d_e, "isV8IntrinsicIdentifier");
  function m_e(e, t) {
    return !e || e.type !== "ArgumentPlaceholder" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(m_e, "isArgumentPlaceholder");
  function y_e(e, t) {
    return !e || e.type !== "BindExpression" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(y_e, "isBindExpression");
  function g_e(e, t) {
    return !e || e.type !== "Decorator" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(g_e, "isDecorator");
  function __e(e, t) {
    return !e || e.type !== "DoExpression" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(__e, "isDoExpression");
  function b_e(e, t) {
    return !e || e.type !== "ExportDefaultSpecifier" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(b_e, "isExportDefaultSpecifier");
  function v_e(e, t) {
    return !e || e.type !== "RecordExpression" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(v_e, "isRecordExpression");
  function S_e(e, t) {
    return !e || e.type !== "TupleExpression" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(S_e, "isTupleExpression");
  function T_e(e, t) {
    return !e || e.type !== "DecimalLiteral" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(T_e, "isDecimalLiteral");
  function E_e(e, t) {
    return !e || e.type !== "ModuleExpression" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(E_e, "isModuleExpression");
  function A_e(e, t) {
    return !e || e.type !== "TopicReference" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(A_e, "isTopicReference");
  function x_e(e, t) {
    return !e || e.type !== "PipelineTopicExpression" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(x_e, "isPipelineTopicExpression");
  function C_e(e, t) {
    return !e || e.type !== "PipelineBareFunction" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(C_e, "isPipelineBareFunction");
  function P_e(e, t) {
    return !e || e.type !== "PipelinePrimaryTopicReference" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(P_e, "isPipelinePrimaryTopicReference");
  function D_e(e, t) {
    return !e || e.type !== "TSParameterProperty" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(D_e, "isTSParameterProperty");
  function w_e(e, t) {
    return !e || e.type !== "TSDeclareFunction" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(w_e, "isTSDeclareFunction");
  function O_e(e, t) {
    return !e || e.type !== "TSDeclareMethod" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(O_e, "isTSDeclareMethod");
  function k_e(e, t) {
    return !e || e.type !== "TSQualifiedName" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(k_e, "isTSQualifiedName");
  function I_e(e, t) {
    return !e || e.type !== "TSCallSignatureDeclaration" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(I_e, "isTSCallSignatureDeclaration");
  function R_e(e, t) {
    return !e || e.type !== "TSConstructSignatureDeclaration" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(R_e, "isTSConstructSignatureDeclaration");
  function N_e(e, t) {
    return !e || e.type !== "TSPropertySignature" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(N_e, "isTSPropertySignature");
  function L_e(e, t) {
    return !e || e.type !== "TSMethodSignature" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(L_e, "isTSMethodSignature");
  function F_e(e, t) {
    return !e || e.type !== "TSIndexSignature" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(F_e, "isTSIndexSignature");
  function M_e(e, t) {
    return !e || e.type !== "TSAnyKeyword" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(M_e, "isTSAnyKeyword");
  function B_e(e, t) {
    return !e || e.type !== "TSBooleanKeyword" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(B_e, "isTSBooleanKeyword");
  function q_e(e, t) {
    return !e || e.type !== "TSBigIntKeyword" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(q_e, "isTSBigIntKeyword");
  function U_e(e, t) {
    return !e || e.type !== "TSIntrinsicKeyword" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(U_e, "isTSIntrinsicKeyword");
  function j_e(e, t) {
    return !e || e.type !== "TSNeverKeyword" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(j_e, "isTSNeverKeyword");
  function V_e(e, t) {
    return !e || e.type !== "TSNullKeyword" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(V_e, "isTSNullKeyword");
  function K_e(e, t) {
    return !e || e.type !== "TSNumberKeyword" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(K_e, "isTSNumberKeyword");
  function H_e(e, t) {
    return !e || e.type !== "TSObjectKeyword" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(H_e, "isTSObjectKeyword");
  function z_e(e, t) {
    return !e || e.type !== "TSStringKeyword" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(z_e, "isTSStringKeyword");
  function G_e(e, t) {
    return !e || e.type !== "TSSymbolKeyword" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(G_e, "isTSSymbolKeyword");
  function W_e(e, t) {
    return !e || e.type !== "TSUndefinedKeyword" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(W_e, "isTSUndefinedKeyword");
  function $_e(e, t) {
    return !e || e.type !== "TSUnknownKeyword" ? !1 : t == null || (0, U.default)(e, t);
  }
  s($_e, "isTSUnknownKeyword");
  function X_e(e, t) {
    return !e || e.type !== "TSVoidKeyword" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(X_e, "isTSVoidKeyword");
  function Y_e(e, t) {
    return !e || e.type !== "TSThisType" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Y_e, "isTSThisType");
  function J_e(e, t) {
    return !e || e.type !== "TSFunctionType" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(J_e, "isTSFunctionType");
  function Q_e(e, t) {
    return !e || e.type !== "TSConstructorType" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Q_e, "isTSConstructorType");
  function Z_e(e, t) {
    return !e || e.type !== "TSTypeReference" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Z_e, "isTSTypeReference");
  function ebe(e, t) {
    return !e || e.type !== "TSTypePredicate" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(ebe, "isTSTypePredicate");
  function tbe(e, t) {
    return !e || e.type !== "TSTypeQuery" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(tbe, "isTSTypeQuery");
  function rbe(e, t) {
    return !e || e.type !== "TSTypeLiteral" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(rbe, "isTSTypeLiteral");
  function ibe(e, t) {
    return !e || e.type !== "TSArrayType" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(ibe, "isTSArrayType");
  function nbe(e, t) {
    return !e || e.type !== "TSTupleType" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(nbe, "isTSTupleType");
  function sbe(e, t) {
    return !e || e.type !== "TSOptionalType" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(sbe, "isTSOptionalType");
  function abe(e, t) {
    return !e || e.type !== "TSRestType" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(abe, "isTSRestType");
  function obe(e, t) {
    return !e || e.type !== "TSNamedTupleMember" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(obe, "isTSNamedTupleMember");
  function ube(e, t) {
    return !e || e.type !== "TSUnionType" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(ube, "isTSUnionType");
  function lbe(e, t) {
    return !e || e.type !== "TSIntersectionType" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(lbe, "isTSIntersectionType");
  function cbe(e, t) {
    return !e || e.type !== "TSConditionalType" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(cbe, "isTSConditionalType");
  function fbe(e, t) {
    return !e || e.type !== "TSInferType" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(fbe, "isTSInferType");
  function pbe(e, t) {
    return !e || e.type !== "TSParenthesizedType" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(pbe, "isTSParenthesizedType");
  function hbe(e, t) {
    return !e || e.type !== "TSTypeOperator" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(hbe, "isTSTypeOperator");
  function dbe(e, t) {
    return !e || e.type !== "TSIndexedAccessType" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(dbe, "isTSIndexedAccessType");
  function mbe(e, t) {
    return !e || e.type !== "TSMappedType" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(mbe, "isTSMappedType");
  function ybe(e, t) {
    return !e || e.type !== "TSTemplateLiteralType" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(ybe, "isTSTemplateLiteralType");
  function gbe(e, t) {
    return !e || e.type !== "TSLiteralType" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(gbe, "isTSLiteralType");
  function _be(e, t) {
    return !e || e.type !== "TSExpressionWithTypeArguments" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(_be, "isTSExpressionWithTypeArguments");
  function bbe(e, t) {
    return !e || e.type !== "TSInterfaceDeclaration" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(bbe, "isTSInterfaceDeclaration");
  function vbe(e, t) {
    return !e || e.type !== "TSInterfaceBody" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(vbe, "isTSInterfaceBody");
  function Sbe(e, t) {
    return !e || e.type !== "TSTypeAliasDeclaration" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Sbe, "isTSTypeAliasDeclaration");
  function Tbe(e, t) {
    return !e || e.type !== "TSInstantiationExpression" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Tbe, "isTSInstantiationExpression");
  function Ebe(e, t) {
    return !e || e.type !== "TSAsExpression" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Ebe, "isTSAsExpression");
  function Abe(e, t) {
    return !e || e.type !== "TSSatisfiesExpression" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Abe, "isTSSatisfiesExpression");
  function xbe(e, t) {
    return !e || e.type !== "TSTypeAssertion" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(xbe, "isTSTypeAssertion");
  function Cbe(e, t) {
    return !e || e.type !== "TSEnumBody" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Cbe, "isTSEnumBody");
  function Pbe(e, t) {
    return !e || e.type !== "TSEnumDeclaration" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Pbe, "isTSEnumDeclaration");
  function Dbe(e, t) {
    return !e || e.type !== "TSEnumMember" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Dbe, "isTSEnumMember");
  function wbe(e, t) {
    return !e || e.type !== "TSModuleDeclaration" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(wbe, "isTSModuleDeclaration");
  function Obe(e, t) {
    return !e || e.type !== "TSModuleBlock" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Obe, "isTSModuleBlock");
  function kbe(e, t) {
    return !e || e.type !== "TSImportType" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(kbe, "isTSImportType");
  function Ibe(e, t) {
    return !e || e.type !== "TSImportEqualsDeclaration" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Ibe, "isTSImportEqualsDeclaration");
  function Rbe(e, t) {
    return !e || e.type !== "TSExternalModuleReference" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Rbe, "isTSExternalModuleReference");
  function Nbe(e, t) {
    return !e || e.type !== "TSNonNullExpression" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Nbe, "isTSNonNullExpression");
  function Lbe(e, t) {
    return !e || e.type !== "TSExportAssignment" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Lbe, "isTSExportAssignment");
  function Fbe(e, t) {
    return !e || e.type !== "TSNamespaceExportDeclaration" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Fbe, "isTSNamespaceExportDeclaration");
  function Mbe(e, t) {
    return !e || e.type !== "TSTypeAnnotation" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Mbe, "isTSTypeAnnotation");
  function Bbe(e, t) {
    return !e || e.type !== "TSTypeParameterInstantiation" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Bbe, "isTSTypeParameterInstantiation");
  function qbe(e, t) {
    return !e || e.type !== "TSTypeParameterDeclaration" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(qbe, "isTSTypeParameterDeclaration");
  function Ube(e, t) {
    return !e || e.type !== "TSTypeParameter" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Ube, "isTSTypeParameter");
  function jbe(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ArrayExpression":
      case "AssignmentExpression":
      case "BinaryExpression":
      case "InterpreterDirective":
      case "Directive":
      case "DirectiveLiteral":
      case "BlockStatement":
      case "BreakStatement":
      case "CallExpression":
      case "CatchClause":
      case "ConditionalExpression":
      case "ContinueStatement":
      case "DebuggerStatement":
      case "DoWhileStatement":
      case "EmptyStatement":
      case "ExpressionStatement":
      case "File":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "Identifier":
      case "IfStatement":
      case "LabeledStatement":
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "LogicalExpression":
      case "MemberExpression":
      case "NewExpression":
      case "Program":
      case "ObjectExpression":
      case "ObjectMethod":
      case "ObjectProperty":
      case "RestElement":
      case "ReturnStatement":
      case "SequenceExpression":
      case "ParenthesizedExpression":
      case "SwitchCase":
      case "SwitchStatement":
      case "ThisExpression":
      case "ThrowStatement":
      case "TryStatement":
      case "UnaryExpression":
      case "UpdateExpression":
      case "VariableDeclaration":
      case "VariableDeclarator":
      case "WhileStatement":
      case "WithStatement":
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ArrowFunctionExpression":
      case "ClassBody":
      case "ClassExpression":
      case "ClassDeclaration":
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ExportSpecifier":
      case "ForOfStatement":
      case "ImportDeclaration":
      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "ImportSpecifier":
      case "ImportExpression":
      case "MetaProperty":
      case "ClassMethod":
      case "ObjectPattern":
      case "SpreadElement":
      case "Super":
      case "TaggedTemplateExpression":
      case "TemplateElement":
      case "TemplateLiteral":
      case "YieldExpression":
      case "AwaitExpression":
      case "Import":
      case "BigIntLiteral":
      case "ExportNamespaceSpecifier":
      case "OptionalMemberExpression":
      case "OptionalCallExpression":
      case "ClassProperty":
      case "ClassAccessorProperty":
      case "ClassPrivateProperty":
      case "ClassPrivateMethod":
      case "PrivateName":
      case "StaticBlock":
      case "ImportAttribute":
        break;
      case "Placeholder":
        switch (e.expectedNode) {
          case "Identifier":
          case "StringLiteral":
          case "BlockStatement":
          case "ClassBody":
            break;
          default:
            return !1;
        }
        break;
      default:
        return !1;
    }
    return t == null || (0, U.default)(e, t);
  }
  s(jbe, "isStandardized");
  function Vbe(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ArrayExpression":
      case "AssignmentExpression":
      case "BinaryExpression":
      case "CallExpression":
      case "ConditionalExpression":
      case "FunctionExpression":
      case "Identifier":
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "LogicalExpression":
      case "MemberExpression":
      case "NewExpression":
      case "ObjectExpression":
      case "SequenceExpression":
      case "ParenthesizedExpression":
      case "ThisExpression":
      case "UnaryExpression":
      case "UpdateExpression":
      case "ArrowFunctionExpression":
      case "ClassExpression":
      case "ImportExpression":
      case "MetaProperty":
      case "Super":
      case "TaggedTemplateExpression":
      case "TemplateLiteral":
      case "YieldExpression":
      case "AwaitExpression":
      case "Import":
      case "BigIntLiteral":
      case "OptionalMemberExpression":
      case "OptionalCallExpression":
      case "TypeCastExpression":
      case "JSXElement":
      case "JSXFragment":
      case "BindExpression":
      case "DoExpression":
      case "RecordExpression":
      case "TupleExpression":
      case "DecimalLiteral":
      case "ModuleExpression":
      case "TopicReference":
      case "PipelineTopicExpression":
      case "PipelineBareFunction":
      case "PipelinePrimaryTopicReference":
      case "TSInstantiationExpression":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSNonNullExpression":
        break;
      case "Placeholder":
        switch (e.expectedNode) {
          case "Expression":
          case "Identifier":
          case "StringLiteral":
            break;
          default:
            return !1;
        }
        break;
      default:
        return !1;
    }
    return t == null || (0, U.default)(e, t);
  }
  s(Vbe, "isExpression");
  function Kbe(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "BinaryExpression":
      case "LogicalExpression":
        break;
      default:
        return !1;
    }
    return t == null || (0, U.default)(e, t);
  }
  s(Kbe, "isBinary");
  function Hbe(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "BlockStatement":
      case "CatchClause":
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "Program":
      case "ObjectMethod":
      case "SwitchStatement":
      case "WhileStatement":
      case "ArrowFunctionExpression":
      case "ClassExpression":
      case "ClassDeclaration":
      case "ForOfStatement":
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "StaticBlock":
      case "TSModuleBlock":
        break;
      case "Placeholder":
        if (e.expectedNode === "BlockStatement") break;
      default:
        return !1;
    }
    return t == null || (0, U.default)(e, t);
  }
  s(Hbe, "isScopable");
  function zbe(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "BlockStatement":
      case "CatchClause":
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "Program":
      case "ObjectMethod":
      case "SwitchStatement":
      case "WhileStatement":
      case "ArrowFunctionExpression":
      case "ForOfStatement":
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "StaticBlock":
      case "TSModuleBlock":
        break;
      case "Placeholder":
        if (e.expectedNode === "BlockStatement") break;
      default:
        return !1;
    }
    return t == null || (0, U.default)(e, t);
  }
  s(zbe, "isBlockParent");
  function Gbe(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "BlockStatement":
      case "Program":
      case "TSModuleBlock":
        break;
      case "Placeholder":
        if (e.expectedNode === "BlockStatement") break;
      default:
        return !1;
    }
    return t == null || (0, U.default)(e, t);
  }
  s(Gbe, "isBlock");
  function Wbe(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "BlockStatement":
      case "BreakStatement":
      case "ContinueStatement":
      case "DebuggerStatement":
      case "DoWhileStatement":
      case "EmptyStatement":
      case "ExpressionStatement":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "IfStatement":
      case "LabeledStatement":
      case "ReturnStatement":
      case "SwitchStatement":
      case "ThrowStatement":
      case "TryStatement":
      case "VariableDeclaration":
      case "WhileStatement":
      case "WithStatement":
      case "ClassDeclaration":
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ForOfStatement":
      case "ImportDeclaration":
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "InterfaceDeclaration":
      case "OpaqueType":
      case "TypeAlias":
      case "EnumDeclaration":
      case "TSDeclareFunction":
      case "TSInterfaceDeclaration":
      case "TSTypeAliasDeclaration":
      case "TSEnumDeclaration":
      case "TSModuleDeclaration":
      case "TSImportEqualsDeclaration":
      case "TSExportAssignment":
      case "TSNamespaceExportDeclaration":
        break;
      case "Placeholder":
        switch (e.expectedNode) {
          case "Statement":
          case "Declaration":
          case "BlockStatement":
            break;
          default:
            return !1;
        }
        break;
      default:
        return !1;
    }
    return t == null || (0, U.default)(e, t);
  }
  s(Wbe, "isStatement");
  function $be(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "BreakStatement":
      case "ContinueStatement":
      case "ReturnStatement":
      case "ThrowStatement":
      case "YieldExpression":
      case "AwaitExpression":
        break;
      default:
        return !1;
    }
    return t == null || (0, U.default)(e, t);
  }
  s($be, "isTerminatorless");
  function Xbe(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "BreakStatement":
      case "ContinueStatement":
      case "ReturnStatement":
      case "ThrowStatement":
        break;
      default:
        return !1;
    }
    return t == null || (0, U.default)(e, t);
  }
  s(Xbe, "isCompletionStatement");
  function Ybe(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ConditionalExpression":
      case "IfStatement":
        break;
      default:
        return !1;
    }
    return t == null || (0, U.default)(e, t);
  }
  s(Ybe, "isConditional");
  function Jbe(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForStatement":
      case "WhileStatement":
      case "ForOfStatement":
        break;
      default:
        return !1;
    }
    return t == null || (0, U.default)(e, t);
  }
  s(Jbe, "isLoop");
  function Qbe(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "DoWhileStatement":
      case "WhileStatement":
        break;
      default:
        return !1;
    }
    return t == null || (0, U.default)(e, t);
  }
  s(Qbe, "isWhile");
  function Zbe(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ExpressionStatement":
      case "ParenthesizedExpression":
      case "TypeCastExpression":
        break;
      default:
        return !1;
    }
    return t == null || (0, U.default)(e, t);
  }
  s(Zbe, "isExpressionWrapper");
  function eve(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ForInStatement":
      case "ForStatement":
      case "ForOfStatement":
        break;
      default:
        return !1;
    }
    return t == null || (0, U.default)(e, t);
  }
  s(eve, "isFor");
  function tve(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ForInStatement":
      case "ForOfStatement":
        break;
      default:
        return !1;
    }
    return t == null || (0, U.default)(e, t);
  }
  s(tve, "isForXStatement");
  function rve(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "ObjectMethod":
      case "ArrowFunctionExpression":
      case "ClassMethod":
      case "ClassPrivateMethod":
        break;
      default:
        return !1;
    }
    return t == null || (0, U.default)(e, t);
  }
  s(rve, "isFunction");
  function ive(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "ObjectMethod":
      case "ArrowFunctionExpression":
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "StaticBlock":
      case "TSModuleBlock":
        break;
      default:
        return !1;
    }
    return t == null || (0, U.default)(e, t);
  }
  s(ive, "isFunctionParent");
  function nve(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "ArrowFunctionExpression":
      case "BigIntLiteral":
      case "DecimalLiteral":
        break;
      case "Placeholder":
        if (e.expectedNode === "StringLiteral") break;
      default:
        return !1;
    }
    return t == null || (0, U.default)(e, t);
  }
  s(nve, "isPureish");
  function sve(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "FunctionDeclaration":
      case "VariableDeclaration":
      case "ClassDeclaration":
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ImportDeclaration":
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "InterfaceDeclaration":
      case "OpaqueType":
      case "TypeAlias":
      case "EnumDeclaration":
      case "TSDeclareFunction":
      case "TSInterfaceDeclaration":
      case "TSTypeAliasDeclaration":
      case "TSEnumDeclaration":
      case "TSModuleDeclaration":
      case "TSImportEqualsDeclaration":
        break;
      case "Placeholder":
        if (e.expectedNode === "Declaration") break;
      default:
        return !1;
    }
    return t == null || (0, U.default)(e, t);
  }
  s(sve, "isDeclaration");
  function ave(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "Identifier":
      case "RestElement":
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ObjectPattern":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSNonNullExpression":
        break;
      case "Placeholder":
        switch (e.expectedNode) {
          case "Pattern":
          case "Identifier":
            break;
          default:
            return !1;
        }
        break;
      default:
        return !1;
    }
    return t == null || (0, U.default)(e, t);
  }
  s(ave, "isPatternLike");
  function ove(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "Identifier":
      case "MemberExpression":
      case "RestElement":
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ObjectPattern":
      case "TSParameterProperty":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSNonNullExpression":
        break;
      case "Placeholder":
        switch (e.expectedNode) {
          case "Pattern":
          case "Identifier":
            break;
          default:
            return !1;
        }
        break;
      default:
        return !1;
    }
    return t == null || (0, U.default)(e, t);
  }
  s(ove, "isLVal");
  function uve(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "Identifier":
      case "TSQualifiedName":
        break;
      case "Placeholder":
        if (e.expectedNode === "Identifier") break;
      default:
        return !1;
    }
    return t == null || (0, U.default)(e, t);
  }
  s(uve, "isTSEntityName");
  function lve(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "TemplateLiteral":
      case "BigIntLiteral":
      case "DecimalLiteral":
        break;
      case "Placeholder":
        if (e.expectedNode === "StringLiteral") break;
      default:
        return !1;
    }
    return t == null || (0, U.default)(e, t);
  }
  s(lve, "isLiteral");
  function cve(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "BigIntLiteral":
      case "JSXAttribute":
      case "JSXClosingElement":
      case "JSXElement":
      case "JSXExpressionContainer":
      case "JSXSpreadChild":
      case "JSXOpeningElement":
      case "JSXText":
      case "JSXFragment":
      case "JSXOpeningFragment":
      case "JSXClosingFragment":
      case "DecimalLiteral":
        break;
      case "Placeholder":
        if (e.expectedNode === "StringLiteral") break;
      default:
        return !1;
    }
    return t == null || (0, U.default)(e, t);
  }
  s(cve, "isImmutable");
  function fve(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ObjectMethod":
      case "ObjectProperty":
      case "ObjectTypeInternalSlot":
      case "ObjectTypeCallProperty":
      case "ObjectTypeIndexer":
      case "ObjectTypeProperty":
      case "ObjectTypeSpreadProperty":
        break;
      default:
        return !1;
    }
    return t == null || (0, U.default)(e, t);
  }
  s(fve, "isUserWhitespacable");
  function pve(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ObjectMethod":
      case "ClassMethod":
      case "ClassPrivateMethod":
        break;
      default:
        return !1;
    }
    return t == null || (0, U.default)(e, t);
  }
  s(pve, "isMethod");
  function hve(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ObjectMethod":
      case "ObjectProperty":
        break;
      default:
        return !1;
    }
    return t == null || (0, U.default)(e, t);
  }
  s(hve, "isObjectMember");
  function dve(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ObjectProperty":
      case "ClassProperty":
      case "ClassAccessorProperty":
      case "ClassPrivateProperty":
        break;
      default:
        return !1;
    }
    return t == null || (0, U.default)(e, t);
  }
  s(dve, "isProperty");
  function mve(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "UnaryExpression":
      case "SpreadElement":
        break;
      default:
        return !1;
    }
    return t == null || (0, U.default)(e, t);
  }
  s(mve, "isUnaryLike");
  function yve(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ObjectPattern":
        break;
      case "Placeholder":
        if (e.expectedNode === "Pattern") break;
      default:
        return !1;
    }
    return t == null || (0, U.default)(e, t);
  }
  s(yve, "isPattern");
  function gve(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ClassExpression":
      case "ClassDeclaration":
        break;
      default:
        return !1;
    }
    return t == null || (0, U.default)(e, t);
  }
  s(gve, "isClass");
  function m8(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ImportDeclaration":
        break;
      default:
        return !1;
    }
    return t == null || (0, U.default)(e, t);
  }
  s(m8, "isImportOrExportDeclaration");
  function _ve(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
        break;
      default:
        return !1;
    }
    return t == null || (0, U.default)(e, t);
  }
  s(_ve, "isExportDeclaration");
  function bve(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ExportSpecifier":
      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "ImportSpecifier":
      case "ExportNamespaceSpecifier":
      case "ExportDefaultSpecifier":
        break;
      default:
        return !1;
    }
    return t == null || (0, U.default)(e, t);
  }
  s(bve, "isModuleSpecifier");
  function vve(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ClassAccessorProperty":
        break;
      default:
        return !1;
    }
    return t == null || (0, U.default)(e, t);
  }
  s(vve, "isAccessor");
  function Sve(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ClassPrivateProperty":
      case "ClassPrivateMethod":
      case "PrivateName":
        break;
      default:
        return !1;
    }
    return t == null || (0, U.default)(e, t);
  }
  s(Sve, "isPrivate");
  function Tve(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "AnyTypeAnnotation":
      case "ArrayTypeAnnotation":
      case "BooleanTypeAnnotation":
      case "BooleanLiteralTypeAnnotation":
      case "NullLiteralTypeAnnotation":
      case "ClassImplements":
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "DeclaredPredicate":
      case "ExistsTypeAnnotation":
      case "FunctionTypeAnnotation":
      case "FunctionTypeParam":
      case "GenericTypeAnnotation":
      case "InferredPredicate":
      case "InterfaceExtends":
      case "InterfaceDeclaration":
      case "InterfaceTypeAnnotation":
      case "IntersectionTypeAnnotation":
      case "MixedTypeAnnotation":
      case "EmptyTypeAnnotation":
      case "NullableTypeAnnotation":
      case "NumberLiteralTypeAnnotation":
      case "NumberTypeAnnotation":
      case "ObjectTypeAnnotation":
      case "ObjectTypeInternalSlot":
      case "ObjectTypeCallProperty":
      case "ObjectTypeIndexer":
      case "ObjectTypeProperty":
      case "ObjectTypeSpreadProperty":
      case "OpaqueType":
      case "QualifiedTypeIdentifier":
      case "StringLiteralTypeAnnotation":
      case "StringTypeAnnotation":
      case "SymbolTypeAnnotation":
      case "ThisTypeAnnotation":
      case "TupleTypeAnnotation":
      case "TypeofTypeAnnotation":
      case "TypeAlias":
      case "TypeAnnotation":
      case "TypeCastExpression":
      case "TypeParameter":
      case "TypeParameterDeclaration":
      case "TypeParameterInstantiation":
      case "UnionTypeAnnotation":
      case "Variance":
      case "VoidTypeAnnotation":
      case "EnumDeclaration":
      case "EnumBooleanBody":
      case "EnumNumberBody":
      case "EnumStringBody":
      case "EnumSymbolBody":
      case "EnumBooleanMember":
      case "EnumNumberMember":
      case "EnumStringMember":
      case "EnumDefaultedMember":
      case "IndexedAccessType":
      case "OptionalIndexedAccessType":
        break;
      default:
        return !1;
    }
    return t == null || (0, U.default)(e, t);
  }
  s(Tve, "isFlow");
  function Eve(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "AnyTypeAnnotation":
      case "ArrayTypeAnnotation":
      case "BooleanTypeAnnotation":
      case "BooleanLiteralTypeAnnotation":
      case "NullLiteralTypeAnnotation":
      case "ExistsTypeAnnotation":
      case "FunctionTypeAnnotation":
      case "GenericTypeAnnotation":
      case "InterfaceTypeAnnotation":
      case "IntersectionTypeAnnotation":
      case "MixedTypeAnnotation":
      case "EmptyTypeAnnotation":
      case "NullableTypeAnnotation":
      case "NumberLiteralTypeAnnotation":
      case "NumberTypeAnnotation":
      case "ObjectTypeAnnotation":
      case "StringLiteralTypeAnnotation":
      case "StringTypeAnnotation":
      case "SymbolTypeAnnotation":
      case "ThisTypeAnnotation":
      case "TupleTypeAnnotation":
      case "TypeofTypeAnnotation":
      case "UnionTypeAnnotation":
      case "VoidTypeAnnotation":
      case "IndexedAccessType":
      case "OptionalIndexedAccessType":
        break;
      default:
        return !1;
    }
    return t == null || (0, U.default)(e, t);
  }
  s(Eve, "isFlowType");
  function Ave(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "AnyTypeAnnotation":
      case "BooleanTypeAnnotation":
      case "NullLiteralTypeAnnotation":
      case "MixedTypeAnnotation":
      case "EmptyTypeAnnotation":
      case "NumberTypeAnnotation":
      case "StringTypeAnnotation":
      case "SymbolTypeAnnotation":
      case "ThisTypeAnnotation":
      case "VoidTypeAnnotation":
        break;
      default:
        return !1;
    }
    return t == null || (0, U.default)(e, t);
  }
  s(Ave, "isFlowBaseAnnotation");
  function xve(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "InterfaceDeclaration":
      case "OpaqueType":
      case "TypeAlias":
        break;
      default:
        return !1;
    }
    return t == null || (0, U.default)(e, t);
  }
  s(xve, "isFlowDeclaration");
  function Cve(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "DeclaredPredicate":
      case "InferredPredicate":
        break;
      default:
        return !1;
    }
    return t == null || (0, U.default)(e, t);
  }
  s(Cve, "isFlowPredicate");
  function Pve(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "EnumBooleanBody":
      case "EnumNumberBody":
      case "EnumStringBody":
      case "EnumSymbolBody":
        break;
      default:
        return !1;
    }
    return t == null || (0, U.default)(e, t);
  }
  s(Pve, "isEnumBody");
  function Dve(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "EnumBooleanMember":
      case "EnumNumberMember":
      case "EnumStringMember":
      case "EnumDefaultedMember":
        break;
      default:
        return !1;
    }
    return t == null || (0, U.default)(e, t);
  }
  s(Dve, "isEnumMember");
  function wve(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "JSXAttribute":
      case "JSXClosingElement":
      case "JSXElement":
      case "JSXEmptyExpression":
      case "JSXExpressionContainer":
      case "JSXSpreadChild":
      case "JSXIdentifier":
      case "JSXMemberExpression":
      case "JSXNamespacedName":
      case "JSXOpeningElement":
      case "JSXSpreadAttribute":
      case "JSXText":
      case "JSXFragment":
      case "JSXOpeningFragment":
      case "JSXClosingFragment":
        break;
      default:
        return !1;
    }
    return t == null || (0, U.default)(e, t);
  }
  s(wve, "isJSX");
  function Ove(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "Noop":
      case "Placeholder":
      case "V8IntrinsicIdentifier":
        break;
      default:
        return !1;
    }
    return t == null || (0, U.default)(e, t);
  }
  s(Ove, "isMiscellaneous");
  function kve(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "TSParameterProperty":
      case "TSDeclareFunction":
      case "TSDeclareMethod":
      case "TSQualifiedName":
      case "TSCallSignatureDeclaration":
      case "TSConstructSignatureDeclaration":
      case "TSPropertySignature":
      case "TSMethodSignature":
      case "TSIndexSignature":
      case "TSAnyKeyword":
      case "TSBooleanKeyword":
      case "TSBigIntKeyword":
      case "TSIntrinsicKeyword":
      case "TSNeverKeyword":
      case "TSNullKeyword":
      case "TSNumberKeyword":
      case "TSObjectKeyword":
      case "TSStringKeyword":
      case "TSSymbolKeyword":
      case "TSUndefinedKeyword":
      case "TSUnknownKeyword":
      case "TSVoidKeyword":
      case "TSThisType":
      case "TSFunctionType":
      case "TSConstructorType":
      case "TSTypeReference":
      case "TSTypePredicate":
      case "TSTypeQuery":
      case "TSTypeLiteral":
      case "TSArrayType":
      case "TSTupleType":
      case "TSOptionalType":
      case "TSRestType":
      case "TSNamedTupleMember":
      case "TSUnionType":
      case "TSIntersectionType":
      case "TSConditionalType":
      case "TSInferType":
      case "TSParenthesizedType":
      case "TSTypeOperator":
      case "TSIndexedAccessType":
      case "TSMappedType":
      case "TSTemplateLiteralType":
      case "TSLiteralType":
      case "TSExpressionWithTypeArguments":
      case "TSInterfaceDeclaration":
      case "TSInterfaceBody":
      case "TSTypeAliasDeclaration":
      case "TSInstantiationExpression":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSEnumBody":
      case "TSEnumDeclaration":
      case "TSEnumMember":
      case "TSModuleDeclaration":
      case "TSModuleBlock":
      case "TSImportType":
      case "TSImportEqualsDeclaration":
      case "TSExternalModuleReference":
      case "TSNonNullExpression":
      case "TSExportAssignment":
      case "TSNamespaceExportDeclaration":
      case "TSTypeAnnotation":
      case "TSTypeParameterInstantiation":
      case "TSTypeParameterDeclaration":
      case "TSTypeParameter":
        break;
      default:
        return !1;
    }
    return t == null || (0, U.default)(e, t);
  }
  s(kve, "isTypeScript");
  function Ive(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "TSCallSignatureDeclaration":
      case "TSConstructSignatureDeclaration":
      case "TSPropertySignature":
      case "TSMethodSignature":
      case "TSIndexSignature":
        break;
      default:
        return !1;
    }
    return t == null || (0, U.default)(e, t);
  }
  s(Ive, "isTSTypeElement");
  function Rve(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "TSAnyKeyword":
      case "TSBooleanKeyword":
      case "TSBigIntKeyword":
      case "TSIntrinsicKeyword":
      case "TSNeverKeyword":
      case "TSNullKeyword":
      case "TSNumberKeyword":
      case "TSObjectKeyword":
      case "TSStringKeyword":
      case "TSSymbolKeyword":
      case "TSUndefinedKeyword":
      case "TSUnknownKeyword":
      case "TSVoidKeyword":
      case "TSThisType":
      case "TSFunctionType":
      case "TSConstructorType":
      case "TSTypeReference":
      case "TSTypePredicate":
      case "TSTypeQuery":
      case "TSTypeLiteral":
      case "TSArrayType":
      case "TSTupleType":
      case "TSOptionalType":
      case "TSRestType":
      case "TSUnionType":
      case "TSIntersectionType":
      case "TSConditionalType":
      case "TSInferType":
      case "TSParenthesizedType":
      case "TSTypeOperator":
      case "TSIndexedAccessType":
      case "TSMappedType":
      case "TSTemplateLiteralType":
      case "TSLiteralType":
      case "TSExpressionWithTypeArguments":
      case "TSImportType":
        break;
      default:
        return !1;
    }
    return t == null || (0, U.default)(e, t);
  }
  s(Rve, "isTSType");
  function Nve(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "TSAnyKeyword":
      case "TSBooleanKeyword":
      case "TSBigIntKeyword":
      case "TSIntrinsicKeyword":
      case "TSNeverKeyword":
      case "TSNullKeyword":
      case "TSNumberKeyword":
      case "TSObjectKeyword":
      case "TSStringKeyword":
      case "TSSymbolKeyword":
      case "TSUndefinedKeyword":
      case "TSUnknownKeyword":
      case "TSVoidKeyword":
      case "TSThisType":
      case "TSTemplateLiteralType":
      case "TSLiteralType":
        break;
      default:
        return !1;
    }
    return t == null || (0, U.default)(e, t);
  }
  s(Nve, "isTSBaseType");
  function Lve(e, t) {
    return (0, td.default)("isNumberLiteral", "isNumericLiteral"), !e || e.type !== "NumberLiteral" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Lve, "isNumberLiteral");
  function Fve(e, t) {
    return (0, td.default)("isRegexLiteral", "isRegExpLiteral"), !e || e.type !== "RegexLiteral" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Fve, "isRegexLiteral");
  function Mve(e, t) {
    return (0, td.default)("isRestProperty", "isRestElement"), !e || e.type !== "RestProperty" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Mve, "isRestProperty");
  function Bve(e, t) {
    return (0, td.default)("isSpreadProperty", "isSpreadElement"), !e || e.type !== "SpreadProperty" ? !1 : t == null || (0, U.default)(e, t);
  }
  s(Bve, "isSpreadProperty");
  function qve(e, t) {
    return (0, td.default)("isModuleDeclaration", "isImportOrExportDeclaration"), m8(e, t);
  }
  s(qve, "isModuleDeclaration");
});

// ../node_modules/@babel/types/lib/validators/matchesPattern.js
var Dx = b((Px) => {
  "use strict";
  Object.defineProperty(Px, "__esModule", {
    value: !0
  });
  Px.default = Uve;
  var rd = Ri();
  function Uve(e, t, r) {
    if (!(0, rd.isMemberExpression)(e)) return !1;
    let i = Array.isArray(t) ? t : t.split("."), n = [], a;
    for (a = e; (0, rd.isMemberExpression)(a); a = a.object)
      n.push(a.property);
    if (n.push(a), n.length < i.length || !r && n.length > i.length) return !1;
    for (let o = 0, u = n.length - 1; o < i.length; o++, u--) {
      let l = n[u], c;
      if ((0, rd.isIdentifier)(l))
        c = l.name;
      else if ((0, rd.isStringLiteral)(l))
        c = l.value;
      else if ((0, rd.isThisExpression)(l))
        c = "this";
      else
        return !1;
      if (i[o] !== c) return !1;
    }
    return !0;
  }
  s(Uve, "matchesPattern");
});

// ../node_modules/@babel/types/lib/validators/buildMatchMemberExpression.js
var Ox = b((wx) => {
  "use strict";
  Object.defineProperty(wx, "__esModule", {
    value: !0
  });
  wx.default = Vve;
  var jve = Dx();
  function Vve(e, t) {
    let r = e.split(".");
    return (i) => (0, jve.default)(i, r, t);
  }
  s(Vve, "buildMatchMemberExpression");
});

// ../node_modules/@babel/types/lib/validators/react/isReactComponent.js
var y8 = b((e_) => {
  "use strict";
  Object.defineProperty(e_, "__esModule", {
    value: !0
  });
  e_.default = void 0;
  var Kve = Ox(), Hve = (0, Kve.default)("React.Component"), F0t = e_.default = Hve;
});

// ../node_modules/@babel/types/lib/validators/react/isCompatTag.js
var g8 = b((kx) => {
  "use strict";
  Object.defineProperty(kx, "__esModule", {
    value: !0
  });
  kx.default = zve;
  function zve(e) {
    return !!e && /^[a-z]/.test(e);
  }
  s(zve, "isCompatTag");
});

// ../node_modules/@babel/types/lib/validators/isType.js
var t_ = b((Ix) => {
  "use strict";
  Object.defineProperty(Ix, "__esModule", {
    value: !0
  });
  Ix.default = Gve;
  var _8 = Sa();
  function Gve(e, t) {
    if (e === t) return !0;
    if (e == null || _8.ALIAS_KEYS[t]) return !1;
    let r = _8.FLIPPED_ALIAS_KEYS[t];
    return !!(r != null && r.includes(e));
  }
  s(Gve, "isType");
});

// ../node_modules/@babel/types/lib/validators/isPlaceholderType.js
var Nx = b((Rx) => {
  "use strict";
  Object.defineProperty(Rx, "__esModule", {
    value: !0
  });
  Rx.default = $ve;
  var Wve = Sa();
  function $ve(e, t) {
    if (e === t) return !0;
    let r = Wve.PLACEHOLDERS_ALIAS[e];
    return !!(r != null && r.includes(t));
  }
  s($ve, "isPlaceholderType");
});

// ../node_modules/@babel/types/lib/validators/is.js
var Hf = b((Lx) => {
  "use strict";
  Object.defineProperty(Lx, "__esModule", {
    value: !0
  });
  Lx.default = Zve;
  var Xve = Zg(), Yve = t_(), Jve = Nx(), Qve = Sa();
  function Zve(e, t, r) {
    return t ? (0, Yve.default)(t.type, e) ? r === void 0 ? !0 : (0, Xve.default)(t, r) : !r && t.type === "Placeholder" && e in Qve.FLIPPED_ALIAS_KEYS ?
    (0, Jve.default)(t.expectedNode, e) : !1 : !1;
  }
  s(Zve, "is");
});

// ../node_modules/@babel/helper-validator-identifier/lib/identifier.js
var E8 = b((id) => {
  "use strict";
  Object.defineProperty(id, "__esModule", {
    value: !0
  });
  id.isIdentifierChar = T8;
  id.isIdentifierName = iSe;
  id.isIdentifierStart = S8;
  var Mx = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993\
-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\
\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\
\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\
\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\
\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CD\uA7D0\uA7D1\uA7D3\uA7D5-\uA7DC\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01\
-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC",
  b8 = "\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\
\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\
\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6\
-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20\
-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65", eSe = new RegExp("[" + Mx + "]"), tSe = new RegExp("[" + Mx + b8 + "]");
  Mx = b8 = null;
  var v8 = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157,
  19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5,
  3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7,
  2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 2, 60, 28, 11, 0, 9, 21, 43, 17,
  47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64,
  6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45,
  52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2,
  1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29,
  113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071,
  18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 129, 74, 6, 0, 67, 12,
  65, 1, 2, 0, 29, 6135, 9, 1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991,
  84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30,
  2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3,
  0, 496, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2,
  2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153,
  7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191], rSe = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5,
  0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13,
  2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4,
  68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58,
  14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 343, 9, 54,
  7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350,
  0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543,
  4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6,
  10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 726, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
  function Fx(e, t) {
    let r = 65536;
    for (let i = 0, n = t.length; i < n; i += 2) {
      if (r += t[i], r > e) return !1;
      if (r += t[i + 1], r >= e) return !0;
    }
    return !1;
  }
  s(Fx, "isInAstralSet");
  function S8(e) {
    return e < 65 ? e === 36 : e <= 90 ? !0 : e < 97 ? e === 95 : e <= 122 ? !0 : e <= 65535 ? e >= 170 && eSe.test(String.fromCharCode(e)) :
    Fx(e, v8);
  }
  s(S8, "isIdentifierStart");
  function T8(e) {
    return e < 48 ? e === 36 : e < 58 ? !0 : e < 65 ? !1 : e <= 90 ? !0 : e < 97 ? e === 95 : e <= 122 ? !0 : e <= 65535 ? e >= 170 && tSe.test(
    String.fromCharCode(e)) : Fx(e, v8) || Fx(e, rSe);
  }
  s(T8, "isIdentifierChar");
  function iSe(e) {
    let t = !0;
    for (let r = 0; r < e.length; r++) {
      let i = e.charCodeAt(r);
      if ((i & 64512) === 55296 && r + 1 < e.length) {
        let n = e.charCodeAt(++r);
        (n & 64512) === 56320 && (i = 65536 + ((i & 1023) << 10) + (n & 1023));
      }
      if (t) {
        if (t = !1, !S8(i))
          return !1;
      } else if (!T8(i))
        return !1;
    }
    return !t;
  }
  s(iSe, "isIdentifierName");
});

// ../node_modules/@babel/helper-validator-identifier/lib/keyword.js
var P8 = b((oc) => {
  "use strict";
  Object.defineProperty(oc, "__esModule", {
    value: !0
  });
  oc.isKeyword = uSe;
  oc.isReservedWord = A8;
  oc.isStrictBindOnlyReservedWord = C8;
  oc.isStrictBindReservedWord = oSe;
  oc.isStrictReservedWord = x8;
  var Bx = {
    keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "swit\
ch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false",
    "in", "instanceof", "typeof", "void", "delete"],
    strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
    strictBind: ["eval", "arguments"]
  }, nSe = new Set(Bx.keyword), sSe = new Set(Bx.strict), aSe = new Set(Bx.strictBind);
  function A8(e, t) {
    return t && e === "await" || e === "enum";
  }
  s(A8, "isReservedWord");
  function x8(e, t) {
    return A8(e, t) || sSe.has(e);
  }
  s(x8, "isStrictReservedWord");
  function C8(e) {
    return aSe.has(e);
  }
  s(C8, "isStrictBindOnlyReservedWord");
  function oSe(e, t) {
    return x8(e, t) || C8(e);
  }
  s(oSe, "isStrictBindReservedWord");
  function uSe(e) {
    return nSe.has(e);
  }
  s(uSe, "isKeyword");
});

// ../node_modules/@babel/helper-validator-identifier/lib/index.js
var r_ = b((ko) => {
  "use strict";
  Object.defineProperty(ko, "__esModule", {
    value: !0
  });
  Object.defineProperty(ko, "isIdentifierChar", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return qx.isIdentifierChar;
    }, "get")
  });
  Object.defineProperty(ko, "isIdentifierName", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return qx.isIdentifierName;
    }, "get")
  });
  Object.defineProperty(ko, "isIdentifierStart", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return qx.isIdentifierStart;
    }, "get")
  });
  Object.defineProperty(ko, "isKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return nd.isKeyword;
    }, "get")
  });
  Object.defineProperty(ko, "isReservedWord", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return nd.isReservedWord;
    }, "get")
  });
  Object.defineProperty(ko, "isStrictBindOnlyReservedWord", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return nd.isStrictBindOnlyReservedWord;
    }, "get")
  });
  Object.defineProperty(ko, "isStrictBindReservedWord", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return nd.isStrictBindReservedWord;
    }, "get")
  });
  Object.defineProperty(ko, "isStrictReservedWord", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return nd.isStrictReservedWord;
    }, "get")
  });
  var qx = E8(), nd = P8();
});

// ../node_modules/@babel/types/lib/validators/isValidIdentifier.js
var zf = b((jx) => {
  "use strict";
  Object.defineProperty(jx, "__esModule", {
    value: !0
  });
  jx.default = lSe;
  var Ux = r_();
  function lSe(e, t = !0) {
    return typeof e != "string" || t && ((0, Ux.isKeyword)(e) || (0, Ux.isStrictReservedWord)(e, !0)) ? !1 : (0, Ux.isIdentifierName)(e);
  }
  s(lSe, "isValidIdentifier");
});

// ../node_modules/@babel/helper-string-parser/lib/index.js
var k8 = b((sd) => {
  "use strict";
  Object.defineProperty(sd, "__esModule", {
    value: !0
  });
  sd.readCodePoint = O8;
  sd.readInt = w8;
  sd.readStringContents = fSe;
  var cSe = /* @__PURE__ */ s(function(t) {
    return t >= 48 && t <= 57;
  }, "isDigit"), D8 = {
    decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]),
    hex: /* @__PURE__ */ new Set([46, 88, 95, 120])
  }, i_ = {
    bin: /* @__PURE__ */ s((e) => e === 48 || e === 49, "bin"),
    oct: /* @__PURE__ */ s((e) => e >= 48 && e <= 55, "oct"),
    dec: /* @__PURE__ */ s((e) => e >= 48 && e <= 57, "dec"),
    hex: /* @__PURE__ */ s((e) => e >= 48 && e <= 57 || e >= 65 && e <= 70 || e >= 97 && e <= 102, "hex")
  };
  function fSe(e, t, r, i, n, a) {
    let o = r, u = i, l = n, c = "", p = null, h = r, {
      length: y
    } = t;
    for (; ; ) {
      if (r >= y) {
        a.unterminated(o, u, l), c += t.slice(h, r);
        break;
      }
      let _ = t.charCodeAt(r);
      if (pSe(e, _, t, r)) {
        c += t.slice(h, r);
        break;
      }
      if (_ === 92) {
        c += t.slice(h, r);
        let g = hSe(t, r, i, n, e === "template", a);
        g.ch === null && !p ? p = {
          pos: r,
          lineStart: i,
          curLine: n
        } : c += g.ch, {
          pos: r,
          lineStart: i,
          curLine: n
        } = g, h = r;
      } else _ === 8232 || _ === 8233 ? (++r, ++n, i = r) : _ === 10 || _ === 13 ? e === "template" ? (c += t.slice(h, r) + `
`, ++r, _ === 13 && t.charCodeAt(r) === 10 && ++r, ++n, h = i = r) : a.unterminated(o, u, l) : ++r;
    }
    return {
      pos: r,
      str: c,
      firstInvalidLoc: p,
      lineStart: i,
      curLine: n,
      containsInvalid: !!p
    };
  }
  s(fSe, "readStringContents");
  function pSe(e, t, r, i) {
    return e === "template" ? t === 96 || t === 36 && r.charCodeAt(i + 1) === 123 : t === (e === "double" ? 34 : 39);
  }
  s(pSe, "isStringEnd");
  function hSe(e, t, r, i, n, a) {
    let o = !n;
    t++;
    let u = /* @__PURE__ */ s((c) => ({
      pos: t,
      ch: c,
      lineStart: r,
      curLine: i
    }), "res"), l = e.charCodeAt(t++);
    switch (l) {
      case 110:
        return u(`
`);
      case 114:
        return u("\r");
      case 120: {
        let c;
        return {
          code: c,
          pos: t
        } = Vx(e, t, r, i, 2, !1, o, a), u(c === null ? null : String.fromCharCode(c));
      }
      case 117: {
        let c;
        return {
          code: c,
          pos: t
        } = O8(e, t, r, i, o, a), u(c === null ? null : String.fromCodePoint(c));
      }
      case 116:
        return u("	");
      case 98:
        return u("\b");
      case 118:
        return u("\v");
      case 102:
        return u("\f");
      case 13:
        e.charCodeAt(t) === 10 && ++t;
      case 10:
        r = t, ++i;
      case 8232:
      case 8233:
        return u("");
      case 56:
      case 57:
        if (n)
          return u(null);
        a.strictNumericEscape(t - 1, r, i);
      default:
        if (l >= 48 && l <= 55) {
          let c = t - 1, h = /^[0-7]+/.exec(e.slice(c, t + 2))[0], y = parseInt(h, 8);
          y > 255 && (h = h.slice(0, -1), y = parseInt(h, 8)), t += h.length - 1;
          let _ = e.charCodeAt(t);
          if (h !== "0" || _ === 56 || _ === 57) {
            if (n)
              return u(null);
            a.strictNumericEscape(c, r, i);
          }
          return u(String.fromCharCode(y));
        }
        return u(String.fromCharCode(l));
    }
  }
  s(hSe, "readEscapedChar");
  function Vx(e, t, r, i, n, a, o, u) {
    let l = t, c;
    return {
      n: c,
      pos: t
    } = w8(e, t, r, i, 16, n, a, !1, u, !o), c === null && (o ? u.invalidEscapeSequence(l, r, i) : t = l - 1), {
      code: c,
      pos: t
    };
  }
  s(Vx, "readHexChar");
  function w8(e, t, r, i, n, a, o, u, l, c) {
    let p = t, h = n === 16 ? D8.hex : D8.decBinOct, y = n === 16 ? i_.hex : n === 10 ? i_.dec : n === 8 ? i_.oct : i_.bin, _ = !1, g = 0;
    for (let m = 0, f = a ?? 1 / 0; m < f; ++m) {
      let d = e.charCodeAt(t), v;
      if (d === 95 && u !== "bail") {
        let E = e.charCodeAt(t - 1), S = e.charCodeAt(t + 1);
        if (u) {
          if (Number.isNaN(S) || !y(S) || h.has(E) || h.has(S)) {
            if (c) return {
              n: null,
              pos: t
            };
            l.unexpectedNumericSeparator(t, r, i);
          }
        } else {
          if (c) return {
            n: null,
            pos: t
          };
          l.numericSeparatorInEscapeSequence(t, r, i);
        }
        ++t;
        continue;
      }
      if (d >= 97 ? v = d - 97 + 10 : d >= 65 ? v = d - 65 + 10 : cSe(d) ? v = d - 48 : v = 1 / 0, v >= n) {
        if (v <= 9 && c)
          return {
            n: null,
            pos: t
          };
        if (v <= 9 && l.invalidDigit(t, r, i, n))
          v = 0;
        else if (o)
          v = 0, _ = !0;
        else
          break;
      }
      ++t, g = g * n + v;
    }
    return t === p || a != null && t - p !== a || _ ? {
      n: null,
      pos: t
    } : {
      n: g,
      pos: t
    };
  }
  s(w8, "readInt");
  function O8(e, t, r, i, n, a) {
    let o = e.charCodeAt(t), u;
    if (o === 123) {
      if (++t, {
        code: u,
        pos: t
      } = Vx(e, t, r, i, e.indexOf("}", t) - t, !0, n, a), ++t, u !== null && u > 1114111)
        if (n)
          a.invalidCodePoint(t, r, i);
        else
          return {
            code: null,
            pos: t
          };
    } else
      ({
        code: u,
        pos: t
      } = Vx(e, t, r, i, 4, !1, n, a));
    return {
      code: u,
      pos: t
    };
  }
  s(O8, "readCodePoint");
});

// ../node_modules/@babel/types/lib/constants/index.js
var Gf = b((Wt) => {
  "use strict";
  Object.defineProperty(Wt, "__esModule", {
    value: !0
  });
  Wt.UPDATE_OPERATORS = Wt.UNARY_OPERATORS = Wt.STRING_UNARY_OPERATORS = Wt.STATEMENT_OR_BLOCK_KEYS = Wt.NUMBER_UNARY_OPERATORS = Wt.NUMBER_BINARY_OPERATORS =
  Wt.LOGICAL_OPERATORS = Wt.INHERIT_KEYS = Wt.FOR_INIT_KEYS = Wt.FLATTENABLE_KEYS = Wt.EQUALITY_BINARY_OPERATORS = Wt.COMPARISON_BINARY_OPERATORS =
  Wt.COMMENT_KEYS = Wt.BOOLEAN_UNARY_OPERATORS = Wt.BOOLEAN_NUMBER_BINARY_OPERATORS = Wt.BOOLEAN_BINARY_OPERATORS = Wt.BINARY_OPERATORS = Wt.
  ASSIGNMENT_OPERATORS = void 0;
  var rTt = Wt.STATEMENT_OR_BLOCK_KEYS = ["consequent", "body", "alternate"], iTt = Wt.FLATTENABLE_KEYS = ["body", "expressions"], nTt = Wt.
  FOR_INIT_KEYS = ["left", "init"], sTt = Wt.COMMENT_KEYS = ["leadingComments", "trailingComments", "innerComments"], dSe = Wt.LOGICAL_OPERATORS =
  ["||", "&&", "??"], aTt = Wt.UPDATE_OPERATORS = ["++", "--"], mSe = Wt.BOOLEAN_NUMBER_BINARY_OPERATORS = [">", "<", ">=", "<="], ySe = Wt.
  EQUALITY_BINARY_OPERATORS = ["==", "===", "!=", "!=="], gSe = Wt.COMPARISON_BINARY_OPERATORS = [...ySe, "in", "instanceof"], _Se = Wt.BOOLEAN_BINARY_OPERATORS =
  [...gSe, ...mSe], I8 = Wt.NUMBER_BINARY_OPERATORS = ["-", "/", "%", "*", "**", "&", "|", ">>", ">>>", "<<", "^"], oTt = Wt.BINARY_OPERATORS =
  ["+", ...I8, ..._Se, "|>"], uTt = Wt.ASSIGNMENT_OPERATORS = ["=", "+=", ...I8.map((e) => e + "="), ...dSe.map((e) => e + "=")], bSe = Wt.BOOLEAN_UNARY_OPERATORS =
  ["delete", "!"], vSe = Wt.NUMBER_UNARY_OPERATORS = ["+", "-", "~"], SSe = Wt.STRING_UNARY_OPERATORS = ["typeof"], lTt = Wt.UNARY_OPERATORS =
  ["void", "throw", ...bSe, ...vSe, ...SSe], cTt = Wt.INHERIT_KEYS = {
    optional: ["typeAnnotation", "typeParameters", "returnType"],
    force: ["start", "loc", "end"]
  };
  Wt.BLOCK_SCOPED_SYMBOL = Symbol.for("var used to be block scoped"), Wt.NOT_LOCAL_BINDING = Symbol.for("should not be considered a local bi\
nding");
});

// ../node_modules/@babel/types/lib/definitions/utils.js
var Io = b((or) => {
  "use strict";
  Object.defineProperty(or, "__esModule", {
    value: !0
  });
  or.allExpandedTypes = or.VISITOR_KEYS = or.NODE_PARENT_VALIDATIONS = or.NODE_FIELDS = or.FLIPPED_ALIAS_KEYS = or.DEPRECATED_KEYS = or.BUILDER_KEYS =
  or.ALIAS_KEYS = void 0;
  or.arrayOf = N8;
  or.arrayOfType = L8;
  or.assertEach = F8;
  or.assertNodeOrValueType = NSe;
  or.assertNodeType = s_;
  or.assertOneOf = ISe;
  or.assertOptionalChainStart = FSe;
  or.assertShape = LSe;
  or.assertValueType = Gx;
  or.chain = M8;
  or.default = B8;
  or.defineAliasedType = qSe;
  or.validate = zx;
  or.validateArrayOfType = kSe;
  or.validateOptional = wSe;
  or.validateOptionalType = OSe;
  or.validateType = DSe;
  var R8 = Hf(), ad = a_(), TSe = or.VISITOR_KEYS = {}, ESe = or.ALIAS_KEYS = {}, Kx = or.FLIPPED_ALIAS_KEYS = {}, ASe = or.NODE_FIELDS = {},
  xSe = or.BUILDER_KEYS = {}, CSe = or.DEPRECATED_KEYS = {}, PSe = or.NODE_PARENT_VALIDATIONS = {};
  function n_(e) {
    return Array.isArray(e) ? "array" : e === null ? "null" : typeof e;
  }
  s(n_, "getType");
  function zx(e) {
    return {
      validate: e
    };
  }
  s(zx, "validate");
  function DSe(...e) {
    return zx(s_(...e));
  }
  s(DSe, "validateType");
  function wSe(e) {
    return {
      validate: e,
      optional: !0
    };
  }
  s(wSe, "validateOptional");
  function OSe(...e) {
    return {
      validate: s_(...e),
      optional: !0
    };
  }
  s(OSe, "validateOptionalType");
  function N8(e) {
    return M8(Gx("array"), F8(e));
  }
  s(N8, "arrayOf");
  function L8(...e) {
    return N8(s_(...e));
  }
  s(L8, "arrayOfType");
  function kSe(...e) {
    return zx(L8(...e));
  }
  s(kSe, "validateArrayOfType");
  function F8(e) {
    let t = process.env.BABEL_TYPES_8_BREAKING ? ad.validateChild : () => {
    };
    function r(i, n, a) {
      if (!Array.isArray(a)) return;
      let o = 0, u = {
        toString() {
          return `${n}[${o}]`;
        }
      };
      for (; o < a.length; o++) {
        let l = a[o];
        e(i, u, l), t(i, u, l);
      }
    }
    return s(r, "validator"), r.each = e, r;
  }
  s(F8, "assertEach");
  function ISe(...e) {
    function t(r, i, n) {
      if (!e.includes(n))
        throw new TypeError(`Property ${i} expected value to be one of ${JSON.stringify(e)} but got ${JSON.stringify(n)}`);
    }
    return s(t, "validate"), t.oneOf = e, t;
  }
  s(ISe, "assertOneOf");
  var RSe = or.allExpandedTypes = [];
  function s_(...e) {
    let t = /* @__PURE__ */ new Set();
    RSe.push({
      types: e,
      set: t
    });
    function r(i, n, a) {
      let o = a?.type;
      if (o != null) {
        if (t.has(o)) {
          (0, ad.validateChild)(i, n, a);
          return;
        }
        if (o === "Placeholder") {
          for (let u of e)
            if ((0, R8.default)(u, a)) {
              (0, ad.validateChild)(i, n, a);
              return;
            }
        }
      }
      throw new TypeError(`Property ${n} of ${i.type} expected node to be of a type ${JSON.stringify(e)} but instead got ${JSON.stringify(o)}`);
    }
    return s(r, "validate"), r.oneOfNodeTypes = e, r;
  }
  s(s_, "assertNodeType");
  function NSe(...e) {
    function t(r, i, n) {
      let a = n_(n);
      for (let o of e)
        if (a === o || (0, R8.default)(o, n)) {
          (0, ad.validateChild)(r, i, n);
          return;
        }
      throw new TypeError(`Property ${i} of ${r.type} expected node to be of a type ${JSON.stringify(e)} but instead got ${JSON.stringify(n?.
      type)}`);
    }
    return s(t, "validate"), t.oneOfNodeOrValueTypes = e, t;
  }
  s(NSe, "assertNodeOrValueType");
  function Gx(e) {
    function t(r, i, n) {
      if (n_(n) !== e)
        throw new TypeError(`Property ${i} expected type of ${e} but got ${n_(n)}`);
    }
    return s(t, "validate"), t.type = e, t;
  }
  s(Gx, "assertValueType");
  function LSe(e) {
    let t = Object.keys(e);
    function r(i, n, a) {
      let o = [];
      for (let u of t)
        try {
          (0, ad.validateField)(i, u, a[u], e[u]);
        } catch (l) {
          if (l instanceof TypeError) {
            o.push(l.message);
            continue;
          }
          throw l;
        }
      if (o.length)
        throw new TypeError(`Property ${n} of ${i.type} expected to have the following:
${o.join(`
`)}`);
    }
    return s(r, "validate"), r.shapeOf = e, r;
  }
  s(LSe, "assertShape");
  function FSe() {
    function e(t) {
      var r;
      let i = t;
      for (; t; ) {
        let {
          type: n
        } = i;
        if (n === "OptionalCallExpression") {
          if (i.optional) return;
          i = i.callee;
          continue;
        }
        if (n === "OptionalMemberExpression") {
          if (i.optional) return;
          i = i.object;
          continue;
        }
        break;
      }
      throw new TypeError(`Non-optional ${t.type} must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chai\
n from ${(r = i) == null ? void 0 : r.type}`);
    }
    return s(e, "validate"), e;
  }
  s(FSe, "assertOptionalChainStart");
  function M8(...e) {
    function t(...r) {
      for (let i of e)
        i(...r);
    }
    if (s(t, "validate"), t.chainOf = e, e.length >= 2 && "type" in e[0] && e[0].type === "array" && !("each" in e[1]))
      throw new Error('An assertValueType("array") validator can only be followed by an assertEach(...) validator.');
    return t;
  }
  s(M8, "chain");
  var MSe = /* @__PURE__ */ new Set(["aliases", "builder", "deprecatedAlias", "fields", "inherits", "visitor", "validate"]), BSe = /* @__PURE__ */ new Set(
  ["default", "optional", "deprecated", "validate"]), Hx = {};
  function qSe(...e) {
    return (t, r = {}) => {
      let i = r.aliases;
      if (!i) {
        var n;
        r.inherits && (i = (n = Hx[r.inherits].aliases) == null ? void 0 : n.slice()), i ?? (i = []), r.aliases = i;
      }
      let a = e.filter((o) => !i.includes(o));
      i.unshift(...a), B8(t, r);
    };
  }
  s(qSe, "defineAliasedType");
  function B8(e, t = {}) {
    let r = t.inherits && Hx[t.inherits] || {}, i = t.fields;
    if (!i && (i = {}, r.fields)) {
      let u = Object.getOwnPropertyNames(r.fields);
      for (let l of u) {
        let c = r.fields[l], p = c.default;
        if (Array.isArray(p) ? p.length > 0 : p && typeof p == "object")
          throw new Error("field defaults can only be primitives or empty arrays currently");
        i[l] = {
          default: Array.isArray(p) ? [] : p,
          optional: c.optional,
          deprecated: c.deprecated,
          validate: c.validate
        };
      }
    }
    let n = t.visitor || r.visitor || [], a = t.aliases || r.aliases || [], o = t.builder || r.builder || t.visitor || [];
    for (let u of Object.keys(t))
      if (!MSe.has(u))
        throw new Error(`Unknown type option "${u}" on ${e}`);
    t.deprecatedAlias && (CSe[t.deprecatedAlias] = e);
    for (let u of n.concat(o))
      i[u] = i[u] || {};
    for (let u of Object.keys(i)) {
      let l = i[u];
      l.default !== void 0 && !o.includes(u) && (l.optional = !0), l.default === void 0 ? l.default = null : !l.validate && l.default != null &&
      (l.validate = Gx(n_(l.default)));
      for (let c of Object.keys(l))
        if (!BSe.has(c))
          throw new Error(`Unknown field key "${c}" on ${e}.${u}`);
    }
    TSe[e] = t.visitor = n, xSe[e] = t.builder = o, ASe[e] = t.fields = i, ESe[e] = t.aliases = a, a.forEach((u) => {
      Kx[u] = Kx[u] || [], Kx[u].push(e);
    }), t.validate && (PSe[e] = t.validate), Hx[e] = t;
  }
  s(B8, "defineType");
});

// ../node_modules/@babel/types/lib/definitions/core.js
var ud = b(($n) => {
  "use strict";
  Object.defineProperty($n, "__esModule", {
    value: !0
  });
  $n.patternLikeCommon = $n.importAttributes = $n.functionTypeAnnotationCommon = $n.functionDeclarationCommon = $n.functionCommon = $n.classMethodOrPropertyCommon =
  $n.classMethodOrDeclareMethodCommon = void 0;
  var cs = Hf(), USe = zf(), q8 = r_(), jSe = k8(), od = Gf(), K = Io(), Ne = (0, K.defineAliasedType)("Standardized");
  Ne("ArrayExpression", {
    fields: {
      elements: {
        validate: (0, K.arrayOf)((0, K.assertNodeOrValueType)("null", "Expression", "SpreadElement")),
        default: process.env.BABEL_TYPES_8_BREAKING ? void 0 : []
      }
    },
    visitor: ["elements"],
    aliases: ["Expression"]
  });
  Ne("AssignmentExpression", {
    fields: {
      operator: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? Object.assign(function() {
          let e = (0, K.assertOneOf)(...od.ASSIGNMENT_OPERATORS), t = (0, K.assertOneOf)("=");
          return function(r, i, n) {
            ((0, cs.default)("Pattern", r.left) ? t : e)(r, i, n);
          };
        }(), {
          type: "string"
        }) : (0, K.assertValueType)("string")
      },
      left: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, K.assertNodeType)("Identifier", "MemberExpression", "OptionalMemberExpression", "\
ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") : (0, K.assertNodeType)(
        "LVal", "OptionalMemberExpression")
      },
      right: {
        validate: (0, K.assertNodeType)("Expression")
      }
    },
    builder: ["operator", "left", "right"],
    visitor: ["left", "right"],
    aliases: ["Expression"]
  });
  Ne("BinaryExpression", {
    builder: ["operator", "left", "right"],
    fields: {
      operator: {
        validate: (0, K.assertOneOf)(...od.BINARY_OPERATORS)
      },
      left: {
        validate: function() {
          let e = (0, K.assertNodeType)("Expression"), t = (0, K.assertNodeType)("Expression", "PrivateName");
          return Object.assign(function(i, n, a) {
            (i.operator === "in" ? t : e)(i, n, a);
          }, {
            oneOfNodeTypes: ["Expression", "PrivateName"]
          });
        }()
      },
      right: {
        validate: (0, K.assertNodeType)("Expression")
      }
    },
    visitor: ["left", "right"],
    aliases: ["Binary", "Expression"]
  });
  Ne("InterpreterDirective", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, K.assertValueType)("string")
      }
    }
  });
  Ne("Directive", {
    visitor: ["value"],
    fields: {
      value: {
        validate: (0, K.assertNodeType)("DirectiveLiteral")
      }
    }
  });
  Ne("DirectiveLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, K.assertValueType)("string")
      }
    }
  });
  Ne("BlockStatement", {
    builder: ["body", "directives"],
    visitor: ["directives", "body"],
    fields: {
      directives: {
        validate: (0, K.arrayOfType)("Directive"),
        default: []
      },
      body: (0, K.validateArrayOfType)("Statement")
    },
    aliases: ["Scopable", "BlockParent", "Block", "Statement"]
  });
  Ne("BreakStatement", {
    visitor: ["label"],
    fields: {
      label: {
        validate: (0, K.assertNodeType)("Identifier"),
        optional: !0
      }
    },
    aliases: ["Statement", "Terminatorless", "CompletionStatement"]
  });
  Ne("CallExpression", {
    visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
    builder: ["callee", "arguments"],
    aliases: ["Expression"],
    fields: Object.assign({
      callee: {
        validate: (0, K.assertNodeType)("Expression", "Super", "V8IntrinsicIdentifier")
      },
      arguments: (0, K.validateArrayOfType)("Expression", "SpreadElement", "ArgumentPlaceholder"),
      typeArguments: {
        validate: (0, K.assertNodeType)("TypeParameterInstantiation"),
        optional: !0
      }
    }, {
      optional: {
        validate: (0, K.assertValueType)("boolean"),
        optional: !0
      },
      typeParameters: {
        validate: (0, K.assertNodeType)("TSTypeParameterInstantiation"),
        optional: !0
      }
    }, process.env.BABEL_TYPES_8_BREAKING ? {} : {
      optional: {
        validate: (0, K.assertValueType)("boolean"),
        optional: !0
      }
    })
  });
  Ne("CatchClause", {
    visitor: ["param", "body"],
    fields: {
      param: {
        validate: (0, K.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"),
        optional: !0
      },
      body: {
        validate: (0, K.assertNodeType)("BlockStatement")
      }
    },
    aliases: ["Scopable", "BlockParent"]
  });
  Ne("ConditionalExpression", {
    visitor: ["test", "consequent", "alternate"],
    fields: {
      test: {
        validate: (0, K.assertNodeType)("Expression")
      },
      consequent: {
        validate: (0, K.assertNodeType)("Expression")
      },
      alternate: {
        validate: (0, K.assertNodeType)("Expression")
      }
    },
    aliases: ["Expression", "Conditional"]
  });
  Ne("ContinueStatement", {
    visitor: ["label"],
    fields: {
      label: {
        validate: (0, K.assertNodeType)("Identifier"),
        optional: !0
      }
    },
    aliases: ["Statement", "Terminatorless", "CompletionStatement"]
  });
  Ne("DebuggerStatement", {
    aliases: ["Statement"]
  });
  Ne("DoWhileStatement", {
    builder: ["test", "body"],
    visitor: ["body", "test"],
    fields: {
      test: {
        validate: (0, K.assertNodeType)("Expression")
      },
      body: {
        validate: (0, K.assertNodeType)("Statement")
      }
    },
    aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"]
  });
  Ne("EmptyStatement", {
    aliases: ["Statement"]
  });
  Ne("ExpressionStatement", {
    visitor: ["expression"],
    fields: {
      expression: {
        validate: (0, K.assertNodeType)("Expression")
      }
    },
    aliases: ["Statement", "ExpressionWrapper"]
  });
  Ne("File", {
    builder: ["program", "comments", "tokens"],
    visitor: ["program"],
    fields: {
      program: {
        validate: (0, K.assertNodeType)("Program")
      },
      comments: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, K.assertEach)((0, K.assertNodeType)("CommentBlock", "CommentLine")) : Object.assign(
        () => {
        }, {
          each: {
            oneOfNodeTypes: ["CommentBlock", "CommentLine"]
          }
        }),
        optional: !0
      },
      tokens: {
        validate: (0, K.assertEach)(Object.assign(() => {
        }, {
          type: "any"
        })),
        optional: !0
      }
    }
  });
  Ne("ForInStatement", {
    visitor: ["left", "right", "body"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
    fields: {
      left: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, K.assertNodeType)("VariableDeclaration", "Identifier", "MemberExpression", "Array\
Pattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") : (0, K.assertNodeType)("Var\
iableDeclaration", "LVal")
      },
      right: {
        validate: (0, K.assertNodeType)("Expression")
      },
      body: {
        validate: (0, K.assertNodeType)("Statement")
      }
    }
  });
  Ne("ForStatement", {
    visitor: ["init", "test", "update", "body"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop"],
    fields: {
      init: {
        validate: (0, K.assertNodeType)("VariableDeclaration", "Expression"),
        optional: !0
      },
      test: {
        validate: (0, K.assertNodeType)("Expression"),
        optional: !0
      },
      update: {
        validate: (0, K.assertNodeType)("Expression"),
        optional: !0
      },
      body: {
        validate: (0, K.assertNodeType)("Statement")
      }
    }
  });
  var Wf = /* @__PURE__ */ s(() => ({
    params: (0, K.validateArrayOfType)("Identifier", "Pattern", "RestElement"),
    generator: {
      default: !1
    },
    async: {
      default: !1
    }
  }), "functionCommon");
  $n.functionCommon = Wf;
  var uc = /* @__PURE__ */ s(() => ({
    returnType: {
      validate: (0, K.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
      optional: !0
    },
    typeParameters: {
      validate: (0, K.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
      optional: !0
    }
  }), "functionTypeAnnotationCommon");
  $n.functionTypeAnnotationCommon = uc;
  var U8 = /* @__PURE__ */ s(() => Object.assign({}, Wf(), {
    declare: {
      validate: (0, K.assertValueType)("boolean"),
      optional: !0
    },
    id: {
      validate: (0, K.assertNodeType)("Identifier"),
      optional: !0
    }
  }), "functionDeclarationCommon");
  $n.functionDeclarationCommon = U8;
  Ne("FunctionDeclaration", {
    builder: ["id", "params", "body", "generator", "async"],
    visitor: ["id", "typeParameters", "params", "predicate", "returnType", "body"],
    fields: Object.assign({}, U8(), uc(), {
      body: {
        validate: (0, K.assertNodeType)("BlockStatement")
      },
      predicate: {
        validate: (0, K.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
        optional: !0
      }
    }),
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Statement", "Pureish", "Declaration"],
    validate: process.env.BABEL_TYPES_8_BREAKING ? function() {
      let e = (0, K.assertNodeType)("Identifier");
      return function(t, r, i) {
        (0, cs.default)("ExportDefaultDeclaration", t) || e(i, "id", i.id);
      };
    }() : void 0
  });
  Ne("FunctionExpression", {
    inherits: "FunctionDeclaration",
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
    fields: Object.assign({}, Wf(), uc(), {
      id: {
        validate: (0, K.assertNodeType)("Identifier"),
        optional: !0
      },
      body: {
        validate: (0, K.assertNodeType)("BlockStatement")
      },
      predicate: {
        validate: (0, K.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
        optional: !0
      }
    })
  });
  var $f = /* @__PURE__ */ s(() => ({
    typeAnnotation: {
      validate: (0, K.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
      optional: !0
    },
    optional: {
      validate: (0, K.assertValueType)("boolean"),
      optional: !0
    },
    decorators: {
      validate: (0, K.arrayOfType)("Decorator"),
      optional: !0
    }
  }), "patternLikeCommon");
  $n.patternLikeCommon = $f;
  Ne("Identifier", {
    builder: ["name"],
    visitor: ["typeAnnotation", "decorators"],
    aliases: ["Expression", "PatternLike", "LVal", "TSEntityName"],
    fields: Object.assign({}, $f(), {
      name: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, K.chain)((0, K.assertValueType)("string"), Object.assign(function(e, t, r) {
          if (!(0, USe.default)(r, !1))
            throw new TypeError(`"${r}" is not a valid identifier name`);
        }, {
          type: "string"
        })) : (0, K.assertValueType)("string")
      }
    }),
    validate: process.env.BABEL_TYPES_8_BREAKING ? function(e, t, r) {
      let i = /\.(\w+)$/.exec(t.toString());
      if (!i) return;
      let [, n] = i, a = {
        computed: !1
      };
      if (n === "property") {
        if ((0, cs.default)("MemberExpression", e, a) || (0, cs.default)("OptionalMemberExpression", e, a)) return;
      } else if (n === "key") {
        if ((0, cs.default)("Property", e, a) || (0, cs.default)("Method", e, a)) return;
      } else if (n === "exported") {
        if ((0, cs.default)("ExportSpecifier", e)) return;
      } else if (n === "imported") {
        if ((0, cs.default)("ImportSpecifier", e, {
          imported: r
        })) return;
      } else if (n === "meta" && (0, cs.default)("MetaProperty", e, {
        meta: r
      }))
        return;
      if (((0, q8.isKeyword)(r.name) || (0, q8.isReservedWord)(r.name, !1)) && r.name !== "this")
        throw new TypeError(`"${r.name}" is not a valid identifier`);
    } : void 0
  });
  Ne("IfStatement", {
    visitor: ["test", "consequent", "alternate"],
    aliases: ["Statement", "Conditional"],
    fields: {
      test: {
        validate: (0, K.assertNodeType)("Expression")
      },
      consequent: {
        validate: (0, K.assertNodeType)("Statement")
      },
      alternate: {
        optional: !0,
        validate: (0, K.assertNodeType)("Statement")
      }
    }
  });
  Ne("LabeledStatement", {
    visitor: ["label", "body"],
    aliases: ["Statement"],
    fields: {
      label: {
        validate: (0, K.assertNodeType)("Identifier")
      },
      body: {
        validate: (0, K.assertNodeType)("Statement")
      }
    }
  });
  Ne("StringLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, K.assertValueType)("string")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  Ne("NumericLiteral", {
    builder: ["value"],
    deprecatedAlias: "NumberLiteral",
    fields: {
      value: {
        validate: (0, K.chain)((0, K.assertValueType)("number"), Object.assign(function(e, t, r) {
          if (1 / r < 0 || !Number.isFinite(r)) {
            let i = new Error(`NumericLiterals must be non-negative finite numbers. You can use t.valueToNode(${r}) instead.`);
          }
        }, {
          type: "number"
        }))
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  Ne("NullLiteral", {
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  Ne("BooleanLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, K.assertValueType)("boolean")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  Ne("RegExpLiteral", {
    builder: ["pattern", "flags"],
    deprecatedAlias: "RegexLiteral",
    aliases: ["Expression", "Pureish", "Literal"],
    fields: {
      pattern: {
        validate: (0, K.assertValueType)("string")
      },
      flags: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, K.chain)((0, K.assertValueType)("string"), Object.assign(function(e, t, r) {
          let i = /[^gimsuy]/.exec(r);
          if (i)
            throw new TypeError(`"${i[0]}" is not a valid RegExp flag`);
        }, {
          type: "string"
        })) : (0, K.assertValueType)("string"),
        default: ""
      }
    }
  });
  Ne("LogicalExpression", {
    builder: ["operator", "left", "right"],
    visitor: ["left", "right"],
    aliases: ["Binary", "Expression"],
    fields: {
      operator: {
        validate: (0, K.assertOneOf)(...od.LOGICAL_OPERATORS)
      },
      left: {
        validate: (0, K.assertNodeType)("Expression")
      },
      right: {
        validate: (0, K.assertNodeType)("Expression")
      }
    }
  });
  Ne("MemberExpression", {
    builder: ["object", "property", "computed", ...process.env.BABEL_TYPES_8_BREAKING ? [] : ["optional"]],
    visitor: ["object", "property"],
    aliases: ["Expression", "LVal"],
    fields: Object.assign({
      object: {
        validate: (0, K.assertNodeType)("Expression", "Super")
      },
      property: {
        validate: function() {
          let e = (0, K.assertNodeType)("Identifier", "PrivateName"), t = (0, K.assertNodeType)("Expression"), r = /* @__PURE__ */ s(function(i, n, a) {
            (i.computed ? t : e)(i, n, a);
          }, "validator");
          return r.oneOfNodeTypes = ["Expression", "Identifier", "PrivateName"], r;
        }()
      },
      computed: {
        default: !1
      }
    }, process.env.BABEL_TYPES_8_BREAKING ? {} : {
      optional: {
        validate: (0, K.assertValueType)("boolean"),
        optional: !0
      }
    })
  });
  Ne("NewExpression", {
    inherits: "CallExpression"
  });
  Ne("Program", {
    visitor: ["directives", "body"],
    builder: ["body", "directives", "sourceType", "interpreter"],
    fields: {
      sourceType: {
        validate: (0, K.assertOneOf)("script", "module"),
        default: "script"
      },
      interpreter: {
        validate: (0, K.assertNodeType)("InterpreterDirective"),
        default: null,
        optional: !0
      },
      directives: {
        validate: (0, K.arrayOfType)("Directive"),
        default: []
      },
      body: (0, K.validateArrayOfType)("Statement")
    },
    aliases: ["Scopable", "BlockParent", "Block"]
  });
  Ne("ObjectExpression", {
    visitor: ["properties"],
    aliases: ["Expression"],
    fields: {
      properties: (0, K.validateArrayOfType)("ObjectMethod", "ObjectProperty", "SpreadElement")
    }
  });
  Ne("ObjectMethod", {
    builder: ["kind", "key", "params", "body", "computed", "generator", "async"],
    visitor: ["decorators", "key", "typeParameters", "params", "returnType", "body"],
    fields: Object.assign({}, Wf(), uc(), {
      kind: Object.assign({
        validate: (0, K.assertOneOf)("method", "get", "set")
      }, process.env.BABEL_TYPES_8_BREAKING ? {} : {
        default: "method"
      }),
      computed: {
        default: !1
      },
      key: {
        validate: function() {
          let e = (0, K.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"), t = (0, K.assertNodeType)("Expres\
sion"), r = /* @__PURE__ */ s(function(i, n, a) {
            (i.computed ? t : e)(i, n, a);
          }, "validator");
          return r.oneOfNodeTypes = ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"], r;
        }()
      },
      decorators: {
        validate: (0, K.arrayOfType)("Decorator"),
        optional: !0
      },
      body: {
        validate: (0, K.assertNodeType)("BlockStatement")
      }
    }),
    aliases: ["UserWhitespacable", "Function", "Scopable", "BlockParent", "FunctionParent", "Method", "ObjectMember"]
  });
  Ne("ObjectProperty", {
    builder: ["key", "value", "computed", "shorthand", ...process.env.BABEL_TYPES_8_BREAKING ? [] : ["decorators"]],
    fields: {
      computed: {
        default: !1
      },
      key: {
        validate: function() {
          let e = (0, K.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName"), t = (0, K.
          assertNodeType)("Expression");
          return Object.assign(function(i, n, a) {
            (i.computed ? t : e)(i, n, a);
          }, {
            oneOfNodeTypes: ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName"]
          });
        }()
      },
      value: {
        validate: (0, K.assertNodeType)("Expression", "PatternLike")
      },
      shorthand: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, K.chain)((0, K.assertValueType)("boolean"), Object.assign(function(e, t, r) {
          if (r) {
            if (e.computed)
              throw new TypeError("Property shorthand of ObjectProperty cannot be true if computed is true");
            if (!(0, cs.default)("Identifier", e.key))
              throw new TypeError("Property shorthand of ObjectProperty cannot be true if key is not an Identifier");
          }
        }, {
          type: "boolean"
        })) : (0, K.assertValueType)("boolean"),
        default: !1
      },
      decorators: {
        validate: (0, K.arrayOfType)("Decorator"),
        optional: !0
      }
    },
    visitor: ["key", "value", "decorators"],
    aliases: ["UserWhitespacable", "Property", "ObjectMember"],
    validate: process.env.BABEL_TYPES_8_BREAKING ? function() {
      let e = (0, K.assertNodeType)("Identifier", "Pattern", "TSAsExpression", "TSSatisfiesExpression", "TSNonNullExpression", "TSTypeAssert\
ion"), t = (0, K.assertNodeType)("Expression");
      return function(r, i, n) {
        ((0, cs.default)("ObjectPattern", r) ? e : t)(n, "value", n.value);
      };
    }() : void 0
  });
  Ne("RestElement", {
    visitor: ["argument", "typeAnnotation"],
    builder: ["argument"],
    aliases: ["LVal", "PatternLike"],
    deprecatedAlias: "RestProperty",
    fields: Object.assign({}, $f(), {
      argument: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, K.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern", "MemberExpressio\
n", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") : (0, K.assertNodeType)("LVal")
      }
    }),
    validate: process.env.BABEL_TYPES_8_BREAKING ? function(e, t) {
      let r = /(\w+)\[(\d+)\]/.exec(t.toString());
      if (!r) throw new Error("Internal Babel error: malformed key.");
      let [, i, n] = r;
      if (e[i].length > +n + 1)
        throw new TypeError(`RestElement must be last element of ${i}`);
    } : void 0
  });
  Ne("ReturnStatement", {
    visitor: ["argument"],
    aliases: ["Statement", "Terminatorless", "CompletionStatement"],
    fields: {
      argument: {
        validate: (0, K.assertNodeType)("Expression"),
        optional: !0
      }
    }
  });
  Ne("SequenceExpression", {
    visitor: ["expressions"],
    fields: {
      expressions: (0, K.validateArrayOfType)("Expression")
    },
    aliases: ["Expression"]
  });
  Ne("ParenthesizedExpression", {
    visitor: ["expression"],
    aliases: ["Expression", "ExpressionWrapper"],
    fields: {
      expression: {
        validate: (0, K.assertNodeType)("Expression")
      }
    }
  });
  Ne("SwitchCase", {
    visitor: ["test", "consequent"],
    fields: {
      test: {
        validate: (0, K.assertNodeType)("Expression"),
        optional: !0
      },
      consequent: (0, K.validateArrayOfType)("Statement")
    }
  });
  Ne("SwitchStatement", {
    visitor: ["discriminant", "cases"],
    aliases: ["Statement", "BlockParent", "Scopable"],
    fields: {
      discriminant: {
        validate: (0, K.assertNodeType)("Expression")
      },
      cases: (0, K.validateArrayOfType)("SwitchCase")
    }
  });
  Ne("ThisExpression", {
    aliases: ["Expression"]
  });
  Ne("ThrowStatement", {
    visitor: ["argument"],
    aliases: ["Statement", "Terminatorless", "CompletionStatement"],
    fields: {
      argument: {
        validate: (0, K.assertNodeType)("Expression")
      }
    }
  });
  Ne("TryStatement", {
    visitor: ["block", "handler", "finalizer"],
    aliases: ["Statement"],
    fields: {
      block: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, K.chain)((0, K.assertNodeType)("BlockStatement"), Object.assign(function(e) {
          if (!e.handler && !e.finalizer)
            throw new TypeError("TryStatement expects either a handler or finalizer, or both");
        }, {
          oneOfNodeTypes: ["BlockStatement"]
        })) : (0, K.assertNodeType)("BlockStatement")
      },
      handler: {
        optional: !0,
        validate: (0, K.assertNodeType)("CatchClause")
      },
      finalizer: {
        optional: !0,
        validate: (0, K.assertNodeType)("BlockStatement")
      }
    }
  });
  Ne("UnaryExpression", {
    builder: ["operator", "argument", "prefix"],
    fields: {
      prefix: {
        default: !0
      },
      argument: {
        validate: (0, K.assertNodeType)("Expression")
      },
      operator: {
        validate: (0, K.assertOneOf)(...od.UNARY_OPERATORS)
      }
    },
    visitor: ["argument"],
    aliases: ["UnaryLike", "Expression"]
  });
  Ne("UpdateExpression", {
    builder: ["operator", "argument", "prefix"],
    fields: {
      prefix: {
        default: !1
      },
      argument: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, K.assertNodeType)("Identifier", "MemberExpression") : (0, K.assertNodeType)("Expr\
ession")
      },
      operator: {
        validate: (0, K.assertOneOf)(...od.UPDATE_OPERATORS)
      }
    },
    visitor: ["argument"],
    aliases: ["Expression"]
  });
  Ne("VariableDeclaration", {
    builder: ["kind", "declarations"],
    visitor: ["declarations"],
    aliases: ["Statement", "Declaration"],
    fields: {
      declare: {
        validate: (0, K.assertValueType)("boolean"),
        optional: !0
      },
      kind: {
        validate: (0, K.assertOneOf)("var", "let", "const", "using", "await using")
      },
      declarations: (0, K.validateArrayOfType)("VariableDeclarator")
    },
    validate: process.env.BABEL_TYPES_8_BREAKING ? (() => {
      let e = (0, K.assertNodeType)("Identifier");
      return function(t, r, i) {
        if ((0, cs.default)("ForXStatement", t, {
          left: i
        })) {
          if (i.declarations.length !== 1)
            throw new TypeError(`Exactly one VariableDeclarator is required in the VariableDeclaration of a ${t.type}`);
        } else
          i.declarations.forEach((n) => {
            n.init || e(n, "id", n.id);
          });
      };
    })() : void 0
  });
  Ne("VariableDeclarator", {
    visitor: ["id", "init"],
    fields: {
      id: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, K.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern") : (0, K.assertNodeType)(
        "LVal")
      },
      definite: {
        optional: !0,
        validate: (0, K.assertValueType)("boolean")
      },
      init: {
        optional: !0,
        validate: (0, K.assertNodeType)("Expression")
      }
    }
  });
  Ne("WhileStatement", {
    visitor: ["test", "body"],
    aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"],
    fields: {
      test: {
        validate: (0, K.assertNodeType)("Expression")
      },
      body: {
        validate: (0, K.assertNodeType)("Statement")
      }
    }
  });
  Ne("WithStatement", {
    visitor: ["object", "body"],
    aliases: ["Statement"],
    fields: {
      object: {
        validate: (0, K.assertNodeType)("Expression")
      },
      body: {
        validate: (0, K.assertNodeType)("Statement")
      }
    }
  });
  Ne("AssignmentPattern", {
    visitor: ["left", "right", "decorators"],
    builder: ["left", "right"],
    aliases: ["Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, $f(), {
      left: {
        validate: (0, K.assertNodeType)("Identifier", "ObjectPattern", "ArrayPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExp\
ression", "TSTypeAssertion", "TSNonNullExpression")
      },
      right: {
        validate: (0, K.assertNodeType)("Expression")
      },
      decorators: {
        validate: (0, K.arrayOfType)("Decorator"),
        optional: !0
      }
    })
  });
  Ne("ArrayPattern", {
    visitor: ["elements", "typeAnnotation"],
    builder: ["elements"],
    aliases: ["Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, $f(), {
      elements: {
        validate: (0, K.chain)((0, K.assertValueType)("array"), (0, K.assertEach)((0, K.assertNodeOrValueType)("null", "PatternLike", "LVal")))
      }
    })
  });
  Ne("ArrowFunctionExpression", {
    builder: ["params", "body", "async"],
    visitor: ["typeParameters", "params", "predicate", "returnType", "body"],
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
    fields: Object.assign({}, Wf(), uc(), {
      expression: {
        validate: (0, K.assertValueType)("boolean")
      },
      body: {
        validate: (0, K.assertNodeType)("BlockStatement", "Expression")
      },
      predicate: {
        validate: (0, K.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
        optional: !0
      }
    })
  });
  Ne("ClassBody", {
    visitor: ["body"],
    fields: {
      body: (0, K.validateArrayOfType)("ClassMethod", "ClassPrivateMethod", "ClassProperty", "ClassPrivateProperty", "ClassAccessorProperty",
      "TSDeclareMethod", "TSIndexSignature", "StaticBlock")
    }
  });
  Ne("ClassExpression", {
    builder: ["id", "superClass", "body", "decorators"],
    visitor: ["decorators", "id", "typeParameters", "superClass", "superTypeParameters", "mixins", "implements", "body"],
    aliases: ["Scopable", "Class", "Expression"],
    fields: {
      id: {
        validate: (0, K.assertNodeType)("Identifier"),
        optional: !0
      },
      typeParameters: {
        validate: (0, K.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
        optional: !0
      },
      body: {
        validate: (0, K.assertNodeType)("ClassBody")
      },
      superClass: {
        optional: !0,
        validate: (0, K.assertNodeType)("Expression")
      },
      superTypeParameters: {
        validate: (0, K.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: !0
      },
      implements: {
        validate: (0, K.arrayOfType)("TSExpressionWithTypeArguments", "ClassImplements"),
        optional: !0
      },
      decorators: {
        validate: (0, K.arrayOfType)("Decorator"),
        optional: !0
      },
      mixins: {
        validate: (0, K.assertNodeType)("InterfaceExtends"),
        optional: !0
      }
    }
  });
  Ne("ClassDeclaration", {
    inherits: "ClassExpression",
    aliases: ["Scopable", "Class", "Statement", "Declaration"],
    fields: {
      id: {
        validate: (0, K.assertNodeType)("Identifier"),
        optional: !0
      },
      typeParameters: {
        validate: (0, K.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
        optional: !0
      },
      body: {
        validate: (0, K.assertNodeType)("ClassBody")
      },
      superClass: {
        optional: !0,
        validate: (0, K.assertNodeType)("Expression")
      },
      superTypeParameters: {
        validate: (0, K.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: !0
      },
      implements: {
        validate: (0, K.arrayOfType)("TSExpressionWithTypeArguments", "ClassImplements"),
        optional: !0
      },
      decorators: {
        validate: (0, K.arrayOfType)("Decorator"),
        optional: !0
      },
      mixins: {
        validate: (0, K.assertNodeType)("InterfaceExtends"),
        optional: !0
      },
      declare: {
        validate: (0, K.assertValueType)("boolean"),
        optional: !0
      },
      abstract: {
        validate: (0, K.assertValueType)("boolean"),
        optional: !0
      }
    },
    validate: process.env.BABEL_TYPES_8_BREAKING ? function() {
      let e = (0, K.assertNodeType)("Identifier");
      return function(t, r, i) {
        (0, cs.default)("ExportDefaultDeclaration", t) || e(i, "id", i.id);
      };
    }() : void 0
  });
  var Wx = $n.importAttributes = {
    attributes: {
      optional: !0,
      validate: (0, K.arrayOfType)("ImportAttribute")
    },
    assertions: {
      deprecated: !0,
      optional: !0,
      validate: (0, K.arrayOfType)("ImportAttribute")
    }
  };
  Ne("ExportAllDeclaration", {
    builder: ["source"],
    visitor: ["source", "attributes", "assertions"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
    fields: Object.assign({
      source: {
        validate: (0, K.assertNodeType)("StringLiteral")
      },
      exportKind: (0, K.validateOptional)((0, K.assertOneOf)("type", "value"))
    }, Wx)
  });
  Ne("ExportDefaultDeclaration", {
    visitor: ["declaration"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
    fields: {
      declaration: (0, K.validateType)("TSDeclareFunction", "FunctionDeclaration", "ClassDeclaration", "Expression"),
      exportKind: (0, K.validateOptional)((0, K.assertOneOf)("value"))
    }
  });
  Ne("ExportNamedDeclaration", {
    builder: ["declaration", "specifiers", "source"],
    visitor: process.env ? ["declaration", "specifiers", "source", "attributes"] : ["declaration", "specifiers", "source", "attributes", "as\
sertions"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
    fields: Object.assign({
      declaration: {
        optional: !0,
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, K.chain)((0, K.assertNodeType)("Declaration"), Object.assign(function(e, t, r) {
          if (r && e.specifiers.length)
            throw new TypeError("Only declaration or specifiers is allowed on ExportNamedDeclaration");
          if (r && e.source)
            throw new TypeError("Cannot export a declaration from a source");
        }, {
          oneOfNodeTypes: ["Declaration"]
        })) : (0, K.assertNodeType)("Declaration")
      }
    }, Wx, {
      specifiers: {
        default: [],
        validate: (0, K.arrayOf)(function() {
          let e = (0, K.assertNodeType)("ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier"), t = (0, K.assertNodeType)(
          "ExportSpecifier");
          return process.env.BABEL_TYPES_8_BREAKING ? Object.assign(function(r, i, n) {
            (r.source ? e : t)(r, i, n);
          }, {
            oneOfNodeTypes: ["ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier"]
          }) : e;
        }())
      },
      source: {
        validate: (0, K.assertNodeType)("StringLiteral"),
        optional: !0
      },
      exportKind: (0, K.validateOptional)((0, K.assertOneOf)("type", "value"))
    })
  });
  Ne("ExportSpecifier", {
    visitor: ["local", "exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, K.assertNodeType)("Identifier")
      },
      exported: {
        validate: (0, K.assertNodeType)("Identifier", "StringLiteral")
      },
      exportKind: {
        validate: (0, K.assertOneOf)("type", "value"),
        optional: !0
      }
    }
  });
  Ne("ForOfStatement", {
    visitor: ["left", "right", "body"],
    builder: ["left", "right", "body", "await"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
    fields: {
      left: {
        validate: function() {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return (0, K.assertNodeType)("VariableDeclaration", "LVal");
          let e = (0, K.assertNodeType)("VariableDeclaration"), t = (0, K.assertNodeType)("Identifier", "MemberExpression", "ArrayPattern", "\
ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression");
          return Object.assign(function(r, i, n) {
            (0, cs.default)("VariableDeclaration", n) ? e(r, i, n) : t(r, i, n);
          }, {
            oneOfNodeTypes: ["VariableDeclaration", "Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TS\
SatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression"]
          });
        }()
      },
      right: {
        validate: (0, K.assertNodeType)("Expression")
      },
      body: {
        validate: (0, K.assertNodeType)("Statement")
      },
      await: {
        default: !1
      }
    }
  });
  Ne("ImportDeclaration", {
    builder: ["specifiers", "source"],
    visitor: ["specifiers", "source", "attributes", "assertions"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration"],
    fields: Object.assign({}, Wx, {
      module: {
        optional: !0,
        validate: (0, K.assertValueType)("boolean")
      },
      phase: {
        default: null,
        validate: (0, K.assertOneOf)("source", "defer")
      },
      specifiers: (0, K.validateArrayOfType)("ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier"),
      source: {
        validate: (0, K.assertNodeType)("StringLiteral")
      },
      importKind: {
        validate: (0, K.assertOneOf)("type", "typeof", "value"),
        optional: !0
      }
    })
  });
  Ne("ImportDefaultSpecifier", {
    visitor: ["local"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, K.assertNodeType)("Identifier")
      }
    }
  });
  Ne("ImportNamespaceSpecifier", {
    visitor: ["local"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, K.assertNodeType)("Identifier")
      }
    }
  });
  Ne("ImportSpecifier", {
    visitor: ["imported", "local"],
    builder: ["local", "imported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, K.assertNodeType)("Identifier")
      },
      imported: {
        validate: (0, K.assertNodeType)("Identifier", "StringLiteral")
      },
      importKind: {
        validate: (0, K.assertOneOf)("type", "typeof", "value"),
        optional: !0
      }
    }
  });
  Ne("ImportExpression", {
    visitor: ["source", "options"],
    aliases: ["Expression"],
    fields: {
      phase: {
        default: null,
        validate: (0, K.assertOneOf)("source", "defer")
      },
      source: {
        validate: (0, K.assertNodeType)("Expression")
      },
      options: {
        validate: (0, K.assertNodeType)("Expression"),
        optional: !0
      }
    }
  });
  Ne("MetaProperty", {
    visitor: ["meta", "property"],
    aliases: ["Expression"],
    fields: {
      meta: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, K.chain)((0, K.assertNodeType)("Identifier"), Object.assign(function(e, t, r) {
          let i;
          switch (r.name) {
            case "function":
              i = "sent";
              break;
            case "new":
              i = "target";
              break;
            case "import":
              i = "meta";
              break;
          }
          if (!(0, cs.default)("Identifier", e.property, {
            name: i
          }))
            throw new TypeError("Unrecognised MetaProperty");
        }, {
          oneOfNodeTypes: ["Identifier"]
        })) : (0, K.assertNodeType)("Identifier")
      },
      property: {
        validate: (0, K.assertNodeType)("Identifier")
      }
    }
  });
  var o_ = /* @__PURE__ */ s(() => ({
    abstract: {
      validate: (0, K.assertValueType)("boolean"),
      optional: !0
    },
    accessibility: {
      validate: (0, K.assertOneOf)("public", "private", "protected"),
      optional: !0
    },
    static: {
      default: !1
    },
    override: {
      default: !1
    },
    computed: {
      default: !1
    },
    optional: {
      validate: (0, K.assertValueType)("boolean"),
      optional: !0
    },
    key: {
      validate: (0, K.chain)(function() {
        let e = (0, K.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"), t = (0, K.assertNodeType)("Expressi\
on");
        return function(r, i, n) {
          (r.computed ? t : e)(r, i, n);
        };
      }(), (0, K.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression"))
    }
  }), "classMethodOrPropertyCommon");
  $n.classMethodOrPropertyCommon = o_;
  var $x = /* @__PURE__ */ s(() => Object.assign({}, Wf(), o_(), {
    params: (0, K.validateArrayOfType)("Identifier", "Pattern", "RestElement", "TSParameterProperty"),
    kind: {
      validate: (0, K.assertOneOf)("get", "set", "method", "constructor"),
      default: "method"
    },
    access: {
      validate: (0, K.chain)((0, K.assertValueType)("string"), (0, K.assertOneOf)("public", "private", "protected")),
      optional: !0
    },
    decorators: {
      validate: (0, K.arrayOfType)("Decorator"),
      optional: !0
    }
  }), "classMethodOrDeclareMethodCommon");
  $n.classMethodOrDeclareMethodCommon = $x;
  Ne("ClassMethod", {
    aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method"],
    builder: ["kind", "key", "params", "body", "computed", "static", "generator", "async"],
    visitor: ["decorators", "key", "typeParameters", "params", "returnType", "body"],
    fields: Object.assign({}, $x(), uc(), {
      body: {
        validate: (0, K.assertNodeType)("BlockStatement")
      }
    })
  });
  Ne("ObjectPattern", {
    visitor: ["properties", "typeAnnotation", "decorators"],
    builder: ["properties"],
    aliases: ["Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, $f(), {
      properties: (0, K.validateArrayOfType)("RestElement", "ObjectProperty")
    })
  });
  Ne("SpreadElement", {
    visitor: ["argument"],
    aliases: ["UnaryLike"],
    deprecatedAlias: "SpreadProperty",
    fields: {
      argument: {
        validate: (0, K.assertNodeType)("Expression")
      }
    }
  });
  Ne("Super", {
    aliases: ["Expression"]
  });
  Ne("TaggedTemplateExpression", {
    visitor: ["tag", "typeParameters", "quasi"],
    builder: ["tag", "quasi"],
    aliases: ["Expression"],
    fields: {
      tag: {
        validate: (0, K.assertNodeType)("Expression")
      },
      quasi: {
        validate: (0, K.assertNodeType)("TemplateLiteral")
      },
      typeParameters: {
        validate: (0, K.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: !0
      }
    }
  });
  Ne("TemplateElement", {
    builder: ["value", "tail"],
    fields: {
      value: {
        validate: (0, K.chain)((0, K.assertShape)({
          raw: {
            validate: (0, K.assertValueType)("string")
          },
          cooked: {
            validate: (0, K.assertValueType)("string"),
            optional: !0
          }
        }), /* @__PURE__ */ s(function(t) {
          let r = t.value.raw, i = !1, n = /* @__PURE__ */ s(() => {
            throw new Error("Internal @babel/types error.");
          }, "error"), {
            str: a,
            firstInvalidLoc: o
          } = (0, jSe.readStringContents)("template", r, 0, 0, 0, {
            unterminated() {
              i = !0;
            },
            strictNumericEscape: n,
            invalidEscapeSequence: n,
            numericSeparatorInEscapeSequence: n,
            unexpectedNumericSeparator: n,
            invalidDigit: n,
            invalidCodePoint: n
          });
          if (!i) throw new Error("Invalid raw");
          t.value.cooked = o ? null : a;
        }, "templateElementCookedValidator"))
      },
      tail: {
        default: !1
      }
    }
  });
  Ne("TemplateLiteral", {
    visitor: ["quasis", "expressions"],
    aliases: ["Expression", "Literal"],
    fields: {
      quasis: (0, K.validateArrayOfType)("TemplateElement"),
      expressions: {
        validate: (0, K.chain)((0, K.assertValueType)("array"), (0, K.assertEach)((0, K.assertNodeType)("Expression", "TSType")), function(e, t, r) {
          if (e.quasis.length !== r.length + 1)
            throw new TypeError(`Number of ${e.type} quasis should be exactly one more than the number of expressions.
Expected ${r.length + 1} quasis but got ${e.quasis.length}`);
        })
      }
    }
  });
  Ne("YieldExpression", {
    builder: ["argument", "delegate"],
    visitor: ["argument"],
    aliases: ["Expression", "Terminatorless"],
    fields: {
      delegate: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, K.chain)((0, K.assertValueType)("boolean"), Object.assign(function(e, t, r) {
          if (r && !e.argument)
            throw new TypeError("Property delegate of YieldExpression cannot be true if there is no argument");
        }, {
          type: "boolean"
        })) : (0, K.assertValueType)("boolean"),
        default: !1
      },
      argument: {
        optional: !0,
        validate: (0, K.assertNodeType)("Expression")
      }
    }
  });
  Ne("AwaitExpression", {
    builder: ["argument"],
    visitor: ["argument"],
    aliases: ["Expression", "Terminatorless"],
    fields: {
      argument: {
        validate: (0, K.assertNodeType)("Expression")
      }
    }
  });
  Ne("Import", {
    aliases: ["Expression"]
  });
  Ne("BigIntLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, K.assertValueType)("string")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  Ne("ExportNamespaceSpecifier", {
    visitor: ["exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      exported: {
        validate: (0, K.assertNodeType)("Identifier")
      }
    }
  });
  Ne("OptionalMemberExpression", {
    builder: ["object", "property", "computed", "optional"],
    visitor: ["object", "property"],
    aliases: ["Expression"],
    fields: {
      object: {
        validate: (0, K.assertNodeType)("Expression")
      },
      property: {
        validate: function() {
          let e = (0, K.assertNodeType)("Identifier"), t = (0, K.assertNodeType)("Expression");
          return Object.assign(function(i, n, a) {
            (i.computed ? t : e)(i, n, a);
          }, {
            oneOfNodeTypes: ["Expression", "Identifier"]
          });
        }()
      },
      computed: {
        default: !1
      },
      optional: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, K.chain)((0, K.assertValueType)("boolean"), (0, K.assertOptionalChainStart)()) : (0, K.
        assertValueType)("boolean")
      }
    }
  });
  Ne("OptionalCallExpression", {
    visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
    builder: ["callee", "arguments", "optional"],
    aliases: ["Expression"],
    fields: Object.assign({
      callee: {
        validate: (0, K.assertNodeType)("Expression")
      },
      arguments: (0, K.validateArrayOfType)("Expression", "SpreadElement", "ArgumentPlaceholder"),
      optional: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, K.chain)((0, K.assertValueType)("boolean"), (0, K.assertOptionalChainStart)()) : (0, K.
        assertValueType)("boolean")
      },
      typeArguments: {
        validate: (0, K.assertNodeType)("TypeParameterInstantiation"),
        optional: !0
      }
    }, {
      typeParameters: {
        validate: (0, K.assertNodeType)("TSTypeParameterInstantiation"),
        optional: !0
      }
    })
  });
  Ne("ClassProperty", {
    visitor: ["decorators", "variance", "key", "typeAnnotation", "value"],
    builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
    aliases: ["Property"],
    fields: Object.assign({}, o_(), {
      value: {
        validate: (0, K.assertNodeType)("Expression"),
        optional: !0
      },
      definite: {
        validate: (0, K.assertValueType)("boolean"),
        optional: !0
      },
      typeAnnotation: {
        validate: (0, K.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: !0
      },
      decorators: {
        validate: (0, K.arrayOfType)("Decorator"),
        optional: !0
      },
      readonly: {
        validate: (0, K.assertValueType)("boolean"),
        optional: !0
      },
      declare: {
        validate: (0, K.assertValueType)("boolean"),
        optional: !0
      },
      variance: {
        validate: (0, K.assertNodeType)("Variance"),
        optional: !0
      }
    })
  });
  Ne("ClassAccessorProperty", {
    visitor: ["decorators", "key", "typeAnnotation", "value"],
    builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
    aliases: ["Property", "Accessor"],
    fields: Object.assign({}, o_(), {
      key: {
        validate: (0, K.chain)(function() {
          let e = (0, K.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "PrivateName"), t = (0, K.assertNodeType)(
          "Expression");
          return function(r, i, n) {
            (r.computed ? t : e)(r, i, n);
          };
        }(), (0, K.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression", "PrivateName"))
      },
      value: {
        validate: (0, K.assertNodeType)("Expression"),
        optional: !0
      },
      definite: {
        validate: (0, K.assertValueType)("boolean"),
        optional: !0
      },
      typeAnnotation: {
        validate: (0, K.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: !0
      },
      decorators: {
        validate: (0, K.arrayOfType)("Decorator"),
        optional: !0
      },
      readonly: {
        validate: (0, K.assertValueType)("boolean"),
        optional: !0
      },
      declare: {
        validate: (0, K.assertValueType)("boolean"),
        optional: !0
      },
      variance: {
        validate: (0, K.assertNodeType)("Variance"),
        optional: !0
      }
    })
  });
  Ne("ClassPrivateProperty", {
    visitor: ["decorators", "variance", "key", "typeAnnotation", "value"],
    builder: ["key", "value", "decorators", "static"],
    aliases: ["Property", "Private"],
    fields: {
      key: {
        validate: (0, K.assertNodeType)("PrivateName")
      },
      value: {
        validate: (0, K.assertNodeType)("Expression"),
        optional: !0
      },
      typeAnnotation: {
        validate: (0, K.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: !0
      },
      decorators: {
        validate: (0, K.arrayOfType)("Decorator"),
        optional: !0
      },
      static: {
        validate: (0, K.assertValueType)("boolean"),
        default: !1
      },
      readonly: {
        validate: (0, K.assertValueType)("boolean"),
        optional: !0
      },
      optional: {
        validate: (0, K.assertValueType)("boolean"),
        optional: !0
      },
      definite: {
        validate: (0, K.assertValueType)("boolean"),
        optional: !0
      },
      variance: {
        validate: (0, K.assertNodeType)("Variance"),
        optional: !0
      }
    }
  });
  Ne("ClassPrivateMethod", {
    builder: ["kind", "key", "params", "body", "static"],
    visitor: ["decorators", "key", "typeParameters", "params", "returnType", "body"],
    aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method", "Private"],
    fields: Object.assign({}, $x(), uc(), {
      kind: {
        validate: (0, K.assertOneOf)("get", "set", "method"),
        default: "method"
      },
      key: {
        validate: (0, K.assertNodeType)("PrivateName")
      },
      body: {
        validate: (0, K.assertNodeType)("BlockStatement")
      }
    })
  });
  Ne("PrivateName", {
    visitor: ["id"],
    aliases: ["Private"],
    fields: {
      id: {
        validate: (0, K.assertNodeType)("Identifier")
      }
    }
  });
  Ne("StaticBlock", {
    visitor: ["body"],
    fields: {
      body: (0, K.validateArrayOfType)("Statement")
    },
    aliases: ["Scopable", "BlockParent", "FunctionParent"]
  });
  Ne("ImportAttribute", {
    visitor: ["key", "value"],
    fields: {
      key: {
        validate: (0, K.assertNodeType)("Identifier", "StringLiteral")
      },
      value: {
        validate: (0, K.assertNodeType)("StringLiteral")
      }
    }
  });
});

// ../node_modules/@babel/types/lib/definitions/flow.js
var V8 = b(() => {
  "use strict";
  var j8 = ud(), ue = Io(), et = (0, ue.defineAliasedType)("Flow"), Xx = /* @__PURE__ */ s((e) => {
    let t = e === "DeclareClass";
    et(e, {
      builder: ["id", "typeParameters", "extends", "body"],
      visitor: ["id", "typeParameters", "extends", ...t ? ["mixins", "implements"] : [], "body"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: Object.assign({
        id: (0, ue.validateType)("Identifier"),
        typeParameters: (0, ue.validateOptionalType)("TypeParameterDeclaration"),
        extends: (0, ue.validateOptional)((0, ue.arrayOfType)("InterfaceExtends"))
      }, t ? {
        mixins: (0, ue.validateOptional)((0, ue.arrayOfType)("InterfaceExtends")),
        implements: (0, ue.validateOptional)((0, ue.arrayOfType)("ClassImplements"))
      } : {}, {
        body: (0, ue.validateType)("ObjectTypeAnnotation")
      })
    });
  }, "defineInterfaceishType");
  et("AnyTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  et("ArrayTypeAnnotation", {
    visitor: ["elementType"],
    aliases: ["FlowType"],
    fields: {
      elementType: (0, ue.validateType)("FlowType")
    }
  });
  et("BooleanTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  et("BooleanLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["FlowType"],
    fields: {
      value: (0, ue.validate)((0, ue.assertValueType)("boolean"))
    }
  });
  et("NullLiteralTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  et("ClassImplements", {
    visitor: ["id", "typeParameters"],
    fields: {
      id: (0, ue.validateType)("Identifier"),
      typeParameters: (0, ue.validateOptionalType)("TypeParameterInstantiation")
    }
  });
  Xx("DeclareClass");
  et("DeclareFunction", {
    builder: ["id"],
    visitor: ["id", "predicate"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, ue.validateType)("Identifier"),
      predicate: (0, ue.validateOptionalType)("DeclaredPredicate")
    }
  });
  Xx("DeclareInterface");
  et("DeclareModule", {
    builder: ["id", "body", "kind"],
    visitor: ["id", "body"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, ue.validateType)("Identifier", "StringLiteral"),
      body: (0, ue.validateType)("BlockStatement"),
      kind: (0, ue.validateOptional)((0, ue.assertOneOf)("CommonJS", "ES"))
    }
  });
  et("DeclareModuleExports", {
    visitor: ["typeAnnotation"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      typeAnnotation: (0, ue.validateType)("TypeAnnotation")
    }
  });
  et("DeclareTypeAlias", {
    visitor: ["id", "typeParameters", "right"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, ue.validateType)("Identifier"),
      typeParameters: (0, ue.validateOptionalType)("TypeParameterDeclaration"),
      right: (0, ue.validateType)("FlowType")
    }
  });
  et("DeclareOpaqueType", {
    visitor: ["id", "typeParameters", "supertype"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, ue.validateType)("Identifier"),
      typeParameters: (0, ue.validateOptionalType)("TypeParameterDeclaration"),
      supertype: (0, ue.validateOptionalType)("FlowType"),
      impltype: (0, ue.validateOptionalType)("FlowType")
    }
  });
  et("DeclareVariable", {
    visitor: ["id"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, ue.validateType)("Identifier")
    }
  });
  et("DeclareExportDeclaration", {
    visitor: ["declaration", "specifiers", "source", "attributes"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: Object.assign({
      declaration: (0, ue.validateOptionalType)("Flow"),
      specifiers: (0, ue.validateOptional)((0, ue.arrayOfType)("ExportSpecifier", "ExportNamespaceSpecifier")),
      source: (0, ue.validateOptionalType)("StringLiteral"),
      default: (0, ue.validateOptional)((0, ue.assertValueType)("boolean"))
    }, j8.importAttributes)
  });
  et("DeclareExportAllDeclaration", {
    visitor: ["source", "attributes"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: Object.assign({
      source: (0, ue.validateType)("StringLiteral"),
      exportKind: (0, ue.validateOptional)((0, ue.assertOneOf)("type", "value"))
    }, j8.importAttributes)
  });
  et("DeclaredPredicate", {
    visitor: ["value"],
    aliases: ["FlowPredicate"],
    fields: {
      value: (0, ue.validateType)("Flow")
    }
  });
  et("ExistsTypeAnnotation", {
    aliases: ["FlowType"]
  });
  et("FunctionTypeAnnotation", {
    builder: ["typeParameters", "params", "rest", "returnType"],
    visitor: ["typeParameters", "this", "params", "rest", "returnType"],
    aliases: ["FlowType"],
    fields: {
      typeParameters: (0, ue.validateOptionalType)("TypeParameterDeclaration"),
      params: (0, ue.validateArrayOfType)("FunctionTypeParam"),
      rest: (0, ue.validateOptionalType)("FunctionTypeParam"),
      this: (0, ue.validateOptionalType)("FunctionTypeParam"),
      returnType: (0, ue.validateType)("FlowType")
    }
  });
  et("FunctionTypeParam", {
    visitor: ["name", "typeAnnotation"],
    fields: {
      name: (0, ue.validateOptionalType)("Identifier"),
      typeAnnotation: (0, ue.validateType)("FlowType"),
      optional: (0, ue.validateOptional)((0, ue.assertValueType)("boolean"))
    }
  });
  et("GenericTypeAnnotation", {
    visitor: ["id", "typeParameters"],
    aliases: ["FlowType"],
    fields: {
      id: (0, ue.validateType)("Identifier", "QualifiedTypeIdentifier"),
      typeParameters: (0, ue.validateOptionalType)("TypeParameterInstantiation")
    }
  });
  et("InferredPredicate", {
    aliases: ["FlowPredicate"]
  });
  et("InterfaceExtends", {
    visitor: ["id", "typeParameters"],
    fields: {
      id: (0, ue.validateType)("Identifier", "QualifiedTypeIdentifier"),
      typeParameters: (0, ue.validateOptionalType)("TypeParameterInstantiation")
    }
  });
  Xx("InterfaceDeclaration");
  et("InterfaceTypeAnnotation", {
    visitor: ["extends", "body"],
    aliases: ["FlowType"],
    fields: {
      extends: (0, ue.validateOptional)((0, ue.arrayOfType)("InterfaceExtends")),
      body: (0, ue.validateType)("ObjectTypeAnnotation")
    }
  });
  et("IntersectionTypeAnnotation", {
    visitor: ["types"],
    aliases: ["FlowType"],
    fields: {
      types: (0, ue.validate)((0, ue.arrayOfType)("FlowType"))
    }
  });
  et("MixedTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  et("EmptyTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  et("NullableTypeAnnotation", {
    visitor: ["typeAnnotation"],
    aliases: ["FlowType"],
    fields: {
      typeAnnotation: (0, ue.validateType)("FlowType")
    }
  });
  et("NumberLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["FlowType"],
    fields: {
      value: (0, ue.validate)((0, ue.assertValueType)("number"))
    }
  });
  et("NumberTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  et("ObjectTypeAnnotation", {
    visitor: ["properties", "indexers", "callProperties", "internalSlots"],
    aliases: ["FlowType"],
    builder: ["properties", "indexers", "callProperties", "internalSlots", "exact"],
    fields: {
      properties: (0, ue.validate)((0, ue.arrayOfType)("ObjectTypeProperty", "ObjectTypeSpreadProperty")),
      indexers: {
        validate: (0, ue.arrayOfType)("ObjectTypeIndexer"),
        optional: !0,
        default: []
      },
      callProperties: {
        validate: (0, ue.arrayOfType)("ObjectTypeCallProperty"),
        optional: !0,
        default: []
      },
      internalSlots: {
        validate: (0, ue.arrayOfType)("ObjectTypeInternalSlot"),
        optional: !0,
        default: []
      },
      exact: {
        validate: (0, ue.assertValueType)("boolean"),
        default: !1
      },
      inexact: (0, ue.validateOptional)((0, ue.assertValueType)("boolean"))
    }
  });
  et("ObjectTypeInternalSlot", {
    visitor: ["id", "value"],
    builder: ["id", "value", "optional", "static", "method"],
    aliases: ["UserWhitespacable"],
    fields: {
      id: (0, ue.validateType)("Identifier"),
      value: (0, ue.validateType)("FlowType"),
      optional: (0, ue.validate)((0, ue.assertValueType)("boolean")),
      static: (0, ue.validate)((0, ue.assertValueType)("boolean")),
      method: (0, ue.validate)((0, ue.assertValueType)("boolean"))
    }
  });
  et("ObjectTypeCallProperty", {
    visitor: ["value"],
    aliases: ["UserWhitespacable"],
    fields: {
      value: (0, ue.validateType)("FlowType"),
      static: (0, ue.validate)((0, ue.assertValueType)("boolean"))
    }
  });
  et("ObjectTypeIndexer", {
    visitor: ["variance", "id", "key", "value"],
    builder: ["id", "key", "value", "variance"],
    aliases: ["UserWhitespacable"],
    fields: {
      id: (0, ue.validateOptionalType)("Identifier"),
      key: (0, ue.validateType)("FlowType"),
      value: (0, ue.validateType)("FlowType"),
      static: (0, ue.validate)((0, ue.assertValueType)("boolean")),
      variance: (0, ue.validateOptionalType)("Variance")
    }
  });
  et("ObjectTypeProperty", {
    visitor: ["key", "value", "variance"],
    aliases: ["UserWhitespacable"],
    fields: {
      key: (0, ue.validateType)("Identifier", "StringLiteral"),
      value: (0, ue.validateType)("FlowType"),
      kind: (0, ue.validate)((0, ue.assertOneOf)("init", "get", "set")),
      static: (0, ue.validate)((0, ue.assertValueType)("boolean")),
      proto: (0, ue.validate)((0, ue.assertValueType)("boolean")),
      optional: (0, ue.validate)((0, ue.assertValueType)("boolean")),
      variance: (0, ue.validateOptionalType)("Variance"),
      method: (0, ue.validate)((0, ue.assertValueType)("boolean"))
    }
  });
  et("ObjectTypeSpreadProperty", {
    visitor: ["argument"],
    aliases: ["UserWhitespacable"],
    fields: {
      argument: (0, ue.validateType)("FlowType")
    }
  });
  et("OpaqueType", {
    visitor: ["id", "typeParameters", "supertype", "impltype"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, ue.validateType)("Identifier"),
      typeParameters: (0, ue.validateOptionalType)("TypeParameterDeclaration"),
      supertype: (0, ue.validateOptionalType)("FlowType"),
      impltype: (0, ue.validateType)("FlowType")
    }
  });
  et("QualifiedTypeIdentifier", {
    visitor: ["qualification", "id"],
    builder: ["id", "qualification"],
    fields: {
      id: (0, ue.validateType)("Identifier"),
      qualification: (0, ue.validateType)("Identifier", "QualifiedTypeIdentifier")
    }
  });
  et("StringLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["FlowType"],
    fields: {
      value: (0, ue.validate)((0, ue.assertValueType)("string"))
    }
  });
  et("StringTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  et("SymbolTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  et("ThisTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  et("TupleTypeAnnotation", {
    visitor: ["types"],
    aliases: ["FlowType"],
    fields: {
      types: (0, ue.validate)((0, ue.arrayOfType)("FlowType"))
    }
  });
  et("TypeofTypeAnnotation", {
    visitor: ["argument"],
    aliases: ["FlowType"],
    fields: {
      argument: (0, ue.validateType)("FlowType")
    }
  });
  et("TypeAlias", {
    visitor: ["id", "typeParameters", "right"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, ue.validateType)("Identifier"),
      typeParameters: (0, ue.validateOptionalType)("TypeParameterDeclaration"),
      right: (0, ue.validateType)("FlowType")
    }
  });
  et("TypeAnnotation", {
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, ue.validateType)("FlowType")
    }
  });
  et("TypeCastExpression", {
    visitor: ["expression", "typeAnnotation"],
    aliases: ["ExpressionWrapper", "Expression"],
    fields: {
      expression: (0, ue.validateType)("Expression"),
      typeAnnotation: (0, ue.validateType)("TypeAnnotation")
    }
  });
  et("TypeParameter", {
    visitor: ["bound", "default", "variance"],
    fields: {
      name: (0, ue.validate)((0, ue.assertValueType)("string")),
      bound: (0, ue.validateOptionalType)("TypeAnnotation"),
      default: (0, ue.validateOptionalType)("FlowType"),
      variance: (0, ue.validateOptionalType)("Variance")
    }
  });
  et("TypeParameterDeclaration", {
    visitor: ["params"],
    fields: {
      params: (0, ue.validate)((0, ue.arrayOfType)("TypeParameter"))
    }
  });
  et("TypeParameterInstantiation", {
    visitor: ["params"],
    fields: {
      params: (0, ue.validate)((0, ue.arrayOfType)("FlowType"))
    }
  });
  et("UnionTypeAnnotation", {
    visitor: ["types"],
    aliases: ["FlowType"],
    fields: {
      types: (0, ue.validate)((0, ue.arrayOfType)("FlowType"))
    }
  });
  et("Variance", {
    builder: ["kind"],
    fields: {
      kind: (0, ue.validate)((0, ue.assertOneOf)("minus", "plus"))
    }
  });
  et("VoidTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  et("EnumDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "body"],
    fields: {
      id: (0, ue.validateType)("Identifier"),
      body: (0, ue.validateType)("EnumBooleanBody", "EnumNumberBody", "EnumStringBody", "EnumSymbolBody")
    }
  });
  et("EnumBooleanBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: (0, ue.validate)((0, ue.assertValueType)("boolean")),
      members: (0, ue.validateArrayOfType)("EnumBooleanMember"),
      hasUnknownMembers: (0, ue.validate)((0, ue.assertValueType)("boolean"))
    }
  });
  et("EnumNumberBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: (0, ue.validate)((0, ue.assertValueType)("boolean")),
      members: (0, ue.validateArrayOfType)("EnumNumberMember"),
      hasUnknownMembers: (0, ue.validate)((0, ue.assertValueType)("boolean"))
    }
  });
  et("EnumStringBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: (0, ue.validate)((0, ue.assertValueType)("boolean")),
      members: (0, ue.validateArrayOfType)("EnumStringMember", "EnumDefaultedMember"),
      hasUnknownMembers: (0, ue.validate)((0, ue.assertValueType)("boolean"))
    }
  });
  et("EnumSymbolBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      members: (0, ue.validateArrayOfType)("EnumDefaultedMember"),
      hasUnknownMembers: (0, ue.validate)((0, ue.assertValueType)("boolean"))
    }
  });
  et("EnumBooleanMember", {
    aliases: ["EnumMember"],
    builder: ["id"],
    visitor: ["id", "init"],
    fields: {
      id: (0, ue.validateType)("Identifier"),
      init: (0, ue.validateType)("BooleanLiteral")
    }
  });
  et("EnumNumberMember", {
    aliases: ["EnumMember"],
    visitor: ["id", "init"],
    fields: {
      id: (0, ue.validateType)("Identifier"),
      init: (0, ue.validateType)("NumericLiteral")
    }
  });
  et("EnumStringMember", {
    aliases: ["EnumMember"],
    visitor: ["id", "init"],
    fields: {
      id: (0, ue.validateType)("Identifier"),
      init: (0, ue.validateType)("StringLiteral")
    }
  });
  et("EnumDefaultedMember", {
    aliases: ["EnumMember"],
    visitor: ["id"],
    fields: {
      id: (0, ue.validateType)("Identifier")
    }
  });
  et("IndexedAccessType", {
    visitor: ["objectType", "indexType"],
    aliases: ["FlowType"],
    fields: {
      objectType: (0, ue.validateType)("FlowType"),
      indexType: (0, ue.validateType)("FlowType")
    }
  });
  et("OptionalIndexedAccessType", {
    visitor: ["objectType", "indexType"],
    aliases: ["FlowType"],
    fields: {
      objectType: (0, ue.validateType)("FlowType"),
      indexType: (0, ue.validateType)("FlowType"),
      optional: (0, ue.validate)((0, ue.assertValueType)("boolean"))
    }
  });
});

// ../node_modules/@babel/types/lib/definitions/jsx.js
var K8 = b(() => {
  "use strict";
  var pi = Io(), fs = (0, pi.defineAliasedType)("JSX");
  fs("JSXAttribute", {
    visitor: ["name", "value"],
    aliases: ["Immutable"],
    fields: {
      name: {
        validate: (0, pi.assertNodeType)("JSXIdentifier", "JSXNamespacedName")
      },
      value: {
        optional: !0,
        validate: (0, pi.assertNodeType)("JSXElement", "JSXFragment", "StringLiteral", "JSXExpressionContainer")
      }
    }
  });
  fs("JSXClosingElement", {
    visitor: ["name"],
    aliases: ["Immutable"],
    fields: {
      name: {
        validate: (0, pi.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
      }
    }
  });
  fs("JSXElement", {
    builder: ["openingElement", "closingElement", "children", "selfClosing"],
    visitor: ["openingElement", "children", "closingElement"],
    aliases: ["Immutable", "Expression"],
    fields: Object.assign({
      openingElement: {
        validate: (0, pi.assertNodeType)("JSXOpeningElement")
      },
      closingElement: {
        optional: !0,
        validate: (0, pi.assertNodeType)("JSXClosingElement")
      },
      children: (0, pi.validateArrayOfType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")
    }, {
      selfClosing: {
        validate: (0, pi.assertValueType)("boolean"),
        optional: !0
      }
    })
  });
  fs("JSXEmptyExpression", {});
  fs("JSXExpressionContainer", {
    visitor: ["expression"],
    aliases: ["Immutable"],
    fields: {
      expression: {
        validate: (0, pi.assertNodeType)("Expression", "JSXEmptyExpression")
      }
    }
  });
  fs("JSXSpreadChild", {
    visitor: ["expression"],
    aliases: ["Immutable"],
    fields: {
      expression: {
        validate: (0, pi.assertNodeType)("Expression")
      }
    }
  });
  fs("JSXIdentifier", {
    builder: ["name"],
    fields: {
      name: {
        validate: (0, pi.assertValueType)("string")
      }
    }
  });
  fs("JSXMemberExpression", {
    visitor: ["object", "property"],
    fields: {
      object: {
        validate: (0, pi.assertNodeType)("JSXMemberExpression", "JSXIdentifier")
      },
      property: {
        validate: (0, pi.assertNodeType)("JSXIdentifier")
      }
    }
  });
  fs("JSXNamespacedName", {
    visitor: ["namespace", "name"],
    fields: {
      namespace: {
        validate: (0, pi.assertNodeType)("JSXIdentifier")
      },
      name: {
        validate: (0, pi.assertNodeType)("JSXIdentifier")
      }
    }
  });
  fs("JSXOpeningElement", {
    builder: ["name", "attributes", "selfClosing"],
    visitor: ["name", "typeParameters", "typeArguments", "attributes"],
    aliases: ["Immutable"],
    fields: Object.assign({
      name: {
        validate: (0, pi.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
      },
      selfClosing: {
        default: !1
      },
      attributes: (0, pi.validateArrayOfType)("JSXAttribute", "JSXSpreadAttribute"),
      typeArguments: {
        validate: (0, pi.assertNodeType)("TypeParameterInstantiation"),
        optional: !0
      }
    }, {
      typeParameters: {
        validate: (0, pi.assertNodeType)("TSTypeParameterInstantiation"),
        optional: !0
      }
    })
  });
  fs("JSXSpreadAttribute", {
    visitor: ["argument"],
    fields: {
      argument: {
        validate: (0, pi.assertNodeType)("Expression")
      }
    }
  });
  fs("JSXText", {
    aliases: ["Immutable"],
    builder: ["value"],
    fields: {
      value: {
        validate: (0, pi.assertValueType)("string")
      }
    }
  });
  fs("JSXFragment", {
    builder: ["openingFragment", "closingFragment", "children"],
    visitor: ["openingFragment", "children", "closingFragment"],
    aliases: ["Immutable", "Expression"],
    fields: {
      openingFragment: {
        validate: (0, pi.assertNodeType)("JSXOpeningFragment")
      },
      closingFragment: {
        validate: (0, pi.assertNodeType)("JSXClosingFragment")
      },
      children: (0, pi.validateArrayOfType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")
    }
  });
  fs("JSXOpeningFragment", {
    aliases: ["Immutable"]
  });
  fs("JSXClosingFragment", {
    aliases: ["Immutable"]
  });
});

// ../node_modules/@babel/types/lib/definitions/placeholders.js
var Qx = b((ol) => {
  "use strict";
  Object.defineProperty(ol, "__esModule", {
    value: !0
  });
  ol.PLACEHOLDERS_FLIPPED_ALIAS = ol.PLACEHOLDERS_ALIAS = ol.PLACEHOLDERS = void 0;
  var VSe = Io(), KSe = ol.PLACEHOLDERS = ["Identifier", "StringLiteral", "Expression", "Statement", "Declaration", "BlockStatement", "Class\
Body", "Pattern"], Jx = ol.PLACEHOLDERS_ALIAS = {
    Declaration: ["Statement"],
    Pattern: ["PatternLike", "LVal"]
  };
  for (let e of KSe) {
    let t = VSe.ALIAS_KEYS[e];
    t != null && t.length && (Jx[e] = t);
  }
  var Yx = ol.PLACEHOLDERS_FLIPPED_ALIAS = {};
  Object.keys(Jx).forEach((e) => {
    Jx[e].forEach((t) => {
      hasOwnProperty.call(Yx, t) || (Yx[t] = []), Yx[t].push(e);
    });
  });
});

// ../node_modules/@babel/types/lib/definitions/misc.js
var H8 = b(() => {
  "use strict";
  var u_ = Io(), HSe = Qx(), zSe = ud(), Zx = (0, u_.defineAliasedType)("Miscellaneous");
  Zx("Noop", {
    visitor: []
  });
  Zx("Placeholder", {
    visitor: [],
    builder: ["expectedNode", "name"],
    fields: Object.assign({
      name: {
        validate: (0, u_.assertNodeType)("Identifier")
      },
      expectedNode: {
        validate: (0, u_.assertOneOf)(...HSe.PLACEHOLDERS)
      }
    }, (0, zSe.patternLikeCommon)())
  });
  Zx("V8IntrinsicIdentifier", {
    builder: ["name"],
    fields: {
      name: {
        validate: (0, u_.assertValueType)("string")
      }
    }
  });
});

// ../node_modules/@babel/types/lib/definitions/experimental.js
var z8 = b(() => {
  "use strict";
  var ri = Io();
  (0, ri.default)("ArgumentPlaceholder", {});
  (0, ri.default)("BindExpression", {
    visitor: ["object", "callee"],
    aliases: ["Expression"],
    fields: process.env.BABEL_TYPES_8_BREAKING ? {
      object: {
        validate: (0, ri.assertNodeType)("Expression")
      },
      callee: {
        validate: (0, ri.assertNodeType)("Expression")
      }
    } : {
      object: {
        validate: Object.assign(() => {
        }, {
          oneOfNodeTypes: ["Expression"]
        })
      },
      callee: {
        validate: Object.assign(() => {
        }, {
          oneOfNodeTypes: ["Expression"]
        })
      }
    }
  });
  (0, ri.default)("Decorator", {
    visitor: ["expression"],
    fields: {
      expression: {
        validate: (0, ri.assertNodeType)("Expression")
      }
    }
  });
  (0, ri.default)("DoExpression", {
    visitor: ["body"],
    builder: ["body", "async"],
    aliases: ["Expression"],
    fields: {
      body: {
        validate: (0, ri.assertNodeType)("BlockStatement")
      },
      async: {
        validate: (0, ri.assertValueType)("boolean"),
        default: !1
      }
    }
  });
  (0, ri.default)("ExportDefaultSpecifier", {
    visitor: ["exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      exported: {
        validate: (0, ri.assertNodeType)("Identifier")
      }
    }
  });
  (0, ri.default)("RecordExpression", {
    visitor: ["properties"],
    aliases: ["Expression"],
    fields: {
      properties: (0, ri.validateArrayOfType)("ObjectProperty", "SpreadElement")
    }
  });
  (0, ri.default)("TupleExpression", {
    fields: {
      elements: {
        validate: (0, ri.arrayOfType)("Expression", "SpreadElement"),
        default: []
      }
    },
    visitor: ["elements"],
    aliases: ["Expression"]
  });
  (0, ri.default)("DecimalLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, ri.assertValueType)("string")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  (0, ri.default)("ModuleExpression", {
    visitor: ["body"],
    fields: {
      body: {
        validate: (0, ri.assertNodeType)("Program")
      }
    },
    aliases: ["Expression"]
  });
  (0, ri.default)("TopicReference", {
    aliases: ["Expression"]
  });
  (0, ri.default)("PipelineTopicExpression", {
    builder: ["expression"],
    visitor: ["expression"],
    fields: {
      expression: {
        validate: (0, ri.assertNodeType)("Expression")
      }
    },
    aliases: ["Expression"]
  });
  (0, ri.default)("PipelineBareFunction", {
    builder: ["callee"],
    visitor: ["callee"],
    fields: {
      callee: {
        validate: (0, ri.assertNodeType)("Expression")
      }
    },
    aliases: ["Expression"]
  });
  (0, ri.default)("PipelinePrimaryTopicReference", {
    aliases: ["Expression"]
  });
});

// ../node_modules/@babel/types/lib/definitions/typescript.js
var Z8 = b(() => {
  "use strict";
  var ve = Io(), G8 = ud(), GSe = Hf(), dt = (0, ve.defineAliasedType)("TypeScript"), Is = (0, ve.assertValueType)("boolean"), W8 = /* @__PURE__ */ s(
  () => ({
    returnType: {
      validate: (0, ve.assertNodeType)("TSTypeAnnotation", "Noop"),
      optional: !0
    },
    typeParameters: {
      validate: (0, ve.assertNodeType)("TSTypeParameterDeclaration", "Noop"),
      optional: !0
    }
  }), "tSFunctionTypeAnnotationCommon");
  dt("TSParameterProperty", {
    aliases: ["LVal"],
    visitor: ["parameter"],
    fields: {
      accessibility: {
        validate: (0, ve.assertOneOf)("public", "private", "protected"),
        optional: !0
      },
      readonly: {
        validate: (0, ve.assertValueType)("boolean"),
        optional: !0
      },
      parameter: {
        validate: (0, ve.assertNodeType)("Identifier", "AssignmentPattern")
      },
      override: {
        validate: (0, ve.assertValueType)("boolean"),
        optional: !0
      },
      decorators: {
        validate: (0, ve.arrayOfType)("Decorator"),
        optional: !0
      }
    }
  });
  dt("TSDeclareFunction", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "params", "returnType"],
    fields: Object.assign({}, (0, G8.functionDeclarationCommon)(), W8())
  });
  dt("TSDeclareMethod", {
    visitor: ["decorators", "key", "typeParameters", "params", "returnType"],
    fields: Object.assign({}, (0, G8.classMethodOrDeclareMethodCommon)(), W8())
  });
  dt("TSQualifiedName", {
    aliases: ["TSEntityName"],
    visitor: ["left", "right"],
    fields: {
      left: (0, ve.validateType)("TSEntityName"),
      right: (0, ve.validateType)("Identifier")
    }
  });
  var l_ = /* @__PURE__ */ s(() => ({
    typeParameters: (0, ve.validateOptionalType)("TSTypeParameterDeclaration"),
    parameters: (0, ve.validateArrayOfType)("ArrayPattern", "Identifier", "ObjectPattern", "RestElement"),
    typeAnnotation: (0, ve.validateOptionalType)("TSTypeAnnotation")
  }), "signatureDeclarationCommon"), $8 = {
    aliases: ["TSTypeElement"],
    visitor: ["typeParameters", "parameters", "typeAnnotation"],
    fields: l_()
  };
  dt("TSCallSignatureDeclaration", $8);
  dt("TSConstructSignatureDeclaration", $8);
  var X8 = /* @__PURE__ */ s(() => ({
    key: (0, ve.validateType)("Expression"),
    computed: {
      default: !1
    },
    optional: (0, ve.validateOptional)(Is)
  }), "namedTypeElementCommon");
  dt("TSPropertySignature", {
    aliases: ["TSTypeElement"],
    visitor: ["key", "typeAnnotation"],
    fields: Object.assign({}, X8(), {
      readonly: (0, ve.validateOptional)(Is),
      typeAnnotation: (0, ve.validateOptionalType)("TSTypeAnnotation"),
      kind: {
        optional: !0,
        validate: (0, ve.assertOneOf)("get", "set")
      }
    })
  });
  dt("TSMethodSignature", {
    aliases: ["TSTypeElement"],
    visitor: ["key", "typeParameters", "parameters", "typeAnnotation"],
    fields: Object.assign({}, l_(), X8(), {
      kind: {
        validate: (0, ve.assertOneOf)("method", "get", "set")
      }
    })
  });
  dt("TSIndexSignature", {
    aliases: ["TSTypeElement"],
    visitor: ["parameters", "typeAnnotation"],
    fields: {
      readonly: (0, ve.validateOptional)(Is),
      static: (0, ve.validateOptional)(Is),
      parameters: (0, ve.validateArrayOfType)("Identifier"),
      typeAnnotation: (0, ve.validateOptionalType)("TSTypeAnnotation")
    }
  });
  var WSe = ["TSAnyKeyword", "TSBooleanKeyword", "TSBigIntKeyword", "TSIntrinsicKeyword", "TSNeverKeyword", "TSNullKeyword", "TSNumberKeywor\
d", "TSObjectKeyword", "TSStringKeyword", "TSSymbolKeyword", "TSUndefinedKeyword", "TSUnknownKeyword", "TSVoidKeyword"];
  for (let e of WSe)
    dt(e, {
      aliases: ["TSType", "TSBaseType"],
      visitor: [],
      fields: {}
    });
  dt("TSThisType", {
    aliases: ["TSType", "TSBaseType"],
    visitor: [],
    fields: {}
  });
  var Y8 = {
    aliases: ["TSType"],
    visitor: ["typeParameters", "parameters", "typeAnnotation"]
  };
  dt("TSFunctionType", Object.assign({}, Y8, {
    fields: l_()
  }));
  dt("TSConstructorType", Object.assign({}, Y8, {
    fields: Object.assign({}, l_(), {
      abstract: (0, ve.validateOptional)(Is)
    })
  }));
  dt("TSTypeReference", {
    aliases: ["TSType"],
    visitor: ["typeName", "typeParameters"],
    fields: {
      typeName: (0, ve.validateType)("TSEntityName"),
      typeParameters: (0, ve.validateOptionalType)("TSTypeParameterInstantiation")
    }
  });
  dt("TSTypePredicate", {
    aliases: ["TSType"],
    visitor: ["parameterName", "typeAnnotation"],
    builder: ["parameterName", "typeAnnotation", "asserts"],
    fields: {
      parameterName: (0, ve.validateType)("Identifier", "TSThisType"),
      typeAnnotation: (0, ve.validateOptionalType)("TSTypeAnnotation"),
      asserts: (0, ve.validateOptional)(Is)
    }
  });
  dt("TSTypeQuery", {
    aliases: ["TSType"],
    visitor: ["exprName", "typeParameters"],
    fields: {
      exprName: (0, ve.validateType)("TSEntityName", "TSImportType"),
      typeParameters: (0, ve.validateOptionalType)("TSTypeParameterInstantiation")
    }
  });
  dt("TSTypeLiteral", {
    aliases: ["TSType"],
    visitor: ["members"],
    fields: {
      members: (0, ve.validateArrayOfType)("TSTypeElement")
    }
  });
  dt("TSArrayType", {
    aliases: ["TSType"],
    visitor: ["elementType"],
    fields: {
      elementType: (0, ve.validateType)("TSType")
    }
  });
  dt("TSTupleType", {
    aliases: ["TSType"],
    visitor: ["elementTypes"],
    fields: {
      elementTypes: (0, ve.validateArrayOfType)("TSType", "TSNamedTupleMember")
    }
  });
  dt("TSOptionalType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, ve.validateType)("TSType")
    }
  });
  dt("TSRestType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, ve.validateType)("TSType")
    }
  });
  dt("TSNamedTupleMember", {
    visitor: ["label", "elementType"],
    builder: ["label", "elementType", "optional"],
    fields: {
      label: (0, ve.validateType)("Identifier"),
      optional: {
        validate: Is,
        default: !1
      },
      elementType: (0, ve.validateType)("TSType")
    }
  });
  var J8 = {
    aliases: ["TSType"],
    visitor: ["types"],
    fields: {
      types: (0, ve.validateArrayOfType)("TSType")
    }
  };
  dt("TSUnionType", J8);
  dt("TSIntersectionType", J8);
  dt("TSConditionalType", {
    aliases: ["TSType"],
    visitor: ["checkType", "extendsType", "trueType", "falseType"],
    fields: {
      checkType: (0, ve.validateType)("TSType"),
      extendsType: (0, ve.validateType)("TSType"),
      trueType: (0, ve.validateType)("TSType"),
      falseType: (0, ve.validateType)("TSType")
    }
  });
  dt("TSInferType", {
    aliases: ["TSType"],
    visitor: ["typeParameter"],
    fields: {
      typeParameter: (0, ve.validateType)("TSTypeParameter")
    }
  });
  dt("TSParenthesizedType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, ve.validateType)("TSType")
    }
  });
  dt("TSTypeOperator", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      operator: (0, ve.validate)((0, ve.assertValueType)("string")),
      typeAnnotation: (0, ve.validateType)("TSType")
    }
  });
  dt("TSIndexedAccessType", {
    aliases: ["TSType"],
    visitor: ["objectType", "indexType"],
    fields: {
      objectType: (0, ve.validateType)("TSType"),
      indexType: (0, ve.validateType)("TSType")
    }
  });
  dt("TSMappedType", {
    aliases: ["TSType"],
    visitor: ["typeParameter", "nameType", "typeAnnotation"],
    builder: ["typeParameter", "typeAnnotation", "nameType"],
    fields: Object.assign({}, {
      typeParameter: (0, ve.validateType)("TSTypeParameter")
    }, {
      readonly: (0, ve.validateOptional)((0, ve.assertOneOf)(!0, !1, "+", "-")),
      optional: (0, ve.validateOptional)((0, ve.assertOneOf)(!0, !1, "+", "-")),
      typeAnnotation: (0, ve.validateOptionalType)("TSType"),
      nameType: (0, ve.validateOptionalType)("TSType")
    })
  });
  dt("TSTemplateLiteralType", {
    aliases: ["TSType", "TSBaseType"],
    visitor: ["quasis", "types"],
    fields: {
      quasis: (0, ve.validateArrayOfType)("TemplateElement"),
      types: {
        validate: (0, ve.chain)((0, ve.assertValueType)("array"), (0, ve.assertEach)((0, ve.assertNodeType)("TSType")), function(e, t, r) {
          if (e.quasis.length !== r.length + 1)
            throw new TypeError(`Number of ${e.type} quasis should be exactly one more than the number of types.
Expected ${r.length + 1} quasis but got ${e.quasis.length}`);
        })
      }
    }
  });
  dt("TSLiteralType", {
    aliases: ["TSType", "TSBaseType"],
    visitor: ["literal"],
    fields: {
      literal: {
        validate: function() {
          let e = (0, ve.assertNodeType)("NumericLiteral", "BigIntLiteral"), t = (0, ve.assertOneOf)("-"), r = (0, ve.assertNodeType)("Numer\
icLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral");
          function i(n, a, o) {
            (0, GSe.default)("UnaryExpression", o) ? (t(o, "operator", o.operator), e(o, "argument", o.argument)) : r(n, a, o);
          }
          return s(i, "validator"), i.oneOfNodeTypes = ["NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiter\
al", "UnaryExpression"], i;
        }()
      }
    }
  });
  dt("TSExpressionWithTypeArguments", {
    aliases: ["TSType"],
    visitor: ["expression", "typeParameters"],
    fields: {
      expression: (0, ve.validateType)("TSEntityName"),
      typeParameters: (0, ve.validateOptionalType)("TSTypeParameterInstantiation")
    }
  });
  dt("TSInterfaceDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "extends", "body"],
    fields: {
      declare: (0, ve.validateOptional)(Is),
      id: (0, ve.validateType)("Identifier"),
      typeParameters: (0, ve.validateOptionalType)("TSTypeParameterDeclaration"),
      extends: (0, ve.validateOptional)((0, ve.arrayOfType)("TSExpressionWithTypeArguments")),
      body: (0, ve.validateType)("TSInterfaceBody")
    }
  });
  dt("TSInterfaceBody", {
    visitor: ["body"],
    fields: {
      body: (0, ve.validateArrayOfType)("TSTypeElement")
    }
  });
  dt("TSTypeAliasDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "typeAnnotation"],
    fields: {
      declare: (0, ve.validateOptional)(Is),
      id: (0, ve.validateType)("Identifier"),
      typeParameters: (0, ve.validateOptionalType)("TSTypeParameterDeclaration"),
      typeAnnotation: (0, ve.validateType)("TSType")
    }
  });
  dt("TSInstantiationExpression", {
    aliases: ["Expression"],
    visitor: ["expression", "typeParameters"],
    fields: {
      expression: (0, ve.validateType)("Expression"),
      typeParameters: (0, ve.validateOptionalType)("TSTypeParameterInstantiation")
    }
  });
  var Q8 = {
    aliases: ["Expression", "LVal", "PatternLike"],
    visitor: ["expression", "typeAnnotation"],
    fields: {
      expression: (0, ve.validateType)("Expression"),
      typeAnnotation: (0, ve.validateType)("TSType")
    }
  };
  dt("TSAsExpression", Q8);
  dt("TSSatisfiesExpression", Q8);
  dt("TSTypeAssertion", {
    aliases: ["Expression", "LVal", "PatternLike"],
    visitor: ["typeAnnotation", "expression"],
    fields: {
      typeAnnotation: (0, ve.validateType)("TSType"),
      expression: (0, ve.validateType)("Expression")
    }
  });
  dt("TSEnumBody", {
    visitor: ["members"],
    fields: {
      members: (0, ve.validateArrayOfType)("TSEnumMember")
    }
  });
  dt("TSEnumDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "members"],
    fields: {
      declare: (0, ve.validateOptional)(Is),
      const: (0, ve.validateOptional)(Is),
      id: (0, ve.validateType)("Identifier"),
      members: (0, ve.validateArrayOfType)("TSEnumMember"),
      initializer: (0, ve.validateOptionalType)("Expression"),
      body: (0, ve.validateOptionalType)("TSEnumBody")
    }
  });
  dt("TSEnumMember", {
    visitor: ["id", "initializer"],
    fields: {
      id: (0, ve.validateType)("Identifier", "StringLiteral"),
      initializer: (0, ve.validateOptionalType)("Expression")
    }
  });
  dt("TSModuleDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "body"],
    fields: Object.assign({
      kind: {
        validate: (0, ve.assertOneOf)("global", "module", "namespace")
      },
      declare: (0, ve.validateOptional)(Is)
    }, {
      global: (0, ve.validateOptional)(Is)
    }, {
      id: (0, ve.validateType)("Identifier", "StringLiteral"),
      body: (0, ve.validateType)("TSModuleBlock", "TSModuleDeclaration")
    })
  });
  dt("TSModuleBlock", {
    aliases: ["Scopable", "Block", "BlockParent", "FunctionParent"],
    visitor: ["body"],
    fields: {
      body: (0, ve.validateArrayOfType)("Statement")
    }
  });
  dt("TSImportType", {
    aliases: ["TSType"],
    builder: ["argument", "qualifier", "typeParameters"],
    visitor: ["argument", "options", "qualifier", "typeParameters"],
    fields: {
      argument: (0, ve.validateType)("StringLiteral"),
      qualifier: (0, ve.validateOptionalType)("TSEntityName"),
      typeParameters: (0, ve.validateOptionalType)("TSTypeParameterInstantiation"),
      options: {
        validate: (0, ve.assertNodeType)("Expression"),
        optional: !0
      }
    }
  });
  dt("TSImportEqualsDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "moduleReference"],
    fields: Object.assign({}, {
      isExport: (0, ve.validate)(Is)
    }, {
      id: (0, ve.validateType)("Identifier"),
      moduleReference: (0, ve.validateType)("TSEntityName", "TSExternalModuleReference"),
      importKind: {
        validate: (0, ve.assertOneOf)("type", "value"),
        optional: !0
      }
    })
  });
  dt("TSExternalModuleReference", {
    visitor: ["expression"],
    fields: {
      expression: (0, ve.validateType)("StringLiteral")
    }
  });
  dt("TSNonNullExpression", {
    aliases: ["Expression", "LVal", "PatternLike"],
    visitor: ["expression"],
    fields: {
      expression: (0, ve.validateType)("Expression")
    }
  });
  dt("TSExportAssignment", {
    aliases: ["Statement"],
    visitor: ["expression"],
    fields: {
      expression: (0, ve.validateType)("Expression")
    }
  });
  dt("TSNamespaceExportDeclaration", {
    aliases: ["Statement"],
    visitor: ["id"],
    fields: {
      id: (0, ve.validateType)("Identifier")
    }
  });
  dt("TSTypeAnnotation", {
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: {
        validate: (0, ve.assertNodeType)("TSType")
      }
    }
  });
  dt("TSTypeParameterInstantiation", {
    visitor: ["params"],
    fields: {
      params: (0, ve.validateArrayOfType)("TSType")
    }
  });
  dt("TSTypeParameterDeclaration", {
    visitor: ["params"],
    fields: {
      params: (0, ve.validateArrayOfType)("TSTypeParameter")
    }
  });
  dt("TSTypeParameter", {
    builder: ["constraint", "default", "name"],
    visitor: ["constraint", "default"],
    fields: {
      name: {
        validate: (0, ve.assertValueType)("string")
      },
      in: {
        validate: (0, ve.assertValueType)("boolean"),
        optional: !0
      },
      out: {
        validate: (0, ve.assertValueType)("boolean"),
        optional: !0
      },
      const: {
        validate: (0, ve.assertValueType)("boolean"),
        optional: !0
      },
      constraint: {
        validate: (0, ve.assertNodeType)("TSType"),
        optional: !0
      },
      default: {
        validate: (0, ve.assertNodeType)("TSType"),
        optional: !0
      }
    }
  });
});

// ../node_modules/@babel/types/lib/definitions/deprecated-aliases.js
var e4 = b((c_) => {
  "use strict";
  Object.defineProperty(c_, "__esModule", {
    value: !0
  });
  c_.DEPRECATED_ALIASES = void 0;
  var wTt = c_.DEPRECATED_ALIASES = {
    ModuleDeclaration: "ImportOrExportDeclaration"
  };
});

// ../node_modules/@babel/types/lib/definitions/index.js
var Sa = b((ps) => {
  "use strict";
  Object.defineProperty(ps, "__esModule", {
    value: !0
  });
  Object.defineProperty(ps, "ALIAS_KEYS", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Rs.ALIAS_KEYS;
    }, "get")
  });
  Object.defineProperty(ps, "BUILDER_KEYS", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Rs.BUILDER_KEYS;
    }, "get")
  });
  Object.defineProperty(ps, "DEPRECATED_ALIASES", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return e1.DEPRECATED_ALIASES;
    }, "get")
  });
  Object.defineProperty(ps, "DEPRECATED_KEYS", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Rs.DEPRECATED_KEYS;
    }, "get")
  });
  Object.defineProperty(ps, "FLIPPED_ALIAS_KEYS", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Rs.FLIPPED_ALIAS_KEYS;
    }, "get")
  });
  Object.defineProperty(ps, "NODE_FIELDS", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Rs.NODE_FIELDS;
    }, "get")
  });
  Object.defineProperty(ps, "NODE_PARENT_VALIDATIONS", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Rs.NODE_PARENT_VALIDATIONS;
    }, "get")
  });
  Object.defineProperty(ps, "PLACEHOLDERS", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return t1.PLACEHOLDERS;
    }, "get")
  });
  Object.defineProperty(ps, "PLACEHOLDERS_ALIAS", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return t1.PLACEHOLDERS_ALIAS;
    }, "get")
  });
  Object.defineProperty(ps, "PLACEHOLDERS_FLIPPED_ALIAS", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return t1.PLACEHOLDERS_FLIPPED_ALIAS;
    }, "get")
  });
  ps.TYPES = void 0;
  Object.defineProperty(ps, "VISITOR_KEYS", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Rs.VISITOR_KEYS;
    }, "get")
  });
  ud();
  V8();
  K8();
  H8();
  z8();
  Z8();
  var Rs = Io(), t1 = Qx(), e1 = e4();
  Object.keys(e1.DEPRECATED_ALIASES).forEach((e) => {
    Rs.FLIPPED_ALIAS_KEYS[e] = Rs.FLIPPED_ALIAS_KEYS[e1.DEPRECATED_ALIASES[e]];
  });
  for (let {
    types: e,
    set: t
  } of Rs.allExpandedTypes)
    for (let r of e) {
      let i = Rs.FLIPPED_ALIAS_KEYS[r];
      i ? i.forEach(t.add, t) : t.add(r);
    }
  var kTt = ps.TYPES = [].concat(Object.keys(Rs.VISITOR_KEYS), Object.keys(Rs.FLIPPED_ALIAS_KEYS), Object.keys(Rs.DEPRECATED_KEYS));
});

// ../node_modules/@babel/types/lib/validators/validate.js
var a_ = b((Xf) => {
  "use strict";
  Object.defineProperty(Xf, "__esModule", {
    value: !0
  });
  Xf.default = $Se;
  Xf.validateChild = r4;
  Xf.validateField = t4;
  Xf.validateInternal = XSe;
  var ld = Sa();
  function $Se(e, t, r) {
    if (!e) return;
    let i = ld.NODE_FIELDS[e.type];
    if (!i) return;
    let n = i[t];
    t4(e, t, r, n), r4(e, t, r);
  }
  s($Se, "validate");
  function XSe(e, t, r, i, n) {
    if (e != null && e.validate && !(e.optional && i == null) && (e.validate(t, r, i), n)) {
      var a;
      let o = i.type;
      if (o == null) return;
      (a = ld.NODE_PARENT_VALIDATIONS[o]) == null || a.call(ld.NODE_PARENT_VALIDATIONS, t, r, i);
    }
  }
  s(XSe, "validateInternal");
  function t4(e, t, r, i) {
    i != null && i.validate && (i.optional && r == null || i.validate(e, t, r));
  }
  s(t4, "validateField");
  function r4(e, t, r) {
    var i;
    let n = r?.type;
    n != null && ((i = ld.NODE_PARENT_VALIDATIONS[n]) == null || i.call(ld.NODE_PARENT_VALIDATIONS, e, t, r));
  }
  s(r4, "validateChild");
});

// ../node_modules/@babel/types/lib/builders/generated/lowercase.js
var r1 = b((I) => {
  "use strict";
  Object.defineProperty(I, "__esModule", {
    value: !0
  });
  I.anyTypeAnnotation = wTe;
  I.argumentPlaceholder = nAe;
  I.arrayExpression = QSe;
  I.arrayPattern = W0e;
  I.arrayTypeAnnotation = OTe;
  I.arrowFunctionExpression = $0e;
  I.assignmentExpression = ZSe;
  I.assignmentPattern = G0e;
  I.awaitExpression = yTe;
  I.bigIntLiteral = _Te;
  I.binaryExpression = e0e;
  I.bindExpression = sAe;
  I.blockStatement = n0e;
  I.booleanLiteral = A0e;
  I.booleanLiteralTypeAnnotation = ITe;
  I.booleanTypeAnnotation = kTe;
  I.breakStatement = s0e;
  I.callExpression = a0e;
  I.catchClause = o0e;
  I.classAccessorProperty = ETe;
  I.classBody = X0e;
  I.classDeclaration = J0e;
  I.classExpression = Y0e;
  I.classImplements = NTe;
  I.classMethod = lTe;
  I.classPrivateMethod = xTe;
  I.classPrivateProperty = ATe;
  I.classProperty = TTe;
  I.conditionalExpression = u0e;
  I.continueStatement = l0e;
  I.debuggerStatement = c0e;
  I.decimalLiteral = fAe;
  I.declareClass = LTe;
  I.declareExportAllDeclaration = HTe;
  I.declareExportDeclaration = KTe;
  I.declareFunction = FTe;
  I.declareInterface = MTe;
  I.declareModule = BTe;
  I.declareModuleExports = qTe;
  I.declareOpaqueType = jTe;
  I.declareTypeAlias = UTe;
  I.declareVariable = VTe;
  I.declaredPredicate = zTe;
  I.decorator = aAe;
  I.directive = r0e;
  I.directiveLiteral = i0e;
  I.doExpression = oAe;
  I.doWhileStatement = f0e;
  I.emptyStatement = p0e;
  I.emptyTypeAnnotation = rEe;
  I.enumBooleanBody = OEe;
  I.enumBooleanMember = NEe;
  I.enumDeclaration = wEe;
  I.enumDefaultedMember = MEe;
  I.enumNumberBody = kEe;
  I.enumNumberMember = LEe;
  I.enumStringBody = IEe;
  I.enumStringMember = FEe;
  I.enumSymbolBody = REe;
  I.existsTypeAnnotation = GTe;
  I.exportAllDeclaration = Q0e;
  I.exportDefaultDeclaration = Z0e;
  I.exportDefaultSpecifier = uAe;
  I.exportNamedDeclaration = eTe;
  I.exportNamespaceSpecifier = bTe;
  I.exportSpecifier = tTe;
  I.expressionStatement = h0e;
  I.file = d0e;
  I.forInStatement = m0e;
  I.forOfStatement = rTe;
  I.forStatement = y0e;
  I.functionDeclaration = g0e;
  I.functionExpression = _0e;
  I.functionTypeAnnotation = WTe;
  I.functionTypeParam = $Te;
  I.genericTypeAnnotation = XTe;
  I.identifier = b0e;
  I.ifStatement = v0e;
  I.import = gTe;
  I.importAttribute = DTe;
  I.importDeclaration = iTe;
  I.importDefaultSpecifier = nTe;
  I.importExpression = oTe;
  I.importNamespaceSpecifier = sTe;
  I.importSpecifier = aTe;
  I.indexedAccessType = BEe;
  I.inferredPredicate = YTe;
  I.interfaceDeclaration = QTe;
  I.interfaceExtends = JTe;
  I.interfaceTypeAnnotation = ZTe;
  I.interpreterDirective = t0e;
  I.intersectionTypeAnnotation = eEe;
  I.jSXAttribute = I.jsxAttribute = UEe;
  I.jSXClosingElement = I.jsxClosingElement = jEe;
  I.jSXClosingFragment = I.jsxClosingFragment = eAe;
  I.jSXElement = I.jsxElement = VEe;
  I.jSXEmptyExpression = I.jsxEmptyExpression = KEe;
  I.jSXExpressionContainer = I.jsxExpressionContainer = HEe;
  I.jSXFragment = I.jsxFragment = QEe;
  I.jSXIdentifier = I.jsxIdentifier = GEe;
  I.jSXMemberExpression = I.jsxMemberExpression = WEe;
  I.jSXNamespacedName = I.jsxNamespacedName = $Ee;
  I.jSXOpeningElement = I.jsxOpeningElement = XEe;
  I.jSXOpeningFragment = I.jsxOpeningFragment = ZEe;
  I.jSXSpreadAttribute = I.jsxSpreadAttribute = YEe;
  I.jSXSpreadChild = I.jsxSpreadChild = zEe;
  I.jSXText = I.jsxText = JEe;
  I.labeledStatement = S0e;
  I.logicalExpression = x0e;
  I.memberExpression = C0e;
  I.metaProperty = uTe;
  I.mixedTypeAnnotation = tEe;
  I.moduleExpression = pAe;
  I.newExpression = P0e;
  I.noop = tAe;
  I.nullLiteral = E0e;
  I.nullLiteralTypeAnnotation = RTe;
  I.nullableTypeAnnotation = iEe;
  I.numberLiteral = Oxe;
  I.numberLiteralTypeAnnotation = nEe;
  I.numberTypeAnnotation = sEe;
  I.numericLiteral = i4;
  I.objectExpression = w0e;
  I.objectMethod = O0e;
  I.objectPattern = cTe;
  I.objectProperty = k0e;
  I.objectTypeAnnotation = aEe;
  I.objectTypeCallProperty = uEe;
  I.objectTypeIndexer = lEe;
  I.objectTypeInternalSlot = oEe;
  I.objectTypeProperty = cEe;
  I.objectTypeSpreadProperty = fEe;
  I.opaqueType = pEe;
  I.optionalCallExpression = STe;
  I.optionalIndexedAccessType = qEe;
  I.optionalMemberExpression = vTe;
  I.parenthesizedExpression = N0e;
  I.pipelineBareFunction = mAe;
  I.pipelinePrimaryTopicReference = yAe;
  I.pipelineTopicExpression = dAe;
  I.placeholder = rAe;
  I.privateName = CTe;
  I.program = D0e;
  I.qualifiedTypeIdentifier = hEe;
  I.recordExpression = lAe;
  I.regExpLiteral = n4;
  I.regexLiteral = kxe;
  I.restElement = s4;
  I.restProperty = Ixe;
  I.returnStatement = I0e;
  I.sequenceExpression = R0e;
  I.spreadElement = a4;
  I.spreadProperty = Rxe;
  I.staticBlock = PTe;
  I.stringLiteral = T0e;
  I.stringLiteralTypeAnnotation = dEe;
  I.stringTypeAnnotation = mEe;
  I.super = fTe;
  I.switchCase = L0e;
  I.switchStatement = F0e;
  I.symbolTypeAnnotation = yEe;
  I.taggedTemplateExpression = pTe;
  I.templateElement = hTe;
  I.templateLiteral = dTe;
  I.thisExpression = M0e;
  I.thisTypeAnnotation = gEe;
  I.throwStatement = B0e;
  I.topicReference = hAe;
  I.tryStatement = q0e;
  I.tSAnyKeyword = I.tsAnyKeyword = CAe;
  I.tSArrayType = I.tsArrayType = GAe;
  I.tSAsExpression = I.tsAsExpression = pxe;
  I.tSBigIntKeyword = I.tsBigIntKeyword = DAe;
  I.tSBooleanKeyword = I.tsBooleanKeyword = PAe;
  I.tSCallSignatureDeclaration = I.tsCallSignatureDeclaration = SAe;
  I.tSConditionalType = I.tsConditionalType = ZAe;
  I.tSConstructSignatureDeclaration = I.tsConstructSignatureDeclaration = TAe;
  I.tSConstructorType = I.tsConstructorType = jAe;
  I.tSDeclareFunction = I.tsDeclareFunction = _Ae;
  I.tSDeclareMethod = I.tsDeclareMethod = bAe;
  I.tSEnumBody = I.tsEnumBody = mxe;
  I.tSEnumDeclaration = I.tsEnumDeclaration = yxe;
  I.tSEnumMember = I.tsEnumMember = gxe;
  I.tSExportAssignment = I.tsExportAssignment = Axe;
  I.tSExpressionWithTypeArguments = I.tsExpressionWithTypeArguments = oxe;
  I.tSExternalModuleReference = I.tsExternalModuleReference = Txe;
  I.tSFunctionType = I.tsFunctionType = UAe;
  I.tSImportEqualsDeclaration = I.tsImportEqualsDeclaration = Sxe;
  I.tSImportType = I.tsImportType = vxe;
  I.tSIndexSignature = I.tsIndexSignature = xAe;
  I.tSIndexedAccessType = I.tsIndexedAccessType = ixe;
  I.tSInferType = I.tsInferType = exe;
  I.tSInstantiationExpression = I.tsInstantiationExpression = fxe;
  I.tSInterfaceBody = I.tsInterfaceBody = lxe;
  I.tSInterfaceDeclaration = I.tsInterfaceDeclaration = uxe;
  I.tSIntersectionType = I.tsIntersectionType = QAe;
  I.tSIntrinsicKeyword = I.tsIntrinsicKeyword = wAe;
  I.tSLiteralType = I.tsLiteralType = axe;
  I.tSMappedType = I.tsMappedType = nxe;
  I.tSMethodSignature = I.tsMethodSignature = AAe;
  I.tSModuleBlock = I.tsModuleBlock = bxe;
  I.tSModuleDeclaration = I.tsModuleDeclaration = _xe;
  I.tSNamedTupleMember = I.tsNamedTupleMember = YAe;
  I.tSNamespaceExportDeclaration = I.tsNamespaceExportDeclaration = xxe;
  I.tSNeverKeyword = I.tsNeverKeyword = OAe;
  I.tSNonNullExpression = I.tsNonNullExpression = Exe;
  I.tSNullKeyword = I.tsNullKeyword = kAe;
  I.tSNumberKeyword = I.tsNumberKeyword = IAe;
  I.tSObjectKeyword = I.tsObjectKeyword = RAe;
  I.tSOptionalType = I.tsOptionalType = $Ae;
  I.tSParameterProperty = I.tsParameterProperty = gAe;
  I.tSParenthesizedType = I.tsParenthesizedType = txe;
  I.tSPropertySignature = I.tsPropertySignature = EAe;
  I.tSQualifiedName = I.tsQualifiedName = vAe;
  I.tSRestType = I.tsRestType = XAe;
  I.tSSatisfiesExpression = I.tsSatisfiesExpression = hxe;
  I.tSStringKeyword = I.tsStringKeyword = NAe;
  I.tSSymbolKeyword = I.tsSymbolKeyword = LAe;
  I.tSTemplateLiteralType = I.tsTemplateLiteralType = sxe;
  I.tSThisType = I.tsThisType = qAe;
  I.tSTupleType = I.tsTupleType = WAe;
  I.tSTypeAliasDeclaration = I.tsTypeAliasDeclaration = cxe;
  I.tSTypeAnnotation = I.tsTypeAnnotation = Cxe;
  I.tSTypeAssertion = I.tsTypeAssertion = dxe;
  I.tSTypeLiteral = I.tsTypeLiteral = zAe;
  I.tSTypeOperator = I.tsTypeOperator = rxe;
  I.tSTypeParameter = I.tsTypeParameter = wxe;
  I.tSTypeParameterDeclaration = I.tsTypeParameterDeclaration = Dxe;
  I.tSTypeParameterInstantiation = I.tsTypeParameterInstantiation = Pxe;
  I.tSTypePredicate = I.tsTypePredicate = KAe;
  I.tSTypeQuery = I.tsTypeQuery = HAe;
  I.tSTypeReference = I.tsTypeReference = VAe;
  I.tSUndefinedKeyword = I.tsUndefinedKeyword = FAe;
  I.tSUnionType = I.tsUnionType = JAe;
  I.tSUnknownKeyword = I.tsUnknownKeyword = MAe;
  I.tSVoidKeyword = I.tsVoidKeyword = BAe;
  I.tupleExpression = cAe;
  I.tupleTypeAnnotation = _Ee;
  I.typeAlias = vEe;
  I.typeAnnotation = SEe;
  I.typeCastExpression = TEe;
  I.typeParameter = EEe;
  I.typeParameterDeclaration = AEe;
  I.typeParameterInstantiation = xEe;
  I.typeofTypeAnnotation = bEe;
  I.unaryExpression = U0e;
  I.unionTypeAnnotation = CEe;
  I.updateExpression = j0e;
  I.v8IntrinsicIdentifier = iAe;
  I.variableDeclaration = V0e;
  I.variableDeclarator = K0e;
  I.variance = PEe;
  I.voidTypeAnnotation = DEe;
  I.whileStatement = H0e;
  I.withStatement = z0e;
  I.yieldExpression = mTe;
  var YSe = a_(), f_ = ed(), JSe = Io(), {
    validateInternal: A
  } = YSe, {
    NODE_FIELDS: ee
  } = JSe;
  function QSe(e = []) {
    let t = {
      type: "ArrayExpression",
      elements: e
    }, r = ee.ArrayExpression;
    return A(r.elements, t, "elements", e, 1), t;
  }
  s(QSe, "arrayExpression");
  function ZSe(e, t, r) {
    let i = {
      type: "AssignmentExpression",
      operator: e,
      left: t,
      right: r
    }, n = ee.AssignmentExpression;
    return A(n.operator, i, "operator", e), A(n.left, i, "left", t, 1), A(n.right, i, "right", r, 1), i;
  }
  s(ZSe, "assignmentExpression");
  function e0e(e, t, r) {
    let i = {
      type: "BinaryExpression",
      operator: e,
      left: t,
      right: r
    }, n = ee.BinaryExpression;
    return A(n.operator, i, "operator", e), A(n.left, i, "left", t, 1), A(n.right, i, "right", r, 1), i;
  }
  s(e0e, "binaryExpression");
  function t0e(e) {
    let t = {
      type: "InterpreterDirective",
      value: e
    }, r = ee.InterpreterDirective;
    return A(r.value, t, "value", e), t;
  }
  s(t0e, "interpreterDirective");
  function r0e(e) {
    let t = {
      type: "Directive",
      value: e
    }, r = ee.Directive;
    return A(r.value, t, "value", e, 1), t;
  }
  s(r0e, "directive");
  function i0e(e) {
    let t = {
      type: "DirectiveLiteral",
      value: e
    }, r = ee.DirectiveLiteral;
    return A(r.value, t, "value", e), t;
  }
  s(i0e, "directiveLiteral");
  function n0e(e, t = []) {
    let r = {
      type: "BlockStatement",
      body: e,
      directives: t
    }, i = ee.BlockStatement;
    return A(i.body, r, "body", e, 1), A(i.directives, r, "directives", t, 1), r;
  }
  s(n0e, "blockStatement");
  function s0e(e = null) {
    let t = {
      type: "BreakStatement",
      label: e
    }, r = ee.BreakStatement;
    return A(r.label, t, "label", e, 1), t;
  }
  s(s0e, "breakStatement");
  function a0e(e, t) {
    let r = {
      type: "CallExpression",
      callee: e,
      arguments: t
    }, i = ee.CallExpression;
    return A(i.callee, r, "callee", e, 1), A(i.arguments, r, "arguments", t, 1), r;
  }
  s(a0e, "callExpression");
  function o0e(e = null, t) {
    let r = {
      type: "CatchClause",
      param: e,
      body: t
    }, i = ee.CatchClause;
    return A(i.param, r, "param", e, 1), A(i.body, r, "body", t, 1), r;
  }
  s(o0e, "catchClause");
  function u0e(e, t, r) {
    let i = {
      type: "ConditionalExpression",
      test: e,
      consequent: t,
      alternate: r
    }, n = ee.ConditionalExpression;
    return A(n.test, i, "test", e, 1), A(n.consequent, i, "consequent", t, 1), A(n.alternate, i, "alternate", r, 1), i;
  }
  s(u0e, "conditionalExpression");
  function l0e(e = null) {
    let t = {
      type: "ContinueStatement",
      label: e
    }, r = ee.ContinueStatement;
    return A(r.label, t, "label", e, 1), t;
  }
  s(l0e, "continueStatement");
  function c0e() {
    return {
      type: "DebuggerStatement"
    };
  }
  s(c0e, "debuggerStatement");
  function f0e(e, t) {
    let r = {
      type: "DoWhileStatement",
      test: e,
      body: t
    }, i = ee.DoWhileStatement;
    return A(i.test, r, "test", e, 1), A(i.body, r, "body", t, 1), r;
  }
  s(f0e, "doWhileStatement");
  function p0e() {
    return {
      type: "EmptyStatement"
    };
  }
  s(p0e, "emptyStatement");
  function h0e(e) {
    let t = {
      type: "ExpressionStatement",
      expression: e
    }, r = ee.ExpressionStatement;
    return A(r.expression, t, "expression", e, 1), t;
  }
  s(h0e, "expressionStatement");
  function d0e(e, t = null, r = null) {
    let i = {
      type: "File",
      program: e,
      comments: t,
      tokens: r
    }, n = ee.File;
    return A(n.program, i, "program", e, 1), A(n.comments, i, "comments", t, 1), A(n.tokens, i, "tokens", r), i;
  }
  s(d0e, "file");
  function m0e(e, t, r) {
    let i = {
      type: "ForInStatement",
      left: e,
      right: t,
      body: r
    }, n = ee.ForInStatement;
    return A(n.left, i, "left", e, 1), A(n.right, i, "right", t, 1), A(n.body, i, "body", r, 1), i;
  }
  s(m0e, "forInStatement");
  function y0e(e = null, t = null, r = null, i) {
    let n = {
      type: "ForStatement",
      init: e,
      test: t,
      update: r,
      body: i
    }, a = ee.ForStatement;
    return A(a.init, n, "init", e, 1), A(a.test, n, "test", t, 1), A(a.update, n, "update", r, 1), A(a.body, n, "body", i, 1), n;
  }
  s(y0e, "forStatement");
  function g0e(e = null, t, r, i = !1, n = !1) {
    let a = {
      type: "FunctionDeclaration",
      id: e,
      params: t,
      body: r,
      generator: i,
      async: n
    }, o = ee.FunctionDeclaration;
    return A(o.id, a, "id", e, 1), A(o.params, a, "params", t, 1), A(o.body, a, "body", r, 1), A(o.generator, a, "generator", i), A(o.async,
    a, "async", n), a;
  }
  s(g0e, "functionDeclaration");
  function _0e(e = null, t, r, i = !1, n = !1) {
    let a = {
      type: "FunctionExpression",
      id: e,
      params: t,
      body: r,
      generator: i,
      async: n
    }, o = ee.FunctionExpression;
    return A(o.id, a, "id", e, 1), A(o.params, a, "params", t, 1), A(o.body, a, "body", r, 1), A(o.generator, a, "generator", i), A(o.async,
    a, "async", n), a;
  }
  s(_0e, "functionExpression");
  function b0e(e) {
    let t = {
      type: "Identifier",
      name: e
    }, r = ee.Identifier;
    return A(r.name, t, "name", e), t;
  }
  s(b0e, "identifier");
  function v0e(e, t, r = null) {
    let i = {
      type: "IfStatement",
      test: e,
      consequent: t,
      alternate: r
    }, n = ee.IfStatement;
    return A(n.test, i, "test", e, 1), A(n.consequent, i, "consequent", t, 1), A(n.alternate, i, "alternate", r, 1), i;
  }
  s(v0e, "ifStatement");
  function S0e(e, t) {
    let r = {
      type: "LabeledStatement",
      label: e,
      body: t
    }, i = ee.LabeledStatement;
    return A(i.label, r, "label", e, 1), A(i.body, r, "body", t, 1), r;
  }
  s(S0e, "labeledStatement");
  function T0e(e) {
    let t = {
      type: "StringLiteral",
      value: e
    }, r = ee.StringLiteral;
    return A(r.value, t, "value", e), t;
  }
  s(T0e, "stringLiteral");
  function i4(e) {
    let t = {
      type: "NumericLiteral",
      value: e
    }, r = ee.NumericLiteral;
    return A(r.value, t, "value", e), t;
  }
  s(i4, "numericLiteral");
  function E0e() {
    return {
      type: "NullLiteral"
    };
  }
  s(E0e, "nullLiteral");
  function A0e(e) {
    let t = {
      type: "BooleanLiteral",
      value: e
    }, r = ee.BooleanLiteral;
    return A(r.value, t, "value", e), t;
  }
  s(A0e, "booleanLiteral");
  function n4(e, t = "") {
    let r = {
      type: "RegExpLiteral",
      pattern: e,
      flags: t
    }, i = ee.RegExpLiteral;
    return A(i.pattern, r, "pattern", e), A(i.flags, r, "flags", t), r;
  }
  s(n4, "regExpLiteral");
  function x0e(e, t, r) {
    let i = {
      type: "LogicalExpression",
      operator: e,
      left: t,
      right: r
    }, n = ee.LogicalExpression;
    return A(n.operator, i, "operator", e), A(n.left, i, "left", t, 1), A(n.right, i, "right", r, 1), i;
  }
  s(x0e, "logicalExpression");
  function C0e(e, t, r = !1, i = null) {
    let n = {
      type: "MemberExpression",
      object: e,
      property: t,
      computed: r,
      optional: i
    }, a = ee.MemberExpression;
    return A(a.object, n, "object", e, 1), A(a.property, n, "property", t, 1), A(a.computed, n, "computed", r), A(a.optional, n, "optional",
    i), n;
  }
  s(C0e, "memberExpression");
  function P0e(e, t) {
    let r = {
      type: "NewExpression",
      callee: e,
      arguments: t
    }, i = ee.NewExpression;
    return A(i.callee, r, "callee", e, 1), A(i.arguments, r, "arguments", t, 1), r;
  }
  s(P0e, "newExpression");
  function D0e(e, t = [], r = "script", i = null) {
    let n = {
      type: "Program",
      body: e,
      directives: t,
      sourceType: r,
      interpreter: i
    }, a = ee.Program;
    return A(a.body, n, "body", e, 1), A(a.directives, n, "directives", t, 1), A(a.sourceType, n, "sourceType", r), A(a.interpreter, n, "int\
erpreter", i, 1), n;
  }
  s(D0e, "program");
  function w0e(e) {
    let t = {
      type: "ObjectExpression",
      properties: e
    }, r = ee.ObjectExpression;
    return A(r.properties, t, "properties", e, 1), t;
  }
  s(w0e, "objectExpression");
  function O0e(e = "method", t, r, i, n = !1, a = !1, o = !1) {
    let u = {
      type: "ObjectMethod",
      kind: e,
      key: t,
      params: r,
      body: i,
      computed: n,
      generator: a,
      async: o
    }, l = ee.ObjectMethod;
    return A(l.kind, u, "kind", e), A(l.key, u, "key", t, 1), A(l.params, u, "params", r, 1), A(l.body, u, "body", i, 1), A(l.computed, u, "\
computed", n), A(l.generator, u, "generator", a), A(l.async, u, "async", o), u;
  }
  s(O0e, "objectMethod");
  function k0e(e, t, r = !1, i = !1, n = null) {
    let a = {
      type: "ObjectProperty",
      key: e,
      value: t,
      computed: r,
      shorthand: i,
      decorators: n
    }, o = ee.ObjectProperty;
    return A(o.key, a, "key", e, 1), A(o.value, a, "value", t, 1), A(o.computed, a, "computed", r), A(o.shorthand, a, "shorthand", i), A(o.decorators,
    a, "decorators", n, 1), a;
  }
  s(k0e, "objectProperty");
  function s4(e) {
    let t = {
      type: "RestElement",
      argument: e
    }, r = ee.RestElement;
    return A(r.argument, t, "argument", e, 1), t;
  }
  s(s4, "restElement");
  function I0e(e = null) {
    let t = {
      type: "ReturnStatement",
      argument: e
    }, r = ee.ReturnStatement;
    return A(r.argument, t, "argument", e, 1), t;
  }
  s(I0e, "returnStatement");
  function R0e(e) {
    let t = {
      type: "SequenceExpression",
      expressions: e
    }, r = ee.SequenceExpression;
    return A(r.expressions, t, "expressions", e, 1), t;
  }
  s(R0e, "sequenceExpression");
  function N0e(e) {
    let t = {
      type: "ParenthesizedExpression",
      expression: e
    }, r = ee.ParenthesizedExpression;
    return A(r.expression, t, "expression", e, 1), t;
  }
  s(N0e, "parenthesizedExpression");
  function L0e(e = null, t) {
    let r = {
      type: "SwitchCase",
      test: e,
      consequent: t
    }, i = ee.SwitchCase;
    return A(i.test, r, "test", e, 1), A(i.consequent, r, "consequent", t, 1), r;
  }
  s(L0e, "switchCase");
  function F0e(e, t) {
    let r = {
      type: "SwitchStatement",
      discriminant: e,
      cases: t
    }, i = ee.SwitchStatement;
    return A(i.discriminant, r, "discriminant", e, 1), A(i.cases, r, "cases", t, 1), r;
  }
  s(F0e, "switchStatement");
  function M0e() {
    return {
      type: "ThisExpression"
    };
  }
  s(M0e, "thisExpression");
  function B0e(e) {
    let t = {
      type: "ThrowStatement",
      argument: e
    }, r = ee.ThrowStatement;
    return A(r.argument, t, "argument", e, 1), t;
  }
  s(B0e, "throwStatement");
  function q0e(e, t = null, r = null) {
    let i = {
      type: "TryStatement",
      block: e,
      handler: t,
      finalizer: r
    }, n = ee.TryStatement;
    return A(n.block, i, "block", e, 1), A(n.handler, i, "handler", t, 1), A(n.finalizer, i, "finalizer", r, 1), i;
  }
  s(q0e, "tryStatement");
  function U0e(e, t, r = !0) {
    let i = {
      type: "UnaryExpression",
      operator: e,
      argument: t,
      prefix: r
    }, n = ee.UnaryExpression;
    return A(n.operator, i, "operator", e), A(n.argument, i, "argument", t, 1), A(n.prefix, i, "prefix", r), i;
  }
  s(U0e, "unaryExpression");
  function j0e(e, t, r = !1) {
    let i = {
      type: "UpdateExpression",
      operator: e,
      argument: t,
      prefix: r
    }, n = ee.UpdateExpression;
    return A(n.operator, i, "operator", e), A(n.argument, i, "argument", t, 1), A(n.prefix, i, "prefix", r), i;
  }
  s(j0e, "updateExpression");
  function V0e(e, t) {
    let r = {
      type: "VariableDeclaration",
      kind: e,
      declarations: t
    }, i = ee.VariableDeclaration;
    return A(i.kind, r, "kind", e), A(i.declarations, r, "declarations", t, 1), r;
  }
  s(V0e, "variableDeclaration");
  function K0e(e, t = null) {
    let r = {
      type: "VariableDeclarator",
      id: e,
      init: t
    }, i = ee.VariableDeclarator;
    return A(i.id, r, "id", e, 1), A(i.init, r, "init", t, 1), r;
  }
  s(K0e, "variableDeclarator");
  function H0e(e, t) {
    let r = {
      type: "WhileStatement",
      test: e,
      body: t
    }, i = ee.WhileStatement;
    return A(i.test, r, "test", e, 1), A(i.body, r, "body", t, 1), r;
  }
  s(H0e, "whileStatement");
  function z0e(e, t) {
    let r = {
      type: "WithStatement",
      object: e,
      body: t
    }, i = ee.WithStatement;
    return A(i.object, r, "object", e, 1), A(i.body, r, "body", t, 1), r;
  }
  s(z0e, "withStatement");
  function G0e(e, t) {
    let r = {
      type: "AssignmentPattern",
      left: e,
      right: t
    }, i = ee.AssignmentPattern;
    return A(i.left, r, "left", e, 1), A(i.right, r, "right", t, 1), r;
  }
  s(G0e, "assignmentPattern");
  function W0e(e) {
    let t = {
      type: "ArrayPattern",
      elements: e
    }, r = ee.ArrayPattern;
    return A(r.elements, t, "elements", e, 1), t;
  }
  s(W0e, "arrayPattern");
  function $0e(e, t, r = !1) {
    let i = {
      type: "ArrowFunctionExpression",
      params: e,
      body: t,
      async: r,
      expression: null
    }, n = ee.ArrowFunctionExpression;
    return A(n.params, i, "params", e, 1), A(n.body, i, "body", t, 1), A(n.async, i, "async", r), i;
  }
  s($0e, "arrowFunctionExpression");
  function X0e(e) {
    let t = {
      type: "ClassBody",
      body: e
    }, r = ee.ClassBody;
    return A(r.body, t, "body", e, 1), t;
  }
  s(X0e, "classBody");
  function Y0e(e = null, t = null, r, i = null) {
    let n = {
      type: "ClassExpression",
      id: e,
      superClass: t,
      body: r,
      decorators: i
    }, a = ee.ClassExpression;
    return A(a.id, n, "id", e, 1), A(a.superClass, n, "superClass", t, 1), A(a.body, n, "body", r, 1), A(a.decorators, n, "decorators", i, 1),
    n;
  }
  s(Y0e, "classExpression");
  function J0e(e = null, t = null, r, i = null) {
    let n = {
      type: "ClassDeclaration",
      id: e,
      superClass: t,
      body: r,
      decorators: i
    }, a = ee.ClassDeclaration;
    return A(a.id, n, "id", e, 1), A(a.superClass, n, "superClass", t, 1), A(a.body, n, "body", r, 1), A(a.decorators, n, "decorators", i, 1),
    n;
  }
  s(J0e, "classDeclaration");
  function Q0e(e) {
    let t = {
      type: "ExportAllDeclaration",
      source: e
    }, r = ee.ExportAllDeclaration;
    return A(r.source, t, "source", e, 1), t;
  }
  s(Q0e, "exportAllDeclaration");
  function Z0e(e) {
    let t = {
      type: "ExportDefaultDeclaration",
      declaration: e
    }, r = ee.ExportDefaultDeclaration;
    return A(r.declaration, t, "declaration", e, 1), t;
  }
  s(Z0e, "exportDefaultDeclaration");
  function eTe(e = null, t = [], r = null) {
    let i = {
      type: "ExportNamedDeclaration",
      declaration: e,
      specifiers: t,
      source: r
    }, n = ee.ExportNamedDeclaration;
    return A(n.declaration, i, "declaration", e, 1), A(n.specifiers, i, "specifiers", t, 1), A(n.source, i, "source", r, 1), i;
  }
  s(eTe, "exportNamedDeclaration");
  function tTe(e, t) {
    let r = {
      type: "ExportSpecifier",
      local: e,
      exported: t
    }, i = ee.ExportSpecifier;
    return A(i.local, r, "local", e, 1), A(i.exported, r, "exported", t, 1), r;
  }
  s(tTe, "exportSpecifier");
  function rTe(e, t, r, i = !1) {
    let n = {
      type: "ForOfStatement",
      left: e,
      right: t,
      body: r,
      await: i
    }, a = ee.ForOfStatement;
    return A(a.left, n, "left", e, 1), A(a.right, n, "right", t, 1), A(a.body, n, "body", r, 1), A(a.await, n, "await", i), n;
  }
  s(rTe, "forOfStatement");
  function iTe(e, t) {
    let r = {
      type: "ImportDeclaration",
      specifiers: e,
      source: t
    }, i = ee.ImportDeclaration;
    return A(i.specifiers, r, "specifiers", e, 1), A(i.source, r, "source", t, 1), r;
  }
  s(iTe, "importDeclaration");
  function nTe(e) {
    let t = {
      type: "ImportDefaultSpecifier",
      local: e
    }, r = ee.ImportDefaultSpecifier;
    return A(r.local, t, "local", e, 1), t;
  }
  s(nTe, "importDefaultSpecifier");
  function sTe(e) {
    let t = {
      type: "ImportNamespaceSpecifier",
      local: e
    }, r = ee.ImportNamespaceSpecifier;
    return A(r.local, t, "local", e, 1), t;
  }
  s(sTe, "importNamespaceSpecifier");
  function aTe(e, t) {
    let r = {
      type: "ImportSpecifier",
      local: e,
      imported: t
    }, i = ee.ImportSpecifier;
    return A(i.local, r, "local", e, 1), A(i.imported, r, "imported", t, 1), r;
  }
  s(aTe, "importSpecifier");
  function oTe(e, t = null) {
    let r = {
      type: "ImportExpression",
      source: e,
      options: t
    }, i = ee.ImportExpression;
    return A(i.source, r, "source", e, 1), A(i.options, r, "options", t, 1), r;
  }
  s(oTe, "importExpression");
  function uTe(e, t) {
    let r = {
      type: "MetaProperty",
      meta: e,
      property: t
    }, i = ee.MetaProperty;
    return A(i.meta, r, "meta", e, 1), A(i.property, r, "property", t, 1), r;
  }
  s(uTe, "metaProperty");
  function lTe(e = "method", t, r, i, n = !1, a = !1, o = !1, u = !1) {
    let l = {
      type: "ClassMethod",
      kind: e,
      key: t,
      params: r,
      body: i,
      computed: n,
      static: a,
      generator: o,
      async: u
    }, c = ee.ClassMethod;
    return A(c.kind, l, "kind", e), A(c.key, l, "key", t, 1), A(c.params, l, "params", r, 1), A(c.body, l, "body", i, 1), A(c.computed, l, "\
computed", n), A(c.static, l, "static", a), A(c.generator, l, "generator", o), A(c.async, l, "async", u), l;
  }
  s(lTe, "classMethod");
  function cTe(e) {
    let t = {
      type: "ObjectPattern",
      properties: e
    }, r = ee.ObjectPattern;
    return A(r.properties, t, "properties", e, 1), t;
  }
  s(cTe, "objectPattern");
  function a4(e) {
    let t = {
      type: "SpreadElement",
      argument: e
    }, r = ee.SpreadElement;
    return A(r.argument, t, "argument", e, 1), t;
  }
  s(a4, "spreadElement");
  function fTe() {
    return {
      type: "Super"
    };
  }
  s(fTe, "_super");
  function pTe(e, t) {
    let r = {
      type: "TaggedTemplateExpression",
      tag: e,
      quasi: t
    }, i = ee.TaggedTemplateExpression;
    return A(i.tag, r, "tag", e, 1), A(i.quasi, r, "quasi", t, 1), r;
  }
  s(pTe, "taggedTemplateExpression");
  function hTe(e, t = !1) {
    let r = {
      type: "TemplateElement",
      value: e,
      tail: t
    }, i = ee.TemplateElement;
    return A(i.value, r, "value", e), A(i.tail, r, "tail", t), r;
  }
  s(hTe, "templateElement");
  function dTe(e, t) {
    let r = {
      type: "TemplateLiteral",
      quasis: e,
      expressions: t
    }, i = ee.TemplateLiteral;
    return A(i.quasis, r, "quasis", e, 1), A(i.expressions, r, "expressions", t, 1), r;
  }
  s(dTe, "templateLiteral");
  function mTe(e = null, t = !1) {
    let r = {
      type: "YieldExpression",
      argument: e,
      delegate: t
    }, i = ee.YieldExpression;
    return A(i.argument, r, "argument", e, 1), A(i.delegate, r, "delegate", t), r;
  }
  s(mTe, "yieldExpression");
  function yTe(e) {
    let t = {
      type: "AwaitExpression",
      argument: e
    }, r = ee.AwaitExpression;
    return A(r.argument, t, "argument", e, 1), t;
  }
  s(yTe, "awaitExpression");
  function gTe() {
    return {
      type: "Import"
    };
  }
  s(gTe, "_import");
  function _Te(e) {
    let t = {
      type: "BigIntLiteral",
      value: e
    }, r = ee.BigIntLiteral;
    return A(r.value, t, "value", e), t;
  }
  s(_Te, "bigIntLiteral");
  function bTe(e) {
    let t = {
      type: "ExportNamespaceSpecifier",
      exported: e
    }, r = ee.ExportNamespaceSpecifier;
    return A(r.exported, t, "exported", e, 1), t;
  }
  s(bTe, "exportNamespaceSpecifier");
  function vTe(e, t, r = !1, i) {
    let n = {
      type: "OptionalMemberExpression",
      object: e,
      property: t,
      computed: r,
      optional: i
    }, a = ee.OptionalMemberExpression;
    return A(a.object, n, "object", e, 1), A(a.property, n, "property", t, 1), A(a.computed, n, "computed", r), A(a.optional, n, "optional",
    i), n;
  }
  s(vTe, "optionalMemberExpression");
  function STe(e, t, r) {
    let i = {
      type: "OptionalCallExpression",
      callee: e,
      arguments: t,
      optional: r
    }, n = ee.OptionalCallExpression;
    return A(n.callee, i, "callee", e, 1), A(n.arguments, i, "arguments", t, 1), A(n.optional, i, "optional", r), i;
  }
  s(STe, "optionalCallExpression");
  function TTe(e, t = null, r = null, i = null, n = !1, a = !1) {
    let o = {
      type: "ClassProperty",
      key: e,
      value: t,
      typeAnnotation: r,
      decorators: i,
      computed: n,
      static: a
    }, u = ee.ClassProperty;
    return A(u.key, o, "key", e, 1), A(u.value, o, "value", t, 1), A(u.typeAnnotation, o, "typeAnnotation", r, 1), A(u.decorators, o, "decor\
ators", i, 1), A(u.computed, o, "computed", n), A(u.static, o, "static", a), o;
  }
  s(TTe, "classProperty");
  function ETe(e, t = null, r = null, i = null, n = !1, a = !1) {
    let o = {
      type: "ClassAccessorProperty",
      key: e,
      value: t,
      typeAnnotation: r,
      decorators: i,
      computed: n,
      static: a
    }, u = ee.ClassAccessorProperty;
    return A(u.key, o, "key", e, 1), A(u.value, o, "value", t, 1), A(u.typeAnnotation, o, "typeAnnotation", r, 1), A(u.decorators, o, "decor\
ators", i, 1), A(u.computed, o, "computed", n), A(u.static, o, "static", a), o;
  }
  s(ETe, "classAccessorProperty");
  function ATe(e, t = null, r = null, i = !1) {
    let n = {
      type: "ClassPrivateProperty",
      key: e,
      value: t,
      decorators: r,
      static: i
    }, a = ee.ClassPrivateProperty;
    return A(a.key, n, "key", e, 1), A(a.value, n, "value", t, 1), A(a.decorators, n, "decorators", r, 1), A(a.static, n, "static", i), n;
  }
  s(ATe, "classPrivateProperty");
  function xTe(e = "method", t, r, i, n = !1) {
    let a = {
      type: "ClassPrivateMethod",
      kind: e,
      key: t,
      params: r,
      body: i,
      static: n
    }, o = ee.ClassPrivateMethod;
    return A(o.kind, a, "kind", e), A(o.key, a, "key", t, 1), A(o.params, a, "params", r, 1), A(o.body, a, "body", i, 1), A(o.static, a, "st\
atic", n), a;
  }
  s(xTe, "classPrivateMethod");
  function CTe(e) {
    let t = {
      type: "PrivateName",
      id: e
    }, r = ee.PrivateName;
    return A(r.id, t, "id", e, 1), t;
  }
  s(CTe, "privateName");
  function PTe(e) {
    let t = {
      type: "StaticBlock",
      body: e
    }, r = ee.StaticBlock;
    return A(r.body, t, "body", e, 1), t;
  }
  s(PTe, "staticBlock");
  function DTe(e, t) {
    let r = {
      type: "ImportAttribute",
      key: e,
      value: t
    }, i = ee.ImportAttribute;
    return A(i.key, r, "key", e, 1), A(i.value, r, "value", t, 1), r;
  }
  s(DTe, "importAttribute");
  function wTe() {
    return {
      type: "AnyTypeAnnotation"
    };
  }
  s(wTe, "anyTypeAnnotation");
  function OTe(e) {
    let t = {
      type: "ArrayTypeAnnotation",
      elementType: e
    }, r = ee.ArrayTypeAnnotation;
    return A(r.elementType, t, "elementType", e, 1), t;
  }
  s(OTe, "arrayTypeAnnotation");
  function kTe() {
    return {
      type: "BooleanTypeAnnotation"
    };
  }
  s(kTe, "booleanTypeAnnotation");
  function ITe(e) {
    let t = {
      type: "BooleanLiteralTypeAnnotation",
      value: e
    }, r = ee.BooleanLiteralTypeAnnotation;
    return A(r.value, t, "value", e), t;
  }
  s(ITe, "booleanLiteralTypeAnnotation");
  function RTe() {
    return {
      type: "NullLiteralTypeAnnotation"
    };
  }
  s(RTe, "nullLiteralTypeAnnotation");
  function NTe(e, t = null) {
    let r = {
      type: "ClassImplements",
      id: e,
      typeParameters: t
    }, i = ee.ClassImplements;
    return A(i.id, r, "id", e, 1), A(i.typeParameters, r, "typeParameters", t, 1), r;
  }
  s(NTe, "classImplements");
  function LTe(e, t = null, r = null, i) {
    let n = {
      type: "DeclareClass",
      id: e,
      typeParameters: t,
      extends: r,
      body: i
    }, a = ee.DeclareClass;
    return A(a.id, n, "id", e, 1), A(a.typeParameters, n, "typeParameters", t, 1), A(a.extends, n, "extends", r, 1), A(a.body, n, "body", i,
    1), n;
  }
  s(LTe, "declareClass");
  function FTe(e) {
    let t = {
      type: "DeclareFunction",
      id: e
    }, r = ee.DeclareFunction;
    return A(r.id, t, "id", e, 1), t;
  }
  s(FTe, "declareFunction");
  function MTe(e, t = null, r = null, i) {
    let n = {
      type: "DeclareInterface",
      id: e,
      typeParameters: t,
      extends: r,
      body: i
    }, a = ee.DeclareInterface;
    return A(a.id, n, "id", e, 1), A(a.typeParameters, n, "typeParameters", t, 1), A(a.extends, n, "extends", r, 1), A(a.body, n, "body", i,
    1), n;
  }
  s(MTe, "declareInterface");
  function BTe(e, t, r = null) {
    let i = {
      type: "DeclareModule",
      id: e,
      body: t,
      kind: r
    }, n = ee.DeclareModule;
    return A(n.id, i, "id", e, 1), A(n.body, i, "body", t, 1), A(n.kind, i, "kind", r), i;
  }
  s(BTe, "declareModule");
  function qTe(e) {
    let t = {
      type: "DeclareModuleExports",
      typeAnnotation: e
    }, r = ee.DeclareModuleExports;
    return A(r.typeAnnotation, t, "typeAnnotation", e, 1), t;
  }
  s(qTe, "declareModuleExports");
  function UTe(e, t = null, r) {
    let i = {
      type: "DeclareTypeAlias",
      id: e,
      typeParameters: t,
      right: r
    }, n = ee.DeclareTypeAlias;
    return A(n.id, i, "id", e, 1), A(n.typeParameters, i, "typeParameters", t, 1), A(n.right, i, "right", r, 1), i;
  }
  s(UTe, "declareTypeAlias");
  function jTe(e, t = null, r = null) {
    let i = {
      type: "DeclareOpaqueType",
      id: e,
      typeParameters: t,
      supertype: r
    }, n = ee.DeclareOpaqueType;
    return A(n.id, i, "id", e, 1), A(n.typeParameters, i, "typeParameters", t, 1), A(n.supertype, i, "supertype", r, 1), i;
  }
  s(jTe, "declareOpaqueType");
  function VTe(e) {
    let t = {
      type: "DeclareVariable",
      id: e
    }, r = ee.DeclareVariable;
    return A(r.id, t, "id", e, 1), t;
  }
  s(VTe, "declareVariable");
  function KTe(e = null, t = null, r = null, i = null) {
    let n = {
      type: "DeclareExportDeclaration",
      declaration: e,
      specifiers: t,
      source: r,
      attributes: i
    }, a = ee.DeclareExportDeclaration;
    return A(a.declaration, n, "declaration", e, 1), A(a.specifiers, n, "specifiers", t, 1), A(a.source, n, "source", r, 1), A(a.attributes,
    n, "attributes", i, 1), n;
  }
  s(KTe, "declareExportDeclaration");
  function HTe(e, t = null) {
    let r = {
      type: "DeclareExportAllDeclaration",
      source: e,
      attributes: t
    }, i = ee.DeclareExportAllDeclaration;
    return A(i.source, r, "source", e, 1), A(i.attributes, r, "attributes", t, 1), r;
  }
  s(HTe, "declareExportAllDeclaration");
  function zTe(e) {
    let t = {
      type: "DeclaredPredicate",
      value: e
    }, r = ee.DeclaredPredicate;
    return A(r.value, t, "value", e, 1), t;
  }
  s(zTe, "declaredPredicate");
  function GTe() {
    return {
      type: "ExistsTypeAnnotation"
    };
  }
  s(GTe, "existsTypeAnnotation");
  function WTe(e = null, t, r = null, i) {
    let n = {
      type: "FunctionTypeAnnotation",
      typeParameters: e,
      params: t,
      rest: r,
      returnType: i
    }, a = ee.FunctionTypeAnnotation;
    return A(a.typeParameters, n, "typeParameters", e, 1), A(a.params, n, "params", t, 1), A(a.rest, n, "rest", r, 1), A(a.returnType, n, "r\
eturnType", i, 1), n;
  }
  s(WTe, "functionTypeAnnotation");
  function $Te(e = null, t) {
    let r = {
      type: "FunctionTypeParam",
      name: e,
      typeAnnotation: t
    }, i = ee.FunctionTypeParam;
    return A(i.name, r, "name", e, 1), A(i.typeAnnotation, r, "typeAnnotation", t, 1), r;
  }
  s($Te, "functionTypeParam");
  function XTe(e, t = null) {
    let r = {
      type: "GenericTypeAnnotation",
      id: e,
      typeParameters: t
    }, i = ee.GenericTypeAnnotation;
    return A(i.id, r, "id", e, 1), A(i.typeParameters, r, "typeParameters", t, 1), r;
  }
  s(XTe, "genericTypeAnnotation");
  function YTe() {
    return {
      type: "InferredPredicate"
    };
  }
  s(YTe, "inferredPredicate");
  function JTe(e, t = null) {
    let r = {
      type: "InterfaceExtends",
      id: e,
      typeParameters: t
    }, i = ee.InterfaceExtends;
    return A(i.id, r, "id", e, 1), A(i.typeParameters, r, "typeParameters", t, 1), r;
  }
  s(JTe, "interfaceExtends");
  function QTe(e, t = null, r = null, i) {
    let n = {
      type: "InterfaceDeclaration",
      id: e,
      typeParameters: t,
      extends: r,
      body: i
    }, a = ee.InterfaceDeclaration;
    return A(a.id, n, "id", e, 1), A(a.typeParameters, n, "typeParameters", t, 1), A(a.extends, n, "extends", r, 1), A(a.body, n, "body", i,
    1), n;
  }
  s(QTe, "interfaceDeclaration");
  function ZTe(e = null, t) {
    let r = {
      type: "InterfaceTypeAnnotation",
      extends: e,
      body: t
    }, i = ee.InterfaceTypeAnnotation;
    return A(i.extends, r, "extends", e, 1), A(i.body, r, "body", t, 1), r;
  }
  s(ZTe, "interfaceTypeAnnotation");
  function eEe(e) {
    let t = {
      type: "IntersectionTypeAnnotation",
      types: e
    }, r = ee.IntersectionTypeAnnotation;
    return A(r.types, t, "types", e, 1), t;
  }
  s(eEe, "intersectionTypeAnnotation");
  function tEe() {
    return {
      type: "MixedTypeAnnotation"
    };
  }
  s(tEe, "mixedTypeAnnotation");
  function rEe() {
    return {
      type: "EmptyTypeAnnotation"
    };
  }
  s(rEe, "emptyTypeAnnotation");
  function iEe(e) {
    let t = {
      type: "NullableTypeAnnotation",
      typeAnnotation: e
    }, r = ee.NullableTypeAnnotation;
    return A(r.typeAnnotation, t, "typeAnnotation", e, 1), t;
  }
  s(iEe, "nullableTypeAnnotation");
  function nEe(e) {
    let t = {
      type: "NumberLiteralTypeAnnotation",
      value: e
    }, r = ee.NumberLiteralTypeAnnotation;
    return A(r.value, t, "value", e), t;
  }
  s(nEe, "numberLiteralTypeAnnotation");
  function sEe() {
    return {
      type: "NumberTypeAnnotation"
    };
  }
  s(sEe, "numberTypeAnnotation");
  function aEe(e, t = [], r = [], i = [], n = !1) {
    let a = {
      type: "ObjectTypeAnnotation",
      properties: e,
      indexers: t,
      callProperties: r,
      internalSlots: i,
      exact: n
    }, o = ee.ObjectTypeAnnotation;
    return A(o.properties, a, "properties", e, 1), A(o.indexers, a, "indexers", t, 1), A(o.callProperties, a, "callProperties", r, 1), A(o.internalSlots,
    a, "internalSlots", i, 1), A(o.exact, a, "exact", n), a;
  }
  s(aEe, "objectTypeAnnotation");
  function oEe(e, t, r, i, n) {
    let a = {
      type: "ObjectTypeInternalSlot",
      id: e,
      value: t,
      optional: r,
      static: i,
      method: n
    }, o = ee.ObjectTypeInternalSlot;
    return A(o.id, a, "id", e, 1), A(o.value, a, "value", t, 1), A(o.optional, a, "optional", r), A(o.static, a, "static", i), A(o.method, a,
    "method", n), a;
  }
  s(oEe, "objectTypeInternalSlot");
  function uEe(e) {
    let t = {
      type: "ObjectTypeCallProperty",
      value: e,
      static: null
    }, r = ee.ObjectTypeCallProperty;
    return A(r.value, t, "value", e, 1), t;
  }
  s(uEe, "objectTypeCallProperty");
  function lEe(e = null, t, r, i = null) {
    let n = {
      type: "ObjectTypeIndexer",
      id: e,
      key: t,
      value: r,
      variance: i,
      static: null
    }, a = ee.ObjectTypeIndexer;
    return A(a.id, n, "id", e, 1), A(a.key, n, "key", t, 1), A(a.value, n, "value", r, 1), A(a.variance, n, "variance", i, 1), n;
  }
  s(lEe, "objectTypeIndexer");
  function cEe(e, t, r = null) {
    let i = {
      type: "ObjectTypeProperty",
      key: e,
      value: t,
      variance: r,
      kind: null,
      method: null,
      optional: null,
      proto: null,
      static: null
    }, n = ee.ObjectTypeProperty;
    return A(n.key, i, "key", e, 1), A(n.value, i, "value", t, 1), A(n.variance, i, "variance", r, 1), i;
  }
  s(cEe, "objectTypeProperty");
  function fEe(e) {
    let t = {
      type: "ObjectTypeSpreadProperty",
      argument: e
    }, r = ee.ObjectTypeSpreadProperty;
    return A(r.argument, t, "argument", e, 1), t;
  }
  s(fEe, "objectTypeSpreadProperty");
  function pEe(e, t = null, r = null, i) {
    let n = {
      type: "OpaqueType",
      id: e,
      typeParameters: t,
      supertype: r,
      impltype: i
    }, a = ee.OpaqueType;
    return A(a.id, n, "id", e, 1), A(a.typeParameters, n, "typeParameters", t, 1), A(a.supertype, n, "supertype", r, 1), A(a.impltype, n, "i\
mpltype", i, 1), n;
  }
  s(pEe, "opaqueType");
  function hEe(e, t) {
    let r = {
      type: "QualifiedTypeIdentifier",
      id: e,
      qualification: t
    }, i = ee.QualifiedTypeIdentifier;
    return A(i.id, r, "id", e, 1), A(i.qualification, r, "qualification", t, 1), r;
  }
  s(hEe, "qualifiedTypeIdentifier");
  function dEe(e) {
    let t = {
      type: "StringLiteralTypeAnnotation",
      value: e
    }, r = ee.StringLiteralTypeAnnotation;
    return A(r.value, t, "value", e), t;
  }
  s(dEe, "stringLiteralTypeAnnotation");
  function mEe() {
    return {
      type: "StringTypeAnnotation"
    };
  }
  s(mEe, "stringTypeAnnotation");
  function yEe() {
    return {
      type: "SymbolTypeAnnotation"
    };
  }
  s(yEe, "symbolTypeAnnotation");
  function gEe() {
    return {
      type: "ThisTypeAnnotation"
    };
  }
  s(gEe, "thisTypeAnnotation");
  function _Ee(e) {
    let t = {
      type: "TupleTypeAnnotation",
      types: e
    }, r = ee.TupleTypeAnnotation;
    return A(r.types, t, "types", e, 1), t;
  }
  s(_Ee, "tupleTypeAnnotation");
  function bEe(e) {
    let t = {
      type: "TypeofTypeAnnotation",
      argument: e
    }, r = ee.TypeofTypeAnnotation;
    return A(r.argument, t, "argument", e, 1), t;
  }
  s(bEe, "typeofTypeAnnotation");
  function vEe(e, t = null, r) {
    let i = {
      type: "TypeAlias",
      id: e,
      typeParameters: t,
      right: r
    }, n = ee.TypeAlias;
    return A(n.id, i, "id", e, 1), A(n.typeParameters, i, "typeParameters", t, 1), A(n.right, i, "right", r, 1), i;
  }
  s(vEe, "typeAlias");
  function SEe(e) {
    let t = {
      type: "TypeAnnotation",
      typeAnnotation: e
    }, r = ee.TypeAnnotation;
    return A(r.typeAnnotation, t, "typeAnnotation", e, 1), t;
  }
  s(SEe, "typeAnnotation");
  function TEe(e, t) {
    let r = {
      type: "TypeCastExpression",
      expression: e,
      typeAnnotation: t
    }, i = ee.TypeCastExpression;
    return A(i.expression, r, "expression", e, 1), A(i.typeAnnotation, r, "typeAnnotation", t, 1), r;
  }
  s(TEe, "typeCastExpression");
  function EEe(e = null, t = null, r = null) {
    let i = {
      type: "TypeParameter",
      bound: e,
      default: t,
      variance: r,
      name: null
    }, n = ee.TypeParameter;
    return A(n.bound, i, "bound", e, 1), A(n.default, i, "default", t, 1), A(n.variance, i, "variance", r, 1), i;
  }
  s(EEe, "typeParameter");
  function AEe(e) {
    let t = {
      type: "TypeParameterDeclaration",
      params: e
    }, r = ee.TypeParameterDeclaration;
    return A(r.params, t, "params", e, 1), t;
  }
  s(AEe, "typeParameterDeclaration");
  function xEe(e) {
    let t = {
      type: "TypeParameterInstantiation",
      params: e
    }, r = ee.TypeParameterInstantiation;
    return A(r.params, t, "params", e, 1), t;
  }
  s(xEe, "typeParameterInstantiation");
  function CEe(e) {
    let t = {
      type: "UnionTypeAnnotation",
      types: e
    }, r = ee.UnionTypeAnnotation;
    return A(r.types, t, "types", e, 1), t;
  }
  s(CEe, "unionTypeAnnotation");
  function PEe(e) {
    let t = {
      type: "Variance",
      kind: e
    }, r = ee.Variance;
    return A(r.kind, t, "kind", e), t;
  }
  s(PEe, "variance");
  function DEe() {
    return {
      type: "VoidTypeAnnotation"
    };
  }
  s(DEe, "voidTypeAnnotation");
  function wEe(e, t) {
    let r = {
      type: "EnumDeclaration",
      id: e,
      body: t
    }, i = ee.EnumDeclaration;
    return A(i.id, r, "id", e, 1), A(i.body, r, "body", t, 1), r;
  }
  s(wEe, "enumDeclaration");
  function OEe(e) {
    let t = {
      type: "EnumBooleanBody",
      members: e,
      explicitType: null,
      hasUnknownMembers: null
    }, r = ee.EnumBooleanBody;
    return A(r.members, t, "members", e, 1), t;
  }
  s(OEe, "enumBooleanBody");
  function kEe(e) {
    let t = {
      type: "EnumNumberBody",
      members: e,
      explicitType: null,
      hasUnknownMembers: null
    }, r = ee.EnumNumberBody;
    return A(r.members, t, "members", e, 1), t;
  }
  s(kEe, "enumNumberBody");
  function IEe(e) {
    let t = {
      type: "EnumStringBody",
      members: e,
      explicitType: null,
      hasUnknownMembers: null
    }, r = ee.EnumStringBody;
    return A(r.members, t, "members", e, 1), t;
  }
  s(IEe, "enumStringBody");
  function REe(e) {
    let t = {
      type: "EnumSymbolBody",
      members: e,
      hasUnknownMembers: null
    }, r = ee.EnumSymbolBody;
    return A(r.members, t, "members", e, 1), t;
  }
  s(REe, "enumSymbolBody");
  function NEe(e) {
    let t = {
      type: "EnumBooleanMember",
      id: e,
      init: null
    }, r = ee.EnumBooleanMember;
    return A(r.id, t, "id", e, 1), t;
  }
  s(NEe, "enumBooleanMember");
  function LEe(e, t) {
    let r = {
      type: "EnumNumberMember",
      id: e,
      init: t
    }, i = ee.EnumNumberMember;
    return A(i.id, r, "id", e, 1), A(i.init, r, "init", t, 1), r;
  }
  s(LEe, "enumNumberMember");
  function FEe(e, t) {
    let r = {
      type: "EnumStringMember",
      id: e,
      init: t
    }, i = ee.EnumStringMember;
    return A(i.id, r, "id", e, 1), A(i.init, r, "init", t, 1), r;
  }
  s(FEe, "enumStringMember");
  function MEe(e) {
    let t = {
      type: "EnumDefaultedMember",
      id: e
    }, r = ee.EnumDefaultedMember;
    return A(r.id, t, "id", e, 1), t;
  }
  s(MEe, "enumDefaultedMember");
  function BEe(e, t) {
    let r = {
      type: "IndexedAccessType",
      objectType: e,
      indexType: t
    }, i = ee.IndexedAccessType;
    return A(i.objectType, r, "objectType", e, 1), A(i.indexType, r, "indexType", t, 1), r;
  }
  s(BEe, "indexedAccessType");
  function qEe(e, t) {
    let r = {
      type: "OptionalIndexedAccessType",
      objectType: e,
      indexType: t,
      optional: null
    }, i = ee.OptionalIndexedAccessType;
    return A(i.objectType, r, "objectType", e, 1), A(i.indexType, r, "indexType", t, 1), r;
  }
  s(qEe, "optionalIndexedAccessType");
  function UEe(e, t = null) {
    let r = {
      type: "JSXAttribute",
      name: e,
      value: t
    }, i = ee.JSXAttribute;
    return A(i.name, r, "name", e, 1), A(i.value, r, "value", t, 1), r;
  }
  s(UEe, "jsxAttribute");
  function jEe(e) {
    let t = {
      type: "JSXClosingElement",
      name: e
    }, r = ee.JSXClosingElement;
    return A(r.name, t, "name", e, 1), t;
  }
  s(jEe, "jsxClosingElement");
  function VEe(e, t = null, r, i = null) {
    let n = {
      type: "JSXElement",
      openingElement: e,
      closingElement: t,
      children: r,
      selfClosing: i
    }, a = ee.JSXElement;
    return A(a.openingElement, n, "openingElement", e, 1), A(a.closingElement, n, "closingElement", t, 1), A(a.children, n, "children", r, 1),
    A(a.selfClosing, n, "selfClosing", i), n;
  }
  s(VEe, "jsxElement");
  function KEe() {
    return {
      type: "JSXEmptyExpression"
    };
  }
  s(KEe, "jsxEmptyExpression");
  function HEe(e) {
    let t = {
      type: "JSXExpressionContainer",
      expression: e
    }, r = ee.JSXExpressionContainer;
    return A(r.expression, t, "expression", e, 1), t;
  }
  s(HEe, "jsxExpressionContainer");
  function zEe(e) {
    let t = {
      type: "JSXSpreadChild",
      expression: e
    }, r = ee.JSXSpreadChild;
    return A(r.expression, t, "expression", e, 1), t;
  }
  s(zEe, "jsxSpreadChild");
  function GEe(e) {
    let t = {
      type: "JSXIdentifier",
      name: e
    }, r = ee.JSXIdentifier;
    return A(r.name, t, "name", e), t;
  }
  s(GEe, "jsxIdentifier");
  function WEe(e, t) {
    let r = {
      type: "JSXMemberExpression",
      object: e,
      property: t
    }, i = ee.JSXMemberExpression;
    return A(i.object, r, "object", e, 1), A(i.property, r, "property", t, 1), r;
  }
  s(WEe, "jsxMemberExpression");
  function $Ee(e, t) {
    let r = {
      type: "JSXNamespacedName",
      namespace: e,
      name: t
    }, i = ee.JSXNamespacedName;
    return A(i.namespace, r, "namespace", e, 1), A(i.name, r, "name", t, 1), r;
  }
  s($Ee, "jsxNamespacedName");
  function XEe(e, t, r = !1) {
    let i = {
      type: "JSXOpeningElement",
      name: e,
      attributes: t,
      selfClosing: r
    }, n = ee.JSXOpeningElement;
    return A(n.name, i, "name", e, 1), A(n.attributes, i, "attributes", t, 1), A(n.selfClosing, i, "selfClosing", r), i;
  }
  s(XEe, "jsxOpeningElement");
  function YEe(e) {
    let t = {
      type: "JSXSpreadAttribute",
      argument: e
    }, r = ee.JSXSpreadAttribute;
    return A(r.argument, t, "argument", e, 1), t;
  }
  s(YEe, "jsxSpreadAttribute");
  function JEe(e) {
    let t = {
      type: "JSXText",
      value: e
    }, r = ee.JSXText;
    return A(r.value, t, "value", e), t;
  }
  s(JEe, "jsxText");
  function QEe(e, t, r) {
    let i = {
      type: "JSXFragment",
      openingFragment: e,
      closingFragment: t,
      children: r
    }, n = ee.JSXFragment;
    return A(n.openingFragment, i, "openingFragment", e, 1), A(n.closingFragment, i, "closingFragment", t, 1), A(n.children, i, "children", r,
    1), i;
  }
  s(QEe, "jsxFragment");
  function ZEe() {
    return {
      type: "JSXOpeningFragment"
    };
  }
  s(ZEe, "jsxOpeningFragment");
  function eAe() {
    return {
      type: "JSXClosingFragment"
    };
  }
  s(eAe, "jsxClosingFragment");
  function tAe() {
    return {
      type: "Noop"
    };
  }
  s(tAe, "noop");
  function rAe(e, t) {
    let r = {
      type: "Placeholder",
      expectedNode: e,
      name: t
    }, i = ee.Placeholder;
    return A(i.expectedNode, r, "expectedNode", e), A(i.name, r, "name", t, 1), r;
  }
  s(rAe, "placeholder");
  function iAe(e) {
    let t = {
      type: "V8IntrinsicIdentifier",
      name: e
    }, r = ee.V8IntrinsicIdentifier;
    return A(r.name, t, "name", e), t;
  }
  s(iAe, "v8IntrinsicIdentifier");
  function nAe() {
    return {
      type: "ArgumentPlaceholder"
    };
  }
  s(nAe, "argumentPlaceholder");
  function sAe(e, t) {
    let r = {
      type: "BindExpression",
      object: e,
      callee: t
    }, i = ee.BindExpression;
    return A(i.object, r, "object", e, 1), A(i.callee, r, "callee", t, 1), r;
  }
  s(sAe, "bindExpression");
  function aAe(e) {
    let t = {
      type: "Decorator",
      expression: e
    }, r = ee.Decorator;
    return A(r.expression, t, "expression", e, 1), t;
  }
  s(aAe, "decorator");
  function oAe(e, t = !1) {
    let r = {
      type: "DoExpression",
      body: e,
      async: t
    }, i = ee.DoExpression;
    return A(i.body, r, "body", e, 1), A(i.async, r, "async", t), r;
  }
  s(oAe, "doExpression");
  function uAe(e) {
    let t = {
      type: "ExportDefaultSpecifier",
      exported: e
    }, r = ee.ExportDefaultSpecifier;
    return A(r.exported, t, "exported", e, 1), t;
  }
  s(uAe, "exportDefaultSpecifier");
  function lAe(e) {
    let t = {
      type: "RecordExpression",
      properties: e
    }, r = ee.RecordExpression;
    return A(r.properties, t, "properties", e, 1), t;
  }
  s(lAe, "recordExpression");
  function cAe(e = []) {
    let t = {
      type: "TupleExpression",
      elements: e
    }, r = ee.TupleExpression;
    return A(r.elements, t, "elements", e, 1), t;
  }
  s(cAe, "tupleExpression");
  function fAe(e) {
    let t = {
      type: "DecimalLiteral",
      value: e
    }, r = ee.DecimalLiteral;
    return A(r.value, t, "value", e), t;
  }
  s(fAe, "decimalLiteral");
  function pAe(e) {
    let t = {
      type: "ModuleExpression",
      body: e
    }, r = ee.ModuleExpression;
    return A(r.body, t, "body", e, 1), t;
  }
  s(pAe, "moduleExpression");
  function hAe() {
    return {
      type: "TopicReference"
    };
  }
  s(hAe, "topicReference");
  function dAe(e) {
    let t = {
      type: "PipelineTopicExpression",
      expression: e
    }, r = ee.PipelineTopicExpression;
    return A(r.expression, t, "expression", e, 1), t;
  }
  s(dAe, "pipelineTopicExpression");
  function mAe(e) {
    let t = {
      type: "PipelineBareFunction",
      callee: e
    }, r = ee.PipelineBareFunction;
    return A(r.callee, t, "callee", e, 1), t;
  }
  s(mAe, "pipelineBareFunction");
  function yAe() {
    return {
      type: "PipelinePrimaryTopicReference"
    };
  }
  s(yAe, "pipelinePrimaryTopicReference");
  function gAe(e) {
    let t = {
      type: "TSParameterProperty",
      parameter: e
    }, r = ee.TSParameterProperty;
    return A(r.parameter, t, "parameter", e, 1), t;
  }
  s(gAe, "tsParameterProperty");
  function _Ae(e = null, t = null, r, i = null) {
    let n = {
      type: "TSDeclareFunction",
      id: e,
      typeParameters: t,
      params: r,
      returnType: i
    }, a = ee.TSDeclareFunction;
    return A(a.id, n, "id", e, 1), A(a.typeParameters, n, "typeParameters", t, 1), A(a.params, n, "params", r, 1), A(a.returnType, n, "retur\
nType", i, 1), n;
  }
  s(_Ae, "tsDeclareFunction");
  function bAe(e = null, t, r = null, i, n = null) {
    let a = {
      type: "TSDeclareMethod",
      decorators: e,
      key: t,
      typeParameters: r,
      params: i,
      returnType: n
    }, o = ee.TSDeclareMethod;
    return A(o.decorators, a, "decorators", e, 1), A(o.key, a, "key", t, 1), A(o.typeParameters, a, "typeParameters", r, 1), A(o.params, a, "\
params", i, 1), A(o.returnType, a, "returnType", n, 1), a;
  }
  s(bAe, "tsDeclareMethod");
  function vAe(e, t) {
    let r = {
      type: "TSQualifiedName",
      left: e,
      right: t
    }, i = ee.TSQualifiedName;
    return A(i.left, r, "left", e, 1), A(i.right, r, "right", t, 1), r;
  }
  s(vAe, "tsQualifiedName");
  function SAe(e = null, t, r = null) {
    let i = {
      type: "TSCallSignatureDeclaration",
      typeParameters: e,
      parameters: t,
      typeAnnotation: r
    }, n = ee.TSCallSignatureDeclaration;
    return A(n.typeParameters, i, "typeParameters", e, 1), A(n.parameters, i, "parameters", t, 1), A(n.typeAnnotation, i, "typeAnnotation", r,
    1), i;
  }
  s(SAe, "tsCallSignatureDeclaration");
  function TAe(e = null, t, r = null) {
    let i = {
      type: "TSConstructSignatureDeclaration",
      typeParameters: e,
      parameters: t,
      typeAnnotation: r
    }, n = ee.TSConstructSignatureDeclaration;
    return A(n.typeParameters, i, "typeParameters", e, 1), A(n.parameters, i, "parameters", t, 1), A(n.typeAnnotation, i, "typeAnnotation", r,
    1), i;
  }
  s(TAe, "tsConstructSignatureDeclaration");
  function EAe(e, t = null) {
    let r = {
      type: "TSPropertySignature",
      key: e,
      typeAnnotation: t
    }, i = ee.TSPropertySignature;
    return A(i.key, r, "key", e, 1), A(i.typeAnnotation, r, "typeAnnotation", t, 1), r;
  }
  s(EAe, "tsPropertySignature");
  function AAe(e, t = null, r, i = null) {
    let n = {
      type: "TSMethodSignature",
      key: e,
      typeParameters: t,
      parameters: r,
      typeAnnotation: i,
      kind: null
    }, a = ee.TSMethodSignature;
    return A(a.key, n, "key", e, 1), A(a.typeParameters, n, "typeParameters", t, 1), A(a.parameters, n, "parameters", r, 1), A(a.typeAnnotation,
    n, "typeAnnotation", i, 1), n;
  }
  s(AAe, "tsMethodSignature");
  function xAe(e, t = null) {
    let r = {
      type: "TSIndexSignature",
      parameters: e,
      typeAnnotation: t
    }, i = ee.TSIndexSignature;
    return A(i.parameters, r, "parameters", e, 1), A(i.typeAnnotation, r, "typeAnnotation", t, 1), r;
  }
  s(xAe, "tsIndexSignature");
  function CAe() {
    return {
      type: "TSAnyKeyword"
    };
  }
  s(CAe, "tsAnyKeyword");
  function PAe() {
    return {
      type: "TSBooleanKeyword"
    };
  }
  s(PAe, "tsBooleanKeyword");
  function DAe() {
    return {
      type: "TSBigIntKeyword"
    };
  }
  s(DAe, "tsBigIntKeyword");
  function wAe() {
    return {
      type: "TSIntrinsicKeyword"
    };
  }
  s(wAe, "tsIntrinsicKeyword");
  function OAe() {
    return {
      type: "TSNeverKeyword"
    };
  }
  s(OAe, "tsNeverKeyword");
  function kAe() {
    return {
      type: "TSNullKeyword"
    };
  }
  s(kAe, "tsNullKeyword");
  function IAe() {
    return {
      type: "TSNumberKeyword"
    };
  }
  s(IAe, "tsNumberKeyword");
  function RAe() {
    return {
      type: "TSObjectKeyword"
    };
  }
  s(RAe, "tsObjectKeyword");
  function NAe() {
    return {
      type: "TSStringKeyword"
    };
  }
  s(NAe, "tsStringKeyword");
  function LAe() {
    return {
      type: "TSSymbolKeyword"
    };
  }
  s(LAe, "tsSymbolKeyword");
  function FAe() {
    return {
      type: "TSUndefinedKeyword"
    };
  }
  s(FAe, "tsUndefinedKeyword");
  function MAe() {
    return {
      type: "TSUnknownKeyword"
    };
  }
  s(MAe, "tsUnknownKeyword");
  function BAe() {
    return {
      type: "TSVoidKeyword"
    };
  }
  s(BAe, "tsVoidKeyword");
  function qAe() {
    return {
      type: "TSThisType"
    };
  }
  s(qAe, "tsThisType");
  function UAe(e = null, t, r = null) {
    let i = {
      type: "TSFunctionType",
      typeParameters: e,
      parameters: t,
      typeAnnotation: r
    }, n = ee.TSFunctionType;
    return A(n.typeParameters, i, "typeParameters", e, 1), A(n.parameters, i, "parameters", t, 1), A(n.typeAnnotation, i, "typeAnnotation", r,
    1), i;
  }
  s(UAe, "tsFunctionType");
  function jAe(e = null, t, r = null) {
    let i = {
      type: "TSConstructorType",
      typeParameters: e,
      parameters: t,
      typeAnnotation: r
    }, n = ee.TSConstructorType;
    return A(n.typeParameters, i, "typeParameters", e, 1), A(n.parameters, i, "parameters", t, 1), A(n.typeAnnotation, i, "typeAnnotation", r,
    1), i;
  }
  s(jAe, "tsConstructorType");
  function VAe(e, t = null) {
    let r = {
      type: "TSTypeReference",
      typeName: e,
      typeParameters: t
    }, i = ee.TSTypeReference;
    return A(i.typeName, r, "typeName", e, 1), A(i.typeParameters, r, "typeParameters", t, 1), r;
  }
  s(VAe, "tsTypeReference");
  function KAe(e, t = null, r = null) {
    let i = {
      type: "TSTypePredicate",
      parameterName: e,
      typeAnnotation: t,
      asserts: r
    }, n = ee.TSTypePredicate;
    return A(n.parameterName, i, "parameterName", e, 1), A(n.typeAnnotation, i, "typeAnnotation", t, 1), A(n.asserts, i, "asserts", r), i;
  }
  s(KAe, "tsTypePredicate");
  function HAe(e, t = null) {
    let r = {
      type: "TSTypeQuery",
      exprName: e,
      typeParameters: t
    }, i = ee.TSTypeQuery;
    return A(i.exprName, r, "exprName", e, 1), A(i.typeParameters, r, "typeParameters", t, 1), r;
  }
  s(HAe, "tsTypeQuery");
  function zAe(e) {
    let t = {
      type: "TSTypeLiteral",
      members: e
    }, r = ee.TSTypeLiteral;
    return A(r.members, t, "members", e, 1), t;
  }
  s(zAe, "tsTypeLiteral");
  function GAe(e) {
    let t = {
      type: "TSArrayType",
      elementType: e
    }, r = ee.TSArrayType;
    return A(r.elementType, t, "elementType", e, 1), t;
  }
  s(GAe, "tsArrayType");
  function WAe(e) {
    let t = {
      type: "TSTupleType",
      elementTypes: e
    }, r = ee.TSTupleType;
    return A(r.elementTypes, t, "elementTypes", e, 1), t;
  }
  s(WAe, "tsTupleType");
  function $Ae(e) {
    let t = {
      type: "TSOptionalType",
      typeAnnotation: e
    }, r = ee.TSOptionalType;
    return A(r.typeAnnotation, t, "typeAnnotation", e, 1), t;
  }
  s($Ae, "tsOptionalType");
  function XAe(e) {
    let t = {
      type: "TSRestType",
      typeAnnotation: e
    }, r = ee.TSRestType;
    return A(r.typeAnnotation, t, "typeAnnotation", e, 1), t;
  }
  s(XAe, "tsRestType");
  function YAe(e, t, r = !1) {
    let i = {
      type: "TSNamedTupleMember",
      label: e,
      elementType: t,
      optional: r
    }, n = ee.TSNamedTupleMember;
    return A(n.label, i, "label", e, 1), A(n.elementType, i, "elementType", t, 1), A(n.optional, i, "optional", r), i;
  }
  s(YAe, "tsNamedTupleMember");
  function JAe(e) {
    let t = {
      type: "TSUnionType",
      types: e
    }, r = ee.TSUnionType;
    return A(r.types, t, "types", e, 1), t;
  }
  s(JAe, "tsUnionType");
  function QAe(e) {
    let t = {
      type: "TSIntersectionType",
      types: e
    }, r = ee.TSIntersectionType;
    return A(r.types, t, "types", e, 1), t;
  }
  s(QAe, "tsIntersectionType");
  function ZAe(e, t, r, i) {
    let n = {
      type: "TSConditionalType",
      checkType: e,
      extendsType: t,
      trueType: r,
      falseType: i
    }, a = ee.TSConditionalType;
    return A(a.checkType, n, "checkType", e, 1), A(a.extendsType, n, "extendsType", t, 1), A(a.trueType, n, "trueType", r, 1), A(a.falseType,
    n, "falseType", i, 1), n;
  }
  s(ZAe, "tsConditionalType");
  function exe(e) {
    let t = {
      type: "TSInferType",
      typeParameter: e
    }, r = ee.TSInferType;
    return A(r.typeParameter, t, "typeParameter", e, 1), t;
  }
  s(exe, "tsInferType");
  function txe(e) {
    let t = {
      type: "TSParenthesizedType",
      typeAnnotation: e
    }, r = ee.TSParenthesizedType;
    return A(r.typeAnnotation, t, "typeAnnotation", e, 1), t;
  }
  s(txe, "tsParenthesizedType");
  function rxe(e) {
    let t = {
      type: "TSTypeOperator",
      typeAnnotation: e,
      operator: null
    }, r = ee.TSTypeOperator;
    return A(r.typeAnnotation, t, "typeAnnotation", e, 1), t;
  }
  s(rxe, "tsTypeOperator");
  function ixe(e, t) {
    let r = {
      type: "TSIndexedAccessType",
      objectType: e,
      indexType: t
    }, i = ee.TSIndexedAccessType;
    return A(i.objectType, r, "objectType", e, 1), A(i.indexType, r, "indexType", t, 1), r;
  }
  s(ixe, "tsIndexedAccessType");
  function nxe(e, t = null, r = null) {
    let i = {
      type: "TSMappedType",
      typeParameter: e,
      typeAnnotation: t,
      nameType: r
    }, n = ee.TSMappedType;
    return A(n.typeParameter, i, "typeParameter", e, 1), A(n.typeAnnotation, i, "typeAnnotation", t, 1), A(n.nameType, i, "nameType", r, 1),
    i;
  }
  s(nxe, "tsMappedType");
  function sxe(e, t) {
    let r = {
      type: "TSTemplateLiteralType",
      quasis: e,
      types: t
    }, i = ee.TSTemplateLiteralType;
    return A(i.quasis, r, "quasis", e, 1), A(i.types, r, "types", t, 1), r;
  }
  s(sxe, "tsTemplateLiteralType");
  function axe(e) {
    let t = {
      type: "TSLiteralType",
      literal: e
    }, r = ee.TSLiteralType;
    return A(r.literal, t, "literal", e, 1), t;
  }
  s(axe, "tsLiteralType");
  function oxe(e, t = null) {
    let r = {
      type: "TSExpressionWithTypeArguments",
      expression: e,
      typeParameters: t
    }, i = ee.TSExpressionWithTypeArguments;
    return A(i.expression, r, "expression", e, 1), A(i.typeParameters, r, "typeParameters", t, 1), r;
  }
  s(oxe, "tsExpressionWithTypeArguments");
  function uxe(e, t = null, r = null, i) {
    let n = {
      type: "TSInterfaceDeclaration",
      id: e,
      typeParameters: t,
      extends: r,
      body: i
    }, a = ee.TSInterfaceDeclaration;
    return A(a.id, n, "id", e, 1), A(a.typeParameters, n, "typeParameters", t, 1), A(a.extends, n, "extends", r, 1), A(a.body, n, "body", i,
    1), n;
  }
  s(uxe, "tsInterfaceDeclaration");
  function lxe(e) {
    let t = {
      type: "TSInterfaceBody",
      body: e
    }, r = ee.TSInterfaceBody;
    return A(r.body, t, "body", e, 1), t;
  }
  s(lxe, "tsInterfaceBody");
  function cxe(e, t = null, r) {
    let i = {
      type: "TSTypeAliasDeclaration",
      id: e,
      typeParameters: t,
      typeAnnotation: r
    }, n = ee.TSTypeAliasDeclaration;
    return A(n.id, i, "id", e, 1), A(n.typeParameters, i, "typeParameters", t, 1), A(n.typeAnnotation, i, "typeAnnotation", r, 1), i;
  }
  s(cxe, "tsTypeAliasDeclaration");
  function fxe(e, t = null) {
    let r = {
      type: "TSInstantiationExpression",
      expression: e,
      typeParameters: t
    }, i = ee.TSInstantiationExpression;
    return A(i.expression, r, "expression", e, 1), A(i.typeParameters, r, "typeParameters", t, 1), r;
  }
  s(fxe, "tsInstantiationExpression");
  function pxe(e, t) {
    let r = {
      type: "TSAsExpression",
      expression: e,
      typeAnnotation: t
    }, i = ee.TSAsExpression;
    return A(i.expression, r, "expression", e, 1), A(i.typeAnnotation, r, "typeAnnotation", t, 1), r;
  }
  s(pxe, "tsAsExpression");
  function hxe(e, t) {
    let r = {
      type: "TSSatisfiesExpression",
      expression: e,
      typeAnnotation: t
    }, i = ee.TSSatisfiesExpression;
    return A(i.expression, r, "expression", e, 1), A(i.typeAnnotation, r, "typeAnnotation", t, 1), r;
  }
  s(hxe, "tsSatisfiesExpression");
  function dxe(e, t) {
    let r = {
      type: "TSTypeAssertion",
      typeAnnotation: e,
      expression: t
    }, i = ee.TSTypeAssertion;
    return A(i.typeAnnotation, r, "typeAnnotation", e, 1), A(i.expression, r, "expression", t, 1), r;
  }
  s(dxe, "tsTypeAssertion");
  function mxe(e) {
    let t = {
      type: "TSEnumBody",
      members: e
    }, r = ee.TSEnumBody;
    return A(r.members, t, "members", e, 1), t;
  }
  s(mxe, "tsEnumBody");
  function yxe(e, t) {
    let r = {
      type: "TSEnumDeclaration",
      id: e,
      members: t
    }, i = ee.TSEnumDeclaration;
    return A(i.id, r, "id", e, 1), A(i.members, r, "members", t, 1), r;
  }
  s(yxe, "tsEnumDeclaration");
  function gxe(e, t = null) {
    let r = {
      type: "TSEnumMember",
      id: e,
      initializer: t
    }, i = ee.TSEnumMember;
    return A(i.id, r, "id", e, 1), A(i.initializer, r, "initializer", t, 1), r;
  }
  s(gxe, "tsEnumMember");
  function _xe(e, t) {
    let r = {
      type: "TSModuleDeclaration",
      id: e,
      body: t,
      kind: null
    }, i = ee.TSModuleDeclaration;
    return A(i.id, r, "id", e, 1), A(i.body, r, "body", t, 1), r;
  }
  s(_xe, "tsModuleDeclaration");
  function bxe(e) {
    let t = {
      type: "TSModuleBlock",
      body: e
    }, r = ee.TSModuleBlock;
    return A(r.body, t, "body", e, 1), t;
  }
  s(bxe, "tsModuleBlock");
  function vxe(e, t = null, r = null) {
    let i = {
      type: "TSImportType",
      argument: e,
      qualifier: t,
      typeParameters: r
    }, n = ee.TSImportType;
    return A(n.argument, i, "argument", e, 1), A(n.qualifier, i, "qualifier", t, 1), A(n.typeParameters, i, "typeParameters", r, 1), i;
  }
  s(vxe, "tsImportType");
  function Sxe(e, t) {
    let r = {
      type: "TSImportEqualsDeclaration",
      id: e,
      moduleReference: t,
      isExport: null
    }, i = ee.TSImportEqualsDeclaration;
    return A(i.id, r, "id", e, 1), A(i.moduleReference, r, "moduleReference", t, 1), r;
  }
  s(Sxe, "tsImportEqualsDeclaration");
  function Txe(e) {
    let t = {
      type: "TSExternalModuleReference",
      expression: e
    }, r = ee.TSExternalModuleReference;
    return A(r.expression, t, "expression", e, 1), t;
  }
  s(Txe, "tsExternalModuleReference");
  function Exe(e) {
    let t = {
      type: "TSNonNullExpression",
      expression: e
    }, r = ee.TSNonNullExpression;
    return A(r.expression, t, "expression", e, 1), t;
  }
  s(Exe, "tsNonNullExpression");
  function Axe(e) {
    let t = {
      type: "TSExportAssignment",
      expression: e
    }, r = ee.TSExportAssignment;
    return A(r.expression, t, "expression", e, 1), t;
  }
  s(Axe, "tsExportAssignment");
  function xxe(e) {
    let t = {
      type: "TSNamespaceExportDeclaration",
      id: e
    }, r = ee.TSNamespaceExportDeclaration;
    return A(r.id, t, "id", e, 1), t;
  }
  s(xxe, "tsNamespaceExportDeclaration");
  function Cxe(e) {
    let t = {
      type: "TSTypeAnnotation",
      typeAnnotation: e
    }, r = ee.TSTypeAnnotation;
    return A(r.typeAnnotation, t, "typeAnnotation", e, 1), t;
  }
  s(Cxe, "tsTypeAnnotation");
  function Pxe(e) {
    let t = {
      type: "TSTypeParameterInstantiation",
      params: e
    }, r = ee.TSTypeParameterInstantiation;
    return A(r.params, t, "params", e, 1), t;
  }
  s(Pxe, "tsTypeParameterInstantiation");
  function Dxe(e) {
    let t = {
      type: "TSTypeParameterDeclaration",
      params: e
    }, r = ee.TSTypeParameterDeclaration;
    return A(r.params, t, "params", e, 1), t;
  }
  s(Dxe, "tsTypeParameterDeclaration");
  function wxe(e = null, t = null, r) {
    let i = {
      type: "TSTypeParameter",
      constraint: e,
      default: t,
      name: r
    }, n = ee.TSTypeParameter;
    return A(n.constraint, i, "constraint", e, 1), A(n.default, i, "default", t, 1), A(n.name, i, "name", r), i;
  }
  s(wxe, "tsTypeParameter");
  function Oxe(e) {
    return (0, f_.default)("NumberLiteral", "NumericLiteral", "The node type "), i4(e);
  }
  s(Oxe, "NumberLiteral");
  function kxe(e, t = "") {
    return (0, f_.default)("RegexLiteral", "RegExpLiteral", "The node type "), n4(e, t);
  }
  s(kxe, "RegexLiteral");
  function Ixe(e) {
    return (0, f_.default)("RestProperty", "RestElement", "The node type "), s4(e);
  }
  s(Ixe, "RestProperty");
  function Rxe(e) {
    return (0, f_.default)("SpreadProperty", "SpreadElement", "The node type "), a4(e);
  }
  s(Rxe, "SpreadProperty");
});

// ../node_modules/@babel/types/lib/builders/generated/uppercase.js
var o4 = b((W) => {
  "use strict";
  Object.defineProperty(W, "__esModule", {
    value: !0
  });
  Object.defineProperty(W, "AnyTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.anyTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(W, "ArgumentPlaceholder", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.argumentPlaceholder;
    }, "get")
  });
  Object.defineProperty(W, "ArrayExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.arrayExpression;
    }, "get")
  });
  Object.defineProperty(W, "ArrayPattern", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.arrayPattern;
    }, "get")
  });
  Object.defineProperty(W, "ArrayTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.arrayTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(W, "ArrowFunctionExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.arrowFunctionExpression;
    }, "get")
  });
  Object.defineProperty(W, "AssignmentExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.assignmentExpression;
    }, "get")
  });
  Object.defineProperty(W, "AssignmentPattern", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.assignmentPattern;
    }, "get")
  });
  Object.defineProperty(W, "AwaitExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.awaitExpression;
    }, "get")
  });
  Object.defineProperty(W, "BigIntLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.bigIntLiteral;
    }, "get")
  });
  Object.defineProperty(W, "BinaryExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.binaryExpression;
    }, "get")
  });
  Object.defineProperty(W, "BindExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.bindExpression;
    }, "get")
  });
  Object.defineProperty(W, "BlockStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.blockStatement;
    }, "get")
  });
  Object.defineProperty(W, "BooleanLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.booleanLiteral;
    }, "get")
  });
  Object.defineProperty(W, "BooleanLiteralTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.booleanLiteralTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(W, "BooleanTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.booleanTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(W, "BreakStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.breakStatement;
    }, "get")
  });
  Object.defineProperty(W, "CallExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.callExpression;
    }, "get")
  });
  Object.defineProperty(W, "CatchClause", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.catchClause;
    }, "get")
  });
  Object.defineProperty(W, "ClassAccessorProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.classAccessorProperty;
    }, "get")
  });
  Object.defineProperty(W, "ClassBody", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.classBody;
    }, "get")
  });
  Object.defineProperty(W, "ClassDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.classDeclaration;
    }, "get")
  });
  Object.defineProperty(W, "ClassExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.classExpression;
    }, "get")
  });
  Object.defineProperty(W, "ClassImplements", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.classImplements;
    }, "get")
  });
  Object.defineProperty(W, "ClassMethod", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.classMethod;
    }, "get")
  });
  Object.defineProperty(W, "ClassPrivateMethod", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.classPrivateMethod;
    }, "get")
  });
  Object.defineProperty(W, "ClassPrivateProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.classPrivateProperty;
    }, "get")
  });
  Object.defineProperty(W, "ClassProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.classProperty;
    }, "get")
  });
  Object.defineProperty(W, "ConditionalExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.conditionalExpression;
    }, "get")
  });
  Object.defineProperty(W, "ContinueStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.continueStatement;
    }, "get")
  });
  Object.defineProperty(W, "DebuggerStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.debuggerStatement;
    }, "get")
  });
  Object.defineProperty(W, "DecimalLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.decimalLiteral;
    }, "get")
  });
  Object.defineProperty(W, "DeclareClass", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.declareClass;
    }, "get")
  });
  Object.defineProperty(W, "DeclareExportAllDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.declareExportAllDeclaration;
    }, "get")
  });
  Object.defineProperty(W, "DeclareExportDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.declareExportDeclaration;
    }, "get")
  });
  Object.defineProperty(W, "DeclareFunction", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.declareFunction;
    }, "get")
  });
  Object.defineProperty(W, "DeclareInterface", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.declareInterface;
    }, "get")
  });
  Object.defineProperty(W, "DeclareModule", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.declareModule;
    }, "get")
  });
  Object.defineProperty(W, "DeclareModuleExports", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.declareModuleExports;
    }, "get")
  });
  Object.defineProperty(W, "DeclareOpaqueType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.declareOpaqueType;
    }, "get")
  });
  Object.defineProperty(W, "DeclareTypeAlias", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.declareTypeAlias;
    }, "get")
  });
  Object.defineProperty(W, "DeclareVariable", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.declareVariable;
    }, "get")
  });
  Object.defineProperty(W, "DeclaredPredicate", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.declaredPredicate;
    }, "get")
  });
  Object.defineProperty(W, "Decorator", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.decorator;
    }, "get")
  });
  Object.defineProperty(W, "Directive", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.directive;
    }, "get")
  });
  Object.defineProperty(W, "DirectiveLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.directiveLiteral;
    }, "get")
  });
  Object.defineProperty(W, "DoExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.doExpression;
    }, "get")
  });
  Object.defineProperty(W, "DoWhileStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.doWhileStatement;
    }, "get")
  });
  Object.defineProperty(W, "EmptyStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.emptyStatement;
    }, "get")
  });
  Object.defineProperty(W, "EmptyTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.emptyTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(W, "EnumBooleanBody", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.enumBooleanBody;
    }, "get")
  });
  Object.defineProperty(W, "EnumBooleanMember", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.enumBooleanMember;
    }, "get")
  });
  Object.defineProperty(W, "EnumDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.enumDeclaration;
    }, "get")
  });
  Object.defineProperty(W, "EnumDefaultedMember", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.enumDefaultedMember;
    }, "get")
  });
  Object.defineProperty(W, "EnumNumberBody", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.enumNumberBody;
    }, "get")
  });
  Object.defineProperty(W, "EnumNumberMember", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.enumNumberMember;
    }, "get")
  });
  Object.defineProperty(W, "EnumStringBody", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.enumStringBody;
    }, "get")
  });
  Object.defineProperty(W, "EnumStringMember", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.enumStringMember;
    }, "get")
  });
  Object.defineProperty(W, "EnumSymbolBody", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.enumSymbolBody;
    }, "get")
  });
  Object.defineProperty(W, "ExistsTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.existsTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(W, "ExportAllDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.exportAllDeclaration;
    }, "get")
  });
  Object.defineProperty(W, "ExportDefaultDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.exportDefaultDeclaration;
    }, "get")
  });
  Object.defineProperty(W, "ExportDefaultSpecifier", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.exportDefaultSpecifier;
    }, "get")
  });
  Object.defineProperty(W, "ExportNamedDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.exportNamedDeclaration;
    }, "get")
  });
  Object.defineProperty(W, "ExportNamespaceSpecifier", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.exportNamespaceSpecifier;
    }, "get")
  });
  Object.defineProperty(W, "ExportSpecifier", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.exportSpecifier;
    }, "get")
  });
  Object.defineProperty(W, "ExpressionStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.expressionStatement;
    }, "get")
  });
  Object.defineProperty(W, "File", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.file;
    }, "get")
  });
  Object.defineProperty(W, "ForInStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.forInStatement;
    }, "get")
  });
  Object.defineProperty(W, "ForOfStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.forOfStatement;
    }, "get")
  });
  Object.defineProperty(W, "ForStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.forStatement;
    }, "get")
  });
  Object.defineProperty(W, "FunctionDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.functionDeclaration;
    }, "get")
  });
  Object.defineProperty(W, "FunctionExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.functionExpression;
    }, "get")
  });
  Object.defineProperty(W, "FunctionTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.functionTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(W, "FunctionTypeParam", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.functionTypeParam;
    }, "get")
  });
  Object.defineProperty(W, "GenericTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.genericTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(W, "Identifier", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.identifier;
    }, "get")
  });
  Object.defineProperty(W, "IfStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.ifStatement;
    }, "get")
  });
  Object.defineProperty(W, "Import", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.import;
    }, "get")
  });
  Object.defineProperty(W, "ImportAttribute", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.importAttribute;
    }, "get")
  });
  Object.defineProperty(W, "ImportDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.importDeclaration;
    }, "get")
  });
  Object.defineProperty(W, "ImportDefaultSpecifier", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.importDefaultSpecifier;
    }, "get")
  });
  Object.defineProperty(W, "ImportExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.importExpression;
    }, "get")
  });
  Object.defineProperty(W, "ImportNamespaceSpecifier", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.importNamespaceSpecifier;
    }, "get")
  });
  Object.defineProperty(W, "ImportSpecifier", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.importSpecifier;
    }, "get")
  });
  Object.defineProperty(W, "IndexedAccessType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.indexedAccessType;
    }, "get")
  });
  Object.defineProperty(W, "InferredPredicate", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.inferredPredicate;
    }, "get")
  });
  Object.defineProperty(W, "InterfaceDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.interfaceDeclaration;
    }, "get")
  });
  Object.defineProperty(W, "InterfaceExtends", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.interfaceExtends;
    }, "get")
  });
  Object.defineProperty(W, "InterfaceTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.interfaceTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(W, "InterpreterDirective", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.interpreterDirective;
    }, "get")
  });
  Object.defineProperty(W, "IntersectionTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.intersectionTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(W, "JSXAttribute", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.jsxAttribute;
    }, "get")
  });
  Object.defineProperty(W, "JSXClosingElement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.jsxClosingElement;
    }, "get")
  });
  Object.defineProperty(W, "JSXClosingFragment", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.jsxClosingFragment;
    }, "get")
  });
  Object.defineProperty(W, "JSXElement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.jsxElement;
    }, "get")
  });
  Object.defineProperty(W, "JSXEmptyExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.jsxEmptyExpression;
    }, "get")
  });
  Object.defineProperty(W, "JSXExpressionContainer", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.jsxExpressionContainer;
    }, "get")
  });
  Object.defineProperty(W, "JSXFragment", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.jsxFragment;
    }, "get")
  });
  Object.defineProperty(W, "JSXIdentifier", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.jsxIdentifier;
    }, "get")
  });
  Object.defineProperty(W, "JSXMemberExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.jsxMemberExpression;
    }, "get")
  });
  Object.defineProperty(W, "JSXNamespacedName", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.jsxNamespacedName;
    }, "get")
  });
  Object.defineProperty(W, "JSXOpeningElement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.jsxOpeningElement;
    }, "get")
  });
  Object.defineProperty(W, "JSXOpeningFragment", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.jsxOpeningFragment;
    }, "get")
  });
  Object.defineProperty(W, "JSXSpreadAttribute", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.jsxSpreadAttribute;
    }, "get")
  });
  Object.defineProperty(W, "JSXSpreadChild", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.jsxSpreadChild;
    }, "get")
  });
  Object.defineProperty(W, "JSXText", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.jsxText;
    }, "get")
  });
  Object.defineProperty(W, "LabeledStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.labeledStatement;
    }, "get")
  });
  Object.defineProperty(W, "LogicalExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.logicalExpression;
    }, "get")
  });
  Object.defineProperty(W, "MemberExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.memberExpression;
    }, "get")
  });
  Object.defineProperty(W, "MetaProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.metaProperty;
    }, "get")
  });
  Object.defineProperty(W, "MixedTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.mixedTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(W, "ModuleExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.moduleExpression;
    }, "get")
  });
  Object.defineProperty(W, "NewExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.newExpression;
    }, "get")
  });
  Object.defineProperty(W, "Noop", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.noop;
    }, "get")
  });
  Object.defineProperty(W, "NullLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.nullLiteral;
    }, "get")
  });
  Object.defineProperty(W, "NullLiteralTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.nullLiteralTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(W, "NullableTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.nullableTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(W, "NumberLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.numberLiteral;
    }, "get")
  });
  Object.defineProperty(W, "NumberLiteralTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.numberLiteralTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(W, "NumberTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.numberTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(W, "NumericLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.numericLiteral;
    }, "get")
  });
  Object.defineProperty(W, "ObjectExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.objectExpression;
    }, "get")
  });
  Object.defineProperty(W, "ObjectMethod", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.objectMethod;
    }, "get")
  });
  Object.defineProperty(W, "ObjectPattern", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.objectPattern;
    }, "get")
  });
  Object.defineProperty(W, "ObjectProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.objectProperty;
    }, "get")
  });
  Object.defineProperty(W, "ObjectTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.objectTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(W, "ObjectTypeCallProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.objectTypeCallProperty;
    }, "get")
  });
  Object.defineProperty(W, "ObjectTypeIndexer", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.objectTypeIndexer;
    }, "get")
  });
  Object.defineProperty(W, "ObjectTypeInternalSlot", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.objectTypeInternalSlot;
    }, "get")
  });
  Object.defineProperty(W, "ObjectTypeProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.objectTypeProperty;
    }, "get")
  });
  Object.defineProperty(W, "ObjectTypeSpreadProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.objectTypeSpreadProperty;
    }, "get")
  });
  Object.defineProperty(W, "OpaqueType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.opaqueType;
    }, "get")
  });
  Object.defineProperty(W, "OptionalCallExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.optionalCallExpression;
    }, "get")
  });
  Object.defineProperty(W, "OptionalIndexedAccessType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.optionalIndexedAccessType;
    }, "get")
  });
  Object.defineProperty(W, "OptionalMemberExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.optionalMemberExpression;
    }, "get")
  });
  Object.defineProperty(W, "ParenthesizedExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.parenthesizedExpression;
    }, "get")
  });
  Object.defineProperty(W, "PipelineBareFunction", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.pipelineBareFunction;
    }, "get")
  });
  Object.defineProperty(W, "PipelinePrimaryTopicReference", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.pipelinePrimaryTopicReference;
    }, "get")
  });
  Object.defineProperty(W, "PipelineTopicExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.pipelineTopicExpression;
    }, "get")
  });
  Object.defineProperty(W, "Placeholder", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.placeholder;
    }, "get")
  });
  Object.defineProperty(W, "PrivateName", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.privateName;
    }, "get")
  });
  Object.defineProperty(W, "Program", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.program;
    }, "get")
  });
  Object.defineProperty(W, "QualifiedTypeIdentifier", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.qualifiedTypeIdentifier;
    }, "get")
  });
  Object.defineProperty(W, "RecordExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.recordExpression;
    }, "get")
  });
  Object.defineProperty(W, "RegExpLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.regExpLiteral;
    }, "get")
  });
  Object.defineProperty(W, "RegexLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.regexLiteral;
    }, "get")
  });
  Object.defineProperty(W, "RestElement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.restElement;
    }, "get")
  });
  Object.defineProperty(W, "RestProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.restProperty;
    }, "get")
  });
  Object.defineProperty(W, "ReturnStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.returnStatement;
    }, "get")
  });
  Object.defineProperty(W, "SequenceExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.sequenceExpression;
    }, "get")
  });
  Object.defineProperty(W, "SpreadElement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.spreadElement;
    }, "get")
  });
  Object.defineProperty(W, "SpreadProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.spreadProperty;
    }, "get")
  });
  Object.defineProperty(W, "StaticBlock", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.staticBlock;
    }, "get")
  });
  Object.defineProperty(W, "StringLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.stringLiteral;
    }, "get")
  });
  Object.defineProperty(W, "StringLiteralTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.stringLiteralTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(W, "StringTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.stringTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(W, "Super", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.super;
    }, "get")
  });
  Object.defineProperty(W, "SwitchCase", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.switchCase;
    }, "get")
  });
  Object.defineProperty(W, "SwitchStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.switchStatement;
    }, "get")
  });
  Object.defineProperty(W, "SymbolTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.symbolTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(W, "TSAnyKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.tsAnyKeyword;
    }, "get")
  });
  Object.defineProperty(W, "TSArrayType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.tsArrayType;
    }, "get")
  });
  Object.defineProperty(W, "TSAsExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.tsAsExpression;
    }, "get")
  });
  Object.defineProperty(W, "TSBigIntKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.tsBigIntKeyword;
    }, "get")
  });
  Object.defineProperty(W, "TSBooleanKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.tsBooleanKeyword;
    }, "get")
  });
  Object.defineProperty(W, "TSCallSignatureDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.tsCallSignatureDeclaration;
    }, "get")
  });
  Object.defineProperty(W, "TSConditionalType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.tsConditionalType;
    }, "get")
  });
  Object.defineProperty(W, "TSConstructSignatureDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.tsConstructSignatureDeclaration;
    }, "get")
  });
  Object.defineProperty(W, "TSConstructorType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.tsConstructorType;
    }, "get")
  });
  Object.defineProperty(W, "TSDeclareFunction", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.tsDeclareFunction;
    }, "get")
  });
  Object.defineProperty(W, "TSDeclareMethod", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.tsDeclareMethod;
    }, "get")
  });
  Object.defineProperty(W, "TSEnumBody", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.tsEnumBody;
    }, "get")
  });
  Object.defineProperty(W, "TSEnumDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.tsEnumDeclaration;
    }, "get")
  });
  Object.defineProperty(W, "TSEnumMember", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.tsEnumMember;
    }, "get")
  });
  Object.defineProperty(W, "TSExportAssignment", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.tsExportAssignment;
    }, "get")
  });
  Object.defineProperty(W, "TSExpressionWithTypeArguments", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.tsExpressionWithTypeArguments;
    }, "get")
  });
  Object.defineProperty(W, "TSExternalModuleReference", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.tsExternalModuleReference;
    }, "get")
  });
  Object.defineProperty(W, "TSFunctionType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.tsFunctionType;
    }, "get")
  });
  Object.defineProperty(W, "TSImportEqualsDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.tsImportEqualsDeclaration;
    }, "get")
  });
  Object.defineProperty(W, "TSImportType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.tsImportType;
    }, "get")
  });
  Object.defineProperty(W, "TSIndexSignature", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.tsIndexSignature;
    }, "get")
  });
  Object.defineProperty(W, "TSIndexedAccessType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.tsIndexedAccessType;
    }, "get")
  });
  Object.defineProperty(W, "TSInferType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.tsInferType;
    }, "get")
  });
  Object.defineProperty(W, "TSInstantiationExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.tsInstantiationExpression;
    }, "get")
  });
  Object.defineProperty(W, "TSInterfaceBody", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.tsInterfaceBody;
    }, "get")
  });
  Object.defineProperty(W, "TSInterfaceDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.tsInterfaceDeclaration;
    }, "get")
  });
  Object.defineProperty(W, "TSIntersectionType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.tsIntersectionType;
    }, "get")
  });
  Object.defineProperty(W, "TSIntrinsicKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.tsIntrinsicKeyword;
    }, "get")
  });
  Object.defineProperty(W, "TSLiteralType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.tsLiteralType;
    }, "get")
  });
  Object.defineProperty(W, "TSMappedType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.tsMappedType;
    }, "get")
  });
  Object.defineProperty(W, "TSMethodSignature", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.tsMethodSignature;
    }, "get")
  });
  Object.defineProperty(W, "TSModuleBlock", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.tsModuleBlock;
    }, "get")
  });
  Object.defineProperty(W, "TSModuleDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.tsModuleDeclaration;
    }, "get")
  });
  Object.defineProperty(W, "TSNamedTupleMember", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.tsNamedTupleMember;
    }, "get")
  });
  Object.defineProperty(W, "TSNamespaceExportDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.tsNamespaceExportDeclaration;
    }, "get")
  });
  Object.defineProperty(W, "TSNeverKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.tsNeverKeyword;
    }, "get")
  });
  Object.defineProperty(W, "TSNonNullExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.tsNonNullExpression;
    }, "get")
  });
  Object.defineProperty(W, "TSNullKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.tsNullKeyword;
    }, "get")
  });
  Object.defineProperty(W, "TSNumberKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.tsNumberKeyword;
    }, "get")
  });
  Object.defineProperty(W, "TSObjectKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.tsObjectKeyword;
    }, "get")
  });
  Object.defineProperty(W, "TSOptionalType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.tsOptionalType;
    }, "get")
  });
  Object.defineProperty(W, "TSParameterProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.tsParameterProperty;
    }, "get")
  });
  Object.defineProperty(W, "TSParenthesizedType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.tsParenthesizedType;
    }, "get")
  });
  Object.defineProperty(W, "TSPropertySignature", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.tsPropertySignature;
    }, "get")
  });
  Object.defineProperty(W, "TSQualifiedName", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.tsQualifiedName;
    }, "get")
  });
  Object.defineProperty(W, "TSRestType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.tsRestType;
    }, "get")
  });
  Object.defineProperty(W, "TSSatisfiesExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.tsSatisfiesExpression;
    }, "get")
  });
  Object.defineProperty(W, "TSStringKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.tsStringKeyword;
    }, "get")
  });
  Object.defineProperty(W, "TSSymbolKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.tsSymbolKeyword;
    }, "get")
  });
  Object.defineProperty(W, "TSTemplateLiteralType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.tsTemplateLiteralType;
    }, "get")
  });
  Object.defineProperty(W, "TSThisType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.tsThisType;
    }, "get")
  });
  Object.defineProperty(W, "TSTupleType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.tsTupleType;
    }, "get")
  });
  Object.defineProperty(W, "TSTypeAliasDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.tsTypeAliasDeclaration;
    }, "get")
  });
  Object.defineProperty(W, "TSTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.tsTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(W, "TSTypeAssertion", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.tsTypeAssertion;
    }, "get")
  });
  Object.defineProperty(W, "TSTypeLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.tsTypeLiteral;
    }, "get")
  });
  Object.defineProperty(W, "TSTypeOperator", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.tsTypeOperator;
    }, "get")
  });
  Object.defineProperty(W, "TSTypeParameter", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.tsTypeParameter;
    }, "get")
  });
  Object.defineProperty(W, "TSTypeParameterDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.tsTypeParameterDeclaration;
    }, "get")
  });
  Object.defineProperty(W, "TSTypeParameterInstantiation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.tsTypeParameterInstantiation;
    }, "get")
  });
  Object.defineProperty(W, "TSTypePredicate", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.tsTypePredicate;
    }, "get")
  });
  Object.defineProperty(W, "TSTypeQuery", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.tsTypeQuery;
    }, "get")
  });
  Object.defineProperty(W, "TSTypeReference", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.tsTypeReference;
    }, "get")
  });
  Object.defineProperty(W, "TSUndefinedKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.tsUndefinedKeyword;
    }, "get")
  });
  Object.defineProperty(W, "TSUnionType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.tsUnionType;
    }, "get")
  });
  Object.defineProperty(W, "TSUnknownKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.tsUnknownKeyword;
    }, "get")
  });
  Object.defineProperty(W, "TSVoidKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.tsVoidKeyword;
    }, "get")
  });
  Object.defineProperty(W, "TaggedTemplateExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.taggedTemplateExpression;
    }, "get")
  });
  Object.defineProperty(W, "TemplateElement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.templateElement;
    }, "get")
  });
  Object.defineProperty(W, "TemplateLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.templateLiteral;
    }, "get")
  });
  Object.defineProperty(W, "ThisExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.thisExpression;
    }, "get")
  });
  Object.defineProperty(W, "ThisTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.thisTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(W, "ThrowStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.throwStatement;
    }, "get")
  });
  Object.defineProperty(W, "TopicReference", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.topicReference;
    }, "get")
  });
  Object.defineProperty(W, "TryStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.tryStatement;
    }, "get")
  });
  Object.defineProperty(W, "TupleExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.tupleExpression;
    }, "get")
  });
  Object.defineProperty(W, "TupleTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.tupleTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(W, "TypeAlias", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.typeAlias;
    }, "get")
  });
  Object.defineProperty(W, "TypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.typeAnnotation;
    }, "get")
  });
  Object.defineProperty(W, "TypeCastExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.typeCastExpression;
    }, "get")
  });
  Object.defineProperty(W, "TypeParameter", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.typeParameter;
    }, "get")
  });
  Object.defineProperty(W, "TypeParameterDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.typeParameterDeclaration;
    }, "get")
  });
  Object.defineProperty(W, "TypeParameterInstantiation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.typeParameterInstantiation;
    }, "get")
  });
  Object.defineProperty(W, "TypeofTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.typeofTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(W, "UnaryExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.unaryExpression;
    }, "get")
  });
  Object.defineProperty(W, "UnionTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.unionTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(W, "UpdateExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.updateExpression;
    }, "get")
  });
  Object.defineProperty(W, "V8IntrinsicIdentifier", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.v8IntrinsicIdentifier;
    }, "get")
  });
  Object.defineProperty(W, "VariableDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.variableDeclaration;
    }, "get")
  });
  Object.defineProperty(W, "VariableDeclarator", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.variableDeclarator;
    }, "get")
  });
  Object.defineProperty(W, "Variance", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.variance;
    }, "get")
  });
  Object.defineProperty(W, "VoidTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.voidTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(W, "WhileStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.whileStatement;
    }, "get")
  });
  Object.defineProperty(W, "WithStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.withStatement;
    }, "get")
  });
  Object.defineProperty(W, "YieldExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $.yieldExpression;
    }, "get")
  });
  var $ = r1();
});

// ../node_modules/@babel/types/lib/builders/generated/index.js
var Ns = b((ul) => {
  "use strict";
  Object.defineProperty(ul, "__esModule", {
    value: !0
  });
  var i1 = r1();
  Object.keys(i1).forEach(function(e) {
    e === "default" || e === "__esModule" || e in ul && ul[e] === i1[e] || Object.defineProperty(ul, e, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return i1[e];
      }, "get")
    });
  });
  var n1 = o4();
  Object.keys(n1).forEach(function(e) {
    e === "default" || e === "__esModule" || e in ul && ul[e] === n1[e] || Object.defineProperty(ul, e, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return n1[e];
      }, "get")
    });
  });
});

// ../node_modules/@babel/types/lib/utils/react/cleanJSXElementLiteralChild.js
var u4 = b((s1) => {
  "use strict";
  Object.defineProperty(s1, "__esModule", {
    value: !0
  });
  s1.default = Fxe;
  var Nxe = Ns(), Lxe = Xn();
  function Fxe(e, t) {
    let r = e.value.split(/\r\n|\n|\r/), i = 0;
    for (let a = 0; a < r.length; a++)
      /[^ \t]/.exec(r[a]) && (i = a);
    let n = "";
    for (let a = 0; a < r.length; a++) {
      let o = r[a], u = a === 0, l = a === r.length - 1, c = a === i, p = o.replace(/\t/g, " ");
      u || (p = p.replace(/^ +/, "")), l || (p = p.replace(/ +$/, "")), p && (c || (p += " "), n += p);
    }
    n && t.push((0, Lxe.inherits)((0, Nxe.stringLiteral)(n), e));
  }
  s(Fxe, "cleanJSXElementLiteralChild");
});

// ../node_modules/@babel/types/lib/builders/react/buildChildren.js
var l4 = b((o1) => {
  "use strict";
  Object.defineProperty(o1, "__esModule", {
    value: !0
  });
  o1.default = Bxe;
  var a1 = Ri(), Mxe = u4();
  function Bxe(e) {
    let t = [];
    for (let r = 0; r < e.children.length; r++) {
      let i = e.children[r];
      if ((0, a1.isJSXText)(i)) {
        (0, Mxe.default)(i, t);
        continue;
      }
      (0, a1.isJSXExpressionContainer)(i) && (i = i.expression), !(0, a1.isJSXEmptyExpression)(i) && t.push(i);
    }
    return t;
  }
  s(Bxe, "buildChildren");
});

// ../node_modules/@babel/types/lib/validators/isNode.js
var l1 = b((u1) => {
  "use strict";
  Object.defineProperty(u1, "__esModule", {
    value: !0
  });
  u1.default = Uxe;
  var qxe = Sa();
  function Uxe(e) {
    return !!(e && qxe.VISITOR_KEYS[e.type]);
  }
  s(Uxe, "isNode");
});

// ../node_modules/@babel/types/lib/asserts/assertNode.js
var c4 = b((c1) => {
  "use strict";
  Object.defineProperty(c1, "__esModule", {
    value: !0
  });
  c1.default = Vxe;
  var jxe = l1();
  function Vxe(e) {
    if (!(0, jxe.default)(e)) {
      var t;
      let r = (t = e?.type) != null ? t : JSON.stringify(e);
      throw new TypeError(`Not a valid node of type "${r}"`);
    }
  }
  s(Vxe, "assertNode");
});

// ../node_modules/@babel/types/lib/asserts/generated/index.js
var f4 = b((B) => {
  "use strict";
  Object.defineProperty(B, "__esModule", {
    value: !0
  });
  B.assertAccessor = a2e;
  B.assertAnyTypeAnnotation = xCe;
  B.assertArgumentPlaceholder = eDe;
  B.assertArrayExpression = Hxe;
  B.assertArrayPattern = V1e;
  B.assertArrayTypeAnnotation = CCe;
  B.assertArrowFunctionExpression = K1e;
  B.assertAssignmentExpression = zxe;
  B.assertAssignmentPattern = j1e;
  B.assertAwaitExpression = pCe;
  B.assertBigIntLiteral = dCe;
  B.assertBinary = Dwe;
  B.assertBinaryExpression = Gxe;
  B.assertBindExpression = tDe;
  B.assertBlock = kwe;
  B.assertBlockParent = Owe;
  B.assertBlockStatement = Yxe;
  B.assertBooleanLiteral = g1e;
  B.assertBooleanLiteralTypeAnnotation = DCe;
  B.assertBooleanTypeAnnotation = PCe;
  B.assertBreakStatement = Jxe;
  B.assertCallExpression = Qxe;
  B.assertCatchClause = Zxe;
  B.assertClass = r2e;
  B.assertClassAccessorProperty = bCe;
  B.assertClassBody = H1e;
  B.assertClassDeclaration = G1e;
  B.assertClassExpression = z1e;
  B.assertClassImplements = OCe;
  B.assertClassMethod = nCe;
  B.assertClassPrivateMethod = SCe;
  B.assertClassPrivateProperty = vCe;
  B.assertClassProperty = _Ce;
  B.assertCompletionStatement = Nwe;
  B.assertConditional = Lwe;
  B.assertConditionalExpression = e1e;
  B.assertContinueStatement = t1e;
  B.assertDebuggerStatement = r1e;
  B.assertDecimalLiteral = oDe;
  B.assertDeclaration = Hwe;
  B.assertDeclareClass = kCe;
  B.assertDeclareExportAllDeclaration = UCe;
  B.assertDeclareExportDeclaration = qCe;
  B.assertDeclareFunction = ICe;
  B.assertDeclareInterface = RCe;
  B.assertDeclareModule = NCe;
  B.assertDeclareModuleExports = LCe;
  B.assertDeclareOpaqueType = MCe;
  B.assertDeclareTypeAlias = FCe;
  B.assertDeclareVariable = BCe;
  B.assertDeclaredPredicate = jCe;
  B.assertDecorator = rDe;
  B.assertDirective = $xe;
  B.assertDirectiveLiteral = Xxe;
  B.assertDoExpression = iDe;
  B.assertDoWhileStatement = i1e;
  B.assertEmptyStatement = n1e;
  B.assertEmptyTypeAnnotation = QCe;
  B.assertEnumBody = h2e;
  B.assertEnumBooleanBody = CPe;
  B.assertEnumBooleanMember = OPe;
  B.assertEnumDeclaration = xPe;
  B.assertEnumDefaultedMember = RPe;
  B.assertEnumMember = d2e;
  B.assertEnumNumberBody = PPe;
  B.assertEnumNumberMember = kPe;
  B.assertEnumStringBody = DPe;
  B.assertEnumStringMember = IPe;
  B.assertEnumSymbolBody = wPe;
  B.assertExistsTypeAnnotation = VCe;
  B.assertExportAllDeclaration = W1e;
  B.assertExportDeclaration = n2e;
  B.assertExportDefaultDeclaration = $1e;
  B.assertExportDefaultSpecifier = nDe;
  B.assertExportNamedDeclaration = X1e;
  B.assertExportNamespaceSpecifier = mCe;
  B.assertExportSpecifier = Y1e;
  B.assertExpression = Pwe;
  B.assertExpressionStatement = s1e;
  B.assertExpressionWrapper = Bwe;
  B.assertFile = a1e;
  B.assertFlow = u2e;
  B.assertFlowBaseAnnotation = c2e;
  B.assertFlowDeclaration = f2e;
  B.assertFlowPredicate = p2e;
  B.assertFlowType = l2e;
  B.assertFor = qwe;
  B.assertForInStatement = o1e;
  B.assertForOfStatement = J1e;
  B.assertForStatement = u1e;
  B.assertForXStatement = Uwe;
  B.assertFunction = jwe;
  B.assertFunctionDeclaration = l1e;
  B.assertFunctionExpression = c1e;
  B.assertFunctionParent = Vwe;
  B.assertFunctionTypeAnnotation = KCe;
  B.assertFunctionTypeParam = HCe;
  B.assertGenericTypeAnnotation = zCe;
  B.assertIdentifier = f1e;
  B.assertIfStatement = p1e;
  B.assertImmutable = Xwe;
  B.assertImport = hCe;
  B.assertImportAttribute = ACe;
  B.assertImportDeclaration = Q1e;
  B.assertImportDefaultSpecifier = Z1e;
  B.assertImportExpression = rCe;
  B.assertImportNamespaceSpecifier = eCe;
  B.assertImportOrExportDeclaration = i2e;
  B.assertImportSpecifier = tCe;
  B.assertIndexedAccessType = NPe;
  B.assertInferredPredicate = GCe;
  B.assertInterfaceDeclaration = $Ce;
  B.assertInterfaceExtends = WCe;
  B.assertInterfaceTypeAnnotation = XCe;
  B.assertInterpreterDirective = Wxe;
  B.assertIntersectionTypeAnnotation = YCe;
  B.assertJSX = m2e;
  B.assertJSXAttribute = FPe;
  B.assertJSXClosingElement = MPe;
  B.assertJSXClosingFragment = YPe;
  B.assertJSXElement = BPe;
  B.assertJSXEmptyExpression = qPe;
  B.assertJSXExpressionContainer = UPe;
  B.assertJSXFragment = $Pe;
  B.assertJSXIdentifier = VPe;
  B.assertJSXMemberExpression = KPe;
  B.assertJSXNamespacedName = HPe;
  B.assertJSXOpeningElement = zPe;
  B.assertJSXOpeningFragment = XPe;
  B.assertJSXSpreadAttribute = GPe;
  B.assertJSXSpreadChild = jPe;
  B.assertJSXText = WPe;
  B.assertLVal = Gwe;
  B.assertLabeledStatement = h1e;
  B.assertLiteral = $we;
  B.assertLogicalExpression = b1e;
  B.assertLoop = Fwe;
  B.assertMemberExpression = v1e;
  B.assertMetaProperty = iCe;
  B.assertMethod = Jwe;
  B.assertMiscellaneous = y2e;
  B.assertMixedTypeAnnotation = JCe;
  B.assertModuleDeclaration = x2e;
  B.assertModuleExpression = uDe;
  B.assertModuleSpecifier = s2e;
  B.assertNewExpression = S1e;
  B.assertNoop = JPe;
  B.assertNullLiteral = y1e;
  B.assertNullLiteralTypeAnnotation = wCe;
  B.assertNullableTypeAnnotation = ZCe;
  B.assertNumberLiteral = S2e;
  B.assertNumberLiteralTypeAnnotation = ePe;
  B.assertNumberTypeAnnotation = tPe;
  B.assertNumericLiteral = m1e;
  B.assertObjectExpression = E1e;
  B.assertObjectMember = Qwe;
  B.assertObjectMethod = A1e;
  B.assertObjectPattern = sCe;
  B.assertObjectProperty = x1e;
  B.assertObjectTypeAnnotation = rPe;
  B.assertObjectTypeCallProperty = nPe;
  B.assertObjectTypeIndexer = sPe;
  B.assertObjectTypeInternalSlot = iPe;
  B.assertObjectTypeProperty = aPe;
  B.assertObjectTypeSpreadProperty = oPe;
  B.assertOpaqueType = uPe;
  B.assertOptionalCallExpression = gCe;
  B.assertOptionalIndexedAccessType = LPe;
  B.assertOptionalMemberExpression = yCe;
  B.assertParenthesizedExpression = w1e;
  B.assertPattern = t2e;
  B.assertPatternLike = zwe;
  B.assertPipelineBareFunction = fDe;
  B.assertPipelinePrimaryTopicReference = pDe;
  B.assertPipelineTopicExpression = cDe;
  B.assertPlaceholder = QPe;
  B.assertPrivate = o2e;
  B.assertPrivateName = TCe;
  B.assertProgram = T1e;
  B.assertProperty = Zwe;
  B.assertPureish = Kwe;
  B.assertQualifiedTypeIdentifier = lPe;
  B.assertRecordExpression = sDe;
  B.assertRegExpLiteral = _1e;
  B.assertRegexLiteral = T2e;
  B.assertRestElement = C1e;
  B.assertRestProperty = E2e;
  B.assertReturnStatement = P1e;
  B.assertScopable = wwe;
  B.assertSequenceExpression = D1e;
  B.assertSpreadElement = aCe;
  B.assertSpreadProperty = A2e;
  B.assertStandardized = Cwe;
  B.assertStatement = Iwe;
  B.assertStaticBlock = ECe;
  B.assertStringLiteral = d1e;
  B.assertStringLiteralTypeAnnotation = cPe;
  B.assertStringTypeAnnotation = fPe;
  B.assertSuper = oCe;
  B.assertSwitchCase = O1e;
  B.assertSwitchStatement = k1e;
  B.assertSymbolTypeAnnotation = pPe;
  B.assertTSAnyKeyword = TDe;
  B.assertTSArrayType = VDe;
  B.assertTSAsExpression = uwe;
  B.assertTSBaseType = v2e;
  B.assertTSBigIntKeyword = ADe;
  B.assertTSBooleanKeyword = EDe;
  B.assertTSCallSignatureDeclaration = gDe;
  B.assertTSConditionalType = XDe;
  B.assertTSConstructSignatureDeclaration = _De;
  B.assertTSConstructorType = MDe;
  B.assertTSDeclareFunction = dDe;
  B.assertTSDeclareMethod = mDe;
  B.assertTSEntityName = Wwe;
  B.assertTSEnumBody = fwe;
  B.assertTSEnumDeclaration = pwe;
  B.assertTSEnumMember = hwe;
  B.assertTSExportAssignment = vwe;
  B.assertTSExpressionWithTypeArguments = iwe;
  B.assertTSExternalModuleReference = _we;
  B.assertTSFunctionType = FDe;
  B.assertTSImportEqualsDeclaration = gwe;
  B.assertTSImportType = ywe;
  B.assertTSIndexSignature = SDe;
  B.assertTSIndexedAccessType = ZDe;
  B.assertTSInferType = YDe;
  B.assertTSInstantiationExpression = owe;
  B.assertTSInterfaceBody = swe;
  B.assertTSInterfaceDeclaration = nwe;
  B.assertTSIntersectionType = $De;
  B.assertTSIntrinsicKeyword = xDe;
  B.assertTSLiteralType = rwe;
  B.assertTSMappedType = ewe;
  B.assertTSMethodSignature = vDe;
  B.assertTSModuleBlock = mwe;
  B.assertTSModuleDeclaration = dwe;
  B.assertTSNamedTupleMember = GDe;
  B.assertTSNamespaceExportDeclaration = Swe;
  B.assertTSNeverKeyword = CDe;
  B.assertTSNonNullExpression = bwe;
  B.assertTSNullKeyword = PDe;
  B.assertTSNumberKeyword = DDe;
  B.assertTSObjectKeyword = wDe;
  B.assertTSOptionalType = HDe;
  B.assertTSParameterProperty = hDe;
  B.assertTSParenthesizedType = JDe;
  B.assertTSPropertySignature = bDe;
  B.assertTSQualifiedName = yDe;
  B.assertTSRestType = zDe;
  B.assertTSSatisfiesExpression = lwe;
  B.assertTSStringKeyword = ODe;
  B.assertTSSymbolKeyword = kDe;
  B.assertTSTemplateLiteralType = twe;
  B.assertTSThisType = LDe;
  B.assertTSTupleType = KDe;
  B.assertTSType = b2e;
  B.assertTSTypeAliasDeclaration = awe;
  B.assertTSTypeAnnotation = Twe;
  B.assertTSTypeAssertion = cwe;
  B.assertTSTypeElement = _2e;
  B.assertTSTypeLiteral = jDe;
  B.assertTSTypeOperator = QDe;
  B.assertTSTypeParameter = xwe;
  B.assertTSTypeParameterDeclaration = Awe;
  B.assertTSTypeParameterInstantiation = Ewe;
  B.assertTSTypePredicate = qDe;
  B.assertTSTypeQuery = UDe;
  B.assertTSTypeReference = BDe;
  B.assertTSUndefinedKeyword = IDe;
  B.assertTSUnionType = WDe;
  B.assertTSUnknownKeyword = RDe;
  B.assertTSVoidKeyword = NDe;
  B.assertTaggedTemplateExpression = uCe;
  B.assertTemplateElement = lCe;
  B.assertTemplateLiteral = cCe;
  B.assertTerminatorless = Rwe;
  B.assertThisExpression = I1e;
  B.assertThisTypeAnnotation = hPe;
  B.assertThrowStatement = R1e;
  B.assertTopicReference = lDe;
  B.assertTryStatement = N1e;
  B.assertTupleExpression = aDe;
  B.assertTupleTypeAnnotation = dPe;
  B.assertTypeAlias = yPe;
  B.assertTypeAnnotation = gPe;
  B.assertTypeCastExpression = _Pe;
  B.assertTypeParameter = bPe;
  B.assertTypeParameterDeclaration = vPe;
  B.assertTypeParameterInstantiation = SPe;
  B.assertTypeScript = g2e;
  B.assertTypeofTypeAnnotation = mPe;
  B.assertUnaryExpression = L1e;
  B.assertUnaryLike = e2e;
  B.assertUnionTypeAnnotation = TPe;
  B.assertUpdateExpression = F1e;
  B.assertUserWhitespacable = Ywe;
  B.assertV8IntrinsicIdentifier = ZPe;
  B.assertVariableDeclaration = M1e;
  B.assertVariableDeclarator = B1e;
  B.assertVariance = EPe;
  B.assertVoidTypeAnnotation = APe;
  B.assertWhile = Mwe;
  B.assertWhileStatement = q1e;
  B.assertWithStatement = U1e;
  B.assertYieldExpression = fCe;
  var Kxe = Hf(), cd = ed();
  function q(e, t, r) {
    if (!(0, Kxe.default)(e, t, r))
      throw new Error(`Expected type "${e}" with option ${JSON.stringify(r)}, but instead got "${t.type}".`);
  }
  s(q, "assert");
  function Hxe(e, t) {
    q("ArrayExpression", e, t);
  }
  s(Hxe, "assertArrayExpression");
  function zxe(e, t) {
    q("AssignmentExpression", e, t);
  }
  s(zxe, "assertAssignmentExpression");
  function Gxe(e, t) {
    q("BinaryExpression", e, t);
  }
  s(Gxe, "assertBinaryExpression");
  function Wxe(e, t) {
    q("InterpreterDirective", e, t);
  }
  s(Wxe, "assertInterpreterDirective");
  function $xe(e, t) {
    q("Directive", e, t);
  }
  s($xe, "assertDirective");
  function Xxe(e, t) {
    q("DirectiveLiteral", e, t);
  }
  s(Xxe, "assertDirectiveLiteral");
  function Yxe(e, t) {
    q("BlockStatement", e, t);
  }
  s(Yxe, "assertBlockStatement");
  function Jxe(e, t) {
    q("BreakStatement", e, t);
  }
  s(Jxe, "assertBreakStatement");
  function Qxe(e, t) {
    q("CallExpression", e, t);
  }
  s(Qxe, "assertCallExpression");
  function Zxe(e, t) {
    q("CatchClause", e, t);
  }
  s(Zxe, "assertCatchClause");
  function e1e(e, t) {
    q("ConditionalExpression", e, t);
  }
  s(e1e, "assertConditionalExpression");
  function t1e(e, t) {
    q("ContinueStatement", e, t);
  }
  s(t1e, "assertContinueStatement");
  function r1e(e, t) {
    q("DebuggerStatement", e, t);
  }
  s(r1e, "assertDebuggerStatement");
  function i1e(e, t) {
    q("DoWhileStatement", e, t);
  }
  s(i1e, "assertDoWhileStatement");
  function n1e(e, t) {
    q("EmptyStatement", e, t);
  }
  s(n1e, "assertEmptyStatement");
  function s1e(e, t) {
    q("ExpressionStatement", e, t);
  }
  s(s1e, "assertExpressionStatement");
  function a1e(e, t) {
    q("File", e, t);
  }
  s(a1e, "assertFile");
  function o1e(e, t) {
    q("ForInStatement", e, t);
  }
  s(o1e, "assertForInStatement");
  function u1e(e, t) {
    q("ForStatement", e, t);
  }
  s(u1e, "assertForStatement");
  function l1e(e, t) {
    q("FunctionDeclaration", e, t);
  }
  s(l1e, "assertFunctionDeclaration");
  function c1e(e, t) {
    q("FunctionExpression", e, t);
  }
  s(c1e, "assertFunctionExpression");
  function f1e(e, t) {
    q("Identifier", e, t);
  }
  s(f1e, "assertIdentifier");
  function p1e(e, t) {
    q("IfStatement", e, t);
  }
  s(p1e, "assertIfStatement");
  function h1e(e, t) {
    q("LabeledStatement", e, t);
  }
  s(h1e, "assertLabeledStatement");
  function d1e(e, t) {
    q("StringLiteral", e, t);
  }
  s(d1e, "assertStringLiteral");
  function m1e(e, t) {
    q("NumericLiteral", e, t);
  }
  s(m1e, "assertNumericLiteral");
  function y1e(e, t) {
    q("NullLiteral", e, t);
  }
  s(y1e, "assertNullLiteral");
  function g1e(e, t) {
    q("BooleanLiteral", e, t);
  }
  s(g1e, "assertBooleanLiteral");
  function _1e(e, t) {
    q("RegExpLiteral", e, t);
  }
  s(_1e, "assertRegExpLiteral");
  function b1e(e, t) {
    q("LogicalExpression", e, t);
  }
  s(b1e, "assertLogicalExpression");
  function v1e(e, t) {
    q("MemberExpression", e, t);
  }
  s(v1e, "assertMemberExpression");
  function S1e(e, t) {
    q("NewExpression", e, t);
  }
  s(S1e, "assertNewExpression");
  function T1e(e, t) {
    q("Program", e, t);
  }
  s(T1e, "assertProgram");
  function E1e(e, t) {
    q("ObjectExpression", e, t);
  }
  s(E1e, "assertObjectExpression");
  function A1e(e, t) {
    q("ObjectMethod", e, t);
  }
  s(A1e, "assertObjectMethod");
  function x1e(e, t) {
    q("ObjectProperty", e, t);
  }
  s(x1e, "assertObjectProperty");
  function C1e(e, t) {
    q("RestElement", e, t);
  }
  s(C1e, "assertRestElement");
  function P1e(e, t) {
    q("ReturnStatement", e, t);
  }
  s(P1e, "assertReturnStatement");
  function D1e(e, t) {
    q("SequenceExpression", e, t);
  }
  s(D1e, "assertSequenceExpression");
  function w1e(e, t) {
    q("ParenthesizedExpression", e, t);
  }
  s(w1e, "assertParenthesizedExpression");
  function O1e(e, t) {
    q("SwitchCase", e, t);
  }
  s(O1e, "assertSwitchCase");
  function k1e(e, t) {
    q("SwitchStatement", e, t);
  }
  s(k1e, "assertSwitchStatement");
  function I1e(e, t) {
    q("ThisExpression", e, t);
  }
  s(I1e, "assertThisExpression");
  function R1e(e, t) {
    q("ThrowStatement", e, t);
  }
  s(R1e, "assertThrowStatement");
  function N1e(e, t) {
    q("TryStatement", e, t);
  }
  s(N1e, "assertTryStatement");
  function L1e(e, t) {
    q("UnaryExpression", e, t);
  }
  s(L1e, "assertUnaryExpression");
  function F1e(e, t) {
    q("UpdateExpression", e, t);
  }
  s(F1e, "assertUpdateExpression");
  function M1e(e, t) {
    q("VariableDeclaration", e, t);
  }
  s(M1e, "assertVariableDeclaration");
  function B1e(e, t) {
    q("VariableDeclarator", e, t);
  }
  s(B1e, "assertVariableDeclarator");
  function q1e(e, t) {
    q("WhileStatement", e, t);
  }
  s(q1e, "assertWhileStatement");
  function U1e(e, t) {
    q("WithStatement", e, t);
  }
  s(U1e, "assertWithStatement");
  function j1e(e, t) {
    q("AssignmentPattern", e, t);
  }
  s(j1e, "assertAssignmentPattern");
  function V1e(e, t) {
    q("ArrayPattern", e, t);
  }
  s(V1e, "assertArrayPattern");
  function K1e(e, t) {
    q("ArrowFunctionExpression", e, t);
  }
  s(K1e, "assertArrowFunctionExpression");
  function H1e(e, t) {
    q("ClassBody", e, t);
  }
  s(H1e, "assertClassBody");
  function z1e(e, t) {
    q("ClassExpression", e, t);
  }
  s(z1e, "assertClassExpression");
  function G1e(e, t) {
    q("ClassDeclaration", e, t);
  }
  s(G1e, "assertClassDeclaration");
  function W1e(e, t) {
    q("ExportAllDeclaration", e, t);
  }
  s(W1e, "assertExportAllDeclaration");
  function $1e(e, t) {
    q("ExportDefaultDeclaration", e, t);
  }
  s($1e, "assertExportDefaultDeclaration");
  function X1e(e, t) {
    q("ExportNamedDeclaration", e, t);
  }
  s(X1e, "assertExportNamedDeclaration");
  function Y1e(e, t) {
    q("ExportSpecifier", e, t);
  }
  s(Y1e, "assertExportSpecifier");
  function J1e(e, t) {
    q("ForOfStatement", e, t);
  }
  s(J1e, "assertForOfStatement");
  function Q1e(e, t) {
    q("ImportDeclaration", e, t);
  }
  s(Q1e, "assertImportDeclaration");
  function Z1e(e, t) {
    q("ImportDefaultSpecifier", e, t);
  }
  s(Z1e, "assertImportDefaultSpecifier");
  function eCe(e, t) {
    q("ImportNamespaceSpecifier", e, t);
  }
  s(eCe, "assertImportNamespaceSpecifier");
  function tCe(e, t) {
    q("ImportSpecifier", e, t);
  }
  s(tCe, "assertImportSpecifier");
  function rCe(e, t) {
    q("ImportExpression", e, t);
  }
  s(rCe, "assertImportExpression");
  function iCe(e, t) {
    q("MetaProperty", e, t);
  }
  s(iCe, "assertMetaProperty");
  function nCe(e, t) {
    q("ClassMethod", e, t);
  }
  s(nCe, "assertClassMethod");
  function sCe(e, t) {
    q("ObjectPattern", e, t);
  }
  s(sCe, "assertObjectPattern");
  function aCe(e, t) {
    q("SpreadElement", e, t);
  }
  s(aCe, "assertSpreadElement");
  function oCe(e, t) {
    q("Super", e, t);
  }
  s(oCe, "assertSuper");
  function uCe(e, t) {
    q("TaggedTemplateExpression", e, t);
  }
  s(uCe, "assertTaggedTemplateExpression");
  function lCe(e, t) {
    q("TemplateElement", e, t);
  }
  s(lCe, "assertTemplateElement");
  function cCe(e, t) {
    q("TemplateLiteral", e, t);
  }
  s(cCe, "assertTemplateLiteral");
  function fCe(e, t) {
    q("YieldExpression", e, t);
  }
  s(fCe, "assertYieldExpression");
  function pCe(e, t) {
    q("AwaitExpression", e, t);
  }
  s(pCe, "assertAwaitExpression");
  function hCe(e, t) {
    q("Import", e, t);
  }
  s(hCe, "assertImport");
  function dCe(e, t) {
    q("BigIntLiteral", e, t);
  }
  s(dCe, "assertBigIntLiteral");
  function mCe(e, t) {
    q("ExportNamespaceSpecifier", e, t);
  }
  s(mCe, "assertExportNamespaceSpecifier");
  function yCe(e, t) {
    q("OptionalMemberExpression", e, t);
  }
  s(yCe, "assertOptionalMemberExpression");
  function gCe(e, t) {
    q("OptionalCallExpression", e, t);
  }
  s(gCe, "assertOptionalCallExpression");
  function _Ce(e, t) {
    q("ClassProperty", e, t);
  }
  s(_Ce, "assertClassProperty");
  function bCe(e, t) {
    q("ClassAccessorProperty", e, t);
  }
  s(bCe, "assertClassAccessorProperty");
  function vCe(e, t) {
    q("ClassPrivateProperty", e, t);
  }
  s(vCe, "assertClassPrivateProperty");
  function SCe(e, t) {
    q("ClassPrivateMethod", e, t);
  }
  s(SCe, "assertClassPrivateMethod");
  function TCe(e, t) {
    q("PrivateName", e, t);
  }
  s(TCe, "assertPrivateName");
  function ECe(e, t) {
    q("StaticBlock", e, t);
  }
  s(ECe, "assertStaticBlock");
  function ACe(e, t) {
    q("ImportAttribute", e, t);
  }
  s(ACe, "assertImportAttribute");
  function xCe(e, t) {
    q("AnyTypeAnnotation", e, t);
  }
  s(xCe, "assertAnyTypeAnnotation");
  function CCe(e, t) {
    q("ArrayTypeAnnotation", e, t);
  }
  s(CCe, "assertArrayTypeAnnotation");
  function PCe(e, t) {
    q("BooleanTypeAnnotation", e, t);
  }
  s(PCe, "assertBooleanTypeAnnotation");
  function DCe(e, t) {
    q("BooleanLiteralTypeAnnotation", e, t);
  }
  s(DCe, "assertBooleanLiteralTypeAnnotation");
  function wCe(e, t) {
    q("NullLiteralTypeAnnotation", e, t);
  }
  s(wCe, "assertNullLiteralTypeAnnotation");
  function OCe(e, t) {
    q("ClassImplements", e, t);
  }
  s(OCe, "assertClassImplements");
  function kCe(e, t) {
    q("DeclareClass", e, t);
  }
  s(kCe, "assertDeclareClass");
  function ICe(e, t) {
    q("DeclareFunction", e, t);
  }
  s(ICe, "assertDeclareFunction");
  function RCe(e, t) {
    q("DeclareInterface", e, t);
  }
  s(RCe, "assertDeclareInterface");
  function NCe(e, t) {
    q("DeclareModule", e, t);
  }
  s(NCe, "assertDeclareModule");
  function LCe(e, t) {
    q("DeclareModuleExports", e, t);
  }
  s(LCe, "assertDeclareModuleExports");
  function FCe(e, t) {
    q("DeclareTypeAlias", e, t);
  }
  s(FCe, "assertDeclareTypeAlias");
  function MCe(e, t) {
    q("DeclareOpaqueType", e, t);
  }
  s(MCe, "assertDeclareOpaqueType");
  function BCe(e, t) {
    q("DeclareVariable", e, t);
  }
  s(BCe, "assertDeclareVariable");
  function qCe(e, t) {
    q("DeclareExportDeclaration", e, t);
  }
  s(qCe, "assertDeclareExportDeclaration");
  function UCe(e, t) {
    q("DeclareExportAllDeclaration", e, t);
  }
  s(UCe, "assertDeclareExportAllDeclaration");
  function jCe(e, t) {
    q("DeclaredPredicate", e, t);
  }
  s(jCe, "assertDeclaredPredicate");
  function VCe(e, t) {
    q("ExistsTypeAnnotation", e, t);
  }
  s(VCe, "assertExistsTypeAnnotation");
  function KCe(e, t) {
    q("FunctionTypeAnnotation", e, t);
  }
  s(KCe, "assertFunctionTypeAnnotation");
  function HCe(e, t) {
    q("FunctionTypeParam", e, t);
  }
  s(HCe, "assertFunctionTypeParam");
  function zCe(e, t) {
    q("GenericTypeAnnotation", e, t);
  }
  s(zCe, "assertGenericTypeAnnotation");
  function GCe(e, t) {
    q("InferredPredicate", e, t);
  }
  s(GCe, "assertInferredPredicate");
  function WCe(e, t) {
    q("InterfaceExtends", e, t);
  }
  s(WCe, "assertInterfaceExtends");
  function $Ce(e, t) {
    q("InterfaceDeclaration", e, t);
  }
  s($Ce, "assertInterfaceDeclaration");
  function XCe(e, t) {
    q("InterfaceTypeAnnotation", e, t);
  }
  s(XCe, "assertInterfaceTypeAnnotation");
  function YCe(e, t) {
    q("IntersectionTypeAnnotation", e, t);
  }
  s(YCe, "assertIntersectionTypeAnnotation");
  function JCe(e, t) {
    q("MixedTypeAnnotation", e, t);
  }
  s(JCe, "assertMixedTypeAnnotation");
  function QCe(e, t) {
    q("EmptyTypeAnnotation", e, t);
  }
  s(QCe, "assertEmptyTypeAnnotation");
  function ZCe(e, t) {
    q("NullableTypeAnnotation", e, t);
  }
  s(ZCe, "assertNullableTypeAnnotation");
  function ePe(e, t) {
    q("NumberLiteralTypeAnnotation", e, t);
  }
  s(ePe, "assertNumberLiteralTypeAnnotation");
  function tPe(e, t) {
    q("NumberTypeAnnotation", e, t);
  }
  s(tPe, "assertNumberTypeAnnotation");
  function rPe(e, t) {
    q("ObjectTypeAnnotation", e, t);
  }
  s(rPe, "assertObjectTypeAnnotation");
  function iPe(e, t) {
    q("ObjectTypeInternalSlot", e, t);
  }
  s(iPe, "assertObjectTypeInternalSlot");
  function nPe(e, t) {
    q("ObjectTypeCallProperty", e, t);
  }
  s(nPe, "assertObjectTypeCallProperty");
  function sPe(e, t) {
    q("ObjectTypeIndexer", e, t);
  }
  s(sPe, "assertObjectTypeIndexer");
  function aPe(e, t) {
    q("ObjectTypeProperty", e, t);
  }
  s(aPe, "assertObjectTypeProperty");
  function oPe(e, t) {
    q("ObjectTypeSpreadProperty", e, t);
  }
  s(oPe, "assertObjectTypeSpreadProperty");
  function uPe(e, t) {
    q("OpaqueType", e, t);
  }
  s(uPe, "assertOpaqueType");
  function lPe(e, t) {
    q("QualifiedTypeIdentifier", e, t);
  }
  s(lPe, "assertQualifiedTypeIdentifier");
  function cPe(e, t) {
    q("StringLiteralTypeAnnotation", e, t);
  }
  s(cPe, "assertStringLiteralTypeAnnotation");
  function fPe(e, t) {
    q("StringTypeAnnotation", e, t);
  }
  s(fPe, "assertStringTypeAnnotation");
  function pPe(e, t) {
    q("SymbolTypeAnnotation", e, t);
  }
  s(pPe, "assertSymbolTypeAnnotation");
  function hPe(e, t) {
    q("ThisTypeAnnotation", e, t);
  }
  s(hPe, "assertThisTypeAnnotation");
  function dPe(e, t) {
    q("TupleTypeAnnotation", e, t);
  }
  s(dPe, "assertTupleTypeAnnotation");
  function mPe(e, t) {
    q("TypeofTypeAnnotation", e, t);
  }
  s(mPe, "assertTypeofTypeAnnotation");
  function yPe(e, t) {
    q("TypeAlias", e, t);
  }
  s(yPe, "assertTypeAlias");
  function gPe(e, t) {
    q("TypeAnnotation", e, t);
  }
  s(gPe, "assertTypeAnnotation");
  function _Pe(e, t) {
    q("TypeCastExpression", e, t);
  }
  s(_Pe, "assertTypeCastExpression");
  function bPe(e, t) {
    q("TypeParameter", e, t);
  }
  s(bPe, "assertTypeParameter");
  function vPe(e, t) {
    q("TypeParameterDeclaration", e, t);
  }
  s(vPe, "assertTypeParameterDeclaration");
  function SPe(e, t) {
    q("TypeParameterInstantiation", e, t);
  }
  s(SPe, "assertTypeParameterInstantiation");
  function TPe(e, t) {
    q("UnionTypeAnnotation", e, t);
  }
  s(TPe, "assertUnionTypeAnnotation");
  function EPe(e, t) {
    q("Variance", e, t);
  }
  s(EPe, "assertVariance");
  function APe(e, t) {
    q("VoidTypeAnnotation", e, t);
  }
  s(APe, "assertVoidTypeAnnotation");
  function xPe(e, t) {
    q("EnumDeclaration", e, t);
  }
  s(xPe, "assertEnumDeclaration");
  function CPe(e, t) {
    q("EnumBooleanBody", e, t);
  }
  s(CPe, "assertEnumBooleanBody");
  function PPe(e, t) {
    q("EnumNumberBody", e, t);
  }
  s(PPe, "assertEnumNumberBody");
  function DPe(e, t) {
    q("EnumStringBody", e, t);
  }
  s(DPe, "assertEnumStringBody");
  function wPe(e, t) {
    q("EnumSymbolBody", e, t);
  }
  s(wPe, "assertEnumSymbolBody");
  function OPe(e, t) {
    q("EnumBooleanMember", e, t);
  }
  s(OPe, "assertEnumBooleanMember");
  function kPe(e, t) {
    q("EnumNumberMember", e, t);
  }
  s(kPe, "assertEnumNumberMember");
  function IPe(e, t) {
    q("EnumStringMember", e, t);
  }
  s(IPe, "assertEnumStringMember");
  function RPe(e, t) {
    q("EnumDefaultedMember", e, t);
  }
  s(RPe, "assertEnumDefaultedMember");
  function NPe(e, t) {
    q("IndexedAccessType", e, t);
  }
  s(NPe, "assertIndexedAccessType");
  function LPe(e, t) {
    q("OptionalIndexedAccessType", e, t);
  }
  s(LPe, "assertOptionalIndexedAccessType");
  function FPe(e, t) {
    q("JSXAttribute", e, t);
  }
  s(FPe, "assertJSXAttribute");
  function MPe(e, t) {
    q("JSXClosingElement", e, t);
  }
  s(MPe, "assertJSXClosingElement");
  function BPe(e, t) {
    q("JSXElement", e, t);
  }
  s(BPe, "assertJSXElement");
  function qPe(e, t) {
    q("JSXEmptyExpression", e, t);
  }
  s(qPe, "assertJSXEmptyExpression");
  function UPe(e, t) {
    q("JSXExpressionContainer", e, t);
  }
  s(UPe, "assertJSXExpressionContainer");
  function jPe(e, t) {
    q("JSXSpreadChild", e, t);
  }
  s(jPe, "assertJSXSpreadChild");
  function VPe(e, t) {
    q("JSXIdentifier", e, t);
  }
  s(VPe, "assertJSXIdentifier");
  function KPe(e, t) {
    q("JSXMemberExpression", e, t);
  }
  s(KPe, "assertJSXMemberExpression");
  function HPe(e, t) {
    q("JSXNamespacedName", e, t);
  }
  s(HPe, "assertJSXNamespacedName");
  function zPe(e, t) {
    q("JSXOpeningElement", e, t);
  }
  s(zPe, "assertJSXOpeningElement");
  function GPe(e, t) {
    q("JSXSpreadAttribute", e, t);
  }
  s(GPe, "assertJSXSpreadAttribute");
  function WPe(e, t) {
    q("JSXText", e, t);
  }
  s(WPe, "assertJSXText");
  function $Pe(e, t) {
    q("JSXFragment", e, t);
  }
  s($Pe, "assertJSXFragment");
  function XPe(e, t) {
    q("JSXOpeningFragment", e, t);
  }
  s(XPe, "assertJSXOpeningFragment");
  function YPe(e, t) {
    q("JSXClosingFragment", e, t);
  }
  s(YPe, "assertJSXClosingFragment");
  function JPe(e, t) {
    q("Noop", e, t);
  }
  s(JPe, "assertNoop");
  function QPe(e, t) {
    q("Placeholder", e, t);
  }
  s(QPe, "assertPlaceholder");
  function ZPe(e, t) {
    q("V8IntrinsicIdentifier", e, t);
  }
  s(ZPe, "assertV8IntrinsicIdentifier");
  function eDe(e, t) {
    q("ArgumentPlaceholder", e, t);
  }
  s(eDe, "assertArgumentPlaceholder");
  function tDe(e, t) {
    q("BindExpression", e, t);
  }
  s(tDe, "assertBindExpression");
  function rDe(e, t) {
    q("Decorator", e, t);
  }
  s(rDe, "assertDecorator");
  function iDe(e, t) {
    q("DoExpression", e, t);
  }
  s(iDe, "assertDoExpression");
  function nDe(e, t) {
    q("ExportDefaultSpecifier", e, t);
  }
  s(nDe, "assertExportDefaultSpecifier");
  function sDe(e, t) {
    q("RecordExpression", e, t);
  }
  s(sDe, "assertRecordExpression");
  function aDe(e, t) {
    q("TupleExpression", e, t);
  }
  s(aDe, "assertTupleExpression");
  function oDe(e, t) {
    q("DecimalLiteral", e, t);
  }
  s(oDe, "assertDecimalLiteral");
  function uDe(e, t) {
    q("ModuleExpression", e, t);
  }
  s(uDe, "assertModuleExpression");
  function lDe(e, t) {
    q("TopicReference", e, t);
  }
  s(lDe, "assertTopicReference");
  function cDe(e, t) {
    q("PipelineTopicExpression", e, t);
  }
  s(cDe, "assertPipelineTopicExpression");
  function fDe(e, t) {
    q("PipelineBareFunction", e, t);
  }
  s(fDe, "assertPipelineBareFunction");
  function pDe(e, t) {
    q("PipelinePrimaryTopicReference", e, t);
  }
  s(pDe, "assertPipelinePrimaryTopicReference");
  function hDe(e, t) {
    q("TSParameterProperty", e, t);
  }
  s(hDe, "assertTSParameterProperty");
  function dDe(e, t) {
    q("TSDeclareFunction", e, t);
  }
  s(dDe, "assertTSDeclareFunction");
  function mDe(e, t) {
    q("TSDeclareMethod", e, t);
  }
  s(mDe, "assertTSDeclareMethod");
  function yDe(e, t) {
    q("TSQualifiedName", e, t);
  }
  s(yDe, "assertTSQualifiedName");
  function gDe(e, t) {
    q("TSCallSignatureDeclaration", e, t);
  }
  s(gDe, "assertTSCallSignatureDeclaration");
  function _De(e, t) {
    q("TSConstructSignatureDeclaration", e, t);
  }
  s(_De, "assertTSConstructSignatureDeclaration");
  function bDe(e, t) {
    q("TSPropertySignature", e, t);
  }
  s(bDe, "assertTSPropertySignature");
  function vDe(e, t) {
    q("TSMethodSignature", e, t);
  }
  s(vDe, "assertTSMethodSignature");
  function SDe(e, t) {
    q("TSIndexSignature", e, t);
  }
  s(SDe, "assertTSIndexSignature");
  function TDe(e, t) {
    q("TSAnyKeyword", e, t);
  }
  s(TDe, "assertTSAnyKeyword");
  function EDe(e, t) {
    q("TSBooleanKeyword", e, t);
  }
  s(EDe, "assertTSBooleanKeyword");
  function ADe(e, t) {
    q("TSBigIntKeyword", e, t);
  }
  s(ADe, "assertTSBigIntKeyword");
  function xDe(e, t) {
    q("TSIntrinsicKeyword", e, t);
  }
  s(xDe, "assertTSIntrinsicKeyword");
  function CDe(e, t) {
    q("TSNeverKeyword", e, t);
  }
  s(CDe, "assertTSNeverKeyword");
  function PDe(e, t) {
    q("TSNullKeyword", e, t);
  }
  s(PDe, "assertTSNullKeyword");
  function DDe(e, t) {
    q("TSNumberKeyword", e, t);
  }
  s(DDe, "assertTSNumberKeyword");
  function wDe(e, t) {
    q("TSObjectKeyword", e, t);
  }
  s(wDe, "assertTSObjectKeyword");
  function ODe(e, t) {
    q("TSStringKeyword", e, t);
  }
  s(ODe, "assertTSStringKeyword");
  function kDe(e, t) {
    q("TSSymbolKeyword", e, t);
  }
  s(kDe, "assertTSSymbolKeyword");
  function IDe(e, t) {
    q("TSUndefinedKeyword", e, t);
  }
  s(IDe, "assertTSUndefinedKeyword");
  function RDe(e, t) {
    q("TSUnknownKeyword", e, t);
  }
  s(RDe, "assertTSUnknownKeyword");
  function NDe(e, t) {
    q("TSVoidKeyword", e, t);
  }
  s(NDe, "assertTSVoidKeyword");
  function LDe(e, t) {
    q("TSThisType", e, t);
  }
  s(LDe, "assertTSThisType");
  function FDe(e, t) {
    q("TSFunctionType", e, t);
  }
  s(FDe, "assertTSFunctionType");
  function MDe(e, t) {
    q("TSConstructorType", e, t);
  }
  s(MDe, "assertTSConstructorType");
  function BDe(e, t) {
    q("TSTypeReference", e, t);
  }
  s(BDe, "assertTSTypeReference");
  function qDe(e, t) {
    q("TSTypePredicate", e, t);
  }
  s(qDe, "assertTSTypePredicate");
  function UDe(e, t) {
    q("TSTypeQuery", e, t);
  }
  s(UDe, "assertTSTypeQuery");
  function jDe(e, t) {
    q("TSTypeLiteral", e, t);
  }
  s(jDe, "assertTSTypeLiteral");
  function VDe(e, t) {
    q("TSArrayType", e, t);
  }
  s(VDe, "assertTSArrayType");
  function KDe(e, t) {
    q("TSTupleType", e, t);
  }
  s(KDe, "assertTSTupleType");
  function HDe(e, t) {
    q("TSOptionalType", e, t);
  }
  s(HDe, "assertTSOptionalType");
  function zDe(e, t) {
    q("TSRestType", e, t);
  }
  s(zDe, "assertTSRestType");
  function GDe(e, t) {
    q("TSNamedTupleMember", e, t);
  }
  s(GDe, "assertTSNamedTupleMember");
  function WDe(e, t) {
    q("TSUnionType", e, t);
  }
  s(WDe, "assertTSUnionType");
  function $De(e, t) {
    q("TSIntersectionType", e, t);
  }
  s($De, "assertTSIntersectionType");
  function XDe(e, t) {
    q("TSConditionalType", e, t);
  }
  s(XDe, "assertTSConditionalType");
  function YDe(e, t) {
    q("TSInferType", e, t);
  }
  s(YDe, "assertTSInferType");
  function JDe(e, t) {
    q("TSParenthesizedType", e, t);
  }
  s(JDe, "assertTSParenthesizedType");
  function QDe(e, t) {
    q("TSTypeOperator", e, t);
  }
  s(QDe, "assertTSTypeOperator");
  function ZDe(e, t) {
    q("TSIndexedAccessType", e, t);
  }
  s(ZDe, "assertTSIndexedAccessType");
  function ewe(e, t) {
    q("TSMappedType", e, t);
  }
  s(ewe, "assertTSMappedType");
  function twe(e, t) {
    q("TSTemplateLiteralType", e, t);
  }
  s(twe, "assertTSTemplateLiteralType");
  function rwe(e, t) {
    q("TSLiteralType", e, t);
  }
  s(rwe, "assertTSLiteralType");
  function iwe(e, t) {
    q("TSExpressionWithTypeArguments", e, t);
  }
  s(iwe, "assertTSExpressionWithTypeArguments");
  function nwe(e, t) {
    q("TSInterfaceDeclaration", e, t);
  }
  s(nwe, "assertTSInterfaceDeclaration");
  function swe(e, t) {
    q("TSInterfaceBody", e, t);
  }
  s(swe, "assertTSInterfaceBody");
  function awe(e, t) {
    q("TSTypeAliasDeclaration", e, t);
  }
  s(awe, "assertTSTypeAliasDeclaration");
  function owe(e, t) {
    q("TSInstantiationExpression", e, t);
  }
  s(owe, "assertTSInstantiationExpression");
  function uwe(e, t) {
    q("TSAsExpression", e, t);
  }
  s(uwe, "assertTSAsExpression");
  function lwe(e, t) {
    q("TSSatisfiesExpression", e, t);
  }
  s(lwe, "assertTSSatisfiesExpression");
  function cwe(e, t) {
    q("TSTypeAssertion", e, t);
  }
  s(cwe, "assertTSTypeAssertion");
  function fwe(e, t) {
    q("TSEnumBody", e, t);
  }
  s(fwe, "assertTSEnumBody");
  function pwe(e, t) {
    q("TSEnumDeclaration", e, t);
  }
  s(pwe, "assertTSEnumDeclaration");
  function hwe(e, t) {
    q("TSEnumMember", e, t);
  }
  s(hwe, "assertTSEnumMember");
  function dwe(e, t) {
    q("TSModuleDeclaration", e, t);
  }
  s(dwe, "assertTSModuleDeclaration");
  function mwe(e, t) {
    q("TSModuleBlock", e, t);
  }
  s(mwe, "assertTSModuleBlock");
  function ywe(e, t) {
    q("TSImportType", e, t);
  }
  s(ywe, "assertTSImportType");
  function gwe(e, t) {
    q("TSImportEqualsDeclaration", e, t);
  }
  s(gwe, "assertTSImportEqualsDeclaration");
  function _we(e, t) {
    q("TSExternalModuleReference", e, t);
  }
  s(_we, "assertTSExternalModuleReference");
  function bwe(e, t) {
    q("TSNonNullExpression", e, t);
  }
  s(bwe, "assertTSNonNullExpression");
  function vwe(e, t) {
    q("TSExportAssignment", e, t);
  }
  s(vwe, "assertTSExportAssignment");
  function Swe(e, t) {
    q("TSNamespaceExportDeclaration", e, t);
  }
  s(Swe, "assertTSNamespaceExportDeclaration");
  function Twe(e, t) {
    q("TSTypeAnnotation", e, t);
  }
  s(Twe, "assertTSTypeAnnotation");
  function Ewe(e, t) {
    q("TSTypeParameterInstantiation", e, t);
  }
  s(Ewe, "assertTSTypeParameterInstantiation");
  function Awe(e, t) {
    q("TSTypeParameterDeclaration", e, t);
  }
  s(Awe, "assertTSTypeParameterDeclaration");
  function xwe(e, t) {
    q("TSTypeParameter", e, t);
  }
  s(xwe, "assertTSTypeParameter");
  function Cwe(e, t) {
    q("Standardized", e, t);
  }
  s(Cwe, "assertStandardized");
  function Pwe(e, t) {
    q("Expression", e, t);
  }
  s(Pwe, "assertExpression");
  function Dwe(e, t) {
    q("Binary", e, t);
  }
  s(Dwe, "assertBinary");
  function wwe(e, t) {
    q("Scopable", e, t);
  }
  s(wwe, "assertScopable");
  function Owe(e, t) {
    q("BlockParent", e, t);
  }
  s(Owe, "assertBlockParent");
  function kwe(e, t) {
    q("Block", e, t);
  }
  s(kwe, "assertBlock");
  function Iwe(e, t) {
    q("Statement", e, t);
  }
  s(Iwe, "assertStatement");
  function Rwe(e, t) {
    q("Terminatorless", e, t);
  }
  s(Rwe, "assertTerminatorless");
  function Nwe(e, t) {
    q("CompletionStatement", e, t);
  }
  s(Nwe, "assertCompletionStatement");
  function Lwe(e, t) {
    q("Conditional", e, t);
  }
  s(Lwe, "assertConditional");
  function Fwe(e, t) {
    q("Loop", e, t);
  }
  s(Fwe, "assertLoop");
  function Mwe(e, t) {
    q("While", e, t);
  }
  s(Mwe, "assertWhile");
  function Bwe(e, t) {
    q("ExpressionWrapper", e, t);
  }
  s(Bwe, "assertExpressionWrapper");
  function qwe(e, t) {
    q("For", e, t);
  }
  s(qwe, "assertFor");
  function Uwe(e, t) {
    q("ForXStatement", e, t);
  }
  s(Uwe, "assertForXStatement");
  function jwe(e, t) {
    q("Function", e, t);
  }
  s(jwe, "assertFunction");
  function Vwe(e, t) {
    q("FunctionParent", e, t);
  }
  s(Vwe, "assertFunctionParent");
  function Kwe(e, t) {
    q("Pureish", e, t);
  }
  s(Kwe, "assertPureish");
  function Hwe(e, t) {
    q("Declaration", e, t);
  }
  s(Hwe, "assertDeclaration");
  function zwe(e, t) {
    q("PatternLike", e, t);
  }
  s(zwe, "assertPatternLike");
  function Gwe(e, t) {
    q("LVal", e, t);
  }
  s(Gwe, "assertLVal");
  function Wwe(e, t) {
    q("TSEntityName", e, t);
  }
  s(Wwe, "assertTSEntityName");
  function $we(e, t) {
    q("Literal", e, t);
  }
  s($we, "assertLiteral");
  function Xwe(e, t) {
    q("Immutable", e, t);
  }
  s(Xwe, "assertImmutable");
  function Ywe(e, t) {
    q("UserWhitespacable", e, t);
  }
  s(Ywe, "assertUserWhitespacable");
  function Jwe(e, t) {
    q("Method", e, t);
  }
  s(Jwe, "assertMethod");
  function Qwe(e, t) {
    q("ObjectMember", e, t);
  }
  s(Qwe, "assertObjectMember");
  function Zwe(e, t) {
    q("Property", e, t);
  }
  s(Zwe, "assertProperty");
  function e2e(e, t) {
    q("UnaryLike", e, t);
  }
  s(e2e, "assertUnaryLike");
  function t2e(e, t) {
    q("Pattern", e, t);
  }
  s(t2e, "assertPattern");
  function r2e(e, t) {
    q("Class", e, t);
  }
  s(r2e, "assertClass");
  function i2e(e, t) {
    q("ImportOrExportDeclaration", e, t);
  }
  s(i2e, "assertImportOrExportDeclaration");
  function n2e(e, t) {
    q("ExportDeclaration", e, t);
  }
  s(n2e, "assertExportDeclaration");
  function s2e(e, t) {
    q("ModuleSpecifier", e, t);
  }
  s(s2e, "assertModuleSpecifier");
  function a2e(e, t) {
    q("Accessor", e, t);
  }
  s(a2e, "assertAccessor");
  function o2e(e, t) {
    q("Private", e, t);
  }
  s(o2e, "assertPrivate");
  function u2e(e, t) {
    q("Flow", e, t);
  }
  s(u2e, "assertFlow");
  function l2e(e, t) {
    q("FlowType", e, t);
  }
  s(l2e, "assertFlowType");
  function c2e(e, t) {
    q("FlowBaseAnnotation", e, t);
  }
  s(c2e, "assertFlowBaseAnnotation");
  function f2e(e, t) {
    q("FlowDeclaration", e, t);
  }
  s(f2e, "assertFlowDeclaration");
  function p2e(e, t) {
    q("FlowPredicate", e, t);
  }
  s(p2e, "assertFlowPredicate");
  function h2e(e, t) {
    q("EnumBody", e, t);
  }
  s(h2e, "assertEnumBody");
  function d2e(e, t) {
    q("EnumMember", e, t);
  }
  s(d2e, "assertEnumMember");
  function m2e(e, t) {
    q("JSX", e, t);
  }
  s(m2e, "assertJSX");
  function y2e(e, t) {
    q("Miscellaneous", e, t);
  }
  s(y2e, "assertMiscellaneous");
  function g2e(e, t) {
    q("TypeScript", e, t);
  }
  s(g2e, "assertTypeScript");
  function _2e(e, t) {
    q("TSTypeElement", e, t);
  }
  s(_2e, "assertTSTypeElement");
  function b2e(e, t) {
    q("TSType", e, t);
  }
  s(b2e, "assertTSType");
  function v2e(e, t) {
    q("TSBaseType", e, t);
  }
  s(v2e, "assertTSBaseType");
  function S2e(e, t) {
    (0, cd.default)("assertNumberLiteral", "assertNumericLiteral"), q("NumberLiteral", e, t);
  }
  s(S2e, "assertNumberLiteral");
  function T2e(e, t) {
    (0, cd.default)("assertRegexLiteral", "assertRegExpLiteral"), q("RegexLiteral", e, t);
  }
  s(T2e, "assertRegexLiteral");
  function E2e(e, t) {
    (0, cd.default)("assertRestProperty", "assertRestElement"), q("RestProperty", e, t);
  }
  s(E2e, "assertRestProperty");
  function A2e(e, t) {
    (0, cd.default)("assertSpreadProperty", "assertSpreadElement"), q("SpreadProperty", e, t);
  }
  s(A2e, "assertSpreadProperty");
  function x2e(e, t) {
    (0, cd.default)("assertModuleDeclaration", "assertImportOrExportDeclaration"), q("ModuleDeclaration", e, t);
  }
  s(x2e, "assertModuleDeclaration");
});

// ../node_modules/@babel/types/lib/builders/flow/createTypeAnnotationBasedOnTypeof.js
var p4 = b((p_) => {
  "use strict";
  Object.defineProperty(p_, "__esModule", {
    value: !0
  });
  p_.default = void 0;
  var za = Ns(), QTt = p_.default = C2e;
  function C2e(e) {
    switch (e) {
      case "string":
        return (0, za.stringTypeAnnotation)();
      case "number":
        return (0, za.numberTypeAnnotation)();
      case "undefined":
        return (0, za.voidTypeAnnotation)();
      case "boolean":
        return (0, za.booleanTypeAnnotation)();
      case "function":
        return (0, za.genericTypeAnnotation)((0, za.identifier)("Function"));
      case "object":
        return (0, za.genericTypeAnnotation)((0, za.identifier)("Object"));
      case "symbol":
        return (0, za.genericTypeAnnotation)((0, za.identifier)("Symbol"));
      case "bigint":
        return (0, za.anyTypeAnnotation)();
    }
    throw new Error("Invalid typeof value: " + e);
  }
  s(C2e, "createTypeAnnotationBasedOnTypeof");
});

// ../node_modules/@babel/types/lib/modifications/flow/removeTypeDuplicates.js
var p1 = b((f1) => {
  "use strict";
  Object.defineProperty(f1, "__esModule", {
    value: !0
  });
  f1.default = d4;
  var fd = Ri();
  function h4(e) {
    return (0, fd.isIdentifier)(e) ? e.name : `${e.id.name}.${h4(e.qualification)}`;
  }
  s(h4, "getQualifiedName");
  function d4(e) {
    let t = Array.from(e), r = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Set(), a = [];
    for (let o = 0; o < t.length; o++) {
      let u = t[o];
      if (u && !a.includes(u)) {
        if ((0, fd.isAnyTypeAnnotation)(u))
          return [u];
        if ((0, fd.isFlowBaseAnnotation)(u)) {
          i.set(u.type, u);
          continue;
        }
        if ((0, fd.isUnionTypeAnnotation)(u)) {
          n.has(u.types) || (t.push(...u.types), n.add(u.types));
          continue;
        }
        if ((0, fd.isGenericTypeAnnotation)(u)) {
          let l = h4(u.id);
          if (r.has(l)) {
            let c = r.get(l);
            c.typeParameters ? u.typeParameters && (c.typeParameters.params.push(...u.typeParameters.params), c.typeParameters.params = d4(c.
            typeParameters.params)) : c = u.typeParameters;
          } else
            r.set(l, u);
          continue;
        }
        a.push(u);
      }
    }
    for (let [, o] of i)
      a.push(o);
    for (let [, o] of r)
      a.push(o);
    return a;
  }
  s(d4, "removeTypeDuplicates");
});

// ../node_modules/@babel/types/lib/builders/flow/createFlowUnionType.js
var m4 = b((h1) => {
  "use strict";
  Object.defineProperty(h1, "__esModule", {
    value: !0
  });
  h1.default = w2e;
  var P2e = Ns(), D2e = p1();
  function w2e(e) {
    let t = (0, D2e.default)(e);
    return t.length === 1 ? t[0] : (0, P2e.unionTypeAnnotation)(t);
  }
  s(w2e, "createFlowUnionType");
});

// ../node_modules/@babel/types/lib/modifications/typescript/removeTypeDuplicates.js
var _4 = b((d1) => {
  "use strict";
  Object.defineProperty(d1, "__esModule", {
    value: !0
  });
  d1.default = g4;
  var Yf = Ri();
  function y4(e) {
    return (0, Yf.isIdentifier)(e) ? e.name : (0, Yf.isThisExpression)(e) ? "this" : `${e.right.name}.${y4(e.left)}`;
  }
  s(y4, "getQualifiedName");
  function g4(e) {
    let t = Array.from(e), r = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Set(), a = [];
    for (let o = 0; o < t.length; o++) {
      let u = t[o];
      if (!u || a.includes(u))
        continue;
      if ((0, Yf.isTSAnyKeyword)(u))
        return [u];
      if ((0, Yf.isTSBaseType)(u)) {
        i.set(u.type, u);
        continue;
      }
      if ((0, Yf.isTSUnionType)(u)) {
        n.has(u.types) || (t.push(...u.types), n.add(u.types));
        continue;
      }
      let l = "typeParameters";
      if ((0, Yf.isTSTypeReference)(u) && u[l]) {
        let c = u[l], p = y4(u.typeName);
        if (r.has(p)) {
          let h = r.get(p), y = h[l];
          y ? (y.params.push(...c.params), y.params = g4(y.params)) : h = c;
        } else
          r.set(p, u);
        continue;
      }
      a.push(u);
    }
    for (let [, o] of i)
      a.push(o);
    for (let [, o] of r)
      a.push(o);
    return a;
  }
  s(g4, "removeTypeDuplicates");
});

// ../node_modules/@babel/types/lib/builders/typescript/createTSUnionType.js
var b4 = b((m1) => {
  "use strict";
  Object.defineProperty(m1, "__esModule", {
    value: !0
  });
  m1.default = R2e;
  var O2e = Ns(), k2e = _4(), I2e = Ri();
  function R2e(e) {
    let t = e.map((i) => (0, I2e.isTSTypeAnnotation)(i) ? i.typeAnnotation : i), r = (0, k2e.default)(t);
    return r.length === 1 ? r[0] : (0, O2e.tsUnionType)(r);
  }
  s(R2e, "createTSUnionType");
});

// ../node_modules/@babel/types/lib/builders/productions.js
var g1 = b((y1) => {
  "use strict";
  Object.defineProperty(y1, "__esModule", {
    value: !0
  });
  y1.buildUndefinedNode = N2e;
  var v4 = Ns();
  function N2e() {
    return (0, v4.unaryExpression)("void", (0, v4.numericLiteral)(0), !0);
  }
  s(N2e, "buildUndefinedNode");
});

// ../node_modules/@babel/types/lib/clone/cloneNode.js
var ll = b((b1) => {
  "use strict";
  Object.defineProperty(b1, "__esModule", {
    value: !0
  });
  b1.default = L2e;
  var S4 = Sa(), T4 = Ri(), {
    hasOwn: Ro
  } = {
    hasOwn: Function.call.bind(Object.prototype.hasOwnProperty)
  };
  function E4(e, t, r, i) {
    return e && typeof e.type == "string" ? A4(e, t, r, i) : e;
  }
  s(E4, "cloneIfNode");
  function _1(e, t, r, i) {
    return Array.isArray(e) ? e.map((n) => E4(n, t, r, i)) : E4(e, t, r, i);
  }
  s(_1, "cloneIfNodeOrArray");
  function L2e(e, t = !0, r = !1) {
    return A4(e, t, r, /* @__PURE__ */ new Map());
  }
  s(L2e, "cloneNode");
  function A4(e, t = !0, r = !1, i) {
    if (!e) return e;
    let {
      type: n
    } = e, a = {
      type: e.type
    };
    if ((0, T4.isIdentifier)(e))
      a.name = e.name, Ro(e, "optional") && typeof e.optional == "boolean" && (a.optional = e.optional), Ro(e, "typeAnnotation") && (a.typeAnnotation =
      t ? _1(e.typeAnnotation, !0, r, i) : e.typeAnnotation), Ro(e, "decorators") && (a.decorators = t ? _1(e.decorators, !0, r, i) : e.decorators);
    else if (Ro(S4.NODE_FIELDS, n))
      for (let o of Object.keys(S4.NODE_FIELDS[n]))
        Ro(e, o) && (t ? a[o] = (0, T4.isFile)(e) && o === "comments" ? h_(e.comments, t, r, i) : _1(e[o], !0, r, i) : a[o] = e[o]);
    else
      throw new Error(`Unknown node type: "${n}"`);
    return Ro(e, "loc") && (r ? a.loc = null : a.loc = e.loc), Ro(e, "leadingComments") && (a.leadingComments = h_(e.leadingComments, t, r, i)),
    Ro(e, "innerComments") && (a.innerComments = h_(e.innerComments, t, r, i)), Ro(e, "trailingComments") && (a.trailingComments = h_(e.trailingComments,
    t, r, i)), Ro(e, "extra") && (a.extra = Object.assign({}, e.extra)), a;
  }
  s(A4, "cloneNodeInternal");
  function h_(e, t, r, i) {
    return !e || !t ? e : e.map((n) => {
      let a = i.get(n);
      if (a) return a;
      let {
        type: o,
        value: u,
        loc: l
      } = n, c = {
        type: o,
        value: u,
        loc: l
      };
      return r && (c.loc = null), i.set(n, c), c;
    });
  }
  s(h_, "maybeCloneComments");
});

// ../node_modules/@babel/types/lib/clone/clone.js
var x4 = b((v1) => {
  "use strict";
  Object.defineProperty(v1, "__esModule", {
    value: !0
  });
  v1.default = M2e;
  var F2e = ll();
  function M2e(e) {
    return (0, F2e.default)(e, !1);
  }
  s(M2e, "clone");
});

// ../node_modules/@babel/types/lib/clone/cloneDeep.js
var C4 = b((S1) => {
  "use strict";
  Object.defineProperty(S1, "__esModule", {
    value: !0
  });
  S1.default = q2e;
  var B2e = ll();
  function q2e(e) {
    return (0, B2e.default)(e);
  }
  s(q2e, "cloneDeep");
});

// ../node_modules/@babel/types/lib/clone/cloneDeepWithoutLoc.js
var P4 = b((T1) => {
  "use strict";
  Object.defineProperty(T1, "__esModule", {
    value: !0
  });
  T1.default = j2e;
  var U2e = ll();
  function j2e(e) {
    return (0, U2e.default)(e, !0, !0);
  }
  s(j2e, "cloneDeepWithoutLoc");
});

// ../node_modules/@babel/types/lib/clone/cloneWithoutLoc.js
var D4 = b((E1) => {
  "use strict";
  Object.defineProperty(E1, "__esModule", {
    value: !0
  });
  E1.default = K2e;
  var V2e = ll();
  function K2e(e) {
    return (0, V2e.default)(e, !1, !0);
  }
  s(K2e, "cloneWithoutLoc");
});

// ../node_modules/@babel/types/lib/comments/addComments.js
var x1 = b((A1) => {
  "use strict";
  Object.defineProperty(A1, "__esModule", {
    value: !0
  });
  A1.default = H2e;
  function H2e(e, t, r) {
    if (!r || !e) return e;
    let i = `${t}Comments`;
    return e[i] ? t === "leading" ? e[i] = r.concat(e[i]) : e[i].push(...r) : e[i] = r, e;
  }
  s(H2e, "addComments");
});

// ../node_modules/@babel/types/lib/comments/addComment.js
var w4 = b((C1) => {
  "use strict";
  Object.defineProperty(C1, "__esModule", {
    value: !0
  });
  C1.default = G2e;
  var z2e = x1();
  function G2e(e, t, r, i) {
    return (0, z2e.default)(e, t, [{
      type: i ? "CommentLine" : "CommentBlock",
      value: r
    }]);
  }
  s(G2e, "addComment");
});

// ../node_modules/@babel/types/lib/utils/inherit.js
var d_ = b((P1) => {
  "use strict";
  Object.defineProperty(P1, "__esModule", {
    value: !0
  });
  P1.default = W2e;
  function W2e(e, t, r) {
    t && r && (t[e] = Array.from(new Set([].concat(t[e], r[e]).filter(Boolean))));
  }
  s(W2e, "inherit");
});

// ../node_modules/@babel/types/lib/comments/inheritInnerComments.js
var w1 = b((D1) => {
  "use strict";
  Object.defineProperty(D1, "__esModule", {
    value: !0
  });
  D1.default = X2e;
  var $2e = d_();
  function X2e(e, t) {
    (0, $2e.default)("innerComments", e, t);
  }
  s(X2e, "inheritInnerComments");
});

// ../node_modules/@babel/types/lib/comments/inheritLeadingComments.js
var k1 = b((O1) => {
  "use strict";
  Object.defineProperty(O1, "__esModule", {
    value: !0
  });
  O1.default = J2e;
  var Y2e = d_();
  function J2e(e, t) {
    (0, Y2e.default)("leadingComments", e, t);
  }
  s(J2e, "inheritLeadingComments");
});

// ../node_modules/@babel/types/lib/comments/inheritTrailingComments.js
var R1 = b((I1) => {
  "use strict";
  Object.defineProperty(I1, "__esModule", {
    value: !0
  });
  I1.default = Z2e;
  var Q2e = d_();
  function Z2e(e, t) {
    (0, Q2e.default)("trailingComments", e, t);
  }
  s(Z2e, "inheritTrailingComments");
});

// ../node_modules/@babel/types/lib/comments/inheritsComments.js
var L1 = b((N1) => {
  "use strict";
  Object.defineProperty(N1, "__esModule", {
    value: !0
  });
  N1.default = iOe;
  var eOe = R1(), tOe = k1(), rOe = w1();
  function iOe(e, t) {
    return (0, eOe.default)(e, t), (0, tOe.default)(e, t), (0, rOe.default)(e, t), e;
  }
  s(iOe, "inheritsComments");
});

// ../node_modules/@babel/types/lib/comments/removeComments.js
var O4 = b((F1) => {
  "use strict";
  Object.defineProperty(F1, "__esModule", {
    value: !0
  });
  F1.default = sOe;
  var nOe = Gf();
  function sOe(e) {
    return nOe.COMMENT_KEYS.forEach((t) => {
      e[t] = null;
    }), e;
  }
  s(sOe, "removeComments");
});

// ../node_modules/@babel/types/lib/constants/generated/index.js
var k4 = b((De) => {
  "use strict";
  Object.defineProperty(De, "__esModule", {
    value: !0
  });
  De.WHILE_TYPES = De.USERWHITESPACABLE_TYPES = De.UNARYLIKE_TYPES = De.TYPESCRIPT_TYPES = De.TSTYPE_TYPES = De.TSTYPEELEMENT_TYPES = De.TSENTITYNAME_TYPES =
  De.TSBASETYPE_TYPES = De.TERMINATORLESS_TYPES = De.STATEMENT_TYPES = De.STANDARDIZED_TYPES = De.SCOPABLE_TYPES = De.PUREISH_TYPES = De.PROPERTY_TYPES =
  De.PRIVATE_TYPES = De.PATTERN_TYPES = De.PATTERNLIKE_TYPES = De.OBJECTMEMBER_TYPES = De.MODULESPECIFIER_TYPES = De.MODULEDECLARATION_TYPES =
  De.MISCELLANEOUS_TYPES = De.METHOD_TYPES = De.LVAL_TYPES = De.LOOP_TYPES = De.LITERAL_TYPES = De.JSX_TYPES = De.IMPORTOREXPORTDECLARATION_TYPES =
  De.IMMUTABLE_TYPES = De.FUNCTION_TYPES = De.FUNCTIONPARENT_TYPES = De.FOR_TYPES = De.FORXSTATEMENT_TYPES = De.FLOW_TYPES = De.FLOWTYPE_TYPES =
  De.FLOWPREDICATE_TYPES = De.FLOWDECLARATION_TYPES = De.FLOWBASEANNOTATION_TYPES = De.EXPRESSION_TYPES = De.EXPRESSIONWRAPPER_TYPES = De.EXPORTDECLARATION_TYPES =
  De.ENUMMEMBER_TYPES = De.ENUMBODY_TYPES = De.DECLARATION_TYPES = De.CONDITIONAL_TYPES = De.COMPLETIONSTATEMENT_TYPES = De.CLASS_TYPES = De.
  BLOCK_TYPES = De.BLOCKPARENT_TYPES = De.BINARY_TYPES = De.ACCESSOR_TYPES = void 0;
  var xt = Sa(), MEt = De.STANDARDIZED_TYPES = xt.FLIPPED_ALIAS_KEYS.Standardized, BEt = De.EXPRESSION_TYPES = xt.FLIPPED_ALIAS_KEYS.Expression,
  qEt = De.BINARY_TYPES = xt.FLIPPED_ALIAS_KEYS.Binary, UEt = De.SCOPABLE_TYPES = xt.FLIPPED_ALIAS_KEYS.Scopable, jEt = De.BLOCKPARENT_TYPES =
  xt.FLIPPED_ALIAS_KEYS.BlockParent, VEt = De.BLOCK_TYPES = xt.FLIPPED_ALIAS_KEYS.Block, KEt = De.STATEMENT_TYPES = xt.FLIPPED_ALIAS_KEYS.Statement,
  HEt = De.TERMINATORLESS_TYPES = xt.FLIPPED_ALIAS_KEYS.Terminatorless, zEt = De.COMPLETIONSTATEMENT_TYPES = xt.FLIPPED_ALIAS_KEYS.CompletionStatement,
  GEt = De.CONDITIONAL_TYPES = xt.FLIPPED_ALIAS_KEYS.Conditional, WEt = De.LOOP_TYPES = xt.FLIPPED_ALIAS_KEYS.Loop, $Et = De.WHILE_TYPES = xt.
  FLIPPED_ALIAS_KEYS.While, XEt = De.EXPRESSIONWRAPPER_TYPES = xt.FLIPPED_ALIAS_KEYS.ExpressionWrapper, YEt = De.FOR_TYPES = xt.FLIPPED_ALIAS_KEYS.
  For, JEt = De.FORXSTATEMENT_TYPES = xt.FLIPPED_ALIAS_KEYS.ForXStatement, QEt = De.FUNCTION_TYPES = xt.FLIPPED_ALIAS_KEYS.Function, ZEt = De.
  FUNCTIONPARENT_TYPES = xt.FLIPPED_ALIAS_KEYS.FunctionParent, eAt = De.PUREISH_TYPES = xt.FLIPPED_ALIAS_KEYS.Pureish, tAt = De.DECLARATION_TYPES =
  xt.FLIPPED_ALIAS_KEYS.Declaration, rAt = De.PATTERNLIKE_TYPES = xt.FLIPPED_ALIAS_KEYS.PatternLike, iAt = De.LVAL_TYPES = xt.FLIPPED_ALIAS_KEYS.
  LVal, nAt = De.TSENTITYNAME_TYPES = xt.FLIPPED_ALIAS_KEYS.TSEntityName, sAt = De.LITERAL_TYPES = xt.FLIPPED_ALIAS_KEYS.Literal, aAt = De.IMMUTABLE_TYPES =
  xt.FLIPPED_ALIAS_KEYS.Immutable, oAt = De.USERWHITESPACABLE_TYPES = xt.FLIPPED_ALIAS_KEYS.UserWhitespacable, uAt = De.METHOD_TYPES = xt.FLIPPED_ALIAS_KEYS.
  Method, lAt = De.OBJECTMEMBER_TYPES = xt.FLIPPED_ALIAS_KEYS.ObjectMember, cAt = De.PROPERTY_TYPES = xt.FLIPPED_ALIAS_KEYS.Property, fAt = De.
  UNARYLIKE_TYPES = xt.FLIPPED_ALIAS_KEYS.UnaryLike, pAt = De.PATTERN_TYPES = xt.FLIPPED_ALIAS_KEYS.Pattern, hAt = De.CLASS_TYPES = xt.FLIPPED_ALIAS_KEYS.
  Class, aOe = De.IMPORTOREXPORTDECLARATION_TYPES = xt.FLIPPED_ALIAS_KEYS.ImportOrExportDeclaration, dAt = De.EXPORTDECLARATION_TYPES = xt.FLIPPED_ALIAS_KEYS.
  ExportDeclaration, mAt = De.MODULESPECIFIER_TYPES = xt.FLIPPED_ALIAS_KEYS.ModuleSpecifier, yAt = De.ACCESSOR_TYPES = xt.FLIPPED_ALIAS_KEYS.
  Accessor, gAt = De.PRIVATE_TYPES = xt.FLIPPED_ALIAS_KEYS.Private, _At = De.FLOW_TYPES = xt.FLIPPED_ALIAS_KEYS.Flow, bAt = De.FLOWTYPE_TYPES =
  xt.FLIPPED_ALIAS_KEYS.FlowType, vAt = De.FLOWBASEANNOTATION_TYPES = xt.FLIPPED_ALIAS_KEYS.FlowBaseAnnotation, SAt = De.FLOWDECLARATION_TYPES =
  xt.FLIPPED_ALIAS_KEYS.FlowDeclaration, TAt = De.FLOWPREDICATE_TYPES = xt.FLIPPED_ALIAS_KEYS.FlowPredicate, EAt = De.ENUMBODY_TYPES = xt.FLIPPED_ALIAS_KEYS.
  EnumBody, AAt = De.ENUMMEMBER_TYPES = xt.FLIPPED_ALIAS_KEYS.EnumMember, xAt = De.JSX_TYPES = xt.FLIPPED_ALIAS_KEYS.JSX, CAt = De.MISCELLANEOUS_TYPES =
  xt.FLIPPED_ALIAS_KEYS.Miscellaneous, PAt = De.TYPESCRIPT_TYPES = xt.FLIPPED_ALIAS_KEYS.TypeScript, DAt = De.TSTYPEELEMENT_TYPES = xt.FLIPPED_ALIAS_KEYS.
  TSTypeElement, wAt = De.TSTYPE_TYPES = xt.FLIPPED_ALIAS_KEYS.TSType, OAt = De.TSBASETYPE_TYPES = xt.FLIPPED_ALIAS_KEYS.TSBaseType, kAt = De.
  MODULEDECLARATION_TYPES = aOe;
});

// ../node_modules/@babel/types/lib/converters/toBlock.js
var q1 = b((B1) => {
  "use strict";
  Object.defineProperty(B1, "__esModule", {
    value: !0
  });
  B1.default = oOe;
  var m_ = Ri(), M1 = Ns();
  function oOe(e, t) {
    if ((0, m_.isBlockStatement)(e))
      return e;
    let r = [];
    return (0, m_.isEmptyStatement)(e) ? r = [] : ((0, m_.isStatement)(e) || ((0, m_.isFunction)(t) ? e = (0, M1.returnStatement)(e) : e = (0, M1.
    expressionStatement)(e)), r = [e]), (0, M1.blockStatement)(r);
  }
  s(oOe, "toBlock");
});

// ../node_modules/@babel/types/lib/converters/ensureBlock.js
var I4 = b((U1) => {
  "use strict";
  Object.defineProperty(U1, "__esModule", {
    value: !0
  });
  U1.default = lOe;
  var uOe = q1();
  function lOe(e, t = "body") {
    let r = (0, uOe.default)(e[t], e);
    return e[t] = r, r;
  }
  s(lOe, "ensureBlock");
});

// ../node_modules/@babel/types/lib/converters/toIdentifier.js
var V1 = b((j1) => {
  "use strict";
  Object.defineProperty(j1, "__esModule", {
    value: !0
  });
  j1.default = pOe;
  var cOe = zf(), fOe = r_();
  function pOe(e) {
    e = e + "";
    let t = "";
    for (let r of e)
      t += (0, fOe.isIdentifierChar)(r.codePointAt(0)) ? r : "-";
    return t = t.replace(/^[-0-9]+/, ""), t = t.replace(/[-\s]+(.)?/g, function(r, i) {
      return i ? i.toUpperCase() : "";
    }), (0, cOe.default)(t) || (t = `_${t}`), t || "_";
  }
  s(pOe, "toIdentifier");
});

// ../node_modules/@babel/types/lib/converters/toBindingIdentifierName.js
var R4 = b((K1) => {
  "use strict";
  Object.defineProperty(K1, "__esModule", {
    value: !0
  });
  K1.default = dOe;
  var hOe = V1();
  function dOe(e) {
    return e = (0, hOe.default)(e), (e === "eval" || e === "arguments") && (e = "_" + e), e;
  }
  s(dOe, "toBindingIdentifierName");
});

// ../node_modules/@babel/types/lib/converters/toComputedKey.js
var N4 = b((H1) => {
  "use strict";
  Object.defineProperty(H1, "__esModule", {
    value: !0
  });
  H1.default = gOe;
  var mOe = Ri(), yOe = Ns();
  function gOe(e, t = e.key || e.property) {
    return !e.computed && (0, mOe.isIdentifier)(t) && (t = (0, yOe.stringLiteral)(t.name)), t;
  }
  s(gOe, "toComputedKey");
});

// ../node_modules/@babel/types/lib/converters/toExpression.js
var L4 = b((y_) => {
  "use strict";
  Object.defineProperty(y_, "__esModule", {
    value: !0
  });
  y_.default = void 0;
  var pd = Ri(), KAt = y_.default = _Oe;
  function _Oe(e) {
    if ((0, pd.isExpressionStatement)(e) && (e = e.expression), (0, pd.isExpression)(e))
      return e;
    if ((0, pd.isClass)(e) ? e.type = "ClassExpression" : (0, pd.isFunction)(e) && (e.type = "FunctionExpression"), !(0, pd.isExpression)(e))
      throw new Error(`cannot turn ${e.type} to an expression`);
    return e;
  }
  s(_Oe, "toExpression");
});

// ../node_modules/@babel/types/lib/traverse/traverseFast.js
var G1 = b((z1) => {
  "use strict";
  Object.defineProperty(z1, "__esModule", {
    value: !0
  });
  z1.default = hd;
  var bOe = Sa(), F4 = Symbol(), M4 = Symbol();
  function hd(e, t, r) {
    if (!e) return !1;
    let i = bOe.VISITOR_KEYS[e.type];
    if (!i) return !1;
    r = r || {};
    let n = t(e, r);
    if (n !== void 0)
      switch (n) {
        case F4:
          return !1;
        case M4:
          return !0;
      }
    for (let a of i) {
      let o = e[a];
      if (o) {
        if (Array.isArray(o)) {
          for (let u of o)
            if (hd(u, t, r)) return !0;
        } else if (hd(o, t, r)) return !0;
      }
    }
    return !1;
  }
  s(hd, "traverseFast");
  hd.skip = F4;
  hd.stop = M4;
});

// ../node_modules/@babel/types/lib/modifications/removeProperties.js
var $1 = b((W1) => {
  "use strict";
  Object.defineProperty(W1, "__esModule", {
    value: !0
  });
  W1.default = TOe;
  var vOe = Gf(), B4 = ["tokens", "start", "end", "loc", "raw", "rawValue"], SOe = [...vOe.COMMENT_KEYS, "comments", ...B4];
  function TOe(e, t = {}) {
    let r = t.preserveComments ? B4 : SOe;
    for (let n of r)
      e[n] != null && (e[n] = void 0);
    for (let n of Object.keys(e))
      n[0] === "_" && e[n] != null && (e[n] = void 0);
    let i = Object.getOwnPropertySymbols(e);
    for (let n of i)
      e[n] = null;
  }
  s(TOe, "removeProperties");
});

// ../node_modules/@babel/types/lib/modifications/removePropertiesDeep.js
var Y1 = b((X1) => {
  "use strict";
  Object.defineProperty(X1, "__esModule", {
    value: !0
  });
  X1.default = xOe;
  var EOe = G1(), AOe = $1();
  function xOe(e, t) {
    return (0, EOe.default)(e, AOe.default, t), e;
  }
  s(xOe, "removePropertiesDeep");
});

// ../node_modules/@babel/types/lib/converters/toKeyAlias.js
var U4 = b((J1) => {
  "use strict";
  Object.defineProperty(J1, "__esModule", {
    value: !0
  });
  J1.default = lc;
  var q4 = Ri(), COe = ll(), POe = Y1();
  function lc(e, t = e.key) {
    let r;
    return e.kind === "method" ? lc.increment() + "" : ((0, q4.isIdentifier)(t) ? r = t.name : (0, q4.isStringLiteral)(t) ? r = JSON.stringify(
    t.value) : r = JSON.stringify((0, POe.default)((0, COe.default)(t))), e.computed && (r = `[${r}]`), e.static && (r = `static:${r}`), r);
  }
  s(lc, "toKeyAlias");
  lc.uid = 0;
  lc.increment = function() {
    return lc.uid >= Number.MAX_SAFE_INTEGER ? lc.uid = 0 : lc.uid++;
  };
});

// ../node_modules/@babel/types/lib/converters/toStatement.js
var j4 = b((__) => {
  "use strict";
  Object.defineProperty(__, "__esModule", {
    value: !0
  });
  __.default = void 0;
  var g_ = Ri(), DOe = Ns(), ext = __.default = wOe;
  function wOe(e, t) {
    if ((0, g_.isStatement)(e))
      return e;
    let r = !1, i;
    if ((0, g_.isClass)(e))
      r = !0, i = "ClassDeclaration";
    else if ((0, g_.isFunction)(e))
      r = !0, i = "FunctionDeclaration";
    else if ((0, g_.isAssignmentExpression)(e))
      return (0, DOe.expressionStatement)(e);
    if (r && !e.id && (i = !1), !i) {
      if (t)
        return !1;
      throw new Error(`cannot turn ${e.type} to a statement`);
    }
    return e.type = i, e;
  }
  s(wOe, "toStatement");
});

// ../node_modules/@babel/types/lib/converters/valueToNode.js
var V4 = b((b_) => {
  "use strict";
  Object.defineProperty(b_, "__esModule", {
    value: !0
  });
  b_.default = void 0;
  var OOe = zf(), vn = Ns(), ixt = b_.default = Q1, kOe = Function.call.bind(Object.prototype.toString);
  function IOe(e) {
    return kOe(e) === "[object RegExp]";
  }
  s(IOe, "isRegExp");
  function ROe(e) {
    if (typeof e != "object" || e === null || Object.prototype.toString.call(e) !== "[object Object]")
      return !1;
    let t = Object.getPrototypeOf(e);
    return t === null || Object.getPrototypeOf(t) === null;
  }
  s(ROe, "isPlainObject");
  function Q1(e) {
    if (e === void 0)
      return (0, vn.identifier)("undefined");
    if (e === !0 || e === !1)
      return (0, vn.booleanLiteral)(e);
    if (e === null)
      return (0, vn.nullLiteral)();
    if (typeof e == "string")
      return (0, vn.stringLiteral)(e);
    if (typeof e == "number") {
      let t;
      if (Number.isFinite(e))
        t = (0, vn.numericLiteral)(Math.abs(e));
      else {
        let r;
        Number.isNaN(e) ? r = (0, vn.numericLiteral)(0) : r = (0, vn.numericLiteral)(1), t = (0, vn.binaryExpression)("/", r, (0, vn.numericLiteral)(
        0));
      }
      return (e < 0 || Object.is(e, -0)) && (t = (0, vn.unaryExpression)("-", t)), t;
    }
    if (typeof e == "bigint")
      return (0, vn.bigIntLiteral)(e.toString());
    if (IOe(e)) {
      let t = e.source, r = /\/([a-z]*)$/.exec(e.toString())[1];
      return (0, vn.regExpLiteral)(t, r);
    }
    if (Array.isArray(e))
      return (0, vn.arrayExpression)(e.map(Q1));
    if (ROe(e)) {
      let t = [];
      for (let r of Object.keys(e)) {
        let i, n = !1;
        (0, OOe.default)(r) ? r === "__proto__" ? (n = !0, i = (0, vn.stringLiteral)(r)) : i = (0, vn.identifier)(r) : i = (0, vn.stringLiteral)(
        r), t.push((0, vn.objectProperty)(i, Q1(e[r]), n));
      }
      return (0, vn.objectExpression)(t);
    }
    throw new Error("don't know how to turn this value into a node");
  }
  s(Q1, "valueToNode");
});

// ../node_modules/@babel/types/lib/modifications/appendToMemberExpression.js
var K4 = b((Z1) => {
  "use strict";
  Object.defineProperty(Z1, "__esModule", {
    value: !0
  });
  Z1.default = LOe;
  var NOe = Ns();
  function LOe(e, t, r = !1) {
    return e.object = (0, NOe.memberExpression)(e.object, e.property, e.computed), e.property = t, e.computed = !!r, e;
  }
  s(LOe, "appendToMemberExpression");
});

// ../node_modules/@babel/types/lib/modifications/inherits.js
var z4 = b((eC) => {
  "use strict";
  Object.defineProperty(eC, "__esModule", {
    value: !0
  });
  eC.default = MOe;
  var H4 = Gf(), FOe = L1();
  function MOe(e, t) {
    if (!e || !t) return e;
    for (let r of H4.INHERIT_KEYS.optional)
      e[r] == null && (e[r] = t[r]);
    for (let r of Object.keys(t))
      r[0] === "_" && r !== "__clone" && (e[r] = t[r]);
    for (let r of H4.INHERIT_KEYS.force)
      e[r] = t[r];
    return (0, FOe.default)(e, t), e;
  }
  s(MOe, "inherits");
});

// ../node_modules/@babel/types/lib/modifications/prependToMemberExpression.js
var G4 = b((tC) => {
  "use strict";
  Object.defineProperty(tC, "__esModule", {
    value: !0
  });
  tC.default = UOe;
  var BOe = Ns(), qOe = Xn();
  function UOe(e, t) {
    if ((0, qOe.isSuper)(e.object))
      throw new Error("Cannot prepend node to super property access (`super.foo`).");
    return e.object = (0, BOe.memberExpression)(t, e.object), e;
  }
  s(UOe, "prependToMemberExpression");
});

// ../node_modules/@babel/types/lib/retrievers/getAssignmentIdentifiers.js
var W4 = b((rC) => {
  "use strict";
  Object.defineProperty(rC, "__esModule", {
    value: !0
  });
  rC.default = jOe;
  function jOe(e) {
    let t = [].concat(e), r = /* @__PURE__ */ Object.create(null);
    for (; t.length; ) {
      let i = t.pop();
      if (i)
        switch (i.type) {
          case "ArrayPattern":
            t.push(...i.elements);
            break;
          case "AssignmentExpression":
          case "AssignmentPattern":
          case "ForInStatement":
          case "ForOfStatement":
            t.push(i.left);
            break;
          case "ObjectPattern":
            t.push(...i.properties);
            break;
          case "ObjectProperty":
            t.push(i.value);
            break;
          case "RestElement":
          case "UpdateExpression":
            t.push(i.argument);
            break;
          case "UnaryExpression":
            i.operator === "delete" && t.push(i.argument);
            break;
          case "Identifier":
            r[i.name] = i;
            break;
          default:
            break;
        }
    }
    return r;
  }
  s(jOe, "getAssignmentIdentifiers");
});

// ../node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js
var dd = b((nC) => {
  "use strict";
  Object.defineProperty(nC, "__esModule", {
    value: !0
  });
  nC.default = iC;
  var yu = Ri();
  function iC(e, t, r, i) {
    let n = [].concat(e), a = /* @__PURE__ */ Object.create(null);
    for (; n.length; ) {
      let o = n.shift();
      if (!o || i && ((0, yu.isAssignmentExpression)(o) || (0, yu.isUnaryExpression)(o) || (0, yu.isUpdateExpression)(o)))
        continue;
      if ((0, yu.isIdentifier)(o)) {
        t ? (a[o.name] = a[o.name] || []).push(o) : a[o.name] = o;
        continue;
      }
      if ((0, yu.isExportDeclaration)(o) && !(0, yu.isExportAllDeclaration)(o)) {
        (0, yu.isDeclaration)(o.declaration) && n.push(o.declaration);
        continue;
      }
      if (r) {
        if ((0, yu.isFunctionDeclaration)(o)) {
          n.push(o.id);
          continue;
        }
        if ((0, yu.isFunctionExpression)(o))
          continue;
      }
      let u = iC.keys[o.type];
      if (u)
        for (let l = 0; l < u.length; l++) {
          let c = u[l], p = o[c];
          p && (Array.isArray(p) ? n.push(...p) : n.push(p));
        }
    }
    return a;
  }
  s(iC, "getBindingIdentifiers");
  var VOe = {
    DeclareClass: ["id"],
    DeclareFunction: ["id"],
    DeclareModule: ["id"],
    DeclareVariable: ["id"],
    DeclareInterface: ["id"],
    DeclareTypeAlias: ["id"],
    DeclareOpaqueType: ["id"],
    InterfaceDeclaration: ["id"],
    TypeAlias: ["id"],
    OpaqueType: ["id"],
    CatchClause: ["param"],
    LabeledStatement: ["label"],
    UnaryExpression: ["argument"],
    AssignmentExpression: ["left"],
    ImportSpecifier: ["local"],
    ImportNamespaceSpecifier: ["local"],
    ImportDefaultSpecifier: ["local"],
    ImportDeclaration: ["specifiers"],
    TSImportEqualsDeclaration: ["id"],
    ExportSpecifier: ["exported"],
    ExportNamespaceSpecifier: ["exported"],
    ExportDefaultSpecifier: ["exported"],
    FunctionDeclaration: ["id", "params"],
    FunctionExpression: ["id", "params"],
    ArrowFunctionExpression: ["params"],
    ObjectMethod: ["params"],
    ClassMethod: ["params"],
    ClassPrivateMethod: ["params"],
    ForInStatement: ["left"],
    ForOfStatement: ["left"],
    ClassDeclaration: ["id"],
    ClassExpression: ["id"],
    RestElement: ["argument"],
    UpdateExpression: ["argument"],
    ObjectProperty: ["value"],
    AssignmentPattern: ["left"],
    ArrayPattern: ["elements"],
    ObjectPattern: ["properties"],
    VariableDeclaration: ["declarations"],
    VariableDeclarator: ["id"]
  };
  iC.keys = VOe;
});

// ../node_modules/@babel/types/lib/retrievers/getOuterBindingIdentifiers.js
var $4 = b((v_) => {
  "use strict";
  Object.defineProperty(v_, "__esModule", {
    value: !0
  });
  v_.default = void 0;
  var KOe = dd(), yxt = v_.default = HOe;
  function HOe(e, t) {
    return (0, KOe.default)(e, t, !0);
  }
  s(HOe, "getOuterBindingIdentifiers");
});

// ../node_modules/@babel/types/lib/retrievers/getFunctionName.js
var Y4 = b((sC) => {
  "use strict";
  Object.defineProperty(sC, "__esModule", {
    value: !0
  });
  sC.default = GOe;
  var Ta = Ri();
  function zOe(e) {
    return (0, Ta.isNullLiteral)(e) ? "null" : (0, Ta.isRegExpLiteral)(e) ? `/${e.pattern}/${e.flags}` : (0, Ta.isTemplateLiteral)(e) ? e.quasis.
    map((t) => t.value.raw).join("") : e.value !== void 0 ? String(e.value) : null;
  }
  s(zOe, "getNameFromLiteralId");
  function X4(e) {
    if (!e.computed || (0, Ta.isLiteral)(e.key))
      return e.key;
  }
  s(X4, "getObjectMemberKey");
  function GOe(e, t) {
    if ("id" in e && e.id)
      return {
        name: e.id.name,
        originalNode: e.id
      };
    let r = "", i;
    if ((0, Ta.isObjectProperty)(t, {
      value: e
    }) ? i = X4(t) : (0, Ta.isObjectMethod)(e) || (0, Ta.isClassMethod)(e) ? (i = X4(e), e.kind === "get" ? r = "get " : e.kind === "set" &&
    (r = "set ")) : (0, Ta.isVariableDeclarator)(t, {
      init: e
    }) ? i = t.id : (0, Ta.isAssignmentExpression)(t, {
      operator: "=",
      right: e
    }) && (i = t.left), !i) return null;
    let n = (0, Ta.isLiteral)(i) ? zOe(i) : (0, Ta.isIdentifier)(i) ? i.name : (0, Ta.isPrivateName)(i) ? i.id.name : null;
    return n == null ? null : {
      name: r + n,
      originalNode: i
    };
  }
  s(GOe, "getFunctionName");
});

// ../node_modules/@babel/types/lib/traverse/traverse.js
var J4 = b((oC) => {
  "use strict";
  Object.defineProperty(oC, "__esModule", {
    value: !0
  });
  oC.default = $Oe;
  var WOe = Sa();
  function $Oe(e, t, r) {
    typeof t == "function" && (t = {
      enter: t
    });
    let {
      enter: i,
      exit: n
    } = t;
    aC(e, i, n, r, []);
  }
  s($Oe, "traverse");
  function aC(e, t, r, i, n) {
    let a = WOe.VISITOR_KEYS[e.type];
    if (a) {
      t && t(e, n, i);
      for (let o of a) {
        let u = e[o];
        if (Array.isArray(u))
          for (let l = 0; l < u.length; l++) {
            let c = u[l];
            c && (n.push({
              node: e,
              key: o,
              index: l
            }), aC(c, t, r, i, n), n.pop());
          }
        else u && (n.push({
          node: e,
          key: o
        }), aC(u, t, r, i, n), n.pop());
      }
      r && r(e, n, i);
    }
  }
  s(aC, "traverseSimpleImpl");
});

// ../node_modules/@babel/types/lib/validators/isBinding.js
var Q4 = b((uC) => {
  "use strict";
  Object.defineProperty(uC, "__esModule", {
    value: !0
  });
  uC.default = YOe;
  var XOe = dd();
  function YOe(e, t, r) {
    if (r && e.type === "Identifier" && t.type === "ObjectProperty" && r.type === "ObjectExpression")
      return !1;
    let i = XOe.default.keys[t.type];
    if (i)
      for (let n = 0; n < i.length; n++) {
        let a = i[n], o = t[a];
        if (Array.isArray(o)) {
          if (o.includes(e)) return !0;
        } else if (o === e) return !0;
      }
    return !1;
  }
  s(YOe, "isBinding");
});

// ../node_modules/@babel/types/lib/validators/isLet.js
var cC = b((lC) => {
  "use strict";
  Object.defineProperty(lC, "__esModule", {
    value: !0
  });
  lC.default = QOe;
  var JOe = Ri();
  Z4 = Symbol.for("var used to be block scoped");
  var Z4;
  function QOe(e) {
    return (0, JOe.isVariableDeclaration)(e) && (e.kind !== "var" || e[Z4]);
  }
  s(QOe, "isLet");
});

// ../node_modules/@babel/types/lib/validators/isBlockScoped.js
var t5 = b((fC) => {
  "use strict";
  Object.defineProperty(fC, "__esModule", {
    value: !0
  });
  fC.default = eke;
  var e5 = Ri(), ZOe = cC();
  function eke(e) {
    return (0, e5.isFunctionDeclaration)(e) || (0, e5.isClassDeclaration)(e) || (0, ZOe.default)(e);
  }
  s(eke, "isBlockScoped");
});

// ../node_modules/@babel/types/lib/validators/isImmutable.js
var r5 = b((pC) => {
  "use strict";
  Object.defineProperty(pC, "__esModule", {
    value: !0
  });
  pC.default = ike;
  var tke = t_(), rke = Ri();
  function ike(e) {
    return (0, tke.default)(e.type, "Immutable") ? !0 : (0, rke.isIdentifier)(e) ? e.name === "undefined" : !1;
  }
  s(ike, "isImmutable");
});

// ../node_modules/@babel/types/lib/validators/isNodesEquivalent.js
var n5 = b((dC) => {
  "use strict";
  Object.defineProperty(dC, "__esModule", {
    value: !0
  });
  dC.default = hC;
  var i5 = Sa();
  function hC(e, t) {
    if (typeof e != "object" || typeof t != "object" || e == null || t == null)
      return e === t;
    if (e.type !== t.type)
      return !1;
    let r = Object.keys(i5.NODE_FIELDS[e.type] || e.type), i = i5.VISITOR_KEYS[e.type];
    for (let n of r) {
      let a = e[n], o = t[n];
      if (typeof a != typeof o)
        return !1;
      if (!(a == null && o == null)) {
        if (a == null || o == null)
          return !1;
        if (Array.isArray(a)) {
          if (!Array.isArray(o) || a.length !== o.length)
            return !1;
          for (let u = 0; u < a.length; u++)
            if (!hC(a[u], o[u]))
              return !1;
          continue;
        }
        if (typeof a == "object" && !(i != null && i.includes(n))) {
          for (let u of Object.keys(a))
            if (a[u] !== o[u])
              return !1;
          continue;
        }
        if (!hC(a, o))
          return !1;
      }
    }
    return !0;
  }
  s(hC, "isNodesEquivalent");
});

// ../node_modules/@babel/types/lib/validators/isReferenced.js
var s5 = b((mC) => {
  "use strict";
  Object.defineProperty(mC, "__esModule", {
    value: !0
  });
  mC.default = nke;
  function nke(e, t, r) {
    switch (t.type) {
      case "MemberExpression":
      case "OptionalMemberExpression":
        return t.property === e ? !!t.computed : t.object === e;
      case "JSXMemberExpression":
        return t.object === e;
      case "VariableDeclarator":
        return t.init === e;
      case "ArrowFunctionExpression":
        return t.body === e;
      case "PrivateName":
        return !1;
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "ObjectMethod":
        return t.key === e ? !!t.computed : !1;
      case "ObjectProperty":
        return t.key === e ? !!t.computed : !r || r.type !== "ObjectPattern";
      case "ClassProperty":
      case "ClassAccessorProperty":
        return t.key === e ? !!t.computed : !0;
      case "ClassPrivateProperty":
        return t.key !== e;
      case "ClassDeclaration":
      case "ClassExpression":
        return t.superClass === e;
      case "AssignmentExpression":
        return t.right === e;
      case "AssignmentPattern":
        return t.right === e;
      case "LabeledStatement":
        return !1;
      case "CatchClause":
        return !1;
      case "RestElement":
        return !1;
      case "BreakStatement":
      case "ContinueStatement":
        return !1;
      case "FunctionDeclaration":
      case "FunctionExpression":
        return !1;
      case "ExportNamespaceSpecifier":
      case "ExportDefaultSpecifier":
        return !1;
      case "ExportSpecifier":
        return r != null && r.source ? !1 : t.local === e;
      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "ImportSpecifier":
        return !1;
      case "ImportAttribute":
        return !1;
      case "JSXAttribute":
        return !1;
      case "ObjectPattern":
      case "ArrayPattern":
        return !1;
      case "MetaProperty":
        return !1;
      case "ObjectTypeProperty":
        return t.key !== e;
      case "TSEnumMember":
        return t.id !== e;
      case "TSPropertySignature":
        return t.key === e ? !!t.computed : !0;
    }
    return !0;
  }
  s(nke, "isReferenced");
});

// ../node_modules/@babel/types/lib/validators/isScope.js
var a5 = b((yC) => {
  "use strict";
  Object.defineProperty(yC, "__esModule", {
    value: !0
  });
  yC.default = ske;
  var cc = Ri();
  function ske(e, t) {
    return (0, cc.isBlockStatement)(e) && ((0, cc.isFunction)(t) || (0, cc.isCatchClause)(t)) ? !1 : (0, cc.isPattern)(e) && ((0, cc.isFunction)(
    t) || (0, cc.isCatchClause)(t)) ? !0 : (0, cc.isScopable)(e);
  }
  s(ske, "isScope");
});

// ../node_modules/@babel/types/lib/validators/isSpecifierDefault.js
var u5 = b((gC) => {
  "use strict";
  Object.defineProperty(gC, "__esModule", {
    value: !0
  });
  gC.default = ake;
  var o5 = Ri();
  function ake(e) {
    return (0, o5.isImportDefaultSpecifier)(e) || (0, o5.isIdentifier)(e.imported || e.exported, {
      name: "default"
    });
  }
  s(ake, "isSpecifierDefault");
});

// ../node_modules/@babel/types/lib/validators/isValidES3Identifier.js
var l5 = b((_C) => {
  "use strict";
  Object.defineProperty(_C, "__esModule", {
    value: !0
  });
  _C.default = lke;
  var oke = zf(), uke = /* @__PURE__ */ new Set(["abstract", "boolean", "byte", "char", "double", "enum", "final", "float", "goto", "impleme\
nts", "int", "interface", "long", "native", "package", "private", "protected", "public", "short", "static", "synchronized", "throws", "trans\
ient", "volatile"]);
  function lke(e) {
    return (0, oke.default)(e) && !uke.has(e);
  }
  s(lke, "isValidES3Identifier");
});

// ../node_modules/@babel/types/lib/validators/isVar.js
var f5 = b((bC) => {
  "use strict";
  Object.defineProperty(bC, "__esModule", {
    value: !0
  });
  bC.default = fke;
  var cke = Ri();
  c5 = Symbol.for("var used to be block scoped");
  var c5;
  function fke(e) {
    return (0, cke.isVariableDeclaration)(e, {
      kind: "var"
    }) && !e[c5];
  }
  s(fke, "isVar");
});

// ../node_modules/@babel/types/lib/converters/gatherSequenceExpressions.js
var p5 = b((TC) => {
  "use strict";
  Object.defineProperty(TC, "__esModule", {
    value: !0
  });
  TC.default = S_;
  var pke = dd(), fc = Ri(), vC = Ns(), SC = g1(), hke = ll();
  function S_(e, t) {
    let r = [], i = !0;
    for (let n of e)
      if ((0, fc.isEmptyStatement)(n) || (i = !1), (0, fc.isExpression)(n))
        r.push(n);
      else if ((0, fc.isExpressionStatement)(n))
        r.push(n.expression);
      else if ((0, fc.isVariableDeclaration)(n)) {
        if (n.kind !== "var") return;
        for (let a of n.declarations) {
          let o = (0, pke.default)(a);
          for (let u of Object.keys(o))
            t.push({
              kind: n.kind,
              id: (0, hke.default)(o[u])
            });
          a.init && r.push((0, vC.assignmentExpression)("=", a.id, a.init));
        }
        i = !0;
      } else if ((0, fc.isIfStatement)(n)) {
        let a = n.consequent ? S_([n.consequent], t) : (0, SC.buildUndefinedNode)(), o = n.alternate ? S_([n.alternate], t) : (0, SC.buildUndefinedNode)();
        if (!a || !o) return;
        r.push((0, vC.conditionalExpression)(n.test, a, o));
      } else if ((0, fc.isBlockStatement)(n)) {
        let a = S_(n.body, t);
        if (!a) return;
        r.push(a);
      } else if ((0, fc.isEmptyStatement)(n))
        e.indexOf(n) === 0 && (i = !0);
      else
        return;
    return i && r.push((0, SC.buildUndefinedNode)()), r.length === 1 ? r[0] : (0, vC.sequenceExpression)(r);
  }
  s(S_, "gatherSequenceExpressions");
});

// ../node_modules/@babel/types/lib/converters/toSequenceExpression.js
var h5 = b((EC) => {
  "use strict";
  Object.defineProperty(EC, "__esModule", {
    value: !0
  });
  EC.default = mke;
  var dke = p5();
  function mke(e, t) {
    if (!(e != null && e.length)) return;
    let r = [], i = (0, dke.default)(e, r);
    if (i) {
      for (let n of r)
        t.push(n);
      return i;
    }
  }
  s(mke, "toSequenceExpression");
});

// ../node_modules/@babel/types/lib/index.js
var Xn = b((Le) => {
  "use strict";
  Object.defineProperty(Le, "__esModule", {
    value: !0
  });
  var cl = {
    react: !0,
    assertNode: !0,
    createTypeAnnotationBasedOnTypeof: !0,
    createUnionTypeAnnotation: !0,
    createFlowUnionType: !0,
    createTSUnionType: !0,
    cloneNode: !0,
    clone: !0,
    cloneDeep: !0,
    cloneDeepWithoutLoc: !0,
    cloneWithoutLoc: !0,
    addComment: !0,
    addComments: !0,
    inheritInnerComments: !0,
    inheritLeadingComments: !0,
    inheritsComments: !0,
    inheritTrailingComments: !0,
    removeComments: !0,
    ensureBlock: !0,
    toBindingIdentifierName: !0,
    toBlock: !0,
    toComputedKey: !0,
    toExpression: !0,
    toIdentifier: !0,
    toKeyAlias: !0,
    toStatement: !0,
    valueToNode: !0,
    appendToMemberExpression: !0,
    inherits: !0,
    prependToMemberExpression: !0,
    removeProperties: !0,
    removePropertiesDeep: !0,
    removeTypeDuplicates: !0,
    getAssignmentIdentifiers: !0,
    getBindingIdentifiers: !0,
    getOuterBindingIdentifiers: !0,
    getFunctionName: !0,
    traverse: !0,
    traverseFast: !0,
    shallowEqual: !0,
    is: !0,
    isBinding: !0,
    isBlockScoped: !0,
    isImmutable: !0,
    isLet: !0,
    isNode: !0,
    isNodesEquivalent: !0,
    isPlaceholderType: !0,
    isReferenced: !0,
    isScope: !0,
    isSpecifierDefault: !0,
    isType: !0,
    isValidES3Identifier: !0,
    isValidIdentifier: !0,
    isVar: !0,
    matchesPattern: !0,
    validate: !0,
    buildMatchMemberExpression: !0,
    __internal__deprecationWarning: !0
  };
  Object.defineProperty(Le, "__internal__deprecationWarning", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return bIe.default;
    }, "get")
  });
  Object.defineProperty(Le, "addComment", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Pke.default;
    }, "get")
  });
  Object.defineProperty(Le, "addComments", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Dke.default;
    }, "get")
  });
  Object.defineProperty(Le, "appendToMemberExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Kke.default;
    }, "get")
  });
  Object.defineProperty(Le, "assertNode", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return bke.default;
    }, "get")
  });
  Object.defineProperty(Le, "buildMatchMemberExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return _Ie.default;
    }, "get")
  });
  Object.defineProperty(Le, "clone", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Eke.default;
    }, "get")
  });
  Object.defineProperty(Le, "cloneDeep", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Ake.default;
    }, "get")
  });
  Object.defineProperty(Le, "cloneDeepWithoutLoc", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return xke.default;
    }, "get")
  });
  Object.defineProperty(Le, "cloneNode", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Tke.default;
    }, "get")
  });
  Object.defineProperty(Le, "cloneWithoutLoc", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Cke.default;
    }, "get")
  });
  Object.defineProperty(Le, "createFlowUnionType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return d5.default;
    }, "get")
  });
  Object.defineProperty(Le, "createTSUnionType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Ske.default;
    }, "get")
  });
  Object.defineProperty(Le, "createTypeAnnotationBasedOnTypeof", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return vke.default;
    }, "get")
  });
  Object.defineProperty(Le, "createUnionTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return d5.default;
    }, "get")
  });
  Object.defineProperty(Le, "ensureBlock", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Nke.default;
    }, "get")
  });
  Object.defineProperty(Le, "getAssignmentIdentifiers", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Xke.default;
    }, "get")
  });
  Object.defineProperty(Le, "getBindingIdentifiers", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Yke.default;
    }, "get")
  });
  Object.defineProperty(Le, "getFunctionName", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Qke.default;
    }, "get")
  });
  Object.defineProperty(Le, "getOuterBindingIdentifiers", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Jke.default;
    }, "get")
  });
  Object.defineProperty(Le, "inheritInnerComments", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return wke.default;
    }, "get")
  });
  Object.defineProperty(Le, "inheritLeadingComments", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Oke.default;
    }, "get")
  });
  Object.defineProperty(Le, "inheritTrailingComments", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Ike.default;
    }, "get")
  });
  Object.defineProperty(Le, "inherits", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Hke.default;
    }, "get")
  });
  Object.defineProperty(Le, "inheritsComments", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return kke.default;
    }, "get")
  });
  Object.defineProperty(Le, "is", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return tIe.default;
    }, "get")
  });
  Object.defineProperty(Le, "isBinding", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return rIe.default;
    }, "get")
  });
  Object.defineProperty(Le, "isBlockScoped", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return iIe.default;
    }, "get")
  });
  Object.defineProperty(Le, "isImmutable", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return nIe.default;
    }, "get")
  });
  Object.defineProperty(Le, "isLet", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return sIe.default;
    }, "get")
  });
  Object.defineProperty(Le, "isNode", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return aIe.default;
    }, "get")
  });
  Object.defineProperty(Le, "isNodesEquivalent", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return oIe.default;
    }, "get")
  });
  Object.defineProperty(Le, "isPlaceholderType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return uIe.default;
    }, "get")
  });
  Object.defineProperty(Le, "isReferenced", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return lIe.default;
    }, "get")
  });
  Object.defineProperty(Le, "isScope", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return cIe.default;
    }, "get")
  });
  Object.defineProperty(Le, "isSpecifierDefault", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return fIe.default;
    }, "get")
  });
  Object.defineProperty(Le, "isType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return pIe.default;
    }, "get")
  });
  Object.defineProperty(Le, "isValidES3Identifier", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return hIe.default;
    }, "get")
  });
  Object.defineProperty(Le, "isValidIdentifier", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return dIe.default;
    }, "get")
  });
  Object.defineProperty(Le, "isVar", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return mIe.default;
    }, "get")
  });
  Object.defineProperty(Le, "matchesPattern", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return yIe.default;
    }, "get")
  });
  Object.defineProperty(Le, "prependToMemberExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return zke.default;
    }, "get")
  });
  Le.react = void 0;
  Object.defineProperty(Le, "removeComments", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Rke.default;
    }, "get")
  });
  Object.defineProperty(Le, "removeProperties", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Gke.default;
    }, "get")
  });
  Object.defineProperty(Le, "removePropertiesDeep", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Wke.default;
    }, "get")
  });
  Object.defineProperty(Le, "removeTypeDuplicates", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $ke.default;
    }, "get")
  });
  Object.defineProperty(Le, "shallowEqual", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return eIe.default;
    }, "get")
  });
  Object.defineProperty(Le, "toBindingIdentifierName", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Lke.default;
    }, "get")
  });
  Object.defineProperty(Le, "toBlock", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Fke.default;
    }, "get")
  });
  Object.defineProperty(Le, "toComputedKey", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Mke.default;
    }, "get")
  });
  Object.defineProperty(Le, "toExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Bke.default;
    }, "get")
  });
  Object.defineProperty(Le, "toIdentifier", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return qke.default;
    }, "get")
  });
  Object.defineProperty(Le, "toKeyAlias", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Uke.default;
    }, "get")
  });
  Object.defineProperty(Le, "toStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return jke.default;
    }, "get")
  });
  Object.defineProperty(Le, "traverse", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return T_.default;
    }, "get")
  });
  Object.defineProperty(Le, "traverseFast", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Zke.default;
    }, "get")
  });
  Object.defineProperty(Le, "validate", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return gIe.default;
    }, "get")
  });
  Object.defineProperty(Le, "valueToNode", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Vke.default;
    }, "get")
  });
  var yke = y8(), gke = g8(), _ke = l4(), bke = c4(), AC = f4();
  Object.keys(AC).forEach(function(e) {
    e === "default" || e === "__esModule" || Object.prototype.hasOwnProperty.call(cl, e) || e in Le && Le[e] === AC[e] || Object.defineProperty(
    Le, e, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return AC[e];
      }, "get")
    });
  });
  var vke = p4(), d5 = m4(), Ske = b4(), xC = g1();
  Object.keys(xC).forEach(function(e) {
    e === "default" || e === "__esModule" || Object.prototype.hasOwnProperty.call(cl, e) || e in Le && Le[e] === xC[e] || Object.defineProperty(
    Le, e, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return xC[e];
      }, "get")
    });
  });
  var CC = Ns();
  Object.keys(CC).forEach(function(e) {
    e === "default" || e === "__esModule" || Object.prototype.hasOwnProperty.call(cl, e) || e in Le && Le[e] === CC[e] || Object.defineProperty(
    Le, e, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return CC[e];
      }, "get")
    });
  });
  var Tke = ll(), Eke = x4(), Ake = C4(), xke = P4(), Cke = D4(), Pke = w4(), Dke = x1(), wke = w1(), Oke = k1(), kke = L1(), Ike = R1(), Rke = O4(),
  PC = k4();
  Object.keys(PC).forEach(function(e) {
    e === "default" || e === "__esModule" || Object.prototype.hasOwnProperty.call(cl, e) || e in Le && Le[e] === PC[e] || Object.defineProperty(
    Le, e, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return PC[e];
      }, "get")
    });
  });
  var DC = Gf();
  Object.keys(DC).forEach(function(e) {
    e === "default" || e === "__esModule" || Object.prototype.hasOwnProperty.call(cl, e) || e in Le && Le[e] === DC[e] || Object.defineProperty(
    Le, e, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return DC[e];
      }, "get")
    });
  });
  var Nke = I4(), Lke = R4(), Fke = q1(), Mke = N4(), Bke = L4(), qke = V1(), Uke = U4(), jke = j4(), Vke = V4(), wC = Sa();
  Object.keys(wC).forEach(function(e) {
    e === "default" || e === "__esModule" || Object.prototype.hasOwnProperty.call(cl, e) || e in Le && Le[e] === wC[e] || Object.defineProperty(
    Le, e, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return wC[e];
      }, "get")
    });
  });
  var Kke = K4(), Hke = z4(), zke = G4(), Gke = $1(), Wke = Y1(), $ke = p1(), Xke = W4(), Yke = dd(), Jke = $4(), Qke = Y4(), T_ = J4();
  Object.keys(T_).forEach(function(e) {
    e === "default" || e === "__esModule" || Object.prototype.hasOwnProperty.call(cl, e) || e in Le && Le[e] === T_[e] || Object.defineProperty(
    Le, e, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return T_[e];
      }, "get")
    });
  });
  var Zke = G1(), eIe = Zg(), tIe = Hf(), rIe = Q4(), iIe = t5(), nIe = r5(), sIe = cC(), aIe = l1(), oIe = n5(), uIe = Nx(), lIe = s5(), cIe = a5(),
  fIe = u5(), pIe = t_(), hIe = l5(), dIe = zf(), mIe = f5(), yIe = Dx(), gIe = a_(), _Ie = Ox(), OC = Ri();
  Object.keys(OC).forEach(function(e) {
    e === "default" || e === "__esModule" || Object.prototype.hasOwnProperty.call(cl, e) || e in Le && Le[e] === OC[e] || Object.defineProperty(
    Le, e, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return OC[e];
      }, "get")
    });
  });
  var bIe = ed(), vIe = h5(), Wxt = Le.react = {
    isReactComponent: yke.default,
    isCompatTag: gke.default,
    buildChildren: _ke.default
  };
  Le.toSequenceExpression = vIe.default;
  process.env.BABEL_TYPES_8_BREAKING && console.warn("BABEL_TYPES_8_BREAKING is not supported anymore. Use the latest Babel 8.0.0 pre-releas\
e instead!");
});

// ../node_modules/@babel/generator/lib/node/whitespace.js
var b5 = b((A_) => {
  "use strict";
  Object.defineProperty(A_, "__esModule", {
    value: !0
  });
  A_.nodes = void 0;
  var SIe = Xn(), {
    FLIPPED_ALIAS_KEYS: TIe,
    isArrayExpression: EIe,
    isAssignmentExpression: y5,
    isBinary: g5,
    isBlockStatement: AIe,
    isCallExpression: _5,
    isFunction: md,
    isIdentifier: E_,
    isLiteral: xIe,
    isMemberExpression: kC,
    isObjectExpression: CIe,
    isOptionalCallExpression: PIe,
    isOptionalMemberExpression: DIe,
    isStringLiteral: wIe
  } = SIe;
  function Jf(e, t) {
    return e && (kC(e) || DIe(e) ? (Jf(e.object, t), e.computed && Jf(e.property, t)) : g5(e) || y5(e) ? (Jf(e.left, t), Jf(e.right, t)) : _5(
    e) || PIe(e) ? (t.hasCall = !0, Jf(e.callee, t)) : md(e) ? t.hasFunction = !0 : E_(e) && (t.hasHelper = t.hasHelper || e.callee && gu(e.
    callee))), t;
  }
  s(Jf, "crawlInternal");
  function m5(e) {
    return Jf(e, {
      hasCall: !1,
      hasFunction: !1,
      hasHelper: !1
    });
  }
  s(m5, "crawl");
  function gu(e) {
    return e ? kC(e) ? gu(e.object) || gu(e.property) : E_(e) ? e.name === "require" || e.name.charCodeAt(0) === 95 : _5(e) ? gu(e.callee) :
    g5(e) || y5(e) ? E_(e.left) && gu(e.left) || gu(e.right) : !1 : !1;
  }
  s(gu, "isHelper");
  function OIe(e) {
    return xIe(e) || CIe(e) || EIe(e) || E_(e) || kC(e);
  }
  s(OIe, "isType");
  var pc = A_.nodes = {
    AssignmentExpression(e) {
      let t = m5(e.right);
      if (t.hasCall && t.hasHelper || t.hasFunction)
        return t.hasFunction ? 3 : 2;
    },
    SwitchCase(e, t) {
      return (e.consequent.length || t.cases[0] === e ? 1 : 0) | (!e.consequent.length && t.cases[t.cases.length - 1] === e ? 2 : 0);
    },
    LogicalExpression(e) {
      if (md(e.left) || md(e.right))
        return 2;
    },
    Literal(e) {
      if (wIe(e) && e.value === "use strict")
        return 2;
    },
    CallExpression(e) {
      if (md(e.callee) || gu(e))
        return 3;
    },
    OptionalCallExpression(e) {
      if (md(e.callee))
        return 3;
    },
    VariableDeclaration(e) {
      for (let t = 0; t < e.declarations.length; t++) {
        let r = e.declarations[t], i = gu(r.id) && !OIe(r.init);
        if (!i && r.init) {
          let n = m5(r.init);
          i = gu(r.init) && n.hasCall || n.hasFunction;
        }
        if (i)
          return 3;
      }
    },
    IfStatement(e) {
      if (AIe(e.consequent))
        return 3;
    }
  };
  pc.ObjectProperty = pc.ObjectTypeProperty = pc.ObjectMethod = function(e, t) {
    if (t.properties[0] === e)
      return 1;
  };
  pc.ObjectTypeCallProperty = function(e, t) {
    var r;
    if (t.callProperties[0] === e && !((r = t.properties) != null && r.length))
      return 1;
  };
  pc.ObjectTypeIndexer = function(e, t) {
    var r, i;
    if (t.indexers[0] === e && !((r = t.properties) != null && r.length) && !((i = t.callProperties) != null && i.length))
      return 1;
  };
  pc.ObjectTypeInternalSlot = function(e, t) {
    var r, i, n;
    if (t.internalSlots[0] === e && !((r = t.properties) != null && r.length) && !((i = t.callProperties) != null && i.length) && !((n = t.indexers) !=
    null && n.length))
      return 1;
  };
  [["Function", !0], ["Class", !0], ["Loop", !0], ["LabeledStatement", !0], ["SwitchStatement", !0], ["TryStatement", !0]].forEach(function([
  e, t]) {
    [e].concat(TIe[e] || []).forEach(function(r) {
      let i = t ? 3 : 0;
      pc[r] = () => i;
    });
  });
});

// ../node_modules/@babel/generator/lib/node/parentheses.js
var P5 = b((ir) => {
  "use strict";
  Object.defineProperty(ir, "__esModule", {
    value: !0
  });
  ir.AssignmentExpression = uRe;
  ir.Binary = A5;
  ir.BinaryExpression = rRe;
  ir.ClassExpression = sRe;
  ir.ArrowFunctionExpression = ir.ConditionalExpression = C5;
  ir.DoExpression = zIe;
  ir.FunctionExpression = aRe;
  ir.FunctionTypeAnnotation = VIe;
  ir.Identifier = cRe;
  ir.LogicalExpression = lRe;
  ir.NullableTypeAnnotation = jIe;
  ir.ObjectExpression = HIe;
  ir.OptionalIndexedAccessType = WIe;
  ir.OptionalCallExpression = ir.OptionalMemberExpression = oRe;
  ir.SequenceExpression = iRe;
  ir.TSSatisfiesExpression = ir.TSAsExpression = $Ie;
  ir.TSConditionalType = XIe;
  ir.TSConstructorType = ir.TSFunctionType = tRe;
  ir.TSInferType = QIe;
  ir.TSInstantiationExpression = eRe;
  ir.TSIntersectionType = JIe;
  ir.UnaryLike = ir.TSTypeAssertion = x5;
  ir.TSTypeOperator = ZIe;
  ir.TSUnionType = YIe;
  ir.IntersectionTypeAnnotation = ir.UnionTypeAnnotation = GIe;
  ir.UpdateExpression = KIe;
  ir.AwaitExpression = ir.YieldExpression = nRe;
  var kIe = Xn(), Ea = fl(), {
    isArrayTypeAnnotation: IIe,
    isBinaryExpression: RIe,
    isCallExpression: NIe,
    isForOfStatement: LIe,
    isIndexedAccessType: FIe,
    isMemberExpression: T5,
    isObjectPattern: MIe,
    isOptionalMemberExpression: BIe,
    isYieldExpression: qIe,
    isStatement: UIe
  } = kIe, v5 = /* @__PURE__ */ new Map([["||", 0], ["??", 0], ["|>", 0], ["&&", 1], ["|", 2], ["^", 3], ["&", 4], ["==", 5], ["===", 5], ["\
!=", 5], ["!==", 5], ["<", 6], [">", 6], ["<=", 6], [">=", 6], ["in", 6], ["instanceof", 6], [">>", 7], ["<<", 7], [">>>", 7], ["+", 8], ["-",
  8], ["*", 9], ["/", 9], ["%", 9], ["**", 10]]);
  function S5(e, t) {
    if (t === "BinaryExpression" || t === "LogicalExpression")
      return v5.get(e.operator);
    if (t === "TSAsExpression" || t === "TSSatisfiesExpression")
      return v5.get("in");
  }
  s(S5, "getBinaryPrecedence");
  function IC(e) {
    return e === "TSAsExpression" || e === "TSSatisfiesExpression" || e === "TSTypeAssertion";
  }
  s(IC, "isTSTypeExpression");
  var x_ = /* @__PURE__ */ s((e, t) => {
    let r = t.type;
    return (r === "ClassDeclaration" || r === "ClassExpression") && t.superClass === e;
  }, "isClassExtendsClause"), C_ = /* @__PURE__ */ s((e, t) => {
    let r = t.type;
    return (r === "MemberExpression" || r === "OptionalMemberExpression") && t.object === e || (r === "CallExpression" || r === "OptionalCal\
lExpression" || r === "NewExpression") && t.callee === e || r === "TaggedTemplateExpression" && t.tag === e || r === "TSNonNullExpression";
  }, "hasPostfixPart");
  function jIe(e, t) {
    return IIe(t);
  }
  s(jIe, "NullableTypeAnnotation");
  function VIe(e, t, r) {
    let i = t.type;
    return i === "UnionTypeAnnotation" || i === "IntersectionTypeAnnotation" || i === "ArrayTypeAnnotation" || !!(r & Ea.TokenContext.arrowFlowReturnType);
  }
  s(VIe, "FunctionTypeAnnotation");
  function KIe(e, t) {
    return C_(e, t) || x_(e, t);
  }
  s(KIe, "UpdateExpression");
  function E5(e) {
    return !!(e & (Ea.TokenContext.expressionStatement | Ea.TokenContext.arrowBody));
  }
  s(E5, "needsParenBeforeExpressionBrace");
  function HIe(e, t, r) {
    return E5(r);
  }
  s(HIe, "ObjectExpression");
  function zIe(e, t, r) {
    return !e.async && !!(r & Ea.TokenContext.expressionStatement);
  }
  s(zIe, "DoExpression");
  function A5(e, t) {
    let r = t.type;
    if (e.type === "BinaryExpression" && e.operator === "**" && r === "BinaryExpression" && t.operator === "**")
      return t.left === e;
    if (x_(e, t) || C_(e, t) || r === "UnaryExpression" || r === "SpreadElement" || r === "AwaitExpression")
      return !0;
    let i = S5(t, r);
    if (i != null) {
      let n = S5(e, e.type);
      if (i === n && r === "BinaryExpression" && t.right === e || i > n)
        return !0;
    }
  }
  s(A5, "Binary");
  function GIe(e, t) {
    let r = t.type;
    return r === "ArrayTypeAnnotation" || r === "NullableTypeAnnotation" || r === "IntersectionTypeAnnotation" || r === "UnionTypeAnnotation";
  }
  s(GIe, "UnionTypeAnnotation");
  function WIe(e, t) {
    return FIe(t) && t.objectType === e;
  }
  s(WIe, "OptionalIndexedAccessType");
  function $Ie(e, t) {
    return (t.type === "AssignmentExpression" || t.type === "AssignmentPattern") && t.left === e || t.type === "BinaryExpression" && (t.operator ===
    "|" || t.operator === "&") && e === t.left ? !0 : A5(e, t);
  }
  s($Ie, "TSAsExpression");
  function XIe(e, t) {
    let r = t.type;
    return r === "TSArrayType" || r === "TSIndexedAccessType" && t.objectType === e || r === "TSOptionalType" || r === "TSTypeOperator" || r ===
    "TSTypeParameter" || (r === "TSIntersectionType" || r === "TSUnionType") && t.types[0] === e || r === "TSConditionalType" && (t.checkType ===
    e || t.extendsType === e);
  }
  s(XIe, "TSConditionalType");
  function YIe(e, t) {
    let r = t.type;
    return r === "TSIntersectionType" || r === "TSTypeOperator" || r === "TSArrayType" || r === "TSIndexedAccessType" && t.objectType === e ||
    r === "TSOptionalType";
  }
  s(YIe, "TSUnionType");
  function JIe(e, t) {
    let r = t.type;
    return r === "TSTypeOperator" || r === "TSArrayType" || r === "TSIndexedAccessType" && t.objectType === e || r === "TSOptionalType";
  }
  s(JIe, "TSIntersectionType");
  function QIe(e, t) {
    let r = t.type;
    return !!(r === "TSArrayType" || r === "TSIndexedAccessType" && t.objectType === e || r === "TSOptionalType" || e.typeParameter.constraint &&
    (r === "TSIntersectionType" || r === "TSUnionType") && t.types[0] === e);
  }
  s(QIe, "TSInferType");
  function ZIe(e, t) {
    let r = t.type;
    return r === "TSArrayType" || r === "TSIndexedAccessType" && t.objectType === e || r === "TSOptionalType";
  }
  s(ZIe, "TSTypeOperator");
  function eRe(e, t) {
    let r = t.type;
    return (r === "CallExpression" || r === "OptionalCallExpression" || r === "NewExpression" || r === "TSInstantiationExpression") && !!t.typeParameters;
  }
  s(eRe, "TSInstantiationExpression");
  function tRe(e, t) {
    let r = t.type;
    return r === "TSIntersectionType" || r === "TSUnionType" || r === "TSTypeOperator" || r === "TSOptionalType" || r === "TSArrayType" || r ===
    "TSIndexedAccessType" && t.objectType === e || r === "TSConditionalType" && (t.checkType === e || t.extendsType === e);
  }
  s(tRe, "TSFunctionType");
  function rRe(e, t, r, i) {
    return e.operator === "in" && i;
  }
  s(rRe, "BinaryExpression");
  function iRe(e, t) {
    let r = t.type;
    return r === "SequenceExpression" || r === "ParenthesizedExpression" || r === "MemberExpression" && t.property === e || r === "OptionalM\
emberExpression" && t.property === e || r === "TemplateLiteral" ? !1 : r === "ClassDeclaration" ? !0 : r === "ForOfStatement" ? t.right === e :
    r === "ExportDefaultDeclaration" ? !0 : !UIe(t);
  }
  s(iRe, "SequenceExpression");
  function nRe(e, t) {
    let r = t.type;
    return r === "BinaryExpression" || r === "LogicalExpression" || r === "UnaryExpression" || r === "SpreadElement" || C_(e, t) || r === "A\
waitExpression" && qIe(e) || r === "ConditionalExpression" && e === t.test || x_(e, t) || IC(r);
  }
  s(nRe, "YieldExpression");
  function sRe(e, t, r) {
    return !!(r & (Ea.TokenContext.expressionStatement | Ea.TokenContext.exportDefault));
  }
  s(sRe, "ClassExpression");
  function x5(e, t) {
    return C_(e, t) || RIe(t) && t.operator === "**" && t.left === e || x_(e, t);
  }
  s(x5, "UnaryLike");
  function aRe(e, t, r) {
    return !!(r & (Ea.TokenContext.expressionStatement | Ea.TokenContext.exportDefault));
  }
  s(aRe, "FunctionExpression");
  function C5(e, t) {
    let r = t.type;
    return r === "UnaryExpression" || r === "SpreadElement" || r === "BinaryExpression" || r === "LogicalExpression" || r === "ConditionalEx\
pression" && t.test === e || r === "AwaitExpression" || IC(r) ? !0 : x5(e, t);
  }
  s(C5, "ConditionalExpression");
  function oRe(e, t) {
    return NIe(t) && t.callee === e || T5(t) && t.object === e;
  }
  s(oRe, "OptionalMemberExpression");
  function uRe(e, t, r) {
    return E5(r) && MIe(e.left) ? !0 : C5(e, t);
  }
  s(uRe, "AssignmentExpression");
  function lRe(e, t) {
    let r = t.type;
    if (IC(r)) return !0;
    if (r !== "LogicalExpression") return !1;
    switch (e.operator) {
      case "||":
        return t.operator === "??" || t.operator === "&&";
      case "&&":
        return t.operator === "??";
      case "??":
        return t.operator !== "??";
    }
  }
  s(lRe, "LogicalExpression");
  function cRe(e, t, r, i, n) {
    var a;
    let o = t.type;
    if ((a = e.extra) != null && a.parenthesized && o === "AssignmentExpression" && t.left === e) {
      let u = t.right.type;
      if ((u === "FunctionExpression" || u === "ClassExpression") && t.right.id == null)
        return !0;
    }
    return n && n(e) !== e.name ? !1 : e.name === "let" ? (T5(t, {
      object: e,
      computed: !0
    }) || BIe(t, {
      object: e,
      computed: !0,
      optional: !1
    })) && r & (Ea.TokenContext.expressionStatement | Ea.TokenContext.forHead | Ea.TokenContext.forInHead) ? !0 : !!(r & Ea.TokenContext.forOfHead) :
    e.name === "async" && LIe(t, {
      left: e,
      await: !1
    });
  }
  s(cRe, "Identifier");
});

// ../node_modules/@babel/generator/lib/node/index.js
var fl = b((_u) => {
  "use strict";
  Object.defineProperty(_u, "__esModule", {
    value: !0
  });
  _u.TokenContext = void 0;
  _u.isLastChild = CRe;
  _u.needsParens = xRe;
  _u.needsWhitespace = NC;
  _u.needsWhitespaceAfter = ARe;
  _u.needsWhitespaceBefore = ERe;
  var fRe = b5(), pRe = P5(), hRe = Xn(), {
    FLIPPED_ALIAS_KEYS: dRe,
    VISITOR_KEYS: mRe,
    isCallExpression: D5,
    isDecorator: yRe,
    isExpressionStatement: gRe,
    isMemberExpression: _Re,
    isNewExpression: bRe,
    isParenthesizedExpression: vRe
  } = hRe, e1t = _u.TokenContext = {
    expressionStatement: 1,
    arrowBody: 2,
    exportDefault: 4,
    forHead: 8,
    forInHead: 16,
    forOfHead: 32,
    arrowFlowReturnType: 64
  };
  function w5(e) {
    let t = /* @__PURE__ */ new Map();
    function r(i, n) {
      let a = t.get(i);
      t.set(i, a ? function(o, u, l, c, p) {
        var h;
        return (h = a(o, u, l, c, p)) != null ? h : n(o, u, l, c, p);
      } : n);
    }
    s(r, "add");
    for (let i of Object.keys(e)) {
      let n = dRe[i];
      if (n)
        for (let a of n)
          r(a, e[i]);
      else
        r(i, e[i]);
    }
    return t;
  }
  s(w5, "expandAliases");
  var SRe = w5(pRe), TRe = w5(fRe.nodes);
  function O5(e) {
    return D5(e) ? !0 : _Re(e) && O5(e.object);
  }
  s(O5, "isOrHasCallExpression");
  function NC(e, t, r) {
    var i;
    if (!e) return !1;
    gRe(e) && (e = e.expression);
    let n = (i = TRe.get(e.type)) == null ? void 0 : i(e, t);
    return typeof n == "number" ? (n & r) !== 0 : !1;
  }
  s(NC, "needsWhitespace");
  function ERe(e, t) {
    return NC(e, t, 1);
  }
  s(ERe, "needsWhitespaceBefore");
  function ARe(e, t) {
    return NC(e, t, 2);
  }
  s(ARe, "needsWhitespaceAfter");
  function xRe(e, t, r, i, n) {
    var a;
    return t ? bRe(t) && t.callee === e && O5(e) ? !0 : yRe(t) ? !RC(e) && !(D5(e) && RC(e.callee)) && !vRe(e) : (a = SRe.get(e.type)) == null ?
    void 0 : a(e, t, r, i, n) : !1;
  }
  s(xRe, "needsParens");
  function RC(e) {
    switch (e.type) {
      case "Identifier":
        return !0;
      case "MemberExpression":
        return !e.computed && e.property.type === "Identifier" && RC(e.object);
      default:
        return !1;
    }
  }
  s(RC, "isDecoratorMemberExpression");
  function CRe(e, t) {
    let r = mRe[e.type];
    for (let i = r.length - 1; i >= 0; i--) {
      let n = e[r[i]];
      if (n === t)
        return !0;
      if (Array.isArray(n)) {
        let a = n.length - 1;
        for (; a >= 0 && n[a] === null; ) a--;
        return a >= 0 && n[a] === t;
      } else if (n)
        return !1;
    }
    return !1;
  }
  s(CRe, "isLastChild");
});

// ../node_modules/@babel/generator/lib/token-map.js
var k5 = b((P_) => {
  "use strict";
  Object.defineProperty(P_, "__esModule", {
    value: !0
  });
  P_.TokenMap = void 0;
  var PRe = Xn(), {
    traverseFast: DRe,
    VISITOR_KEYS: wRe
  } = PRe, LC = class {
    static {
      s(this, "TokenMap");
    }
    constructor(t, r, i) {
      this._tokens = void 0, this._source = void 0, this._nodesToTokenIndexes = /* @__PURE__ */ new Map(), this._nodesOccurrencesCountCache =
      /* @__PURE__ */ new Map(), this._tokensCache = /* @__PURE__ */ new Map(), this._tokens = r, this._source = i, DRe(t, (n) => {
        let a = this._getTokensIndexesOfNode(n);
        a.length > 0 && this._nodesToTokenIndexes.set(n, a);
      }), this._tokensCache = null;
    }
    has(t) {
      return this._nodesToTokenIndexes.has(t);
    }
    getIndexes(t) {
      return this._nodesToTokenIndexes.get(t);
    }
    find(t, r) {
      let i = this._nodesToTokenIndexes.get(t);
      if (i)
        for (let n = 0; n < i.length; n++) {
          let a = i[n], o = this._tokens[a];
          if (r(o, a)) return o;
        }
      return null;
    }
    findLastIndex(t, r) {
      let i = this._nodesToTokenIndexes.get(t);
      if (i)
        for (let n = i.length - 1; n >= 0; n--) {
          let a = i[n], o = this._tokens[a];
          if (r(o, a)) return a;
        }
      return -1;
    }
    findMatching(t, r, i = 0) {
      let n = this._nodesToTokenIndexes.get(t);
      if (n) {
        let a = 0, o = i;
        if (o > 1) {
          let u = this._nodesOccurrencesCountCache.get(t);
          u && u.test === r && u.count < o && (a = u.i + 1, i -= u.count + 1);
        }
        for (; a < n.length; a++) {
          let u = this._tokens[n[a]];
          if (this.matchesOriginal(u, r)) {
            if (i === 0)
              return o > 0 && this._nodesOccurrencesCountCache.set(t, {
                test: r,
                count: o,
                i: a
              }), u;
            i--;
          }
        }
      }
      return null;
    }
    matchesOriginal(t, r) {
      return t.end - t.start !== r.length ? !1 : t.value != null ? t.value === r : this._source.startsWith(r, t.start);
    }
    startMatches(t, r) {
      let i = this._nodesToTokenIndexes.get(t);
      if (!i) return !1;
      let n = this._tokens[i[0]];
      return n.start !== t.start ? !1 : this.matchesOriginal(n, r);
    }
    endMatches(t, r) {
      let i = this._nodesToTokenIndexes.get(t);
      if (!i) return !1;
      let n = this._tokens[i[i.length - 1]];
      return n.end !== t.end ? !1 : this.matchesOriginal(n, r);
    }
    _getTokensIndexesOfNode(t) {
      if (t.start == null || t.end == null) return [];
      let {
        first: r,
        last: i
      } = this._findTokensOfNode(t, 0, this._tokens.length - 1), n = r, a = ORe(t);
      (t.type === "ExportNamedDeclaration" || t.type === "ExportDefaultDeclaration") && t.declaration && t.declaration.type === "ClassDeclar\
ation" && a.next();
      let o = [];
      for (let u of a) {
        if (u == null || u.start == null || u.end == null) continue;
        let l = this._findTokensOfNode(u, n, i), c = l.first;
        for (let p = n; p < c; p++) o.push(p);
        n = l.last + 1;
      }
      for (let u = n; u <= i; u++) o.push(u);
      return o;
    }
    _findTokensOfNode(t, r, i) {
      let n = this._tokensCache.get(t);
      if (n) return n;
      let a = this._findFirstTokenOfNode(t.start, r, i), o = this._findLastTokenOfNode(t.end, a, i);
      return this._tokensCache.set(t, {
        first: a,
        last: o
      }), {
        first: a,
        last: o
      };
    }
    _findFirstTokenOfNode(t, r, i) {
      for (; r <= i; ) {
        let n = i + r >> 1;
        if (t < this._tokens[n].start)
          i = n - 1;
        else if (t > this._tokens[n].start)
          r = n + 1;
        else
          return n;
      }
      return r;
    }
    _findLastTokenOfNode(t, r, i) {
      for (; r <= i; ) {
        let n = i + r >> 1;
        if (t < this._tokens[n].end)
          i = n - 1;
        else if (t > this._tokens[n].end)
          r = n + 1;
        else
          return n;
      }
      return i;
    }
  };
  P_.TokenMap = LC;
  function* ORe(e) {
    if (e.type === "TemplateLiteral") {
      yield e.quasis[0];
      for (let r = 1; r < e.quasis.length; r++)
        yield e.expressions[r - 1], yield e.quasis[r];
      return;
    }
    let t = wRe[e.type];
    for (let r of t) {
      let i = e[r];
      i && (Array.isArray(i) ? yield* i : yield i);
    }
  }
  s(ORe, "childrenIterator");
});

// ../node_modules/@babel/generator/lib/generators/template-literals.js
var I5 = b((Qf) => {
  "use strict";
  Object.defineProperty(Qf, "__esModule", {
    value: !0
  });
  Qf.TaggedTemplateExpression = kRe;
  Qf.TemplateElement = IRe;
  Qf.TemplateLiteral = NRe;
  Qf._printTemplate = RRe;
  function kRe(e) {
    this.print(e.tag), this.print(e.typeParameters), this.print(e.quasi);
  }
  s(kRe, "TaggedTemplateExpression");
  function IRe() {
    throw new Error("TemplateElement printing is handled in TemplateLiteral");
  }
  s(IRe, "TemplateElement");
  function RRe(e, t) {
    let r = e.quasis, i = "`";
    for (let n = 0; n < r.length - 1; n++)
      if (i += r[n].value.raw, this.token(i + "${", !0), this.print(t[n]), i = "}", this.tokenMap) {
        let a = this.tokenMap.findMatching(e, "}", n);
        a && this._catchUpTo(a.loc.start);
      }
    i += r[r.length - 1].value.raw, this.token(i + "`", !0);
  }
  s(RRe, "_printTemplate");
  function NRe(e) {
    this._printTemplate(e, e.expressions);
  }
  s(NRe, "TemplateLiteral");
});

// ../node_modules/@babel/generator/lib/generators/expressions.js
var N5 = b((Cr) => {
  "use strict";
  Object.defineProperty(Cr, "__esModule", {
    value: !0
  });
  Cr.LogicalExpression = Cr.BinaryExpression = Cr.AssignmentExpression = aNe;
  Cr.AssignmentPattern = sNe;
  Cr.AwaitExpression = tNe;
  Cr.BindExpression = oNe;
  Cr.CallExpression = ZRe;
  Cr.ConditionalExpression = HRe;
  Cr.Decorator = YRe;
  Cr.DoExpression = jRe;
  Cr.EmptyStatement = iNe;
  Cr.ExpressionStatement = nNe;
  Cr.Import = eNe;
  Cr.MemberExpression = uNe;
  Cr.MetaProperty = lNe;
  Cr.ModuleExpression = pNe;
  Cr.NewExpression = zRe;
  Cr.OptionalCallExpression = QRe;
  Cr.OptionalMemberExpression = JRe;
  Cr.ParenthesizedExpression = VRe;
  Cr.PrivateName = cNe;
  Cr.SequenceExpression = GRe;
  Cr.Super = $Re;
  Cr.ThisExpression = WRe;
  Cr.UnaryExpression = URe;
  Cr.UpdateExpression = KRe;
  Cr.V8IntrinsicIdentifier = fNe;
  Cr.YieldExpression = rNe;
  Cr._shouldPrintDecoratorsBeforeExport = XRe;
  var LRe = Xn(), FRe = fl(), {
    isCallExpression: MRe,
    isLiteral: R5,
    isMemberExpression: FC,
    isNewExpression: BRe,
    isPattern: qRe
  } = LRe;
  function URe(e) {
    let {
      operator: t
    } = e;
    t === "void" || t === "delete" || t === "typeof" || t === "throw" ? (this.word(t), this.space()) : this.token(t), this.print(e.argument);
  }
  s(URe, "UnaryExpression");
  function jRe(e) {
    e.async && (this.word("async", !0), this.space()), this.word("do"), this.space(), this.print(e.body);
  }
  s(jRe, "DoExpression");
  function VRe(e) {
    this.tokenChar(40);
    let t = this.enterDelimited();
    this.print(e.expression), t(), this.rightParens(e);
  }
  s(VRe, "ParenthesizedExpression");
  function KRe(e) {
    e.prefix ? (this.token(e.operator), this.print(e.argument)) : (this.print(e.argument, !0), this.token(e.operator));
  }
  s(KRe, "UpdateExpression");
  function HRe(e) {
    this.print(e.test), this.space(), this.tokenChar(63), this.space(), this.print(e.consequent), this.space(), this.tokenChar(58), this.space(),
    this.print(e.alternate);
  }
  s(HRe, "ConditionalExpression");
  function zRe(e, t) {
    if (this.word("new"), this.space(), this.print(e.callee), this.format.minified && e.arguments.length === 0 && !e.optional && !MRe(t, {
      callee: e
    }) && !FC(t) && !BRe(t) || (this.print(e.typeArguments), this.print(e.typeParameters), e.optional && this.token("?."), e.arguments.length ===
    0 && this.tokenMap && !this.tokenMap.endMatches(e, ")")))
      return;
    this.tokenChar(40);
    let r = this.enterDelimited();
    this.printList(e.arguments, this.shouldPrintTrailingComma(")")), r(), this.rightParens(e);
  }
  s(zRe, "NewExpression");
  function GRe(e) {
    this.printList(e.expressions);
  }
  s(GRe, "SequenceExpression");
  function WRe() {
    this.word("this");
  }
  s(WRe, "ThisExpression");
  function $Re() {
    this.word("super");
  }
  s($Re, "Super");
  function XRe(e) {
    return typeof this.format.decoratorsBeforeExport == "boolean" ? this.format.decoratorsBeforeExport : typeof e.start == "number" && e.start ===
    e.declaration.start;
  }
  s(XRe, "_shouldPrintDecoratorsBeforeExport");
  function YRe(e) {
    this.tokenChar(64), this.print(e.expression), this.newline();
  }
  s(YRe, "Decorator");
  function JRe(e) {
    let {
      computed: t
    } = e, {
      optional: r,
      property: i
    } = e;
    if (this.print(e.object), !t && FC(i))
      throw new TypeError("Got a MemberExpression for MemberExpression property");
    R5(i) && typeof i.value == "number" && (t = !0), r && this.token("?."), t ? (this.tokenChar(91), this.print(i), this.tokenChar(93)) : (r ||
    this.tokenChar(46), this.print(i));
  }
  s(JRe, "OptionalMemberExpression");
  function QRe(e) {
    this.print(e.callee), this.print(e.typeParameters), e.optional && this.token("?."), this.print(e.typeArguments), this.tokenChar(40);
    let t = this.enterDelimited();
    this.printList(e.arguments), t(), this.rightParens(e);
  }
  s(QRe, "OptionalCallExpression");
  function ZRe(e) {
    this.print(e.callee), this.print(e.typeArguments), this.print(e.typeParameters), this.tokenChar(40);
    let t = this.enterDelimited();
    this.printList(e.arguments, this.shouldPrintTrailingComma(")")), t(), this.rightParens(e);
  }
  s(ZRe, "CallExpression");
  function eNe() {
    this.word("import");
  }
  s(eNe, "Import");
  function tNe(e) {
    this.word("await"), e.argument && (this.space(), this.printTerminatorless(e.argument));
  }
  s(tNe, "AwaitExpression");
  function rNe(e) {
    this.word("yield", !0), e.delegate ? (this.tokenChar(42), e.argument && (this.space(), this.print(e.argument))) : e.argument && (this.space(),
    this.printTerminatorless(e.argument));
  }
  s(rNe, "YieldExpression");
  function iNe() {
    this.semicolon(!0);
  }
  s(iNe, "EmptyStatement");
  function nNe(e) {
    this.tokenContext |= FRe.TokenContext.expressionStatement, this.print(e.expression), this.semicolon();
  }
  s(nNe, "ExpressionStatement");
  function sNe(e) {
    this.print(e.left), (e.left.type === "Identifier" || qRe(e.left)) && (e.left.optional && this.tokenChar(63), this.print(e.left.typeAnnotation)),
    this.space(), this.tokenChar(61), this.space(), this.print(e.right);
  }
  s(sNe, "AssignmentPattern");
  function aNe(e) {
    this.print(e.left), this.space(), e.operator === "in" || e.operator === "instanceof" ? this.word(e.operator) : (this.token(e.operator), this.
    _endsWithDiv = e.operator === "/"), this.space(), this.print(e.right);
  }
  s(aNe, "AssignmentExpression");
  function oNe(e) {
    this.print(e.object), this.token("::"), this.print(e.callee);
  }
  s(oNe, "BindExpression");
  function uNe(e) {
    if (this.print(e.object), !e.computed && FC(e.property))
      throw new TypeError("Got a MemberExpression for MemberExpression property");
    let t = e.computed;
    if (R5(e.property) && typeof e.property.value == "number" && (t = !0), t) {
      let r = this.enterDelimited();
      this.tokenChar(91), this.print(e.property), this.tokenChar(93), r();
    } else
      this.tokenChar(46), this.print(e.property);
  }
  s(uNe, "MemberExpression");
  function lNe(e) {
    this.print(e.meta), this.tokenChar(46), this.print(e.property);
  }
  s(lNe, "MetaProperty");
  function cNe(e) {
    this.tokenChar(35), this.print(e.id);
  }
  s(cNe, "PrivateName");
  function fNe(e) {
    this.tokenChar(37), this.word(e.name);
  }
  s(fNe, "V8IntrinsicIdentifier");
  function pNe(e) {
    this.word("module", !0), this.space(), this.tokenChar(123), this.indent();
    let {
      body: t
    } = e;
    (t.body.length || t.directives.length) && this.newline(), this.print(t), this.dedent(), this.rightBrace(e);
  }
  s(pNe, "ModuleExpression");
});

// ../node_modules/@babel/generator/lib/generators/statements.js
var B5 = b((xi) => {
  "use strict";
  Object.defineProperty(xi, "__esModule", {
    value: !0
  });
  xi.BreakStatement = TNe;
  xi.CatchClause = DNe;
  xi.ContinueStatement = ENe;
  xi.DebuggerStatement = kNe;
  xi.DoWhileStatement = SNe;
  xi.ForOfStatement = xi.ForInStatement = void 0;
  xi.ForStatement = bNe;
  xi.IfStatement = _Ne;
  xi.LabeledStatement = CNe;
  xi.ReturnStatement = ANe;
  xi.SwitchCase = ONe;
  xi.SwitchStatement = wNe;
  xi.ThrowStatement = xNe;
  xi.TryStatement = PNe;
  xi.VariableDeclaration = INe;
  xi.VariableDeclarator = RNe;
  xi.WhileStatement = vNe;
  xi.WithStatement = gNe;
  var hNe = Xn(), MC = fl(), {
    isFor: L5,
    isForStatement: dNe,
    isIfStatement: mNe,
    isStatement: yNe
  } = hNe;
  function gNe(e) {
    this.word("with"), this.space(), this.tokenChar(40), this.print(e.object), this.tokenChar(41), this.printBlock(e);
  }
  s(gNe, "WithStatement");
  function _Ne(e) {
    this.word("if"), this.space(), this.tokenChar(40), this.print(e.test), this.tokenChar(41), this.space();
    let t = e.alternate && mNe(F5(e.consequent));
    t && (this.tokenChar(123), this.newline(), this.indent()), this.printAndIndentOnComments(e.consequent), t && (this.dedent(), this.newline(),
    this.tokenChar(125)), e.alternate && (this.endsWith(125) && this.space(), this.word("else"), this.space(), this.printAndIndentOnComments(
    e.alternate));
  }
  s(_Ne, "IfStatement");
  function F5(e) {
    let {
      body: t
    } = e;
    return yNe(t) === !1 ? e : F5(t);
  }
  s(F5, "getLastStatement");
  function bNe(e) {
    this.word("for"), this.space(), this.tokenChar(40);
    {
      let t = this.enterForStatementInit();
      this.tokenContext |= MC.TokenContext.forHead, this.print(e.init), t();
    }
    this.tokenChar(59), e.test && (this.space(), this.print(e.test)), this.token(";", !1, 1), e.update && (this.space(), this.print(e.update)),
    this.tokenChar(41), this.printBlock(e);
  }
  s(bNe, "ForStatement");
  function vNe(e) {
    this.word("while"), this.space(), this.tokenChar(40), this.print(e.test), this.tokenChar(41), this.printBlock(e);
  }
  s(vNe, "WhileStatement");
  function M5(e) {
    this.word("for"), this.space();
    let t = e.type === "ForOfStatement";
    t && e.await && (this.word("await"), this.space()), this.noIndentInnerCommentsHere(), this.tokenChar(40);
    {
      let r = t ? null : this.enterForStatementInit();
      this.tokenContext |= t ? MC.TokenContext.forOfHead : MC.TokenContext.forInHead, this.print(e.left), r?.();
    }
    this.space(), this.word(t ? "of" : "in"), this.space(), this.print(e.right), this.tokenChar(41), this.printBlock(e);
  }
  s(M5, "ForXStatement");
  var l1t = xi.ForInStatement = M5, c1t = xi.ForOfStatement = M5;
  function SNe(e) {
    this.word("do"), this.space(), this.print(e.body), this.space(), this.word("while"), this.space(), this.tokenChar(40), this.print(e.test),
    this.tokenChar(41), this.semicolon();
  }
  s(SNe, "DoWhileStatement");
  function D_(e, t) {
    t && (e.space(), e.printTerminatorless(t)), e.semicolon();
  }
  s(D_, "printStatementAfterKeyword");
  function TNe(e) {
    this.word("break"), D_(this, e.label);
  }
  s(TNe, "BreakStatement");
  function ENe(e) {
    this.word("continue"), D_(this, e.label);
  }
  s(ENe, "ContinueStatement");
  function ANe(e) {
    this.word("return"), D_(this, e.argument);
  }
  s(ANe, "ReturnStatement");
  function xNe(e) {
    this.word("throw"), D_(this, e.argument);
  }
  s(xNe, "ThrowStatement");
  function CNe(e) {
    this.print(e.label), this.tokenChar(58), this.space(), this.print(e.body);
  }
  s(CNe, "LabeledStatement");
  function PNe(e) {
    this.word("try"), this.space(), this.print(e.block), this.space(), e.handlers ? this.print(e.handlers[0]) : this.print(e.handler), e.finalizer &&
    (this.space(), this.word("finally"), this.space(), this.print(e.finalizer));
  }
  s(PNe, "TryStatement");
  function DNe(e) {
    this.word("catch"), this.space(), e.param && (this.tokenChar(40), this.print(e.param), this.print(e.param.typeAnnotation), this.tokenChar(
    41), this.space()), this.print(e.body);
  }
  s(DNe, "CatchClause");
  function wNe(e) {
    this.word("switch"), this.space(), this.tokenChar(40), this.print(e.discriminant), this.tokenChar(41), this.space(), this.tokenChar(123),
    this.printSequence(e.cases, !0, void 0, /* @__PURE__ */ s(function(r, i) {
      if (!r && e.cases[e.cases.length - 1] === i) return -1;
    }, "addNewlines")), this.rightBrace(e);
  }
  s(wNe, "SwitchStatement");
  function ONe(e) {
    e.test ? (this.word("case"), this.space(), this.print(e.test), this.tokenChar(58)) : (this.word("default"), this.tokenChar(58)), e.consequent.
    length && (this.newline(), this.printSequence(e.consequent, !0));
  }
  s(ONe, "SwitchCase");
  function kNe() {
    this.word("debugger"), this.semicolon();
  }
  s(kNe, "DebuggerStatement");
  function INe(e, t) {
    e.declare && (this.word("declare"), this.space());
    let {
      kind: r
    } = e;
    r === "await using" ? (this.word("await"), this.space(), this.word("using", !0)) : this.word(r, r === "using"), this.space();
    let i = !1;
    if (!L5(t))
      for (let n of e.declarations)
        n.init && (i = !0);
    if (this.printList(e.declarations, void 0, void 0, e.declarations.length > 1, i ? function(n) {
      this.token(",", !1, n), this.newline();
    } : void 0), L5(t)) {
      if (dNe(t)) {
        if (t.init === e) return;
      } else if (t.left === e) return;
    }
    this.semicolon();
  }
  s(INe, "VariableDeclaration");
  function RNe(e) {
    this.print(e.id), e.definite && this.tokenChar(33), this.print(e.id.typeAnnotation), e.init && (this.space(), this.tokenChar(61), this.space(),
    this.print(e.init));
  }
  s(RNe, "VariableDeclarator");
});

// ../node_modules/@babel/generator/lib/generators/classes.js
var q5 = b((Aa) => {
  "use strict";
  Object.defineProperty(Aa, "__esModule", {
    value: !0
  });
  Aa.ClassAccessorProperty = jNe;
  Aa.ClassBody = BNe;
  Aa.ClassExpression = Aa.ClassDeclaration = MNe;
  Aa.ClassMethod = KNe;
  Aa.ClassPrivateMethod = HNe;
  Aa.ClassPrivateProperty = VNe;
  Aa.ClassProperty = UNe;
  Aa.StaticBlock = GNe;
  Aa._classMethodHead = zNe;
  var NNe = Xn(), {
    isExportDefaultDeclaration: LNe,
    isExportNamedDeclaration: FNe
  } = NNe;
  function MNe(e, t) {
    (!(LNe(t) || FNe(t)) || !this._shouldPrintDecoratorsBeforeExport(t)) && this.printJoin(e.decorators), e.declare && (this.word("declare"),
    this.space()), e.abstract && (this.word("abstract"), this.space()), this.word("class"), e.id && (this.space(), this.print(e.id)), this.print(
    e.typeParameters), e.superClass && (this.space(), this.word("extends"), this.space(), this.print(e.superClass), this.print(e.superTypeParameters)),
    e.implements && (this.space(), this.word("implements"), this.space(), this.printList(e.implements)), this.space(), this.print(e.body);
  }
  s(MNe, "ClassDeclaration");
  function BNe(e) {
    if (this.tokenChar(123), e.body.length === 0)
      this.tokenChar(125);
    else {
      this.newline();
      let t = qNe(this, e);
      t?.(-1);
      let r = this.enterDelimited();
      this.printJoin(e.body, !0, !0, t, !0), r(), this.endsWith(10) || this.newline(), this.rightBrace(e);
    }
  }
  s(BNe, "ClassBody");
  function qNe(e, t) {
    if (!e.tokenMap || t.start == null || t.end == null)
      return null;
    let r = e.tokenMap.getIndexes(t);
    if (!r) return null;
    let i = 1, n = 0, a = 0, o = /* @__PURE__ */ s(() => {
      for (; a < t.body.length && t.body[a].start == null; )
        a++;
    }, "advanceNextLocIndex");
    return o(), (u) => {
      a <= u && (a = u + 1, o());
      let l = a === t.body.length ? t.end : t.body[a].start, c;
      for (; i < r.length && e.tokenMap.matchesOriginal(c = e._tokens[r[i]], ";") && c.start < l; )
        e.token(";", void 0, n++), i++;
    };
  }
  s(qNe, "classBodyEmptySemicolonsPrinter");
  function UNe(e) {
    if (this.printJoin(e.decorators), !e.static && !this.format.preserveFormat) {
      var t;
      let r = (t = e.key.loc) == null || (t = t.end) == null ? void 0 : t.line;
      r && this.catchUp(r);
    }
    this.tsPrintClassMemberModifiers(e), e.computed ? (this.tokenChar(91), this.print(e.key), this.tokenChar(93)) : (this._variance(e), this.
    print(e.key)), e.optional && this.tokenChar(63), e.definite && this.tokenChar(33), this.print(e.typeAnnotation), e.value && (this.space(),
    this.tokenChar(61), this.space(), this.print(e.value)), this.semicolon();
  }
  s(UNe, "ClassProperty");
  function jNe(e) {
    var t;
    this.printJoin(e.decorators);
    let r = (t = e.key.loc) == null || (t = t.end) == null ? void 0 : t.line;
    r && this.catchUp(r), this.tsPrintClassMemberModifiers(e), this.word("accessor", !0), this.space(), e.computed ? (this.tokenChar(91), this.
    print(e.key), this.tokenChar(93)) : (this._variance(e), this.print(e.key)), e.optional && this.tokenChar(63), e.definite && this.tokenChar(
    33), this.print(e.typeAnnotation), e.value && (this.space(), this.tokenChar(61), this.space(), this.print(e.value)), this.semicolon();
  }
  s(jNe, "ClassAccessorProperty");
  function VNe(e) {
    this.printJoin(e.decorators), this.tsPrintClassMemberModifiers(e), this.print(e.key), e.optional && this.tokenChar(63), e.definite && this.
    tokenChar(33), this.print(e.typeAnnotation), e.value && (this.space(), this.tokenChar(61), this.space(), this.print(e.value)), this.semicolon();
  }
  s(VNe, "ClassPrivateProperty");
  function KNe(e) {
    this._classMethodHead(e), this.space(), this.print(e.body);
  }
  s(KNe, "ClassMethod");
  function HNe(e) {
    this._classMethodHead(e), this.space(), this.print(e.body);
  }
  s(HNe, "ClassPrivateMethod");
  function zNe(e) {
    if (this.printJoin(e.decorators), !this.format.preserveFormat) {
      var t;
      let r = (t = e.key.loc) == null || (t = t.end) == null ? void 0 : t.line;
      r && this.catchUp(r);
    }
    this.tsPrintClassMemberModifiers(e), this._methodHead(e);
  }
  s(zNe, "_classMethodHead");
  function GNe(e) {
    this.word("static"), this.space(), this.tokenChar(123), e.body.length === 0 ? this.tokenChar(125) : (this.newline(), this.printSequence(
    e.body, !0), this.rightBrace(e));
  }
  s(GNe, "StaticBlock");
});

// ../node_modules/@babel/generator/lib/generators/methods.js
var U5 = b((xa) => {
  "use strict";
  Object.defineProperty(xa, "__esModule", {
    value: !0
  });
  xa.ArrowFunctionExpression = iLe;
  xa.FunctionDeclaration = xa.FunctionExpression = rLe;
  xa._functionHead = tLe;
  xa._methodHead = ZNe;
  xa._param = QNe;
  xa._parameters = JNe;
  xa._params = YNe;
  xa._predicate = eLe;
  xa._shouldPrintArrowParamsParens = nLe;
  var WNe = Xn(), $Ne = fl(), {
    isIdentifier: XNe
  } = WNe;
  function YNe(e, t, r) {
    this.print(e.typeParameters);
    let i = sLe.call(this, t, r);
    i && this.sourceIdentifierName(i.name, i.pos), this.tokenChar(40), this._parameters(e.params, ")");
    let n = e.type === "ArrowFunctionExpression";
    this.print(e.returnType, n), this._noLineTerminator = n;
  }
  s(YNe, "_params");
  function JNe(e, t) {
    let r = this.enterDelimited(), i = this.shouldPrintTrailingComma(t), n = e.length;
    for (let a = 0; a < n; a++)
      this._param(e[a]), (i || a < n - 1) && (this.token(",", null, a), this.space());
    this.token(t), r();
  }
  s(JNe, "_parameters");
  function QNe(e) {
    this.printJoin(e.decorators), this.print(e), e.optional && this.tokenChar(63), this.print(e.typeAnnotation);
  }
  s(QNe, "_param");
  function ZNe(e) {
    let t = e.kind, r = e.key;
    (t === "get" || t === "set") && (this.word(t), this.space()), e.async && (this.word("async", !0), this.space()), (t === "method" || t ===
    "init") && e.generator && this.tokenChar(42), e.computed ? (this.tokenChar(91), this.print(r), this.tokenChar(93)) : this.print(r), e.optional &&
    this.tokenChar(63), this._params(e, e.computed && e.key.type !== "StringLiteral" ? void 0 : e.key, void 0);
  }
  s(ZNe, "_methodHead");
  function eLe(e, t) {
    e.predicate && (e.returnType || this.tokenChar(58), this.space(), this.print(e.predicate, t));
  }
  s(eLe, "_predicate");
  function tLe(e, t) {
    e.async && (this.word("async"), this.format.preserveFormat || (this._endsWithInnerRaw = !1), this.space()), this.word("function"), e.generator &&
    (this.format.preserveFormat || (this._endsWithInnerRaw = !1), this.tokenChar(42)), this.space(), e.id && this.print(e.id), this._params(
    e, e.id, t), e.type !== "TSDeclareFunction" && this._predicate(e);
  }
  s(tLe, "_functionHead");
  function rLe(e, t) {
    this._functionHead(e, t), this.space(), this.print(e.body);
  }
  s(rLe, "FunctionExpression");
  function iLe(e, t) {
    e.async && (this.word("async", !0), this.space()), this._shouldPrintArrowParamsParens(e) ? this._params(e, void 0, t) : this.print(e.params[0],
    !0), this._predicate(e, !0), this.space(), this.printInnerComments(), this.token("=>"), this.space(), this.tokenContext |= $Ne.TokenContext.
    arrowBody, this.print(e.body);
  }
  s(iLe, "ArrowFunctionExpression");
  function nLe(e) {
    var t, r;
    if (e.params.length !== 1 || e.typeParameters || e.returnType || e.predicate)
      return !0;
    let i = e.params[0];
    if (!XNe(i) || i.typeAnnotation || i.optional || (t = i.leadingComments) != null && t.length || (r = i.trailingComments) != null && r.length)
      return !0;
    if (this.tokenMap) {
      if (e.loc == null || this.tokenMap.findMatching(e, "(") !== null) return !0;
      let n = this.tokenMap.findMatching(e, "=>");
      return n?.loc == null ? !0 : n.loc.start.line !== e.loc.start.line;
    }
    return !!this.format.retainLines;
  }
  s(nLe, "_shouldPrintArrowParamsParens");
  function sLe(e, t) {
    let r = e;
    if (!r && t) {
      let l = t.type;
      l === "VariableDeclarator" ? r = t.id : l === "AssignmentExpression" || l === "AssignmentPattern" ? r = t.left : l === "ObjectProperty" ||
      l === "ClassProperty" ? (!t.computed || t.key.type === "StringLiteral") && (r = t.key) : (l === "ClassPrivateProperty" || l === "Class\
AccessorProperty") && (r = t.key);
    }
    if (!r) return;
    let i;
    if (r.type === "Identifier") {
      var n, a;
      i = {
        pos: (n = r.loc) == null ? void 0 : n.start,
        name: ((a = r.loc) == null ? void 0 : a.identifierName) || r.name
      };
    } else if (r.type === "PrivateName") {
      var o;
      i = {
        pos: (o = r.loc) == null ? void 0 : o.start,
        name: "#" + r.id.name
      };
    } else if (r.type === "StringLiteral") {
      var u;
      i = {
        pos: (u = r.loc) == null ? void 0 : u.start,
        name: r.value
      };
    }
    return i;
  }
  s(sLe, "_getFuncIdName");
});

// ../node_modules/@babel/generator/lib/generators/modules.js
var BC = b((hs) => {
  "use strict";
  Object.defineProperty(hs, "__esModule", {
    value: !0
  });
  hs.ExportAllDeclaration = bLe;
  hs.ExportDefaultDeclaration = SLe;
  hs.ExportDefaultSpecifier = mLe;
  hs.ExportNamedDeclaration = vLe;
  hs.ExportNamespaceSpecifier = gLe;
  hs.ExportSpecifier = yLe;
  hs.ImportAttribute = ELe;
  hs.ImportDeclaration = TLe;
  hs.ImportDefaultSpecifier = dLe;
  hs.ImportExpression = xLe;
  hs.ImportNamespaceSpecifier = ALe;
  hs.ImportSpecifier = hLe;
  hs._printAttributes = _Le;
  var aLe = Xn(), oLe = fl(), {
    isClassDeclaration: uLe,
    isExportDefaultSpecifier: lLe,
    isExportNamespaceSpecifier: cLe,
    isImportDefaultSpecifier: fLe,
    isImportNamespaceSpecifier: pLe,
    isStatement: V5
  } = aLe;
  function hLe(e) {
    (e.importKind === "type" || e.importKind === "typeof") && (this.word(e.importKind), this.space()), this.print(e.imported), e.local && e.
    local.name !== e.imported.name && (this.space(), this.word("as"), this.space(), this.print(e.local));
  }
  s(hLe, "ImportSpecifier");
  function dLe(e) {
    this.print(e.local);
  }
  s(dLe, "ImportDefaultSpecifier");
  function mLe(e) {
    this.print(e.exported);
  }
  s(mLe, "ExportDefaultSpecifier");
  function yLe(e) {
    e.exportKind === "type" && (this.word("type"), this.space()), this.print(e.local), e.exported && e.local.name !== e.exported.name && (this.
    space(), this.word("as"), this.space(), this.print(e.exported));
  }
  s(yLe, "ExportSpecifier");
  function gLe(e) {
    this.tokenChar(42), this.space(), this.word("as"), this.space(), this.print(e.exported);
  }
  s(gLe, "ExportNamespaceSpecifier");
  var j5 = !1;
  function _Le(e, t) {
    var r;
    let {
      importAttributesKeyword: i
    } = this.format, {
      attributes: n,
      assertions: a
    } = e;
    n && !i && e.extra && (e.extra.deprecatedAssertSyntax || e.extra.deprecatedWithLegacySyntax) && !j5 && (j5 = !0, console.warn('You are u\
sing import attributes, without specifying the desired output syntax.\nPlease specify the "importAttributesKeyword" generator option, whose v\
alue can be one of:\n - "with"        : `import { a } from "b" with { type: "json" };`\n - "assert"      : `import { a } from "b" assert { typ\
e: "json" };`\n - "with-legacy" : `import { a } from "b" with type: "json";`\n'));
    let o = i === "assert" || !i && a;
    if (this.word(o ? "assert" : "with"), this.space(), !o && (i === "with-legacy" || !i && (r = e.extra) != null && r.deprecatedWithLegacySyntax)) {
      this.printList(n || a);
      return;
    }
    let u = t ? 1 : 0;
    this.token("{", null, u), this.space(), this.printList(n || a, this.shouldPrintTrailingComma("}")), this.space(), this.token("}", null, u);
  }
  s(_Le, "_printAttributes");
  function bLe(e) {
    var t, r;
    this.word("export"), this.space(), e.exportKind === "type" && (this.word("type"), this.space()), this.tokenChar(42), this.space(), this.
    word("from"), this.space(), (t = e.attributes) != null && t.length || (r = e.assertions) != null && r.length ? (this.print(e.source, !0),
    this.space(), this._printAttributes(e, !1)) : this.print(e.source), this.semicolon();
  }
  s(bLe, "ExportAllDeclaration");
  function K5(e, t) {
    uLe(t.declaration) && e._shouldPrintDecoratorsBeforeExport(t) && e.printJoin(t.declaration.decorators);
  }
  s(K5, "maybePrintDecoratorsBeforeExport");
  function vLe(e) {
    if (K5(this, e), this.word("export"), this.space(), e.declaration) {
      let i = e.declaration;
      this.print(i), V5(i) || this.semicolon();
    } else {
      e.exportKind === "type" && (this.word("type"), this.space());
      let i = e.specifiers.slice(0), n = !1;
      for (; ; ) {
        let o = i[0];
        if (lLe(o) || cLe(o))
          n = !0, this.print(i.shift()), i.length && (this.tokenChar(44), this.space());
        else
          break;
      }
      let a = !1;
      if ((i.length || !i.length && !n) && (a = !0, this.tokenChar(123), i.length && (this.space(), this.printList(i, this.shouldPrintTrailingComma(
      "}")), this.space()), this.tokenChar(125)), e.source) {
        var t, r;
        this.space(), this.word("from"), this.space(), (t = e.attributes) != null && t.length || (r = e.assertions) != null && r.length ? (this.
        print(e.source, !0), this.space(), this._printAttributes(e, a)) : this.print(e.source);
      }
      this.semicolon();
    }
  }
  s(vLe, "ExportNamedDeclaration");
  function SLe(e) {
    K5(this, e), this.word("export"), this.noIndentInnerCommentsHere(), this.space(), this.word("default"), this.space(), this.tokenContext |=
    oLe.TokenContext.exportDefault;
    let t = e.declaration;
    this.print(t), V5(t) || this.semicolon();
  }
  s(SLe, "ExportDefaultDeclaration");
  function TLe(e) {
    var t, r;
    this.word("import"), this.space();
    let i = e.importKind === "type" || e.importKind === "typeof";
    i ? (this.noIndentInnerCommentsHere(), this.word(e.importKind), this.space()) : e.module ? (this.noIndentInnerCommentsHere(), this.word(
    "module"), this.space()) : e.phase && (this.noIndentInnerCommentsHere(), this.word(e.phase), this.space());
    let n = e.specifiers.slice(0), a = !!n.length;
    for (; a; ) {
      let u = n[0];
      if (fLe(u) || pLe(u))
        this.print(n.shift()), n.length && (this.tokenChar(44), this.space());
      else
        break;
    }
    let o = !1;
    n.length ? (o = !0, this.tokenChar(123), this.space(), this.printList(n, this.shouldPrintTrailingComma("}")), this.space(), this.tokenChar(
    125)) : i && !a && (o = !0, this.tokenChar(123), this.tokenChar(125)), (a || i) && (this.space(), this.word("from"), this.space()), (t =
    e.attributes) != null && t.length || (r = e.assertions) != null && r.length ? (this.print(e.source, !0), this.space(), this._printAttributes(
    e, o)) : this.print(e.source), this.semicolon();
  }
  s(TLe, "ImportDeclaration");
  function ELe(e) {
    this.print(e.key), this.tokenChar(58), this.space(), this.print(e.value);
  }
  s(ELe, "ImportAttribute");
  function ALe(e) {
    this.tokenChar(42), this.space(), this.word("as"), this.space(), this.print(e.local);
  }
  s(ALe, "ImportNamespaceSpecifier");
  function xLe(e) {
    this.word("import"), e.phase && (this.tokenChar(46), this.word(e.phase)), this.tokenChar(40), this.print(e.source), e.options != null &&
    (this.tokenChar(44), this.space(), this.print(e.options)), this.tokenChar(41);
  }
  s(xLe, "ImportExpression");
});

// ../node_modules/jsesc/jsesc.js
var W5 = b((b1t, G5) => {
  "use strict";
  var H5 = {}, CLe = H5.hasOwnProperty, z5 = /* @__PURE__ */ s((e, t) => {
    for (let r in e)
      CLe.call(e, r) && t(r, e[r]);
  }, "forOwn"), PLe = /* @__PURE__ */ s((e, t) => (t && z5(t, (r, i) => {
    e[r] = i;
  }), e), "extend"), DLe = /* @__PURE__ */ s((e, t) => {
    let r = e.length, i = -1;
    for (; ++i < r; )
      t(e[i]);
  }, "forEach"), w_ = /* @__PURE__ */ s((e) => "\\u" + ("0000" + e).slice(-4), "fourHexEscape"), yd = /* @__PURE__ */ s((e, t) => {
    let r = e.toString(16);
    return t ? r : r.toUpperCase();
  }, "hexadecimal"), gd = H5.toString, wLe = Array.isArray, OLe = /* @__PURE__ */ s((e) => typeof Buffer == "function" && Buffer.isBuffer(e),
  "isBuffer"), kLe = /* @__PURE__ */ s((e) => gd.call(e) == "[object Object]", "isObject"), ILe = /* @__PURE__ */ s((e) => typeof e == "stri\
ng" || gd.call(e) == "[object String]", "isString"), RLe = /* @__PURE__ */ s((e) => typeof e == "number" || gd.call(e) == "[object Number]",
  "isNumber"), qC = /* @__PURE__ */ s((e) => typeof e == "bigint", "isBigInt"), NLe = /* @__PURE__ */ s((e) => typeof e == "function", "isFu\
nction"), LLe = /* @__PURE__ */ s((e) => gd.call(e) == "[object Map]", "isMap"), FLe = /* @__PURE__ */ s((e) => gd.call(e) == "[object Set]",
  "isSet"), MLe = {
    "\\": "\\\\",
    "\b": "\\b",
    "\f": "\\f",
    "\n": "\\n",
    "\r": "\\r",
    "	": "\\t"
    // `\v` is omitted intentionally, because in IE < 9, '\v' == 'v'.
    // '\v': '\\x0B'
  }, BLe = /[\\\b\f\n\r\t]/, qLe = /[0-9]/, ULe = /[\xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/, jLe = /([\uD800-\uDBFF][\uDC00-\uDFFF])|([\uD800-\uDFFF])|(['"`])|[^]/g,
  VLe = /([\uD800-\uDBFF][\uDC00-\uDFFF])|([\uD800-\uDFFF])|(['"`])|[^ !#-&\(-\[\]-_a-~]/g, pl = /* @__PURE__ */ s((e, t) => {
    let r = /* @__PURE__ */ s(() => {
      c = l, ++t.indentLevel, l = t.indent.repeat(t.indentLevel);
    }, "increaseIndentation"), i = {
      escapeEverything: !1,
      minimal: !1,
      isScriptContext: !1,
      quotes: "single",
      wrap: !1,
      es6: !1,
      json: !1,
      compact: !0,
      lowercaseHex: !1,
      numbers: "decimal",
      indent: "	",
      indentLevel: 0,
      __inline1__: !1,
      __inline2__: !1
    }, n = t && t.json;
    n && (i.quotes = "double", i.wrap = !0), t = PLe(i, t), t.quotes != "single" && t.quotes != "double" && t.quotes != "backtick" && (t.quotes =
    "single");
    let a = t.quotes == "double" ? '"' : t.quotes == "backtick" ? "`" : "'", o = t.compact, u = t.lowercaseHex, l = t.indent.repeat(t.indentLevel),
    c = "", p = t.__inline1__, h = t.__inline2__, y = o ? "" : `
`, _, g = !0, m = t.numbers == "binary", f = t.numbers == "octal", d = t.numbers == "decimal", v = t.numbers == "hexadecimal";
    if (n && e && NLe(e.toJSON) && (e = e.toJSON()), !ILe(e)) {
      if (LLe(e))
        return e.size == 0 ? "new Map()" : (o || (t.__inline1__ = !0, t.__inline2__ = !1), "new Map(" + pl(Array.from(e), t) + ")");
      if (FLe(e))
        return e.size == 0 ? "new Set()" : "new Set(" + pl(Array.from(e), t) + ")";
      if (OLe(e))
        return e.length == 0 ? "Buffer.from([])" : "Buffer.from(" + pl(Array.from(e), t) + ")";
      if (wLe(e))
        return _ = [], t.wrap = !0, p && (t.__inline1__ = !1, t.__inline2__ = !0), h || r(), DLe(e, (S) => {
          g = !1, h && (t.__inline2__ = !1), _.push(
            (o || h ? "" : l) + pl(S, t)
          );
        }), g ? "[]" : h ? "[" + _.join(", ") + "]" : "[" + y + _.join("," + y) + y + (o ? "" : c) + "]";
      if (RLe(e) || qC(e)) {
        if (n)
          return JSON.stringify(Number(e));
        let S;
        if (d)
          S = String(e);
        else if (v) {
          let x = e.toString(16);
          u || (x = x.toUpperCase()), S = "0x" + x;
        } else m ? S = "0b" + e.toString(2) : f && (S = "0o" + e.toString(8));
        return qC(e) ? S + "n" : S;
      } else return qC(e) ? n ? JSON.stringify(Number(e)) : e + "n" : kLe(e) ? (_ = [], t.wrap = !0, r(), z5(e, (S, x) => {
        g = !1, _.push(
          (o ? "" : l) + pl(S, t) + ":" + (o ? "" : " ") + pl(x, t)
        );
      }), g ? "{}" : "{" + y + _.join("," + y) + y + (o ? "" : c) + "}") : n ? JSON.stringify(e) || "null" : String(e);
    }
    let E = t.escapeEverything ? jLe : VLe;
    return _ = e.replace(E, (S, x, C, z, w, D) => {
      if (x) {
        if (t.minimal) return x;
        let T = x.charCodeAt(0), R = x.charCodeAt(1);
        if (t.es6) {
          let j = (T - 55296) * 1024 + R - 56320 + 65536;
          return "\\u{" + yd(j, u) + "}";
        }
        return w_(yd(T, u)) + w_(yd(R, u));
      }
      if (C)
        return w_(yd(C.charCodeAt(0), u));
      if (S == "\0" && !n && !qLe.test(D.charAt(w + 1)))
        return "\\0";
      if (z)
        return z == a || t.escapeEverything ? "\\" + z : z;
      if (BLe.test(S))
        return MLe[S];
      if (t.minimal && !ULe.test(S))
        return S;
      let N = yd(S.charCodeAt(0), u);
      return n || N.length > 2 ? w_(N) : "\\x" + ("00" + N).slice(-2);
    }), a == "`" && (_ = _.replace(/\$\{/g, "\\${")), t.isScriptContext && (_ = _.replace(/<\/(script|style)/gi, "<\\/$1").replace(/<!--/g, n ?
    "\\u003C!--" : "\\x3C!--")), t.wrap && (_ = a + _ + a), _;
  }, "jsesc");
  pl.version = "3.0.2";
  G5.exports = pl;
});

// ../node_modules/@babel/generator/lib/generators/types.js
var jC = b((ii) => {
  "use strict";
  Object.defineProperty(ii, "__esModule", {
    value: !0
  });
  ii.ArgumentPlaceholder = WLe;
  ii.ArrayPattern = ii.ArrayExpression = QLe;
  ii.BigIntLiteral = aFe;
  ii.BooleanLiteral = rFe;
  ii.Identifier = GLe;
  ii.NullLiteral = iFe;
  ii.NumericLiteral = nFe;
  ii.ObjectPattern = ii.ObjectExpression = XLe;
  ii.ObjectMethod = YLe;
  ii.ObjectProperty = JLe;
  ii.PipelineBareFunction = lFe;
  ii.PipelinePrimaryTopicReference = cFe;
  ii.PipelineTopicExpression = uFe;
  ii.RecordExpression = ZLe;
  ii.RegExpLiteral = tFe;
  ii.SpreadElement = ii.RestElement = $Le;
  ii.StringLiteral = sFe;
  ii.TopicReference = oFe;
  ii.TupleExpression = eFe;
  ii._getRawIdentifier = zLe;
  var KLe = Xn(), Y5 = W5(), {
    isAssignmentPattern: HLe,
    isIdentifier: UC
  } = KLe, $5 = null, O_ = "";
  function zLe(e) {
    if (e === $5) return O_;
    $5 = e;
    let {
      name: t
    } = e, r = this.tokenMap.find(e, (i) => i.value === t);
    return r ? (O_ = this._originalCode.slice(r.start, r.end), O_) : O_ = e.name;
  }
  s(zLe, "_getRawIdentifier");
  function GLe(e) {
    var t;
    this.sourceIdentifierName(((t = e.loc) == null ? void 0 : t.identifierName) || e.name), this.word(this.tokenMap ? this._getRawIdentifier(
    e) : e.name);
  }
  s(GLe, "Identifier");
  function WLe() {
    this.tokenChar(63);
  }
  s(WLe, "ArgumentPlaceholder");
  function $Le(e) {
    this.token("..."), this.print(e.argument);
  }
  s($Le, "RestElement");
  function XLe(e) {
    let t = e.properties;
    if (this.tokenChar(123), t.length) {
      let r = this.enterDelimited();
      this.space(), this.printList(t, this.shouldPrintTrailingComma("}"), !0, !0), this.space(), r();
    }
    this.sourceWithOffset("end", e.loc, -1), this.tokenChar(125);
  }
  s(XLe, "ObjectExpression");
  function YLe(e) {
    this.printJoin(e.decorators), this._methodHead(e), this.space(), this.print(e.body);
  }
  s(YLe, "ObjectMethod");
  function JLe(e) {
    if (this.printJoin(e.decorators), e.computed)
      this.tokenChar(91), this.print(e.key), this.tokenChar(93);
    else {
      if (HLe(e.value) && UC(e.key) && e.key.name === e.value.left.name) {
        this.print(e.value);
        return;
      }
      if (this.print(e.key), e.shorthand && UC(e.key) && UC(e.value) && e.key.name === e.value.name)
        return;
    }
    this.tokenChar(58), this.space(), this.print(e.value);
  }
  s(JLe, "ObjectProperty");
  function QLe(e) {
    let t = e.elements, r = t.length;
    this.tokenChar(91);
    let i = this.enterDelimited();
    for (let n = 0; n < t.length; n++) {
      let a = t[n];
      a ? (n > 0 && this.space(), this.print(a), (n < r - 1 || this.shouldPrintTrailingComma("]")) && this.token(",", !1, n)) : this.token("\
,", !1, n);
    }
    i(), this.tokenChar(93);
  }
  s(QLe, "ArrayExpression");
  function ZLe(e) {
    let t = e.properties, r, i;
    if (this.format.recordAndTupleSyntaxType === "bar")
      r = "{|", i = "|}";
    else {
      if (this.format.recordAndTupleSyntaxType !== "hash" && this.format.recordAndTupleSyntaxType != null)
        throw new Error(`The "recordAndTupleSyntaxType" generator option must be "bar" or "hash" (${JSON.stringify(this.format.recordAndTupleSyntaxType)}\
 received).`);
      r = "#{", i = "}";
    }
    this.token(r), t.length && (this.space(), this.printList(t, this.shouldPrintTrailingComma(i), !0, !0), this.space()), this.token(i);
  }
  s(ZLe, "RecordExpression");
  function eFe(e) {
    let t = e.elements, r = t.length, i, n;
    if (this.format.recordAndTupleSyntaxType === "bar")
      i = "[|", n = "|]";
    else if (this.format.recordAndTupleSyntaxType === "hash")
      i = "#[", n = "]";
    else
      throw new Error(`${this.format.recordAndTupleSyntaxType} is not a valid recordAndTuple syntax type`);
    this.token(i);
    for (let a = 0; a < t.length; a++) {
      let o = t[a];
      o && (a > 0 && this.space(), this.print(o), (a < r - 1 || this.shouldPrintTrailingComma(n)) && this.token(",", !1, a));
    }
    this.token(n);
  }
  s(eFe, "TupleExpression");
  function tFe(e) {
    this.word(`/${e.pattern}/${e.flags}`);
  }
  s(tFe, "RegExpLiteral");
  function rFe(e) {
    this.word(e.value ? "true" : "false");
  }
  s(rFe, "BooleanLiteral");
  function iFe() {
    this.word("null");
  }
  s(iFe, "NullLiteral");
  function nFe(e) {
    let t = this.getPossibleRaw(e), r = this.format.jsescOption, i = e.value, n = i + "";
    r.numbers ? this.number(Y5(i, r), i) : t == null ? this.number(n, i) : this.format.minified ? this.number(t.length < n.length ? t : n, i) :
    this.number(t, i);
  }
  s(nFe, "NumericLiteral");
  function sFe(e) {
    let t = this.getPossibleRaw(e);
    if (!this.format.minified && t !== void 0) {
      this.token(t);
      return;
    }
    let r = Y5(e.value, this.format.jsescOption);
    this.token(r);
  }
  s(sFe, "StringLiteral");
  function aFe(e) {
    let t = this.getPossibleRaw(e);
    if (!this.format.minified && t !== void 0) {
      this.word(t);
      return;
    }
    this.word(e.value + "n");
  }
  s(aFe, "BigIntLiteral");
  var X5 = /* @__PURE__ */ new Set(["^^", "@@", "^", "%", "#"]);
  function oFe() {
    let {
      topicToken: e
    } = this.format;
    if (X5.has(e))
      this.token(e);
    else {
      let t = JSON.stringify(e), r = Array.from(X5, (i) => JSON.stringify(i));
      throw new Error(`The "topicToken" generator option must be one of ${r.join(", ")} (${t} received instead).`);
    }
  }
  s(oFe, "TopicReference");
  function uFe(e) {
    this.print(e.expression);
  }
  s(uFe, "PipelineTopicExpression");
  function lFe(e) {
    this.print(e.callee);
  }
  s(lFe, "PipelineBareFunction");
  function cFe() {
    this.tokenChar(35);
  }
  s(cFe, "PipelinePrimaryTopicReference");
});

// ../node_modules/@babel/generator/lib/generators/flow.js
var Q5 = b((Ke) => {
  "use strict";
  Object.defineProperty(Ke, "__esModule", {
    value: !0
  });
  Ke.AnyTypeAnnotation = mFe;
  Ke.ArrayTypeAnnotation = yFe;
  Ke.BooleanLiteralTypeAnnotation = _Fe;
  Ke.BooleanTypeAnnotation = gFe;
  Ke.DeclareClass = vFe;
  Ke.DeclareExportAllDeclaration = kFe;
  Ke.DeclareExportDeclaration = OFe;
  Ke.DeclareFunction = SFe;
  Ke.DeclareInterface = AFe;
  Ke.DeclareModule = xFe;
  Ke.DeclareModuleExports = CFe;
  Ke.DeclareOpaqueType = DFe;
  Ke.DeclareTypeAlias = PFe;
  Ke.DeclareVariable = wFe;
  Ke.DeclaredPredicate = EFe;
  Ke.EmptyTypeAnnotation = ZFe;
  Ke.EnumBooleanBody = RFe;
  Ke.EnumBooleanMember = BFe;
  Ke.EnumDeclaration = IFe;
  Ke.EnumDefaultedMember = MFe;
  Ke.EnumNumberBody = NFe;
  Ke.EnumNumberMember = qFe;
  Ke.EnumStringBody = LFe;
  Ke.EnumStringMember = UFe;
  Ke.EnumSymbolBody = FFe;
  Ke.ExistsTypeAnnotation = VFe;
  Ke.FunctionTypeAnnotation = KFe;
  Ke.FunctionTypeParam = HFe;
  Ke.IndexedAccessType = AMe;
  Ke.InferredPredicate = TFe;
  Ke.InterfaceDeclaration = $Fe;
  Ke.GenericTypeAnnotation = Ke.ClassImplements = Ke.InterfaceExtends = zFe;
  Ke.InterfaceTypeAnnotation = YFe;
  Ke.IntersectionTypeAnnotation = JFe;
  Ke.MixedTypeAnnotation = QFe;
  Ke.NullLiteralTypeAnnotation = bFe;
  Ke.NullableTypeAnnotation = eMe;
  Object.defineProperty(Ke, "NumberLiteralTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return J5.NumericLiteral;
    }, "get")
  });
  Ke.NumberTypeAnnotation = tMe;
  Ke.ObjectTypeAnnotation = fMe;
  Ke.ObjectTypeCallProperty = hMe;
  Ke.ObjectTypeIndexer = dMe;
  Ke.ObjectTypeInternalSlot = pMe;
  Ke.ObjectTypeProperty = mMe;
  Ke.ObjectTypeSpreadProperty = yMe;
  Ke.OpaqueType = cMe;
  Ke.OptionalIndexedAccessType = xMe;
  Ke.QualifiedTypeIdentifier = gMe;
  Object.defineProperty(Ke, "StringLiteralTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return J5.StringLiteral;
    }, "get")
  });
  Ke.StringTypeAnnotation = rMe;
  Ke.SymbolTypeAnnotation = _Me;
  Ke.ThisTypeAnnotation = iMe;
  Ke.TupleTypeAnnotation = nMe;
  Ke.TypeAlias = aMe;
  Ke.TypeAnnotation = oMe;
  Ke.TypeCastExpression = SMe;
  Ke.TypeParameter = lMe;
  Ke.TypeParameterDeclaration = Ke.TypeParameterInstantiation = uMe;
  Ke.TypeofTypeAnnotation = sMe;
  Ke.UnionTypeAnnotation = vMe;
  Ke.Variance = TMe;
  Ke.VoidTypeAnnotation = EMe;
  Ke._interfaceish = GFe;
  Ke._variance = WFe;
  var fFe = Xn(), pFe = BC(), hFe = fl(), J5 = jC(), {
    isDeclareExportDeclaration: k_,
    isStatement: dFe
  } = fFe;
  function mFe() {
    this.word("any");
  }
  s(mFe, "AnyTypeAnnotation");
  function yFe(e) {
    this.print(e.elementType, !0), this.tokenChar(91), this.tokenChar(93);
  }
  s(yFe, "ArrayTypeAnnotation");
  function gFe() {
    this.word("boolean");
  }
  s(gFe, "BooleanTypeAnnotation");
  function _Fe(e) {
    this.word(e.value ? "true" : "false");
  }
  s(_Fe, "BooleanLiteralTypeAnnotation");
  function bFe() {
    this.word("null");
  }
  s(bFe, "NullLiteralTypeAnnotation");
  function vFe(e, t) {
    k_(t) || (this.word("declare"), this.space()), this.word("class"), this.space(), this._interfaceish(e);
  }
  s(vFe, "DeclareClass");
  function SFe(e, t) {
    k_(t) || (this.word("declare"), this.space()), this.word("function"), this.space(), this.print(e.id), this.print(e.id.typeAnnotation.typeAnnotation),
    e.predicate && (this.space(), this.print(e.predicate)), this.semicolon();
  }
  s(SFe, "DeclareFunction");
  function TFe() {
    this.tokenChar(37), this.word("checks");
  }
  s(TFe, "InferredPredicate");
  function EFe(e) {
    this.tokenChar(37), this.word("checks"), this.tokenChar(40), this.print(e.value), this.tokenChar(41);
  }
  s(EFe, "DeclaredPredicate");
  function AFe(e) {
    this.word("declare"), this.space(), this.InterfaceDeclaration(e);
  }
  s(AFe, "DeclareInterface");
  function xFe(e) {
    this.word("declare"), this.space(), this.word("module"), this.space(), this.print(e.id), this.space(), this.print(e.body);
  }
  s(xFe, "DeclareModule");
  function CFe(e) {
    this.word("declare"), this.space(), this.word("module"), this.tokenChar(46), this.word("exports"), this.print(e.typeAnnotation);
  }
  s(CFe, "DeclareModuleExports");
  function PFe(e) {
    this.word("declare"), this.space(), this.TypeAlias(e);
  }
  s(PFe, "DeclareTypeAlias");
  function DFe(e, t) {
    k_(t) || (this.word("declare"), this.space()), this.OpaqueType(e);
  }
  s(DFe, "DeclareOpaqueType");
  function wFe(e, t) {
    k_(t) || (this.word("declare"), this.space()), this.word("var"), this.space(), this.print(e.id), this.print(e.id.typeAnnotation), this.semicolon();
  }
  s(wFe, "DeclareVariable");
  function OFe(e) {
    this.word("declare"), this.space(), this.word("export"), this.space(), e.default && (this.word("default"), this.space()), jFe.call(this,
    e);
  }
  s(OFe, "DeclareExportDeclaration");
  function kFe(e) {
    this.word("declare"), this.space(), pFe.ExportAllDeclaration.call(this, e);
  }
  s(kFe, "DeclareExportAllDeclaration");
  function IFe(e) {
    let {
      id: t,
      body: r
    } = e;
    this.word("enum"), this.space(), this.print(t), this.print(r);
  }
  s(IFe, "EnumDeclaration");
  function I_(e, t, r) {
    r && (e.space(), e.word("of"), e.space(), e.word(t)), e.space();
  }
  s(I_, "enumExplicitType");
  function R_(e, t) {
    let {
      members: r
    } = t;
    e.token("{"), e.indent(), e.newline();
    for (let i of r)
      e.print(i), e.newline();
    t.hasUnknownMembers && (e.token("..."), e.newline()), e.dedent(), e.token("}");
  }
  s(R_, "enumBody");
  function RFe(e) {
    let {
      explicitType: t
    } = e;
    I_(this, "boolean", t), R_(this, e);
  }
  s(RFe, "EnumBooleanBody");
  function NFe(e) {
    let {
      explicitType: t
    } = e;
    I_(this, "number", t), R_(this, e);
  }
  s(NFe, "EnumNumberBody");
  function LFe(e) {
    let {
      explicitType: t
    } = e;
    I_(this, "string", t), R_(this, e);
  }
  s(LFe, "EnumStringBody");
  function FFe(e) {
    I_(this, "symbol", !0), R_(this, e);
  }
  s(FFe, "EnumSymbolBody");
  function MFe(e) {
    let {
      id: t
    } = e;
    this.print(t), this.tokenChar(44);
  }
  s(MFe, "EnumDefaultedMember");
  function VC(e, t) {
    e.print(t.id), e.space(), e.token("="), e.space(), e.print(t.init), e.token(",");
  }
  s(VC, "enumInitializedMember");
  function BFe(e) {
    VC(this, e);
  }
  s(BFe, "EnumBooleanMember");
  function qFe(e) {
    VC(this, e);
  }
  s(qFe, "EnumNumberMember");
  function UFe(e) {
    VC(this, e);
  }
  s(UFe, "EnumStringMember");
  function jFe(e) {
    if (e.declaration) {
      let t = e.declaration;
      this.print(t), dFe(t) || this.semicolon();
    } else
      this.tokenChar(123), e.specifiers.length && (this.space(), this.printList(e.specifiers), this.space()), this.tokenChar(125), e.source &&
      (this.space(), this.word("from"), this.space(), this.print(e.source)), this.semicolon();
  }
  s(jFe, "FlowExportDeclaration");
  function VFe() {
    this.tokenChar(42);
  }
  s(VFe, "ExistsTypeAnnotation");
  function KFe(e, t) {
    this.print(e.typeParameters), this.tokenChar(40), e.this && (this.word("this"), this.tokenChar(58), this.space(), this.print(e.this.typeAnnotation),
    (e.params.length || e.rest) && (this.tokenChar(44), this.space())), this.printList(e.params), e.rest && (e.params.length && (this.tokenChar(
    44), this.space()), this.token("..."), this.print(e.rest)), this.tokenChar(41);
    let r = t?.type;
    r != null && (r === "ObjectTypeCallProperty" || r === "ObjectTypeInternalSlot" || r === "DeclareFunction" || r === "ObjectTypeProperty" &&
    t.method) ? this.tokenChar(58) : (this.space(), this.token("=>")), this.space(), this.print(e.returnType);
  }
  s(KFe, "FunctionTypeAnnotation");
  function HFe(e) {
    this.print(e.name), e.optional && this.tokenChar(63), e.name && (this.tokenChar(58), this.space()), this.print(e.typeAnnotation);
  }
  s(HFe, "FunctionTypeParam");
  function zFe(e) {
    this.print(e.id), this.print(e.typeParameters, !0);
  }
  s(zFe, "InterfaceExtends");
  function GFe(e) {
    var t;
    if (this.print(e.id), this.print(e.typeParameters), (t = e.extends) != null && t.length && (this.space(), this.word("extends"), this.space(),
    this.printList(e.extends)), e.type === "DeclareClass") {
      var r, i;
      (r = e.mixins) != null && r.length && (this.space(), this.word("mixins"), this.space(), this.printList(e.mixins)), (i = e.implements) !=
      null && i.length && (this.space(), this.word("implements"), this.space(), this.printList(e.implements));
    }
    this.space(), this.print(e.body);
  }
  s(GFe, "_interfaceish");
  function WFe(e) {
    var t;
    let r = (t = e.variance) == null ? void 0 : t.kind;
    r != null && (r === "plus" ? this.tokenChar(43) : r === "minus" && this.tokenChar(45));
  }
  s(WFe, "_variance");
  function $Fe(e) {
    this.word("interface"), this.space(), this._interfaceish(e);
  }
  s($Fe, "InterfaceDeclaration");
  function XFe(e) {
    this.space(), this.token("&", !1, e), this.space();
  }
  s(XFe, "andSeparator");
  function YFe(e) {
    var t;
    this.word("interface"), (t = e.extends) != null && t.length && (this.space(), this.word("extends"), this.space(), this.printList(e.extends)),
    this.space(), this.print(e.body);
  }
  s(YFe, "InterfaceTypeAnnotation");
  function JFe(e) {
    this.printJoin(e.types, void 0, void 0, XFe);
  }
  s(JFe, "IntersectionTypeAnnotation");
  function QFe() {
    this.word("mixed");
  }
  s(QFe, "MixedTypeAnnotation");
  function ZFe() {
    this.word("empty");
  }
  s(ZFe, "EmptyTypeAnnotation");
  function eMe(e) {
    this.tokenChar(63), this.print(e.typeAnnotation);
  }
  s(eMe, "NullableTypeAnnotation");
  function tMe() {
    this.word("number");
  }
  s(tMe, "NumberTypeAnnotation");
  function rMe() {
    this.word("string");
  }
  s(rMe, "StringTypeAnnotation");
  function iMe() {
    this.word("this");
  }
  s(iMe, "ThisTypeAnnotation");
  function nMe(e) {
    this.tokenChar(91), this.printList(e.types), this.tokenChar(93);
  }
  s(nMe, "TupleTypeAnnotation");
  function sMe(e) {
    this.word("typeof"), this.space(), this.print(e.argument);
  }
  s(sMe, "TypeofTypeAnnotation");
  function aMe(e) {
    this.word("type"), this.space(), this.print(e.id), this.print(e.typeParameters), this.space(), this.tokenChar(61), this.space(), this.print(
    e.right), this.semicolon();
  }
  s(aMe, "TypeAlias");
  function oMe(e, t) {
    this.tokenChar(58), this.space(), t.type === "ArrowFunctionExpression" ? this.tokenContext |= hFe.TokenContext.arrowFlowReturnType : e.optional &&
    this.tokenChar(63), this.print(e.typeAnnotation);
  }
  s(oMe, "TypeAnnotation");
  function uMe(e) {
    this.tokenChar(60), this.printList(e.params), this.tokenChar(62);
  }
  s(uMe, "TypeParameterInstantiation");
  function lMe(e) {
    this._variance(e), this.word(e.name), e.bound && this.print(e.bound), e.default && (this.space(), this.tokenChar(61), this.space(), this.
    print(e.default));
  }
  s(lMe, "TypeParameter");
  function cMe(e) {
    this.word("opaque"), this.space(), this.word("type"), this.space(), this.print(e.id), this.print(e.typeParameters), e.supertype && (this.
    tokenChar(58), this.space(), this.print(e.supertype)), e.impltype && (this.space(), this.tokenChar(61), this.space(), this.print(e.impltype)),
    this.semicolon();
  }
  s(cMe, "OpaqueType");
  function fMe(e) {
    e.exact ? this.token("{|") : this.tokenChar(123);
    let t = [...e.properties, ...e.callProperties || [], ...e.indexers || [], ...e.internalSlots || []];
    t.length && (this.newline(), this.space(), this.printJoin(t, !0, !0, void 0, void 0, /* @__PURE__ */ s(function(i) {
      if (i && !t[0]) return 1;
    }, "addNewlines"), () => {
      (t.length !== 1 || e.inexact) && (this.tokenChar(44), this.space());
    }), this.space()), e.inexact && (this.indent(), this.token("..."), t.length && this.newline(), this.dedent()), e.exact ? this.token("|}") :
    this.tokenChar(125);
  }
  s(fMe, "ObjectTypeAnnotation");
  function pMe(e) {
    e.static && (this.word("static"), this.space()), this.tokenChar(91), this.tokenChar(91), this.print(e.id), this.tokenChar(93), this.tokenChar(
    93), e.optional && this.tokenChar(63), e.method || (this.tokenChar(58), this.space()), this.print(e.value);
  }
  s(pMe, "ObjectTypeInternalSlot");
  function hMe(e) {
    e.static && (this.word("static"), this.space()), this.print(e.value);
  }
  s(hMe, "ObjectTypeCallProperty");
  function dMe(e) {
    e.static && (this.word("static"), this.space()), this._variance(e), this.tokenChar(91), e.id && (this.print(e.id), this.tokenChar(58), this.
    space()), this.print(e.key), this.tokenChar(93), this.tokenChar(58), this.space(), this.print(e.value);
  }
  s(dMe, "ObjectTypeIndexer");
  function mMe(e) {
    e.proto && (this.word("proto"), this.space()), e.static && (this.word("static"), this.space()), (e.kind === "get" || e.kind === "set") &&
    (this.word(e.kind), this.space()), this._variance(e), this.print(e.key), e.optional && this.tokenChar(63), e.method || (this.tokenChar(58),
    this.space()), this.print(e.value);
  }
  s(mMe, "ObjectTypeProperty");
  function yMe(e) {
    this.token("..."), this.print(e.argument);
  }
  s(yMe, "ObjectTypeSpreadProperty");
  function gMe(e) {
    this.print(e.qualification), this.tokenChar(46), this.print(e.id);
  }
  s(gMe, "QualifiedTypeIdentifier");
  function _Me() {
    this.word("symbol");
  }
  s(_Me, "SymbolTypeAnnotation");
  function bMe(e) {
    this.space(), this.token("|", !1, e), this.space();
  }
  s(bMe, "orSeparator");
  function vMe(e) {
    this.printJoin(e.types, void 0, void 0, bMe);
  }
  s(vMe, "UnionTypeAnnotation");
  function SMe(e) {
    this.tokenChar(40), this.print(e.expression), this.print(e.typeAnnotation), this.tokenChar(41);
  }
  s(SMe, "TypeCastExpression");
  function TMe(e) {
    e.kind === "plus" ? this.tokenChar(43) : this.tokenChar(45);
  }
  s(TMe, "Variance");
  function EMe() {
    this.word("void");
  }
  s(EMe, "VoidTypeAnnotation");
  function AMe(e) {
    this.print(e.objectType, !0), this.tokenChar(91), this.print(e.indexType), this.tokenChar(93);
  }
  s(AMe, "IndexedAccessType");
  function xMe(e) {
    this.print(e.objectType), e.optional && this.token("?."), this.tokenChar(91), this.print(e.indexType), this.tokenChar(93);
  }
  s(xMe, "OptionalIndexedAccessType");
});

// ../node_modules/@babel/generator/lib/generators/base.js
var Z5 = b((bu) => {
  "use strict";
  Object.defineProperty(bu, "__esModule", {
    value: !0
  });
  bu.BlockStatement = DMe;
  bu.Directive = wMe;
  bu.DirectiveLiteral = IMe;
  bu.File = CMe;
  bu.InterpreterDirective = RMe;
  bu.Placeholder = NMe;
  bu.Program = PMe;
  function CMe(e) {
    e.program && this.print(e.program.interpreter), this.print(e.program);
  }
  s(CMe, "File");
  function PMe(e) {
    var t;
    this.noIndentInnerCommentsHere(), this.printInnerComments();
    let r = (t = e.directives) == null ? void 0 : t.length;
    if (r) {
      var i;
      let n = e.body.length ? 2 : 1;
      this.printSequence(e.directives, void 0, n), (i = e.directives[r - 1].trailingComments) != null && i.length || this.newline(n);
    }
    this.printSequence(e.body);
  }
  s(PMe, "Program");
  function DMe(e) {
    var t;
    this.tokenChar(123);
    let r = this.enterDelimited(), i = (t = e.directives) == null ? void 0 : t.length;
    if (i) {
      var n;
      let a = e.body.length ? 2 : 1;
      this.printSequence(e.directives, !0, a), (n = e.directives[i - 1].trailingComments) != null && n.length || this.newline(a);
    }
    this.printSequence(e.body, !0), r(), this.rightBrace(e);
  }
  s(DMe, "BlockStatement");
  function wMe(e) {
    this.print(e.value), this.semicolon();
  }
  s(wMe, "Directive");
  var OMe = /(?:^|[^\\])(?:\\\\)*'/, kMe = /(?:^|[^\\])(?:\\\\)*"/;
  function IMe(e) {
    let t = this.getPossibleRaw(e);
    if (!this.format.minified && t !== void 0) {
      this.token(t);
      return;
    }
    let {
      value: r
    } = e;
    if (!kMe.test(r))
      this.token(`"${r}"`);
    else if (!OMe.test(r))
      this.token(`'${r}'`);
    else
      throw new Error("Malformed AST: it is not possible to print a directive containing both unescaped single and double quotes.");
  }
  s(IMe, "DirectiveLiteral");
  function RMe(e) {
    this.token(`#!${e.value}`), this.newline(1, !0);
  }
  s(RMe, "InterpreterDirective");
  function NMe(e) {
    this.token("%%"), this.print(e.name), this.token("%%"), e.expectedNode === "Statement" && this.semicolon();
  }
  s(NMe, "Placeholder");
});

// ../node_modules/@babel/generator/lib/generators/jsx.js
var e9 = b((Nn) => {
  "use strict";
  Object.defineProperty(Nn, "__esModule", {
    value: !0
  });
  Nn.JSXAttribute = LMe;
  Nn.JSXClosingElement = GMe;
  Nn.JSXClosingFragment = YMe;
  Nn.JSXElement = KMe;
  Nn.JSXEmptyExpression = WMe;
  Nn.JSXExpressionContainer = UMe;
  Nn.JSXFragment = $Me;
  Nn.JSXIdentifier = FMe;
  Nn.JSXMemberExpression = BMe;
  Nn.JSXNamespacedName = MMe;
  Nn.JSXOpeningElement = zMe;
  Nn.JSXOpeningFragment = XMe;
  Nn.JSXSpreadAttribute = qMe;
  Nn.JSXSpreadChild = jMe;
  Nn.JSXText = VMe;
  function LMe(e) {
    this.print(e.name), e.value && (this.tokenChar(61), this.print(e.value));
  }
  s(LMe, "JSXAttribute");
  function FMe(e) {
    this.word(e.name);
  }
  s(FMe, "JSXIdentifier");
  function MMe(e) {
    this.print(e.namespace), this.tokenChar(58), this.print(e.name);
  }
  s(MMe, "JSXNamespacedName");
  function BMe(e) {
    this.print(e.object), this.tokenChar(46), this.print(e.property);
  }
  s(BMe, "JSXMemberExpression");
  function qMe(e) {
    this.tokenChar(123), this.token("..."), this.print(e.argument), this.rightBrace(e);
  }
  s(qMe, "JSXSpreadAttribute");
  function UMe(e) {
    this.tokenChar(123), this.print(e.expression), this.rightBrace(e);
  }
  s(UMe, "JSXExpressionContainer");
  function jMe(e) {
    this.tokenChar(123), this.token("..."), this.print(e.expression), this.rightBrace(e);
  }
  s(jMe, "JSXSpreadChild");
  function VMe(e) {
    let t = this.getPossibleRaw(e);
    t !== void 0 ? this.token(t, !0) : this.token(e.value, !0);
  }
  s(VMe, "JSXText");
  function KMe(e) {
    let t = e.openingElement;
    if (this.print(t), !t.selfClosing) {
      this.indent();
      for (let r of e.children)
        this.print(r);
      this.dedent(), this.print(e.closingElement);
    }
  }
  s(KMe, "JSXElement");
  function HMe() {
    this.space();
  }
  s(HMe, "spaceSeparator");
  function zMe(e) {
    this.tokenChar(60), this.print(e.name), e.typeArguments && this.print(e.typeArguments), this.print(e.typeParameters), e.attributes.length >
    0 && (this.space(), this.printJoin(e.attributes, void 0, void 0, HMe)), e.selfClosing && (this.space(), this.tokenChar(47)), this.tokenChar(
    62);
  }
  s(zMe, "JSXOpeningElement");
  function GMe(e) {
    this.tokenChar(60), this.tokenChar(47), this.print(e.name), this.tokenChar(62);
  }
  s(GMe, "JSXClosingElement");
  function WMe() {
    this.printInnerComments();
  }
  s(WMe, "JSXEmptyExpression");
  function $Me(e) {
    this.print(e.openingFragment), this.indent();
    for (let t of e.children)
      this.print(t);
    this.dedent(), this.print(e.closingFragment);
  }
  s($Me, "JSXFragment");
  function XMe() {
    this.tokenChar(60), this.tokenChar(62);
  }
  s(XMe, "JSXOpeningFragment");
  function YMe() {
    this.token("</"), this.tokenChar(62);
  }
  s(YMe, "JSXClosingFragment");
});

// ../node_modules/@babel/generator/lib/generators/typescript.js
var s9 = b((Be) => {
  "use strict";
  Object.defineProperty(Be, "__esModule", {
    value: !0
  });
  Be.TSAnyKeyword = cBe;
  Be.TSArrayType = kBe;
  Be.TSSatisfiesExpression = Be.TSAsExpression = YBe;
  Be.TSBigIntKeyword = fBe;
  Be.TSBooleanKeyword = mBe;
  Be.TSCallSignatureDeclaration = nBe;
  Be.TSInterfaceHeritage = Be.TSClassImplements = GBe;
  Be.TSConditionalType = BBe;
  Be.TSConstructSignatureDeclaration = sBe;
  Be.TSConstructorType = xBe;
  Be.TSDeclareFunction = tBe;
  Be.TSDeclareMethod = rBe;
  Be.TSEnumBody = n9;
  Be.TSEnumDeclaration = ZBe;
  Be.TSEnumMember = e3e;
  Be.TSExportAssignment = o3e;
  Be.TSExternalModuleReference = s3e;
  Be.TSFunctionType = ABe;
  Be.TSImportEqualsDeclaration = n3e;
  Be.TSImportType = i3e;
  Be.TSIndexSignature = lBe;
  Be.TSIndexedAccessType = VBe;
  Be.TSInferType = qBe;
  Be.TSInstantiationExpression = QBe;
  Be.TSInterfaceBody = $Be;
  Be.TSInterfaceDeclaration = WBe;
  Be.TSIntersectionType = MBe;
  Be.TSIntrinsicKeyword = TBe;
  Be.TSLiteralType = zBe;
  Be.TSMappedType = KBe;
  Be.TSMethodSignature = uBe;
  Be.TSModuleBlock = r3e;
  Be.TSModuleDeclaration = t3e;
  Be.TSNamedTupleMember = LBe;
  Be.TSNamespaceExportDeclaration = u3e;
  Be.TSNeverKeyword = SBe;
  Be.TSNonNullExpression = a3e;
  Be.TSNullKeyword = vBe;
  Be.TSNumberKeyword = hBe;
  Be.TSObjectKeyword = dBe;
  Be.TSOptionalType = RBe;
  Be.TSParameterProperty = eBe;
  Be.TSParenthesizedType = UBe;
  Be.TSPropertySignature = aBe;
  Be.TSQualifiedName = iBe;
  Be.TSRestType = NBe;
  Be.TSStringKeyword = yBe;
  Be.TSSymbolKeyword = gBe;
  Be.TSTemplateLiteralType = HBe;
  Be.TSThisType = EBe;
  Be.TSTupleType = IBe;
  Be.TSTypeAliasDeclaration = XBe;
  Be.TSTypeAnnotation = JMe;
  Be.TSTypeAssertion = JBe;
  Be.TSTypeLiteral = OBe;
  Be.TSTypeOperator = jBe;
  Be.TSTypeParameter = ZMe;
  Be.TSTypeParameterDeclaration = Be.TSTypeParameterInstantiation = QMe;
  Be.TSTypePredicate = DBe;
  Be.TSTypeQuery = wBe;
  Be.TSTypeReference = PBe;
  Be.TSUndefinedKeyword = bBe;
  Be.TSUnionType = FBe;
  Be.TSUnknownKeyword = pBe;
  Be.TSVoidKeyword = _Be;
  Be.tsPrintClassMemberModifiers = c3e;
  Be.tsPrintFunctionOrConstructorType = CBe;
  Be.tsPrintPropertyOrMethodName = oBe;
  Be.tsPrintSignatureDeclarationBase = l3e;
  function JMe(e, t) {
    this.token((t.type === "TSFunctionType" || t.type === "TSConstructorType") && t.typeAnnotation === e ? "=>" : ":"), this.space(), e.optional &&
    this.tokenChar(63), this.print(e.typeAnnotation);
  }
  s(JMe, "TSTypeAnnotation");
  function QMe(e, t) {
    this.tokenChar(60);
    let r = t.type === "ArrowFunctionExpression" && e.params.length === 1;
    this.tokenMap && e.start != null && e.end != null && (r && (r = !!this.tokenMap.find(e, (i) => this.tokenMap.matchesOriginal(i, ","))), r ||
    (r = this.shouldPrintTrailingComma(">"))), this.printList(e.params, r), this.tokenChar(62);
  }
  s(QMe, "TSTypeParameterInstantiation");
  function ZMe(e) {
    e.in && (this.word("in"), this.space()), e.out && (this.word("out"), this.space()), this.word(e.name), e.constraint && (this.space(), this.
    word("extends"), this.space(), this.print(e.constraint)), e.default && (this.space(), this.tokenChar(61), this.space(), this.print(e.default));
  }
  s(ZMe, "TSTypeParameter");
  function eBe(e) {
    e.accessibility && (this.word(e.accessibility), this.space()), e.readonly && (this.word("readonly"), this.space()), this._param(e.parameter);
  }
  s(eBe, "TSParameterProperty");
  function tBe(e, t) {
    e.declare && (this.word("declare"), this.space()), this._functionHead(e, t), this.semicolon();
  }
  s(tBe, "TSDeclareFunction");
  function rBe(e) {
    this._classMethodHead(e), this.semicolon();
  }
  s(rBe, "TSDeclareMethod");
  function iBe(e) {
    this.print(e.left), this.tokenChar(46), this.print(e.right);
  }
  s(iBe, "TSQualifiedName");
  function nBe(e) {
    this.tsPrintSignatureDeclarationBase(e), _d(this, e);
  }
  s(nBe, "TSCallSignatureDeclaration");
  function _d(e, t) {
    if (!e.tokenMap || !t.start || !t.end) {
      e.semicolon();
      return;
    }
    e.tokenMap.endMatches(t, ",") ? e.token(",") : e.tokenMap.endMatches(t, ";") && e.semicolon();
  }
  s(_d, "maybePrintTrailingCommaOrSemicolon");
  function sBe(e) {
    this.word("new"), this.space(), this.tsPrintSignatureDeclarationBase(e), _d(this, e);
  }
  s(sBe, "TSConstructSignatureDeclaration");
  function aBe(e) {
    let {
      readonly: t
    } = e;
    t && (this.word("readonly"), this.space()), this.tsPrintPropertyOrMethodName(e), this.print(e.typeAnnotation), _d(this, e);
  }
  s(aBe, "TSPropertySignature");
  function oBe(e) {
    e.computed && this.tokenChar(91), this.print(e.key), e.computed && this.tokenChar(93), e.optional && this.tokenChar(63);
  }
  s(oBe, "tsPrintPropertyOrMethodName");
  function uBe(e) {
    let {
      kind: t
    } = e;
    (t === "set" || t === "get") && (this.word(t), this.space()), this.tsPrintPropertyOrMethodName(e), this.tsPrintSignatureDeclarationBase(
    e), _d(this, e);
  }
  s(uBe, "TSMethodSignature");
  function lBe(e) {
    let {
      readonly: t,
      static: r
    } = e;
    r && (this.word("static"), this.space()), t && (this.word("readonly"), this.space()), this.tokenChar(91), this._parameters(e.parameters,
    "]"), this.print(e.typeAnnotation), _d(this, e);
  }
  s(lBe, "TSIndexSignature");
  function cBe() {
    this.word("any");
  }
  s(cBe, "TSAnyKeyword");
  function fBe() {
    this.word("bigint");
  }
  s(fBe, "TSBigIntKeyword");
  function pBe() {
    this.word("unknown");
  }
  s(pBe, "TSUnknownKeyword");
  function hBe() {
    this.word("number");
  }
  s(hBe, "TSNumberKeyword");
  function dBe() {
    this.word("object");
  }
  s(dBe, "TSObjectKeyword");
  function mBe() {
    this.word("boolean");
  }
  s(mBe, "TSBooleanKeyword");
  function yBe() {
    this.word("string");
  }
  s(yBe, "TSStringKeyword");
  function gBe() {
    this.word("symbol");
  }
  s(gBe, "TSSymbolKeyword");
  function _Be() {
    this.word("void");
  }
  s(_Be, "TSVoidKeyword");
  function bBe() {
    this.word("undefined");
  }
  s(bBe, "TSUndefinedKeyword");
  function vBe() {
    this.word("null");
  }
  s(vBe, "TSNullKeyword");
  function SBe() {
    this.word("never");
  }
  s(SBe, "TSNeverKeyword");
  function TBe() {
    this.word("intrinsic");
  }
  s(TBe, "TSIntrinsicKeyword");
  function EBe() {
    this.word("this");
  }
  s(EBe, "TSThisType");
  function ABe(e) {
    this.tsPrintFunctionOrConstructorType(e);
  }
  s(ABe, "TSFunctionType");
  function xBe(e) {
    e.abstract && (this.word("abstract"), this.space()), this.word("new"), this.space(), this.tsPrintFunctionOrConstructorType(e);
  }
  s(xBe, "TSConstructorType");
  function CBe(e) {
    let {
      typeParameters: t
    } = e, r = e.parameters;
    this.print(t), this.tokenChar(40), this._parameters(r, ")"), this.space();
    let i = e.typeAnnotation;
    this.print(i);
  }
  s(CBe, "tsPrintFunctionOrConstructorType");
  function PBe(e) {
    let t = e.typeParameters;
    this.print(e.typeName, !!t), this.print(t);
  }
  s(PBe, "TSTypeReference");
  function DBe(e) {
    e.asserts && (this.word("asserts"), this.space()), this.print(e.parameterName), e.typeAnnotation && (this.space(), this.word("is"), this.
    space(), this.print(e.typeAnnotation.typeAnnotation));
  }
  s(DBe, "TSTypePredicate");
  function wBe(e) {
    this.word("typeof"), this.space(), this.print(e.exprName);
    let t = e.typeParameters;
    t && this.print(t);
  }
  s(wBe, "TSTypeQuery");
  function OBe(e) {
    N_(this, e, () => this.printJoin(e.members, !0, !0));
  }
  s(OBe, "TSTypeLiteral");
  function kBe(e) {
    this.print(e.elementType, !0), this.tokenChar(91), this.tokenChar(93);
  }
  s(kBe, "TSArrayType");
  function IBe(e) {
    this.tokenChar(91), this.printList(e.elementTypes, this.shouldPrintTrailingComma("]")), this.tokenChar(93);
  }
  s(IBe, "TSTupleType");
  function RBe(e) {
    this.print(e.typeAnnotation), this.tokenChar(63);
  }
  s(RBe, "TSOptionalType");
  function NBe(e) {
    this.token("..."), this.print(e.typeAnnotation);
  }
  s(NBe, "TSRestType");
  function LBe(e) {
    this.print(e.label), e.optional && this.tokenChar(63), this.tokenChar(58), this.space(), this.print(e.elementType);
  }
  s(LBe, "TSNamedTupleMember");
  function FBe(e) {
    i9(this, e, "|");
  }
  s(FBe, "TSUnionType");
  function MBe(e) {
    i9(this, e, "&");
  }
  s(MBe, "TSIntersectionType");
  function i9(e, t, r) {
    var i;
    let n = 0;
    (i = e.tokenMap) != null && i.startMatches(t, r) && (n = 1, e.token(r)), e.printJoin(t.types, void 0, void 0, function(a) {
      this.space(), this.token(r, null, a + n), this.space();
    });
  }
  s(i9, "tsPrintUnionOrIntersectionType");
  function BBe(e) {
    this.print(e.checkType), this.space(), this.word("extends"), this.space(), this.print(e.extendsType), this.space(), this.tokenChar(63), this.
    space(), this.print(e.trueType), this.space(), this.tokenChar(58), this.space(), this.print(e.falseType);
  }
  s(BBe, "TSConditionalType");
  function qBe(e) {
    this.word("infer"), this.print(e.typeParameter);
  }
  s(qBe, "TSInferType");
  function UBe(e) {
    this.tokenChar(40), this.print(e.typeAnnotation), this.tokenChar(41);
  }
  s(UBe, "TSParenthesizedType");
  function jBe(e) {
    this.word(e.operator), this.space(), this.print(e.typeAnnotation);
  }
  s(jBe, "TSTypeOperator");
  function VBe(e) {
    this.print(e.objectType, !0), this.tokenChar(91), this.print(e.indexType), this.tokenChar(93);
  }
  s(VBe, "TSIndexedAccessType");
  function KBe(e) {
    let {
      nameType: t,
      optional: r,
      readonly: i,
      typeAnnotation: n
    } = e;
    this.tokenChar(123);
    let a = this.enterDelimited();
    this.space(), i && (t9(this, i), this.word("readonly"), this.space()), this.tokenChar(91), this.word(e.typeParameter.name), this.space(),
    this.word("in"), this.space(), this.print(e.typeParameter.constraint), t && (this.space(), this.word("as"), this.space(), this.print(t)),
    this.tokenChar(93), r && (t9(this, r), this.tokenChar(63)), n && (this.tokenChar(58), this.space(), this.print(n)), this.space(), a(), this.
    tokenChar(125);
  }
  s(KBe, "TSMappedType");
  function t9(e, t) {
    t !== !0 && e.token(t);
  }
  s(t9, "tokenIfPlusMinus");
  function HBe(e) {
    this._printTemplate(e, e.types);
  }
  s(HBe, "TSTemplateLiteralType");
  function zBe(e) {
    this.print(e.literal);
  }
  s(zBe, "TSLiteralType");
  function GBe(e) {
    this.print(e.expression), this.print(e.typeArguments);
  }
  s(GBe, "TSClassImplements");
  function WBe(e) {
    let {
      declare: t,
      id: r,
      typeParameters: i,
      extends: n,
      body: a
    } = e;
    t && (this.word("declare"), this.space()), this.word("interface"), this.space(), this.print(r), this.print(i), n != null && n.length && (this.
    space(), this.word("extends"), this.space(), this.printList(n)), this.space(), this.print(a);
  }
  s(WBe, "TSInterfaceDeclaration");
  function $Be(e) {
    N_(this, e, () => this.printJoin(e.body, !0, !0));
  }
  s($Be, "TSInterfaceBody");
  function XBe(e) {
    let {
      declare: t,
      id: r,
      typeParameters: i,
      typeAnnotation: n
    } = e;
    t && (this.word("declare"), this.space()), this.word("type"), this.space(), this.print(r), this.print(i), this.space(), this.tokenChar(61),
    this.space(), this.print(n), this.semicolon();
  }
  s(XBe, "TSTypeAliasDeclaration");
  function YBe(e) {
    let {
      type: t,
      expression: r,
      typeAnnotation: i
    } = e;
    this.print(r, !0), this.space(), this.word(t === "TSAsExpression" ? "as" : "satisfies"), this.space(), this.print(i);
  }
  s(YBe, "TSTypeExpression");
  function JBe(e) {
    let {
      typeAnnotation: t,
      expression: r
    } = e;
    this.tokenChar(60), this.print(t), this.tokenChar(62), this.space(), this.print(r);
  }
  s(JBe, "TSTypeAssertion");
  function QBe(e) {
    this.print(e.expression), this.print(e.typeParameters);
  }
  s(QBe, "TSInstantiationExpression");
  function ZBe(e) {
    let {
      declare: t,
      const: r,
      id: i
    } = e;
    t && (this.word("declare"), this.space()), r && (this.word("const"), this.space()), this.word("enum"), this.space(), this.print(i), this.
    space(), n9.call(this, e);
  }
  s(ZBe, "TSEnumDeclaration");
  function n9(e) {
    N_(this, e, () => {
      var t;
      return this.printList(e.members, (t = this.shouldPrintTrailingComma("}")) != null ? t : !0, !0, !0);
    });
  }
  s(n9, "TSEnumBody");
  function e3e(e) {
    let {
      id: t,
      initializer: r
    } = e;
    this.print(t), r && (this.space(), this.tokenChar(61), this.space(), this.print(r));
  }
  s(e3e, "TSEnumMember");
  function t3e(e) {
    let {
      declare: t,
      id: r,
      kind: i
    } = e;
    t && (this.word("declare"), this.space());
    {
      if (e.global || (this.word(i ?? (r.type === "Identifier" ? "namespace" : "module")), this.space()), this.print(r), !e.body) {
        this.semicolon();
        return;
      }
      let n = e.body;
      for (; n.type === "TSModuleDeclaration"; )
        this.tokenChar(46), this.print(n.id), n = n.body;
      this.space(), this.print(n);
    }
  }
  s(t3e, "TSModuleDeclaration");
  function r3e(e) {
    N_(this, e, () => this.printSequence(e.body, !0));
  }
  s(r3e, "TSModuleBlock");
  function i3e(e) {
    let {
      argument: t,
      qualifier: r,
      options: i
    } = e;
    this.word("import"), this.tokenChar(40), this.print(t), i && (this.tokenChar(44), this.print(i)), this.tokenChar(41), r && (this.tokenChar(
    46), this.print(r));
    let n = e.typeParameters;
    n && this.print(n);
  }
  s(i3e, "TSImportType");
  function n3e(e) {
    let {
      id: t,
      moduleReference: r
    } = e;
    e.isExport && (this.word("export"), this.space()), this.word("import"), this.space(), this.print(t), this.space(), this.tokenChar(61), this.
    space(), this.print(r), this.semicolon();
  }
  s(n3e, "TSImportEqualsDeclaration");
  function s3e(e) {
    this.token("require("), this.print(e.expression), this.tokenChar(41);
  }
  s(s3e, "TSExternalModuleReference");
  function a3e(e) {
    this.print(e.expression), this.tokenChar(33);
  }
  s(a3e, "TSNonNullExpression");
  function o3e(e) {
    this.word("export"), this.space(), this.tokenChar(61), this.space(), this.print(e.expression), this.semicolon();
  }
  s(o3e, "TSExportAssignment");
  function u3e(e) {
    this.word("export"), this.space(), this.word("as"), this.space(), this.word("namespace"), this.space(), this.print(e.id), this.semicolon();
  }
  s(u3e, "TSNamespaceExportDeclaration");
  function l3e(e) {
    let {
      typeParameters: t
    } = e, r = e.parameters;
    this.print(t), this.tokenChar(40), this._parameters(r, ")");
    let i = e.typeAnnotation;
    this.print(i);
  }
  s(l3e, "tsPrintSignatureDeclarationBase");
  function c3e(e) {
    let t = e.type === "ClassPrivateProperty", r = e.type === "ClassAccessorProperty" || e.type === "ClassProperty";
    r9(this, e, [r && e.declare && "declare", !t && e.accessibility]), e.static && (this.word("static"), this.space()), r9(this, e, [!t && e.
    abstract && "abstract", !t && e.override && "override", (r || t) && e.readonly && "readonly"]);
  }
  s(c3e, "tsPrintClassMemberModifiers");
  function N_(e, t, r) {
    e.token("{");
    let i = e.enterDelimited();
    r(), i(), e.rightBrace(t);
  }
  s(N_, "printBraced");
  function r9(e, t, r) {
    var i;
    let n = /* @__PURE__ */ new Set();
    for (let a of r)
      a && n.add(a);
    (i = e.tokenMap) == null || i.find(t, (a) => {
      if (n.has(a.value))
        return e.token(a.value), e.space(), n.delete(a.value), n.size === 0;
    });
    for (let a of n)
      e.word(a), e.space();
  }
  s(r9, "printModifiersList");
});

// ../node_modules/@babel/generator/lib/generators/index.js
var a9 = b((ur) => {
  "use strict";
  Object.defineProperty(ur, "__esModule", {
    value: !0
  });
  var KC = I5();
  Object.keys(KC).forEach(function(e) {
    e === "default" || e === "__esModule" || e in ur && ur[e] === KC[e] || Object.defineProperty(ur, e, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return KC[e];
      }, "get")
    });
  });
  var HC = N5();
  Object.keys(HC).forEach(function(e) {
    e === "default" || e === "__esModule" || e in ur && ur[e] === HC[e] || Object.defineProperty(ur, e, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return HC[e];
      }, "get")
    });
  });
  var zC = B5();
  Object.keys(zC).forEach(function(e) {
    e === "default" || e === "__esModule" || e in ur && ur[e] === zC[e] || Object.defineProperty(ur, e, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return zC[e];
      }, "get")
    });
  });
  var GC = q5();
  Object.keys(GC).forEach(function(e) {
    e === "default" || e === "__esModule" || e in ur && ur[e] === GC[e] || Object.defineProperty(ur, e, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return GC[e];
      }, "get")
    });
  });
  var WC = U5();
  Object.keys(WC).forEach(function(e) {
    e === "default" || e === "__esModule" || e in ur && ur[e] === WC[e] || Object.defineProperty(ur, e, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return WC[e];
      }, "get")
    });
  });
  var $C = BC();
  Object.keys($C).forEach(function(e) {
    e === "default" || e === "__esModule" || e in ur && ur[e] === $C[e] || Object.defineProperty(ur, e, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return $C[e];
      }, "get")
    });
  });
  var XC = jC();
  Object.keys(XC).forEach(function(e) {
    e === "default" || e === "__esModule" || e in ur && ur[e] === XC[e] || Object.defineProperty(ur, e, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return XC[e];
      }, "get")
    });
  });
  var YC = Q5();
  Object.keys(YC).forEach(function(e) {
    e === "default" || e === "__esModule" || e in ur && ur[e] === YC[e] || Object.defineProperty(ur, e, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return YC[e];
      }, "get")
    });
  });
  var JC = Z5();
  Object.keys(JC).forEach(function(e) {
    e === "default" || e === "__esModule" || e in ur && ur[e] === JC[e] || Object.defineProperty(ur, e, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return JC[e];
      }, "get")
    });
  });
  var QC = e9();
  Object.keys(QC).forEach(function(e) {
    e === "default" || e === "__esModule" || e in ur && ur[e] === QC[e] || Object.defineProperty(ur, e, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return QC[e];
      }, "get")
    });
  });
  var ZC = s9();
  Object.keys(ZC).forEach(function(e) {
    e === "default" || e === "__esModule" || e in ur && ur[e] === ZC[e] || Object.defineProperty(ur, e, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return ZC[e];
      }, "get")
    });
  });
});

// ../node_modules/@babel/generator/lib/generators/deprecated.js
var o9 = b((eP) => {
  "use strict";
  Object.defineProperty(eP, "__esModule", {
    value: !0
  });
  eP.addDeprecatedGenerators = f3e;
  function f3e(e) {
    {
      let t = {
        Noop() {
        },
        TSExpressionWithTypeArguments(r) {
          this.print(r.expression), this.print(r.typeParameters);
        },
        DecimalLiteral(r) {
          let i = this.getPossibleRaw(r);
          if (!this.format.minified && i !== void 0) {
            this.word(i);
            return;
          }
          this.word(r.value + "m");
        }
      };
      Object.assign(e.prototype, t);
    }
  }
  s(f3e, "addDeprecatedGenerators");
});

// ../node_modules/@babel/generator/lib/printer.js
var f9 = b((L_) => {
  "use strict";
  Object.defineProperty(L_, "__esModule", {
    value: !0
  });
  L_.default = void 0;
  var p3e = h8(), l9 = fl(), h3e = Xn(), d3e = k5(), m3e = a9(), y3e = o9(), {
    isExpression: g3e,
    isFunction: _3e,
    isStatement: b3e,
    isClassBody: v3e,
    isTSInterfaceBody: S3e,
    isTSEnumMember: T3e
  } = h3e, E3e = /e/i, A3e = /\.0+$/, c9 = /[\n\r\u2028\u2029]/, x3e = /[\n\r\u2028\u2029]|\*\//;
  function u9(e) {
    return e.type === "CommentLine" || c9.test(e.value);
  }
  s(u9, "commentIsNewline");
  var {
    needsParens: C3e
  } = l9, bd = class {
    static {
      s(this, "Printer");
    }
    constructor(t, r, i, n) {
      this.inForStatementInit = !1, this.tokenContext = 0, this._tokens = null, this._originalCode = null, this._currentNode = null, this._indent =
      0, this._indentRepeat = 0, this._insideAux = !1, this._noLineTerminator = !1, this._noLineTerminatorAfterNode = null, this._printAuxAfterOnNextUserNode =
      !1, this._printedComments = /* @__PURE__ */ new Set(), this._endsWithInteger = !1, this._endsWithWord = !1, this._endsWithDiv = !1, this.
      _lastCommentLine = 0, this._endsWithInnerRaw = !1, this._indentInnerComments = !0, this.tokenMap = null, this._boundGetRawIdentifier =
      this._getRawIdentifier.bind(this), this._printSemicolonBeforeNextNode = -1, this._printSemicolonBeforeNextToken = -1, this.format = t,
      this._tokens = i, this._originalCode = n, this._indentRepeat = t.indent.style.length, this._inputMap = r?._inputMap, this._buf = new p3e.
      default(r, t.indent.style[0]);
    }
    enterForStatementInit() {
      return this.inForStatementInit ? () => {
      } : (this.inForStatementInit = !0, () => {
        this.inForStatementInit = !1;
      });
    }
    enterDelimited() {
      let t = this.inForStatementInit, r = this._noLineTerminatorAfterNode;
      return t === !1 && r === null ? () => {
      } : (this.inForStatementInit = !1, this._noLineTerminatorAfterNode = null, () => {
        this.inForStatementInit = t, this._noLineTerminatorAfterNode = r;
      });
    }
    generate(t) {
      return this.format.preserveFormat && (this.tokenMap = new d3e.TokenMap(t, this._tokens, this._originalCode)), this.print(t), this._maybeAddAuxComment(),
      this._buf.get();
    }
    indent() {
      let {
        format: t
      } = this;
      t.preserveFormat || t.compact || t.concise || this._indent++;
    }
    dedent() {
      let {
        format: t
      } = this;
      t.preserveFormat || t.compact || t.concise || this._indent--;
    }
    semicolon(t = !1) {
      if (this._maybeAddAuxComment(), t) {
        this._appendChar(59), this._noLineTerminator = !1;
        return;
      }
      if (this.tokenMap) {
        let r = this._currentNode;
        if (r.start != null && r.end != null) {
          if (!this.tokenMap.endMatches(r, ";")) {
            this._printSemicolonBeforeNextNode = this._buf.getCurrentLine();
            return;
          }
          let i = this.tokenMap.getIndexes(this._currentNode);
          this._catchUpTo(this._tokens[i[i.length - 1]].loc.start);
        }
      }
      this._queue(59), this._noLineTerminator = !1;
    }
    rightBrace(t) {
      this.format.minified && this._buf.removeLastSemicolon(), this.sourceWithOffset("end", t.loc, -1), this.tokenChar(125);
    }
    rightParens(t) {
      this.sourceWithOffset("end", t.loc, -1), this.tokenChar(41);
    }
    space(t = !1) {
      let {
        format: r
      } = this;
      if (!(r.compact || r.preserveFormat)) {
        if (t)
          this._space();
        else if (this._buf.hasContent()) {
          let i = this.getLastChar();
          i !== 32 && i !== 10 && this._space();
        }
      }
    }
    word(t, r = !1) {
      this.tokenContext = 0, this._maybePrintInnerComments(t), this._maybeAddAuxComment(), this.tokenMap && this._catchUpToCurrentToken(t), (this.
      _endsWithWord || this._endsWithDiv && t.charCodeAt(0) === 47) && this._space(), this._append(t, !1), this._endsWithWord = !0, this._noLineTerminator =
      r;
    }
    number(t, r) {
      function i(n) {
        if (n.length > 2 && n.charCodeAt(0) === 48) {
          let a = n.charCodeAt(1);
          return a === 98 || a === 111 || a === 120;
        }
        return !1;
      }
      s(i, "isNonDecimalLiteral"), this.word(t), this._endsWithInteger = Number.isInteger(r) && !i(t) && !E3e.test(t) && !A3e.test(t) && t.charCodeAt(
      t.length - 1) !== 46;
    }
    token(t, r = !1, i = 0) {
      this.tokenContext = 0, this._maybePrintInnerComments(t, i), this._maybeAddAuxComment(), this.tokenMap && this._catchUpToCurrentToken(t,
      i);
      let n = this.getLastChar(), a = t.charCodeAt(0);
      (n === 33 && (t === "--" || a === 61) || a === 43 && n === 43 || a === 45 && n === 45 || a === 46 && this._endsWithInteger) && this._space(),
      this._append(t, r), this._noLineTerminator = !1;
    }
    tokenChar(t) {
      this.tokenContext = 0;
      let r = String.fromCharCode(t);
      this._maybePrintInnerComments(r), this._maybeAddAuxComment(), this.tokenMap && this._catchUpToCurrentToken(r);
      let i = this.getLastChar();
      (t === 43 && i === 43 || t === 45 && i === 45 || t === 46 && this._endsWithInteger) && this._space(), this._appendChar(t), this._noLineTerminator =
      !1;
    }
    newline(t = 1, r) {
      if (!(t <= 0)) {
        if (!r) {
          if (this.format.retainLines || this.format.compact) return;
          if (this.format.concise) {
            this.space();
            return;
          }
        }
        t > 2 && (t = 2), t -= this._buf.getNewlineCount();
        for (let i = 0; i < t; i++)
          this._newline();
      }
    }
    endsWith(t) {
      return this.getLastChar() === t;
    }
    getLastChar() {
      return this._buf.getLastChar();
    }
    endsWithCharAndNewline() {
      return this._buf.endsWithCharAndNewline();
    }
    removeTrailingNewline() {
      this._buf.removeTrailingNewline();
    }
    exactSource(t, r) {
      if (!t) {
        r();
        return;
      }
      this._catchUp("start", t), this._buf.exactSource(t, r);
    }
    source(t, r) {
      r && (this._catchUp(t, r), this._buf.source(t, r));
    }
    sourceWithOffset(t, r, i) {
      !r || this.format.preserveFormat || (this._catchUp(t, r), this._buf.sourceWithOffset(t, r, i));
    }
    sourceIdentifierName(t, r) {
      if (!this._buf._canMarkIdName) return;
      let i = this._buf._sourcePosition;
      i.identifierNamePos = r, i.identifierName = t;
    }
    _space() {
      this._queue(32);
    }
    _newline() {
      this._queue(10);
    }
    _catchUpToCurrentToken(t, r = 0) {
      let i = this.tokenMap.findMatching(this._currentNode, t, r);
      i && this._catchUpTo(i.loc.start), this._printSemicolonBeforeNextToken !== -1 && this._printSemicolonBeforeNextToken === this._buf.getCurrentLine() &&
      (this._buf.appendChar(59), this._endsWithWord = !1, this._endsWithInteger = !1, this._endsWithDiv = !1), this._printSemicolonBeforeNextToken =
      -1, this._printSemicolonBeforeNextNode = -1;
    }
    _append(t, r) {
      this._maybeIndent(t.charCodeAt(0)), this._buf.append(t, r), this._endsWithWord = !1, this._endsWithInteger = !1, this._endsWithDiv = !1;
    }
    _appendChar(t) {
      this._maybeIndent(t), this._buf.appendChar(t), this._endsWithWord = !1, this._endsWithInteger = !1, this._endsWithDiv = !1;
    }
    _queue(t) {
      this._maybeIndent(t), this._buf.queue(t), this._endsWithWord = !1, this._endsWithInteger = !1;
    }
    _maybeIndent(t) {
      this._indent && t !== 10 && this.endsWith(10) && this._buf.queueIndentation(this._getIndent());
    }
    _shouldIndent(t) {
      if (this._indent && t !== 10 && this.endsWith(10))
        return !0;
    }
    catchUp(t) {
      if (!this.format.retainLines) return;
      let r = t - this._buf.getCurrentLine();
      for (let i = 0; i < r; i++)
        this._newline();
    }
    _catchUp(t, r) {
      let {
        format: i
      } = this;
      if (!i.preserveFormat) {
        i.retainLines && r != null && r[t] && this.catchUp(r[t].line);
        return;
      }
      let n = r?.[t];
      n != null && this._catchUpTo(n);
    }
    _catchUpTo({
      line: t,
      column: r,
      index: i
    }) {
      let n = t - this._buf.getCurrentLine();
      if (n > 0 && this._noLineTerminator)
        return;
      for (let o = 0; o < n; o++)
        this._newline();
      let a = n > 0 ? r : r - this._buf.getCurrentColumn();
      if (a > 0) {
        let o = this._originalCode ? this._originalCode.slice(i - a, i).replace(/[^\t\x0B\f \xA0\u1680\u2000-\u200A\u202F\u205F\u3000\uFEFF]/gu,
        " ") : " ".repeat(a);
        this._append(o, !1);
      }
    }
    _getIndent() {
      return this._indentRepeat * this._indent;
    }
    printTerminatorless(t) {
      this._noLineTerminator = !0, this.print(t);
    }
    print(t, r, i) {
      var n, a, o;
      if (!t) return;
      this._endsWithInnerRaw = !1;
      let u = t.type, l = this.format, c = l.concise;
      t._compact && (l.concise = !0);
      let p = this[u];
      if (p === void 0)
        throw new ReferenceError(`unknown node of type ${JSON.stringify(u)} with constructor ${JSON.stringify(t.constructor.name)}`);
      let h = this._currentNode;
      this._currentNode = t, this.tokenMap && (this._printSemicolonBeforeNextToken = this._printSemicolonBeforeNextNode);
      let y = this._insideAux;
      this._insideAux = t.loc == null, this._maybeAddAuxComment(this._insideAux && !y);
      let _ = (n = t.extra) == null ? void 0 : n.parenthesized, g = _ && l.preserveFormat || _ && l.retainFunctionParens && u === "FunctionE\
xpression" || C3e(t, h, this.tokenContext, this.inForStatementInit, l.preserveFormat ? this._boundGetRawIdentifier : void 0);
      if (!g && _ && (a = t.leadingComments) != null && a.length && t.leadingComments[0].type === "CommentBlock")
        switch (h?.type) {
          case "ExpressionStatement":
          case "VariableDeclarator":
          case "AssignmentExpression":
          case "ReturnStatement":
            break;
          case "CallExpression":
          case "OptionalCallExpression":
          case "NewExpression":
            if (h.callee !== t) break;
          default:
            g = !0;
        }
      let m = !1;
      !g && this._noLineTerminator && ((o = t.leadingComments) != null && o.some(u9) || this.format.retainLines && t.loc && t.loc.start.line >
      this._buf.getCurrentLine()) && (g = !0, m = !0);
      let f, d;
      if (!g && (r || (r = h && this._noLineTerminatorAfterNode === h && l9.isLastChild(h, t)), r)) {
        var v;
        (v = t.trailingComments) != null && v.some(u9) ? g3e(t) && (g = !0) : (f = this._noLineTerminatorAfterNode, this._noLineTerminatorAfterNode =
        t);
      }
      g && (this.tokenChar(40), m && this.indent(), this._endsWithInnerRaw = !1, this.inForStatementInit && (d = !0, this.inForStatementInit =
      !1), f = this._noLineTerminatorAfterNode, this._noLineTerminatorAfterNode = null), this._lastCommentLine = 0, this._printLeadingComments(
      t, h);
      let E = u === "Program" || u === "File" ? null : t.loc;
      this.exactSource(E, p.bind(this, t, h)), g ? (this._printTrailingComments(t, h), m && (this.dedent(), this.newline()), this.tokenChar(
      41), this._noLineTerminator = r, d && (this.inForStatementInit = !0)) : r && !this._noLineTerminator ? (this._noLineTerminator = !0, this.
      _printTrailingComments(t, h)) : this._printTrailingComments(t, h, i), this._currentNode = h, l.concise = c, this._insideAux = y, f !==
      void 0 && (this._noLineTerminatorAfterNode = f), this._endsWithInnerRaw = !1;
    }
    _maybeAddAuxComment(t) {
      t && this._printAuxBeforeComment(), this._insideAux || this._printAuxAfterComment();
    }
    _printAuxBeforeComment() {
      if (this._printAuxAfterOnNextUserNode) return;
      this._printAuxAfterOnNextUserNode = !0;
      let t = this.format.auxiliaryCommentBefore;
      t && this._printComment({
        type: "CommentBlock",
        value: t
      }, 0);
    }
    _printAuxAfterComment() {
      if (!this._printAuxAfterOnNextUserNode) return;
      this._printAuxAfterOnNextUserNode = !1;
      let t = this.format.auxiliaryCommentAfter;
      t && this._printComment({
        type: "CommentBlock",
        value: t
      }, 0);
    }
    getPossibleRaw(t) {
      let r = t.extra;
      if (r?.raw != null && r.rawValue != null && t.value === r.rawValue)
        return r.raw;
    }
    printJoin(t, r, i, n, a, o, u, l) {
      if (!(t != null && t.length)) return;
      if (i == null && this.format.retainLines) {
        var c;
        let m = (c = t[0].loc) == null ? void 0 : c.start.line;
        m != null && m !== this._buf.getCurrentLine() && (i = !0);
      }
      i && this.indent();
      let p = {
        addNewlines: o,
        nextNodeStartLine: 0
      }, h = n?.bind(this), y = t.length;
      for (let m = 0; m < y; m++) {
        let f = t[m];
        if (f && (r && this._printNewline(m === 0, p), this.print(f, void 0, l || 0), u?.(f, m), h != null && (m < y - 1 ? h(m, !1) : a && h(
        m, !0)), r)) {
          var _;
          if ((_ = f.trailingComments) != null && _.length || (this._lastCommentLine = 0), m + 1 === y)
            this.newline(1);
          else {
            var g;
            let d = t[m + 1];
            p.nextNodeStartLine = ((g = d.loc) == null ? void 0 : g.start.line) || 0, this._printNewline(!0, p);
          }
        }
      }
      i && this.dedent();
    }
    printAndIndentOnComments(t) {
      let r = t.leadingComments && t.leadingComments.length > 0;
      r && this.indent(), this.print(t), r && this.dedent();
    }
    printBlock(t) {
      let r = t.body;
      r.type !== "EmptyStatement" && this.space(), this.print(r);
    }
    _printTrailingComments(t, r, i) {
      let {
        innerComments: n,
        trailingComments: a
      } = t;
      n != null && n.length && this._printComments(2, n, t, r, i), a != null && a.length && this._printComments(2, a, t, r, i);
    }
    _printLeadingComments(t, r) {
      let i = t.leadingComments;
      i != null && i.length && this._printComments(0, i, t, r);
    }
    _maybePrintInnerComments(t, r) {
      if (this._endsWithInnerRaw) {
        var i;
        this.printInnerComments((i = this.tokenMap) == null ? void 0 : i.findMatching(this._currentNode, t, r));
      }
      this._endsWithInnerRaw = !0, this._indentInnerComments = !0;
    }
    printInnerComments(t) {
      let r = this._currentNode, i = r.innerComments;
      if (!(i != null && i.length)) return;
      let n = this.endsWith(32), a = this._indentInnerComments, o = this._printedComments.size;
      a && this.indent(), this._printComments(1, i, r, void 0, void 0, t), n && o !== this._printedComments.size && this.space(), a && this.
      dedent();
    }
    noIndentInnerCommentsHere() {
      this._indentInnerComments = !1;
    }
    printSequence(t, r, i, n) {
      this.printJoin(t, !0, r ?? !1, void 0, void 0, n, void 0, i);
    }
    printList(t, r, i, n, a, o) {
      this.printJoin(t, i, n, a ?? P3e, r, void 0, o);
    }
    shouldPrintTrailingComma(t) {
      if (!this.tokenMap) return null;
      let r = this.tokenMap.findLastIndex(this._currentNode, (i) => this.tokenMap.matchesOriginal(i, t));
      return r <= 0 ? null : this.tokenMap.matchesOriginal(this._tokens[r - 1], ",");
    }
    _printNewline(t, r) {
      let i = this.format;
      if (i.retainLines || i.compact) return;
      if (i.concise) {
        this.space();
        return;
      }
      if (!t)
        return;
      let n = r.nextNodeStartLine, a = this._lastCommentLine;
      if (n > 0 && a > 0) {
        let o = n - a;
        if (o >= 0) {
          this.newline(o || 1);
          return;
        }
      }
      this._buf.hasContent() && this.newline(1);
    }
    _shouldPrintComment(t, r) {
      if (t.ignore || this._printedComments.has(t)) return 0;
      if (this._noLineTerminator && x3e.test(t.value))
        return 2;
      if (r && this.tokenMap) {
        let i = this.tokenMap.find(this._currentNode, (n) => n.value === t.value);
        if (i && i.start > r.start)
          return 2;
      }
      return this._printedComments.add(t), this.format.shouldPrintComment(t.value) ? 1 : 0;
    }
    _printComment(t, r) {
      let i = this._noLineTerminator, n = t.type === "CommentBlock", a = n && r !== 1 && !this._noLineTerminator;
      a && this._buf.hasContent() && r !== 2 && this.newline(1);
      let o = this.getLastChar();
      o !== 91 && o !== 123 && o !== 40 && this.space();
      let u;
      if (n) {
        if (u = `/*${t.value}*/`, this.format.indent.adjustMultilineComment) {
          var l;
          let c = (l = t.loc) == null ? void 0 : l.start.column;
          if (c) {
            let p = new RegExp("\\n\\s{1," + c + "}", "g");
            u = u.replace(p, `
`);
          }
          if (this.format.concise)
            u = u.replace(/\n(?!$)/g, `
`);
          else {
            let p = this.format.retainLines ? 0 : this._buf.getCurrentColumn();
            (this._shouldIndent(47) || this.format.retainLines) && (p += this._getIndent()), u = u.replace(/\n(?!$)/g, `
${" ".repeat(p)}`);
          }
        }
      } else i ? u = `/*${t.value}*/` : u = `//${t.value}`;
      if (this._endsWithDiv && this._space(), this.tokenMap) {
        let {
          _printSemicolonBeforeNextToken: c,
          _printSemicolonBeforeNextNode: p
        } = this;
        this._printSemicolonBeforeNextToken = -1, this._printSemicolonBeforeNextNode = -1, this.source("start", t.loc), this._append(u, n), this.
        _printSemicolonBeforeNextNode = p, this._printSemicolonBeforeNextToken = c;
      } else
        this.source("start", t.loc), this._append(u, n);
      !n && !i && this.newline(1, !0), a && r !== 3 && this.newline(1);
    }
    _printComments(t, r, i, n, a = 0, o) {
      let u = i.loc, l = r.length, c = !!u, p = c ? u.start.line : 0, h = c ? u.end.line : 0, y = 0, _ = 0, g = this._noLineTerminator ? function() {
      } : this.newline.bind(this);
      for (let m = 0; m < l; m++) {
        let f = r[m], d = this._shouldPrintComment(f, o);
        if (d === 2) {
          c = !1;
          break;
        }
        if (c && f.loc && d === 1) {
          let v = f.loc.start.line, E = f.loc.end.line;
          if (t === 0) {
            let S = 0;
            m === 0 ? this._buf.hasContent() && (f.type === "CommentLine" || v !== E) && (S = _ = 1) : S = v - y, y = E, g(S), this._printComment(
            f, 1), m + 1 === l && (g(Math.max(p - y, _)), y = p);
          } else if (t === 1) {
            let S = v - (m === 0 ? p : y);
            y = E, g(S), this._printComment(f, 1), m + 1 === l && (g(Math.min(1, h - y)), y = h);
          } else {
            let S = v - (m === 0 ? h - a : y);
            y = E, g(S), this._printComment(f, 1);
          }
        } else {
          if (c = !1, d !== 1)
            continue;
          if (l === 1) {
            let v = f.loc ? f.loc.start.line === f.loc.end.line : !c9.test(f.value), E = v && !b3e(i) && !v3e(n) && !S3e(n) && !T3e(i);
            t === 0 ? this._printComment(f, E && i.type !== "ObjectExpression" || v && _3e(n, {
              body: i
            }) ? 1 : 0) : E && t === 2 ? this._printComment(f, 1) : this._printComment(f, 0);
          } else t === 1 && !(i.type === "ObjectExpression" && i.properties.length > 1) && i.type !== "ClassBody" && i.type !== "TSInterface\
Body" ? this._printComment(f, m === 0 ? 2 : m === l - 1 ? 3 : 0) : this._printComment(f, 0);
        }
      }
      t === 2 && c && y && (this._lastCommentLine = y);
    }
  };
  Object.assign(bd.prototype, m3e);
  (0, y3e.addDeprecatedGenerators)(bd);
  var L1t = L_.default = bd;
  function P3e(e, t) {
    this.token(",", !1, e), t || this.space();
  }
  s(P3e, "commaSeparator");
});

// ../node_modules/@babel/generator/lib/index.js
var y9 = b((Zf) => {
  "use strict";
  Object.defineProperty(Zf, "__esModule", {
    value: !0
  });
  Zf.default = void 0;
  Zf.generate = m9;
  var p9 = p8(), h9 = f9();
  function d9(e, t, r) {
    if (t.experimental_preserveFormat) {
      if (typeof e != "string")
        throw new Error("`experimental_preserveFormat` requires the original `code` to be passed to @babel/generator as a string");
      if (!t.retainLines)
        throw new Error("`experimental_preserveFormat` requires `retainLines` to be set to `true`");
      if (t.compact && t.compact !== "auto")
        throw new Error("`experimental_preserveFormat` is not compatible with the `compact` option");
      if (t.minified)
        throw new Error("`experimental_preserveFormat` is not compatible with the `minified` option");
      if (t.jsescOption)
        throw new Error("`experimental_preserveFormat` is not compatible with the `jsescOption` option");
      if (!Array.isArray(r.tokens))
        throw new Error("`experimental_preserveFormat` requires the AST to have attatched the token of the input code. Make sure to enable t\
he `tokens: true` parser option.");
    }
    let i = {
      auxiliaryCommentBefore: t.auxiliaryCommentBefore,
      auxiliaryCommentAfter: t.auxiliaryCommentAfter,
      shouldPrintComment: t.shouldPrintComment,
      preserveFormat: t.experimental_preserveFormat,
      retainLines: t.retainLines,
      retainFunctionParens: t.retainFunctionParens,
      comments: t.comments == null || t.comments,
      compact: t.compact,
      minified: t.minified,
      concise: t.concise,
      indent: {
        adjustMultilineComment: !0,
        style: "  "
      },
      jsescOption: Object.assign({
        quotes: "double",
        wrap: !0,
        minimal: !1
      }, t.jsescOption),
      topicToken: t.topicToken,
      importAttributesKeyword: t.importAttributesKeyword
    };
    {
      var n;
      i.decoratorsBeforeExport = t.decoratorsBeforeExport, i.jsescOption.json = t.jsonCompatibleStrings, i.recordAndTupleSyntaxType = (n = t.
      recordAndTupleSyntaxType) != null ? n : "hash";
    }
    i.minified ? (i.compact = !0, i.shouldPrintComment = i.shouldPrintComment || (() => i.comments)) : i.shouldPrintComment = i.shouldPrintComment ||
    ((l) => i.comments || l.includes("@license") || l.includes("@preserve")), i.compact === "auto" && (i.compact = typeof e == "string" && e.
    length > 5e5, i.compact && console.error(`[BABEL] Note: The code generator has deoptimised the styling of ${t.filename} as it exceeds th\
e max of 500KB.`)), (i.compact || i.preserveFormat) && (i.indent.adjustMultilineComment = !1);
    let {
      auxiliaryCommentBefore: a,
      auxiliaryCommentAfter: o,
      shouldPrintComment: u
    } = i;
    return a && !u(a) && (i.auxiliaryCommentBefore = void 0), o && !u(o) && (i.auxiliaryCommentAfter = void 0), i;
  }
  s(d9, "normalizeOptions");
  Zf.CodeGenerator = class {
    static {
      s(this, "CodeGenerator");
    }
    constructor(t, r = {}, i) {
      this._ast = void 0, this._format = void 0, this._map = void 0, this._ast = t, this._format = d9(i, r, t), this._map = r.sourceMaps ? new p9.
      default(r, i) : null;
    }
    generate() {
      return new h9.default(this._format, this._map).generate(this._ast);
    }
  };
  function m9(e, t = {}, r) {
    let i = d9(r, t, e), n = t.sourceMaps ? new p9.default(t, r) : null;
    return new h9.default(i, n, e.tokens, typeof r == "string" ? r : null).generate(e);
  }
  s(m9, "generate");
  var q1t = Zf.default = m9;
});

// ../node_modules/@babel/parser/lib/index.js
var W9 = b((wd) => {
  "use strict";
  Object.defineProperty(wd, "__esModule", {
    value: !0
  });
  function D3e(e, t) {
    if (e == null) return {};
    var r = {};
    for (var i in e) if ({}.hasOwnProperty.call(e, i)) {
      if (t.indexOf(i) !== -1) continue;
      r[i] = e[i];
    }
    return r;
  }
  s(D3e, "_objectWithoutPropertiesLoose");
  var Lo = class {
    static {
      s(this, "Position");
    }
    constructor(t, r, i) {
      this.line = void 0, this.column = void 0, this.index = void 0, this.line = t, this.column = r, this.index = i;
    }
  }, np = class {
    static {
      s(this, "SourceLocation");
    }
    constructor(t, r) {
      this.start = void 0, this.end = void 0, this.filename = void 0, this.identifierName = void 0, this.start = t, this.end = r;
    }
  };
  function ms(e, t) {
    let {
      line: r,
      column: i,
      index: n
    } = e;
    return new Lo(r, i + t, n + t);
  }
  s(ms, "createPositionWithColumnOffset");
  var g9 = "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED", w3e = {
    ImportMetaOutsideModule: {
      message: `import.meta may appear only with 'sourceType: "module"'`,
      code: g9
    },
    ImportOutsideModule: {
      message: `'import' and 'export' may appear only with 'sourceType: "module"'`,
      code: g9
    }
  }, _9 = {
    ArrayPattern: "array destructuring pattern",
    AssignmentExpression: "assignment expression",
    AssignmentPattern: "assignment expression",
    ArrowFunctionExpression: "arrow function expression",
    ConditionalExpression: "conditional expression",
    CatchClause: "catch clause",
    ForOfStatement: "for-of statement",
    ForInStatement: "for-in statement",
    ForStatement: "for-loop",
    FormalParameters: "function parameter list",
    Identifier: "identifier",
    ImportSpecifier: "import specifier",
    ImportDefaultSpecifier: "import default specifier",
    ImportNamespaceSpecifier: "import namespace specifier",
    ObjectPattern: "object destructuring pattern",
    ParenthesizedExpression: "parenthesized expression",
    RestElement: "rest element",
    UpdateExpression: {
      true: "prefix operation",
      false: "postfix operation"
    },
    VariableDeclarator: "variable declaration",
    YieldExpression: "yield expression"
  }, B_ = /* @__PURE__ */ s((e) => e.type === "UpdateExpression" ? _9.UpdateExpression[`${e.prefix}`] : _9[e.type], "toNodeDescription"), O3e = {
    AccessorIsGenerator: /* @__PURE__ */ s(({
      kind: e
    }) => `A ${e}ter cannot be a generator.`, "AccessorIsGenerator"),
    ArgumentsInClass: "'arguments' is only allowed in functions and class methods.",
    AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.",
    AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.",
    AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.",
    AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.",
    AwaitUsingNotInAsyncContext: "'await using' is only allowed within async functions and at the top levels of modules.",
    AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.",
    BadGetterArity: "A 'get' accessor must not have any formal parameters.",
    BadSetterArity: "A 'set' accessor must have exactly one formal parameter.",
    BadSetterRestParameter: "A 'set' accessor function argument must not be a rest parameter.",
    ConstructorClassField: "Classes may not have a field named 'constructor'.",
    ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.",
    ConstructorIsAccessor: "Class constructor may not be an accessor.",
    ConstructorIsAsync: "Constructor can't be an async function.",
    ConstructorIsGenerator: "Constructor can't be a generator.",
    DeclarationMissingInitializer: /* @__PURE__ */ s(({
      kind: e
    }) => `Missing initializer in ${e} declaration.`, "DeclarationMissingInitializer"),
    DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(deco\
rator)(args)'.",
    DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use\
 the 'export @decorator class {}' syntax.",
    DecoratorsBeforeAfterExport: "Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the s\
ame time.",
    DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
    DecoratorExportClass: "Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use \
the '@decorator export class {}' syntax.",
    DecoratorSemicolon: "Decorators must not be followed by a semicolon.",
    DecoratorStaticBlock: "Decorators can't be used with a static block.",
    DeferImportRequiresNamespace: 'Only `import defer * as x from "./module"` is valid.',
    DeletePrivateField: "Deleting a private field is not allowed.",
    DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",
    DuplicateConstructor: "Duplicate constructor in the same class.",
    DuplicateDefaultExport: "Only one default export allowed per module.",
    DuplicateExport: /* @__PURE__ */ s(({
      exportName: e
    }) => `\`${e}\` has already been exported. Exported identifiers must be unique.`, "DuplicateExport"),
    DuplicateProto: "Redefinition of __proto__ property.",
    DuplicateRegExpFlags: "Duplicate regular expression flag.",
    DynamicImportPhaseRequiresImportExpressions: /* @__PURE__ */ s(({
      phase: e
    }) => `'import.${e}(...)' can only be parsed when using the 'createImportExpressions' option.`, "DynamicImportPhaseRequiresImportExpress\
ions"),
    ElementAfterRest: "Rest element must be last element.",
    EscapedCharNotAnIdentifier: "Invalid Unicode escape.",
    ExportBindingIsString: /* @__PURE__ */ s(({
      localName: e,
      exportName: t
    }) => `A string literal cannot be used as an exported binding without \`from\`.
- Did you mean \`export { '${e}' as '${t}' } from 'some-module'\`?`, "ExportBindingIsString"),
    ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.",
    ForInOfLoopInitializer: /* @__PURE__ */ s(({
      type: e
    }) => `'${e === "ForInStatement" ? "for-in" : "for-of"}' loop variable declaration may not have an initializer.`, "ForInOfLoopInitialize\
r"),
    ForInUsing: "For-in loop may not start with 'using' declaration.",
    ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.",
    ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.",
    GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.",
    IllegalBreakContinue: /* @__PURE__ */ s(({
      type: e
    }) => `Unsyntactic ${e === "BreakStatement" ? "break" : "continue"}.`, "IllegalBreakContinue"),
    IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.",
    IllegalReturn: "'return' outside of function.",
    ImportAttributesUseAssert: "The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You \
can enable the `deprecatedImportAssert` parser plugin to suppress this error.",
    ImportBindingIsString: /* @__PURE__ */ s(({
      importName: e
    }) => `A string literal cannot be used as an imported binding.
- Did you mean \`import { "${e}" as foo }\`?`, "ImportBindingIsString"),
    ImportCallArity: "`import()` requires exactly one or two arguments.",
    ImportCallNotNewExpression: "Cannot use new with import(...).",
    ImportCallSpreadArgument: "`...` is not allowed in `import()`.",
    ImportJSONBindingNotDefault: "A JSON module can only be imported with `default`.",
    ImportReflectionHasAssertion: "`import module x` cannot have assertions.",
    ImportReflectionNotBinding: 'Only `import module x from "./module"` is valid.',
    IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.",
    InvalidBigIntLiteral: "Invalid BigIntLiteral.",
    InvalidCodePoint: "Code point out of bounds.",
    InvalidCoverInitializedName: "Invalid shorthand property initializer.",
    InvalidDecimal: "Invalid decimal.",
    InvalidDigit: /* @__PURE__ */ s(({
      radix: e
    }) => `Expected number in radix ${e}.`, "InvalidDigit"),
    InvalidEscapeSequence: "Bad character escape sequence.",
    InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.",
    InvalidEscapedReservedWord: /* @__PURE__ */ s(({
      reservedWord: e
    }) => `Escape sequence in keyword ${e}.`, "InvalidEscapedReservedWord"),
    InvalidIdentifier: /* @__PURE__ */ s(({
      identifierName: e
    }) => `Invalid identifier ${e}.`, "InvalidIdentifier"),
    InvalidLhs: /* @__PURE__ */ s(({
      ancestor: e
    }) => `Invalid left-hand side in ${B_(e)}.`, "InvalidLhs"),
    InvalidLhsBinding: /* @__PURE__ */ s(({
      ancestor: e
    }) => `Binding invalid left-hand side in ${B_(e)}.`, "InvalidLhsBinding"),
    InvalidLhsOptionalChaining: /* @__PURE__ */ s(({
      ancestor: e
    }) => `Invalid optional chaining in the left-hand side of ${B_(e)}.`, "InvalidLhsOptionalChaining"),
    InvalidNumber: "Invalid number.",
    InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.",
    InvalidOrUnexpectedToken: /* @__PURE__ */ s(({
      unexpected: e
    }) => `Unexpected character '${e}'.`, "InvalidOrUnexpectedToken"),
    InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.",
    InvalidPrivateFieldResolution: /* @__PURE__ */ s(({
      identifierName: e
    }) => `Private name #${e} is not defined.`, "InvalidPrivateFieldResolution"),
    InvalidPropertyBindingPattern: "Binding member expression.",
    InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.",
    InvalidRestAssignmentPattern: "Invalid rest operator's argument.",
    LabelRedeclaration: /* @__PURE__ */ s(({
      labelName: e
    }) => `Label '${e}' is already declared.`, "LabelRedeclaration"),
    LetInLexicalBinding: "'let' is disallowed as a lexically bound name.",
    LineTerminatorBeforeArrow: "No line break is allowed before '=>'.",
    MalformedRegExpFlags: "Invalid regular expression flag.",
    MissingClassName: "A class name is required.",
    MissingEqInAssignment: "Only '=' operator can be used for specifying default value.",
    MissingSemicolon: "Missing semicolon.",
    MissingPlugin: /* @__PURE__ */ s(({
      missingPlugin: e
    }) => `This experimental syntax requires enabling the parser plugin: ${e.map((t) => JSON.stringify(t)).join(", ")}.`, "MissingPlugin"),
    MissingOneOfPlugins: /* @__PURE__ */ s(({
      missingPlugin: e
    }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${e.map((t) => JSON.stringify(t)).join(", ")}.`,
    "MissingOneOfPlugins"),
    MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.",
    MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.",
    ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.",
    ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.",
    ModuleAttributesWithDuplicateKeys: /* @__PURE__ */ s(({
      key: e
    }) => `Duplicate key "${e}" is not allowed in module attributes.`, "ModuleAttributesWithDuplicateKeys"),
    ModuleExportNameHasLoneSurrogate: /* @__PURE__ */ s(({
      surrogateCharCode: e
    }) => `An export name cannot include a lone surrogate, found '\\u${e.toString(16)}'.`, "ModuleExportNameHasLoneSurrogate"),
    ModuleExportUndefined: /* @__PURE__ */ s(({
      localName: e
    }) => `Export '${e}' is not defined.`, "ModuleExportUndefined"),
    MultipleDefaultsInSwitch: "Multiple default clauses.",
    NewlineAfterThrow: "Illegal newline after throw.",
    NoCatchOrFinally: "Missing catch or finally clause.",
    NumberIdentifier: "Identifier directly after number.",
    NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.",
    ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.",
    OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.",
    OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.",
    OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.",
    ParamDupe: "Argument name clash.",
    PatternHasAccessor: "Object pattern can't contain getter or setter.",
    PatternHasMethod: "Object pattern can't contain methods.",
    PrivateInExpectedIn: /* @__PURE__ */ s(({
      identifierName: e
    }) => `Private names are only allowed in property accesses (\`obj.#${e}\`) or in \`in\` expressions (\`#${e} in obj\`).`, "PrivateInExpe\
ctedIn"),
    PrivateNameRedeclaration: /* @__PURE__ */ s(({
      identifierName: e
    }) => `Duplicate private name #${e}.`, "PrivateNameRedeclaration"),
    RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 're\
cordAndTuple' plugin is set to 'bar'.",
    RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the\
 'recordAndTuple' plugin is set to 'bar'.",
    RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of th\
e 'recordAndTuple' plugin is set to 'hash'.",
    RecordNoProto: "'__proto__' is not allowed in Record expressions.",
    RestTrailingComma: "Unexpected trailing comma after rest element.",
    SloppyFunction: "In non-strict mode code, functions can only be declared at top level or inside a block.",
    SloppyFunctionAnnexB: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if sta\
tement.",
    SourcePhaseImportRequiresDefault: 'Only `import source x from "./module"` is valid.',
    StaticPrototype: "Classes may not have static property named prototype.",
    SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or n\
ot extending another class?",
    SuperPrivateField: "Private fields can't be accessed on super.",
    TrailingDecorator: "Decorators must be attached to a class element.",
    TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'reco\
rdAndTuple' plugin is set to 'bar'.",
    TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the '\
recordAndTuple' plugin is set to 'bar'.",
    TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the \
'recordAndTuple' plugin is set to 'hash'.",
    UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.",
    UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.',
    UnexpectedDigitAfterHash: "Unexpected digit after hash token.",
    UnexpectedImportExport: "'import' and 'export' may only appear at the top level.",
    UnexpectedKeyword: /* @__PURE__ */ s(({
      keyword: e
    }) => `Unexpected keyword '${e}'.`, "UnexpectedKeyword"),
    UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.",
    UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.",
    UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.",
    UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.",
    UnexpectedPrivateField: "Unexpected private name.",
    UnexpectedReservedWord: /* @__PURE__ */ s(({
      reservedWord: e
    }) => `Unexpected reserved word '${e}'.`, "UnexpectedReservedWord"),
    UnexpectedSuper: "'super' is only allowed in object methods and classes.",
    UnexpectedToken: /* @__PURE__ */ s(({
      expected: e,
      unexpected: t
    }) => `Unexpected token${t ? ` '${t}'.` : ""}${e ? `, expected "${e}"` : ""}`, "UnexpectedToken"),
    UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",
    UnexpectedUsingDeclaration: "Using declaration cannot appear in the top level when source type is `script`.",
    UnsupportedBind: "Binding should be performed on object property.",
    UnsupportedDecoratorExport: "A decorated export must export a class declaration.",
    UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.",
    UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.",
    UnsupportedMetaProperty: /* @__PURE__ */ s(({
      target: e,
      onlyValidPropertyName: t
    }) => `The only valid meta property for ${e} is ${e}.${t}.`, "UnsupportedMetaProperty"),
    UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.",
    UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.",
    UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).",
    UnterminatedComment: "Unterminated comment.",
    UnterminatedRegExp: "Unterminated regular expression.",
    UnterminatedString: "Unterminated string constant.",
    UnterminatedTemplate: "Unterminated template.",
    UsingDeclarationExport: "Using declaration cannot be exported.",
    UsingDeclarationHasBindingPattern: "Using declaration cannot have destructuring patterns.",
    VarRedeclaration: /* @__PURE__ */ s(({
      identifierName: e
    }) => `Identifier '${e}' has already been declared.`, "VarRedeclaration"),
    YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.",
    YieldInParameter: "Yield expression is not allowed in formal parameters.",
    YieldNotInGeneratorFunction: "'yield' is only allowed within generator functions.",
    ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0."
  }, k3e = {
    StrictDelete: "Deleting local variable in strict mode.",
    StrictEvalArguments: /* @__PURE__ */ s(({
      referenceName: e
    }) => `Assigning to '${e}' in strict mode.`, "StrictEvalArguments"),
    StrictEvalArgumentsBinding: /* @__PURE__ */ s(({
      bindingName: e
    }) => `Binding '${e}' in strict mode.`, "StrictEvalArgumentsBinding"),
    StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.",
    StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.",
    StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.",
    StrictWith: "'with' in strict mode."
  }, I3e = /* @__PURE__ */ new Set(["ArrowFunctionExpression", "AssignmentExpression", "ConditionalExpression", "YieldExpression"]), R3e = Object.
  assign({
    PipeBodyIsTighter: "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due \
to its loose operator precedence.",
    PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" opt\
ion.',
    PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.",
    PipeTopicUnconfiguredToken: /* @__PURE__ */ s(({
      token: e
    }) => `Invalid topic token ${e}. In order to use ${e} as a topic reference, the pipelineOperator plugin must be configured with { "propo\
sal": "hack", "topicToken": "${e}" }.`, "PipeTopicUnconfiguredToken"),
    PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.",
    PipeUnparenthesizedBody: /* @__PURE__ */ s(({
      type: e
    }) => `Hack-style pipe body cannot be an unparenthesized ${B_({
      type: e
    })}; please wrap it in parentheses.`, "PipeUnparenthesizedBody")
  }, {
    PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.',
    PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.",
    PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.",
    PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.",
    PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.",
    PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "sma\
rt" option.'
  }), N3e = ["message"];
  function b9(e, t, r) {
    Object.defineProperty(e, t, {
      enumerable: !1,
      configurable: !0,
      value: r
    });
  }
  s(b9, "defineHidden");
  function L3e({
    toMessage: e,
    code: t,
    reasonCode: r,
    syntaxPlugin: i
  }) {
    let n = r === "MissingPlugin" || r === "MissingOneOfPlugins";
    {
      let a = {
        AccessorCannotDeclareThisParameter: "AccesorCannotDeclareThisParameter",
        AccessorCannotHaveTypeParameters: "AccesorCannotHaveTypeParameters",
        ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference: "ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumRefer\
ence",
        SetAccessorCannotHaveOptionalParameter: "SetAccesorCannotHaveOptionalParameter",
        SetAccessorCannotHaveRestParameter: "SetAccesorCannotHaveRestParameter",
        SetAccessorCannotHaveReturnType: "SetAccesorCannotHaveReturnType"
      };
      a[r] && (r = a[r]);
    }
    return /* @__PURE__ */ s(function a(o, u) {
      let l = new SyntaxError();
      return l.code = t, l.reasonCode = r, l.loc = o, l.pos = o.index, l.syntaxPlugin = i, n && (l.missingPlugin = u.missingPlugin), b9(l, "\
clone", /* @__PURE__ */ s(function(p = {}) {
        var h;
        let {
          line: y,
          column: _,
          index: g
        } = (h = p.loc) != null ? h : o;
        return a(new Lo(y, _, g), Object.assign({}, u, p.details));
      }, "clone")), b9(l, "details", u), Object.defineProperty(l, "message", {
        configurable: !0,
        get() {
          let c = `${e(u)} (${o.line}:${o.column})`;
          return this.message = c, c;
        },
        set(c) {
          Object.defineProperty(this, "message", {
            value: c,
            writable: !0
          });
        }
      }), l;
    }, "constructor");
  }
  s(L3e, "toParseErrorConstructor");
  function Eu(e, t) {
    if (Array.isArray(e))
      return (i) => Eu(i, e[0]);
    let r = {};
    for (let i of Object.keys(e)) {
      let n = e[i], a = typeof n == "string" ? {
        message: /* @__PURE__ */ s(() => n, "message")
      } : typeof n == "function" ? {
        message: n
      } : n, {
        message: o
      } = a, u = D3e(a, N3e), l = typeof o == "string" ? () => o : o;
      r[i] = L3e(Object.assign({
        code: "BABEL_PARSER_SYNTAX_ERROR",
        reasonCode: i,
        toMessage: l
      }, t ? {
        syntaxPlugin: t
      } : {}, u));
    }
    return r;
  }
  s(Eu, "ParseErrorEnum");
  var Z = Object.assign({}, Eu(w3e), Eu(O3e), Eu(k3e), Eu`pipelineOperator`(R3e));
  function F3e() {
    return {
      sourceType: "script",
      sourceFilename: void 0,
      startIndex: 0,
      startColumn: 0,
      startLine: 1,
      allowAwaitOutsideFunction: !1,
      allowReturnOutsideFunction: !1,
      allowNewTargetOutsideFunction: !1,
      allowImportExportEverywhere: !1,
      allowSuperOutsideMethod: !1,
      allowUndeclaredExports: !1,
      allowYieldOutsideFunction: !1,
      plugins: [],
      strictMode: null,
      ranges: !1,
      tokens: !1,
      createImportExpressions: !1,
      createParenthesizedExpressions: !1,
      errorRecovery: !1,
      attachComment: !0,
      annexB: !0
    };
  }
  s(F3e, "createDefaultOptions");
  function M3e(e) {
    let t = F3e();
    if (e == null)
      return t;
    if (e.annexB != null && e.annexB !== !1)
      throw new Error("The `annexB` option can only be set to `false`.");
    for (let r of Object.keys(t))
      e[r] != null && (t[r] = e[r]);
    if (t.startLine === 1)
      e.startIndex == null && t.startColumn > 0 ? t.startIndex = t.startColumn : e.startColumn == null && t.startIndex > 0 && (t.startColumn =
      t.startIndex);
    else if ((e.startColumn == null || e.startIndex == null) && e.startIndex != null)
      throw new Error("With a `startLine > 1` you must also specify `startIndex` and `startColumn`.");
    return t;
  }
  s(M3e, "getOptions");
  var {
    defineProperty: B3e
  } = Object, v9 = /* @__PURE__ */ s((e, t) => {
    e && B3e(e, t, {
      enumerable: !1,
      value: e[t]
    });
  }, "toUnenumerable");
  function vd(e) {
    return v9(e.loc.start, "index"), v9(e.loc.end, "index"), e;
  }
  s(vd, "toESTreeLocation");
  var q3e = /* @__PURE__ */ s((e) => class extends e {
    static {
      s(this, "ESTreeParserMixin");
    }
    parse() {
      let r = vd(super.parse());
      return this.optionFlags & 256 && (r.tokens = r.tokens.map(vd)), r;
    }
    parseRegExpLiteral({
      pattern: r,
      flags: i
    }) {
      let n = null;
      try {
        n = new RegExp(r, i);
      } catch {
      }
      let a = this.estreeParseLiteral(n);
      return a.regex = {
        pattern: r,
        flags: i
      }, a;
    }
    parseBigIntLiteral(r) {
      let i;
      try {
        i = BigInt(r);
      } catch {
        i = null;
      }
      let n = this.estreeParseLiteral(i);
      return n.bigint = String(n.value || r), n;
    }
    parseDecimalLiteral(r) {
      let n = this.estreeParseLiteral(null);
      return n.decimal = String(n.value || r), n;
    }
    estreeParseLiteral(r) {
      return this.parseLiteral(r, "Literal");
    }
    parseStringLiteral(r) {
      return this.estreeParseLiteral(r);
    }
    parseNumericLiteral(r) {
      return this.estreeParseLiteral(r);
    }
    parseNullLiteral() {
      return this.estreeParseLiteral(null);
    }
    parseBooleanLiteral(r) {
      return this.estreeParseLiteral(r);
    }
    directiveToStmt(r) {
      let i = r.value;
      delete r.value, i.type = "Literal", i.raw = i.extra.raw, i.value = i.extra.expressionValue;
      let n = r;
      return n.type = "ExpressionStatement", n.expression = i, n.directive = i.extra.rawValue, delete i.extra, n;
    }
    initFunction(r, i) {
      super.initFunction(r, i), r.expression = !1;
    }
    checkDeclaration(r) {
      r != null && this.isObjectProperty(r) ? this.checkDeclaration(r.value) : super.checkDeclaration(r);
    }
    getObjectOrClassMethodParams(r) {
      return r.value.params;
    }
    isValidDirective(r) {
      var i;
      return r.type === "ExpressionStatement" && r.expression.type === "Literal" && typeof r.expression.value == "string" && !((i = r.expression.
      extra) != null && i.parenthesized);
    }
    parseBlockBody(r, i, n, a, o) {
      super.parseBlockBody(r, i, n, a, o);
      let u = r.directives.map((l) => this.directiveToStmt(l));
      r.body = u.concat(r.body), delete r.directives;
    }
    parsePrivateName() {
      let r = super.parsePrivateName();
      return this.getPluginOption("estree", "classFeatures") ? this.convertPrivateNameToPrivateIdentifier(r) : r;
    }
    convertPrivateNameToPrivateIdentifier(r) {
      let i = super.getPrivateNameSV(r);
      return r = r, delete r.id, r.name = i, r.type = "PrivateIdentifier", r;
    }
    isPrivateName(r) {
      return this.getPluginOption("estree", "classFeatures") ? r.type === "PrivateIdentifier" : super.isPrivateName(r);
    }
    getPrivateNameSV(r) {
      return this.getPluginOption("estree", "classFeatures") ? r.name : super.getPrivateNameSV(r);
    }
    parseLiteral(r, i) {
      let n = super.parseLiteral(r, i);
      return n.raw = n.extra.raw, delete n.extra, n;
    }
    parseFunctionBody(r, i, n = !1) {
      super.parseFunctionBody(r, i, n), r.expression = r.body.type !== "BlockStatement";
    }
    parseMethod(r, i, n, a, o, u, l = !1) {
      let c = this.startNode();
      c.kind = r.kind, c = super.parseMethod(c, i, n, a, o, u, l), c.type = "FunctionExpression", delete c.kind, r.value = c;
      let {
        typeParameters: p
      } = r;
      return p && (delete r.typeParameters, c.typeParameters = p, this.resetStartLocationFromNode(c, p)), u === "ClassPrivateMethod" && (r.computed =
      !1), this.finishNode(r, "MethodDefinition");
    }
    nameIsConstructor(r) {
      return r.type === "Literal" ? r.value === "constructor" : super.nameIsConstructor(r);
    }
    parseClassProperty(...r) {
      let i = super.parseClassProperty(...r);
      return this.getPluginOption("estree", "classFeatures") && (i.type = "PropertyDefinition"), i;
    }
    parseClassPrivateProperty(...r) {
      let i = super.parseClassPrivateProperty(...r);
      return this.getPluginOption("estree", "classFeatures") && (i.type = "PropertyDefinition", i.computed = !1), i;
    }
    parseClassAccessorProperty(r) {
      let i = super.parseClassAccessorProperty(r);
      return this.getPluginOption("estree", "classFeatures") && (i.type = "AccessorProperty"), i;
    }
    parseObjectMethod(r, i, n, a, o) {
      let u = super.parseObjectMethod(r, i, n, a, o);
      return u && (u.type = "Property", u.kind === "method" && (u.kind = "init"), u.shorthand = !1), u;
    }
    parseObjectProperty(r, i, n, a) {
      let o = super.parseObjectProperty(r, i, n, a);
      return o && (o.kind = "init", o.type = "Property"), o;
    }
    isValidLVal(r, i, n) {
      return r === "Property" ? "value" : super.isValidLVal(r, i, n);
    }
    isAssignable(r, i) {
      return r != null && this.isObjectProperty(r) ? this.isAssignable(r.value, i) : super.isAssignable(r, i);
    }
    toAssignable(r, i = !1) {
      if (r != null && this.isObjectProperty(r)) {
        let {
          key: n,
          value: a
        } = r;
        this.isPrivateName(n) && this.classScope.usePrivateName(this.getPrivateNameSV(n), n.loc.start), this.toAssignable(a, i);
      } else
        super.toAssignable(r, i);
    }
    toAssignableObjectExpressionProp(r, i, n) {
      r.type === "Property" && (r.kind === "get" || r.kind === "set") ? this.raise(Z.PatternHasAccessor, r.key) : r.type === "Property" && r.
      method ? this.raise(Z.PatternHasMethod, r.key) : super.toAssignableObjectExpressionProp(r, i, n);
    }
    finishCallExpression(r, i) {
      let n = super.finishCallExpression(r, i);
      if (n.callee.type === "Import") {
        var a, o;
        n.type = "ImportExpression", n.source = n.arguments[0], n.options = (a = n.arguments[1]) != null ? a : null, n.attributes = (o = n.arguments[1]) !=
        null ? o : null, delete n.arguments, delete n.callee;
      }
      return n;
    }
    toReferencedArguments(r) {
      r.type !== "ImportExpression" && super.toReferencedArguments(r);
    }
    parseExport(r, i) {
      let n = this.state.lastTokStartLoc, a = super.parseExport(r, i);
      switch (a.type) {
        case "ExportAllDeclaration":
          a.exported = null;
          break;
        case "ExportNamedDeclaration":
          a.specifiers.length === 1 && a.specifiers[0].type === "ExportNamespaceSpecifier" && (a.type = "ExportAllDeclaration", a.exported =
          a.specifiers[0].exported, delete a.specifiers);
        case "ExportDefaultDeclaration":
          {
            var o;
            let {
              declaration: u
            } = a;
            u?.type === "ClassDeclaration" && ((o = u.decorators) == null ? void 0 : o.length) > 0 && u.start === a.start && this.resetStartLocation(
            a, n);
          }
          break;
      }
      return a;
    }
    parseSubscript(r, i, n, a) {
      let o = super.parseSubscript(r, i, n, a);
      if (a.optionalChainMember) {
        if ((o.type === "OptionalMemberExpression" || o.type === "OptionalCallExpression") && (o.type = o.type.substring(8)), a.stop) {
          let u = this.startNodeAtNode(o);
          return u.expression = o, this.finishNode(u, "ChainExpression");
        }
      } else (o.type === "MemberExpression" || o.type === "CallExpression") && (o.optional = !1);
      return o;
    }
    isOptionalMemberExpression(r) {
      return r.type === "ChainExpression" ? r.expression.type === "MemberExpression" : super.isOptionalMemberExpression(r);
    }
    hasPropertyAsPrivateName(r) {
      return r.type === "ChainExpression" && (r = r.expression), super.hasPropertyAsPrivateName(r);
    }
    isObjectProperty(r) {
      return r.type === "Property" && r.kind === "init" && !r.method;
    }
    isObjectMethod(r) {
      return r.type === "Property" && (r.method || r.kind === "get" || r.kind === "set");
    }
    finishNodeAt(r, i, n) {
      return vd(super.finishNodeAt(r, i, n));
    }
    resetStartLocation(r, i) {
      super.resetStartLocation(r, i), vd(r);
    }
    resetEndLocation(r, i = this.state.lastTokEndLoc) {
      super.resetEndLocation(r, i), vd(r);
    }
  }, "estree"), mc = class {
    static {
      s(this, "TokContext");
    }
    constructor(t, r) {
      this.token = void 0, this.preserveSpace = void 0, this.token = t, this.preserveSpace = !!r;
    }
  }, Er = {
    brace: new mc("{"),
    j_oTag: new mc("<tag"),
    j_cTag: new mc("</tag"),
    j_expr: new mc("<tag>...</tag>", !0)
  };
  Er.template = new mc("`", !0);
  var Yt = !0, Me = !0, tP = !0, Sd = !0, hl = !0, U3e = !0, j_ = class {
    static {
      s(this, "ExportedTokenType");
    }
    constructor(t, r = {}) {
      this.label = void 0, this.keyword = void 0, this.beforeExpr = void 0, this.startsExpr = void 0, this.rightAssociative = void 0, this.isLoop =
      void 0, this.isAssign = void 0, this.prefix = void 0, this.postfix = void 0, this.binop = void 0, this.label = t, this.keyword = r.keyword,
      this.beforeExpr = !!r.beforeExpr, this.startsExpr = !!r.startsExpr, this.rightAssociative = !!r.rightAssociative, this.isLoop = !!r.isLoop,
      this.isAssign = !!r.isAssign, this.prefix = !!r.prefix, this.postfix = !!r.postfix, this.binop = r.binop != null ? r.binop : null, this.
      updateContext = null;
    }
  }, xP = /* @__PURE__ */ new Map();
  function lr(e, t = {}) {
    t.keyword = e;
    let r = lt(e, t);
    return xP.set(e, r), r;
  }
  s(lr, "createKeyword");
  function ds(e, t) {
    return lt(e, {
      beforeExpr: Yt,
      binop: t
    });
  }
  s(ds, "createBinop");
  var xd = -1, Su = [], CP = [], PP = [], DP = [], wP = [], OP = [];
  function lt(e, t = {}) {
    var r, i, n, a;
    return ++xd, CP.push(e), PP.push((r = t.binop) != null ? r : -1), DP.push((i = t.beforeExpr) != null ? i : !1), wP.push((n = t.startsExpr) !=
    null ? n : !1), OP.push((a = t.prefix) != null ? a : !1), Su.push(new j_(e, t)), xd;
  }
  s(lt, "createToken");
  function Xt(e, t = {}) {
    var r, i, n, a;
    return ++xd, xP.set(e, xd), CP.push(e), PP.push((r = t.binop) != null ? r : -1), DP.push((i = t.beforeExpr) != null ? i : !1), wP.push((n =
    t.startsExpr) != null ? n : !1), OP.push((a = t.prefix) != null ? a : !1), Su.push(new j_("name", t)), xd;
  }
  s(Xt, "createKeywordLike");
  var j3e = {
    bracketL: lt("[", {
      beforeExpr: Yt,
      startsExpr: Me
    }),
    bracketHashL: lt("#[", {
      beforeExpr: Yt,
      startsExpr: Me
    }),
    bracketBarL: lt("[|", {
      beforeExpr: Yt,
      startsExpr: Me
    }),
    bracketR: lt("]"),
    bracketBarR: lt("|]"),
    braceL: lt("{", {
      beforeExpr: Yt,
      startsExpr: Me
    }),
    braceBarL: lt("{|", {
      beforeExpr: Yt,
      startsExpr: Me
    }),
    braceHashL: lt("#{", {
      beforeExpr: Yt,
      startsExpr: Me
    }),
    braceR: lt("}"),
    braceBarR: lt("|}"),
    parenL: lt("(", {
      beforeExpr: Yt,
      startsExpr: Me
    }),
    parenR: lt(")"),
    comma: lt(",", {
      beforeExpr: Yt
    }),
    semi: lt(";", {
      beforeExpr: Yt
    }),
    colon: lt(":", {
      beforeExpr: Yt
    }),
    doubleColon: lt("::", {
      beforeExpr: Yt
    }),
    dot: lt("."),
    question: lt("?", {
      beforeExpr: Yt
    }),
    questionDot: lt("?."),
    arrow: lt("=>", {
      beforeExpr: Yt
    }),
    template: lt("template"),
    ellipsis: lt("...", {
      beforeExpr: Yt
    }),
    backQuote: lt("`", {
      startsExpr: Me
    }),
    dollarBraceL: lt("${", {
      beforeExpr: Yt,
      startsExpr: Me
    }),
    templateTail: lt("...`", {
      startsExpr: Me
    }),
    templateNonTail: lt("...${", {
      beforeExpr: Yt,
      startsExpr: Me
    }),
    at: lt("@"),
    hash: lt("#", {
      startsExpr: Me
    }),
    interpreterDirective: lt("#!..."),
    eq: lt("=", {
      beforeExpr: Yt,
      isAssign: Sd
    }),
    assign: lt("_=", {
      beforeExpr: Yt,
      isAssign: Sd
    }),
    slashAssign: lt("_=", {
      beforeExpr: Yt,
      isAssign: Sd
    }),
    xorAssign: lt("_=", {
      beforeExpr: Yt,
      isAssign: Sd
    }),
    moduloAssign: lt("_=", {
      beforeExpr: Yt,
      isAssign: Sd
    }),
    incDec: lt("++/--", {
      prefix: hl,
      postfix: U3e,
      startsExpr: Me
    }),
    bang: lt("!", {
      beforeExpr: Yt,
      prefix: hl,
      startsExpr: Me
    }),
    tilde: lt("~", {
      beforeExpr: Yt,
      prefix: hl,
      startsExpr: Me
    }),
    doubleCaret: lt("^^", {
      startsExpr: Me
    }),
    doubleAt: lt("@@", {
      startsExpr: Me
    }),
    pipeline: ds("|>", 0),
    nullishCoalescing: ds("??", 1),
    logicalOR: ds("||", 1),
    logicalAND: ds("&&", 2),
    bitwiseOR: ds("|", 3),
    bitwiseXOR: ds("^", 4),
    bitwiseAND: ds("&", 5),
    equality: ds("==/!=/===/!==", 6),
    lt: ds("</>/<=/>=", 7),
    gt: ds("</>/<=/>=", 7),
    relational: ds("</>/<=/>=", 7),
    bitShift: ds("<</>>/>>>", 8),
    bitShiftL: ds("<</>>/>>>", 8),
    bitShiftR: ds("<</>>/>>>", 8),
    plusMin: lt("+/-", {
      beforeExpr: Yt,
      binop: 9,
      prefix: hl,
      startsExpr: Me
    }),
    modulo: lt("%", {
      binop: 10,
      startsExpr: Me
    }),
    star: lt("*", {
      binop: 10
    }),
    slash: ds("/", 10),
    exponent: lt("**", {
      beforeExpr: Yt,
      binop: 11,
      rightAssociative: !0
    }),
    _in: lr("in", {
      beforeExpr: Yt,
      binop: 7
    }),
    _instanceof: lr("instanceof", {
      beforeExpr: Yt,
      binop: 7
    }),
    _break: lr("break"),
    _case: lr("case", {
      beforeExpr: Yt
    }),
    _catch: lr("catch"),
    _continue: lr("continue"),
    _debugger: lr("debugger"),
    _default: lr("default", {
      beforeExpr: Yt
    }),
    _else: lr("else", {
      beforeExpr: Yt
    }),
    _finally: lr("finally"),
    _function: lr("function", {
      startsExpr: Me
    }),
    _if: lr("if"),
    _return: lr("return", {
      beforeExpr: Yt
    }),
    _switch: lr("switch"),
    _throw: lr("throw", {
      beforeExpr: Yt,
      prefix: hl,
      startsExpr: Me
    }),
    _try: lr("try"),
    _var: lr("var"),
    _const: lr("const"),
    _with: lr("with"),
    _new: lr("new", {
      beforeExpr: Yt,
      startsExpr: Me
    }),
    _this: lr("this", {
      startsExpr: Me
    }),
    _super: lr("super", {
      startsExpr: Me
    }),
    _class: lr("class", {
      startsExpr: Me
    }),
    _extends: lr("extends", {
      beforeExpr: Yt
    }),
    _export: lr("export"),
    _import: lr("import", {
      startsExpr: Me
    }),
    _null: lr("null", {
      startsExpr: Me
    }),
    _true: lr("true", {
      startsExpr: Me
    }),
    _false: lr("false", {
      startsExpr: Me
    }),
    _typeof: lr("typeof", {
      beforeExpr: Yt,
      prefix: hl,
      startsExpr: Me
    }),
    _void: lr("void", {
      beforeExpr: Yt,
      prefix: hl,
      startsExpr: Me
    }),
    _delete: lr("delete", {
      beforeExpr: Yt,
      prefix: hl,
      startsExpr: Me
    }),
    _do: lr("do", {
      isLoop: tP,
      beforeExpr: Yt
    }),
    _for: lr("for", {
      isLoop: tP
    }),
    _while: lr("while", {
      isLoop: tP
    }),
    _as: Xt("as", {
      startsExpr: Me
    }),
    _assert: Xt("assert", {
      startsExpr: Me
    }),
    _async: Xt("async", {
      startsExpr: Me
    }),
    _await: Xt("await", {
      startsExpr: Me
    }),
    _defer: Xt("defer", {
      startsExpr: Me
    }),
    _from: Xt("from", {
      startsExpr: Me
    }),
    _get: Xt("get", {
      startsExpr: Me
    }),
    _let: Xt("let", {
      startsExpr: Me
    }),
    _meta: Xt("meta", {
      startsExpr: Me
    }),
    _of: Xt("of", {
      startsExpr: Me
    }),
    _sent: Xt("sent", {
      startsExpr: Me
    }),
    _set: Xt("set", {
      startsExpr: Me
    }),
    _source: Xt("source", {
      startsExpr: Me
    }),
    _static: Xt("static", {
      startsExpr: Me
    }),
    _using: Xt("using", {
      startsExpr: Me
    }),
    _yield: Xt("yield", {
      startsExpr: Me
    }),
    _asserts: Xt("asserts", {
      startsExpr: Me
    }),
    _checks: Xt("checks", {
      startsExpr: Me
    }),
    _exports: Xt("exports", {
      startsExpr: Me
    }),
    _global: Xt("global", {
      startsExpr: Me
    }),
    _implements: Xt("implements", {
      startsExpr: Me
    }),
    _intrinsic: Xt("intrinsic", {
      startsExpr: Me
    }),
    _infer: Xt("infer", {
      startsExpr: Me
    }),
    _is: Xt("is", {
      startsExpr: Me
    }),
    _mixins: Xt("mixins", {
      startsExpr: Me
    }),
    _proto: Xt("proto", {
      startsExpr: Me
    }),
    _require: Xt("require", {
      startsExpr: Me
    }),
    _satisfies: Xt("satisfies", {
      startsExpr: Me
    }),
    _keyof: Xt("keyof", {
      startsExpr: Me
    }),
    _readonly: Xt("readonly", {
      startsExpr: Me
    }),
    _unique: Xt("unique", {
      startsExpr: Me
    }),
    _abstract: Xt("abstract", {
      startsExpr: Me
    }),
    _declare: Xt("declare", {
      startsExpr: Me
    }),
    _enum: Xt("enum", {
      startsExpr: Me
    }),
    _module: Xt("module", {
      startsExpr: Me
    }),
    _namespace: Xt("namespace", {
      startsExpr: Me
    }),
    _interface: Xt("interface", {
      startsExpr: Me
    }),
    _type: Xt("type", {
      startsExpr: Me
    }),
    _opaque: Xt("opaque", {
      startsExpr: Me
    }),
    name: lt("name", {
      startsExpr: Me
    }),
    placeholder: lt("%%", {
      startsExpr: !0
    }),
    string: lt("string", {
      startsExpr: Me
    }),
    num: lt("num", {
      startsExpr: Me
    }),
    bigint: lt("bigint", {
      startsExpr: Me
    }),
    decimal: lt("decimal", {
      startsExpr: Me
    }),
    regexp: lt("regexp", {
      startsExpr: Me
    }),
    privateName: lt("#name", {
      startsExpr: Me
    }),
    eof: lt("eof"),
    jsxName: lt("jsxName"),
    jsxText: lt("jsxText", {
      beforeExpr: !0
    }),
    jsxTagStart: lt("jsxTagStart", {
      startsExpr: !0
    }),
    jsxTagEnd: lt("jsxTagEnd")
  };
  function Ar(e) {
    return e >= 93 && e <= 133;
  }
  s(Ar, "tokenIsIdentifier");
  function V3e(e) {
    return e <= 92;
  }
  s(V3e, "tokenKeywordOrIdentifierIsKeyword");
  function Ga(e) {
    return e >= 58 && e <= 133;
  }
  s(Ga, "tokenIsKeywordOrIdentifier");
  function I9(e) {
    return e >= 58 && e <= 137;
  }
  s(I9, "tokenIsLiteralPropertyName");
  function K3e(e) {
    return DP[e];
  }
  s(K3e, "tokenComesBeforeExpression");
  function Ed(e) {
    return wP[e];
  }
  s(Ed, "tokenCanStartExpression");
  function H3e(e) {
    return e >= 29 && e <= 33;
  }
  s(H3e, "tokenIsAssignment");
  function S9(e) {
    return e >= 129 && e <= 131;
  }
  s(S9, "tokenIsFlowInterfaceOrTypeOrOpaque");
  function z3e(e) {
    return e >= 90 && e <= 92;
  }
  s(z3e, "tokenIsLoop");
  function kP(e) {
    return e >= 58 && e <= 92;
  }
  s(kP, "tokenIsKeyword");
  function G3e(e) {
    return e >= 39 && e <= 59;
  }
  s(G3e, "tokenIsOperator");
  function W3e(e) {
    return e === 34;
  }
  s(W3e, "tokenIsPostfix");
  function $3e(e) {
    return OP[e];
  }
  s($3e, "tokenIsPrefix");
  function X3e(e) {
    return e >= 121 && e <= 123;
  }
  s(X3e, "tokenIsTSTypeOperator");
  function Y3e(e) {
    return e >= 124 && e <= 130;
  }
  s(Y3e, "tokenIsTSDeclarationStart");
  function ml(e) {
    return CP[e];
  }
  s(ml, "tokenLabelName");
  function q_(e) {
    return PP[e];
  }
  s(q_, "tokenOperatorPrecedence");
  function J3e(e) {
    return e === 57;
  }
  s(J3e, "tokenIsRightAssociative");
  function V_(e) {
    return e >= 24 && e <= 25;
  }
  s(V_, "tokenIsTemplate");
  function vu(e) {
    return Su[e];
  }
  s(vu, "getExportedToken");
  Su[8].updateContext = (e) => {
    e.pop();
  }, Su[5].updateContext = Su[7].updateContext = Su[23].updateContext = (e) => {
    e.push(Er.brace);
  }, Su[22].updateContext = (e) => {
    e[e.length - 1] === Er.template ? e.pop() : e.push(Er.template);
  }, Su[143].updateContext = (e) => {
    e.push(Er.j_expr, Er.j_oTag);
  };
  var IP = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993\
-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\
\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\
\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\
\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\
\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CD\uA7D0\uA7D1\uA7D3\uA7D5-\uA7DC\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01\
-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC",
  R9 = "\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\
\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\
\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6\
-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20\
-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65", Q3e = new RegExp("[" + IP + "]"), Z3e = new RegExp("[" + IP + R9 + "]");
  IP = R9 = null;
  var N9 = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157,
  19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5,
  3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7,
  2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 2, 60, 28, 11, 0, 9, 21, 43, 17,
  47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64,
  6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45,
  52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2,
  1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29,
  113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071,
  18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 129, 74, 6, 0, 67, 12,
  65, 1, 2, 0, 29, 6135, 9, 1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991,
  84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30,
  2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3,
  0, 496, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2,
  2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153,
  7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191], eqe = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5,
  0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13,
  2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4,
  68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58,
  14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 343, 9, 54,
  7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350,
  0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543,
  4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6,
  10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 726, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
  function aP(e, t) {
    let r = 65536;
    for (let i = 0, n = t.length; i < n; i += 2) {
      if (r += t[i], r > e) return !1;
      if (r += t[i + 1], r >= e) return !0;
    }
    return !1;
  }
  s(aP, "isInAstralSet");
  function Tu(e) {
    return e < 65 ? e === 36 : e <= 90 ? !0 : e < 97 ? e === 95 : e <= 122 ? !0 : e <= 65535 ? e >= 170 && Q3e.test(String.fromCharCode(e)) :
    aP(e, N9);
  }
  s(Tu, "isIdentifierStart");
  function tp(e) {
    return e < 48 ? e === 36 : e < 58 ? !0 : e < 65 ? !1 : e <= 90 ? !0 : e < 97 ? e === 95 : e <= 122 ? !0 : e <= 65535 ? e >= 170 && Z3e.test(
    String.fromCharCode(e)) : aP(e, N9) || aP(e, eqe);
  }
  s(tp, "isIdentifierChar");
  var RP = {
    keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "swit\
ch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false",
    "in", "instanceof", "typeof", "void", "delete"],
    strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
    strictBind: ["eval", "arguments"]
  }, tqe = new Set(RP.keyword), rqe = new Set(RP.strict), iqe = new Set(RP.strictBind);
  function L9(e, t) {
    return t && e === "await" || e === "enum";
  }
  s(L9, "isReservedWord");
  function F9(e, t) {
    return L9(e, t) || rqe.has(e);
  }
  s(F9, "isStrictReservedWord");
  function M9(e) {
    return iqe.has(e);
  }
  s(M9, "isStrictBindOnlyReservedWord");
  function B9(e, t) {
    return F9(e, t) || M9(e);
  }
  s(B9, "isStrictBindReservedWord");
  function nqe(e) {
    return tqe.has(e);
  }
  s(nqe, "isKeyword");
  function sqe(e, t, r) {
    return e === 64 && t === 64 && Tu(r);
  }
  s(sqe, "isIteratorStart");
  var aqe = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function",
  "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import",
  "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protecte\
d", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
  function oqe(e) {
    return aqe.has(e);
  }
  s(oqe, "canBeReservedWord");
  var Cd = class {
    static {
      s(this, "Scope");
    }
    constructor(t) {
      this.flags = 0, this.names = /* @__PURE__ */ new Map(), this.firstLexicalName = "", this.flags = t;
    }
  }, Pd = class {
    static {
      s(this, "ScopeHandler");
    }
    constructor(t, r) {
      this.parser = void 0, this.scopeStack = [], this.inModule = void 0, this.undefinedExports = /* @__PURE__ */ new Map(), this.parser = t,
      this.inModule = r;
    }
    get inTopLevel() {
      return (this.currentScope().flags & 1) > 0;
    }
    get inFunction() {
      return (this.currentVarScopeFlags() & 2) > 0;
    }
    get allowSuper() {
      return (this.currentThisScopeFlags() & 16) > 0;
    }
    get allowDirectSuper() {
      return (this.currentThisScopeFlags() & 32) > 0;
    }
    get inClass() {
      return (this.currentThisScopeFlags() & 64) > 0;
    }
    get inClassAndNotInNonArrowFunction() {
      let t = this.currentThisScopeFlags();
      return (t & 64) > 0 && (t & 2) === 0;
    }
    get inStaticBlock() {
      for (let t = this.scopeStack.length - 1; ; t--) {
        let {
          flags: r
        } = this.scopeStack[t];
        if (r & 128)
          return !0;
        if (r & 451)
          return !1;
      }
    }
    get inNonArrowFunction() {
      return (this.currentThisScopeFlags() & 2) > 0;
    }
    get treatFunctionsAsVar() {
      return this.treatFunctionsAsVarInScope(this.currentScope());
    }
    createScope(t) {
      return new Cd(t);
    }
    enter(t) {
      this.scopeStack.push(this.createScope(t));
    }
    exit() {
      return this.scopeStack.pop().flags;
    }
    treatFunctionsAsVarInScope(t) {
      return !!(t.flags & 130 || !this.parser.inModule && t.flags & 1);
    }
    declareName(t, r, i) {
      let n = this.currentScope();
      if (r & 8 || r & 16) {
        this.checkRedeclarationInScope(n, t, r, i);
        let a = n.names.get(t) || 0;
        r & 16 ? a = a | 4 : (n.firstLexicalName || (n.firstLexicalName = t), a = a | 2), n.names.set(t, a), r & 8 && this.maybeExportDefined(
        n, t);
      } else if (r & 4)
        for (let a = this.scopeStack.length - 1; a >= 0 && (n = this.scopeStack[a], this.checkRedeclarationInScope(n, t, r, i), n.names.set(
        t, (n.names.get(t) || 0) | 1), this.maybeExportDefined(n, t), !(n.flags & 387)); --a)
          ;
      this.parser.inModule && n.flags & 1 && this.undefinedExports.delete(t);
    }
    maybeExportDefined(t, r) {
      this.parser.inModule && t.flags & 1 && this.undefinedExports.delete(r);
    }
    checkRedeclarationInScope(t, r, i, n) {
      this.isRedeclaredInScope(t, r, i) && this.parser.raise(Z.VarRedeclaration, n, {
        identifierName: r
      });
    }
    isRedeclaredInScope(t, r, i) {
      if (!(i & 1)) return !1;
      if (i & 8)
        return t.names.has(r);
      let n = t.names.get(r);
      return i & 16 ? (n & 2) > 0 || !this.treatFunctionsAsVarInScope(t) && (n & 1) > 0 : (n & 2) > 0 && !(t.flags & 8 && t.firstLexicalName ===
      r) || !this.treatFunctionsAsVarInScope(t) && (n & 4) > 0;
    }
    checkLocalExport(t) {
      let {
        name: r
      } = t;
      this.scopeStack[0].names.has(r) || this.undefinedExports.set(r, t.loc.start);
    }
    currentScope() {
      return this.scopeStack[this.scopeStack.length - 1];
    }
    currentVarScopeFlags() {
      for (let t = this.scopeStack.length - 1; ; t--) {
        let {
          flags: r
        } = this.scopeStack[t];
        if (r & 387)
          return r;
      }
    }
    currentThisScopeFlags() {
      for (let t = this.scopeStack.length - 1; ; t--) {
        let {
          flags: r
        } = this.scopeStack[t];
        if (r & 451 && !(r & 4))
          return r;
      }
    }
  }, oP = class extends Cd {
    static {
      s(this, "FlowScope");
    }
    constructor(...t) {
      super(...t), this.declareFunctions = /* @__PURE__ */ new Set();
    }
  }, uP = class extends Pd {
    static {
      s(this, "FlowScopeHandler");
    }
    createScope(t) {
      return new oP(t);
    }
    declareName(t, r, i) {
      let n = this.currentScope();
      if (r & 2048) {
        this.checkRedeclarationInScope(n, t, r, i), this.maybeExportDefined(n, t), n.declareFunctions.add(t);
        return;
      }
      super.declareName(t, r, i);
    }
    isRedeclaredInScope(t, r, i) {
      if (super.isRedeclaredInScope(t, r, i)) return !0;
      if (i & 2048 && !t.declareFunctions.has(r)) {
        let n = t.names.get(r);
        return (n & 4) > 0 || (n & 2) > 0;
      }
      return !1;
    }
    checkLocalExport(t) {
      this.scopeStack[0].declareFunctions.has(t.name) || super.checkLocalExport(t);
    }
  }, lP = class {
    static {
      s(this, "BaseParser");
    }
    constructor() {
      this.sawUnambiguousESM = !1, this.ambiguousScriptDifferentAst = !1;
    }
    sourceToOffsetPos(t) {
      return t + this.startIndex;
    }
    offsetToSourcePos(t) {
      return t - this.startIndex;
    }
    hasPlugin(t) {
      if (typeof t == "string")
        return this.plugins.has(t);
      {
        let [r, i] = t;
        if (!this.hasPlugin(r))
          return !1;
        let n = this.plugins.get(r);
        for (let a of Object.keys(i))
          if (n?.[a] !== i[a])
            return !1;
        return !0;
      }
    }
    getPluginOption(t, r) {
      var i;
      return (i = this.plugins.get(t)) == null ? void 0 : i[r];
    }
  };
  function q9(e, t) {
    e.trailingComments === void 0 ? e.trailingComments = t : e.trailingComments.unshift(...t);
  }
  s(q9, "setTrailingComments");
  function uqe(e, t) {
    e.leadingComments === void 0 ? e.leadingComments = t : e.leadingComments.unshift(...t);
  }
  s(uqe, "setLeadingComments");
  function Dd(e, t) {
    e.innerComments === void 0 ? e.innerComments = t : e.innerComments.unshift(...t);
  }
  s(Dd, "setInnerComments");
  function hc(e, t, r) {
    let i = null, n = t.length;
    for (; i === null && n > 0; )
      i = t[--n];
    i === null || i.start > r.start ? Dd(e, r.comments) : q9(i, r.comments);
  }
  s(hc, "adjustInnerComments");
  var cP = class extends lP {
    static {
      s(this, "CommentsParser");
    }
    addComment(t) {
      this.filename && (t.loc.filename = this.filename);
      let {
        commentsLen: r
      } = this.state;
      this.comments.length !== r && (this.comments.length = r), this.comments.push(t), this.state.commentsLen++;
    }
    processComment(t) {
      let {
        commentStack: r
      } = this.state, i = r.length;
      if (i === 0) return;
      let n = i - 1, a = r[n];
      a.start === t.end && (a.leadingNode = t, n--);
      let {
        start: o
      } = t;
      for (; n >= 0; n--) {
        let u = r[n], l = u.end;
        if (l > o)
          u.containingNode = t, this.finalizeComment(u), r.splice(n, 1);
        else {
          l === o && (u.trailingNode = t);
          break;
        }
      }
    }
    finalizeComment(t) {
      let {
        comments: r
      } = t;
      if (t.leadingNode !== null || t.trailingNode !== null)
        t.leadingNode !== null && q9(t.leadingNode, r), t.trailingNode !== null && uqe(t.trailingNode, r);
      else {
        let {
          containingNode: i,
          start: n
        } = t;
        if (this.input.charCodeAt(this.offsetToSourcePos(n) - 1) === 44)
          switch (i.type) {
            case "ObjectExpression":
            case "ObjectPattern":
            case "RecordExpression":
              hc(i, i.properties, t);
              break;
            case "CallExpression":
            case "OptionalCallExpression":
              hc(i, i.arguments, t);
              break;
            case "FunctionDeclaration":
            case "FunctionExpression":
            case "ArrowFunctionExpression":
            case "ObjectMethod":
            case "ClassMethod":
            case "ClassPrivateMethod":
              hc(i, i.params, t);
              break;
            case "ArrayExpression":
            case "ArrayPattern":
            case "TupleExpression":
              hc(i, i.elements, t);
              break;
            case "ExportNamedDeclaration":
            case "ImportDeclaration":
              hc(i, i.specifiers, t);
              break;
            case "TSEnumDeclaration":
              hc(i, i.members, t);
              break;
            case "TSEnumBody":
              hc(i, i.members, t);
              break;
            default:
              Dd(i, r);
          }
        else
          Dd(i, r);
      }
    }
    finalizeRemainingComments() {
      let {
        commentStack: t
      } = this.state;
      for (let r = t.length - 1; r >= 0; r--)
        this.finalizeComment(t[r]);
      this.state.commentStack = [];
    }
    resetPreviousNodeTrailingComments(t) {
      let {
        commentStack: r
      } = this.state, {
        length: i
      } = r;
      if (i === 0) return;
      let n = r[i - 1];
      n.leadingNode === t && (n.leadingNode = null);
    }
    resetPreviousIdentifierLeadingComments(t) {
      let {
        commentStack: r
      } = this.state, {
        length: i
      } = r;
      i !== 0 && (r[i - 1].trailingNode === t ? r[i - 1].trailingNode = null : i >= 2 && r[i - 2].trailingNode === t && (r[i - 2].trailingNode =
      null));
    }
    takeSurroundingComments(t, r, i) {
      let {
        commentStack: n
      } = this.state, a = n.length;
      if (a === 0) return;
      let o = a - 1;
      for (; o >= 0; o--) {
        let u = n[o], l = u.end;
        if (u.start === i)
          u.leadingNode = t;
        else if (l === r)
          u.trailingNode = t;
        else if (l < r)
          break;
      }
    }
  }, lqe = /\r\n|[\r\n\u2028\u2029]/, F_ = new RegExp(lqe.source, "g");
  function rp(e) {
    switch (e) {
      case 10:
      case 13:
      case 8232:
      case 8233:
        return !0;
      default:
        return !1;
    }
  }
  s(rp, "isNewLine");
  function T9(e, t, r) {
    for (let i = t; i < r; i++)
      if (rp(e.charCodeAt(i)))
        return !0;
    return !1;
  }
  s(T9, "hasNewLine");
  var rP = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, iP = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g;
  function cqe(e) {
    switch (e) {
      case 9:
      case 11:
      case 12:
      case 32:
      case 160:
      case 5760:
      case 8192:
      case 8193:
      case 8194:
      case 8195:
      case 8196:
      case 8197:
      case 8198:
      case 8199:
      case 8200:
      case 8201:
      case 8202:
      case 8239:
      case 8287:
      case 12288:
      case 65279:
        return !0;
      default:
        return !1;
    }
  }
  s(cqe, "isWhitespace");
  var fP = class e {
    static {
      s(this, "State");
    }
    constructor() {
      this.flags = 1024, this.startIndex = void 0, this.curLine = void 0, this.lineStart = void 0, this.startLoc = void 0, this.endLoc = void 0,
      this.errors = [], this.potentialArrowAt = -1, this.noArrowAt = [], this.noArrowParamsConversionAt = [], this.topicContext = {
        maxNumOfResolvableTopics: 0,
        maxTopicIndex: null
      }, this.labels = [], this.commentsLen = 0, this.commentStack = [], this.pos = 0, this.type = 140, this.value = null, this.start = 0, this.
      end = 0, this.lastTokEndLoc = null, this.lastTokStartLoc = null, this.context = [Er.brace], this.firstInvalidTemplateEscapePos = null,
      this.strictErrors = /* @__PURE__ */ new Map(), this.tokensLength = 0;
    }
    get strict() {
      return (this.flags & 1) > 0;
    }
    set strict(t) {
      t ? this.flags |= 1 : this.flags &= -2;
    }
    init({
      strictMode: t,
      sourceType: r,
      startIndex: i,
      startLine: n,
      startColumn: a
    }) {
      this.strict = t === !1 ? !1 : t === !0 ? !0 : r === "module", this.startIndex = i, this.curLine = n, this.lineStart = -a, this.startLoc =
      this.endLoc = new Lo(n, a, i);
    }
    get maybeInArrowParameters() {
      return (this.flags & 2) > 0;
    }
    set maybeInArrowParameters(t) {
      t ? this.flags |= 2 : this.flags &= -3;
    }
    get inType() {
      return (this.flags & 4) > 0;
    }
    set inType(t) {
      t ? this.flags |= 4 : this.flags &= -5;
    }
    get noAnonFunctionType() {
      return (this.flags & 8) > 0;
    }
    set noAnonFunctionType(t) {
      t ? this.flags |= 8 : this.flags &= -9;
    }
    get hasFlowComment() {
      return (this.flags & 16) > 0;
    }
    set hasFlowComment(t) {
      t ? this.flags |= 16 : this.flags &= -17;
    }
    get isAmbientContext() {
      return (this.flags & 32) > 0;
    }
    set isAmbientContext(t) {
      t ? this.flags |= 32 : this.flags &= -33;
    }
    get inAbstractClass() {
      return (this.flags & 64) > 0;
    }
    set inAbstractClass(t) {
      t ? this.flags |= 64 : this.flags &= -65;
    }
    get inDisallowConditionalTypesContext() {
      return (this.flags & 128) > 0;
    }
    set inDisallowConditionalTypesContext(t) {
      t ? this.flags |= 128 : this.flags &= -129;
    }
    get soloAwait() {
      return (this.flags & 256) > 0;
    }
    set soloAwait(t) {
      t ? this.flags |= 256 : this.flags &= -257;
    }
    get inFSharpPipelineDirectBody() {
      return (this.flags & 512) > 0;
    }
    set inFSharpPipelineDirectBody(t) {
      t ? this.flags |= 512 : this.flags &= -513;
    }
    get canStartJSXElement() {
      return (this.flags & 1024) > 0;
    }
    set canStartJSXElement(t) {
      t ? this.flags |= 1024 : this.flags &= -1025;
    }
    get containsEsc() {
      return (this.flags & 2048) > 0;
    }
    set containsEsc(t) {
      t ? this.flags |= 2048 : this.flags &= -2049;
    }
    get hasTopLevelAwait() {
      return (this.flags & 4096) > 0;
    }
    set hasTopLevelAwait(t) {
      t ? this.flags |= 4096 : this.flags &= -4097;
    }
    curPosition() {
      return new Lo(this.curLine, this.pos - this.lineStart, this.pos + this.startIndex);
    }
    clone() {
      let t = new e();
      return t.flags = this.flags, t.startIndex = this.startIndex, t.curLine = this.curLine, t.lineStart = this.lineStart, t.startLoc = this.
      startLoc, t.endLoc = this.endLoc, t.errors = this.errors.slice(), t.potentialArrowAt = this.potentialArrowAt, t.noArrowAt = this.noArrowAt.
      slice(), t.noArrowParamsConversionAt = this.noArrowParamsConversionAt.slice(), t.topicContext = this.topicContext, t.labels = this.labels.
      slice(), t.commentsLen = this.commentsLen, t.commentStack = this.commentStack.slice(), t.pos = this.pos, t.type = this.type, t.value =
      this.value, t.start = this.start, t.end = this.end, t.lastTokEndLoc = this.lastTokEndLoc, t.lastTokStartLoc = this.lastTokStartLoc, t.
      context = this.context.slice(), t.firstInvalidTemplateEscapePos = this.firstInvalidTemplateEscapePos, t.strictErrors = this.strictErrors,
      t.tokensLength = this.tokensLength, t;
    }
  }, fqe = /* @__PURE__ */ s(function(t) {
    return t >= 48 && t <= 57;
  }, "isDigit"), E9 = {
    decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]),
    hex: /* @__PURE__ */ new Set([46, 88, 95, 120])
  }, M_ = {
    bin: /* @__PURE__ */ s((e) => e === 48 || e === 49, "bin"),
    oct: /* @__PURE__ */ s((e) => e >= 48 && e <= 55, "oct"),
    dec: /* @__PURE__ */ s((e) => e >= 48 && e <= 57, "dec"),
    hex: /* @__PURE__ */ s((e) => e >= 48 && e <= 57 || e >= 65 && e <= 70 || e >= 97 && e <= 102, "hex")
  };
  function A9(e, t, r, i, n, a) {
    let o = r, u = i, l = n, c = "", p = null, h = r, {
      length: y
    } = t;
    for (; ; ) {
      if (r >= y) {
        a.unterminated(o, u, l), c += t.slice(h, r);
        break;
      }
      let _ = t.charCodeAt(r);
      if (pqe(e, _, t, r)) {
        c += t.slice(h, r);
        break;
      }
      if (_ === 92) {
        c += t.slice(h, r);
        let g = hqe(t, r, i, n, e === "template", a);
        g.ch === null && !p ? p = {
          pos: r,
          lineStart: i,
          curLine: n
        } : c += g.ch, {
          pos: r,
          lineStart: i,
          curLine: n
        } = g, h = r;
      } else _ === 8232 || _ === 8233 ? (++r, ++n, i = r) : _ === 10 || _ === 13 ? e === "template" ? (c += t.slice(h, r) + `
`, ++r, _ === 13 && t.charCodeAt(r) === 10 && ++r, ++n, h = i = r) : a.unterminated(o, u, l) : ++r;
    }
    return {
      pos: r,
      str: c,
      firstInvalidLoc: p,
      lineStart: i,
      curLine: n,
      containsInvalid: !!p
    };
  }
  s(A9, "readStringContents");
  function pqe(e, t, r, i) {
    return e === "template" ? t === 96 || t === 36 && r.charCodeAt(i + 1) === 123 : t === (e === "double" ? 34 : 39);
  }
  s(pqe, "isStringEnd");
  function hqe(e, t, r, i, n, a) {
    let o = !n;
    t++;
    let u = /* @__PURE__ */ s((c) => ({
      pos: t,
      ch: c,
      lineStart: r,
      curLine: i
    }), "res"), l = e.charCodeAt(t++);
    switch (l) {
      case 110:
        return u(`
`);
      case 114:
        return u("\r");
      case 120: {
        let c;
        return {
          code: c,
          pos: t
        } = pP(e, t, r, i, 2, !1, o, a), u(c === null ? null : String.fromCharCode(c));
      }
      case 117: {
        let c;
        return {
          code: c,
          pos: t
        } = j9(e, t, r, i, o, a), u(c === null ? null : String.fromCodePoint(c));
      }
      case 116:
        return u("	");
      case 98:
        return u("\b");
      case 118:
        return u("\v");
      case 102:
        return u("\f");
      case 13:
        e.charCodeAt(t) === 10 && ++t;
      case 10:
        r = t, ++i;
      case 8232:
      case 8233:
        return u("");
      case 56:
      case 57:
        if (n)
          return u(null);
        a.strictNumericEscape(t - 1, r, i);
      default:
        if (l >= 48 && l <= 55) {
          let c = t - 1, h = /^[0-7]+/.exec(e.slice(c, t + 2))[0], y = parseInt(h, 8);
          y > 255 && (h = h.slice(0, -1), y = parseInt(h, 8)), t += h.length - 1;
          let _ = e.charCodeAt(t);
          if (h !== "0" || _ === 56 || _ === 57) {
            if (n)
              return u(null);
            a.strictNumericEscape(c, r, i);
          }
          return u(String.fromCharCode(y));
        }
        return u(String.fromCharCode(l));
    }
  }
  s(hqe, "readEscapedChar");
  function pP(e, t, r, i, n, a, o, u) {
    let l = t, c;
    return {
      n: c,
      pos: t
    } = U9(e, t, r, i, 16, n, a, !1, u, !o), c === null && (o ? u.invalidEscapeSequence(l, r, i) : t = l - 1), {
      code: c,
      pos: t
    };
  }
  s(pP, "readHexChar");
  function U9(e, t, r, i, n, a, o, u, l, c) {
    let p = t, h = n === 16 ? E9.hex : E9.decBinOct, y = n === 16 ? M_.hex : n === 10 ? M_.dec : n === 8 ? M_.oct : M_.bin, _ = !1, g = 0;
    for (let m = 0, f = a ?? 1 / 0; m < f; ++m) {
      let d = e.charCodeAt(t), v;
      if (d === 95 && u !== "bail") {
        let E = e.charCodeAt(t - 1), S = e.charCodeAt(t + 1);
        if (u) {
          if (Number.isNaN(S) || !y(S) || h.has(E) || h.has(S)) {
            if (c) return {
              n: null,
              pos: t
            };
            l.unexpectedNumericSeparator(t, r, i);
          }
        } else {
          if (c) return {
            n: null,
            pos: t
          };
          l.numericSeparatorInEscapeSequence(t, r, i);
        }
        ++t;
        continue;
      }
      if (d >= 97 ? v = d - 97 + 10 : d >= 65 ? v = d - 65 + 10 : fqe(d) ? v = d - 48 : v = 1 / 0, v >= n) {
        if (v <= 9 && c)
          return {
            n: null,
            pos: t
          };
        if (v <= 9 && l.invalidDigit(t, r, i, n))
          v = 0;
        else if (o)
          v = 0, _ = !0;
        else
          break;
      }
      ++t, g = g * n + v;
    }
    return t === p || a != null && t - p !== a || _ ? {
      n: null,
      pos: t
    } : {
      n: g,
      pos: t
    };
  }
  s(U9, "readInt");
  function j9(e, t, r, i, n, a) {
    let o = e.charCodeAt(t), u;
    if (o === 123) {
      if (++t, {
        code: u,
        pos: t
      } = pP(e, t, r, i, e.indexOf("}", t) - t, !0, n, a), ++t, u !== null && u > 1114111)
        if (n)
          a.invalidCodePoint(t, r, i);
        else
          return {
            code: null,
            pos: t
          };
    } else
      ({
        code: u,
        pos: t
      } = pP(e, t, r, i, 4, !1, n, a));
    return {
      code: u,
      pos: t
    };
  }
  s(j9, "readCodePoint");
  function Td(e, t, r) {
    return new Lo(r, e - t, e);
  }
  s(Td, "buildPosition");
  var dqe = /* @__PURE__ */ new Set([103, 109, 115, 105, 121, 117, 100, 118]), No = class {
    static {
      s(this, "Token");
    }
    constructor(t) {
      let r = t.startIndex || 0;
      this.type = t.type, this.value = t.value, this.start = r + t.start, this.end = r + t.end, this.loc = new np(t.startLoc, t.endLoc);
    }
  }, hP = class extends cP {
    static {
      s(this, "Tokenizer");
    }
    constructor(t, r) {
      super(), this.isLookahead = void 0, this.tokens = [], this.errorHandlers_readInt = {
        invalidDigit: /* @__PURE__ */ s((i, n, a, o) => this.optionFlags & 2048 ? (this.raise(Z.InvalidDigit, Td(i, n, a), {
          radix: o
        }), !0) : !1, "invalidDigit"),
        numericSeparatorInEscapeSequence: this.errorBuilder(Z.NumericSeparatorInEscapeSequence),
        unexpectedNumericSeparator: this.errorBuilder(Z.UnexpectedNumericSeparator)
      }, this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, {
        invalidEscapeSequence: this.errorBuilder(Z.InvalidEscapeSequence),
        invalidCodePoint: this.errorBuilder(Z.InvalidCodePoint)
      }), this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, {
        strictNumericEscape: /* @__PURE__ */ s((i, n, a) => {
          this.recordStrictModeErrors(Z.StrictNumericEscape, Td(i, n, a));
        }, "strictNumericEscape"),
        unterminated: /* @__PURE__ */ s((i, n, a) => {
          throw this.raise(Z.UnterminatedString, Td(i - 1, n, a));
        }, "unterminated")
      }), this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, {
        strictNumericEscape: this.errorBuilder(Z.StrictNumericEscape),
        unterminated: /* @__PURE__ */ s((i, n, a) => {
          throw this.raise(Z.UnterminatedTemplate, Td(i, n, a));
        }, "unterminated")
      }), this.state = new fP(), this.state.init(t), this.input = r, this.length = r.length, this.comments = [], this.isLookahead = !1;
    }
    pushToken(t) {
      this.tokens.length = this.state.tokensLength, this.tokens.push(t), ++this.state.tokensLength;
    }
    next() {
      this.checkKeywordEscapes(), this.optionFlags & 256 && this.pushToken(new No(this.state)), this.state.lastTokEndLoc = this.state.endLoc,
      this.state.lastTokStartLoc = this.state.startLoc, this.nextToken();
    }
    eat(t) {
      return this.match(t) ? (this.next(), !0) : !1;
    }
    match(t) {
      return this.state.type === t;
    }
    createLookaheadState(t) {
      return {
        pos: t.pos,
        value: null,
        type: t.type,
        start: t.start,
        end: t.end,
        context: [this.curContext()],
        inType: t.inType,
        startLoc: t.startLoc,
        lastTokEndLoc: t.lastTokEndLoc,
        curLine: t.curLine,
        lineStart: t.lineStart,
        curPosition: t.curPosition
      };
    }
    lookahead() {
      let t = this.state;
      this.state = this.createLookaheadState(t), this.isLookahead = !0, this.nextToken(), this.isLookahead = !1;
      let r = this.state;
      return this.state = t, r;
    }
    nextTokenStart() {
      return this.nextTokenStartSince(this.state.pos);
    }
    nextTokenStartSince(t) {
      return rP.lastIndex = t, rP.test(this.input) ? rP.lastIndex : t;
    }
    lookaheadCharCode() {
      return this.input.charCodeAt(this.nextTokenStart());
    }
    nextTokenInLineStart() {
      return this.nextTokenInLineStartSince(this.state.pos);
    }
    nextTokenInLineStartSince(t) {
      return iP.lastIndex = t, iP.test(this.input) ? iP.lastIndex : t;
    }
    lookaheadInLineCharCode() {
      return this.input.charCodeAt(this.nextTokenInLineStart());
    }
    codePointAtPos(t) {
      let r = this.input.charCodeAt(t);
      if ((r & 64512) === 55296 && ++t < this.input.length) {
        let i = this.input.charCodeAt(t);
        (i & 64512) === 56320 && (r = 65536 + ((r & 1023) << 10) + (i & 1023));
      }
      return r;
    }
    setStrict(t) {
      this.state.strict = t, t && (this.state.strictErrors.forEach(([r, i]) => this.raise(r, i)), this.state.strictErrors.clear());
    }
    curContext() {
      return this.state.context[this.state.context.length - 1];
    }
    nextToken() {
      if (this.skipSpace(), this.state.start = this.state.pos, this.isLookahead || (this.state.startLoc = this.state.curPosition()), this.state.
      pos >= this.length) {
        this.finishToken(140);
        return;
      }
      this.getTokenFromCode(this.codePointAtPos(this.state.pos));
    }
    skipBlockComment(t) {
      let r;
      this.isLookahead || (r = this.state.curPosition());
      let i = this.state.pos, n = this.input.indexOf(t, i + 2);
      if (n === -1)
        throw this.raise(Z.UnterminatedComment, this.state.curPosition());
      for (this.state.pos = n + t.length, F_.lastIndex = i + 2; F_.test(this.input) && F_.lastIndex <= n; )
        ++this.state.curLine, this.state.lineStart = F_.lastIndex;
      if (this.isLookahead) return;
      let a = {
        type: "CommentBlock",
        value: this.input.slice(i + 2, n),
        start: this.sourceToOffsetPos(i),
        end: this.sourceToOffsetPos(n + t.length),
        loc: new np(r, this.state.curPosition())
      };
      return this.optionFlags & 256 && this.pushToken(a), a;
    }
    skipLineComment(t) {
      let r = this.state.pos, i;
      this.isLookahead || (i = this.state.curPosition());
      let n = this.input.charCodeAt(this.state.pos += t);
      if (this.state.pos < this.length)
        for (; !rp(n) && ++this.state.pos < this.length; )
          n = this.input.charCodeAt(this.state.pos);
      if (this.isLookahead) return;
      let a = this.state.pos, u = {
        type: "CommentLine",
        value: this.input.slice(r + t, a),
        start: this.sourceToOffsetPos(r),
        end: this.sourceToOffsetPos(a),
        loc: new np(i, this.state.curPosition())
      };
      return this.optionFlags & 256 && this.pushToken(u), u;
    }
    skipSpace() {
      let t = this.state.pos, r = this.optionFlags & 4096 ? [] : null;
      e: for (; this.state.pos < this.length; ) {
        let i = this.input.charCodeAt(this.state.pos);
        switch (i) {
          case 32:
          case 160:
          case 9:
            ++this.state.pos;
            break;
          case 13:
            this.input.charCodeAt(this.state.pos + 1) === 10 && ++this.state.pos;
          case 10:
          case 8232:
          case 8233:
            ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
            break;
          case 47:
            switch (this.input.charCodeAt(this.state.pos + 1)) {
              case 42: {
                let n = this.skipBlockComment("*/");
                n !== void 0 && (this.addComment(n), r?.push(n));
                break;
              }
              case 47: {
                let n = this.skipLineComment(2);
                n !== void 0 && (this.addComment(n), r?.push(n));
                break;
              }
              default:
                break e;
            }
            break;
          default:
            if (cqe(i))
              ++this.state.pos;
            else if (i === 45 && !this.inModule && this.optionFlags & 8192) {
              let n = this.state.pos;
              if (this.input.charCodeAt(n + 1) === 45 && this.input.charCodeAt(n + 2) === 62 && (t === 0 || this.state.lineStart > t)) {
                let a = this.skipLineComment(3);
                a !== void 0 && (this.addComment(a), r?.push(a));
              } else
                break e;
            } else if (i === 60 && !this.inModule && this.optionFlags & 8192) {
              let n = this.state.pos;
              if (this.input.charCodeAt(n + 1) === 33 && this.input.charCodeAt(n + 2) === 45 && this.input.charCodeAt(n + 3) === 45) {
                let a = this.skipLineComment(4);
                a !== void 0 && (this.addComment(a), r?.push(a));
              } else
                break e;
            } else
              break e;
        }
      }
      if (r?.length > 0) {
        let i = this.state.pos, n = {
          start: this.sourceToOffsetPos(t),
          end: this.sourceToOffsetPos(i),
          comments: r,
          leadingNode: null,
          trailingNode: null,
          containingNode: null
        };
        this.state.commentStack.push(n);
      }
    }
    finishToken(t, r) {
      this.state.end = this.state.pos, this.state.endLoc = this.state.curPosition();
      let i = this.state.type;
      this.state.type = t, this.state.value = r, this.isLookahead || this.updateContext(i);
    }
    replaceToken(t) {
      this.state.type = t, this.updateContext();
    }
    readToken_numberSign() {
      if (this.state.pos === 0 && this.readToken_interpreter())
        return;
      let t = this.state.pos + 1, r = this.codePointAtPos(t);
      if (r >= 48 && r <= 57)
        throw this.raise(Z.UnexpectedDigitAfterHash, this.state.curPosition());
      if (r === 123 || r === 91 && this.hasPlugin("recordAndTuple")) {
        if (this.expectPlugin("recordAndTuple"), this.getPluginOption("recordAndTuple", "syntaxType") === "bar")
          throw this.raise(r === 123 ? Z.RecordExpressionHashIncorrectStartSyntaxType : Z.TupleExpressionHashIncorrectStartSyntaxType, this.
          state.curPosition());
        this.state.pos += 2, r === 123 ? this.finishToken(7) : this.finishToken(1);
      } else Tu(r) ? (++this.state.pos, this.finishToken(139, this.readWord1(r))) : r === 92 ? (++this.state.pos, this.finishToken(139, this.
      readWord1())) : this.finishOp(27, 1);
    }
    readToken_dot() {
      let t = this.input.charCodeAt(this.state.pos + 1);
      if (t >= 48 && t <= 57) {
        this.readNumber(!0);
        return;
      }
      t === 46 && this.input.charCodeAt(this.state.pos + 2) === 46 ? (this.state.pos += 3, this.finishToken(21)) : (++this.state.pos, this.finishToken(
      16));
    }
    readToken_slash() {
      this.input.charCodeAt(this.state.pos + 1) === 61 ? this.finishOp(31, 2) : this.finishOp(56, 1);
    }
    readToken_interpreter() {
      if (this.state.pos !== 0 || this.length < 2) return !1;
      let t = this.input.charCodeAt(this.state.pos + 1);
      if (t !== 33) return !1;
      let r = this.state.pos;
      for (this.state.pos += 1; !rp(t) && ++this.state.pos < this.length; )
        t = this.input.charCodeAt(this.state.pos);
      let i = this.input.slice(r + 2, this.state.pos);
      return this.finishToken(28, i), !0;
    }
    readToken_mult_modulo(t) {
      let r = t === 42 ? 55 : 54, i = 1, n = this.input.charCodeAt(this.state.pos + 1);
      t === 42 && n === 42 && (i++, n = this.input.charCodeAt(this.state.pos + 2), r = 57), n === 61 && !this.state.inType && (i++, r = t ===
      37 ? 33 : 30), this.finishOp(r, i);
    }
    readToken_pipe_amp(t) {
      let r = this.input.charCodeAt(this.state.pos + 1);
      if (r === t) {
        this.input.charCodeAt(this.state.pos + 2) === 61 ? this.finishOp(30, 3) : this.finishOp(t === 124 ? 41 : 42, 2);
        return;
      }
      if (t === 124) {
        if (r === 62) {
          this.finishOp(39, 2);
          return;
        }
        if (this.hasPlugin("recordAndTuple") && r === 125) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
            throw this.raise(Z.RecordExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
          this.state.pos += 2, this.finishToken(9);
          return;
        }
        if (this.hasPlugin("recordAndTuple") && r === 93) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
            throw this.raise(Z.TupleExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
          this.state.pos += 2, this.finishToken(4);
          return;
        }
      }
      if (r === 61) {
        this.finishOp(30, 2);
        return;
      }
      this.finishOp(t === 124 ? 43 : 45, 1);
    }
    readToken_caret() {
      let t = this.input.charCodeAt(this.state.pos + 1);
      t === 61 && !this.state.inType ? this.finishOp(32, 2) : t === 94 && this.hasPlugin(["pipelineOperator", {
        proposal: "hack",
        topicToken: "^^"
      }]) ? (this.finishOp(37, 2), this.input.codePointAt(this.state.pos) === 94 && this.unexpected()) : this.finishOp(44, 1);
    }
    readToken_atSign() {
      this.input.charCodeAt(this.state.pos + 1) === 64 && this.hasPlugin(["pipelineOperator", {
        proposal: "hack",
        topicToken: "@@"
      }]) ? this.finishOp(38, 2) : this.finishOp(26, 1);
    }
    readToken_plus_min(t) {
      let r = this.input.charCodeAt(this.state.pos + 1);
      if (r === t) {
        this.finishOp(34, 2);
        return;
      }
      r === 61 ? this.finishOp(30, 2) : this.finishOp(53, 1);
    }
    readToken_lt() {
      let {
        pos: t
      } = this.state, r = this.input.charCodeAt(t + 1);
      if (r === 60) {
        if (this.input.charCodeAt(t + 2) === 61) {
          this.finishOp(30, 3);
          return;
        }
        this.finishOp(51, 2);
        return;
      }
      if (r === 61) {
        this.finishOp(49, 2);
        return;
      }
      this.finishOp(47, 1);
    }
    readToken_gt() {
      let {
        pos: t
      } = this.state, r = this.input.charCodeAt(t + 1);
      if (r === 62) {
        let i = this.input.charCodeAt(t + 2) === 62 ? 3 : 2;
        if (this.input.charCodeAt(t + i) === 61) {
          this.finishOp(30, i + 1);
          return;
        }
        this.finishOp(52, i);
        return;
      }
      if (r === 61) {
        this.finishOp(49, 2);
        return;
      }
      this.finishOp(48, 1);
    }
    readToken_eq_excl(t) {
      let r = this.input.charCodeAt(this.state.pos + 1);
      if (r === 61) {
        this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
        return;
      }
      if (t === 61 && r === 62) {
        this.state.pos += 2, this.finishToken(19);
        return;
      }
      this.finishOp(t === 61 ? 29 : 35, 1);
    }
    readToken_question() {
      let t = this.input.charCodeAt(this.state.pos + 1), r = this.input.charCodeAt(this.state.pos + 2);
      t === 63 ? r === 61 ? this.finishOp(30, 3) : this.finishOp(40, 2) : t === 46 && !(r >= 48 && r <= 57) ? (this.state.pos += 2, this.finishToken(
      18)) : (++this.state.pos, this.finishToken(17));
    }
    getTokenFromCode(t) {
      switch (t) {
        case 46:
          this.readToken_dot();
          return;
        case 40:
          ++this.state.pos, this.finishToken(10);
          return;
        case 41:
          ++this.state.pos, this.finishToken(11);
          return;
        case 59:
          ++this.state.pos, this.finishToken(13);
          return;
        case 44:
          ++this.state.pos, this.finishToken(12);
          return;
        case 91:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
              throw this.raise(Z.TupleExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
            this.state.pos += 2, this.finishToken(2);
          } else
            ++this.state.pos, this.finishToken(0);
          return;
        case 93:
          ++this.state.pos, this.finishToken(3);
          return;
        case 123:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
              throw this.raise(Z.RecordExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
            this.state.pos += 2, this.finishToken(6);
          } else
            ++this.state.pos, this.finishToken(5);
          return;
        case 125:
          ++this.state.pos, this.finishToken(8);
          return;
        case 58:
          this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58 ? this.finishOp(15, 2) : (++this.state.pos, this.
          finishToken(14));
          return;
        case 63:
          this.readToken_question();
          return;
        case 96:
          this.readTemplateToken();
          return;
        case 48: {
          let r = this.input.charCodeAt(this.state.pos + 1);
          if (r === 120 || r === 88) {
            this.readRadixNumber(16);
            return;
          }
          if (r === 111 || r === 79) {
            this.readRadixNumber(8);
            return;
          }
          if (r === 98 || r === 66) {
            this.readRadixNumber(2);
            return;
          }
        }
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          this.readNumber(!1);
          return;
        case 34:
        case 39:
          this.readString(t);
          return;
        case 47:
          this.readToken_slash();
          return;
        case 37:
        case 42:
          this.readToken_mult_modulo(t);
          return;
        case 124:
        case 38:
          this.readToken_pipe_amp(t);
          return;
        case 94:
          this.readToken_caret();
          return;
        case 43:
        case 45:
          this.readToken_plus_min(t);
          return;
        case 60:
          this.readToken_lt();
          return;
        case 62:
          this.readToken_gt();
          return;
        case 61:
        case 33:
          this.readToken_eq_excl(t);
          return;
        case 126:
          this.finishOp(36, 1);
          return;
        case 64:
          this.readToken_atSign();
          return;
        case 35:
          this.readToken_numberSign();
          return;
        case 92:
          this.readWord();
          return;
        default:
          if (Tu(t)) {
            this.readWord(t);
            return;
          }
      }
      throw this.raise(Z.InvalidOrUnexpectedToken, this.state.curPosition(), {
        unexpected: String.fromCodePoint(t)
      });
    }
    finishOp(t, r) {
      let i = this.input.slice(this.state.pos, this.state.pos + r);
      this.state.pos += r, this.finishToken(t, i);
    }
    readRegexp() {
      let t = this.state.startLoc, r = this.state.start + 1, i, n, {
        pos: a
      } = this.state;
      for (; ; ++a) {
        if (a >= this.length)
          throw this.raise(Z.UnterminatedRegExp, ms(t, 1));
        let c = this.input.charCodeAt(a);
        if (rp(c))
          throw this.raise(Z.UnterminatedRegExp, ms(t, 1));
        if (i)
          i = !1;
        else {
          if (c === 91)
            n = !0;
          else if (c === 93 && n)
            n = !1;
          else if (c === 47 && !n)
            break;
          i = c === 92;
        }
      }
      let o = this.input.slice(r, a);
      ++a;
      let u = "", l = /* @__PURE__ */ s(() => ms(t, a + 2 - r), "nextPos");
      for (; a < this.length; ) {
        let c = this.codePointAtPos(a), p = String.fromCharCode(c);
        if (dqe.has(c))
          c === 118 ? u.includes("u") && this.raise(Z.IncompatibleRegExpUVFlags, l()) : c === 117 && u.includes("v") && this.raise(Z.IncompatibleRegExpUVFlags,
          l()), u.includes(p) && this.raise(Z.DuplicateRegExpFlags, l());
        else if (tp(c) || c === 92)
          this.raise(Z.MalformedRegExpFlags, l());
        else
          break;
        ++a, u += p;
      }
      this.state.pos = a, this.finishToken(138, {
        pattern: o,
        flags: u
      });
    }
    readInt(t, r, i = !1, n = !0) {
      let {
        n: a,
        pos: o
      } = U9(this.input, this.state.pos, this.state.lineStart, this.state.curLine, t, r, i, n, this.errorHandlers_readInt, !1);
      return this.state.pos = o, a;
    }
    readRadixNumber(t) {
      let r = this.state.pos, i = this.state.curPosition(), n = !1;
      this.state.pos += 2;
      let a = this.readInt(t);
      a == null && this.raise(Z.InvalidDigit, ms(i, 2), {
        radix: t
      });
      let o = this.input.charCodeAt(this.state.pos);
      if (o === 110)
        ++this.state.pos, n = !0;
      else if (o === 109)
        throw this.raise(Z.InvalidDecimal, i);
      if (Tu(this.codePointAtPos(this.state.pos)))
        throw this.raise(Z.NumberIdentifier, this.state.curPosition());
      if (n) {
        let u = this.input.slice(r, this.state.pos).replace(/[_n]/g, "");
        this.finishToken(136, u);
        return;
      }
      this.finishToken(135, a);
    }
    readNumber(t) {
      let r = this.state.pos, i = this.state.curPosition(), n = !1, a = !1, o = !1, u = !1;
      !t && this.readInt(10) === null && this.raise(Z.InvalidNumber, this.state.curPosition());
      let l = this.state.pos - r >= 2 && this.input.charCodeAt(r) === 48;
      if (l) {
        let _ = this.input.slice(r, this.state.pos);
        if (this.recordStrictModeErrors(Z.StrictOctalLiteral, i), !this.state.strict) {
          let g = _.indexOf("_");
          g > 0 && this.raise(Z.ZeroDigitNumericSeparator, ms(i, g));
        }
        u = l && !/[89]/.test(_);
      }
      let c = this.input.charCodeAt(this.state.pos);
      if (c === 46 && !u && (++this.state.pos, this.readInt(10), n = !0, c = this.input.charCodeAt(this.state.pos)), (c === 69 || c === 101) &&
      !u && (c = this.input.charCodeAt(++this.state.pos), (c === 43 || c === 45) && ++this.state.pos, this.readInt(10) === null && this.raise(
      Z.InvalidOrMissingExponent, i), n = !0, o = !0, c = this.input.charCodeAt(this.state.pos)), c === 110 && ((n || l) && this.raise(Z.InvalidBigIntLiteral,
      i), ++this.state.pos, a = !0), c === 109) {
        this.expectPlugin("decimal", this.state.curPosition()), (o || l) && this.raise(Z.InvalidDecimal, i), ++this.state.pos;
        var p = !0;
      }
      if (Tu(this.codePointAtPos(this.state.pos)))
        throw this.raise(Z.NumberIdentifier, this.state.curPosition());
      let h = this.input.slice(r, this.state.pos).replace(/[_mn]/g, "");
      if (a) {
        this.finishToken(136, h);
        return;
      }
      if (p) {
        this.finishToken(137, h);
        return;
      }
      let y = u ? parseInt(h, 8) : parseFloat(h);
      this.finishToken(135, y);
    }
    readCodePoint(t) {
      let {
        code: r,
        pos: i
      } = j9(this.input, this.state.pos, this.state.lineStart, this.state.curLine, t, this.errorHandlers_readCodePoint);
      return this.state.pos = i, r;
    }
    readString(t) {
      let {
        str: r,
        pos: i,
        curLine: n,
        lineStart: a
      } = A9(t === 34 ? "double" : "single", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);
      this.state.pos = i + 1, this.state.lineStart = a, this.state.curLine = n, this.finishToken(134, r);
    }
    readTemplateContinuation() {
      this.match(8) || this.unexpected(null, 8), this.state.pos--, this.readTemplateToken();
    }
    readTemplateToken() {
      let t = this.input[this.state.pos], {
        str: r,
        firstInvalidLoc: i,
        pos: n,
        curLine: a,
        lineStart: o
      } = A9("template", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);
      this.state.pos = n + 1, this.state.lineStart = o, this.state.curLine = a, i && (this.state.firstInvalidTemplateEscapePos = new Lo(i.curLine,
      i.pos - i.lineStart, this.sourceToOffsetPos(i.pos))), this.input.codePointAt(n) === 96 ? this.finishToken(24, i ? null : t + r + "`") :
      (this.state.pos++, this.finishToken(25, i ? null : t + r + "${"));
    }
    recordStrictModeErrors(t, r) {
      let i = r.index;
      this.state.strict && !this.state.strictErrors.has(i) ? this.raise(t, r) : this.state.strictErrors.set(i, [t, r]);
    }
    readWord1(t) {
      this.state.containsEsc = !1;
      let r = "", i = this.state.pos, n = this.state.pos;
      for (t !== void 0 && (this.state.pos += t <= 65535 ? 1 : 2); this.state.pos < this.length; ) {
        let a = this.codePointAtPos(this.state.pos);
        if (tp(a))
          this.state.pos += a <= 65535 ? 1 : 2;
        else if (a === 92) {
          this.state.containsEsc = !0, r += this.input.slice(n, this.state.pos);
          let o = this.state.curPosition(), u = this.state.pos === i ? Tu : tp;
          if (this.input.charCodeAt(++this.state.pos) !== 117) {
            this.raise(Z.MissingUnicodeEscape, this.state.curPosition()), n = this.state.pos - 1;
            continue;
          }
          ++this.state.pos;
          let l = this.readCodePoint(!0);
          l !== null && (u(l) || this.raise(Z.EscapedCharNotAnIdentifier, o), r += String.fromCodePoint(l)), n = this.state.pos;
        } else
          break;
      }
      return r + this.input.slice(n, this.state.pos);
    }
    readWord(t) {
      let r = this.readWord1(t), i = xP.get(r);
      i !== void 0 ? this.finishToken(i, ml(i)) : this.finishToken(132, r);
    }
    checkKeywordEscapes() {
      let {
        type: t
      } = this.state;
      kP(t) && this.state.containsEsc && this.raise(Z.InvalidEscapedReservedWord, this.state.startLoc, {
        reservedWord: ml(t)
      });
    }
    raise(t, r, i = {}) {
      let n = r instanceof Lo ? r : r.loc.start, a = t(n, i);
      if (!(this.optionFlags & 2048)) throw a;
      return this.isLookahead || this.state.errors.push(a), a;
    }
    raiseOverwrite(t, r, i = {}) {
      let n = r instanceof Lo ? r : r.loc.start, a = n.index, o = this.state.errors;
      for (let u = o.length - 1; u >= 0; u--) {
        let l = o[u];
        if (l.loc.index === a)
          return o[u] = t(n, i);
        if (l.loc.index < a) break;
      }
      return this.raise(t, r, i);
    }
    updateContext(t) {
    }
    unexpected(t, r) {
      throw this.raise(Z.UnexpectedToken, t ?? this.state.startLoc, {
        expected: r ? ml(r) : null
      });
    }
    expectPlugin(t, r) {
      if (this.hasPlugin(t))
        return !0;
      throw this.raise(Z.MissingPlugin, r ?? this.state.startLoc, {
        missingPlugin: [t]
      });
    }
    expectOnePlugin(t) {
      if (!t.some((r) => this.hasPlugin(r)))
        throw this.raise(Z.MissingOneOfPlugins, this.state.startLoc, {
          missingPlugin: t
        });
    }
    errorBuilder(t) {
      return (r, i, n) => {
        this.raise(t, Td(r, i, n));
      };
    }
  }, dP = class {
    static {
      s(this, "ClassScope");
    }
    constructor() {
      this.privateNames = /* @__PURE__ */ new Set(), this.loneAccessors = /* @__PURE__ */ new Map(), this.undefinedPrivateNames = /* @__PURE__ */ new Map();
    }
  }, mP = class {
    static {
      s(this, "ClassScopeHandler");
    }
    constructor(t) {
      this.parser = void 0, this.stack = [], this.undefinedPrivateNames = /* @__PURE__ */ new Map(), this.parser = t;
    }
    current() {
      return this.stack[this.stack.length - 1];
    }
    enter() {
      this.stack.push(new dP());
    }
    exit() {
      let t = this.stack.pop(), r = this.current();
      for (let [i, n] of Array.from(t.undefinedPrivateNames))
        r ? r.undefinedPrivateNames.has(i) || r.undefinedPrivateNames.set(i, n) : this.parser.raise(Z.InvalidPrivateFieldResolution, n, {
          identifierName: i
        });
    }
    declarePrivateName(t, r, i) {
      let {
        privateNames: n,
        loneAccessors: a,
        undefinedPrivateNames: o
      } = this.current(), u = n.has(t);
      if (r & 3) {
        let l = u && a.get(t);
        if (l) {
          let c = l & 4, p = r & 4, h = l & 3, y = r & 3;
          u = h === y || c !== p, u || a.delete(t);
        } else u || a.set(t, r);
      }
      u && this.parser.raise(Z.PrivateNameRedeclaration, i, {
        identifierName: t
      }), n.add(t), o.delete(t);
    }
    usePrivateName(t, r) {
      let i;
      for (i of this.stack)
        if (i.privateNames.has(t)) return;
      i ? i.undefinedPrivateNames.set(t, r) : this.parser.raise(Z.InvalidPrivateFieldResolution, r, {
        identifierName: t
      });
    }
  }, sp = class {
    static {
      s(this, "ExpressionScope");
    }
    constructor(t = 0) {
      this.type = t;
    }
    canBeArrowParameterDeclaration() {
      return this.type === 2 || this.type === 1;
    }
    isCertainlyParameterDeclaration() {
      return this.type === 3;
    }
  }, K_ = class extends sp {
    static {
      s(this, "ArrowHeadParsingScope");
    }
    constructor(t) {
      super(t), this.declarationErrors = /* @__PURE__ */ new Map();
    }
    recordDeclarationError(t, r) {
      let i = r.index;
      this.declarationErrors.set(i, [t, r]);
    }
    clearDeclarationError(t) {
      this.declarationErrors.delete(t);
    }
    iterateErrors(t) {
      this.declarationErrors.forEach(t);
    }
  }, yP = class {
    static {
      s(this, "ExpressionScopeHandler");
    }
    constructor(t) {
      this.parser = void 0, this.stack = [new sp()], this.parser = t;
    }
    enter(t) {
      this.stack.push(t);
    }
    exit() {
      this.stack.pop();
    }
    recordParameterInitializerError(t, r) {
      let i = r.loc.start, {
        stack: n
      } = this, a = n.length - 1, o = n[a];
      for (; !o.isCertainlyParameterDeclaration(); ) {
        if (o.canBeArrowParameterDeclaration())
          o.recordDeclarationError(t, i);
        else
          return;
        o = n[--a];
      }
      this.parser.raise(t, i);
    }
    recordArrowParameterBindingError(t, r) {
      let {
        stack: i
      } = this, n = i[i.length - 1], a = r.loc.start;
      if (n.isCertainlyParameterDeclaration())
        this.parser.raise(t, a);
      else if (n.canBeArrowParameterDeclaration())
        n.recordDeclarationError(t, a);
      else
        return;
    }
    recordAsyncArrowParametersError(t) {
      let {
        stack: r
      } = this, i = r.length - 1, n = r[i];
      for (; n.canBeArrowParameterDeclaration(); )
        n.type === 2 && n.recordDeclarationError(Z.AwaitBindingIdentifier, t), n = r[--i];
    }
    validateAsPattern() {
      let {
        stack: t
      } = this, r = t[t.length - 1];
      r.canBeArrowParameterDeclaration() && r.iterateErrors(([i, n]) => {
        this.parser.raise(i, n);
        let a = t.length - 2, o = t[a];
        for (; o.canBeArrowParameterDeclaration(); )
          o.clearDeclarationError(n.index), o = t[--a];
      });
    }
  };
  function mqe() {
    return new sp(3);
  }
  s(mqe, "newParameterDeclarationScope");
  function yqe() {
    return new K_(1);
  }
  s(yqe, "newArrowHeadScope");
  function gqe() {
    return new K_(2);
  }
  s(gqe, "newAsyncArrowScope");
  function V9() {
    return new sp();
  }
  s(V9, "newExpressionScope");
  var gP = class {
    static {
      s(this, "ProductionParameterHandler");
    }
    constructor() {
      this.stacks = [];
    }
    enter(t) {
      this.stacks.push(t);
    }
    exit() {
      this.stacks.pop();
    }
    currentFlags() {
      return this.stacks[this.stacks.length - 1];
    }
    get hasAwait() {
      return (this.currentFlags() & 2) > 0;
    }
    get hasYield() {
      return (this.currentFlags() & 1) > 0;
    }
    get hasReturn() {
      return (this.currentFlags() & 4) > 0;
    }
    get hasIn() {
      return (this.currentFlags() & 8) > 0;
    }
  };
  function U_(e, t) {
    return (e ? 2 : 0) | (t ? 1 : 0);
  }
  s(U_, "functionFlags");
  var _P = class extends hP {
    static {
      s(this, "UtilParser");
    }
    addExtra(t, r, i, n = !0) {
      if (!t) return;
      let {
        extra: a
      } = t;
      a == null && (a = {}, t.extra = a), n ? a[r] = i : Object.defineProperty(a, r, {
        enumerable: n,
        value: i
      });
    }
    isContextual(t) {
      return this.state.type === t && !this.state.containsEsc;
    }
    isUnparsedContextual(t, r) {
      let i = t + r.length;
      if (this.input.slice(t, i) === r) {
        let n = this.input.charCodeAt(i);
        return !(tp(n) || (n & 64512) === 55296);
      }
      return !1;
    }
    isLookaheadContextual(t) {
      let r = this.nextTokenStart();
      return this.isUnparsedContextual(r, t);
    }
    eatContextual(t) {
      return this.isContextual(t) ? (this.next(), !0) : !1;
    }
    expectContextual(t, r) {
      if (!this.eatContextual(t)) {
        if (r != null)
          throw this.raise(r, this.state.startLoc);
        this.unexpected(null, t);
      }
    }
    canInsertSemicolon() {
      return this.match(140) || this.match(8) || this.hasPrecedingLineBreak();
    }
    hasPrecedingLineBreak() {
      return T9(this.input, this.offsetToSourcePos(this.state.lastTokEndLoc.index), this.state.start);
    }
    hasFollowingLineBreak() {
      return T9(this.input, this.state.end, this.nextTokenStart());
    }
    isLineTerminator() {
      return this.eat(13) || this.canInsertSemicolon();
    }
    semicolon(t = !0) {
      (t ? this.isLineTerminator() : this.eat(13)) || this.raise(Z.MissingSemicolon, this.state.lastTokEndLoc);
    }
    expect(t, r) {
      this.eat(t) || this.unexpected(r, t);
    }
    tryParse(t, r = this.state.clone()) {
      let i = {
        node: null
      };
      try {
        let n = t((a = null) => {
          throw i.node = a, i;
        });
        if (this.state.errors.length > r.errors.length) {
          let a = this.state;
          return this.state = r, this.state.tokensLength = a.tokensLength, {
            node: n,
            error: a.errors[r.errors.length],
            thrown: !1,
            aborted: !1,
            failState: a
          };
        }
        return {
          node: n,
          error: null,
          thrown: !1,
          aborted: !1,
          failState: null
        };
      } catch (n) {
        let a = this.state;
        if (this.state = r, n instanceof SyntaxError)
          return {
            node: null,
            error: n,
            thrown: !0,
            aborted: !1,
            failState: a
          };
        if (n === i)
          return {
            node: i.node,
            error: null,
            thrown: !1,
            aborted: !0,
            failState: a
          };
        throw n;
      }
    }
    checkExpressionErrors(t, r) {
      if (!t) return !1;
      let {
        shorthandAssignLoc: i,
        doubleProtoLoc: n,
        privateKeyLoc: a,
        optionalParametersLoc: o
      } = t, u = !!i || !!n || !!o || !!a;
      if (!r)
        return u;
      i != null && this.raise(Z.InvalidCoverInitializedName, i), n != null && this.raise(Z.DuplicateProto, n), a != null && this.raise(Z.UnexpectedPrivateField,
      a), o != null && this.unexpected(o);
    }
    isLiteralPropertyName() {
      return I9(this.state.type);
    }
    isPrivateName(t) {
      return t.type === "PrivateName";
    }
    getPrivateNameSV(t) {
      return t.id.name;
    }
    hasPropertyAsPrivateName(t) {
      return (t.type === "MemberExpression" || t.type === "OptionalMemberExpression") && this.isPrivateName(t.property);
    }
    isObjectProperty(t) {
      return t.type === "ObjectProperty";
    }
    isObjectMethod(t) {
      return t.type === "ObjectMethod";
    }
    initializeScopes(t = this.options.sourceType === "module") {
      let r = this.state.labels;
      this.state.labels = [];
      let i = this.exportedIdentifiers;
      this.exportedIdentifiers = /* @__PURE__ */ new Set();
      let n = this.inModule;
      this.inModule = t;
      let a = this.scope, o = this.getScopeHandler();
      this.scope = new o(this, t);
      let u = this.prodParam;
      this.prodParam = new gP();
      let l = this.classScope;
      this.classScope = new mP(this);
      let c = this.expressionScope;
      return this.expressionScope = new yP(this), () => {
        this.state.labels = r, this.exportedIdentifiers = i, this.inModule = n, this.scope = a, this.prodParam = u, this.classScope = l, this.
        expressionScope = c;
      };
    }
    enterInitialScopes() {
      let t = 0;
      this.inModule && (t |= 2), this.optionFlags & 32 && (t |= 1), this.scope.enter(1), this.prodParam.enter(t);
    }
    checkDestructuringPrivate(t) {
      let {
        privateKeyLoc: r
      } = t;
      r !== null && this.expectPlugin("destructuringPrivate", r);
    }
  }, ip = class {
    static {
      s(this, "ExpressionErrors");
    }
    constructor() {
      this.shorthandAssignLoc = null, this.doubleProtoLoc = null, this.privateKeyLoc = null, this.optionalParametersLoc = null;
    }
  }, ap = class {
    static {
      s(this, "Node");
    }
    constructor(t, r, i) {
      this.type = "", this.start = r, this.end = 0, this.loc = new np(i), t?.optionFlags & 128 && (this.range = [r, 0]), t != null && t.filename &&
      (this.loc.filename = t.filename);
    }
  }, NP = ap.prototype;
  NP.__clone = function() {
    let e = new ap(void 0, this.start, this.loc.start), t = Object.keys(this);
    for (let r = 0, i = t.length; r < i; r++) {
      let n = t[r];
      n !== "leadingComments" && n !== "trailingComments" && n !== "innerComments" && (e[n] = this[n]);
    }
    return e;
  };
  function _qe(e) {
    return Au(e);
  }
  s(_qe, "clonePlaceholder");
  function Au(e) {
    let {
      type: t,
      start: r,
      end: i,
      loc: n,
      range: a,
      extra: o,
      name: u
    } = e, l = Object.create(NP);
    return l.type = t, l.start = r, l.end = i, l.loc = n, l.range = a, l.extra = o, l.name = u, t === "Placeholder" && (l.expectedNode = e.expectedNode),
    l;
  }
  s(Au, "cloneIdentifier");
  function bqe(e) {
    let {
      type: t,
      start: r,
      end: i,
      loc: n,
      range: a,
      extra: o
    } = e;
    if (t === "Placeholder")
      return _qe(e);
    let u = Object.create(NP);
    return u.type = t, u.start = r, u.end = i, u.loc = n, u.range = a, e.raw !== void 0 ? u.raw = e.raw : u.extra = o, u.value = e.value, u;
  }
  s(bqe, "cloneStringLiteral");
  var bP = class extends _P {
    static {
      s(this, "NodeUtils");
    }
    startNode() {
      let t = this.state.startLoc;
      return new ap(this, t.index, t);
    }
    startNodeAt(t) {
      return new ap(this, t.index, t);
    }
    startNodeAtNode(t) {
      return this.startNodeAt(t.loc.start);
    }
    finishNode(t, r) {
      return this.finishNodeAt(t, r, this.state.lastTokEndLoc);
    }
    finishNodeAt(t, r, i) {
      return t.type = r, t.end = i.index, t.loc.end = i, this.optionFlags & 128 && (t.range[1] = i.index), this.optionFlags & 4096 && this.processComment(
      t), t;
    }
    resetStartLocation(t, r) {
      t.start = r.index, t.loc.start = r, this.optionFlags & 128 && (t.range[0] = r.index);
    }
    resetEndLocation(t, r = this.state.lastTokEndLoc) {
      t.end = r.index, t.loc.end = r, this.optionFlags & 128 && (t.range[1] = r.index);
    }
    resetStartLocationFromNode(t, r) {
      this.resetStartLocation(t, r.loc.start);
    }
  }, vqe = /* @__PURE__ */ new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "sta\
tic", "string", "true", "typeof", "void"]), mt = Eu`flow`({
    AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",
    AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since \
they are either an ES module or they are a CommonJS module.",
    AssignReservedType: /* @__PURE__ */ s(({
      reservedType: e
    }) => `Cannot overwrite reserved type ${e}.`, "AssignReservedType"),
    DeclareClassElement: "The `declare` modifier can only appear on class fields.",
    DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.",
    DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.",
    EnumBooleanMemberNotInitialized: /* @__PURE__ */ s(({
      memberName: e,
      enumName: t
    }) => `Boolean enum members need to be initialized. Use either \`${e} = true,\` or \`${e} = false,\` in enum \`${t}\`.`, "EnumBooleanMem\
berNotInitialized"),
    EnumDuplicateMemberName: /* @__PURE__ */ s(({
      memberName: e,
      enumName: t
    }) => `Enum member names need to be unique, but the name \`${e}\` has already been used before in enum \`${t}\`.`, "EnumDuplicateMemberN\
ame"),
    EnumInconsistentMemberValues: /* @__PURE__ */ s(({
      enumName: e
    }) => `Enum \`${e}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, num\
bers, or strings) for all member initializers.`, "EnumInconsistentMemberValues"),
    EnumInvalidExplicitType: /* @__PURE__ */ s(({
      invalidEnumType: e,
      enumName: t
    }) => `Enum type \`${e}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${t}\`.`, "EnumInvalidEx\
plicitType"),
    EnumInvalidExplicitTypeUnknownSupplied: /* @__PURE__ */ s(({
      enumName: e
    }) => `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${e}\`.`, "EnumInvalidEx\
plicitTypeUnknownSupplied"),
    EnumInvalidMemberInitializerPrimaryType: /* @__PURE__ */ s(({
      enumName: e,
      memberName: t,
      explicitType: r
    }) => `Enum \`${e}\` has type \`${r}\`, so the initializer of \`${t}\` needs to be a ${r} literal.`, "EnumInvalidMemberInitializerPrimar\
yType"),
    EnumInvalidMemberInitializerSymbolType: /* @__PURE__ */ s(({
      enumName: e,
      memberName: t
    }) => `Symbol enum members cannot be initialized. Use \`${t},\` in enum \`${e}\`.`, "EnumInvalidMemberInitializerSymbolType"),
    EnumInvalidMemberInitializerUnknownType: /* @__PURE__ */ s(({
      enumName: e,
      memberName: t
    }) => `The enum member initializer for \`${t}\` needs to be a literal (either a boolean, number, or string) in enum \`${e}\`.`, "EnumInv\
alidMemberInitializerUnknownType"),
    EnumInvalidMemberName: /* @__PURE__ */ s(({
      enumName: e,
      memberName: t,
      suggestion: r
    }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${t}\`, consider using \`${r}\`, in enum \`${e}\
\`.`, "EnumInvalidMemberName"),
    EnumNumberMemberNotInitialized: /* @__PURE__ */ s(({
      enumName: e,
      memberName: t
    }) => `Number enum members need to be initialized, e.g. \`${t} = 1\` in enum \`${e}\`.`, "EnumNumberMemberNotInitialized"),
    EnumStringMemberInconsistentlyInitialized: /* @__PURE__ */ s(({
      enumName: e
    }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${e}\`.`, "EnumStringMemb\
erInconsistentlyInitialized"),
    GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.",
    ImportReflectionHasImportType: "An `import module` declaration can not use `type` or `typeof` keyword.",
    ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements.\
 It cannot be used with `import type` or `import typeof` statements.",
    InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.",
    InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.",
    InexactVariance: "Explicit inexact syntax cannot have variance.",
    InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.",
    MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",
    NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.",
    NestedFlowComment: "Cannot have a flow comment inside another flow comment.",
    PatternIsOptional: Object.assign({
      message: "A binding pattern parameter cannot be optional in an implementation signature."
    }, {
      reasonCode: "OptionalBindingPattern"
    }),
    SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.",
    SpreadVariance: "Spread properties cannot have variance.",
    ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.",
    ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.",
    ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.",
    ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.",
    ThisParamNoDefault: "The `this` parameter may not have a default value.",
    TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`\
.",
    TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.",
    UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.",
    UnexpectedReservedType: /* @__PURE__ */ s(({
      reservedType: e
    }) => `Unexpected reserved type ${e}.`, "UnexpectedReservedType"),
    UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.",
    UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.",
    UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.",
    UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".',
    UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.",
    UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}\
`, use `async <T>() => {}`.",
    UnsupportedDeclareExportKind: /* @__PURE__ */ s(({
      unsupportedExportKind: e,
      suggestion: t
    }) => `\`declare export ${e}\` is not supported. Use \`${t}\` instead.`, "UnsupportedDeclareExportKind"),
    UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.",
    UnterminatedFlowComment: "Unterminated flow-comment."
  });
  function Sqe(e) {
    return e.type === "DeclareExportAllDeclaration" || e.type === "DeclareExportDeclaration" && (!e.declaration || e.declaration.type !== "T\
ypeAlias" && e.declaration.type !== "InterfaceDeclaration");
  }
  s(Sqe, "isEsModuleType");
  function x9(e) {
    return e.importKind === "type" || e.importKind === "typeof";
  }
  s(x9, "hasTypeImportKind");
  var Tqe = {
    const: "declare export var",
    let: "declare export var",
    type: "export type",
    interface: "export interface"
  };
  function Eqe(e, t) {
    let r = [], i = [];
    for (let n = 0; n < e.length; n++)
      (t(e[n], n, e) ? r : i).push(e[n]);
    return [r, i];
  }
  s(Eqe, "partition");
  var Aqe = /\*?\s*@((?:no)?flow)\b/, xqe = /* @__PURE__ */ s((e) => class extends e {
    static {
      s(this, "FlowParserMixin");
    }
    constructor(...r) {
      super(...r), this.flowPragma = void 0;
    }
    getScopeHandler() {
      return uP;
    }
    shouldParseTypes() {
      return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
    }
    finishToken(r, i) {
      r !== 134 && r !== 13 && r !== 28 && this.flowPragma === void 0 && (this.flowPragma = null), super.finishToken(r, i);
    }
    addComment(r) {
      if (this.flowPragma === void 0) {
        let i = Aqe.exec(r.value);
        if (i) if (i[1] === "flow")
          this.flowPragma = "flow";
        else if (i[1] === "noflow")
          this.flowPragma = "noflow";
        else
          throw new Error("Unexpected flow pragma");
      }
      super.addComment(r);
    }
    flowParseTypeInitialiser(r) {
      let i = this.state.inType;
      this.state.inType = !0, this.expect(r || 14);
      let n = this.flowParseType();
      return this.state.inType = i, n;
    }
    flowParsePredicate() {
      let r = this.startNode(), i = this.state.startLoc;
      return this.next(), this.expectContextual(110), this.state.lastTokStartLoc.index > i.index + 1 && this.raise(mt.UnexpectedSpaceBetweenModuloChecks,
      i), this.eat(10) ? (r.value = super.parseExpression(), this.expect(11), this.finishNode(r, "DeclaredPredicate")) : this.finishNode(r, "\
InferredPredicate");
    }
    flowParseTypeAndPredicateInitialiser() {
      let r = this.state.inType;
      this.state.inType = !0, this.expect(14);
      let i = null, n = null;
      return this.match(54) ? (this.state.inType = r, n = this.flowParsePredicate()) : (i = this.flowParseType(), this.state.inType = r, this.
      match(54) && (n = this.flowParsePredicate())), [i, n];
    }
    flowParseDeclareClass(r) {
      return this.next(), this.flowParseInterfaceish(r, !0), this.finishNode(r, "DeclareClass");
    }
    flowParseDeclareFunction(r) {
      this.next();
      let i = r.id = this.parseIdentifier(), n = this.startNode(), a = this.startNode();
      this.match(47) ? n.typeParameters = this.flowParseTypeParameterDeclaration() : n.typeParameters = null, this.expect(10);
      let o = this.flowParseFunctionTypeParams();
      return n.params = o.params, n.rest = o.rest, n.this = o._this, this.expect(11), [n.returnType, r.predicate] = this.flowParseTypeAndPredicateInitialiser(),
      a.typeAnnotation = this.finishNode(n, "FunctionTypeAnnotation"), i.typeAnnotation = this.finishNode(a, "TypeAnnotation"), this.resetEndLocation(
      i), this.semicolon(), this.scope.declareName(r.id.name, 2048, r.id.loc.start), this.finishNode(r, "DeclareFunction");
    }
    flowParseDeclare(r, i) {
      if (this.match(80))
        return this.flowParseDeclareClass(r);
      if (this.match(68))
        return this.flowParseDeclareFunction(r);
      if (this.match(74))
        return this.flowParseDeclareVariable(r);
      if (this.eatContextual(127))
        return this.match(16) ? this.flowParseDeclareModuleExports(r) : (i && this.raise(mt.NestedDeclareModule, this.state.lastTokStartLoc),
        this.flowParseDeclareModule(r));
      if (this.isContextual(130))
        return this.flowParseDeclareTypeAlias(r);
      if (this.isContextual(131))
        return this.flowParseDeclareOpaqueType(r);
      if (this.isContextual(129))
        return this.flowParseDeclareInterface(r);
      if (this.match(82))
        return this.flowParseDeclareExportDeclaration(r, i);
      this.unexpected();
    }
    flowParseDeclareVariable(r) {
      return this.next(), r.id = this.flowParseTypeAnnotatableIdentifier(!0), this.scope.declareName(r.id.name, 5, r.id.loc.start), this.semicolon(),
      this.finishNode(r, "DeclareVariable");
    }
    flowParseDeclareModule(r) {
      this.scope.enter(0), this.match(134) ? r.id = super.parseExprAtom() : r.id = this.parseIdentifier();
      let i = r.body = this.startNode(), n = i.body = [];
      for (this.expect(5); !this.match(8); ) {
        let u = this.startNode();
        this.match(83) ? (this.next(), !this.isContextual(130) && !this.match(87) && this.raise(mt.InvalidNonTypeImportInDeclareModule, this.
        state.lastTokStartLoc), super.parseImport(u)) : (this.expectContextual(125, mt.UnsupportedStatementInDeclareModule), u = this.flowParseDeclare(
        u, !0)), n.push(u);
      }
      this.scope.exit(), this.expect(8), this.finishNode(i, "BlockStatement");
      let a = null, o = !1;
      return n.forEach((u) => {
        Sqe(u) ? (a === "CommonJS" && this.raise(mt.AmbiguousDeclareModuleKind, u), a = "ES") : u.type === "DeclareModuleExports" && (o && this.
        raise(mt.DuplicateDeclareModuleExports, u), a === "ES" && this.raise(mt.AmbiguousDeclareModuleKind, u), a = "CommonJS", o = !0);
      }), r.kind = a || "CommonJS", this.finishNode(r, "DeclareModule");
    }
    flowParseDeclareExportDeclaration(r, i) {
      if (this.expect(82), this.eat(65))
        return this.match(68) || this.match(80) ? r.declaration = this.flowParseDeclare(this.startNode()) : (r.declaration = this.flowParseType(),
        this.semicolon()), r.default = !0, this.finishNode(r, "DeclareExportDeclaration");
      if (this.match(75) || this.isLet() || (this.isContextual(130) || this.isContextual(129)) && !i) {
        let n = this.state.value;
        throw this.raise(mt.UnsupportedDeclareExportKind, this.state.startLoc, {
          unsupportedExportKind: n,
          suggestion: Tqe[n]
        });
      }
      if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(131))
        return r.declaration = this.flowParseDeclare(this.startNode()), r.default = !1, this.finishNode(r, "DeclareExportDeclaration");
      if (this.match(55) || this.match(5) || this.isContextual(129) || this.isContextual(130) || this.isContextual(131))
        return r = this.parseExport(r, null), r.type === "ExportNamedDeclaration" && (r.type = "ExportDeclaration", r.default = !1, delete r.
        exportKind), r.type = "Declare" + r.type, r;
      this.unexpected();
    }
    flowParseDeclareModuleExports(r) {
      return this.next(), this.expectContextual(111), r.typeAnnotation = this.flowParseTypeAnnotation(), this.semicolon(), this.finishNode(r,
      "DeclareModuleExports");
    }
    flowParseDeclareTypeAlias(r) {
      this.next();
      let i = this.flowParseTypeAlias(r);
      return i.type = "DeclareTypeAlias", i;
    }
    flowParseDeclareOpaqueType(r) {
      this.next();
      let i = this.flowParseOpaqueType(r, !0);
      return i.type = "DeclareOpaqueType", i;
    }
    flowParseDeclareInterface(r) {
      return this.next(), this.flowParseInterfaceish(r, !1), this.finishNode(r, "DeclareInterface");
    }
    flowParseInterfaceish(r, i) {
      if (r.id = this.flowParseRestrictedIdentifier(!i, !0), this.scope.declareName(r.id.name, i ? 17 : 8201, r.id.loc.start), this.match(47) ?
      r.typeParameters = this.flowParseTypeParameterDeclaration() : r.typeParameters = null, r.extends = [], this.eat(81))
        do
          r.extends.push(this.flowParseInterfaceExtends());
        while (!i && this.eat(12));
      if (i) {
        if (r.implements = [], r.mixins = [], this.eatContextual(117))
          do
            r.mixins.push(this.flowParseInterfaceExtends());
          while (this.eat(12));
        if (this.eatContextual(113))
          do
            r.implements.push(this.flowParseInterfaceExtends());
          while (this.eat(12));
      }
      r.body = this.flowParseObjectType({
        allowStatic: i,
        allowExact: !1,
        allowSpread: !1,
        allowProto: i,
        allowInexact: !1
      });
    }
    flowParseInterfaceExtends() {
      let r = this.startNode();
      return r.id = this.flowParseQualifiedTypeIdentifier(), this.match(47) ? r.typeParameters = this.flowParseTypeParameterInstantiation() :
      r.typeParameters = null, this.finishNode(r, "InterfaceExtends");
    }
    flowParseInterface(r) {
      return this.flowParseInterfaceish(r, !1), this.finishNode(r, "InterfaceDeclaration");
    }
    checkNotUnderscore(r) {
      r === "_" && this.raise(mt.UnexpectedReservedUnderscore, this.state.startLoc);
    }
    checkReservedType(r, i, n) {
      vqe.has(r) && this.raise(n ? mt.AssignReservedType : mt.UnexpectedReservedType, i, {
        reservedType: r
      });
    }
    flowParseRestrictedIdentifier(r, i) {
      return this.checkReservedType(this.state.value, this.state.startLoc, i), this.parseIdentifier(r);
    }
    flowParseTypeAlias(r) {
      return r.id = this.flowParseRestrictedIdentifier(!1, !0), this.scope.declareName(r.id.name, 8201, r.id.loc.start), this.match(47) ? r.
      typeParameters = this.flowParseTypeParameterDeclaration() : r.typeParameters = null, r.right = this.flowParseTypeInitialiser(29), this.
      semicolon(), this.finishNode(r, "TypeAlias");
    }
    flowParseOpaqueType(r, i) {
      return this.expectContextual(130), r.id = this.flowParseRestrictedIdentifier(!0, !0), this.scope.declareName(r.id.name, 8201, r.id.loc.
      start), this.match(47) ? r.typeParameters = this.flowParseTypeParameterDeclaration() : r.typeParameters = null, r.supertype = null, this.
      match(14) && (r.supertype = this.flowParseTypeInitialiser(14)), r.impltype = null, i || (r.impltype = this.flowParseTypeInitialiser(29)),
      this.semicolon(), this.finishNode(r, "OpaqueType");
    }
    flowParseTypeParameter(r = !1) {
      let i = this.state.startLoc, n = this.startNode(), a = this.flowParseVariance(), o = this.flowParseTypeAnnotatableIdentifier();
      return n.name = o.name, n.variance = a, n.bound = o.typeAnnotation, this.match(29) ? (this.eat(29), n.default = this.flowParseType()) :
      r && this.raise(mt.MissingTypeParamDefault, i), this.finishNode(n, "TypeParameter");
    }
    flowParseTypeParameterDeclaration() {
      let r = this.state.inType, i = this.startNode();
      i.params = [], this.state.inType = !0, this.match(47) || this.match(143) ? this.next() : this.unexpected();
      let n = !1;
      do {
        let a = this.flowParseTypeParameter(n);
        i.params.push(a), a.default && (n = !0), this.match(48) || this.expect(12);
      } while (!this.match(48));
      return this.expect(48), this.state.inType = r, this.finishNode(i, "TypeParameterDeclaration");
    }
    flowInTopLevelContext(r) {
      if (this.curContext() !== Er.brace) {
        let i = this.state.context;
        this.state.context = [i[0]];
        try {
          return r();
        } finally {
          this.state.context = i;
        }
      } else
        return r();
    }
    flowParseTypeParameterInstantiationInExpression() {
      if (this.reScan_lt() === 47)
        return this.flowParseTypeParameterInstantiation();
    }
    flowParseTypeParameterInstantiation() {
      let r = this.startNode(), i = this.state.inType;
      return this.state.inType = !0, r.params = [], this.flowInTopLevelContext(() => {
        this.expect(47);
        let n = this.state.noAnonFunctionType;
        for (this.state.noAnonFunctionType = !1; !this.match(48); )
          r.params.push(this.flowParseType()), this.match(48) || this.expect(12);
        this.state.noAnonFunctionType = n;
      }), this.state.inType = i, !this.state.inType && this.curContext() === Er.brace && this.reScan_lt_gt(), this.expect(48), this.finishNode(
      r, "TypeParameterInstantiation");
    }
    flowParseTypeParameterInstantiationCallOrNew() {
      if (this.reScan_lt() !== 47) return;
      let r = this.startNode(), i = this.state.inType;
      for (r.params = [], this.state.inType = !0, this.expect(47); !this.match(48); )
        r.params.push(this.flowParseTypeOrImplicitInstantiation()), this.match(48) || this.expect(12);
      return this.expect(48), this.state.inType = i, this.finishNode(r, "TypeParameterInstantiation");
    }
    flowParseInterfaceType() {
      let r = this.startNode();
      if (this.expectContextual(129), r.extends = [], this.eat(81))
        do
          r.extends.push(this.flowParseInterfaceExtends());
        while (this.eat(12));
      return r.body = this.flowParseObjectType({
        allowStatic: !1,
        allowExact: !1,
        allowSpread: !1,
        allowProto: !1,
        allowInexact: !1
      }), this.finishNode(r, "InterfaceTypeAnnotation");
    }
    flowParseObjectPropertyKey() {
      return this.match(135) || this.match(134) ? super.parseExprAtom() : this.parseIdentifier(!0);
    }
    flowParseObjectTypeIndexer(r, i, n) {
      return r.static = i, this.lookahead().type === 14 ? (r.id = this.flowParseObjectPropertyKey(), r.key = this.flowParseTypeInitialiser()) :
      (r.id = null, r.key = this.flowParseType()), this.expect(3), r.value = this.flowParseTypeInitialiser(), r.variance = n, this.finishNode(
      r, "ObjectTypeIndexer");
    }
    flowParseObjectTypeInternalSlot(r, i) {
      return r.static = i, r.id = this.flowParseObjectPropertyKey(), this.expect(3), this.expect(3), this.match(47) || this.match(10) ? (r.method =
      !0, r.optional = !1, r.value = this.flowParseObjectTypeMethodish(this.startNodeAt(r.loc.start))) : (r.method = !1, this.eat(17) && (r.
      optional = !0), r.value = this.flowParseTypeInitialiser()), this.finishNode(r, "ObjectTypeInternalSlot");
    }
    flowParseObjectTypeMethodish(r) {
      for (r.params = [], r.rest = null, r.typeParameters = null, r.this = null, this.match(47) && (r.typeParameters = this.flowParseTypeParameterDeclaration()),
      this.expect(10), this.match(78) && (r.this = this.flowParseFunctionTypeParam(!0), r.this.name = null, this.match(11) || this.expect(12)); !this.
      match(11) && !this.match(21); )
        r.params.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
      return this.eat(21) && (r.rest = this.flowParseFunctionTypeParam(!1)), this.expect(11), r.returnType = this.flowParseTypeInitialiser(),
      this.finishNode(r, "FunctionTypeAnnotation");
    }
    flowParseObjectTypeCallProperty(r, i) {
      let n = this.startNode();
      return r.static = i, r.value = this.flowParseObjectTypeMethodish(n), this.finishNode(r, "ObjectTypeCallProperty");
    }
    flowParseObjectType({
      allowStatic: r,
      allowExact: i,
      allowSpread: n,
      allowProto: a,
      allowInexact: o
    }) {
      let u = this.state.inType;
      this.state.inType = !0;
      let l = this.startNode();
      l.callProperties = [], l.properties = [], l.indexers = [], l.internalSlots = [];
      let c, p, h = !1;
      for (i && this.match(6) ? (this.expect(6), c = 9, p = !0) : (this.expect(5), c = 8, p = !1), l.exact = p; !this.match(c); ) {
        let _ = !1, g = null, m = null, f = this.startNode();
        if (a && this.isContextual(118)) {
          let v = this.lookahead();
          v.type !== 14 && v.type !== 17 && (this.next(), g = this.state.startLoc, r = !1);
        }
        if (r && this.isContextual(106)) {
          let v = this.lookahead();
          v.type !== 14 && v.type !== 17 && (this.next(), _ = !0);
        }
        let d = this.flowParseVariance();
        if (this.eat(0))
          g != null && this.unexpected(g), this.eat(0) ? (d && this.unexpected(d.loc.start), l.internalSlots.push(this.flowParseObjectTypeInternalSlot(
          f, _))) : l.indexers.push(this.flowParseObjectTypeIndexer(f, _, d));
        else if (this.match(10) || this.match(47))
          g != null && this.unexpected(g), d && this.unexpected(d.loc.start), l.callProperties.push(this.flowParseObjectTypeCallProperty(f, _));
        else {
          let v = "init";
          if (this.isContextual(99) || this.isContextual(104)) {
            let S = this.lookahead();
            I9(S.type) && (v = this.state.value, this.next());
          }
          let E = this.flowParseObjectTypeProperty(f, _, g, d, v, n, o ?? !p);
          E === null ? (h = !0, m = this.state.lastTokStartLoc) : l.properties.push(E);
        }
        this.flowObjectTypeSemicolon(), m && !this.match(8) && !this.match(9) && this.raise(mt.UnexpectedExplicitInexactInObject, m);
      }
      this.expect(c), n && (l.inexact = h);
      let y = this.finishNode(l, "ObjectTypeAnnotation");
      return this.state.inType = u, y;
    }
    flowParseObjectTypeProperty(r, i, n, a, o, u, l) {
      if (this.eat(21))
        return this.match(12) || this.match(13) || this.match(8) || this.match(9) ? (u ? l || this.raise(mt.InexactInsideExact, this.state.lastTokStartLoc) :
        this.raise(mt.InexactInsideNonObject, this.state.lastTokStartLoc), a && this.raise(mt.InexactVariance, a), null) : (u || this.raise(
        mt.UnexpectedSpreadType, this.state.lastTokStartLoc), n != null && this.unexpected(n), a && this.raise(mt.SpreadVariance, a), r.argument =
        this.flowParseType(), this.finishNode(r, "ObjectTypeSpreadProperty"));
      {
        r.key = this.flowParseObjectPropertyKey(), r.static = i, r.proto = n != null, r.kind = o;
        let c = !1;
        return this.match(47) || this.match(10) ? (r.method = !0, n != null && this.unexpected(n), a && this.unexpected(a.loc.start), r.value =
        this.flowParseObjectTypeMethodish(this.startNodeAt(r.loc.start)), (o === "get" || o === "set") && this.flowCheckGetterSetterParams(r),
        !u && r.key.name === "constructor" && r.value.this && this.raise(mt.ThisParamBannedInConstructor, r.value.this)) : (o !== "init" && this.
        unexpected(), r.method = !1, this.eat(17) && (c = !0), r.value = this.flowParseTypeInitialiser(), r.variance = a), r.optional = c, this.
        finishNode(r, "ObjectTypeProperty");
      }
    }
    flowCheckGetterSetterParams(r) {
      let i = r.kind === "get" ? 0 : 1, n = r.value.params.length + (r.value.rest ? 1 : 0);
      r.value.this && this.raise(r.kind === "get" ? mt.GetterMayNotHaveThisParam : mt.SetterMayNotHaveThisParam, r.value.this), n !== i && this.
      raise(r.kind === "get" ? Z.BadGetterArity : Z.BadSetterArity, r), r.kind === "set" && r.value.rest && this.raise(Z.BadSetterRestParameter,
      r);
    }
    flowObjectTypeSemicolon() {
      !this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9) && this.unexpected();
    }
    flowParseQualifiedTypeIdentifier(r, i) {
      r ?? (r = this.state.startLoc);
      let n = i || this.flowParseRestrictedIdentifier(!0);
      for (; this.eat(16); ) {
        let a = this.startNodeAt(r);
        a.qualification = n, a.id = this.flowParseRestrictedIdentifier(!0), n = this.finishNode(a, "QualifiedTypeIdentifier");
      }
      return n;
    }
    flowParseGenericType(r, i) {
      let n = this.startNodeAt(r);
      return n.typeParameters = null, n.id = this.flowParseQualifiedTypeIdentifier(r, i), this.match(47) && (n.typeParameters = this.flowParseTypeParameterInstantiation()),
      this.finishNode(n, "GenericTypeAnnotation");
    }
    flowParseTypeofType() {
      let r = this.startNode();
      return this.expect(87), r.argument = this.flowParsePrimaryType(), this.finishNode(r, "TypeofTypeAnnotation");
    }
    flowParseTupleType() {
      let r = this.startNode();
      for (r.types = [], this.expect(0); this.state.pos < this.length && !this.match(3) && (r.types.push(this.flowParseType()), !this.match(
      3)); )
        this.expect(12);
      return this.expect(3), this.finishNode(r, "TupleTypeAnnotation");
    }
    flowParseFunctionTypeParam(r) {
      let i = null, n = !1, a = null, o = this.startNode(), u = this.lookahead(), l = this.state.type === 78;
      return u.type === 14 || u.type === 17 ? (l && !r && this.raise(mt.ThisParamMustBeFirst, o), i = this.parseIdentifier(l), this.eat(17) &&
      (n = !0, l && this.raise(mt.ThisParamMayNotBeOptional, o)), a = this.flowParseTypeInitialiser()) : a = this.flowParseType(), o.name = i,
      o.optional = n, o.typeAnnotation = a, this.finishNode(o, "FunctionTypeParam");
    }
    reinterpretTypeAsFunctionTypeParam(r) {
      let i = this.startNodeAt(r.loc.start);
      return i.name = null, i.optional = !1, i.typeAnnotation = r, this.finishNode(i, "FunctionTypeParam");
    }
    flowParseFunctionTypeParams(r = []) {
      let i = null, n = null;
      for (this.match(78) && (n = this.flowParseFunctionTypeParam(!0), n.name = null, this.match(11) || this.expect(12)); !this.match(11) &&
      !this.match(21); )
        r.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
      return this.eat(21) && (i = this.flowParseFunctionTypeParam(!1)), {
        params: r,
        rest: i,
        _this: n
      };
    }
    flowIdentToTypeAnnotation(r, i, n) {
      switch (n.name) {
        case "any":
          return this.finishNode(i, "AnyTypeAnnotation");
        case "bool":
        case "boolean":
          return this.finishNode(i, "BooleanTypeAnnotation");
        case "mixed":
          return this.finishNode(i, "MixedTypeAnnotation");
        case "empty":
          return this.finishNode(i, "EmptyTypeAnnotation");
        case "number":
          return this.finishNode(i, "NumberTypeAnnotation");
        case "string":
          return this.finishNode(i, "StringTypeAnnotation");
        case "symbol":
          return this.finishNode(i, "SymbolTypeAnnotation");
        default:
          return this.checkNotUnderscore(n.name), this.flowParseGenericType(r, n);
      }
    }
    flowParsePrimaryType() {
      let r = this.state.startLoc, i = this.startNode(), n, a, o = !1, u = this.state.noAnonFunctionType;
      switch (this.state.type) {
        case 5:
          return this.flowParseObjectType({
            allowStatic: !1,
            allowExact: !1,
            allowSpread: !0,
            allowProto: !1,
            allowInexact: !0
          });
        case 6:
          return this.flowParseObjectType({
            allowStatic: !1,
            allowExact: !0,
            allowSpread: !0,
            allowProto: !1,
            allowInexact: !1
          });
        case 0:
          return this.state.noAnonFunctionType = !1, a = this.flowParseTupleType(), this.state.noAnonFunctionType = u, a;
        case 47: {
          let l = this.startNode();
          return l.typeParameters = this.flowParseTypeParameterDeclaration(), this.expect(10), n = this.flowParseFunctionTypeParams(), l.params =
          n.params, l.rest = n.rest, l.this = n._this, this.expect(11), this.expect(19), l.returnType = this.flowParseType(), this.finishNode(
          l, "FunctionTypeAnnotation");
        }
        case 10: {
          let l = this.startNode();
          if (this.next(), !this.match(11) && !this.match(21))
            if (Ar(this.state.type) || this.match(78)) {
              let c = this.lookahead().type;
              o = c !== 17 && c !== 14;
            } else
              o = !0;
          if (o) {
            if (this.state.noAnonFunctionType = !1, a = this.flowParseType(), this.state.noAnonFunctionType = u, this.state.noAnonFunctionType ||
            !(this.match(12) || this.match(11) && this.lookahead().type === 19))
              return this.expect(11), a;
            this.eat(12);
          }
          return a ? n = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(a)]) : n = this.flowParseFunctionTypeParams(),
          l.params = n.params, l.rest = n.rest, l.this = n._this, this.expect(11), this.expect(19), l.returnType = this.flowParseType(), l.typeParameters =
          null, this.finishNode(l, "FunctionTypeAnnotation");
        }
        case 134:
          return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
        case 85:
        case 86:
          return i.value = this.match(85), this.next(), this.finishNode(i, "BooleanLiteralTypeAnnotation");
        case 53:
          if (this.state.value === "-") {
            if (this.next(), this.match(135))
              return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", i);
            if (this.match(136))
              return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", i);
            throw this.raise(mt.UnexpectedSubtractionOperand, this.state.startLoc);
          }
          this.unexpected();
          return;
        case 135:
          return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
        case 136:
          return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
        case 88:
          return this.next(), this.finishNode(i, "VoidTypeAnnotation");
        case 84:
          return this.next(), this.finishNode(i, "NullLiteralTypeAnnotation");
        case 78:
          return this.next(), this.finishNode(i, "ThisTypeAnnotation");
        case 55:
          return this.next(), this.finishNode(i, "ExistsTypeAnnotation");
        case 87:
          return this.flowParseTypeofType();
        default:
          if (kP(this.state.type)) {
            let l = ml(this.state.type);
            return this.next(), super.createIdentifier(i, l);
          } else if (Ar(this.state.type))
            return this.isContextual(129) ? this.flowParseInterfaceType() : this.flowIdentToTypeAnnotation(r, i, this.parseIdentifier());
      }
      this.unexpected();
    }
    flowParsePostfixType() {
      let r = this.state.startLoc, i = this.flowParsePrimaryType(), n = !1;
      for (; (this.match(0) || this.match(18)) && !this.canInsertSemicolon(); ) {
        let a = this.startNodeAt(r), o = this.eat(18);
        n = n || o, this.expect(0), !o && this.match(3) ? (a.elementType = i, this.next(), i = this.finishNode(a, "ArrayTypeAnnotation")) : (a.
        objectType = i, a.indexType = this.flowParseType(), this.expect(3), n ? (a.optional = o, i = this.finishNode(a, "OptionalIndexedAcce\
ssType")) : i = this.finishNode(a, "IndexedAccessType"));
      }
      return i;
    }
    flowParsePrefixType() {
      let r = this.startNode();
      return this.eat(17) ? (r.typeAnnotation = this.flowParsePrefixType(), this.finishNode(r, "NullableTypeAnnotation")) : this.flowParsePostfixType();
    }
    flowParseAnonFunctionWithoutParens() {
      let r = this.flowParsePrefixType();
      if (!this.state.noAnonFunctionType && this.eat(19)) {
        let i = this.startNodeAt(r.loc.start);
        return i.params = [this.reinterpretTypeAsFunctionTypeParam(r)], i.rest = null, i.this = null, i.returnType = this.flowParseType(), i.
        typeParameters = null, this.finishNode(i, "FunctionTypeAnnotation");
      }
      return r;
    }
    flowParseIntersectionType() {
      let r = this.startNode();
      this.eat(45);
      let i = this.flowParseAnonFunctionWithoutParens();
      for (r.types = [i]; this.eat(45); )
        r.types.push(this.flowParseAnonFunctionWithoutParens());
      return r.types.length === 1 ? i : this.finishNode(r, "IntersectionTypeAnnotation");
    }
    flowParseUnionType() {
      let r = this.startNode();
      this.eat(43);
      let i = this.flowParseIntersectionType();
      for (r.types = [i]; this.eat(43); )
        r.types.push(this.flowParseIntersectionType());
      return r.types.length === 1 ? i : this.finishNode(r, "UnionTypeAnnotation");
    }
    flowParseType() {
      let r = this.state.inType;
      this.state.inType = !0;
      let i = this.flowParseUnionType();
      return this.state.inType = r, i;
    }
    flowParseTypeOrImplicitInstantiation() {
      if (this.state.type === 132 && this.state.value === "_") {
        let r = this.state.startLoc, i = this.parseIdentifier();
        return this.flowParseGenericType(r, i);
      } else
        return this.flowParseType();
    }
    flowParseTypeAnnotation() {
      let r = this.startNode();
      return r.typeAnnotation = this.flowParseTypeInitialiser(), this.finishNode(r, "TypeAnnotation");
    }
    flowParseTypeAnnotatableIdentifier(r) {
      let i = r ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
      return this.match(14) && (i.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(i)), i;
    }
    typeCastToParameter(r) {
      return r.expression.typeAnnotation = r.typeAnnotation, this.resetEndLocation(r.expression, r.typeAnnotation.loc.end), r.expression;
    }
    flowParseVariance() {
      let r = null;
      return this.match(53) ? (r = this.startNode(), this.state.value === "+" ? r.kind = "plus" : r.kind = "minus", this.next(), this.finishNode(
      r, "Variance")) : r;
    }
    parseFunctionBody(r, i, n = !1) {
      if (i) {
        this.forwardNoArrowParamsConversionAt(r, () => super.parseFunctionBody(r, !0, n));
        return;
      }
      super.parseFunctionBody(r, !1, n);
    }
    parseFunctionBodyAndFinish(r, i, n = !1) {
      if (this.match(14)) {
        let a = this.startNode();
        [a.typeAnnotation, r.predicate] = this.flowParseTypeAndPredicateInitialiser(), r.returnType = a.typeAnnotation ? this.finishNode(a, "\
TypeAnnotation") : null;
      }
      return super.parseFunctionBodyAndFinish(r, i, n);
    }
    parseStatementLike(r) {
      if (this.state.strict && this.isContextual(129)) {
        let n = this.lookahead();
        if (Ga(n.type)) {
          let a = this.startNode();
          return this.next(), this.flowParseInterface(a);
        }
      } else if (this.isContextual(126)) {
        let n = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(n);
      }
      let i = super.parseStatementLike(r);
      return this.flowPragma === void 0 && !this.isValidDirective(i) && (this.flowPragma = null), i;
    }
    parseExpressionStatement(r, i, n) {
      if (i.type === "Identifier") {
        if (i.name === "declare") {
          if (this.match(80) || Ar(this.state.type) || this.match(68) || this.match(74) || this.match(82))
            return this.flowParseDeclare(r);
        } else if (Ar(this.state.type)) {
          if (i.name === "interface")
            return this.flowParseInterface(r);
          if (i.name === "type")
            return this.flowParseTypeAlias(r);
          if (i.name === "opaque")
            return this.flowParseOpaqueType(r, !1);
        }
      }
      return super.parseExpressionStatement(r, i, n);
    }
    shouldParseExportDeclaration() {
      let {
        type: r
      } = this.state;
      return r === 126 || S9(r) ? !this.state.containsEsc : super.shouldParseExportDeclaration();
    }
    isExportDefaultSpecifier() {
      let {
        type: r
      } = this.state;
      return r === 126 || S9(r) ? this.state.containsEsc : super.isExportDefaultSpecifier();
    }
    parseExportDefaultExpression() {
      if (this.isContextual(126)) {
        let r = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(r);
      }
      return super.parseExportDefaultExpression();
    }
    parseConditional(r, i, n) {
      if (!this.match(17)) return r;
      if (this.state.maybeInArrowParameters) {
        let y = this.lookaheadCharCode();
        if (y === 44 || y === 61 || y === 58 || y === 41)
          return this.setOptionalParametersError(n), r;
      }
      this.expect(17);
      let a = this.state.clone(), o = this.state.noArrowAt, u = this.startNodeAt(i), {
        consequent: l,
        failed: c
      } = this.tryParseConditionalConsequent(), [p, h] = this.getArrowLikeExpressions(l);
      if (c || h.length > 0) {
        let y = [...o];
        if (h.length > 0) {
          this.state = a, this.state.noArrowAt = y;
          for (let _ = 0; _ < h.length; _++)
            y.push(h[_].start);
          ({
            consequent: l,
            failed: c
          } = this.tryParseConditionalConsequent()), [p, h] = this.getArrowLikeExpressions(l);
        }
        c && p.length > 1 && this.raise(mt.AmbiguousConditionalArrow, a.startLoc), c && p.length === 1 && (this.state = a, y.push(p[0].start),
        this.state.noArrowAt = y, {
          consequent: l,
          failed: c
        } = this.tryParseConditionalConsequent());
      }
      return this.getArrowLikeExpressions(l, !0), this.state.noArrowAt = o, this.expect(14), u.test = r, u.consequent = l, u.alternate = this.
      forwardNoArrowParamsConversionAt(u, () => this.parseMaybeAssign(void 0, void 0)), this.finishNode(u, "ConditionalExpression");
    }
    tryParseConditionalConsequent() {
      this.state.noArrowParamsConversionAt.push(this.state.start);
      let r = this.parseMaybeAssignAllowIn(), i = !this.match(14);
      return this.state.noArrowParamsConversionAt.pop(), {
        consequent: r,
        failed: i
      };
    }
    getArrowLikeExpressions(r, i) {
      let n = [r], a = [];
      for (; n.length !== 0; ) {
        let o = n.pop();
        o.type === "ArrowFunctionExpression" && o.body.type !== "BlockStatement" ? (o.typeParameters || !o.returnType ? this.finishArrowValidation(
        o) : a.push(o), n.push(o.body)) : o.type === "ConditionalExpression" && (n.push(o.consequent), n.push(o.alternate));
      }
      return i ? (a.forEach((o) => this.finishArrowValidation(o)), [a, []]) : Eqe(a, (o) => o.params.every((u) => this.isAssignable(u, !0)));
    }
    finishArrowValidation(r) {
      var i;
      this.toAssignableList(r.params, (i = r.extra) == null ? void 0 : i.trailingCommaLoc, !1), this.scope.enter(6), super.checkParams(r, !1,
      !0), this.scope.exit();
    }
    forwardNoArrowParamsConversionAt(r, i) {
      let n;
      return this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(r.start)) ? (this.state.noArrowParamsConversionAt.push(this.
      state.start), n = i(), this.state.noArrowParamsConversionAt.pop()) : n = i(), n;
    }
    parseParenItem(r, i) {
      let n = super.parseParenItem(r, i);
      if (this.eat(17) && (n.optional = !0, this.resetEndLocation(r)), this.match(14)) {
        let a = this.startNodeAt(i);
        return a.expression = n, a.typeAnnotation = this.flowParseTypeAnnotation(), this.finishNode(a, "TypeCastExpression");
      }
      return n;
    }
    assertModuleNodeAllowed(r) {
      r.type === "ImportDeclaration" && (r.importKind === "type" || r.importKind === "typeof") || r.type === "ExportNamedDeclaration" && r.exportKind ===
      "type" || r.type === "ExportAllDeclaration" && r.exportKind === "type" || super.assertModuleNodeAllowed(r);
    }
    parseExportDeclaration(r) {
      if (this.isContextual(130)) {
        r.exportKind = "type";
        let i = this.startNode();
        return this.next(), this.match(5) ? (r.specifiers = this.parseExportSpecifiers(!0), super.parseExportFrom(r), null) : this.flowParseTypeAlias(
        i);
      } else if (this.isContextual(131)) {
        r.exportKind = "type";
        let i = this.startNode();
        return this.next(), this.flowParseOpaqueType(i, !1);
      } else if (this.isContextual(129)) {
        r.exportKind = "type";
        let i = this.startNode();
        return this.next(), this.flowParseInterface(i);
      } else if (this.isContextual(126)) {
        r.exportKind = "value";
        let i = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(i);
      } else
        return super.parseExportDeclaration(r);
    }
    eatExportStar(r) {
      return super.eatExportStar(r) ? !0 : this.isContextual(130) && this.lookahead().type === 55 ? (r.exportKind = "type", this.next(), this.
      next(), !0) : !1;
    }
    maybeParseExportNamespaceSpecifier(r) {
      let {
        startLoc: i
      } = this.state, n = super.maybeParseExportNamespaceSpecifier(r);
      return n && r.exportKind === "type" && this.unexpected(i), n;
    }
    parseClassId(r, i, n) {
      super.parseClassId(r, i, n), this.match(47) && (r.typeParameters = this.flowParseTypeParameterDeclaration());
    }
    parseClassMember(r, i, n) {
      let {
        startLoc: a
      } = this.state;
      if (this.isContextual(125)) {
        if (super.parseClassMemberFromModifier(r, i))
          return;
        i.declare = !0;
      }
      super.parseClassMember(r, i, n), i.declare && (i.type !== "ClassProperty" && i.type !== "ClassPrivateProperty" && i.type !== "Property\
Definition" ? this.raise(mt.DeclareClassElement, a) : i.value && this.raise(mt.DeclareClassFieldInitializer, i.value));
    }
    isIterator(r) {
      return r === "iterator" || r === "asyncIterator";
    }
    readIterator() {
      let r = super.readWord1(), i = "@@" + r;
      (!this.isIterator(r) || !this.state.inType) && this.raise(Z.InvalidIdentifier, this.state.curPosition(), {
        identifierName: i
      }), this.finishToken(132, i);
    }
    getTokenFromCode(r) {
      let i = this.input.charCodeAt(this.state.pos + 1);
      r === 123 && i === 124 ? this.finishOp(6, 2) : this.state.inType && (r === 62 || r === 60) ? this.finishOp(r === 62 ? 48 : 47, 1) : this.
      state.inType && r === 63 ? i === 46 ? this.finishOp(18, 2) : this.finishOp(17, 1) : sqe(r, i, this.input.charCodeAt(this.state.pos + 2)) ?
      (this.state.pos += 2, this.readIterator()) : super.getTokenFromCode(r);
    }
    isAssignable(r, i) {
      return r.type === "TypeCastExpression" ? this.isAssignable(r.expression, i) : super.isAssignable(r, i);
    }
    toAssignable(r, i = !1) {
      !i && r.type === "AssignmentExpression" && r.left.type === "TypeCastExpression" && (r.left = this.typeCastToParameter(r.left)), super.
      toAssignable(r, i);
    }
    toAssignableList(r, i, n) {
      for (let a = 0; a < r.length; a++) {
        let o = r[a];
        o?.type === "TypeCastExpression" && (r[a] = this.typeCastToParameter(o));
      }
      super.toAssignableList(r, i, n);
    }
    toReferencedList(r, i) {
      for (let a = 0; a < r.length; a++) {
        var n;
        let o = r[a];
        o && o.type === "TypeCastExpression" && !((n = o.extra) != null && n.parenthesized) && (r.length > 1 || !i) && this.raise(mt.TypeCastInPattern,
        o.typeAnnotation);
      }
      return r;
    }
    parseArrayLike(r, i, n, a) {
      let o = super.parseArrayLike(r, i, n, a);
      return i && !this.state.maybeInArrowParameters && this.toReferencedList(o.elements), o;
    }
    isValidLVal(r, i, n) {
      return r === "TypeCastExpression" || super.isValidLVal(r, i, n);
    }
    parseClassProperty(r) {
      return this.match(14) && (r.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassProperty(r);
    }
    parseClassPrivateProperty(r) {
      return this.match(14) && (r.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassPrivateProperty(r);
    }
    isClassMethod() {
      return this.match(47) || super.isClassMethod();
    }
    isClassProperty() {
      return this.match(14) || super.isClassProperty();
    }
    isNonstaticConstructor(r) {
      return !this.match(14) && super.isNonstaticConstructor(r);
    }
    pushClassMethod(r, i, n, a, o, u) {
      if (i.variance && this.unexpected(i.variance.loc.start), delete i.variance, this.match(47) && (i.typeParameters = this.flowParseTypeParameterDeclaration()),
      super.pushClassMethod(r, i, n, a, o, u), i.params && o) {
        let l = i.params;
        l.length > 0 && this.isThisParam(l[0]) && this.raise(mt.ThisParamBannedInConstructor, i);
      } else if (i.type === "MethodDefinition" && o && i.value.params) {
        let l = i.value.params;
        l.length > 0 && this.isThisParam(l[0]) && this.raise(mt.ThisParamBannedInConstructor, i);
      }
    }
    pushClassPrivateMethod(r, i, n, a) {
      i.variance && this.unexpected(i.variance.loc.start), delete i.variance, this.match(47) && (i.typeParameters = this.flowParseTypeParameterDeclaration()),
      super.pushClassPrivateMethod(r, i, n, a);
    }
    parseClassSuper(r) {
      if (super.parseClassSuper(r), r.superClass && (this.match(47) || this.match(51)) && (r.superTypeParameters = this.flowParseTypeParameterInstantiationInExpression()),
      this.isContextual(113)) {
        this.next();
        let i = r.implements = [];
        do {
          let n = this.startNode();
          n.id = this.flowParseRestrictedIdentifier(!0), this.match(47) ? n.typeParameters = this.flowParseTypeParameterInstantiation() : n.
          typeParameters = null, i.push(this.finishNode(n, "ClassImplements"));
        } while (this.eat(12));
      }
    }
    checkGetterSetterParams(r) {
      super.checkGetterSetterParams(r);
      let i = this.getObjectOrClassMethodParams(r);
      if (i.length > 0) {
        let n = i[0];
        this.isThisParam(n) && r.kind === "get" ? this.raise(mt.GetterMayNotHaveThisParam, n) : this.isThisParam(n) && this.raise(mt.SetterMayNotHaveThisParam,
        n);
      }
    }
    parsePropertyNamePrefixOperator(r) {
      r.variance = this.flowParseVariance();
    }
    parseObjPropValue(r, i, n, a, o, u, l) {
      r.variance && this.unexpected(r.variance.loc.start), delete r.variance;
      let c;
      this.match(47) && !u && (c = this.flowParseTypeParameterDeclaration(), this.match(10) || this.unexpected());
      let p = super.parseObjPropValue(r, i, n, a, o, u, l);
      return c && ((p.value || p).typeParameters = c), p;
    }
    parseFunctionParamType(r) {
      return this.eat(17) && (r.type !== "Identifier" && this.raise(mt.PatternIsOptional, r), this.isThisParam(r) && this.raise(mt.ThisParamMayNotBeOptional,
      r), r.optional = !0), this.match(14) ? r.typeAnnotation = this.flowParseTypeAnnotation() : this.isThisParam(r) && this.raise(mt.ThisParamAnnotationRequired,
      r), this.match(29) && this.isThisParam(r) && this.raise(mt.ThisParamNoDefault, r), this.resetEndLocation(r), r;
    }
    parseMaybeDefault(r, i) {
      let n = super.parseMaybeDefault(r, i);
      return n.type === "AssignmentPattern" && n.typeAnnotation && n.right.start < n.typeAnnotation.start && this.raise(mt.TypeBeforeInitializer,
      n.typeAnnotation), n;
    }
    checkImportReflection(r) {
      super.checkImportReflection(r), r.module && r.importKind !== "value" && this.raise(mt.ImportReflectionHasImportType, r.specifiers[0].loc.
      start);
    }
    parseImportSpecifierLocal(r, i, n) {
      i.local = x9(r) ? this.flowParseRestrictedIdentifier(!0, !0) : this.parseIdentifier(), r.specifiers.push(this.finishImportSpecifier(i,
      n));
    }
    isPotentialImportPhase(r) {
      if (super.isPotentialImportPhase(r)) return !0;
      if (this.isContextual(130)) {
        if (!r) return !0;
        let i = this.lookaheadCharCode();
        return i === 123 || i === 42;
      }
      return !r && this.isContextual(87);
    }
    applyImportPhase(r, i, n, a) {
      if (super.applyImportPhase(r, i, n, a), i) {
        if (!n && this.match(65))
          return;
        r.exportKind = n === "type" ? n : "value";
      } else
        n === "type" && this.match(55) && this.unexpected(), r.importKind = n === "type" || n === "typeof" ? n : "value";
    }
    parseImportSpecifier(r, i, n, a, o) {
      let u = r.imported, l = null;
      u.type === "Identifier" && (u.name === "type" ? l = "type" : u.name === "typeof" && (l = "typeof"));
      let c = !1;
      if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
        let h = this.parseIdentifier(!0);
        l !== null && !Ga(this.state.type) ? (r.imported = h, r.importKind = l, r.local = Au(h)) : (r.imported = u, r.importKind = null, r.local =
        this.parseIdentifier());
      } else {
        if (l !== null && Ga(this.state.type))
          r.imported = this.parseIdentifier(!0), r.importKind = l;
        else {
          if (i)
            throw this.raise(Z.ImportBindingIsString, r, {
              importName: u.value
            });
          r.imported = u, r.importKind = null;
        }
        this.eatContextual(93) ? r.local = this.parseIdentifier() : (c = !0, r.local = Au(r.imported));
      }
      let p = x9(r);
      return n && p && this.raise(mt.ImportTypeShorthandOnlyInPureImport, r), (n || p) && this.checkReservedType(r.local.name, r.local.loc.start,
      !0), c && !n && !p && this.checkReservedWord(r.local.name, r.loc.start, !0, !0), this.finishImportSpecifier(r, "ImportSpecifier");
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case 78:
          return this.parseIdentifier(!0);
        default:
          return super.parseBindingAtom();
      }
    }
    parseFunctionParams(r, i) {
      let n = r.kind;
      n !== "get" && n !== "set" && this.match(47) && (r.typeParameters = this.flowParseTypeParameterDeclaration()), super.parseFunctionParams(
      r, i);
    }
    parseVarId(r, i) {
      super.parseVarId(r, i), this.match(14) && (r.id.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(r.id));
    }
    parseAsyncArrowFromCallExpression(r, i) {
      if (this.match(14)) {
        let n = this.state.noAnonFunctionType;
        this.state.noAnonFunctionType = !0, r.returnType = this.flowParseTypeAnnotation(), this.state.noAnonFunctionType = n;
      }
      return super.parseAsyncArrowFromCallExpression(r, i);
    }
    shouldParseAsyncArrow() {
      return this.match(14) || super.shouldParseAsyncArrow();
    }
    parseMaybeAssign(r, i) {
      var n;
      let a = null, o;
      if (this.hasPlugin("jsx") && (this.match(143) || this.match(47))) {
        if (a = this.state.clone(), o = this.tryParse(() => super.parseMaybeAssign(r, i), a), !o.error) return o.node;
        let {
          context: c
        } = this.state, p = c[c.length - 1];
        (p === Er.j_oTag || p === Er.j_expr) && c.pop();
      }
      if ((n = o) != null && n.error || this.match(47)) {
        var u, l;
        a = a || this.state.clone();
        let c, p = this.tryParse((y) => {
          var _;
          c = this.flowParseTypeParameterDeclaration();
          let g = this.forwardNoArrowParamsConversionAt(c, () => {
            let f = super.parseMaybeAssign(r, i);
            return this.resetStartLocationFromNode(f, c), f;
          });
          (_ = g.extra) != null && _.parenthesized && y();
          let m = this.maybeUnwrapTypeCastExpression(g);
          return m.type !== "ArrowFunctionExpression" && y(), m.typeParameters = c, this.resetStartLocationFromNode(m, c), g;
        }, a), h = null;
        if (p.node && this.maybeUnwrapTypeCastExpression(p.node).type === "ArrowFunctionExpression") {
          if (!p.error && !p.aborted)
            return p.node.async && this.raise(mt.UnexpectedTypeParameterBeforeAsyncArrowFunction, c), p.node;
          h = p.node;
        }
        if ((u = o) != null && u.node)
          return this.state = o.failState, o.node;
        if (h)
          return this.state = p.failState, h;
        throw (l = o) != null && l.thrown ? o.error : p.thrown ? p.error : this.raise(mt.UnexpectedTokenAfterTypeParameter, c);
      }
      return super.parseMaybeAssign(r, i);
    }
    parseArrow(r) {
      if (this.match(14)) {
        let i = this.tryParse(() => {
          let n = this.state.noAnonFunctionType;
          this.state.noAnonFunctionType = !0;
          let a = this.startNode();
          return [a.typeAnnotation, r.predicate] = this.flowParseTypeAndPredicateInitialiser(), this.state.noAnonFunctionType = n, this.canInsertSemicolon() &&
          this.unexpected(), this.match(19) || this.unexpected(), a;
        });
        if (i.thrown) return null;
        i.error && (this.state = i.failState), r.returnType = i.node.typeAnnotation ? this.finishNode(i.node, "TypeAnnotation") : null;
      }
      return super.parseArrow(r);
    }
    shouldParseArrow(r) {
      return this.match(14) || super.shouldParseArrow(r);
    }
    setArrowFunctionParameters(r, i) {
      this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(r.start)) ? r.params = i : super.setArrowFunctionParameters(r, i);
    }
    checkParams(r, i, n, a = !0) {
      if (!(n && this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(r.start)))) {
        for (let o = 0; o < r.params.length; o++)
          this.isThisParam(r.params[o]) && o > 0 && this.raise(mt.ThisParamMustBeFirst, r.params[o]);
        super.checkParams(r, i, n, a);
      }
    }
    parseParenAndDistinguishExpression(r) {
      return super.parseParenAndDistinguishExpression(r && !this.state.noArrowAt.includes(this.sourceToOffsetPos(this.state.start)));
    }
    parseSubscripts(r, i, n) {
      if (r.type === "Identifier" && r.name === "async" && this.state.noArrowAt.includes(i.index)) {
        this.next();
        let a = this.startNodeAt(i);
        a.callee = r, a.arguments = super.parseCallExpressionArguments(11), r = this.finishNode(a, "CallExpression");
      } else if (r.type === "Identifier" && r.name === "async" && this.match(47)) {
        let a = this.state.clone(), o = this.tryParse((l) => this.parseAsyncArrowWithTypeParameters(i) || l(), a);
        if (!o.error && !o.aborted) return o.node;
        let u = this.tryParse(() => super.parseSubscripts(r, i, n), a);
        if (u.node && !u.error) return u.node;
        if (o.node)
          return this.state = o.failState, o.node;
        if (u.node)
          return this.state = u.failState, u.node;
        throw o.error || u.error;
      }
      return super.parseSubscripts(r, i, n);
    }
    parseSubscript(r, i, n, a) {
      if (this.match(18) && this.isLookaheadToken_lt()) {
        if (a.optionalChainMember = !0, n)
          return a.stop = !0, r;
        this.next();
        let o = this.startNodeAt(i);
        return o.callee = r, o.typeArguments = this.flowParseTypeParameterInstantiationInExpression(), this.expect(10), o.arguments = this.parseCallExpressionArguments(
        11), o.optional = !0, this.finishCallExpression(o, !0);
      } else if (!n && this.shouldParseTypes() && (this.match(47) || this.match(51))) {
        let o = this.startNodeAt(i);
        o.callee = r;
        let u = this.tryParse(() => (o.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew(), this.expect(10), o.arguments = super.
        parseCallExpressionArguments(11), a.optionalChainMember && (o.optional = !1), this.finishCallExpression(o, a.optionalChainMember)));
        if (u.node)
          return u.error && (this.state = u.failState), u.node;
      }
      return super.parseSubscript(r, i, n, a);
    }
    parseNewCallee(r) {
      super.parseNewCallee(r);
      let i = null;
      this.shouldParseTypes() && this.match(47) && (i = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node), r.typeArguments =
      i;
    }
    parseAsyncArrowWithTypeParameters(r) {
      let i = this.startNodeAt(r);
      if (this.parseFunctionParams(i, !1), !!this.parseArrow(i))
        return super.parseArrowExpression(i, void 0, !0);
    }
    readToken_mult_modulo(r) {
      let i = this.input.charCodeAt(this.state.pos + 1);
      if (r === 42 && i === 47 && this.state.hasFlowComment) {
        this.state.hasFlowComment = !1, this.state.pos += 2, this.nextToken();
        return;
      }
      super.readToken_mult_modulo(r);
    }
    readToken_pipe_amp(r) {
      let i = this.input.charCodeAt(this.state.pos + 1);
      if (r === 124 && i === 125) {
        this.finishOp(9, 2);
        return;
      }
      super.readToken_pipe_amp(r);
    }
    parseTopLevel(r, i) {
      let n = super.parseTopLevel(r, i);
      return this.state.hasFlowComment && this.raise(mt.UnterminatedFlowComment, this.state.curPosition()), n;
    }
    skipBlockComment() {
      if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
        if (this.state.hasFlowComment)
          throw this.raise(mt.NestedFlowComment, this.state.startLoc);
        this.hasFlowCommentCompletion();
        let r = this.skipFlowComment();
        r && (this.state.pos += r, this.state.hasFlowComment = !0);
        return;
      }
      return super.skipBlockComment(this.state.hasFlowComment ? "*-/" : "*/");
    }
    skipFlowComment() {
      let {
        pos: r
      } = this.state, i = 2;
      for (; [32, 9].includes(this.input.charCodeAt(r + i)); )
        i++;
      let n = this.input.charCodeAt(i + r), a = this.input.charCodeAt(i + r + 1);
      return n === 58 && a === 58 ? i + 2 : this.input.slice(i + r, i + r + 12) === "flow-include" ? i + 12 : n === 58 && a !== 58 ? i : !1;
    }
    hasFlowCommentCompletion() {
      if (this.input.indexOf("*/", this.state.pos) === -1)
        throw this.raise(Z.UnterminatedComment, this.state.curPosition());
    }
    flowEnumErrorBooleanMemberNotInitialized(r, {
      enumName: i,
      memberName: n
    }) {
      this.raise(mt.EnumBooleanMemberNotInitialized, r, {
        memberName: n,
        enumName: i
      });
    }
    flowEnumErrorInvalidMemberInitializer(r, i) {
      return this.raise(i.explicitType ? i.explicitType === "symbol" ? mt.EnumInvalidMemberInitializerSymbolType : mt.EnumInvalidMemberInitializerPrimaryType :
      mt.EnumInvalidMemberInitializerUnknownType, r, i);
    }
    flowEnumErrorNumberMemberNotInitialized(r, i) {
      this.raise(mt.EnumNumberMemberNotInitialized, r, i);
    }
    flowEnumErrorStringMemberInconsistentlyInitialized(r, i) {
      this.raise(mt.EnumStringMemberInconsistentlyInitialized, r, i);
    }
    flowEnumMemberInit() {
      let r = this.state.startLoc, i = /* @__PURE__ */ s(() => this.match(12) || this.match(8), "endOfInit");
      switch (this.state.type) {
        case 135: {
          let n = this.parseNumericLiteral(this.state.value);
          return i() ? {
            type: "number",
            loc: n.loc.start,
            value: n
          } : {
            type: "invalid",
            loc: r
          };
        }
        case 134: {
          let n = this.parseStringLiteral(this.state.value);
          return i() ? {
            type: "string",
            loc: n.loc.start,
            value: n
          } : {
            type: "invalid",
            loc: r
          };
        }
        case 85:
        case 86: {
          let n = this.parseBooleanLiteral(this.match(85));
          return i() ? {
            type: "boolean",
            loc: n.loc.start,
            value: n
          } : {
            type: "invalid",
            loc: r
          };
        }
        default:
          return {
            type: "invalid",
            loc: r
          };
      }
    }
    flowEnumMemberRaw() {
      let r = this.state.startLoc, i = this.parseIdentifier(!0), n = this.eat(29) ? this.flowEnumMemberInit() : {
        type: "none",
        loc: r
      };
      return {
        id: i,
        init: n
      };
    }
    flowEnumCheckExplicitTypeMismatch(r, i, n) {
      let {
        explicitType: a
      } = i;
      a !== null && a !== n && this.flowEnumErrorInvalidMemberInitializer(r, i);
    }
    flowEnumMembers({
      enumName: r,
      explicitType: i
    }) {
      let n = /* @__PURE__ */ new Set(), a = {
        booleanMembers: [],
        numberMembers: [],
        stringMembers: [],
        defaultedMembers: []
      }, o = !1;
      for (; !this.match(8); ) {
        if (this.eat(21)) {
          o = !0;
          break;
        }
        let u = this.startNode(), {
          id: l,
          init: c
        } = this.flowEnumMemberRaw(), p = l.name;
        if (p === "")
          continue;
        /^[a-z]/.test(p) && this.raise(mt.EnumInvalidMemberName, l, {
          memberName: p,
          suggestion: p[0].toUpperCase() + p.slice(1),
          enumName: r
        }), n.has(p) && this.raise(mt.EnumDuplicateMemberName, l, {
          memberName: p,
          enumName: r
        }), n.add(p);
        let h = {
          enumName: r,
          explicitType: i,
          memberName: p
        };
        switch (u.id = l, c.type) {
          case "boolean": {
            this.flowEnumCheckExplicitTypeMismatch(c.loc, h, "boolean"), u.init = c.value, a.booleanMembers.push(this.finishNode(u, "EnumBoo\
leanMember"));
            break;
          }
          case "number": {
            this.flowEnumCheckExplicitTypeMismatch(c.loc, h, "number"), u.init = c.value, a.numberMembers.push(this.finishNode(u, "EnumNumbe\
rMember"));
            break;
          }
          case "string": {
            this.flowEnumCheckExplicitTypeMismatch(c.loc, h, "string"), u.init = c.value, a.stringMembers.push(this.finishNode(u, "EnumStrin\
gMember"));
            break;
          }
          case "invalid":
            throw this.flowEnumErrorInvalidMemberInitializer(c.loc, h);
          case "none":
            switch (i) {
              case "boolean":
                this.flowEnumErrorBooleanMemberNotInitialized(c.loc, h);
                break;
              case "number":
                this.flowEnumErrorNumberMemberNotInitialized(c.loc, h);
                break;
              default:
                a.defaultedMembers.push(this.finishNode(u, "EnumDefaultedMember"));
            }
        }
        this.match(8) || this.expect(12);
      }
      return {
        members: a,
        hasUnknownMembers: o
      };
    }
    flowEnumStringMembers(r, i, {
      enumName: n
    }) {
      if (r.length === 0)
        return i;
      if (i.length === 0)
        return r;
      if (i.length > r.length) {
        for (let a of r)
          this.flowEnumErrorStringMemberInconsistentlyInitialized(a, {
            enumName: n
          });
        return i;
      } else {
        for (let a of i)
          this.flowEnumErrorStringMemberInconsistentlyInitialized(a, {
            enumName: n
          });
        return r;
      }
    }
    flowEnumParseExplicitType({
      enumName: r
    }) {
      if (!this.eatContextual(102)) return null;
      if (!Ar(this.state.type))
        throw this.raise(mt.EnumInvalidExplicitTypeUnknownSupplied, this.state.startLoc, {
          enumName: r
        });
      let {
        value: i
      } = this.state;
      return this.next(), i !== "boolean" && i !== "number" && i !== "string" && i !== "symbol" && this.raise(mt.EnumInvalidExplicitType, this.
      state.startLoc, {
        enumName: r,
        invalidEnumType: i
      }), i;
    }
    flowEnumBody(r, i) {
      let n = i.name, a = i.loc.start, o = this.flowEnumParseExplicitType({
        enumName: n
      });
      this.expect(5);
      let {
        members: u,
        hasUnknownMembers: l
      } = this.flowEnumMembers({
        enumName: n,
        explicitType: o
      });
      switch (r.hasUnknownMembers = l, o) {
        case "boolean":
          return r.explicitType = !0, r.members = u.booleanMembers, this.expect(8), this.finishNode(r, "EnumBooleanBody");
        case "number":
          return r.explicitType = !0, r.members = u.numberMembers, this.expect(8), this.finishNode(r, "EnumNumberBody");
        case "string":
          return r.explicitType = !0, r.members = this.flowEnumStringMembers(u.stringMembers, u.defaultedMembers, {
            enumName: n
          }), this.expect(8), this.finishNode(r, "EnumStringBody");
        case "symbol":
          return r.members = u.defaultedMembers, this.expect(8), this.finishNode(r, "EnumSymbolBody");
        default: {
          let c = /* @__PURE__ */ s(() => (r.members = [], this.expect(8), this.finishNode(r, "EnumStringBody")), "empty");
          r.explicitType = !1;
          let p = u.booleanMembers.length, h = u.numberMembers.length, y = u.stringMembers.length, _ = u.defaultedMembers.length;
          if (!p && !h && !y && !_)
            return c();
          if (!p && !h)
            return r.members = this.flowEnumStringMembers(u.stringMembers, u.defaultedMembers, {
              enumName: n
            }), this.expect(8), this.finishNode(r, "EnumStringBody");
          if (!h && !y && p >= _) {
            for (let g of u.defaultedMembers)
              this.flowEnumErrorBooleanMemberNotInitialized(g.loc.start, {
                enumName: n,
                memberName: g.id.name
              });
            return r.members = u.booleanMembers, this.expect(8), this.finishNode(r, "EnumBooleanBody");
          } else if (!p && !y && h >= _) {
            for (let g of u.defaultedMembers)
              this.flowEnumErrorNumberMemberNotInitialized(g.loc.start, {
                enumName: n,
                memberName: g.id.name
              });
            return r.members = u.numberMembers, this.expect(8), this.finishNode(r, "EnumNumberBody");
          } else
            return this.raise(mt.EnumInconsistentMemberValues, a, {
              enumName: n
            }), c();
        }
      }
    }
    flowParseEnumDeclaration(r) {
      let i = this.parseIdentifier();
      return r.id = i, r.body = this.flowEnumBody(this.startNode(), i), this.finishNode(r, "EnumDeclaration");
    }
    jsxParseOpeningElementAfterName(r) {
      return this.shouldParseTypes() && (this.match(47) || this.match(51)) && (r.typeArguments = this.flowParseTypeParameterInstantiationInExpression()),
      super.jsxParseOpeningElementAfterName(r);
    }
    isLookaheadToken_lt() {
      let r = this.nextTokenStart();
      if (this.input.charCodeAt(r) === 60) {
        let i = this.input.charCodeAt(r + 1);
        return i !== 60 && i !== 61;
      }
      return !1;
    }
    reScan_lt_gt() {
      let {
        type: r
      } = this.state;
      r === 47 ? (this.state.pos -= 1, this.readToken_lt()) : r === 48 && (this.state.pos -= 1, this.readToken_gt());
    }
    reScan_lt() {
      let {
        type: r
      } = this.state;
      return r === 51 ? (this.state.pos -= 2, this.finishOp(47, 1), 47) : r;
    }
    maybeUnwrapTypeCastExpression(r) {
      return r.type === "TypeCastExpression" ? r.expression : r;
    }
  }, "flow"), Cqe = {
    __proto__: null,
    quot: '"',
    amp: "&",
    apos: "'",
    lt: "<",
    gt: ">",
    nbsp: "\xA0",
    iexcl: "\xA1",
    cent: "\xA2",
    pound: "\xA3",
    curren: "\xA4",
    yen: "\xA5",
    brvbar: "\xA6",
    sect: "\xA7",
    uml: "\xA8",
    copy: "\xA9",
    ordf: "\xAA",
    laquo: "\xAB",
    not: "\xAC",
    shy: "\xAD",
    reg: "\xAE",
    macr: "\xAF",
    deg: "\xB0",
    plusmn: "\xB1",
    sup2: "\xB2",
    sup3: "\xB3",
    acute: "\xB4",
    micro: "\xB5",
    para: "\xB6",
    middot: "\xB7",
    cedil: "\xB8",
    sup1: "\xB9",
    ordm: "\xBA",
    raquo: "\xBB",
    frac14: "\xBC",
    frac12: "\xBD",
    frac34: "\xBE",
    iquest: "\xBF",
    Agrave: "\xC0",
    Aacute: "\xC1",
    Acirc: "\xC2",
    Atilde: "\xC3",
    Auml: "\xC4",
    Aring: "\xC5",
    AElig: "\xC6",
    Ccedil: "\xC7",
    Egrave: "\xC8",
    Eacute: "\xC9",
    Ecirc: "\xCA",
    Euml: "\xCB",
    Igrave: "\xCC",
    Iacute: "\xCD",
    Icirc: "\xCE",
    Iuml: "\xCF",
    ETH: "\xD0",
    Ntilde: "\xD1",
    Ograve: "\xD2",
    Oacute: "\xD3",
    Ocirc: "\xD4",
    Otilde: "\xD5",
    Ouml: "\xD6",
    times: "\xD7",
    Oslash: "\xD8",
    Ugrave: "\xD9",
    Uacute: "\xDA",
    Ucirc: "\xDB",
    Uuml: "\xDC",
    Yacute: "\xDD",
    THORN: "\xDE",
    szlig: "\xDF",
    agrave: "\xE0",
    aacute: "\xE1",
    acirc: "\xE2",
    atilde: "\xE3",
    auml: "\xE4",
    aring: "\xE5",
    aelig: "\xE6",
    ccedil: "\xE7",
    egrave: "\xE8",
    eacute: "\xE9",
    ecirc: "\xEA",
    euml: "\xEB",
    igrave: "\xEC",
    iacute: "\xED",
    icirc: "\xEE",
    iuml: "\xEF",
    eth: "\xF0",
    ntilde: "\xF1",
    ograve: "\xF2",
    oacute: "\xF3",
    ocirc: "\xF4",
    otilde: "\xF5",
    ouml: "\xF6",
    divide: "\xF7",
    oslash: "\xF8",
    ugrave: "\xF9",
    uacute: "\xFA",
    ucirc: "\xFB",
    uuml: "\xFC",
    yacute: "\xFD",
    thorn: "\xFE",
    yuml: "\xFF",
    OElig: "\u0152",
    oelig: "\u0153",
    Scaron: "\u0160",
    scaron: "\u0161",
    Yuml: "\u0178",
    fnof: "\u0192",
    circ: "\u02C6",
    tilde: "\u02DC",
    Alpha: "\u0391",
    Beta: "\u0392",
    Gamma: "\u0393",
    Delta: "\u0394",
    Epsilon: "\u0395",
    Zeta: "\u0396",
    Eta: "\u0397",
    Theta: "\u0398",
    Iota: "\u0399",
    Kappa: "\u039A",
    Lambda: "\u039B",
    Mu: "\u039C",
    Nu: "\u039D",
    Xi: "\u039E",
    Omicron: "\u039F",
    Pi: "\u03A0",
    Rho: "\u03A1",
    Sigma: "\u03A3",
    Tau: "\u03A4",
    Upsilon: "\u03A5",
    Phi: "\u03A6",
    Chi: "\u03A7",
    Psi: "\u03A8",
    Omega: "\u03A9",
    alpha: "\u03B1",
    beta: "\u03B2",
    gamma: "\u03B3",
    delta: "\u03B4",
    epsilon: "\u03B5",
    zeta: "\u03B6",
    eta: "\u03B7",
    theta: "\u03B8",
    iota: "\u03B9",
    kappa: "\u03BA",
    lambda: "\u03BB",
    mu: "\u03BC",
    nu: "\u03BD",
    xi: "\u03BE",
    omicron: "\u03BF",
    pi: "\u03C0",
    rho: "\u03C1",
    sigmaf: "\u03C2",
    sigma: "\u03C3",
    tau: "\u03C4",
    upsilon: "\u03C5",
    phi: "\u03C6",
    chi: "\u03C7",
    psi: "\u03C8",
    omega: "\u03C9",
    thetasym: "\u03D1",
    upsih: "\u03D2",
    piv: "\u03D6",
    ensp: "\u2002",
    emsp: "\u2003",
    thinsp: "\u2009",
    zwnj: "\u200C",
    zwj: "\u200D",
    lrm: "\u200E",
    rlm: "\u200F",
    ndash: "\u2013",
    mdash: "\u2014",
    lsquo: "\u2018",
    rsquo: "\u2019",
    sbquo: "\u201A",
    ldquo: "\u201C",
    rdquo: "\u201D",
    bdquo: "\u201E",
    dagger: "\u2020",
    Dagger: "\u2021",
    bull: "\u2022",
    hellip: "\u2026",
    permil: "\u2030",
    prime: "\u2032",
    Prime: "\u2033",
    lsaquo: "\u2039",
    rsaquo: "\u203A",
    oline: "\u203E",
    frasl: "\u2044",
    euro: "\u20AC",
    image: "\u2111",
    weierp: "\u2118",
    real: "\u211C",
    trade: "\u2122",
    alefsym: "\u2135",
    larr: "\u2190",
    uarr: "\u2191",
    rarr: "\u2192",
    darr: "\u2193",
    harr: "\u2194",
    crarr: "\u21B5",
    lArr: "\u21D0",
    uArr: "\u21D1",
    rArr: "\u21D2",
    dArr: "\u21D3",
    hArr: "\u21D4",
    forall: "\u2200",
    part: "\u2202",
    exist: "\u2203",
    empty: "\u2205",
    nabla: "\u2207",
    isin: "\u2208",
    notin: "\u2209",
    ni: "\u220B",
    prod: "\u220F",
    sum: "\u2211",
    minus: "\u2212",
    lowast: "\u2217",
    radic: "\u221A",
    prop: "\u221D",
    infin: "\u221E",
    ang: "\u2220",
    and: "\u2227",
    or: "\u2228",
    cap: "\u2229",
    cup: "\u222A",
    int: "\u222B",
    there4: "\u2234",
    sim: "\u223C",
    cong: "\u2245",
    asymp: "\u2248",
    ne: "\u2260",
    equiv: "\u2261",
    le: "\u2264",
    ge: "\u2265",
    sub: "\u2282",
    sup: "\u2283",
    nsub: "\u2284",
    sube: "\u2286",
    supe: "\u2287",
    oplus: "\u2295",
    otimes: "\u2297",
    perp: "\u22A5",
    sdot: "\u22C5",
    lceil: "\u2308",
    rceil: "\u2309",
    lfloor: "\u230A",
    rfloor: "\u230B",
    lang: "\u2329",
    rang: "\u232A",
    loz: "\u25CA",
    spades: "\u2660",
    clubs: "\u2663",
    hearts: "\u2665",
    diams: "\u2666"
  }, dc = Eu`jsx`({
    AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.",
    MissingClosingTagElement: /* @__PURE__ */ s(({
      openingTagName: e
    }) => `Expected corresponding JSX closing tag for <${e}>.`, "MissingClosingTagElement"),
    MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.",
    UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?",
    UnexpectedToken: /* @__PURE__ */ s(({
      unexpected: e,
      HTMLEntity: t
    }) => `Unexpected token \`${e}\`. Did you mean \`${t}\` or \`{'${e}'}\`?`, "UnexpectedToken"),
    UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.",
    UnterminatedJsxContent: "Unterminated JSX contents.",
    UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"
  });
  function dl(e) {
    return e ? e.type === "JSXOpeningFragment" || e.type === "JSXClosingFragment" : !1;
  }
  s(dl, "isFragment");
  function ep(e) {
    if (e.type === "JSXIdentifier")
      return e.name;
    if (e.type === "JSXNamespacedName")
      return e.namespace.name + ":" + e.name.name;
    if (e.type === "JSXMemberExpression")
      return ep(e.object) + "." + ep(e.property);
    throw new Error("Node had unexpected type: " + e.type);
  }
  s(ep, "getQualifiedJSXName");
  var Pqe = /* @__PURE__ */ s((e) => class extends e {
    static {
      s(this, "JSXParserMixin");
    }
    jsxReadToken() {
      let r = "", i = this.state.pos;
      for (; ; ) {
        if (this.state.pos >= this.length)
          throw this.raise(dc.UnterminatedJsxContent, this.state.startLoc);
        let n = this.input.charCodeAt(this.state.pos);
        switch (n) {
          case 60:
          case 123:
            if (this.state.pos === this.state.start) {
              n === 60 && this.state.canStartJSXElement ? (++this.state.pos, this.finishToken(143)) : super.getTokenFromCode(n);
              return;
            }
            r += this.input.slice(i, this.state.pos), this.finishToken(142, r);
            return;
          case 38:
            r += this.input.slice(i, this.state.pos), r += this.jsxReadEntity(), i = this.state.pos;
            break;
          case 62:
          case 125:
          default:
            rp(n) ? (r += this.input.slice(i, this.state.pos), r += this.jsxReadNewLine(!0), i = this.state.pos) : ++this.state.pos;
        }
      }
    }
    jsxReadNewLine(r) {
      let i = this.input.charCodeAt(this.state.pos), n;
      return ++this.state.pos, i === 13 && this.input.charCodeAt(this.state.pos) === 10 ? (++this.state.pos, n = r ? `
` : `\r
`) : n = String.fromCharCode(i), ++this.state.curLine, this.state.lineStart = this.state.pos, n;
    }
    jsxReadString(r) {
      let i = "", n = ++this.state.pos;
      for (; ; ) {
        if (this.state.pos >= this.length)
          throw this.raise(Z.UnterminatedString, this.state.startLoc);
        let a = this.input.charCodeAt(this.state.pos);
        if (a === r) break;
        a === 38 ? (i += this.input.slice(n, this.state.pos), i += this.jsxReadEntity(), n = this.state.pos) : rp(a) ? (i += this.input.slice(
        n, this.state.pos), i += this.jsxReadNewLine(!1), n = this.state.pos) : ++this.state.pos;
      }
      i += this.input.slice(n, this.state.pos++), this.finishToken(134, i);
    }
    jsxReadEntity() {
      let r = ++this.state.pos;
      if (this.codePointAtPos(this.state.pos) === 35) {
        ++this.state.pos;
        let i = 10;
        this.codePointAtPos(this.state.pos) === 120 && (i = 16, ++this.state.pos);
        let n = this.readInt(i, void 0, !1, "bail");
        if (n !== null && this.codePointAtPos(this.state.pos) === 59)
          return ++this.state.pos, String.fromCodePoint(n);
      } else {
        let i = 0, n = !1;
        for (; i++ < 10 && this.state.pos < this.length && !(n = this.codePointAtPos(this.state.pos) === 59); )
          ++this.state.pos;
        if (n) {
          let a = this.input.slice(r, this.state.pos), o = Cqe[a];
          if (++this.state.pos, o)
            return o;
        }
      }
      return this.state.pos = r, "&";
    }
    jsxReadWord() {
      let r, i = this.state.pos;
      do
        r = this.input.charCodeAt(++this.state.pos);
      while (tp(r) || r === 45);
      this.finishToken(141, this.input.slice(i, this.state.pos));
    }
    jsxParseIdentifier() {
      let r = this.startNode();
      return this.match(141) ? r.name = this.state.value : kP(this.state.type) ? r.name = ml(this.state.type) : this.unexpected(), this.next(),
      this.finishNode(r, "JSXIdentifier");
    }
    jsxParseNamespacedName() {
      let r = this.state.startLoc, i = this.jsxParseIdentifier();
      if (!this.eat(14)) return i;
      let n = this.startNodeAt(r);
      return n.namespace = i, n.name = this.jsxParseIdentifier(), this.finishNode(n, "JSXNamespacedName");
    }
    jsxParseElementName() {
      let r = this.state.startLoc, i = this.jsxParseNamespacedName();
      if (i.type === "JSXNamespacedName")
        return i;
      for (; this.eat(16); ) {
        let n = this.startNodeAt(r);
        n.object = i, n.property = this.jsxParseIdentifier(), i = this.finishNode(n, "JSXMemberExpression");
      }
      return i;
    }
    jsxParseAttributeValue() {
      let r;
      switch (this.state.type) {
        case 5:
          return r = this.startNode(), this.setContext(Er.brace), this.next(), r = this.jsxParseExpressionContainer(r, Er.j_oTag), r.expression.
          type === "JSXEmptyExpression" && this.raise(dc.AttributeIsEmpty, r), r;
        case 143:
        case 134:
          return this.parseExprAtom();
        default:
          throw this.raise(dc.UnsupportedJsxValue, this.state.startLoc);
      }
    }
    jsxParseEmptyExpression() {
      let r = this.startNodeAt(this.state.lastTokEndLoc);
      return this.finishNodeAt(r, "JSXEmptyExpression", this.state.startLoc);
    }
    jsxParseSpreadChild(r) {
      return this.next(), r.expression = this.parseExpression(), this.setContext(Er.j_expr), this.state.canStartJSXElement = !0, this.expect(
      8), this.finishNode(r, "JSXSpreadChild");
    }
    jsxParseExpressionContainer(r, i) {
      if (this.match(8))
        r.expression = this.jsxParseEmptyExpression();
      else {
        let n = this.parseExpression();
        r.expression = n;
      }
      return this.setContext(i), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(r, "JSXExpressionContainer");
    }
    jsxParseAttribute() {
      let r = this.startNode();
      return this.match(5) ? (this.setContext(Er.brace), this.next(), this.expect(21), r.argument = this.parseMaybeAssignAllowIn(), this.setContext(
      Er.j_oTag), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(r, "JSXSpreadAttribute")) : (r.name = this.jsxParseNamespacedName(),
      r.value = this.eat(29) ? this.jsxParseAttributeValue() : null, this.finishNode(r, "JSXAttribute"));
    }
    jsxParseOpeningElementAt(r) {
      let i = this.startNodeAt(r);
      return this.eat(144) ? this.finishNode(i, "JSXOpeningFragment") : (i.name = this.jsxParseElementName(), this.jsxParseOpeningElementAfterName(
      i));
    }
    jsxParseOpeningElementAfterName(r) {
      let i = [];
      for (; !this.match(56) && !this.match(144); )
        i.push(this.jsxParseAttribute());
      return r.attributes = i, r.selfClosing = this.eat(56), this.expect(144), this.finishNode(r, "JSXOpeningElement");
    }
    jsxParseClosingElementAt(r) {
      let i = this.startNodeAt(r);
      return this.eat(144) ? this.finishNode(i, "JSXClosingFragment") : (i.name = this.jsxParseElementName(), this.expect(144), this.finishNode(
      i, "JSXClosingElement"));
    }
    jsxParseElementAt(r) {
      let i = this.startNodeAt(r), n = [], a = this.jsxParseOpeningElementAt(r), o = null;
      if (!a.selfClosing) {
        e: for (; ; )
          switch (this.state.type) {
            case 143:
              if (r = this.state.startLoc, this.next(), this.eat(56)) {
                o = this.jsxParseClosingElementAt(r);
                break e;
              }
              n.push(this.jsxParseElementAt(r));
              break;
            case 142:
              n.push(this.parseLiteral(this.state.value, "JSXText"));
              break;
            case 5: {
              let u = this.startNode();
              this.setContext(Er.brace), this.next(), this.match(21) ? n.push(this.jsxParseSpreadChild(u)) : n.push(this.jsxParseExpressionContainer(
              u, Er.j_expr));
              break;
            }
            default:
              this.unexpected();
          }
        dl(a) && !dl(o) && o !== null ? this.raise(dc.MissingClosingTagFragment, o) : !dl(a) && dl(o) ? this.raise(dc.MissingClosingTagElement,
        o, {
          openingTagName: ep(a.name)
        }) : !dl(a) && !dl(o) && ep(o.name) !== ep(a.name) && this.raise(dc.MissingClosingTagElement, o, {
          openingTagName: ep(a.name)
        });
      }
      if (dl(a) ? (i.openingFragment = a, i.closingFragment = o) : (i.openingElement = a, i.closingElement = o), i.children = n, this.match(
      47))
        throw this.raise(dc.UnwrappedAdjacentJSXElements, this.state.startLoc);
      return dl(a) ? this.finishNode(i, "JSXFragment") : this.finishNode(i, "JSXElement");
    }
    jsxParseElement() {
      let r = this.state.startLoc;
      return this.next(), this.jsxParseElementAt(r);
    }
    setContext(r) {
      let {
        context: i
      } = this.state;
      i[i.length - 1] = r;
    }
    parseExprAtom(r) {
      return this.match(143) ? this.jsxParseElement() : this.match(47) && this.input.charCodeAt(this.state.pos) !== 33 ? (this.replaceToken(
      143), this.jsxParseElement()) : super.parseExprAtom(r);
    }
    skipSpace() {
      this.curContext().preserveSpace || super.skipSpace();
    }
    getTokenFromCode(r) {
      let i = this.curContext();
      if (i === Er.j_expr) {
        this.jsxReadToken();
        return;
      }
      if (i === Er.j_oTag || i === Er.j_cTag) {
        if (Tu(r)) {
          this.jsxReadWord();
          return;
        }
        if (r === 62) {
          ++this.state.pos, this.finishToken(144);
          return;
        }
        if ((r === 34 || r === 39) && i === Er.j_oTag) {
          this.jsxReadString(r);
          return;
        }
      }
      if (r === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {
        ++this.state.pos, this.finishToken(143);
        return;
      }
      super.getTokenFromCode(r);
    }
    updateContext(r) {
      let {
        context: i,
        type: n
      } = this.state;
      if (n === 56 && r === 143)
        i.splice(-2, 2, Er.j_cTag), this.state.canStartJSXElement = !1;
      else if (n === 143)
        i.push(Er.j_oTag);
      else if (n === 144) {
        let a = i[i.length - 1];
        a === Er.j_oTag && r === 56 || a === Er.j_cTag ? (i.pop(), this.state.canStartJSXElement = i[i.length - 1] === Er.j_expr) : (this.setContext(
        Er.j_expr), this.state.canStartJSXElement = !0);
      } else
        this.state.canStartJSXElement = K3e(n);
    }
  }, "jsx"), vP = class extends Cd {
    static {
      s(this, "TypeScriptScope");
    }
    constructor(...t) {
      super(...t), this.tsNames = /* @__PURE__ */ new Map();
    }
  }, SP = class extends Pd {
    static {
      s(this, "TypeScriptScopeHandler");
    }
    constructor(...t) {
      super(...t), this.importsStack = [];
    }
    createScope(t) {
      return this.importsStack.push(/* @__PURE__ */ new Set()), new vP(t);
    }
    enter(t) {
      t === 256 && this.importsStack.push(/* @__PURE__ */ new Set()), super.enter(t);
    }
    exit() {
      let t = super.exit();
      return t === 256 && this.importsStack.pop(), t;
    }
    hasImport(t, r) {
      let i = this.importsStack.length;
      if (this.importsStack[i - 1].has(t))
        return !0;
      if (!r && i > 1) {
        for (let n = 0; n < i - 1; n++)
          if (this.importsStack[n].has(t)) return !0;
      }
      return !1;
    }
    declareName(t, r, i) {
      if (r & 4096) {
        this.hasImport(t, !0) && this.parser.raise(Z.VarRedeclaration, i, {
          identifierName: t
        }), this.importsStack[this.importsStack.length - 1].add(t);
        return;
      }
      let n = this.currentScope(), a = n.tsNames.get(t) || 0;
      if (r & 1024) {
        this.maybeExportDefined(n, t), n.tsNames.set(t, a | 16);
        return;
      }
      super.declareName(t, r, i), r & 2 && (r & 1 || (this.checkRedeclarationInScope(n, t, r, i), this.maybeExportDefined(n, t)), a = a | 1),
      r & 256 && (a = a | 2), r & 512 && (a = a | 4), r & 128 && (a = a | 8), a && n.tsNames.set(t, a);
    }
    isRedeclaredInScope(t, r, i) {
      let n = t.tsNames.get(r);
      if ((n & 2) > 0) {
        if (i & 256) {
          let a = !!(i & 512), o = (n & 4) > 0;
          return a !== o;
        }
        return !0;
      }
      return i & 128 && (n & 8) > 0 ? t.names.get(r) & 2 ? !!(i & 1) : !1 : i & 2 && (n & 1) > 0 ? !0 : super.isRedeclaredInScope(t, r, i);
    }
    checkLocalExport(t) {
      let {
        name: r
      } = t;
      if (this.hasImport(r)) return;
      let i = this.scopeStack.length;
      for (let n = i - 1; n >= 0; n--) {
        let o = this.scopeStack[n].tsNames.get(r);
        if ((o & 1) > 0 || (o & 16) > 0)
          return;
      }
      super.checkLocalExport(t);
    }
  }, K9 = /* @__PURE__ */ s((e) => e.type === "ParenthesizedExpression" ? K9(e.expression) : e, "unwrapParenthesizedExpression"), TP = class extends bP {
    static {
      s(this, "LValParser");
    }
    toAssignable(t, r = !1) {
      var i, n;
      let a;
      switch ((t.type === "ParenthesizedExpression" || (i = t.extra) != null && i.parenthesized) && (a = K9(t), r ? a.type === "Identifier" ?
      this.expressionScope.recordArrowParameterBindingError(Z.InvalidParenthesizedAssignment, t) : a.type !== "MemberExpression" && !this.isOptionalMemberExpression(
      a) && this.raise(Z.InvalidParenthesizedAssignment, t) : this.raise(Z.InvalidParenthesizedAssignment, t)), t.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
          break;
        case "ObjectExpression":
          t.type = "ObjectPattern";
          for (let u = 0, l = t.properties.length, c = l - 1; u < l; u++) {
            var o;
            let p = t.properties[u], h = u === c;
            this.toAssignableObjectExpressionProp(p, h, r), h && p.type === "RestElement" && (o = t.extra) != null && o.trailingCommaLoc && this.
            raise(Z.RestTrailingComma, t.extra.trailingCommaLoc);
          }
          break;
        case "ObjectProperty": {
          let {
            key: u,
            value: l
          } = t;
          this.isPrivateName(u) && this.classScope.usePrivateName(this.getPrivateNameSV(u), u.loc.start), this.toAssignable(l, r);
          break;
        }
        case "SpreadElement":
          throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignabl\
e's caller.");
        case "ArrayExpression":
          t.type = "ArrayPattern", this.toAssignableList(t.elements, (n = t.extra) == null ? void 0 : n.trailingCommaLoc, r);
          break;
        case "AssignmentExpression":
          t.operator !== "=" && this.raise(Z.MissingEqInAssignment, t.left.loc.end), t.type = "AssignmentPattern", delete t.operator, this.toAssignable(
          t.left, r);
          break;
        case "ParenthesizedExpression":
          this.toAssignable(a, r);
          break;
      }
    }
    toAssignableObjectExpressionProp(t, r, i) {
      if (t.type === "ObjectMethod")
        this.raise(t.kind === "get" || t.kind === "set" ? Z.PatternHasAccessor : Z.PatternHasMethod, t.key);
      else if (t.type === "SpreadElement") {
        t.type = "RestElement";
        let n = t.argument;
        this.checkToRestConversion(n, !1), this.toAssignable(n, i), r || this.raise(Z.RestTrailingComma, t);
      } else
        this.toAssignable(t, i);
    }
    toAssignableList(t, r, i) {
      let n = t.length - 1;
      for (let a = 0; a <= n; a++) {
        let o = t[a];
        o && (this.toAssignableListItem(t, a, i), o.type === "RestElement" && (a < n ? this.raise(Z.RestTrailingComma, o) : r && this.raise(
        Z.RestTrailingComma, r)));
      }
    }
    toAssignableListItem(t, r, i) {
      let n = t[r];
      if (n.type === "SpreadElement") {
        n.type = "RestElement";
        let a = n.argument;
        this.checkToRestConversion(a, !0), this.toAssignable(a, i);
      } else
        this.toAssignable(n, i);
    }
    isAssignable(t, r) {
      switch (t.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
          return !0;
        case "ObjectExpression": {
          let i = t.properties.length - 1;
          return t.properties.every((n, a) => n.type !== "ObjectMethod" && (a === i || n.type !== "SpreadElement") && this.isAssignable(n));
        }
        case "ObjectProperty":
          return this.isAssignable(t.value);
        case "SpreadElement":
          return this.isAssignable(t.argument);
        case "ArrayExpression":
          return t.elements.every((i) => i === null || this.isAssignable(i));
        case "AssignmentExpression":
          return t.operator === "=";
        case "ParenthesizedExpression":
          return this.isAssignable(t.expression);
        case "MemberExpression":
        case "OptionalMemberExpression":
          return !r;
        default:
          return !1;
      }
    }
    toReferencedList(t, r) {
      return t;
    }
    toReferencedListDeep(t, r) {
      this.toReferencedList(t, r);
      for (let i of t)
        i?.type === "ArrayExpression" && this.toReferencedListDeep(i.elements);
    }
    parseSpread(t) {
      let r = this.startNode();
      return this.next(), r.argument = this.parseMaybeAssignAllowIn(t, void 0), this.finishNode(r, "SpreadElement");
    }
    parseRestBinding() {
      let t = this.startNode();
      return this.next(), t.argument = this.parseBindingAtom(), this.finishNode(t, "RestElement");
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case 0: {
          let t = this.startNode();
          return this.next(), t.elements = this.parseBindingList(3, 93, 1), this.finishNode(t, "ArrayPattern");
        }
        case 5:
          return this.parseObjectLike(8, !0);
      }
      return this.parseIdentifier();
    }
    parseBindingList(t, r, i) {
      let n = i & 1, a = [], o = !0;
      for (; !this.eat(t); )
        if (o ? o = !1 : this.expect(12), n && this.match(12))
          a.push(null);
        else {
          if (this.eat(t))
            break;
          if (this.match(21)) {
            let u = this.parseRestBinding();
            if ((this.hasPlugin("flow") || i & 2) && (u = this.parseFunctionParamType(u)), a.push(u), !this.checkCommaAfterRest(r)) {
              this.expect(t);
              break;
            }
          } else {
            let u = [];
            if (i & 2)
              for (this.match(26) && this.hasPlugin("decorators") && this.raise(Z.UnsupportedParameterDecorator, this.state.startLoc); this.
              match(26); )
                u.push(this.parseDecorator());
            a.push(this.parseBindingElement(i, u));
          }
        }
      return a;
    }
    parseBindingRestProperty(t) {
      return this.next(), t.argument = this.parseIdentifier(), this.checkCommaAfterRest(125), this.finishNode(t, "RestElement");
    }
    parseBindingProperty() {
      let {
        type: t,
        startLoc: r
      } = this.state;
      if (t === 21)
        return this.parseBindingRestProperty(this.startNode());
      let i = this.startNode();
      return t === 139 ? (this.expectPlugin("destructuringPrivate", r), this.classScope.usePrivateName(this.state.value, r), i.key = this.parsePrivateName()) :
      this.parsePropertyName(i), i.method = !1, this.parseObjPropValue(i, r, !1, !1, !0, !1);
    }
    parseBindingElement(t, r) {
      let i = this.parseMaybeDefault();
      (this.hasPlugin("flow") || t & 2) && this.parseFunctionParamType(i);
      let n = this.parseMaybeDefault(i.loc.start, i);
      return r.length && (i.decorators = r), n;
    }
    parseFunctionParamType(t) {
      return t;
    }
    parseMaybeDefault(t, r) {
      if (t ?? (t = this.state.startLoc), r = r ?? this.parseBindingAtom(), !this.eat(29)) return r;
      let i = this.startNodeAt(t);
      return i.left = r, i.right = this.parseMaybeAssignAllowIn(), this.finishNode(i, "AssignmentPattern");
    }
    isValidLVal(t, r, i) {
      switch (t) {
        case "AssignmentPattern":
          return "left";
        case "RestElement":
          return "argument";
        case "ObjectProperty":
          return "value";
        case "ParenthesizedExpression":
          return "expression";
        case "ArrayPattern":
          return "elements";
        case "ObjectPattern":
          return "properties";
      }
      return !1;
    }
    isOptionalMemberExpression(t) {
      return t.type === "OptionalMemberExpression";
    }
    checkLVal(t, r, i = 64, n = !1, a = !1, o = !1) {
      var u;
      let l = t.type;
      if (this.isObjectMethod(t)) return;
      let c = this.isOptionalMemberExpression(t);
      if (c || l === "MemberExpression") {
        c && (this.expectPlugin("optionalChainingAssign", t.loc.start), r.type !== "AssignmentExpression" && this.raise(Z.InvalidLhsOptionalChaining,
        t, {
          ancestor: r
        })), i !== 64 && this.raise(Z.InvalidPropertyBindingPattern, t);
        return;
      }
      if (l === "Identifier") {
        this.checkIdentifier(t, i, a);
        let {
          name: m
        } = t;
        n && (n.has(m) ? this.raise(Z.ParamDupe, t) : n.add(m));
        return;
      }
      let p = this.isValidLVal(l, !(o || (u = t.extra) != null && u.parenthesized) && r.type === "AssignmentExpression", i);
      if (p === !0) return;
      if (p === !1) {
        let m = i === 64 ? Z.InvalidLhs : Z.InvalidLhsBinding;
        this.raise(m, t, {
          ancestor: r
        });
        return;
      }
      let h, y;
      typeof p == "string" ? (h = p, y = l === "ParenthesizedExpression") : [h, y] = p;
      let _ = l === "ArrayPattern" || l === "ObjectPattern" ? {
        type: l
      } : r, g = t[h];
      if (Array.isArray(g))
        for (let m of g)
          m && this.checkLVal(m, _, i, n, a, y);
      else g && this.checkLVal(g, _, i, n, a, y);
    }
    checkIdentifier(t, r, i = !1) {
      this.state.strict && (i ? B9(t.name, this.inModule) : M9(t.name)) && (r === 64 ? this.raise(Z.StrictEvalArguments, t, {
        referenceName: t.name
      }) : this.raise(Z.StrictEvalArgumentsBinding, t, {
        bindingName: t.name
      })), r & 8192 && t.name === "let" && this.raise(Z.LetInLexicalBinding, t), r & 64 || this.declareNameFromIdentifier(t, r);
    }
    declareNameFromIdentifier(t, r) {
      this.scope.declareName(t.name, r, t.loc.start);
    }
    checkToRestConversion(t, r) {
      switch (t.type) {
        case "ParenthesizedExpression":
          this.checkToRestConversion(t.expression, r);
          break;
        case "Identifier":
        case "MemberExpression":
          break;
        case "ArrayExpression":
        case "ObjectExpression":
          if (r) break;
        default:
          this.raise(Z.InvalidRestAssignmentPattern, t);
      }
    }
    checkCommaAfterRest(t) {
      return this.match(12) ? (this.raise(this.lookaheadCharCode() === t ? Z.RestTrailingComma : Z.ElementAfterRest, this.state.startLoc), !0) :
      !1;
    }
  };
  function Dqe(e) {
    if (e == null)
      throw new Error(`Unexpected ${e} value.`);
    return e;
  }
  s(Dqe, "nonNull");
  function C9(e) {
    if (!e)
      throw new Error("Assert fail");
  }
  s(C9, "assert");
  var Je = Eu`typescript`({
    AbstractMethodHasImplementation: /* @__PURE__ */ s(({
      methodName: e
    }) => `Method '${e}' cannot have an implementation because it is marked abstract.`, "AbstractMethodHasImplementation"),
    AbstractPropertyHasInitializer: /* @__PURE__ */ s(({
      propertyName: e
    }) => `Property '${e}' cannot have an initializer because it is marked abstract.`, "AbstractPropertyHasInitializer"),
    AccessorCannotBeOptional: "An 'accessor' property cannot be declared optional.",
    AccessorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.",
    AccessorCannotHaveTypeParameters: "An accessor cannot have type parameters.",
    ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.",
    ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.",
    ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or num\
eric literal or literal enum reference.",
    ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.",
    DeclareAccessor: /* @__PURE__ */ s(({
      kind: e
    }) => `'declare' is not allowed in ${e}ters.`, "DeclareAccessor"),
    DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.",
    DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.",
    DuplicateAccessibilityModifier: /* @__PURE__ */ s(({
      modifier: e
    }) => "Accessibility modifier already seen.", "DuplicateAccessibilityModifier"),
    DuplicateModifier: /* @__PURE__ */ s(({
      modifier: e
    }) => `Duplicate modifier: '${e}'.`, "DuplicateModifier"),
    EmptyHeritageClauseType: /* @__PURE__ */ s(({
      token: e
    }) => `'${e}' list cannot be empty.`, "EmptyHeritageClauseType"),
    EmptyTypeArguments: "Type argument list cannot be empty.",
    EmptyTypeParameters: "Type parameter list cannot be empty.",
    ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.",
    ImportAliasHasImportType: "An import alias can not use 'import type'.",
    ImportReflectionHasImportType: "An `import module` declaration can not use `type` modifier",
    IncompatibleModifiers: /* @__PURE__ */ s(({
      modifiers: e
    }) => `'${e[0]}' modifier cannot be used with '${e[1]}' modifier.`, "IncompatibleModifiers"),
    IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.",
    IndexSignatureHasAccessibility: /* @__PURE__ */ s(({
      modifier: e
    }) => `Index signatures cannot have an accessibility modifier ('${e}').`, "IndexSignatureHasAccessibility"),
    IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.",
    IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.",
    IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.",
    InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.",
    InvalidHeritageClauseType: /* @__PURE__ */ s(({
      token: e
    }) => `'${e}' list can only include identifiers or qualified-names with optional type arguments.`, "InvalidHeritageClauseType"),
    InvalidModifierOnTypeMember: /* @__PURE__ */ s(({
      modifier: e
    }) => `'${e}' modifier cannot appear on a type member.`, "InvalidModifierOnTypeMember"),
    InvalidModifierOnTypeParameter: /* @__PURE__ */ s(({
      modifier: e
    }) => `'${e}' modifier cannot appear on a type parameter.`, "InvalidModifierOnTypeParameter"),
    InvalidModifierOnTypeParameterPositions: /* @__PURE__ */ s(({
      modifier: e
    }) => `'${e}' modifier can only appear on a type parameter of a class, interface or type alias.`, "InvalidModifierOnTypeParameterPositio\
ns"),
    InvalidModifiersOrder: /* @__PURE__ */ s(({
      orderedModifiers: e
    }) => `'${e[0]}' modifier must precede '${e[1]}' modifier.`, "InvalidModifiersOrder"),
    InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. You can either wrap the i\
nstantiation expression in parentheses, or delete the type arguments.",
    InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.",
    MissingInterfaceName: "'interface' declarations must be followed by an identifier.",
    NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.",
    NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.",
    OptionalTypeBeforeRequired: "A required element cannot follow an optional element.",
    OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.",
    PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
    PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
    PrivateElementHasAccessibility: /* @__PURE__ */ s(({
      modifier: e
    }) => `Private elements cannot have an accessibility modifier ('${e}').`, "PrivateElementHasAccessibility"),
    ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.",
    ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.",
    ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.",
    SetAccessorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.",
    SetAccessorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.",
    SetAccessorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.",
    SingleTypeParameterWithoutTrailingComma: /* @__PURE__ */ s(({
      typeParameterName: e
    }) => `Single type parameter ${e} should have a trailing comma. Example usage: <${e},>.`, "SingleTypeParameterWithoutTrailingComma"),
    StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.",
    TupleOptionalAfterType: "A labeled tuple optional element must be declared using a question mark after the name and before the colon (`n\
ame?: type`), rather than after the type (`name: type?`).",
    TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number =\
 25`.",
    TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.",
    TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statemen\
t.",
    TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statemen\
t.",
    UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.",
    UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
    UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
    UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",
    UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.",
    UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.",
    UnsupportedSignatureParameterKind: /* @__PURE__ */ s(({
      type: e
    }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${e}.`, "UnsupportedSignatureParameterKind")
  });
  function wqe(e) {
    switch (e) {
      case "any":
        return "TSAnyKeyword";
      case "boolean":
        return "TSBooleanKeyword";
      case "bigint":
        return "TSBigIntKeyword";
      case "never":
        return "TSNeverKeyword";
      case "number":
        return "TSNumberKeyword";
      case "object":
        return "TSObjectKeyword";
      case "string":
        return "TSStringKeyword";
      case "symbol":
        return "TSSymbolKeyword";
      case "undefined":
        return "TSUndefinedKeyword";
      case "unknown":
        return "TSUnknownKeyword";
      default:
        return;
    }
  }
  s(wqe, "keywordTypeFromName");
  function P9(e) {
    return e === "private" || e === "public" || e === "protected";
  }
  s(P9, "tsIsAccessModifier");
  function Oqe(e) {
    return e === "in" || e === "out";
  }
  s(Oqe, "tsIsVarianceAnnotations");
  var kqe = /* @__PURE__ */ s((e) => class extends e {
    static {
      s(this, "TypeScriptParserMixin");
    }
    constructor(...r) {
      super(...r), this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, {
        allowedModifiers: ["in", "out"],
        disallowedModifiers: ["const", "public", "private", "protected", "readonly", "declare", "abstract", "override"],
        errorTemplate: Je.InvalidModifierOnTypeParameter
      }), this.tsParseConstModifier = this.tsParseModifiers.bind(this, {
        allowedModifiers: ["const"],
        disallowedModifiers: ["in", "out"],
        errorTemplate: Je.InvalidModifierOnTypeParameterPositions
      }), this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, {
        allowedModifiers: ["in", "out", "const"],
        disallowedModifiers: ["public", "private", "protected", "readonly", "declare", "abstract", "override"],
        errorTemplate: Je.InvalidModifierOnTypeParameter
      });
    }
    getScopeHandler() {
      return SP;
    }
    tsIsIdentifier() {
      return Ar(this.state.type);
    }
    tsTokenCanFollowModifier() {
      return this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(139) || this.isLiteralPropertyName();
    }
    tsNextTokenOnSameLineAndCanFollowModifier() {
      return this.next(), this.hasPrecedingLineBreak() ? !1 : this.tsTokenCanFollowModifier();
    }
    tsNextTokenCanFollowModifier() {
      return this.match(106) ? (this.next(), this.tsTokenCanFollowModifier()) : this.tsNextTokenOnSameLineAndCanFollowModifier();
    }
    tsParseModifier(r, i) {
      if (!Ar(this.state.type) && this.state.type !== 58 && this.state.type !== 75)
        return;
      let n = this.state.value;
      if (r.includes(n)) {
        if (i && this.tsIsStartOfStaticBlocks())
          return;
        if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this)))
          return n;
      }
    }
    tsParseModifiers({
      allowedModifiers: r,
      disallowedModifiers: i,
      stopOnStartOfClassStaticBlock: n,
      errorTemplate: a = Je.InvalidModifierOnTypeMember
    }, o) {
      let u = /* @__PURE__ */ s((c, p, h, y) => {
        p === h && o[y] && this.raise(Je.InvalidModifiersOrder, c, {
          orderedModifiers: [h, y]
        });
      }, "enforceOrder"), l = /* @__PURE__ */ s((c, p, h, y) => {
        (o[h] && p === y || o[y] && p === h) && this.raise(Je.IncompatibleModifiers, c, {
          modifiers: [h, y]
        });
      }, "incompatible");
      for (; ; ) {
        let {
          startLoc: c
        } = this.state, p = this.tsParseModifier(r.concat(i ?? []), n);
        if (!p) break;
        P9(p) ? o.accessibility ? this.raise(Je.DuplicateAccessibilityModifier, c, {
          modifier: p
        }) : (u(c, p, p, "override"), u(c, p, p, "static"), u(c, p, p, "readonly"), o.accessibility = p) : Oqe(p) ? (o[p] && this.raise(Je.DuplicateModifier,
        c, {
          modifier: p
        }), o[p] = !0, u(c, p, "in", "out")) : (hasOwnProperty.call(o, p) ? this.raise(Je.DuplicateModifier, c, {
          modifier: p
        }) : (u(c, p, "static", "readonly"), u(c, p, "static", "override"), u(c, p, "override", "readonly"), u(c, p, "abstract", "override"),
        l(c, p, "declare", "override"), l(c, p, "static", "abstract")), o[p] = !0), i != null && i.includes(p) && this.raise(a, c, {
          modifier: p
        });
      }
    }
    tsIsListTerminator(r) {
      switch (r) {
        case "EnumMembers":
        case "TypeMembers":
          return this.match(8);
        case "HeritageClauseElement":
          return this.match(5);
        case "TupleElementTypes":
          return this.match(3);
        case "TypeParametersOrArguments":
          return this.match(48);
      }
    }
    tsParseList(r, i) {
      let n = [];
      for (; !this.tsIsListTerminator(r); )
        n.push(i());
      return n;
    }
    tsParseDelimitedList(r, i, n) {
      return Dqe(this.tsParseDelimitedListWorker(r, i, !0, n));
    }
    tsParseDelimitedListWorker(r, i, n, a) {
      let o = [], u = -1;
      for (; !this.tsIsListTerminator(r); ) {
        u = -1;
        let l = i();
        if (l == null)
          return;
        if (o.push(l), this.eat(12)) {
          u = this.state.lastTokStartLoc.index;
          continue;
        }
        if (this.tsIsListTerminator(r))
          break;
        n && this.expect(12);
        return;
      }
      return a && (a.value = u), o;
    }
    tsParseBracketedList(r, i, n, a, o) {
      a || (n ? this.expect(0) : this.expect(47));
      let u = this.tsParseDelimitedList(r, i, o);
      return n ? this.expect(3) : this.expect(48), u;
    }
    tsParseImportType() {
      let r = this.startNode();
      return this.expect(83), this.expect(10), this.match(134) ? r.argument = this.parseStringLiteral(this.state.value) : (this.raise(Je.UnsupportedImportTypeArgument,
      this.state.startLoc), r.argument = super.parseExprAtom()), this.eat(12) && !this.match(11) ? (r.options = super.parseMaybeAssignAllowIn(),
      this.eat(12)) : r.options = null, this.expect(11), this.eat(16) && (r.qualifier = this.tsParseEntityName(3)), this.match(47) && (r.typeParameters =
      this.tsParseTypeArguments()), this.finishNode(r, "TSImportType");
    }
    tsParseEntityName(r) {
      let i;
      if (r & 1 && this.match(78))
        if (r & 2)
          i = this.parseIdentifier(!0);
        else {
          let n = this.startNode();
          this.next(), i = this.finishNode(n, "ThisExpression");
        }
      else
        i = this.parseIdentifier(!!(r & 1));
      for (; this.eat(16); ) {
        let n = this.startNodeAtNode(i);
        n.left = i, n.right = this.parseIdentifier(!!(r & 1)), i = this.finishNode(n, "TSQualifiedName");
      }
      return i;
    }
    tsParseTypeReference() {
      let r = this.startNode();
      return r.typeName = this.tsParseEntityName(1), !this.hasPrecedingLineBreak() && this.match(47) && (r.typeParameters = this.tsParseTypeArguments()),
      this.finishNode(r, "TSTypeReference");
    }
    tsParseThisTypePredicate(r) {
      this.next();
      let i = this.startNodeAtNode(r);
      return i.parameterName = r, i.typeAnnotation = this.tsParseTypeAnnotation(!1), i.asserts = !1, this.finishNode(i, "TSTypePredicate");
    }
    tsParseThisTypeNode() {
      let r = this.startNode();
      return this.next(), this.finishNode(r, "TSThisType");
    }
    tsParseTypeQuery() {
      let r = this.startNode();
      return this.expect(87), this.match(83) ? r.exprName = this.tsParseImportType() : r.exprName = this.tsParseEntityName(3), !this.hasPrecedingLineBreak() &&
      this.match(47) && (r.typeParameters = this.tsParseTypeArguments()), this.finishNode(r, "TSTypeQuery");
    }
    tsParseTypeParameter(r) {
      let i = this.startNode();
      return r(i), i.name = this.tsParseTypeParameterName(), i.constraint = this.tsEatThenParseType(81), i.default = this.tsEatThenParseType(
      29), this.finishNode(i, "TSTypeParameter");
    }
    tsTryParseTypeParameters(r) {
      if (this.match(47))
        return this.tsParseTypeParameters(r);
    }
    tsParseTypeParameters(r) {
      let i = this.startNode();
      this.match(47) || this.match(143) ? this.next() : this.unexpected();
      let n = {
        value: -1
      };
      return i.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, r), !1, !0, n), i.params.
      length === 0 && this.raise(Je.EmptyTypeParameters, i), n.value !== -1 && this.addExtra(i, "trailingComma", n.value), this.finishNode(i,
      "TSTypeParameterDeclaration");
    }
    tsFillSignature(r, i) {
      let n = r === 19, a = "parameters", o = "typeAnnotation";
      i.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier), this.expect(10), i[a] = this.tsParseBindingListForSignature(),
      n ? i[o] = this.tsParseTypeOrTypePredicateAnnotation(r) : this.match(r) && (i[o] = this.tsParseTypeOrTypePredicateAnnotation(r));
    }
    tsParseBindingListForSignature() {
      let r = super.parseBindingList(11, 41, 2);
      for (let i of r) {
        let {
          type: n
        } = i;
        (n === "AssignmentPattern" || n === "TSParameterProperty") && this.raise(Je.UnsupportedSignatureParameterKind, i, {
          type: n
        });
      }
      return r;
    }
    tsParseTypeMemberSemicolon() {
      !this.eat(12) && !this.isLineTerminator() && this.expect(13);
    }
    tsParseSignatureMember(r, i) {
      return this.tsFillSignature(14, i), this.tsParseTypeMemberSemicolon(), this.finishNode(i, r);
    }
    tsIsUnambiguouslyIndexSignature() {
      return this.next(), Ar(this.state.type) ? (this.next(), this.match(14)) : !1;
    }
    tsTryParseIndexSignature(r) {
      if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this))))
        return;
      this.expect(0);
      let i = this.parseIdentifier();
      i.typeAnnotation = this.tsParseTypeAnnotation(), this.resetEndLocation(i), this.expect(3), r.parameters = [i];
      let n = this.tsTryParseTypeAnnotation();
      return n && (r.typeAnnotation = n), this.tsParseTypeMemberSemicolon(), this.finishNode(r, "TSIndexSignature");
    }
    tsParsePropertyOrMethodSignature(r, i) {
      this.eat(17) && (r.optional = !0);
      let n = r;
      if (this.match(10) || this.match(47)) {
        i && this.raise(Je.ReadonlyForMethodSignature, r);
        let a = n;
        a.kind && this.match(47) && this.raise(Je.AccessorCannotHaveTypeParameters, this.state.curPosition()), this.tsFillSignature(14, a), this.
        tsParseTypeMemberSemicolon();
        let o = "parameters", u = "typeAnnotation";
        if (a.kind === "get")
          a[o].length > 0 && (this.raise(Z.BadGetterArity, this.state.curPosition()), this.isThisParam(a[o][0]) && this.raise(Je.AccessorCannotDeclareThisParameter,
          this.state.curPosition()));
        else if (a.kind === "set") {
          if (a[o].length !== 1)
            this.raise(Z.BadSetterArity, this.state.curPosition());
          else {
            let l = a[o][0];
            this.isThisParam(l) && this.raise(Je.AccessorCannotDeclareThisParameter, this.state.curPosition()), l.type === "Identifier" && l.
            optional && this.raise(Je.SetAccessorCannotHaveOptionalParameter, this.state.curPosition()), l.type === "RestElement" && this.raise(
            Je.SetAccessorCannotHaveRestParameter, this.state.curPosition());
          }
          a[u] && this.raise(Je.SetAccessorCannotHaveReturnType, a[u]);
        } else
          a.kind = "method";
        return this.finishNode(a, "TSMethodSignature");
      } else {
        let a = n;
        i && (a.readonly = !0);
        let o = this.tsTryParseTypeAnnotation();
        return o && (a.typeAnnotation = o), this.tsParseTypeMemberSemicolon(), this.finishNode(a, "TSPropertySignature");
      }
    }
    tsParseTypeMember() {
      let r = this.startNode();
      if (this.match(10) || this.match(47))
        return this.tsParseSignatureMember("TSCallSignatureDeclaration", r);
      if (this.match(77)) {
        let n = this.startNode();
        return this.next(), this.match(10) || this.match(47) ? this.tsParseSignatureMember("TSConstructSignatureDeclaration", r) : (r.key = this.
        createIdentifier(n, "new"), this.tsParsePropertyOrMethodSignature(r, !1));
      }
      this.tsParseModifiers({
        allowedModifiers: ["readonly"],
        disallowedModifiers: ["declare", "abstract", "private", "protected", "public", "static", "override"]
      }, r);
      let i = this.tsTryParseIndexSignature(r);
      return i || (super.parsePropertyName(r), !r.computed && r.key.type === "Identifier" && (r.key.name === "get" || r.key.name === "set") &&
      this.tsTokenCanFollowModifier() && (r.kind = r.key.name, super.parsePropertyName(r)), this.tsParsePropertyOrMethodSignature(r, !!r.readonly));
    }
    tsParseTypeLiteral() {
      let r = this.startNode();
      return r.members = this.tsParseObjectTypeMembers(), this.finishNode(r, "TSTypeLiteral");
    }
    tsParseObjectTypeMembers() {
      this.expect(5);
      let r = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
      return this.expect(8), r;
    }
    tsIsStartOfMappedType() {
      return this.next(), this.eat(53) ? this.isContextual(122) : (this.isContextual(122) && this.next(), !this.match(0) || (this.next(), !this.
      tsIsIdentifier()) ? !1 : (this.next(), this.match(58)));
    }
    tsParseMappedType() {
      let r = this.startNode();
      this.expect(5), this.match(53) ? (r.readonly = this.state.value, this.next(), this.expectContextual(122)) : this.eatContextual(122) &&
      (r.readonly = !0), this.expect(0);
      {
        let i = this.startNode();
        i.name = this.tsParseTypeParameterName(), i.constraint = this.tsExpectThenParseType(58), r.typeParameter = this.finishNode(i, "TSTyp\
eParameter");
      }
      return r.nameType = this.eatContextual(93) ? this.tsParseType() : null, this.expect(3), this.match(53) ? (r.optional = this.state.value,
      this.next(), this.expect(17)) : this.eat(17) && (r.optional = !0), r.typeAnnotation = this.tsTryParseType(), this.semicolon(), this.expect(
      8), this.finishNode(r, "TSMappedType");
    }
    tsParseTupleType() {
      let r = this.startNode();
      r.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), !0, !1);
      let i = !1;
      return r.elementTypes.forEach((n) => {
        let {
          type: a
        } = n;
        i && a !== "TSRestType" && a !== "TSOptionalType" && !(a === "TSNamedTupleMember" && n.optional) && this.raise(Je.OptionalTypeBeforeRequired,
        n), i || (i = a === "TSNamedTupleMember" && n.optional || a === "TSOptionalType");
      }), this.finishNode(r, "TSTupleType");
    }
    tsParseTupleElementType() {
      let r = this.state.startLoc, i = this.eat(21), {
        startLoc: n
      } = this.state, a, o, u, l, p = Ga(this.state.type) ? this.lookaheadCharCode() : null;
      if (p === 58)
        a = !0, u = !1, o = this.parseIdentifier(!0), this.expect(14), l = this.tsParseType();
      else if (p === 63) {
        u = !0;
        let h = this.state.value, y = this.tsParseNonArrayType();
        this.lookaheadCharCode() === 58 ? (a = !0, o = this.createIdentifier(this.startNodeAt(n), h), this.expect(17), this.expect(14), l = this.
        tsParseType()) : (a = !1, l = y, this.expect(17));
      } else
        l = this.tsParseType(), u = this.eat(17), a = this.eat(14);
      if (a) {
        let h;
        o ? (h = this.startNodeAt(n), h.optional = u, h.label = o, h.elementType = l, this.eat(17) && (h.optional = !0, this.raise(Je.TupleOptionalAfterType,
        this.state.lastTokStartLoc))) : (h = this.startNodeAt(n), h.optional = u, this.raise(Je.InvalidTupleMemberLabel, l), h.label = l, h.
        elementType = this.tsParseType()), l = this.finishNode(h, "TSNamedTupleMember");
      } else if (u) {
        let h = this.startNodeAt(n);
        h.typeAnnotation = l, l = this.finishNode(h, "TSOptionalType");
      }
      if (i) {
        let h = this.startNodeAt(r);
        h.typeAnnotation = l, l = this.finishNode(h, "TSRestType");
      }
      return l;
    }
    tsParseParenthesizedType() {
      let r = this.startNode();
      return this.expect(10), r.typeAnnotation = this.tsParseType(), this.expect(11), this.finishNode(r, "TSParenthesizedType");
    }
    tsParseFunctionOrConstructorType(r, i) {
      let n = this.startNode();
      return r === "TSConstructorType" && (n.abstract = !!i, i && this.next(), this.next()), this.tsInAllowConditionalTypesContext(() => this.
      tsFillSignature(19, n)), this.finishNode(n, r);
    }
    tsParseLiteralTypeNode() {
      let r = this.startNode();
      switch (this.state.type) {
        case 135:
        case 136:
        case 134:
        case 85:
        case 86:
          r.literal = super.parseExprAtom();
          break;
        default:
          this.unexpected();
      }
      return this.finishNode(r, "TSLiteralType");
    }
    tsParseTemplateLiteralType() {
      {
        let r = this.startNode();
        return r.literal = super.parseTemplate(!1), this.finishNode(r, "TSLiteralType");
      }
    }
    parseTemplateSubstitution() {
      return this.state.inType ? this.tsParseType() : super.parseTemplateSubstitution();
    }
    tsParseThisTypeOrThisTypePredicate() {
      let r = this.tsParseThisTypeNode();
      return this.isContextual(116) && !this.hasPrecedingLineBreak() ? this.tsParseThisTypePredicate(r) : r;
    }
    tsParseNonArrayType() {
      switch (this.state.type) {
        case 134:
        case 135:
        case 136:
        case 85:
        case 86:
          return this.tsParseLiteralTypeNode();
        case 53:
          if (this.state.value === "-") {
            let r = this.startNode(), i = this.lookahead();
            return i.type !== 135 && i.type !== 136 && this.unexpected(), r.literal = this.parseMaybeUnary(), this.finishNode(r, "TSLiteralT\
ype");
          }
          break;
        case 78:
          return this.tsParseThisTypeOrThisTypePredicate();
        case 87:
          return this.tsParseTypeQuery();
        case 83:
          return this.tsParseImportType();
        case 5:
          return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
        case 0:
          return this.tsParseTupleType();
        case 10:
          return this.tsParseParenthesizedType();
        case 25:
        case 24:
          return this.tsParseTemplateLiteralType();
        default: {
          let {
            type: r
          } = this.state;
          if (Ar(r) || r === 88 || r === 84) {
            let i = r === 88 ? "TSVoidKeyword" : r === 84 ? "TSNullKeyword" : wqe(this.state.value);
            if (i !== void 0 && this.lookaheadCharCode() !== 46) {
              let n = this.startNode();
              return this.next(), this.finishNode(n, i);
            }
            return this.tsParseTypeReference();
          }
        }
      }
      this.unexpected();
    }
    tsParseArrayTypeOrHigher() {
      let {
        startLoc: r
      } = this.state, i = this.tsParseNonArrayType();
      for (; !this.hasPrecedingLineBreak() && this.eat(0); )
        if (this.match(3)) {
          let n = this.startNodeAt(r);
          n.elementType = i, this.expect(3), i = this.finishNode(n, "TSArrayType");
        } else {
          let n = this.startNodeAt(r);
          n.objectType = i, n.indexType = this.tsParseType(), this.expect(3), i = this.finishNode(n, "TSIndexedAccessType");
        }
      return i;
    }
    tsParseTypeOperator() {
      let r = this.startNode(), i = this.state.value;
      return this.next(), r.operator = i, r.typeAnnotation = this.tsParseTypeOperatorOrHigher(), i === "readonly" && this.tsCheckTypeAnnotationForReadOnly(
      r), this.finishNode(r, "TSTypeOperator");
    }
    tsCheckTypeAnnotationForReadOnly(r) {
      switch (r.typeAnnotation.type) {
        case "TSTupleType":
        case "TSArrayType":
          return;
        default:
          this.raise(Je.UnexpectedReadonly, r);
      }
    }
    tsParseInferType() {
      let r = this.startNode();
      this.expectContextual(115);
      let i = this.startNode();
      return i.name = this.tsParseTypeParameterName(), i.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType()), r.typeParameter =
      this.finishNode(i, "TSTypeParameter"), this.finishNode(r, "TSInferType");
    }
    tsParseConstraintForInferType() {
      if (this.eat(81)) {
        let r = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
        if (this.state.inDisallowConditionalTypesContext || !this.match(17))
          return r;
      }
    }
    tsParseTypeOperatorOrHigher() {
      return X3e(this.state.type) && !this.state.containsEsc ? this.tsParseTypeOperator() : this.isContextual(115) ? this.tsParseInferType() :
      this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
    }
    tsParseUnionOrIntersectionType(r, i, n) {
      let a = this.startNode(), o = this.eat(n), u = [];
      do
        u.push(i());
      while (this.eat(n));
      return u.length === 1 && !o ? u[0] : (a.types = u, this.finishNode(a, r));
    }
    tsParseIntersectionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
    }
    tsParseUnionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
    }
    tsIsStartOfFunctionType() {
      return this.match(47) ? !0 : this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
    }
    tsSkipParameterStart() {
      if (Ar(this.state.type) || this.match(78))
        return this.next(), !0;
      if (this.match(5)) {
        let {
          errors: r
        } = this.state, i = r.length;
        try {
          return this.parseObjectLike(8, !0), r.length === i;
        } catch {
          return !1;
        }
      }
      if (this.match(0)) {
        this.next();
        let {
          errors: r
        } = this.state, i = r.length;
        try {
          return super.parseBindingList(3, 93, 1), r.length === i;
        } catch {
          return !1;
        }
      }
      return !1;
    }
    tsIsUnambiguouslyStartOfFunctionType() {
      return this.next(), !!(this.match(11) || this.match(21) || this.tsSkipParameterStart() && (this.match(14) || this.match(12) || this.match(
      17) || this.match(29) || this.match(11) && (this.next(), this.match(19))));
    }
    tsParseTypeOrTypePredicateAnnotation(r) {
      return this.tsInType(() => {
        let i = this.startNode();
        this.expect(r);
        let n = this.startNode(), a = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
        if (a && this.match(78)) {
          let l = this.tsParseThisTypeOrThisTypePredicate();
          return l.type === "TSThisType" ? (n.parameterName = l, n.asserts = !0, n.typeAnnotation = null, l = this.finishNode(n, "TSTypePred\
icate")) : (this.resetStartLocationFromNode(l, n), l.asserts = !0), i.typeAnnotation = l, this.finishNode(i, "TSTypeAnnotation");
        }
        let o = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
        if (!o)
          return a ? (n.parameterName = this.parseIdentifier(), n.asserts = a, n.typeAnnotation = null, i.typeAnnotation = this.finishNode(n,
          "TSTypePredicate"), this.finishNode(i, "TSTypeAnnotation")) : this.tsParseTypeAnnotation(!1, i);
        let u = this.tsParseTypeAnnotation(!1);
        return n.parameterName = o, n.typeAnnotation = u, n.asserts = a, i.typeAnnotation = this.finishNode(n, "TSTypePredicate"), this.finishNode(
        i, "TSTypeAnnotation");
      });
    }
    tsTryParseTypeOrTypePredicateAnnotation() {
      if (this.match(14))
        return this.tsParseTypeOrTypePredicateAnnotation(14);
    }
    tsTryParseTypeAnnotation() {
      if (this.match(14))
        return this.tsParseTypeAnnotation();
    }
    tsTryParseType() {
      return this.tsEatThenParseType(14);
    }
    tsParseTypePredicatePrefix() {
      let r = this.parseIdentifier();
      if (this.isContextual(116) && !this.hasPrecedingLineBreak())
        return this.next(), r;
    }
    tsParseTypePredicateAsserts() {
      if (this.state.type !== 109)
        return !1;
      let r = this.state.containsEsc;
      return this.next(), !Ar(this.state.type) && !this.match(78) ? !1 : (r && this.raise(Z.InvalidEscapedReservedWord, this.state.lastTokStartLoc,
      {
        reservedWord: "asserts"
      }), !0);
    }
    tsParseTypeAnnotation(r = !0, i = this.startNode()) {
      return this.tsInType(() => {
        r && this.expect(14), i.typeAnnotation = this.tsParseType();
      }), this.finishNode(i, "TSTypeAnnotation");
    }
    tsParseType() {
      C9(this.state.inType);
      let r = this.tsParseNonConditionalType();
      if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81))
        return r;
      let i = this.startNodeAtNode(r);
      return i.checkType = r, i.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType()), this.expect(
      17), i.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.expect(14), i.falseType = this.tsInAllowConditionalTypesContext(
      () => this.tsParseType()), this.finishNode(i, "TSConditionalType");
    }
    isAbstractConstructorSignature() {
      return this.isContextual(124) && this.lookahead().type === 77;
    }
    tsParseNonConditionalType() {
      return this.tsIsStartOfFunctionType() ? this.tsParseFunctionOrConstructorType("TSFunctionType") : this.match(77) ? this.tsParseFunctionOrConstructorType(
      "TSConstructorType") : this.isAbstractConstructorSignature() ? this.tsParseFunctionOrConstructorType("TSConstructorType", !0) : this.tsParseUnionTypeOrHigher();
    }
    tsParseTypeAssertion() {
      this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(Je.ReservedTypeAssertion, this.state.startLoc);
      let r = this.startNode();
      return r.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? this.tsParseTypeReference() : this.tsParseType())), this.
      expect(48), r.expression = this.parseMaybeUnary(), this.finishNode(r, "TSTypeAssertion");
    }
    tsParseHeritageClause(r) {
      let i = this.state.startLoc, n = this.tsParseDelimitedList("HeritageClauseElement", () => {
        {
          let a = this.startNode();
          return a.expression = this.tsParseEntityName(3), this.match(47) && (a.typeParameters = this.tsParseTypeArguments()), this.finishNode(
          a, "TSExpressionWithTypeArguments");
        }
      });
      return n.length || this.raise(Je.EmptyHeritageClauseType, i, {
        token: r
      }), n;
    }
    tsParseInterfaceDeclaration(r, i = {}) {
      if (this.hasFollowingLineBreak()) return null;
      this.expectContextual(129), i.declare && (r.declare = !0), Ar(this.state.type) ? (r.id = this.parseIdentifier(), this.checkIdentifier(
      r.id, 130)) : (r.id = null, this.raise(Je.MissingInterfaceName, this.state.startLoc)), r.typeParameters = this.tsTryParseTypeParameters(
      this.tsParseInOutConstModifiers), this.eat(81) && (r.extends = this.tsParseHeritageClause("extends"));
      let n = this.startNode();
      return n.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this)), r.body = this.finishNode(n, "TSInterfaceBody"), this.finishNode(
      r, "TSInterfaceDeclaration");
    }
    tsParseTypeAliasDeclaration(r) {
      return r.id = this.parseIdentifier(), this.checkIdentifier(r.id, 2), r.typeAnnotation = this.tsInType(() => {
        if (r.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers), this.expect(29), this.isContextual(114) && this.lookahead().
        type !== 16) {
          let i = this.startNode();
          return this.next(), this.finishNode(i, "TSIntrinsicKeyword");
        }
        return this.tsParseType();
      }), this.semicolon(), this.finishNode(r, "TSTypeAliasDeclaration");
    }
    tsInTopLevelContext(r) {
      if (this.curContext() !== Er.brace) {
        let i = this.state.context;
        this.state.context = [i[0]];
        try {
          return r();
        } finally {
          this.state.context = i;
        }
      } else
        return r();
    }
    tsInType(r) {
      let i = this.state.inType;
      this.state.inType = !0;
      try {
        return r();
      } finally {
        this.state.inType = i;
      }
    }
    tsInDisallowConditionalTypesContext(r) {
      let i = this.state.inDisallowConditionalTypesContext;
      this.state.inDisallowConditionalTypesContext = !0;
      try {
        return r();
      } finally {
        this.state.inDisallowConditionalTypesContext = i;
      }
    }
    tsInAllowConditionalTypesContext(r) {
      let i = this.state.inDisallowConditionalTypesContext;
      this.state.inDisallowConditionalTypesContext = !1;
      try {
        return r();
      } finally {
        this.state.inDisallowConditionalTypesContext = i;
      }
    }
    tsEatThenParseType(r) {
      if (this.match(r))
        return this.tsNextThenParseType();
    }
    tsExpectThenParseType(r) {
      return this.tsInType(() => (this.expect(r), this.tsParseType()));
    }
    tsNextThenParseType() {
      return this.tsInType(() => (this.next(), this.tsParseType()));
    }
    tsParseEnumMember() {
      let r = this.startNode();
      return r.id = this.match(134) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(!0), this.eat(29) && (r.initializer =
      super.parseMaybeAssignAllowIn()), this.finishNode(r, "TSEnumMember");
    }
    tsParseEnumDeclaration(r, i = {}) {
      return i.const && (r.const = !0), i.declare && (r.declare = !0), this.expectContextual(126), r.id = this.parseIdentifier(), this.checkIdentifier(
      r.id, r.const ? 8971 : 8459), this.expect(5), r.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)),
      this.expect(8), this.finishNode(r, "TSEnumDeclaration");
    }
    tsParseEnumBody() {
      let r = this.startNode();
      return this.expect(5), r.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)), this.expect(8), this.finishNode(
      r, "TSEnumBody");
    }
    tsParseModuleBlock() {
      let r = this.startNode();
      return this.scope.enter(0), this.expect(5), super.parseBlockOrModuleBlockBody(r.body = [], void 0, !0, 8), this.scope.exit(), this.finishNode(
      r, "TSModuleBlock");
    }
    tsParseModuleOrNamespaceDeclaration(r, i = !1) {
      if (r.id = this.parseIdentifier(), i || this.checkIdentifier(r.id, 1024), this.eat(16)) {
        let n = this.startNode();
        this.tsParseModuleOrNamespaceDeclaration(n, !0), r.body = n;
      } else
        this.scope.enter(256), this.prodParam.enter(0), r.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit();
      return this.finishNode(r, "TSModuleDeclaration");
    }
    tsParseAmbientExternalModuleDeclaration(r) {
      return this.isContextual(112) ? (r.kind = "global", r.global = !0, r.id = this.parseIdentifier()) : this.match(134) ? (r.kind = "modul\
e", r.id = super.parseStringLiteral(this.state.value)) : this.unexpected(), this.match(5) ? (this.scope.enter(256), this.prodParam.enter(0),
      r.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit()) : this.semicolon(), this.finishNode(r, "TSModuleDeclarat\
ion");
    }
    tsParseImportEqualsDeclaration(r, i, n) {
      r.isExport = n || !1, r.id = i || this.parseIdentifier(), this.checkIdentifier(r.id, 4096), this.expect(29);
      let a = this.tsParseModuleReference();
      return r.importKind === "type" && a.type !== "TSExternalModuleReference" && this.raise(Je.ImportAliasHasImportType, a), r.moduleReference =
      a, this.semicolon(), this.finishNode(r, "TSImportEqualsDeclaration");
    }
    tsIsExternalModuleReference() {
      return this.isContextual(119) && this.lookaheadCharCode() === 40;
    }
    tsParseModuleReference() {
      return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(0);
    }
    tsParseExternalModuleReference() {
      let r = this.startNode();
      return this.expectContextual(119), this.expect(10), this.match(134) || this.unexpected(), r.expression = super.parseExprAtom(), this.expect(
      11), this.sawUnambiguousESM = !0, this.finishNode(r, "TSExternalModuleReference");
    }
    tsLookAhead(r) {
      let i = this.state.clone(), n = r();
      return this.state = i, n;
    }
    tsTryParseAndCatch(r) {
      let i = this.tryParse((n) => r() || n());
      if (!(i.aborted || !i.node))
        return i.error && (this.state = i.failState), i.node;
    }
    tsTryParse(r) {
      let i = this.state.clone(), n = r();
      if (n !== void 0 && n !== !1)
        return n;
      this.state = i;
    }
    tsTryParseDeclare(r) {
      if (this.isLineTerminator())
        return;
      let i = this.state.type, n;
      return this.isContextual(100) && (i = 74, n = "let"), this.tsInAmbientContext(() => {
        switch (i) {
          case 68:
            return r.declare = !0, super.parseFunctionStatement(r, !1, !1);
          case 80:
            return r.declare = !0, this.parseClass(r, !0, !1);
          case 126:
            return this.tsParseEnumDeclaration(r, {
              declare: !0
            });
          case 112:
            return this.tsParseAmbientExternalModuleDeclaration(r);
          case 75:
          case 74:
            return !this.match(75) || !this.isLookaheadContextual("enum") ? (r.declare = !0, this.parseVarStatement(r, n || this.state.value,
            !0)) : (this.expect(75), this.tsParseEnumDeclaration(r, {
              const: !0,
              declare: !0
            }));
          case 129: {
            let a = this.tsParseInterfaceDeclaration(r, {
              declare: !0
            });
            if (a) return a;
          }
          default:
            if (Ar(i))
              return this.tsParseDeclaration(r, this.state.value, !0, null);
        }
      });
    }
    tsTryParseExportDeclaration() {
      return this.tsParseDeclaration(this.startNode(), this.state.value, !0, null);
    }
    tsParseExpressionStatement(r, i, n) {
      switch (i.name) {
        case "declare": {
          let a = this.tsTryParseDeclare(r);
          return a && (a.declare = !0), a;
        }
        case "global":
          if (this.match(5)) {
            this.scope.enter(256), this.prodParam.enter(0);
            let a = r;
            return a.kind = "global", r.global = !0, a.id = i, a.body = this.tsParseModuleBlock(), this.scope.exit(), this.prodParam.exit(),
            this.finishNode(a, "TSModuleDeclaration");
          }
          break;
        default:
          return this.tsParseDeclaration(r, i.name, !1, n);
      }
    }
    tsParseDeclaration(r, i, n, a) {
      switch (i) {
        case "abstract":
          if (this.tsCheckLineTerminator(n) && (this.match(80) || Ar(this.state.type)))
            return this.tsParseAbstractDeclaration(r, a);
          break;
        case "module":
          if (this.tsCheckLineTerminator(n)) {
            if (this.match(134))
              return this.tsParseAmbientExternalModuleDeclaration(r);
            if (Ar(this.state.type))
              return r.kind = "module", this.tsParseModuleOrNamespaceDeclaration(r);
          }
          break;
        case "namespace":
          if (this.tsCheckLineTerminator(n) && Ar(this.state.type))
            return r.kind = "namespace", this.tsParseModuleOrNamespaceDeclaration(r);
          break;
        case "type":
          if (this.tsCheckLineTerminator(n) && Ar(this.state.type))
            return this.tsParseTypeAliasDeclaration(r);
          break;
      }
    }
    tsCheckLineTerminator(r) {
      return r ? this.hasFollowingLineBreak() ? !1 : (this.next(), !0) : !this.isLineTerminator();
    }
    tsTryParseGenericAsyncArrowFunction(r) {
      if (!this.match(47)) return;
      let i = this.state.maybeInArrowParameters;
      this.state.maybeInArrowParameters = !0;
      let n = this.tsTryParseAndCatch(() => {
        let a = this.startNodeAt(r);
        return a.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier), super.parseFunctionParams(a), a.returnType = this.tsTryParseTypeOrTypePredicateAnnotation(),
        this.expect(19), a;
      });
      if (this.state.maybeInArrowParameters = i, !!n)
        return super.parseArrowExpression(n, null, !0);
    }
    tsParseTypeArgumentsInExpression() {
      if (this.reScan_lt() === 47)
        return this.tsParseTypeArguments();
    }
    tsParseTypeArguments() {
      let r = this.startNode();
      return r.params = this.tsInType(() => this.tsInTopLevelContext(() => (this.expect(47), this.tsParseDelimitedList("TypeParametersOrArgu\
ments", this.tsParseType.bind(this))))), r.params.length === 0 ? this.raise(Je.EmptyTypeArguments, r) : !this.state.inType && this.curContext() ===
      Er.brace && this.reScan_lt_gt(), this.expect(48), this.finishNode(r, "TSTypeParameterInstantiation");
    }
    tsIsDeclarationStart() {
      return Y3e(this.state.type);
    }
    isExportDefaultSpecifier() {
      return this.tsIsDeclarationStart() ? !1 : super.isExportDefaultSpecifier();
    }
    parseBindingElement(r, i) {
      let n = this.state.startLoc, a = {};
      this.tsParseModifiers({
        allowedModifiers: ["public", "private", "protected", "override", "readonly"]
      }, a);
      let o = a.accessibility, u = a.override, l = a.readonly;
      !(r & 4) && (o || l || u) && this.raise(Je.UnexpectedParameterModifier, n);
      let c = this.parseMaybeDefault();
      r & 2 && this.parseFunctionParamType(c);
      let p = this.parseMaybeDefault(c.loc.start, c);
      if (o || l || u) {
        let h = this.startNodeAt(n);
        return i.length && (h.decorators = i), o && (h.accessibility = o), l && (h.readonly = l), u && (h.override = u), p.type !== "Identif\
ier" && p.type !== "AssignmentPattern" && this.raise(Je.UnsupportedParameterPropertyKind, h), h.parameter = p, this.finishNode(h, "TSParamet\
erProperty");
      }
      return i.length && (c.decorators = i), p;
    }
    isSimpleParameter(r) {
      return r.type === "TSParameterProperty" && super.isSimpleParameter(r.parameter) || super.isSimpleParameter(r);
    }
    tsDisallowOptionalPattern(r) {
      for (let i of r.params)
        i.type !== "Identifier" && i.optional && !this.state.isAmbientContext && this.raise(Je.PatternIsOptional, i);
    }
    setArrowFunctionParameters(r, i, n) {
      super.setArrowFunctionParameters(r, i, n), this.tsDisallowOptionalPattern(r);
    }
    parseFunctionBodyAndFinish(r, i, n = !1) {
      this.match(14) && (r.returnType = this.tsParseTypeOrTypePredicateAnnotation(14));
      let a = i === "FunctionDeclaration" ? "TSDeclareFunction" : i === "ClassMethod" || i === "ClassPrivateMethod" ? "TSDeclareMethod" : void 0;
      return a && !this.match(5) && this.isLineTerminator() ? this.finishNode(r, a) : a === "TSDeclareFunction" && this.state.isAmbientContext &&
      (this.raise(Je.DeclareFunctionHasImplementation, r), r.declare) ? super.parseFunctionBodyAndFinish(r, a, n) : (this.tsDisallowOptionalPattern(
      r), super.parseFunctionBodyAndFinish(r, i, n));
    }
    registerFunctionStatementId(r) {
      !r.body && r.id ? this.checkIdentifier(r.id, 1024) : super.registerFunctionStatementId(r);
    }
    tsCheckForInvalidTypeCasts(r) {
      r.forEach((i) => {
        i?.type === "TSTypeCastExpression" && this.raise(Je.UnexpectedTypeAnnotation, i.typeAnnotation);
      });
    }
    toReferencedList(r, i) {
      return this.tsCheckForInvalidTypeCasts(r), r;
    }
    parseArrayLike(r, i, n, a) {
      let o = super.parseArrayLike(r, i, n, a);
      return o.type === "ArrayExpression" && this.tsCheckForInvalidTypeCasts(o.elements), o;
    }
    parseSubscript(r, i, n, a) {
      if (!this.hasPrecedingLineBreak() && this.match(35)) {
        this.state.canStartJSXElement = !1, this.next();
        let u = this.startNodeAt(i);
        return u.expression = r, this.finishNode(u, "TSNonNullExpression");
      }
      let o = !1;
      if (this.match(18) && this.lookaheadCharCode() === 60) {
        if (n)
          return a.stop = !0, r;
        a.optionalChainMember = o = !0, this.next();
      }
      if (this.match(47) || this.match(51)) {
        let u, l = this.tsTryParseAndCatch(() => {
          if (!n && this.atPossibleAsyncArrow(r)) {
            let y = this.tsTryParseGenericAsyncArrowFunction(i);
            if (y)
              return y;
          }
          let c = this.tsParseTypeArgumentsInExpression();
          if (!c) return;
          if (o && !this.match(10)) {
            u = this.state.curPosition();
            return;
          }
          if (V_(this.state.type)) {
            let y = super.parseTaggedTemplateExpression(r, i, a);
            return y.typeParameters = c, y;
          }
          if (!n && this.eat(10)) {
            let y = this.startNodeAt(i);
            return y.callee = r, y.arguments = this.parseCallExpressionArguments(11), this.tsCheckForInvalidTypeCasts(y.arguments), y.typeParameters =
            c, a.optionalChainMember && (y.optional = o), this.finishCallExpression(y, a.optionalChainMember);
          }
          let p = this.state.type;
          if (p === 48 || p === 52 || p !== 10 && Ed(p) && !this.hasPrecedingLineBreak())
            return;
          let h = this.startNodeAt(i);
          return h.expression = r, h.typeParameters = c, this.finishNode(h, "TSInstantiationExpression");
        });
        if (u && this.unexpected(u, 10), l)
          return l.type === "TSInstantiationExpression" && (this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40) && this.raise(
          Je.InvalidPropertyAccessAfterInstantiationExpression, this.state.startLoc), l;
      }
      return super.parseSubscript(r, i, n, a);
    }
    parseNewCallee(r) {
      var i;
      super.parseNewCallee(r);
      let {
        callee: n
      } = r;
      n.type === "TSInstantiationExpression" && !((i = n.extra) != null && i.parenthesized) && (r.typeParameters = n.typeParameters, r.callee =
      n.expression);
    }
    parseExprOp(r, i, n) {
      let a;
      if (q_(58) > n && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (a = this.isContextual(120)))) {
        let o = this.startNodeAt(i);
        return o.expression = r, o.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? (a && this.raise(Z.UnexpectedKeyword,
        this.state.startLoc, {
          keyword: "const"
        }), this.tsParseTypeReference()) : this.tsParseType())), this.finishNode(o, a ? "TSSatisfiesExpression" : "TSAsExpression"), this.reScan_lt_gt(),
        this.parseExprOp(o, i, n);
      }
      return super.parseExprOp(r, i, n);
    }
    checkReservedWord(r, i, n, a) {
      this.state.isAmbientContext || super.checkReservedWord(r, i, n, a);
    }
    checkImportReflection(r) {
      super.checkImportReflection(r), r.module && r.importKind !== "value" && this.raise(Je.ImportReflectionHasImportType, r.specifiers[0].loc.
      start);
    }
    checkDuplicateExports() {
    }
    isPotentialImportPhase(r) {
      if (super.isPotentialImportPhase(r)) return !0;
      if (this.isContextual(130)) {
        let i = this.lookaheadCharCode();
        return r ? i === 123 || i === 42 : i !== 61;
      }
      return !r && this.isContextual(87);
    }
    applyImportPhase(r, i, n, a) {
      super.applyImportPhase(r, i, n, a), i ? r.exportKind = n === "type" ? "type" : "value" : r.importKind = n === "type" || n === "typeof" ?
      n : "value";
    }
    parseImport(r) {
      if (this.match(134))
        return r.importKind = "value", super.parseImport(r);
      let i;
      if (Ar(this.state.type) && this.lookaheadCharCode() === 61)
        return r.importKind = "value", this.tsParseImportEqualsDeclaration(r);
      if (this.isContextual(130)) {
        let n = this.parseMaybeImportPhase(r, !1);
        if (this.lookaheadCharCode() === 61)
          return this.tsParseImportEqualsDeclaration(r, n);
        i = super.parseImportSpecifiersAndAfter(r, n);
      } else
        i = super.parseImport(r);
      return i.importKind === "type" && i.specifiers.length > 1 && i.specifiers[0].type === "ImportDefaultSpecifier" && this.raise(Je.TypeImportCannotSpecifyDefaultAndNamed,
      i), i;
    }
    parseExport(r, i) {
      if (this.match(83)) {
        let n = r;
        this.next();
        let a = null;
        return this.isContextual(130) && this.isPotentialImportPhase(!1) ? a = this.parseMaybeImportPhase(n, !1) : n.importKind = "value", this.
        tsParseImportEqualsDeclaration(n, a, !0);
      } else if (this.eat(29)) {
        let n = r;
        return n.expression = super.parseExpression(), this.semicolon(), this.sawUnambiguousESM = !0, this.finishNode(n, "TSExportAssignment");
      } else if (this.eatContextual(93)) {
        let n = r;
        return this.expectContextual(128), n.id = this.parseIdentifier(), this.semicolon(), this.finishNode(n, "TSNamespaceExportDeclaration");
      } else
        return super.parseExport(r, i);
    }
    isAbstractClass() {
      return this.isContextual(124) && this.lookahead().type === 80;
    }
    parseExportDefaultExpression() {
      if (this.isAbstractClass()) {
        let r = this.startNode();
        return this.next(), r.abstract = !0, this.parseClass(r, !0, !0);
      }
      if (this.match(129)) {
        let r = this.tsParseInterfaceDeclaration(this.startNode());
        if (r) return r;
      }
      return super.parseExportDefaultExpression();
    }
    parseVarStatement(r, i, n = !1) {
      let {
        isAmbientContext: a
      } = this.state, o = super.parseVarStatement(r, i, n || a);
      if (!a) return o;
      for (let {
        id: u,
        init: l
      } of o.declarations)
        l && (i !== "const" || u.typeAnnotation ? this.raise(Je.InitializerNotAllowedInAmbientContext, l) : Rqe(l, this.hasPlugin("estree")) ||
        this.raise(Je.ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference, l));
      return o;
    }
    parseStatementContent(r, i) {
      if (this.match(75) && this.isLookaheadContextual("enum")) {
        let n = this.startNode();
        return this.expect(75), this.tsParseEnumDeclaration(n, {
          const: !0
        });
      }
      if (this.isContextual(126))
        return this.tsParseEnumDeclaration(this.startNode());
      if (this.isContextual(129)) {
        let n = this.tsParseInterfaceDeclaration(this.startNode());
        if (n) return n;
      }
      return super.parseStatementContent(r, i);
    }
    parseAccessModifier() {
      return this.tsParseModifier(["public", "protected", "private"]);
    }
    tsHasSomeModifiers(r, i) {
      return i.some((n) => P9(n) ? r.accessibility === n : !!r[n]);
    }
    tsIsStartOfStaticBlocks() {
      return this.isContextual(106) && this.lookaheadCharCode() === 123;
    }
    parseClassMember(r, i, n) {
      let a = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
      this.tsParseModifiers({
        allowedModifiers: a,
        disallowedModifiers: ["in", "out"],
        stopOnStartOfClassStaticBlock: !0,
        errorTemplate: Je.InvalidModifierOnTypeParameterPositions
      }, i);
      let o = /* @__PURE__ */ s(() => {
        this.tsIsStartOfStaticBlocks() ? (this.next(), this.next(), this.tsHasSomeModifiers(i, a) && this.raise(Je.StaticBlockCannotHaveModifier,
        this.state.curPosition()), super.parseClassStaticBlock(r, i)) : this.parseClassMemberWithIsStatic(r, i, n, !!i.static);
      }, "callParseClassMemberWithIsStatic");
      i.declare ? this.tsInAmbientContext(o) : o();
    }
    parseClassMemberWithIsStatic(r, i, n, a) {
      let o = this.tsTryParseIndexSignature(i);
      if (o) {
        r.body.push(o), i.abstract && this.raise(Je.IndexSignatureHasAbstract, i), i.accessibility && this.raise(Je.IndexSignatureHasAccessibility,
        i, {
          modifier: i.accessibility
        }), i.declare && this.raise(Je.IndexSignatureHasDeclare, i), i.override && this.raise(Je.IndexSignatureHasOverride, i);
        return;
      }
      !this.state.inAbstractClass && i.abstract && this.raise(Je.NonAbstractClassHasAbstractMethod, i), i.override && (n.hadSuperClass || this.
      raise(Je.OverrideNotInSubClass, i)), super.parseClassMemberWithIsStatic(r, i, n, a);
    }
    parsePostMemberNameModifiers(r) {
      this.eat(17) && (r.optional = !0), r.readonly && this.match(10) && this.raise(Je.ClassMethodHasReadonly, r), r.declare && this.match(10) &&
      this.raise(Je.ClassMethodHasDeclare, r);
    }
    parseExpressionStatement(r, i, n) {
      return (i.type === "Identifier" ? this.tsParseExpressionStatement(r, i, n) : void 0) || super.parseExpressionStatement(r, i, n);
    }
    shouldParseExportDeclaration() {
      return this.tsIsDeclarationStart() ? !0 : super.shouldParseExportDeclaration();
    }
    parseConditional(r, i, n) {
      if (!this.match(17)) return r;
      if (this.state.maybeInArrowParameters) {
        let a = this.lookaheadCharCode();
        if (a === 44 || a === 61 || a === 58 || a === 41)
          return this.setOptionalParametersError(n), r;
      }
      return super.parseConditional(r, i, n);
    }
    parseParenItem(r, i) {
      let n = super.parseParenItem(r, i);
      if (this.eat(17) && (n.optional = !0, this.resetEndLocation(r)), this.match(14)) {
        let a = this.startNodeAt(i);
        return a.expression = r, a.typeAnnotation = this.tsParseTypeAnnotation(), this.finishNode(a, "TSTypeCastExpression");
      }
      return r;
    }
    parseExportDeclaration(r) {
      if (!this.state.isAmbientContext && this.isContextual(125))
        return this.tsInAmbientContext(() => this.parseExportDeclaration(r));
      let i = this.state.startLoc, n = this.eatContextual(125);
      if (n && (this.isContextual(125) || !this.shouldParseExportDeclaration()))
        throw this.raise(Je.ExpectedAmbientAfterExportDeclare, this.state.startLoc);
      let o = Ar(this.state.type) && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(r);
      return o ? ((o.type === "TSInterfaceDeclaration" || o.type === "TSTypeAliasDeclaration" || n) && (r.exportKind = "type"), n && o.type !==
      "TSImportEqualsDeclaration" && (this.resetStartLocation(o, i), o.declare = !0), o) : null;
    }
    parseClassId(r, i, n, a) {
      if ((!i || n) && this.isContextual(113))
        return;
      super.parseClassId(r, i, n, r.declare ? 1024 : 8331);
      let o = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
      o && (r.typeParameters = o);
    }
    parseClassPropertyAnnotation(r) {
      r.optional || (this.eat(35) ? r.definite = !0 : this.eat(17) && (r.optional = !0));
      let i = this.tsTryParseTypeAnnotation();
      i && (r.typeAnnotation = i);
    }
    parseClassProperty(r) {
      if (this.parseClassPropertyAnnotation(r), this.state.isAmbientContext && !(r.readonly && !r.typeAnnotation) && this.match(29) && this.
      raise(Je.DeclareClassFieldHasInitializer, this.state.startLoc), r.abstract && this.match(29)) {
        let {
          key: i
        } = r;
        this.raise(Je.AbstractPropertyHasInitializer, this.state.startLoc, {
          propertyName: i.type === "Identifier" && !r.computed ? i.name : `[${this.input.slice(this.offsetToSourcePos(i.start), this.offsetToSourcePos(
          i.end))}]`
        });
      }
      return super.parseClassProperty(r);
    }
    parseClassPrivateProperty(r) {
      return r.abstract && this.raise(Je.PrivateElementHasAbstract, r), r.accessibility && this.raise(Je.PrivateElementHasAccessibility, r, {
        modifier: r.accessibility
      }), this.parseClassPropertyAnnotation(r), super.parseClassPrivateProperty(r);
    }
    parseClassAccessorProperty(r) {
      return this.parseClassPropertyAnnotation(r), r.optional && this.raise(Je.AccessorCannotBeOptional, r), super.parseClassAccessorProperty(
      r);
    }
    pushClassMethod(r, i, n, a, o, u) {
      let l = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      l && o && this.raise(Je.ConstructorHasTypeParameters, l);
      let {
        declare: c = !1,
        kind: p
      } = i;
      c && (p === "get" || p === "set") && this.raise(Je.DeclareAccessor, i, {
        kind: p
      }), l && (i.typeParameters = l), super.pushClassMethod(r, i, n, a, o, u);
    }
    pushClassPrivateMethod(r, i, n, a) {
      let o = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      o && (i.typeParameters = o), super.pushClassPrivateMethod(r, i, n, a);
    }
    declareClassPrivateMethodInScope(r, i) {
      r.type !== "TSDeclareMethod" && (r.type === "MethodDefinition" && !hasOwnProperty.call(r.value, "body") || super.declareClassPrivateMethodInScope(
      r, i));
    }
    parseClassSuper(r) {
      super.parseClassSuper(r), r.superClass && (this.match(47) || this.match(51)) && (r.superTypeParameters = this.tsParseTypeArgumentsInExpression()),
      this.eatContextual(113) && (r.implements = this.tsParseHeritageClause("implements"));
    }
    parseObjPropValue(r, i, n, a, o, u, l) {
      let c = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      return c && (r.typeParameters = c), super.parseObjPropValue(r, i, n, a, o, u, l);
    }
    parseFunctionParams(r, i) {
      let n = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      n && (r.typeParameters = n), super.parseFunctionParams(r, i);
    }
    parseVarId(r, i) {
      super.parseVarId(r, i), r.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.eat(35) && (r.definite = !0);
      let n = this.tsTryParseTypeAnnotation();
      n && (r.id.typeAnnotation = n, this.resetEndLocation(r.id));
    }
    parseAsyncArrowFromCallExpression(r, i) {
      return this.match(14) && (r.returnType = this.tsParseTypeAnnotation()), super.parseAsyncArrowFromCallExpression(r, i);
    }
    parseMaybeAssign(r, i) {
      var n, a, o, u, l;
      let c, p, h;
      if (this.hasPlugin("jsx") && (this.match(143) || this.match(47))) {
        if (c = this.state.clone(), p = this.tryParse(() => super.parseMaybeAssign(r, i), c), !p.error) return p.node;
        let {
          context: g
        } = this.state, m = g[g.length - 1];
        (m === Er.j_oTag || m === Er.j_expr) && g.pop();
      }
      if (!((n = p) != null && n.error) && !this.match(47))
        return super.parseMaybeAssign(r, i);
      (!c || c === this.state) && (c = this.state.clone());
      let y, _ = this.tryParse((g) => {
        var m, f;
        y = this.tsParseTypeParameters(this.tsParseConstModifier);
        let d = super.parseMaybeAssign(r, i);
        return (d.type !== "ArrowFunctionExpression" || (m = d.extra) != null && m.parenthesized) && g(), ((f = y) == null ? void 0 : f.params.
        length) !== 0 && this.resetStartLocationFromNode(d, y), d.typeParameters = y, d;
      }, c);
      if (!_.error && !_.aborted)
        return y && this.reportReservedArrowTypeParam(y), _.node;
      if (!p && (C9(!this.hasPlugin("jsx")), h = this.tryParse(() => super.parseMaybeAssign(r, i), c), !h.error))
        return h.node;
      if ((a = p) != null && a.node)
        return this.state = p.failState, p.node;
      if (_.node)
        return this.state = _.failState, y && this.reportReservedArrowTypeParam(y), _.node;
      if ((o = h) != null && o.node)
        return this.state = h.failState, h.node;
      throw ((u = p) == null ? void 0 : u.error) || _.error || ((l = h) == null ? void 0 : l.error);
    }
    reportReservedArrowTypeParam(r) {
      var i;
      r.params.length === 1 && !r.params[0].constraint && !((i = r.extra) != null && i.trailingComma) && this.getPluginOption("typescript", "\
disallowAmbiguousJSXLike") && this.raise(Je.ReservedArrowTypeParam, r);
    }
    parseMaybeUnary(r, i) {
      return !this.hasPlugin("jsx") && this.match(47) ? this.tsParseTypeAssertion() : super.parseMaybeUnary(r, i);
    }
    parseArrow(r) {
      if (this.match(14)) {
        let i = this.tryParse((n) => {
          let a = this.tsParseTypeOrTypePredicateAnnotation(14);
          return (this.canInsertSemicolon() || !this.match(19)) && n(), a;
        });
        if (i.aborted) return;
        i.thrown || (i.error && (this.state = i.failState), r.returnType = i.node);
      }
      return super.parseArrow(r);
    }
    parseFunctionParamType(r) {
      this.eat(17) && (r.optional = !0);
      let i = this.tsTryParseTypeAnnotation();
      return i && (r.typeAnnotation = i), this.resetEndLocation(r), r;
    }
    isAssignable(r, i) {
      switch (r.type) {
        case "TSTypeCastExpression":
          return this.isAssignable(r.expression, i);
        case "TSParameterProperty":
          return !0;
        default:
          return super.isAssignable(r, i);
      }
    }
    toAssignable(r, i = !1) {
      switch (r.type) {
        case "ParenthesizedExpression":
          this.toAssignableParenthesizedExpression(r, i);
          break;
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
          i ? this.expressionScope.recordArrowParameterBindingError(Je.UnexpectedTypeCastInParameter, r) : this.raise(Je.UnexpectedTypeCastInParameter,
          r), this.toAssignable(r.expression, i);
          break;
        case "AssignmentExpression":
          !i && r.left.type === "TSTypeCastExpression" && (r.left = this.typeCastToParameter(r.left));
        default:
          super.toAssignable(r, i);
      }
    }
    toAssignableParenthesizedExpression(r, i) {
      switch (r.expression.type) {
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
        case "ParenthesizedExpression":
          this.toAssignable(r.expression, i);
          break;
        default:
          super.toAssignable(r, i);
      }
    }
    checkToRestConversion(r, i) {
      switch (r.type) {
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
        case "TSNonNullExpression":
          this.checkToRestConversion(r.expression, !1);
          break;
        default:
          super.checkToRestConversion(r, i);
      }
    }
    isValidLVal(r, i, n) {
      switch (r) {
        case "TSTypeCastExpression":
          return !0;
        case "TSParameterProperty":
          return "parameter";
        case "TSNonNullExpression":
          return "expression";
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
          return (n !== 64 || !i) && ["expression", !0];
        default:
          return super.isValidLVal(r, i, n);
      }
    }
    parseBindingAtom() {
      return this.state.type === 78 ? this.parseIdentifier(!0) : super.parseBindingAtom();
    }
    parseMaybeDecoratorArguments(r, i) {
      if (this.match(47) || this.match(51)) {
        let n = this.tsParseTypeArgumentsInExpression();
        if (this.match(10)) {
          let a = super.parseMaybeDecoratorArguments(r, i);
          return a.typeParameters = n, a;
        }
        this.unexpected(null, 10);
      }
      return super.parseMaybeDecoratorArguments(r, i);
    }
    checkCommaAfterRest(r) {
      return this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === r ? (this.next(), !1) : super.checkCommaAfterRest(
      r);
    }
    isClassMethod() {
      return this.match(47) || super.isClassMethod();
    }
    isClassProperty() {
      return this.match(35) || this.match(14) || super.isClassProperty();
    }
    parseMaybeDefault(r, i) {
      let n = super.parseMaybeDefault(r, i);
      return n.type === "AssignmentPattern" && n.typeAnnotation && n.right.start < n.typeAnnotation.start && this.raise(Je.TypeAnnotationAfterAssign,
      n.typeAnnotation), n;
    }
    getTokenFromCode(r) {
      if (this.state.inType) {
        if (r === 62) {
          this.finishOp(48, 1);
          return;
        }
        if (r === 60) {
          this.finishOp(47, 1);
          return;
        }
      }
      super.getTokenFromCode(r);
    }
    reScan_lt_gt() {
      let {
        type: r
      } = this.state;
      r === 47 ? (this.state.pos -= 1, this.readToken_lt()) : r === 48 && (this.state.pos -= 1, this.readToken_gt());
    }
    reScan_lt() {
      let {
        type: r
      } = this.state;
      return r === 51 ? (this.state.pos -= 2, this.finishOp(47, 1), 47) : r;
    }
    toAssignableListItem(r, i, n) {
      let a = r[i];
      a.type === "TSTypeCastExpression" && (r[i] = this.typeCastToParameter(a)), super.toAssignableListItem(r, i, n);
    }
    typeCastToParameter(r) {
      return r.expression.typeAnnotation = r.typeAnnotation, this.resetEndLocation(r.expression, r.typeAnnotation.loc.end), r.expression;
    }
    shouldParseArrow(r) {
      return this.match(14) ? r.every((i) => this.isAssignable(i, !0)) : super.shouldParseArrow(r);
    }
    shouldParseAsyncArrow() {
      return this.match(14) || super.shouldParseAsyncArrow();
    }
    canHaveLeadingDecorator() {
      return super.canHaveLeadingDecorator() || this.isAbstractClass();
    }
    jsxParseOpeningElementAfterName(r) {
      if (this.match(47) || this.match(51)) {
        let i = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
        i && (r.typeParameters = i);
      }
      return super.jsxParseOpeningElementAfterName(r);
    }
    getGetterSetterExpectedParamCount(r) {
      let i = super.getGetterSetterExpectedParamCount(r), a = this.getObjectOrClassMethodParams(r)[0];
      return a && this.isThisParam(a) ? i + 1 : i;
    }
    parseCatchClauseParam() {
      let r = super.parseCatchClauseParam(), i = this.tsTryParseTypeAnnotation();
      return i && (r.typeAnnotation = i, this.resetEndLocation(r)), r;
    }
    tsInAmbientContext(r) {
      let {
        isAmbientContext: i,
        strict: n
      } = this.state;
      this.state.isAmbientContext = !0, this.state.strict = !1;
      try {
        return r();
      } finally {
        this.state.isAmbientContext = i, this.state.strict = n;
      }
    }
    parseClass(r, i, n) {
      let a = this.state.inAbstractClass;
      this.state.inAbstractClass = !!r.abstract;
      try {
        return super.parseClass(r, i, n);
      } finally {
        this.state.inAbstractClass = a;
      }
    }
    tsParseAbstractDeclaration(r, i) {
      if (this.match(80))
        return r.abstract = !0, this.maybeTakeDecorators(i, this.parseClass(r, !0, !1));
      if (this.isContextual(129)) {
        if (!this.hasFollowingLineBreak())
          return r.abstract = !0, this.raise(Je.NonClassMethodPropertyHasAbstractModifer, r), this.tsParseInterfaceDeclaration(r);
      } else
        this.unexpected(null, 80);
    }
    parseMethod(r, i, n, a, o, u, l) {
      let c = super.parseMethod(r, i, n, a, o, u, l);
      if (c.abstract && (this.hasPlugin("estree") ? c.value : c).body) {
        let {
          key: y
        } = c;
        this.raise(Je.AbstractMethodHasImplementation, c, {
          methodName: y.type === "Identifier" && !c.computed ? y.name : `[${this.input.slice(this.offsetToSourcePos(y.start), this.offsetToSourcePos(
          y.end))}]`
        });
      }
      return c;
    }
    tsParseTypeParameterName() {
      return this.parseIdentifier().name;
    }
    shouldParseAsAmbientContext() {
      return !!this.getPluginOption("typescript", "dts");
    }
    parse() {
      return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.parse();
    }
    getExpression() {
      return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.getExpression();
    }
    parseExportSpecifier(r, i, n, a) {
      return !i && a ? (this.parseTypeOnlyImportExportSpecifier(r, !1, n), this.finishNode(r, "ExportSpecifier")) : (r.exportKind = "value",
      super.parseExportSpecifier(r, i, n, a));
    }
    parseImportSpecifier(r, i, n, a, o) {
      return !i && a ? (this.parseTypeOnlyImportExportSpecifier(r, !0, n), this.finishNode(r, "ImportSpecifier")) : (r.importKind = "value",
      super.parseImportSpecifier(r, i, n, a, n ? 4098 : 4096));
    }
    parseTypeOnlyImportExportSpecifier(r, i, n) {
      let a = i ? "imported" : "local", o = i ? "local" : "exported", u = r[a], l, c = !1, p = !0, h = u.loc.start;
      if (this.isContextual(93)) {
        let _ = this.parseIdentifier();
        if (this.isContextual(93)) {
          let g = this.parseIdentifier();
          Ga(this.state.type) ? (c = !0, u = _, l = i ? this.parseIdentifier() : this.parseModuleExportName(), p = !1) : (l = g, p = !1);
        } else Ga(this.state.type) ? (p = !1, l = i ? this.parseIdentifier() : this.parseModuleExportName()) : (c = !0, u = _);
      } else Ga(this.state.type) && (c = !0, i ? (u = this.parseIdentifier(!0), this.isContextual(93) || this.checkReservedWord(u.name, u.loc.
      start, !0, !0)) : u = this.parseModuleExportName());
      c && n && this.raise(i ? Je.TypeModifierIsUsedInTypeImports : Je.TypeModifierIsUsedInTypeExports, h), r[a] = u, r[o] = l;
      let y = i ? "importKind" : "exportKind";
      r[y] = c ? "type" : "value", p && this.eatContextual(93) && (r[o] = i ? this.parseIdentifier() : this.parseModuleExportName()), r[o] ||
      (r[o] = Au(r[a])), i && this.checkIdentifier(r[o], c ? 4098 : 4096);
    }
  }, "typescript");
  function Iqe(e) {
    if (e.type !== "MemberExpression") return !1;
    let {
      computed: t,
      property: r
    } = e;
    return t && r.type !== "StringLiteral" && (r.type !== "TemplateLiteral" || r.expressions.length > 0) ? !1 : z9(e.object);
  }
  s(Iqe, "isPossiblyLiteralEnum");
  function Rqe(e, t) {
    var r;
    let {
      type: i
    } = e;
    if ((r = e.extra) != null && r.parenthesized)
      return !1;
    if (t) {
      if (i === "Literal") {
        let {
          value: n
        } = e;
        if (typeof n == "string" || typeof n == "boolean")
          return !0;
      }
    } else if (i === "StringLiteral" || i === "BooleanLiteral")
      return !0;
    return !!(H9(e, t) || Nqe(e, t) || i === "TemplateLiteral" && e.expressions.length === 0 || Iqe(e));
  }
  s(Rqe, "isValidAmbientConstInitializer");
  function H9(e, t) {
    return t ? e.type === "Literal" && (typeof e.value == "number" || "bigint" in e) : e.type === "NumericLiteral" || e.type === "BigIntLite\
ral";
  }
  s(H9, "isNumber");
  function Nqe(e, t) {
    if (e.type === "UnaryExpression") {
      let {
        operator: r,
        argument: i
      } = e;
      if (r === "-" && H9(i, t))
        return !0;
    }
    return !1;
  }
  s(Nqe, "isNegativeNumber");
  function z9(e) {
    return e.type === "Identifier" ? !0 : e.type !== "MemberExpression" || e.computed ? !1 : z9(e.object);
  }
  s(z9, "isUncomputedMemberExpressionChain");
  var D9 = Eu`placeholders`({
    ClassNameIsRequired: "A class name is required.",
    UnexpectedSpace: "Unexpected space in placeholder."
  }), Lqe = /* @__PURE__ */ s((e) => class extends e {
    static {
      s(this, "PlaceholdersParserMixin");
    }
    parsePlaceholder(r) {
      if (this.match(133)) {
        let i = this.startNode();
        return this.next(), this.assertNoSpace(), i.name = super.parseIdentifier(!0), this.assertNoSpace(), this.expect(133), this.finishPlaceholder(
        i, r);
      }
    }
    finishPlaceholder(r, i) {
      let n = r;
      return (!n.expectedNode || !n.type) && (n = this.finishNode(n, "Placeholder")), n.expectedNode = i, n;
    }
    getTokenFromCode(r) {
      r === 37 && this.input.charCodeAt(this.state.pos + 1) === 37 ? this.finishOp(133, 2) : super.getTokenFromCode(r);
    }
    parseExprAtom(r) {
      return this.parsePlaceholder("Expression") || super.parseExprAtom(r);
    }
    parseIdentifier(r) {
      return this.parsePlaceholder("Identifier") || super.parseIdentifier(r);
    }
    checkReservedWord(r, i, n, a) {
      r !== void 0 && super.checkReservedWord(r, i, n, a);
    }
    parseBindingAtom() {
      return this.parsePlaceholder("Pattern") || super.parseBindingAtom();
    }
    isValidLVal(r, i, n) {
      return r === "Placeholder" || super.isValidLVal(r, i, n);
    }
    toAssignable(r, i) {
      r && r.type === "Placeholder" && r.expectedNode === "Expression" ? r.expectedNode = "Pattern" : super.toAssignable(r, i);
    }
    chStartsBindingIdentifier(r, i) {
      return !!(super.chStartsBindingIdentifier(r, i) || this.lookahead().type === 133);
    }
    verifyBreakContinue(r, i) {
      r.label && r.label.type === "Placeholder" || super.verifyBreakContinue(r, i);
    }
    parseExpressionStatement(r, i) {
      var n;
      if (i.type !== "Placeholder" || (n = i.extra) != null && n.parenthesized)
        return super.parseExpressionStatement(r, i);
      if (this.match(14)) {
        let o = r;
        return o.label = this.finishPlaceholder(i, "Identifier"), this.next(), o.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration(),
        this.finishNode(o, "LabeledStatement");
      }
      this.semicolon();
      let a = r;
      return a.name = i.name, this.finishPlaceholder(a, "Statement");
    }
    parseBlock(r, i, n) {
      return this.parsePlaceholder("BlockStatement") || super.parseBlock(r, i, n);
    }
    parseFunctionId(r) {
      return this.parsePlaceholder("Identifier") || super.parseFunctionId(r);
    }
    parseClass(r, i, n) {
      let a = i ? "ClassDeclaration" : "ClassExpression";
      this.next();
      let o = this.state.strict, u = this.parsePlaceholder("Identifier");
      if (u)
        if (this.match(81) || this.match(133) || this.match(5))
          r.id = u;
        else {
          if (n || !i)
            return r.id = null, r.body = this.finishPlaceholder(u, "ClassBody"), this.finishNode(r, a);
          throw this.raise(D9.ClassNameIsRequired, this.state.startLoc);
        }
      else
        this.parseClassId(r, i, n);
      return super.parseClassSuper(r), r.body = this.parsePlaceholder("ClassBody") || super.parseClassBody(!!r.superClass, o), this.finishNode(
      r, a);
    }
    parseExport(r, i) {
      let n = this.parsePlaceholder("Identifier");
      if (!n) return super.parseExport(r, i);
      let a = r;
      if (!this.isContextual(98) && !this.match(12))
        return a.specifiers = [], a.source = null, a.declaration = this.finishPlaceholder(n, "Declaration"), this.finishNode(a, "ExportNamed\
Declaration");
      this.expectPlugin("exportDefaultFrom");
      let o = this.startNode();
      return o.exported = n, a.specifiers = [this.finishNode(o, "ExportDefaultSpecifier")], super.parseExport(a, i);
    }
    isExportDefaultSpecifier() {
      if (this.match(65)) {
        let r = this.nextTokenStart();
        if (this.isUnparsedContextual(r, "from") && this.input.startsWith(ml(133), this.nextTokenStartSince(r + 4)))
          return !0;
      }
      return super.isExportDefaultSpecifier();
    }
    maybeParseExportDefaultSpecifier(r, i) {
      var n;
      return (n = r.specifiers) != null && n.length ? !0 : super.maybeParseExportDefaultSpecifier(r, i);
    }
    checkExport(r) {
      let {
        specifiers: i
      } = r;
      i != null && i.length && (r.specifiers = i.filter((n) => n.exported.type === "Placeholder")), super.checkExport(r), r.specifiers = i;
    }
    parseImport(r) {
      let i = this.parsePlaceholder("Identifier");
      if (!i) return super.parseImport(r);
      if (r.specifiers = [], !this.isContextual(98) && !this.match(12))
        return r.source = this.finishPlaceholder(i, "StringLiteral"), this.semicolon(), this.finishNode(r, "ImportDeclaration");
      let n = this.startNodeAtNode(i);
      return n.local = i, r.specifiers.push(this.finishNode(n, "ImportDefaultSpecifier")), this.eat(12) && (this.maybeParseStarImportSpecifier(
      r) || this.parseNamedImportSpecifiers(r)), this.expectContextual(98), r.source = this.parseImportSource(), this.semicolon(), this.finishNode(
      r, "ImportDeclaration");
    }
    parseImportSource() {
      return this.parsePlaceholder("StringLiteral") || super.parseImportSource();
    }
    assertNoSpace() {
      this.state.start > this.offsetToSourcePos(this.state.lastTokEndLoc.index) && this.raise(D9.UnexpectedSpace, this.state.lastTokEndLoc);
    }
  }, "placeholders"), Fqe = /* @__PURE__ */ s((e) => class extends e {
    static {
      s(this, "V8IntrinsicMixin");
    }
    parseV8Intrinsic() {
      if (this.match(54)) {
        let r = this.state.startLoc, i = this.startNode();
        if (this.next(), Ar(this.state.type)) {
          let n = this.parseIdentifierName(), a = this.createIdentifier(i, n);
          if (a.type = "V8IntrinsicIdentifier", this.match(10))
            return a;
        }
        this.unexpected(r);
      }
    }
    parseExprAtom(r) {
      return this.parseV8Intrinsic() || super.parseExprAtom(r);
    }
  }, "v8intrinsic"), w9 = ["minimal", "fsharp", "hack", "smart"], O9 = ["^^", "@@", "^", "%", "#"];
  function Mqe(e) {
    if (e.has("decorators")) {
      if (e.has("decorators-legacy"))
        throw new Error("Cannot use the decorators and decorators-legacy plugin together");
      let r = e.get("decorators").decoratorsBeforeExport;
      if (r != null && typeof r != "boolean")
        throw new Error("'decoratorsBeforeExport' must be a boolean, if specified.");
      let i = e.get("decorators").allowCallParenthesized;
      if (i != null && typeof i != "boolean")
        throw new Error("'allowCallParenthesized' must be a boolean.");
    }
    if (e.has("flow") && e.has("typescript"))
      throw new Error("Cannot combine flow and typescript plugins.");
    if (e.has("placeholders") && e.has("v8intrinsic"))
      throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
    if (e.has("pipelineOperator")) {
      var t;
      let r = e.get("pipelineOperator").proposal;
      if (!w9.includes(r)) {
        let n = w9.map((a) => `"${a}"`).join(", ");
        throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${n}.`);
      }
      let i = ((t = e.get("recordAndTuple")) == null ? void 0 : t.syntaxType) === "hash";
      if (r === "hack") {
        if (e.has("placeholders"))
          throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
        if (e.has("v8intrinsic"))
          throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
        let n = e.get("pipelineOperator").topicToken;
        if (!O9.includes(n)) {
          let a = O9.map((o) => `"${o}"`).join(", ");
          throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${a}\
.`);
        }
        if (n === "#" && i)
          throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "hack", topicToken: "#" }]\` and \`${JSON.stringify(["\
recordAndTuple", e.get("recordAndTuple")])}\`.`);
      } else if (r === "smart" && i)
        throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "smart" }]\` and \`${JSON.stringify(["recordAndTuple", e.
        get("recordAndTuple")])}\`.`);
    }
    if (e.has("moduleAttributes")) {
      if (e.has("deprecatedImportAssert") || e.has("importAssertions"))
        throw new Error("Cannot combine importAssertions, deprecatedImportAssert and moduleAttributes plugins.");
      if (e.get("moduleAttributes").version !== "may-2020")
        throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the on\
ly supported value is 'may-2020'.");
    }
    if (e.has("importAssertions") && e.has("deprecatedImportAssert"))
      throw new Error("Cannot combine importAssertions and deprecatedImportAssert plugins.");
    if (!e.has("deprecatedImportAssert") && e.has("importAttributes") && e.get("importAttributes").deprecatedAssertSyntax && e.set("deprecat\
edImportAssert", {}), e.has("recordAndTuple")) {
      let r = e.get("recordAndTuple").syntaxType;
      if (r != null) {
        let i = ["hash", "bar"];
        if (!i.includes(r))
          throw new Error("The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " + i.map((n) => `'${n}'`).join(", "));
      }
    }
    if (e.has("asyncDoExpressions") && !e.has("doExpressions")) {
      let r = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
      throw r.missingPlugins = "doExpressions", r;
    }
    if (e.has("optionalChainingAssign") && e.get("optionalChainingAssign").version !== "2023-07")
      throw new Error("The 'optionalChainingAssign' plugin requires a 'version' option, representing the last proposal update. Currently, th\
e only supported value is '2023-07'.");
  }
  s(Mqe, "validatePlugins");
  var G9 = {
    estree: q3e,
    jsx: Pqe,
    flow: xqe,
    typescript: kqe,
    v8intrinsic: Fqe,
    placeholders: Lqe
  }, Bqe = Object.keys(G9), EP = class extends TP {
    static {
      s(this, "ExpressionParser");
    }
    checkProto(t, r, i, n) {
      if (t.type === "SpreadElement" || this.isObjectMethod(t) || t.computed || t.shorthand)
        return i;
      let a = t.key;
      return (a.type === "Identifier" ? a.name : a.value) === "__proto__" ? r ? (this.raise(Z.RecordNoProto, a), !0) : (i && (n ? n.doubleProtoLoc ===
      null && (n.doubleProtoLoc = a.loc.start) : this.raise(Z.DuplicateProto, a)), !0) : i;
    }
    shouldExitDescending(t, r) {
      return t.type === "ArrowFunctionExpression" && this.offsetToSourcePos(t.start) === r;
    }
    getExpression() {
      this.enterInitialScopes(), this.nextToken();
      let t = this.parseExpression();
      return this.match(140) || this.unexpected(), this.finalizeRemainingComments(), t.comments = this.comments, t.errors = this.state.errors,
      this.optionFlags & 256 && (t.tokens = this.tokens), t;
    }
    parseExpression(t, r) {
      return t ? this.disallowInAnd(() => this.parseExpressionBase(r)) : this.allowInAnd(() => this.parseExpressionBase(r));
    }
    parseExpressionBase(t) {
      let r = this.state.startLoc, i = this.parseMaybeAssign(t);
      if (this.match(12)) {
        let n = this.startNodeAt(r);
        for (n.expressions = [i]; this.eat(12); )
          n.expressions.push(this.parseMaybeAssign(t));
        return this.toReferencedList(n.expressions), this.finishNode(n, "SequenceExpression");
      }
      return i;
    }
    parseMaybeAssignDisallowIn(t, r) {
      return this.disallowInAnd(() => this.parseMaybeAssign(t, r));
    }
    parseMaybeAssignAllowIn(t, r) {
      return this.allowInAnd(() => this.parseMaybeAssign(t, r));
    }
    setOptionalParametersError(t) {
      t.optionalParametersLoc = this.state.startLoc;
    }
    parseMaybeAssign(t, r) {
      let i = this.state.startLoc, n = this.isContextual(108);
      if (n && this.prodParam.hasYield) {
        this.next();
        let l = this.parseYield(i);
        return r && (l = r.call(this, l, i)), l;
      }
      let a;
      t ? a = !1 : (t = new ip(), a = !0);
      let {
        type: o
      } = this.state;
      (o === 10 || Ar(o)) && (this.state.potentialArrowAt = this.state.start);
      let u = this.parseMaybeConditional(t);
      if (r && (u = r.call(this, u, i)), H3e(this.state.type)) {
        let l = this.startNodeAt(i), c = this.state.value;
        if (l.operator = c, this.match(29)) {
          this.toAssignable(u, !0), l.left = u;
          let p = i.index;
          t.doubleProtoLoc != null && t.doubleProtoLoc.index >= p && (t.doubleProtoLoc = null), t.shorthandAssignLoc != null && t.shorthandAssignLoc.
          index >= p && (t.shorthandAssignLoc = null), t.privateKeyLoc != null && t.privateKeyLoc.index >= p && (this.checkDestructuringPrivate(
          t), t.privateKeyLoc = null);
        } else
          l.left = u;
        return this.next(), l.right = this.parseMaybeAssign(), this.checkLVal(u, this.finishNode(l, "AssignmentExpression")), l;
      } else a && this.checkExpressionErrors(t, !0);
      if (n) {
        let {
          type: l
        } = this.state;
        if ((this.hasPlugin("v8intrinsic") ? Ed(l) : Ed(l) && !this.match(54)) && !this.isAmbiguousPrefixOrIdentifier())
          return this.raiseOverwrite(Z.YieldNotInGeneratorFunction, i), this.parseYield(i);
      }
      return u;
    }
    parseMaybeConditional(t) {
      let r = this.state.startLoc, i = this.state.potentialArrowAt, n = this.parseExprOps(t);
      return this.shouldExitDescending(n, i) ? n : this.parseConditional(n, r, t);
    }
    parseConditional(t, r, i) {
      if (this.eat(17)) {
        let n = this.startNodeAt(r);
        return n.test = t, n.consequent = this.parseMaybeAssignAllowIn(), this.expect(14), n.alternate = this.parseMaybeAssign(), this.finishNode(
        n, "ConditionalExpression");
      }
      return t;
    }
    parseMaybeUnaryOrPrivate(t) {
      return this.match(139) ? this.parsePrivateName() : this.parseMaybeUnary(t);
    }
    parseExprOps(t) {
      let r = this.state.startLoc, i = this.state.potentialArrowAt, n = this.parseMaybeUnaryOrPrivate(t);
      return this.shouldExitDescending(n, i) ? n : this.parseExprOp(n, r, -1);
    }
    parseExprOp(t, r, i) {
      if (this.isPrivateName(t)) {
        let a = this.getPrivateNameSV(t);
        (i >= q_(58) || !this.prodParam.hasIn || !this.match(58)) && this.raise(Z.PrivateInExpectedIn, t, {
          identifierName: a
        }), this.classScope.usePrivateName(a, t.loc.start);
      }
      let n = this.state.type;
      if (G3e(n) && (this.prodParam.hasIn || !this.match(58))) {
        let a = q_(n);
        if (a > i) {
          if (n === 39) {
            if (this.expectPlugin("pipelineOperator"), this.state.inFSharpPipelineDirectBody)
              return t;
            this.checkPipelineAtInfixOperator(t, r);
          }
          let o = this.startNodeAt(r);
          o.left = t, o.operator = this.state.value;
          let u = n === 41 || n === 42, l = n === 40;
          if (l && (a = q_(42)), this.next(), n === 39 && this.hasPlugin(["pipelineOperator", {
            proposal: "minimal"
          }]) && this.state.type === 96 && this.prodParam.hasAwait)
            throw this.raise(Z.UnexpectedAwaitAfterPipelineBody, this.state.startLoc);
          o.right = this.parseExprOpRightExpr(n, a);
          let c = this.finishNode(o, u || l ? "LogicalExpression" : "BinaryExpression"), p = this.state.type;
          if (l && (p === 41 || p === 42) || u && p === 40)
            throw this.raise(Z.MixingCoalesceWithLogical, this.state.startLoc);
          return this.parseExprOp(c, r, i);
        }
      }
      return t;
    }
    parseExprOpRightExpr(t, r) {
      let i = this.state.startLoc;
      switch (t) {
        case 39:
          switch (this.getPluginOption("pipelineOperator", "proposal")) {
            case "hack":
              return this.withTopicBindingContext(() => this.parseHackPipeBody());
            case "fsharp":
              return this.withSoloAwaitPermittingContext(() => this.parseFSharpPipelineBody(r));
          }
          if (this.getPluginOption("pipelineOperator", "proposal") === "smart")
            return this.withTopicBindingContext(() => {
              if (this.prodParam.hasYield && this.isContextual(108))
                throw this.raise(Z.PipeBodyIsTighter, this.state.startLoc);
              return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(t, r), i);
            });
        default:
          return this.parseExprOpBaseRightExpr(t, r);
      }
    }
    parseExprOpBaseRightExpr(t, r) {
      let i = this.state.startLoc;
      return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), i, J3e(t) ? r - 1 : r);
    }
    parseHackPipeBody() {
      var t;
      let {
        startLoc: r
      } = this.state, i = this.parseMaybeAssign();
      return I3e.has(i.type) && !((t = i.extra) != null && t.parenthesized) && this.raise(Z.PipeUnparenthesizedBody, r, {
        type: i.type
      }), this.topicReferenceWasUsedInCurrentContext() || this.raise(Z.PipeTopicUnused, r), i;
    }
    checkExponentialAfterUnary(t) {
      this.match(57) && this.raise(Z.UnexpectedTokenUnaryExponentiation, t.argument);
    }
    parseMaybeUnary(t, r) {
      let i = this.state.startLoc, n = this.isContextual(96);
      if (n && this.recordAwaitIfAllowed()) {
        this.next();
        let l = this.parseAwait(i);
        return r || this.checkExponentialAfterUnary(l), l;
      }
      let a = this.match(34), o = this.startNode();
      if ($3e(this.state.type)) {
        o.operator = this.state.value, o.prefix = !0, this.match(72) && this.expectPlugin("throwExpressions");
        let l = this.match(89);
        if (this.next(), o.argument = this.parseMaybeUnary(null, !0), this.checkExpressionErrors(t, !0), this.state.strict && l) {
          let c = o.argument;
          c.type === "Identifier" ? this.raise(Z.StrictDelete, o) : this.hasPropertyAsPrivateName(c) && this.raise(Z.DeletePrivateField, o);
        }
        if (!a)
          return r || this.checkExponentialAfterUnary(o), this.finishNode(o, "UnaryExpression");
      }
      let u = this.parseUpdate(o, a, t);
      if (n) {
        let {
          type: l
        } = this.state;
        if ((this.hasPlugin("v8intrinsic") ? Ed(l) : Ed(l) && !this.match(54)) && !this.isAmbiguousPrefixOrIdentifier())
          return this.raiseOverwrite(Z.AwaitNotInAsyncContext, i), this.parseAwait(i);
      }
      return u;
    }
    parseUpdate(t, r, i) {
      if (r) {
        let o = t;
        return this.checkLVal(o.argument, this.finishNode(o, "UpdateExpression")), t;
      }
      let n = this.state.startLoc, a = this.parseExprSubscripts(i);
      if (this.checkExpressionErrors(i, !1)) return a;
      for (; W3e(this.state.type) && !this.canInsertSemicolon(); ) {
        let o = this.startNodeAt(n);
        o.operator = this.state.value, o.prefix = !1, o.argument = a, this.next(), this.checkLVal(a, a = this.finishNode(o, "UpdateExpressio\
n"));
      }
      return a;
    }
    parseExprSubscripts(t) {
      let r = this.state.startLoc, i = this.state.potentialArrowAt, n = this.parseExprAtom(t);
      return this.shouldExitDescending(n, i) ? n : this.parseSubscripts(n, r);
    }
    parseSubscripts(t, r, i) {
      let n = {
        optionalChainMember: !1,
        maybeAsyncArrow: this.atPossibleAsyncArrow(t),
        stop: !1
      };
      do
        t = this.parseSubscript(t, r, i, n), n.maybeAsyncArrow = !1;
      while (!n.stop);
      return t;
    }
    parseSubscript(t, r, i, n) {
      let {
        type: a
      } = this.state;
      if (!i && a === 15)
        return this.parseBind(t, r, i, n);
      if (V_(a))
        return this.parseTaggedTemplateExpression(t, r, n);
      let o = !1;
      if (a === 18) {
        if (i && (this.raise(Z.OptionalChainingNoNew, this.state.startLoc), this.lookaheadCharCode() === 40))
          return n.stop = !0, t;
        n.optionalChainMember = o = !0, this.next();
      }
      if (!i && this.match(10))
        return this.parseCoverCallAndAsyncArrowHead(t, r, n, o);
      {
        let u = this.eat(0);
        return u || o || this.eat(16) ? this.parseMember(t, r, n, u, o) : (n.stop = !0, t);
      }
    }
    parseMember(t, r, i, n, a) {
      let o = this.startNodeAt(r);
      return o.object = t, o.computed = n, n ? (o.property = this.parseExpression(), this.expect(3)) : this.match(139) ? (t.type === "Super" &&
      this.raise(Z.SuperPrivateField, r), this.classScope.usePrivateName(this.state.value, this.state.startLoc), o.property = this.parsePrivateName()) :
      o.property = this.parseIdentifier(!0), i.optionalChainMember ? (o.optional = a, this.finishNode(o, "OptionalMemberExpression")) : this.
      finishNode(o, "MemberExpression");
    }
    parseBind(t, r, i, n) {
      let a = this.startNodeAt(r);
      return a.object = t, this.next(), a.callee = this.parseNoCallExpr(), n.stop = !0, this.parseSubscripts(this.finishNode(a, "BindExpress\
ion"), r, i);
    }
    parseCoverCallAndAsyncArrowHead(t, r, i, n) {
      let a = this.state.maybeInArrowParameters, o = null;
      this.state.maybeInArrowParameters = !0, this.next();
      let u = this.startNodeAt(r);
      u.callee = t;
      let {
        maybeAsyncArrow: l,
        optionalChainMember: c
      } = i;
      l && (this.expressionScope.enter(gqe()), o = new ip()), c && (u.optional = n), n ? u.arguments = this.parseCallExpressionArguments(11) :
      u.arguments = this.parseCallExpressionArguments(11, t.type !== "Super", u, o);
      let p = this.finishCallExpression(u, c);
      return l && this.shouldParseAsyncArrow() && !n ? (i.stop = !0, this.checkDestructuringPrivate(o), this.expressionScope.validateAsPattern(),
      this.expressionScope.exit(), p = this.parseAsyncArrowFromCallExpression(this.startNodeAt(r), p)) : (l && (this.checkExpressionErrors(o,
      !0), this.expressionScope.exit()), this.toReferencedArguments(p)), this.state.maybeInArrowParameters = a, p;
    }
    toReferencedArguments(t, r) {
      this.toReferencedListDeep(t.arguments, r);
    }
    parseTaggedTemplateExpression(t, r, i) {
      let n = this.startNodeAt(r);
      return n.tag = t, n.quasi = this.parseTemplate(!0), i.optionalChainMember && this.raise(Z.OptionalChainingNoTemplate, r), this.finishNode(
      n, "TaggedTemplateExpression");
    }
    atPossibleAsyncArrow(t) {
      return t.type === "Identifier" && t.name === "async" && this.state.lastTokEndLoc.index === t.end && !this.canInsertSemicolon() && t.end -
      t.start === 5 && this.offsetToSourcePos(t.start) === this.state.potentialArrowAt;
    }
    finishCallExpression(t, r) {
      if (t.callee.type === "Import")
        if (t.arguments.length === 0 || t.arguments.length > 2)
          this.raise(Z.ImportCallArity, t);
        else
          for (let i of t.arguments)
            i.type === "SpreadElement" && this.raise(Z.ImportCallSpreadArgument, i);
      return this.finishNode(t, r ? "OptionalCallExpression" : "CallExpression");
    }
    parseCallExpressionArguments(t, r, i, n) {
      let a = [], o = !0, u = this.state.inFSharpPipelineDirectBody;
      for (this.state.inFSharpPipelineDirectBody = !1; !this.eat(t); ) {
        if (o)
          o = !1;
        else if (this.expect(12), this.match(t)) {
          i && this.addTrailingCommaExtraToNode(i), this.next();
          break;
        }
        a.push(this.parseExprListItem(!1, n, r));
      }
      return this.state.inFSharpPipelineDirectBody = u, a;
    }
    shouldParseAsyncArrow() {
      return this.match(19) && !this.canInsertSemicolon();
    }
    parseAsyncArrowFromCallExpression(t, r) {
      var i;
      return this.resetPreviousNodeTrailingComments(r), this.expect(19), this.parseArrowExpression(t, r.arguments, !0, (i = r.extra) == null ?
      void 0 : i.trailingCommaLoc), r.innerComments && Dd(t, r.innerComments), r.callee.trailingComments && Dd(t, r.callee.trailingComments),
      t;
    }
    parseNoCallExpr() {
      let t = this.state.startLoc;
      return this.parseSubscripts(this.parseExprAtom(), t, !0);
    }
    parseExprAtom(t) {
      let r, i = null, {
        type: n
      } = this.state;
      switch (n) {
        case 79:
          return this.parseSuper();
        case 83:
          return r = this.startNode(), this.next(), this.match(16) ? this.parseImportMetaProperty(r) : this.match(10) ? this.optionFlags & 512 ?
          this.parseImportCall(r) : this.finishNode(r, "Import") : (this.raise(Z.UnsupportedImport, this.state.lastTokStartLoc), this.finishNode(
          r, "Import"));
        case 78:
          return r = this.startNode(), this.next(), this.finishNode(r, "ThisExpression");
        case 90:
          return this.parseDo(this.startNode(), !1);
        case 56:
        case 31:
          return this.readRegexp(), this.parseRegExpLiteral(this.state.value);
        case 135:
          return this.parseNumericLiteral(this.state.value);
        case 136:
          return this.parseBigIntLiteral(this.state.value);
        case 134:
          return this.parseStringLiteral(this.state.value);
        case 84:
          return this.parseNullLiteral();
        case 85:
          return this.parseBooleanLiteral(!0);
        case 86:
          return this.parseBooleanLiteral(!1);
        case 10: {
          let a = this.state.potentialArrowAt === this.state.start;
          return this.parseParenAndDistinguishExpression(a);
        }
        case 2:
        case 1:
          return this.parseArrayLike(this.state.type === 2 ? 4 : 3, !1, !0);
        case 0:
          return this.parseArrayLike(3, !0, !1, t);
        case 6:
        case 7:
          return this.parseObjectLike(this.state.type === 6 ? 9 : 8, !1, !0);
        case 5:
          return this.parseObjectLike(8, !1, !1, t);
        case 68:
          return this.parseFunctionOrFunctionSent();
        case 26:
          i = this.parseDecorators();
        case 80:
          return this.parseClass(this.maybeTakeDecorators(i, this.startNode()), !1);
        case 77:
          return this.parseNewOrNewTarget();
        case 25:
        case 24:
          return this.parseTemplate(!1);
        case 15: {
          r = this.startNode(), this.next(), r.object = null;
          let a = r.callee = this.parseNoCallExpr();
          if (a.type === "MemberExpression")
            return this.finishNode(r, "BindExpression");
          throw this.raise(Z.UnsupportedBind, a);
        }
        case 139:
          return this.raise(Z.PrivateInExpectedIn, this.state.startLoc, {
            identifierName: this.state.value
          }), this.parsePrivateName();
        case 33:
          return this.parseTopicReferenceThenEqualsSign(54, "%");
        case 32:
          return this.parseTopicReferenceThenEqualsSign(44, "^");
        case 37:
        case 38:
          return this.parseTopicReference("hack");
        case 44:
        case 54:
        case 27: {
          let a = this.getPluginOption("pipelineOperator", "proposal");
          if (a)
            return this.parseTopicReference(a);
          this.unexpected();
          break;
        }
        case 47: {
          let a = this.input.codePointAt(this.nextTokenStart());
          Tu(a) || a === 62 ? this.expectOnePlugin(["jsx", "flow", "typescript"]) : this.unexpected();
          break;
        }
        default:
          if (n === 137)
            return this.parseDecimalLiteral(this.state.value);
          if (Ar(n)) {
            if (this.isContextual(127) && this.lookaheadInLineCharCode() === 123)
              return this.parseModuleExpression();
            let a = this.state.potentialArrowAt === this.state.start, o = this.state.containsEsc, u = this.parseIdentifier();
            if (!o && u.name === "async" && !this.canInsertSemicolon()) {
              let {
                type: l
              } = this.state;
              if (l === 68)
                return this.resetPreviousNodeTrailingComments(u), this.next(), this.parseAsyncFunctionExpression(this.startNodeAtNode(u));
              if (Ar(l))
                return this.lookaheadCharCode() === 61 ? this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(u)) : u;
              if (l === 90)
                return this.resetPreviousNodeTrailingComments(u), this.parseDo(this.startNodeAtNode(u), !0);
            }
            return a && this.match(19) && !this.canInsertSemicolon() ? (this.next(), this.parseArrowExpression(this.startNodeAtNode(u), [u],
            !1)) : u;
          } else
            this.unexpected();
      }
    }
    parseTopicReferenceThenEqualsSign(t, r) {
      let i = this.getPluginOption("pipelineOperator", "proposal");
      if (i)
        return this.state.type = t, this.state.value = r, this.state.pos--, this.state.end--, this.state.endLoc = ms(this.state.endLoc, -1),
        this.parseTopicReference(i);
      this.unexpected();
    }
    parseTopicReference(t) {
      let r = this.startNode(), i = this.state.startLoc, n = this.state.type;
      return this.next(), this.finishTopicReference(r, i, t, n);
    }
    finishTopicReference(t, r, i, n) {
      if (this.testTopicReferenceConfiguration(i, r, n))
        return i === "hack" ? (this.topicReferenceIsAllowedInCurrentContext() || this.raise(Z.PipeTopicUnbound, r), this.registerTopicReference(),
        this.finishNode(t, "TopicReference")) : (this.topicReferenceIsAllowedInCurrentContext() || this.raise(Z.PrimaryTopicNotAllowed, r), this.
        registerTopicReference(), this.finishNode(t, "PipelinePrimaryTopicReference"));
      throw this.raise(Z.PipeTopicUnconfiguredToken, r, {
        token: ml(n)
      });
    }
    testTopicReferenceConfiguration(t, r, i) {
      switch (t) {
        case "hack":
          return this.hasPlugin(["pipelineOperator", {
            topicToken: ml(i)
          }]);
        case "smart":
          return i === 27;
        default:
          throw this.raise(Z.PipeTopicRequiresHackPipes, r);
      }
    }
    parseAsyncArrowUnaryFunction(t) {
      this.prodParam.enter(U_(!0, this.prodParam.hasYield));
      let r = [this.parseIdentifier()];
      return this.prodParam.exit(), this.hasPrecedingLineBreak() && this.raise(Z.LineTerminatorBeforeArrow, this.state.curPosition()), this.
      expect(19), this.parseArrowExpression(t, r, !0);
    }
    parseDo(t, r) {
      this.expectPlugin("doExpressions"), r && this.expectPlugin("asyncDoExpressions"), t.async = r, this.next();
      let i = this.state.labels;
      return this.state.labels = [], r ? (this.prodParam.enter(2), t.body = this.parseBlock(), this.prodParam.exit()) : t.body = this.parseBlock(),
      this.state.labels = i, this.finishNode(t, "DoExpression");
    }
    parseSuper() {
      let t = this.startNode();
      return this.next(), this.match(10) && !this.scope.allowDirectSuper && !(this.optionFlags & 16) ? this.raise(Z.SuperNotAllowed, t) : !this.
      scope.allowSuper && !(this.optionFlags & 16) && this.raise(Z.UnexpectedSuper, t), !this.match(10) && !this.match(0) && !this.match(16) &&
      this.raise(Z.UnsupportedSuper, t), this.finishNode(t, "Super");
    }
    parsePrivateName() {
      let t = this.startNode(), r = this.startNodeAt(ms(this.state.startLoc, 1)), i = this.state.value;
      return this.next(), t.id = this.createIdentifier(r, i), this.finishNode(t, "PrivateName");
    }
    parseFunctionOrFunctionSent() {
      let t = this.startNode();
      if (this.next(), this.prodParam.hasYield && this.match(16)) {
        let r = this.createIdentifier(this.startNodeAtNode(t), "function");
        return this.next(), this.match(103) ? this.expectPlugin("functionSent") : this.hasPlugin("functionSent") || this.unexpected(), this.
        parseMetaProperty(t, r, "sent");
      }
      return this.parseFunction(t);
    }
    parseMetaProperty(t, r, i) {
      t.meta = r;
      let n = this.state.containsEsc;
      return t.property = this.parseIdentifier(!0), (t.property.name !== i || n) && this.raise(Z.UnsupportedMetaProperty, t.property, {
        target: r.name,
        onlyValidPropertyName: i
      }), this.finishNode(t, "MetaProperty");
    }
    parseImportMetaProperty(t) {
      let r = this.createIdentifier(this.startNodeAtNode(t), "import");
      if (this.next(), this.isContextual(101))
        this.inModule || this.raise(Z.ImportMetaOutsideModule, r), this.sawUnambiguousESM = !0;
      else if (this.isContextual(105) || this.isContextual(97)) {
        let i = this.isContextual(105);
        if (this.expectPlugin(i ? "sourcePhaseImports" : "deferredImportEvaluation"), !(this.optionFlags & 512))
          throw this.raise(Z.DynamicImportPhaseRequiresImportExpressions, this.state.startLoc, {
            phase: this.state.value
          });
        return this.next(), t.phase = i ? "source" : "defer", this.parseImportCall(t);
      }
      return this.parseMetaProperty(t, r, "meta");
    }
    parseLiteralAtNode(t, r, i) {
      return this.addExtra(i, "rawValue", t), this.addExtra(i, "raw", this.input.slice(this.offsetToSourcePos(i.start), this.state.end)), i.
      value = t, this.next(), this.finishNode(i, r);
    }
    parseLiteral(t, r) {
      let i = this.startNode();
      return this.parseLiteralAtNode(t, r, i);
    }
    parseStringLiteral(t) {
      return this.parseLiteral(t, "StringLiteral");
    }
    parseNumericLiteral(t) {
      return this.parseLiteral(t, "NumericLiteral");
    }
    parseBigIntLiteral(t) {
      return this.parseLiteral(t, "BigIntLiteral");
    }
    parseDecimalLiteral(t) {
      return this.parseLiteral(t, "DecimalLiteral");
    }
    parseRegExpLiteral(t) {
      let r = this.startNode();
      return this.addExtra(r, "raw", this.input.slice(this.offsetToSourcePos(r.start), this.state.end)), r.pattern = t.pattern, r.flags = t.
      flags, this.next(), this.finishNode(r, "RegExpLiteral");
    }
    parseBooleanLiteral(t) {
      let r = this.startNode();
      return r.value = t, this.next(), this.finishNode(r, "BooleanLiteral");
    }
    parseNullLiteral() {
      let t = this.startNode();
      return this.next(), this.finishNode(t, "NullLiteral");
    }
    parseParenAndDistinguishExpression(t) {
      let r = this.state.startLoc, i;
      this.next(), this.expressionScope.enter(yqe());
      let n = this.state.maybeInArrowParameters, a = this.state.inFSharpPipelineDirectBody;
      this.state.maybeInArrowParameters = !0, this.state.inFSharpPipelineDirectBody = !1;
      let o = this.state.startLoc, u = [], l = new ip(), c = !0, p, h;
      for (; !this.match(11); ) {
        if (c)
          c = !1;
        else if (this.expect(12, l.optionalParametersLoc === null ? null : l.optionalParametersLoc), this.match(11)) {
          h = this.state.startLoc;
          break;
        }
        if (this.match(21)) {
          let g = this.state.startLoc;
          if (p = this.state.startLoc, u.push(this.parseParenItem(this.parseRestBinding(), g)), !this.checkCommaAfterRest(41))
            break;
        } else
          u.push(this.parseMaybeAssignAllowIn(l, this.parseParenItem));
      }
      let y = this.state.lastTokEndLoc;
      this.expect(11), this.state.maybeInArrowParameters = n, this.state.inFSharpPipelineDirectBody = a;
      let _ = this.startNodeAt(r);
      return t && this.shouldParseArrow(u) && (_ = this.parseArrow(_)) ? (this.checkDestructuringPrivate(l), this.expressionScope.validateAsPattern(),
      this.expressionScope.exit(), this.parseArrowExpression(_, u, !1), _) : (this.expressionScope.exit(), u.length || this.unexpected(this.
      state.lastTokStartLoc), h && this.unexpected(h), p && this.unexpected(p), this.checkExpressionErrors(l, !0), this.toReferencedListDeep(
      u, !0), u.length > 1 ? (i = this.startNodeAt(o), i.expressions = u, this.finishNode(i, "SequenceExpression"), this.resetEndLocation(i,
      y)) : i = u[0], this.wrapParenthesis(r, i));
    }
    wrapParenthesis(t, r) {
      if (!(this.optionFlags & 1024))
        return this.addExtra(r, "parenthesized", !0), this.addExtra(r, "parenStart", t.index), this.takeSurroundingComments(r, t.index, this.
        state.lastTokEndLoc.index), r;
      let i = this.startNodeAt(t);
      return i.expression = r, this.finishNode(i, "ParenthesizedExpression");
    }
    shouldParseArrow(t) {
      return !this.canInsertSemicolon();
    }
    parseArrow(t) {
      if (this.eat(19))
        return t;
    }
    parseParenItem(t, r) {
      return t;
    }
    parseNewOrNewTarget() {
      let t = this.startNode();
      if (this.next(), this.match(16)) {
        let r = this.createIdentifier(this.startNodeAtNode(t), "new");
        this.next();
        let i = this.parseMetaProperty(t, r, "target");
        return !this.scope.inNonArrowFunction && !this.scope.inClass && !(this.optionFlags & 4) && this.raise(Z.UnexpectedNewTarget, i), i;
      }
      return this.parseNew(t);
    }
    parseNew(t) {
      if (this.parseNewCallee(t), this.eat(10)) {
        let r = this.parseExprList(11);
        this.toReferencedList(r), t.arguments = r;
      } else
        t.arguments = [];
      return this.finishNode(t, "NewExpression");
    }
    parseNewCallee(t) {
      let r = this.match(83), i = this.parseNoCallExpr();
      t.callee = i, r && (i.type === "Import" || i.type === "ImportExpression") && this.raise(Z.ImportCallNotNewExpression, i);
    }
    parseTemplateElement(t) {
      let {
        start: r,
        startLoc: i,
        end: n,
        value: a
      } = this.state, o = r + 1, u = this.startNodeAt(ms(i, 1));
      a === null && (t || this.raise(Z.InvalidEscapeSequenceTemplate, ms(this.state.firstInvalidTemplateEscapePos, 1)));
      let l = this.match(24), c = l ? -1 : -2, p = n + c;
      u.value = {
        raw: this.input.slice(o, p).replace(/\r\n?/g, `
`),
        cooked: a === null ? null : a.slice(1, c)
      }, u.tail = l, this.next();
      let h = this.finishNode(u, "TemplateElement");
      return this.resetEndLocation(h, ms(this.state.lastTokEndLoc, c)), h;
    }
    parseTemplate(t) {
      let r = this.startNode(), i = this.parseTemplateElement(t), n = [i], a = [];
      for (; !i.tail; )
        a.push(this.parseTemplateSubstitution()), this.readTemplateContinuation(), n.push(i = this.parseTemplateElement(t));
      return r.expressions = a, r.quasis = n, this.finishNode(r, "TemplateLiteral");
    }
    parseTemplateSubstitution() {
      return this.parseExpression();
    }
    parseObjectLike(t, r, i, n) {
      i && this.expectPlugin("recordAndTuple");
      let a = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !1;
      let o = !1, u = !0, l = this.startNode();
      for (l.properties = [], this.next(); !this.match(t); ) {
        if (u)
          u = !1;
        else if (this.expect(12), this.match(t)) {
          this.addTrailingCommaExtraToNode(l);
          break;
        }
        let p;
        r ? p = this.parseBindingProperty() : (p = this.parsePropertyDefinition(n), o = this.checkProto(p, i, o, n)), i && !this.isObjectProperty(
        p) && p.type !== "SpreadElement" && this.raise(Z.InvalidRecordProperty, p), p.shorthand && this.addExtra(p, "shorthand", !0), l.properties.
        push(p);
      }
      this.next(), this.state.inFSharpPipelineDirectBody = a;
      let c = "ObjectExpression";
      return r ? c = "ObjectPattern" : i && (c = "RecordExpression"), this.finishNode(l, c);
    }
    addTrailingCommaExtraToNode(t) {
      this.addExtra(t, "trailingComma", this.state.lastTokStartLoc.index), this.addExtra(t, "trailingCommaLoc", this.state.lastTokStartLoc, !1);
    }
    maybeAsyncOrAccessorProp(t) {
      return !t.computed && t.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
    }
    parsePropertyDefinition(t) {
      let r = [];
      if (this.match(26))
        for (this.hasPlugin("decorators") && this.raise(Z.UnsupportedPropertyDecorator, this.state.startLoc); this.match(26); )
          r.push(this.parseDecorator());
      let i = this.startNode(), n = !1, a = !1, o;
      if (this.match(21))
        return r.length && this.unexpected(), this.parseSpread();
      r.length && (i.decorators = r, r = []), i.method = !1, t && (o = this.state.startLoc);
      let u = this.eat(55);
      this.parsePropertyNamePrefixOperator(i);
      let l = this.state.containsEsc;
      if (this.parsePropertyName(i, t), !u && !l && this.maybeAsyncOrAccessorProp(i)) {
        let {
          key: c
        } = i, p = c.name;
        p === "async" && !this.hasPrecedingLineBreak() && (n = !0, this.resetPreviousNodeTrailingComments(c), u = this.eat(55), this.parsePropertyName(
        i)), (p === "get" || p === "set") && (a = !0, this.resetPreviousNodeTrailingComments(c), i.kind = p, this.match(55) && (u = !0, this.
        raise(Z.AccessorIsGenerator, this.state.curPosition(), {
          kind: p
        }), this.next()), this.parsePropertyName(i));
      }
      return this.parseObjPropValue(i, o, u, n, !1, a, t);
    }
    getGetterSetterExpectedParamCount(t) {
      return t.kind === "get" ? 0 : 1;
    }
    getObjectOrClassMethodParams(t) {
      return t.params;
    }
    checkGetterSetterParams(t) {
      var r;
      let i = this.getGetterSetterExpectedParamCount(t), n = this.getObjectOrClassMethodParams(t);
      n.length !== i && this.raise(t.kind === "get" ? Z.BadGetterArity : Z.BadSetterArity, t), t.kind === "set" && ((r = n[n.length - 1]) ==
      null ? void 0 : r.type) === "RestElement" && this.raise(Z.BadSetterRestParameter, t);
    }
    parseObjectMethod(t, r, i, n, a) {
      if (a) {
        let o = this.parseMethod(t, r, !1, !1, !1, "ObjectMethod");
        return this.checkGetterSetterParams(o), o;
      }
      if (i || r || this.match(10))
        return n && this.unexpected(), t.kind = "method", t.method = !0, this.parseMethod(t, r, i, !1, !1, "ObjectMethod");
    }
    parseObjectProperty(t, r, i, n) {
      if (t.shorthand = !1, this.eat(14))
        return t.value = i ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowIn(n), this.finishNode(t, "ObjectProper\
ty");
      if (!t.computed && t.key.type === "Identifier") {
        if (this.checkReservedWord(t.key.name, t.key.loc.start, !0, !1), i)
          t.value = this.parseMaybeDefault(r, Au(t.key));
        else if (this.match(29)) {
          let a = this.state.startLoc;
          n != null ? n.shorthandAssignLoc === null && (n.shorthandAssignLoc = a) : this.raise(Z.InvalidCoverInitializedName, a), t.value = this.
          parseMaybeDefault(r, Au(t.key));
        } else
          t.value = Au(t.key);
        return t.shorthand = !0, this.finishNode(t, "ObjectProperty");
      }
    }
    parseObjPropValue(t, r, i, n, a, o, u) {
      let l = this.parseObjectMethod(t, i, n, a, o) || this.parseObjectProperty(t, r, a, u);
      return l || this.unexpected(), l;
    }
    parsePropertyName(t, r) {
      if (this.eat(0))
        t.computed = !0, t.key = this.parseMaybeAssignAllowIn(), this.expect(3);
      else {
        let {
          type: i,
          value: n
        } = this.state, a;
        if (Ga(i))
          a = this.parseIdentifier(!0);
        else
          switch (i) {
            case 135:
              a = this.parseNumericLiteral(n);
              break;
            case 134:
              a = this.parseStringLiteral(n);
              break;
            case 136:
              a = this.parseBigIntLiteral(n);
              break;
            case 139: {
              let o = this.state.startLoc;
              r != null ? r.privateKeyLoc === null && (r.privateKeyLoc = o) : this.raise(Z.UnexpectedPrivateField, o), a = this.parsePrivateName();
              break;
            }
            default:
              if (i === 137) {
                a = this.parseDecimalLiteral(n);
                break;
              }
              this.unexpected();
          }
        t.key = a, i !== 139 && (t.computed = !1);
      }
    }
    initFunction(t, r) {
      t.id = null, t.generator = !1, t.async = r;
    }
    parseMethod(t, r, i, n, a, o, u = !1) {
      this.initFunction(t, i), t.generator = r, this.scope.enter(18 | (u ? 64 : 0) | (a ? 32 : 0)), this.prodParam.enter(U_(i, t.generator)),
      this.parseFunctionParams(t, n);
      let l = this.parseFunctionBodyAndFinish(t, o, !0);
      return this.prodParam.exit(), this.scope.exit(), l;
    }
    parseArrayLike(t, r, i, n) {
      i && this.expectPlugin("recordAndTuple");
      let a = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !1;
      let o = this.startNode();
      return this.next(), o.elements = this.parseExprList(t, !i, n, o), this.state.inFSharpPipelineDirectBody = a, this.finishNode(o, i ? "T\
upleExpression" : "ArrayExpression");
    }
    parseArrowExpression(t, r, i, n) {
      this.scope.enter(6);
      let a = U_(i, !1);
      !this.match(5) && this.prodParam.hasIn && (a |= 8), this.prodParam.enter(a), this.initFunction(t, i);
      let o = this.state.maybeInArrowParameters;
      return r && (this.state.maybeInArrowParameters = !0, this.setArrowFunctionParameters(t, r, n)), this.state.maybeInArrowParameters = !1,
      this.parseFunctionBody(t, !0), this.prodParam.exit(), this.scope.exit(), this.state.maybeInArrowParameters = o, this.finishNode(t, "Ar\
rowFunctionExpression");
    }
    setArrowFunctionParameters(t, r, i) {
      this.toAssignableList(r, i, !1), t.params = r;
    }
    parseFunctionBodyAndFinish(t, r, i = !1) {
      return this.parseFunctionBody(t, !1, i), this.finishNode(t, r);
    }
    parseFunctionBody(t, r, i = !1) {
      let n = r && !this.match(5);
      if (this.expressionScope.enter(V9()), n)
        t.body = this.parseMaybeAssign(), this.checkParams(t, !1, r, !1);
      else {
        let a = this.state.strict, o = this.state.labels;
        this.state.labels = [], this.prodParam.enter(this.prodParam.currentFlags() | 4), t.body = this.parseBlock(!0, !1, (u) => {
          let l = !this.isSimpleParamList(t.params);
          u && l && this.raise(Z.IllegalLanguageModeDirective, (t.kind === "method" || t.kind === "constructor") && t.key ? t.key.loc.end : t);
          let c = !a && this.state.strict;
          this.checkParams(t, !this.state.strict && !r && !i && !l, r, c), this.state.strict && t.id && this.checkIdentifier(t.id, 65, c);
        }), this.prodParam.exit(), this.state.labels = o;
      }
      this.expressionScope.exit();
    }
    isSimpleParameter(t) {
      return t.type === "Identifier";
    }
    isSimpleParamList(t) {
      for (let r = 0, i = t.length; r < i; r++)
        if (!this.isSimpleParameter(t[r])) return !1;
      return !0;
    }
    checkParams(t, r, i, n = !0) {
      let a = !r && /* @__PURE__ */ new Set(), o = {
        type: "FormalParameters"
      };
      for (let u of t.params)
        this.checkLVal(u, o, 5, a, n);
    }
    parseExprList(t, r, i, n) {
      let a = [], o = !0;
      for (; !this.eat(t); ) {
        if (o)
          o = !1;
        else if (this.expect(12), this.match(t)) {
          n && this.addTrailingCommaExtraToNode(n), this.next();
          break;
        }
        a.push(this.parseExprListItem(r, i));
      }
      return a;
    }
    parseExprListItem(t, r, i) {
      let n;
      if (this.match(12))
        t || this.raise(Z.UnexpectedToken, this.state.curPosition(), {
          unexpected: ","
        }), n = null;
      else if (this.match(21)) {
        let a = this.state.startLoc;
        n = this.parseParenItem(this.parseSpread(r), a);
      } else if (this.match(17)) {
        this.expectPlugin("partialApplication"), i || this.raise(Z.UnexpectedArgumentPlaceholder, this.state.startLoc);
        let a = this.startNode();
        this.next(), n = this.finishNode(a, "ArgumentPlaceholder");
      } else
        n = this.parseMaybeAssignAllowIn(r, this.parseParenItem);
      return n;
    }
    parseIdentifier(t) {
      let r = this.startNode(), i = this.parseIdentifierName(t);
      return this.createIdentifier(r, i);
    }
    createIdentifier(t, r) {
      return t.name = r, t.loc.identifierName = r, this.finishNode(t, "Identifier");
    }
    parseIdentifierName(t) {
      let r, {
        startLoc: i,
        type: n
      } = this.state;
      Ga(n) ? r = this.state.value : this.unexpected();
      let a = V3e(n);
      return t ? a && this.replaceToken(132) : this.checkReservedWord(r, i, a, !1), this.next(), r;
    }
    checkReservedWord(t, r, i, n) {
      if (t.length > 10 || !oqe(t))
        return;
      if (i && nqe(t)) {
        this.raise(Z.UnexpectedKeyword, r, {
          keyword: t
        });
        return;
      }
      if ((this.state.strict ? n ? B9 : F9 : L9)(t, this.inModule)) {
        this.raise(Z.UnexpectedReservedWord, r, {
          reservedWord: t
        });
        return;
      } else if (t === "yield") {
        if (this.prodParam.hasYield) {
          this.raise(Z.YieldBindingIdentifier, r);
          return;
        }
      } else if (t === "await") {
        if (this.prodParam.hasAwait) {
          this.raise(Z.AwaitBindingIdentifier, r);
          return;
        }
        if (this.scope.inStaticBlock) {
          this.raise(Z.AwaitBindingIdentifierInStaticBlock, r);
          return;
        }
        this.expressionScope.recordAsyncArrowParametersError(r);
      } else if (t === "arguments" && this.scope.inClassAndNotInNonArrowFunction) {
        this.raise(Z.ArgumentsInClass, r);
        return;
      }
    }
    recordAwaitIfAllowed() {
      let t = this.prodParam.hasAwait || this.optionFlags & 1 && !this.scope.inFunction;
      return t && !this.scope.inFunction && (this.state.hasTopLevelAwait = !0), t;
    }
    parseAwait(t) {
      let r = this.startNodeAt(t);
      return this.expressionScope.recordParameterInitializerError(Z.AwaitExpressionFormalParameter, r), this.eat(55) && this.raise(Z.ObsoleteAwaitStar,
      r), !this.scope.inFunction && !(this.optionFlags & 1) && (this.isAmbiguousPrefixOrIdentifier() ? this.ambiguousScriptDifferentAst = !0 :
      this.sawUnambiguousESM = !0), this.state.soloAwait || (r.argument = this.parseMaybeUnary(null, !0)), this.finishNode(r, "AwaitExpressi\
on");
    }
    isAmbiguousPrefixOrIdentifier() {
      if (this.hasPrecedingLineBreak()) return !0;
      let {
        type: t
      } = this.state;
      return t === 53 || t === 10 || t === 0 || V_(t) || t === 102 && !this.state.containsEsc || t === 138 || t === 56 || this.hasPlugin("v8\
intrinsic") && t === 54;
    }
    parseYield(t) {
      let r = this.startNodeAt(t);
      this.expressionScope.recordParameterInitializerError(Z.YieldInParameter, r);
      let i = !1, n = null;
      if (!this.hasPrecedingLineBreak())
        switch (i = this.eat(55), this.state.type) {
          case 13:
          case 140:
          case 8:
          case 11:
          case 3:
          case 9:
          case 14:
          case 12:
            if (!i) break;
          default:
            n = this.parseMaybeAssign();
        }
      return r.delegate = i, r.argument = n, this.finishNode(r, "YieldExpression");
    }
    parseImportCall(t) {
      if (this.next(), t.source = this.parseMaybeAssignAllowIn(), t.options = null, this.eat(12) && !this.match(11) && (t.options = this.parseMaybeAssignAllowIn(),
      this.eat(12) && !this.match(11))) {
        do
          this.parseMaybeAssignAllowIn();
        while (this.eat(12) && !this.match(11));
        this.raise(Z.ImportCallArity, t);
      }
      return this.expect(11), this.finishNode(t, "ImportExpression");
    }
    checkPipelineAtInfixOperator(t, r) {
      this.hasPlugin(["pipelineOperator", {
        proposal: "smart"
      }]) && t.type === "SequenceExpression" && this.raise(Z.PipelineHeadSequenceExpression, r);
    }
    parseSmartPipelineBodyInStyle(t, r) {
      if (this.isSimpleReference(t)) {
        let i = this.startNodeAt(r);
        return i.callee = t, this.finishNode(i, "PipelineBareFunction");
      } else {
        let i = this.startNodeAt(r);
        return this.checkSmartPipeTopicBodyEarlyErrors(r), i.expression = t, this.finishNode(i, "PipelineTopicExpression");
      }
    }
    isSimpleReference(t) {
      switch (t.type) {
        case "MemberExpression":
          return !t.computed && this.isSimpleReference(t.object);
        case "Identifier":
          return !0;
        default:
          return !1;
      }
    }
    checkSmartPipeTopicBodyEarlyErrors(t) {
      if (this.match(19))
        throw this.raise(Z.PipelineBodyNoArrow, this.state.startLoc);
      this.topicReferenceWasUsedInCurrentContext() || this.raise(Z.PipelineTopicUnused, t);
    }
    withTopicBindingContext(t) {
      let r = this.state.topicContext;
      this.state.topicContext = {
        maxNumOfResolvableTopics: 1,
        maxTopicIndex: null
      };
      try {
        return t();
      } finally {
        this.state.topicContext = r;
      }
    }
    withSmartMixTopicForbiddingContext(t) {
      if (this.hasPlugin(["pipelineOperator", {
        proposal: "smart"
      }])) {
        let r = this.state.topicContext;
        this.state.topicContext = {
          maxNumOfResolvableTopics: 0,
          maxTopicIndex: null
        };
        try {
          return t();
        } finally {
          this.state.topicContext = r;
        }
      } else
        return t();
    }
    withSoloAwaitPermittingContext(t) {
      let r = this.state.soloAwait;
      this.state.soloAwait = !0;
      try {
        return t();
      } finally {
        this.state.soloAwait = r;
      }
    }
    allowInAnd(t) {
      let r = this.prodParam.currentFlags();
      if (8 & ~r) {
        this.prodParam.enter(r | 8);
        try {
          return t();
        } finally {
          this.prodParam.exit();
        }
      }
      return t();
    }
    disallowInAnd(t) {
      let r = this.prodParam.currentFlags();
      if (8 & r) {
        this.prodParam.enter(r & -9);
        try {
          return t();
        } finally {
          this.prodParam.exit();
        }
      }
      return t();
    }
    registerTopicReference() {
      this.state.topicContext.maxTopicIndex = 0;
    }
    topicReferenceIsAllowedInCurrentContext() {
      return this.state.topicContext.maxNumOfResolvableTopics >= 1;
    }
    topicReferenceWasUsedInCurrentContext() {
      return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
    }
    parseFSharpPipelineBody(t) {
      let r = this.state.startLoc;
      this.state.potentialArrowAt = this.state.start;
      let i = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !0;
      let n = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), r, t);
      return this.state.inFSharpPipelineDirectBody = i, n;
    }
    parseModuleExpression() {
      this.expectPlugin("moduleBlocks");
      let t = this.startNode();
      this.next(), this.match(5) || this.unexpected(null, 5);
      let r = this.startNodeAt(this.state.endLoc);
      this.next();
      let i = this.initializeScopes(!0);
      this.enterInitialScopes();
      try {
        t.body = this.parseProgram(r, 8, "module");
      } finally {
        i();
      }
      return this.finishNode(t, "ModuleExpression");
    }
    parsePropertyNamePrefixOperator(t) {
    }
  }, nP = {
    kind: 1
  }, qqe = {
    kind: 2
  }, Uqe = /[\uD800-\uDFFF]/u, sP = /in(?:stanceof)?/y;
  function jqe(e, t, r) {
    for (let i = 0; i < e.length; i++) {
      let n = e[i], {
        type: a
      } = n;
      if (typeof a == "number") {
        {
          if (a === 139) {
            let {
              loc: o,
              start: u,
              value: l,
              end: c
            } = n, p = u + 1, h = ms(o.start, 1);
            e.splice(i, 1, new No({
              type: vu(27),
              value: "#",
              start: u,
              end: p,
              startLoc: o.start,
              endLoc: h
            }), new No({
              type: vu(132),
              value: l,
              start: p,
              end: c,
              startLoc: h,
              endLoc: o.end
            })), i++;
            continue;
          }
          if (V_(a)) {
            let {
              loc: o,
              start: u,
              value: l,
              end: c
            } = n, p = u + 1, h = ms(o.start, 1), y;
            t.charCodeAt(u - r) === 96 ? y = new No({
              type: vu(22),
              value: "`",
              start: u,
              end: p,
              startLoc: o.start,
              endLoc: h
            }) : y = new No({
              type: vu(8),
              value: "}",
              start: u,
              end: p,
              startLoc: o.start,
              endLoc: h
            });
            let _, g, m, f;
            a === 24 ? (g = c - 1, m = ms(o.end, -1), _ = l === null ? null : l.slice(1, -1), f = new No({
              type: vu(22),
              value: "`",
              start: g,
              end: c,
              startLoc: m,
              endLoc: o.end
            })) : (g = c - 2, m = ms(o.end, -2), _ = l === null ? null : l.slice(1, -2), f = new No({
              type: vu(23),
              value: "${",
              start: g,
              end: c,
              startLoc: m,
              endLoc: o.end
            })), e.splice(i, 1, y, new No({
              type: vu(20),
              value: _,
              start: p,
              end: g,
              startLoc: h,
              endLoc: m
            }), f), i += 2;
            continue;
          }
        }
        n.type = vu(a);
      }
    }
    return e;
  }
  s(jqe, "babel7CompatTokens");
  var AP = class extends EP {
    static {
      s(this, "StatementParser");
    }
    parseTopLevel(t, r) {
      return t.program = this.parseProgram(r), t.comments = this.comments, this.optionFlags & 256 && (t.tokens = jqe(this.tokens, this.input,
      this.startIndex)), this.finishNode(t, "File");
    }
    parseProgram(t, r = 140, i = this.options.sourceType) {
      if (t.sourceType = i, t.interpreter = this.parseInterpreterDirective(), this.parseBlockBody(t, !0, !0, r), this.inModule) {
        if (!(this.optionFlags & 64) && this.scope.undefinedExports.size > 0)
          for (let [a, o] of Array.from(this.scope.undefinedExports))
            this.raise(Z.ModuleExportUndefined, o, {
              localName: a
            });
        this.addExtra(t, "topLevelAwait", this.state.hasTopLevelAwait);
      }
      let n;
      return r === 140 ? n = this.finishNode(t, "Program") : n = this.finishNodeAt(t, "Program", ms(this.state.startLoc, -1)), n;
    }
    stmtToDirective(t) {
      let r = t;
      r.type = "Directive", r.value = r.expression, delete r.expression;
      let i = r.value, n = i.value, a = this.input.slice(this.offsetToSourcePos(i.start), this.offsetToSourcePos(i.end)), o = i.value = a.slice(
      1, -1);
      return this.addExtra(i, "raw", a), this.addExtra(i, "rawValue", o), this.addExtra(i, "expressionValue", n), i.type = "DirectiveLiteral",
      r;
    }
    parseInterpreterDirective() {
      if (!this.match(28))
        return null;
      let t = this.startNode();
      return t.value = this.state.value, this.next(), this.finishNode(t, "InterpreterDirective");
    }
    isLet() {
      return this.isContextual(100) ? this.hasFollowingBindingAtom() : !1;
    }
    chStartsBindingIdentifier(t, r) {
      if (Tu(t)) {
        if (sP.lastIndex = r, sP.test(this.input)) {
          let i = this.codePointAtPos(sP.lastIndex);
          if (!tp(i) && i !== 92)
            return !1;
        }
        return !0;
      } else return t === 92;
    }
    chStartsBindingPattern(t) {
      return t === 91 || t === 123;
    }
    hasFollowingBindingAtom() {
      let t = this.nextTokenStart(), r = this.codePointAtPos(t);
      return this.chStartsBindingPattern(r) || this.chStartsBindingIdentifier(r, t);
    }
    hasInLineFollowingBindingIdentifierOrBrace() {
      let t = this.nextTokenInLineStart(), r = this.codePointAtPos(t);
      return r === 123 || this.chStartsBindingIdentifier(r, t);
    }
    startsUsingForOf() {
      let {
        type: t,
        containsEsc: r
      } = this.lookahead();
      if (t === 102 && !r)
        return !1;
      if (Ar(t) && !this.hasFollowingLineBreak())
        return this.expectPlugin("explicitResourceManagement"), !0;
    }
    startsAwaitUsing() {
      let t = this.nextTokenInLineStart();
      if (this.isUnparsedContextual(t, "using")) {
        t = this.nextTokenInLineStartSince(t + 5);
        let r = this.codePointAtPos(t);
        if (this.chStartsBindingIdentifier(r, t))
          return this.expectPlugin("explicitResourceManagement"), !0;
      }
      return !1;
    }
    parseModuleItem() {
      return this.parseStatementLike(15);
    }
    parseStatementListItem() {
      return this.parseStatementLike(6 | (!this.options.annexB || this.state.strict ? 0 : 8));
    }
    parseStatementOrSloppyAnnexBFunctionDeclaration(t = !1) {
      let r = 0;
      return this.options.annexB && !this.state.strict && (r |= 4, t && (r |= 8)), this.parseStatementLike(r);
    }
    parseStatement() {
      return this.parseStatementLike(0);
    }
    parseStatementLike(t) {
      let r = null;
      return this.match(26) && (r = this.parseDecorators(!0)), this.parseStatementContent(t, r);
    }
    parseStatementContent(t, r) {
      let i = this.state.type, n = this.startNode(), a = !!(t & 2), o = !!(t & 4), u = t & 1;
      switch (i) {
        case 60:
          return this.parseBreakContinueStatement(n, !0);
        case 63:
          return this.parseBreakContinueStatement(n, !1);
        case 64:
          return this.parseDebuggerStatement(n);
        case 90:
          return this.parseDoWhileStatement(n);
        case 91:
          return this.parseForStatement(n);
        case 68:
          if (this.lookaheadCharCode() === 46) break;
          return o || this.raise(this.state.strict ? Z.StrictFunction : this.options.annexB ? Z.SloppyFunctionAnnexB : Z.SloppyFunction, this.
          state.startLoc), this.parseFunctionStatement(n, !1, !a && o);
        case 80:
          return a || this.unexpected(), this.parseClass(this.maybeTakeDecorators(r, n), !0);
        case 69:
          return this.parseIfStatement(n);
        case 70:
          return this.parseReturnStatement(n);
        case 71:
          return this.parseSwitchStatement(n);
        case 72:
          return this.parseThrowStatement(n);
        case 73:
          return this.parseTryStatement(n);
        case 96:
          if (!this.state.containsEsc && this.startsAwaitUsing())
            return this.recordAwaitIfAllowed() ? a || this.raise(Z.UnexpectedLexicalDeclaration, n) : this.raise(Z.AwaitUsingNotInAsyncContext,
            n), this.next(), this.parseVarStatement(n, "await using");
          break;
        case 107:
          if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifierOrBrace())
            break;
          return this.expectPlugin("explicitResourceManagement"), !this.scope.inModule && this.scope.inTopLevel ? this.raise(Z.UnexpectedUsingDeclaration,
          this.state.startLoc) : a || this.raise(Z.UnexpectedLexicalDeclaration, this.state.startLoc), this.parseVarStatement(n, "using");
        case 100: {
          if (this.state.containsEsc)
            break;
          let p = this.nextTokenStart(), h = this.codePointAtPos(p);
          if (h !== 91 && (!a && this.hasFollowingLineBreak() || !this.chStartsBindingIdentifier(h, p) && h !== 123))
            break;
        }
        case 75:
          a || this.raise(Z.UnexpectedLexicalDeclaration, this.state.startLoc);
        case 74: {
          let p = this.state.value;
          return this.parseVarStatement(n, p);
        }
        case 92:
          return this.parseWhileStatement(n);
        case 76:
          return this.parseWithStatement(n);
        case 5:
          return this.parseBlock();
        case 13:
          return this.parseEmptyStatement(n);
        case 83: {
          let p = this.lookaheadCharCode();
          if (p === 40 || p === 46)
            break;
        }
        case 82: {
          !(this.optionFlags & 8) && !u && this.raise(Z.UnexpectedImportExport, this.state.startLoc), this.next();
          let p;
          return i === 83 ? p = this.parseImport(n) : p = this.parseExport(n, r), this.assertModuleNodeAllowed(p), p;
        }
        default:
          if (this.isAsyncFunction())
            return a || this.raise(Z.AsyncFunctionInSingleStatementContext, this.state.startLoc), this.next(), this.parseFunctionStatement(n,
            !0, !a && o);
      }
      let l = this.state.value, c = this.parseExpression();
      return Ar(i) && c.type === "Identifier" && this.eat(14) ? this.parseLabeledStatement(n, l, c, t) : this.parseExpressionStatement(n, c,
      r);
    }
    assertModuleNodeAllowed(t) {
      !(this.optionFlags & 8) && !this.inModule && this.raise(Z.ImportOutsideModule, t);
    }
    decoratorsEnabledBeforeExport() {
      return this.hasPlugin("decorators-legacy") ? !0 : this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBefore\
Export") !== !1;
    }
    maybeTakeDecorators(t, r, i) {
      if (t) {
        var n;
        (n = r.decorators) != null && n.length ? (typeof this.getPluginOption("decorators", "decoratorsBeforeExport") != "boolean" && this.raise(
        Z.DecoratorsBeforeAfterExport, r.decorators[0]), r.decorators.unshift(...t)) : r.decorators = t, this.resetStartLocationFromNode(r, t[0]),
        i && this.resetStartLocationFromNode(i, r);
      }
      return r;
    }
    canHaveLeadingDecorator() {
      return this.match(80);
    }
    parseDecorators(t) {
      let r = [];
      do
        r.push(this.parseDecorator());
      while (this.match(26));
      if (this.match(82))
        t || this.unexpected(), this.decoratorsEnabledBeforeExport() || this.raise(Z.DecoratorExportClass, this.state.startLoc);
      else if (!this.canHaveLeadingDecorator())
        throw this.raise(Z.UnexpectedLeadingDecorator, this.state.startLoc);
      return r;
    }
    parseDecorator() {
      this.expectOnePlugin(["decorators", "decorators-legacy"]);
      let t = this.startNode();
      if (this.next(), this.hasPlugin("decorators")) {
        let r = this.state.startLoc, i;
        if (this.match(10)) {
          let n = this.state.startLoc;
          this.next(), i = this.parseExpression(), this.expect(11), i = this.wrapParenthesis(n, i);
          let a = this.state.startLoc;
          t.expression = this.parseMaybeDecoratorArguments(i, n), this.getPluginOption("decorators", "allowCallParenthesized") === !1 && t.expression !==
          i && this.raise(Z.DecoratorArgumentsOutsideParentheses, a);
        } else {
          for (i = this.parseIdentifier(!1); this.eat(16); ) {
            let n = this.startNodeAt(r);
            n.object = i, this.match(139) ? (this.classScope.usePrivateName(this.state.value, this.state.startLoc), n.property = this.parsePrivateName()) :
            n.property = this.parseIdentifier(!0), n.computed = !1, i = this.finishNode(n, "MemberExpression");
          }
          t.expression = this.parseMaybeDecoratorArguments(i, r);
        }
      } else
        t.expression = this.parseExprSubscripts();
      return this.finishNode(t, "Decorator");
    }
    parseMaybeDecoratorArguments(t, r) {
      if (this.eat(10)) {
        let i = this.startNodeAt(r);
        return i.callee = t, i.arguments = this.parseCallExpressionArguments(11), this.toReferencedList(i.arguments), this.finishNode(i, "Ca\
llExpression");
      }
      return t;
    }
    parseBreakContinueStatement(t, r) {
      return this.next(), this.isLineTerminator() ? t.label = null : (t.label = this.parseIdentifier(), this.semicolon()), this.verifyBreakContinue(
      t, r), this.finishNode(t, r ? "BreakStatement" : "ContinueStatement");
    }
    verifyBreakContinue(t, r) {
      let i;
      for (i = 0; i < this.state.labels.length; ++i) {
        let n = this.state.labels[i];
        if ((t.label == null || n.name === t.label.name) && (n.kind != null && (r || n.kind === 1) || t.label && r))
          break;
      }
      if (i === this.state.labels.length) {
        let n = r ? "BreakStatement" : "ContinueStatement";
        this.raise(Z.IllegalBreakContinue, t, {
          type: n
        });
      }
    }
    parseDebuggerStatement(t) {
      return this.next(), this.semicolon(), this.finishNode(t, "DebuggerStatement");
    }
    parseHeaderExpression() {
      this.expect(10);
      let t = this.parseExpression();
      return this.expect(11), t;
    }
    parseDoWhileStatement(t) {
      return this.next(), this.state.labels.push(nP), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.
      labels.pop(), this.expect(92), t.test = this.parseHeaderExpression(), this.eat(13), this.finishNode(t, "DoWhileStatement");
    }
    parseForStatement(t) {
      this.next(), this.state.labels.push(nP);
      let r = null;
      if (this.isContextual(96) && this.recordAwaitIfAllowed() && (r = this.state.startLoc, this.next()), this.scope.enter(0), this.expect(10),
      this.match(13))
        return r !== null && this.unexpected(r), this.parseFor(t, null);
      let i = this.isContextual(100);
      {
        let l = this.isContextual(96) && this.startsAwaitUsing(), c = l || this.isContextual(107) && this.startsUsingForOf(), p = i && this.
        hasFollowingBindingAtom() || c;
        if (this.match(74) || this.match(75) || p) {
          let h = this.startNode(), y;
          l ? (y = "await using", this.recordAwaitIfAllowed() || this.raise(Z.AwaitUsingNotInAsyncContext, this.state.startLoc), this.next()) :
          y = this.state.value, this.next(), this.parseVar(h, !0, y);
          let _ = this.finishNode(h, "VariableDeclaration"), g = this.match(58);
          return g && c && this.raise(Z.ForInUsing, _), (g || this.isContextual(102)) && _.declarations.length === 1 ? this.parseForIn(t, _,
          r) : (r !== null && this.unexpected(r), this.parseFor(t, _));
        }
      }
      let n = this.isContextual(95), a = new ip(), o = this.parseExpression(!0, a), u = this.isContextual(102);
      if (u && (i && this.raise(Z.ForOfLet, o), r === null && n && o.type === "Identifier" && this.raise(Z.ForOfAsync, o)), u || this.match(
      58)) {
        this.checkDestructuringPrivate(a), this.toAssignable(o, !0);
        let l = u ? "ForOfStatement" : "ForInStatement";
        return this.checkLVal(o, {
          type: l
        }), this.parseForIn(t, o, r);
      } else
        this.checkExpressionErrors(a, !0);
      return r !== null && this.unexpected(r), this.parseFor(t, o);
    }
    parseFunctionStatement(t, r, i) {
      return this.next(), this.parseFunction(t, 1 | (i ? 2 : 0) | (r ? 8 : 0));
    }
    parseIfStatement(t) {
      return this.next(), t.test = this.parseHeaderExpression(), t.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration(), t.alternate =
      this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null, this.finishNode(t, "IfStatement");
    }
    parseReturnStatement(t) {
      return !this.prodParam.hasReturn && !(this.optionFlags & 2) && this.raise(Z.IllegalReturn, this.state.startLoc), this.next(), this.isLineTerminator() ?
      t.argument = null : (t.argument = this.parseExpression(), this.semicolon()), this.finishNode(t, "ReturnStatement");
    }
    parseSwitchStatement(t) {
      this.next(), t.discriminant = this.parseHeaderExpression();
      let r = t.cases = [];
      this.expect(5), this.state.labels.push(qqe), this.scope.enter(0);
      let i;
      for (let n; !this.match(8); )
        if (this.match(61) || this.match(65)) {
          let a = this.match(61);
          i && this.finishNode(i, "SwitchCase"), r.push(i = this.startNode()), i.consequent = [], this.next(), a ? i.test = this.parseExpression() :
          (n && this.raise(Z.MultipleDefaultsInSwitch, this.state.lastTokStartLoc), n = !0, i.test = null), this.expect(14);
        } else
          i ? i.consequent.push(this.parseStatementListItem()) : this.unexpected();
      return this.scope.exit(), i && this.finishNode(i, "SwitchCase"), this.next(), this.state.labels.pop(), this.finishNode(t, "SwitchState\
ment");
    }
    parseThrowStatement(t) {
      return this.next(), this.hasPrecedingLineBreak() && this.raise(Z.NewlineAfterThrow, this.state.lastTokEndLoc), t.argument = this.parseExpression(),
      this.semicolon(), this.finishNode(t, "ThrowStatement");
    }
    parseCatchClauseParam() {
      let t = this.parseBindingAtom();
      return this.scope.enter(this.options.annexB && t.type === "Identifier" ? 8 : 0), this.checkLVal(t, {
        type: "CatchClause"
      }, 9), t;
    }
    parseTryStatement(t) {
      if (this.next(), t.block = this.parseBlock(), t.handler = null, this.match(62)) {
        let r = this.startNode();
        this.next(), this.match(10) ? (this.expect(10), r.param = this.parseCatchClauseParam(), this.expect(11)) : (r.param = null, this.scope.
        enter(0)), r.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(!1, !1)), this.scope.exit(), t.handler = this.finishNode(
        r, "CatchClause");
      }
      return t.finalizer = this.eat(67) ? this.parseBlock() : null, !t.handler && !t.finalizer && this.raise(Z.NoCatchOrFinally, t), this.finishNode(
      t, "TryStatement");
    }
    parseVarStatement(t, r, i = !1) {
      return this.next(), this.parseVar(t, !1, r, i), this.semicolon(), this.finishNode(t, "VariableDeclaration");
    }
    parseWhileStatement(t) {
      return this.next(), t.test = this.parseHeaderExpression(), this.state.labels.push(nP), t.body = this.withSmartMixTopicForbiddingContext(
      () => this.parseStatement()), this.state.labels.pop(), this.finishNode(t, "WhileStatement");
    }
    parseWithStatement(t) {
      return this.state.strict && this.raise(Z.StrictWith, this.state.startLoc), this.next(), t.object = this.parseHeaderExpression(), t.body =
      this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.finishNode(t, "WithStatement");
    }
    parseEmptyStatement(t) {
      return this.next(), this.finishNode(t, "EmptyStatement");
    }
    parseLabeledStatement(t, r, i, n) {
      for (let o of this.state.labels)
        o.name === r && this.raise(Z.LabelRedeclaration, i, {
          labelName: r
        });
      let a = z3e(this.state.type) ? 1 : this.match(71) ? 2 : null;
      for (let o = this.state.labels.length - 1; o >= 0; o--) {
        let u = this.state.labels[o];
        if (u.statementStart === t.start)
          u.statementStart = this.sourceToOffsetPos(this.state.start), u.kind = a;
        else
          break;
      }
      return this.state.labels.push({
        name: r,
        kind: a,
        statementStart: this.sourceToOffsetPos(this.state.start)
      }), t.body = n & 8 ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(!0) : this.parseStatement(), this.state.labels.pop(), t.label =
      i, this.finishNode(t, "LabeledStatement");
    }
    parseExpressionStatement(t, r, i) {
      return t.expression = r, this.semicolon(), this.finishNode(t, "ExpressionStatement");
    }
    parseBlock(t = !1, r = !0, i) {
      let n = this.startNode();
      return t && this.state.strictErrors.clear(), this.expect(5), r && this.scope.enter(0), this.parseBlockBody(n, t, !1, 8, i), r && this.
      scope.exit(), this.finishNode(n, "BlockStatement");
    }
    isValidDirective(t) {
      return t.type === "ExpressionStatement" && t.expression.type === "StringLiteral" && !t.expression.extra.parenthesized;
    }
    parseBlockBody(t, r, i, n, a) {
      let o = t.body = [], u = t.directives = [];
      this.parseBlockOrModuleBlockBody(o, r ? u : void 0, i, n, a);
    }
    parseBlockOrModuleBlockBody(t, r, i, n, a) {
      let o = this.state.strict, u = !1, l = !1;
      for (; !this.match(n); ) {
        let c = i ? this.parseModuleItem() : this.parseStatementListItem();
        if (r && !l) {
          if (this.isValidDirective(c)) {
            let p = this.stmtToDirective(c);
            r.push(p), !u && p.value.value === "use strict" && (u = !0, this.setStrict(!0));
            continue;
          }
          l = !0, this.state.strictErrors.clear();
        }
        t.push(c);
      }
      a?.call(this, u), o || this.setStrict(!1), this.next();
    }
    parseFor(t, r) {
      return t.init = r, this.semicolon(!1), t.test = this.match(13) ? null : this.parseExpression(), this.semicolon(!1), t.update = this.match(
      11) ? null : this.parseExpression(), this.expect(11), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.
      scope.exit(), this.state.labels.pop(), this.finishNode(t, "ForStatement");
    }
    parseForIn(t, r, i) {
      let n = this.match(58);
      return this.next(), n ? i !== null && this.unexpected(i) : t.await = i !== null, r.type === "VariableDeclaration" && r.declarations[0].
      init != null && (!n || !this.options.annexB || this.state.strict || r.kind !== "var" || r.declarations[0].id.type !== "Identifier") &&
      this.raise(Z.ForInOfLoopInitializer, r, {
        type: n ? "ForInStatement" : "ForOfStatement"
      }), r.type === "AssignmentPattern" && this.raise(Z.InvalidLhs, r, {
        ancestor: {
          type: "ForStatement"
        }
      }), t.left = r, t.right = n ? this.parseExpression() : this.parseMaybeAssignAllowIn(), this.expect(11), t.body = this.withSmartMixTopicForbiddingContext(
      () => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(t, n ? "ForInStatement" : "ForOfStatement");
    }
    parseVar(t, r, i, n = !1) {
      let a = t.declarations = [];
      for (t.kind = i; ; ) {
        let o = this.startNode();
        if (this.parseVarId(o, i), o.init = this.eat(29) ? r ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn() : null, o.
        init === null && !n && (o.id.type !== "Identifier" && !(r && (this.match(58) || this.isContextual(102))) ? this.raise(Z.DeclarationMissingInitializer,
        this.state.lastTokEndLoc, {
          kind: "destructuring"
        }) : (i === "const" || i === "using" || i === "await using") && !(this.match(58) || this.isContextual(102)) && this.raise(Z.DeclarationMissingInitializer,
        this.state.lastTokEndLoc, {
          kind: i
        })), a.push(this.finishNode(o, "VariableDeclarator")), !this.eat(12)) break;
      }
      return t;
    }
    parseVarId(t, r) {
      let i = this.parseBindingAtom();
      (r === "using" || r === "await using") && (i.type === "ArrayPattern" || i.type === "ObjectPattern") && this.raise(Z.UsingDeclarationHasBindingPattern,
      i.loc.start), this.checkLVal(i, {
        type: "VariableDeclarator"
      }, r === "var" ? 5 : 8201), t.id = i;
    }
    parseAsyncFunctionExpression(t) {
      return this.parseFunction(t, 8);
    }
    parseFunction(t, r = 0) {
      let i = r & 2, n = !!(r & 1), a = n && !(r & 4), o = !!(r & 8);
      this.initFunction(t, o), this.match(55) && (i && this.raise(Z.GeneratorInSingleStatementContext, this.state.startLoc), this.next(), t.
      generator = !0), n && (t.id = this.parseFunctionId(a));
      let u = this.state.maybeInArrowParameters;
      return this.state.maybeInArrowParameters = !1, this.scope.enter(2), this.prodParam.enter(U_(o, t.generator)), n || (t.id = this.parseFunctionId()),
      this.parseFunctionParams(t, !1), this.withSmartMixTopicForbiddingContext(() => {
        this.parseFunctionBodyAndFinish(t, n ? "FunctionDeclaration" : "FunctionExpression");
      }), this.prodParam.exit(), this.scope.exit(), n && !i && this.registerFunctionStatementId(t), this.state.maybeInArrowParameters = u, t;
    }
    parseFunctionId(t) {
      return t || Ar(this.state.type) ? this.parseIdentifier() : null;
    }
    parseFunctionParams(t, r) {
      this.expect(10), this.expressionScope.enter(mqe()), t.params = this.parseBindingList(11, 41, 2 | (r ? 4 : 0)), this.expressionScope.exit();
    }
    registerFunctionStatementId(t) {
      t.id && this.scope.declareName(t.id.name, !this.options.annexB || this.state.strict || t.generator || t.async ? this.scope.treatFunctionsAsVar ?
      5 : 8201 : 17, t.id.loc.start);
    }
    parseClass(t, r, i) {
      this.next();
      let n = this.state.strict;
      return this.state.strict = !0, this.parseClassId(t, r, i), this.parseClassSuper(t), t.body = this.parseClassBody(!!t.superClass, n), this.
      finishNode(t, r ? "ClassDeclaration" : "ClassExpression");
    }
    isClassProperty() {
      return this.match(29) || this.match(13) || this.match(8);
    }
    isClassMethod() {
      return this.match(10);
    }
    nameIsConstructor(t) {
      return t.type === "Identifier" && t.name === "constructor" || t.type === "StringLiteral" && t.value === "constructor";
    }
    isNonstaticConstructor(t) {
      return !t.computed && !t.static && this.nameIsConstructor(t.key);
    }
    parseClassBody(t, r) {
      this.classScope.enter();
      let i = {
        hadConstructor: !1,
        hadSuperClass: t
      }, n = [], a = this.startNode();
      if (a.body = [], this.expect(5), this.withSmartMixTopicForbiddingContext(() => {
        for (; !this.match(8); ) {
          if (this.eat(13)) {
            if (n.length > 0)
              throw this.raise(Z.DecoratorSemicolon, this.state.lastTokEndLoc);
            continue;
          }
          if (this.match(26)) {
            n.push(this.parseDecorator());
            continue;
          }
          let o = this.startNode();
          n.length && (o.decorators = n, this.resetStartLocationFromNode(o, n[0]), n = []), this.parseClassMember(a, o, i), o.kind === "cons\
tructor" && o.decorators && o.decorators.length > 0 && this.raise(Z.DecoratorConstructor, o);
        }
      }), this.state.strict = r, this.next(), n.length)
        throw this.raise(Z.TrailingDecorator, this.state.startLoc);
      return this.classScope.exit(), this.finishNode(a, "ClassBody");
    }
    parseClassMemberFromModifier(t, r) {
      let i = this.parseIdentifier(!0);
      if (this.isClassMethod()) {
        let n = r;
        return n.kind = "method", n.computed = !1, n.key = i, n.static = !1, this.pushClassMethod(t, n, !1, !1, !1, !1), !0;
      } else if (this.isClassProperty()) {
        let n = r;
        return n.computed = !1, n.key = i, n.static = !1, t.body.push(this.parseClassProperty(n)), !0;
      }
      return this.resetPreviousNodeTrailingComments(i), !1;
    }
    parseClassMember(t, r, i) {
      let n = this.isContextual(106);
      if (n) {
        if (this.parseClassMemberFromModifier(t, r))
          return;
        if (this.eat(5)) {
          this.parseClassStaticBlock(t, r);
          return;
        }
      }
      this.parseClassMemberWithIsStatic(t, r, i, n);
    }
    parseClassMemberWithIsStatic(t, r, i, n) {
      let a = r, o = r, u = r, l = r, c = r, p = a, h = a;
      if (r.static = n, this.parsePropertyNamePrefixOperator(r), this.eat(55)) {
        p.kind = "method";
        let d = this.match(139);
        if (this.parseClassElementName(p), d) {
          this.pushClassPrivateMethod(t, o, !0, !1);
          return;
        }
        this.isNonstaticConstructor(a) && this.raise(Z.ConstructorIsGenerator, a.key), this.pushClassMethod(t, a, !0, !1, !1, !1);
        return;
      }
      let y = !this.state.containsEsc && Ar(this.state.type), _ = this.parseClassElementName(r), g = y ? _.name : null, m = this.isPrivateName(
      _), f = this.state.startLoc;
      if (this.parsePostMemberNameModifiers(h), this.isClassMethod()) {
        if (p.kind = "method", m) {
          this.pushClassPrivateMethod(t, o, !1, !1);
          return;
        }
        let d = this.isNonstaticConstructor(a), v = !1;
        d && (a.kind = "constructor", i.hadConstructor && !this.hasPlugin("typescript") && this.raise(Z.DuplicateConstructor, _), d && this.
        hasPlugin("typescript") && r.override && this.raise(Z.OverrideOnConstructor, _), i.hadConstructor = !0, v = i.hadSuperClass), this.pushClassMethod(
        t, a, !1, !1, d, v);
      } else if (this.isClassProperty())
        m ? this.pushClassPrivateProperty(t, l) : this.pushClassProperty(t, u);
      else if (g === "async" && !this.isLineTerminator()) {
        this.resetPreviousNodeTrailingComments(_);
        let d = this.eat(55);
        h.optional && this.unexpected(f), p.kind = "method";
        let v = this.match(139);
        this.parseClassElementName(p), this.parsePostMemberNameModifiers(h), v ? this.pushClassPrivateMethod(t, o, d, !0) : (this.isNonstaticConstructor(
        a) && this.raise(Z.ConstructorIsAsync, a.key), this.pushClassMethod(t, a, d, !0, !1, !1));
      } else if ((g === "get" || g === "set") && !(this.match(55) && this.isLineTerminator())) {
        this.resetPreviousNodeTrailingComments(_), p.kind = g;
        let d = this.match(139);
        this.parseClassElementName(a), d ? this.pushClassPrivateMethod(t, o, !1, !1) : (this.isNonstaticConstructor(a) && this.raise(Z.ConstructorIsAccessor,
        a.key), this.pushClassMethod(t, a, !1, !1, !1, !1)), this.checkGetterSetterParams(a);
      } else if (g === "accessor" && !this.isLineTerminator()) {
        this.expectPlugin("decoratorAutoAccessors"), this.resetPreviousNodeTrailingComments(_);
        let d = this.match(139);
        this.parseClassElementName(u), this.pushClassAccessorProperty(t, c, d);
      } else this.isLineTerminator() ? m ? this.pushClassPrivateProperty(t, l) : this.pushClassProperty(t, u) : this.unexpected();
    }
    parseClassElementName(t) {
      let {
        type: r,
        value: i
      } = this.state;
      if ((r === 132 || r === 134) && t.static && i === "prototype" && this.raise(Z.StaticPrototype, this.state.startLoc), r === 139) {
        i === "constructor" && this.raise(Z.ConstructorClassPrivateField, this.state.startLoc);
        let n = this.parsePrivateName();
        return t.key = n, n;
      }
      return this.parsePropertyName(t), t.key;
    }
    parseClassStaticBlock(t, r) {
      var i;
      this.scope.enter(208);
      let n = this.state.labels;
      this.state.labels = [], this.prodParam.enter(0);
      let a = r.body = [];
      this.parseBlockOrModuleBlockBody(a, void 0, !1, 8), this.prodParam.exit(), this.scope.exit(), this.state.labels = n, t.body.push(this.
      finishNode(r, "StaticBlock")), (i = r.decorators) != null && i.length && this.raise(Z.DecoratorStaticBlock, r);
    }
    pushClassProperty(t, r) {
      !r.computed && this.nameIsConstructor(r.key) && this.raise(Z.ConstructorClassField, r.key), t.body.push(this.parseClassProperty(r));
    }
    pushClassPrivateProperty(t, r) {
      let i = this.parseClassPrivateProperty(r);
      t.body.push(i), this.classScope.declarePrivateName(this.getPrivateNameSV(i.key), 0, i.key.loc.start);
    }
    pushClassAccessorProperty(t, r, i) {
      !i && !r.computed && this.nameIsConstructor(r.key) && this.raise(Z.ConstructorClassField, r.key);
      let n = this.parseClassAccessorProperty(r);
      t.body.push(n), i && this.classScope.declarePrivateName(this.getPrivateNameSV(n.key), 0, n.key.loc.start);
    }
    pushClassMethod(t, r, i, n, a, o) {
      t.body.push(this.parseMethod(r, i, n, a, o, "ClassMethod", !0));
    }
    pushClassPrivateMethod(t, r, i, n) {
      let a = this.parseMethod(r, i, n, !1, !1, "ClassPrivateMethod", !0);
      t.body.push(a);
      let o = a.kind === "get" ? a.static ? 6 : 2 : a.kind === "set" ? a.static ? 5 : 1 : 0;
      this.declareClassPrivateMethodInScope(a, o);
    }
    declareClassPrivateMethodInScope(t, r) {
      this.classScope.declarePrivateName(this.getPrivateNameSV(t.key), r, t.key.loc.start);
    }
    parsePostMemberNameModifiers(t) {
    }
    parseClassPrivateProperty(t) {
      return this.parseInitializer(t), this.semicolon(), this.finishNode(t, "ClassPrivateProperty");
    }
    parseClassProperty(t) {
      return this.parseInitializer(t), this.semicolon(), this.finishNode(t, "ClassProperty");
    }
    parseClassAccessorProperty(t) {
      return this.parseInitializer(t), this.semicolon(), this.finishNode(t, "ClassAccessorProperty");
    }
    parseInitializer(t) {
      this.scope.enter(80), this.expressionScope.enter(V9()), this.prodParam.enter(0), t.value = this.eat(29) ? this.parseMaybeAssignAllowIn() :
      null, this.expressionScope.exit(), this.prodParam.exit(), this.scope.exit();
    }
    parseClassId(t, r, i, n = 8331) {
      if (Ar(this.state.type))
        t.id = this.parseIdentifier(), r && this.declareNameFromIdentifier(t.id, n);
      else if (i || !r)
        t.id = null;
      else
        throw this.raise(Z.MissingClassName, this.state.startLoc);
    }
    parseClassSuper(t) {
      t.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
    }
    parseExport(t, r) {
      let i = this.parseMaybeImportPhase(t, !0), n = this.maybeParseExportDefaultSpecifier(t, i), a = !n || this.eat(12), o = a && this.eatExportStar(
      t), u = o && this.maybeParseExportNamespaceSpecifier(t), l = a && (!u || this.eat(12)), c = n || o;
      if (o && !u) {
        if (n && this.unexpected(), r)
          throw this.raise(Z.UnsupportedDecoratorExport, t);
        return this.parseExportFrom(t, !0), this.sawUnambiguousESM = !0, this.finishNode(t, "ExportAllDeclaration");
      }
      let p = this.maybeParseExportNamedSpecifiers(t);
      n && a && !o && !p && this.unexpected(null, 5), u && l && this.unexpected(null, 98);
      let h;
      if (c || p) {
        if (h = !1, r)
          throw this.raise(Z.UnsupportedDecoratorExport, t);
        this.parseExportFrom(t, c);
      } else
        h = this.maybeParseExportDeclaration(t);
      if (c || p || h) {
        var y;
        let _ = t;
        if (this.checkExport(_, !0, !1, !!_.source), ((y = _.declaration) == null ? void 0 : y.type) === "ClassDeclaration")
          this.maybeTakeDecorators(r, _.declaration, _);
        else if (r)
          throw this.raise(Z.UnsupportedDecoratorExport, t);
        return this.sawUnambiguousESM = !0, this.finishNode(_, "ExportNamedDeclaration");
      }
      if (this.eat(65)) {
        let _ = t, g = this.parseExportDefaultExpression();
        if (_.declaration = g, g.type === "ClassDeclaration")
          this.maybeTakeDecorators(r, g, _);
        else if (r)
          throw this.raise(Z.UnsupportedDecoratorExport, t);
        return this.checkExport(_, !0, !0), this.sawUnambiguousESM = !0, this.finishNode(_, "ExportDefaultDeclaration");
      }
      this.unexpected(null, 5);
    }
    eatExportStar(t) {
      return this.eat(55);
    }
    maybeParseExportDefaultSpecifier(t, r) {
      if (r || this.isExportDefaultSpecifier()) {
        this.expectPlugin("exportDefaultFrom", r?.loc.start);
        let i = r || this.parseIdentifier(!0), n = this.startNodeAtNode(i);
        return n.exported = i, t.specifiers = [this.finishNode(n, "ExportDefaultSpecifier")], !0;
      }
      return !1;
    }
    maybeParseExportNamespaceSpecifier(t) {
      if (this.isContextual(93)) {
        var r, i;
        (i = (r = t).specifiers) != null || (r.specifiers = []);
        let n = this.startNodeAt(this.state.lastTokStartLoc);
        return this.next(), n.exported = this.parseModuleExportName(), t.specifiers.push(this.finishNode(n, "ExportNamespaceSpecifier")), !0;
      }
      return !1;
    }
    maybeParseExportNamedSpecifiers(t) {
      if (this.match(5)) {
        let r = t;
        r.specifiers || (r.specifiers = []);
        let i = r.exportKind === "type";
        return r.specifiers.push(...this.parseExportSpecifiers(i)), r.source = null, this.hasPlugin("importAssertions") ? r.assertions = [] :
        r.attributes = [], r.declaration = null, !0;
      }
      return !1;
    }
    maybeParseExportDeclaration(t) {
      return this.shouldParseExportDeclaration() ? (t.specifiers = [], t.source = null, this.hasPlugin("importAssertions") ? t.assertions = [] :
      t.attributes = [], t.declaration = this.parseExportDeclaration(t), !0) : !1;
    }
    isAsyncFunction() {
      if (!this.isContextual(95)) return !1;
      let t = this.nextTokenInLineStart();
      return this.isUnparsedContextual(t, "function");
    }
    parseExportDefaultExpression() {
      let t = this.startNode();
      if (this.match(68))
        return this.next(), this.parseFunction(t, 5);
      if (this.isAsyncFunction())
        return this.next(), this.next(), this.parseFunction(t, 13);
      if (this.match(80))
        return this.parseClass(t, !0, !0);
      if (this.match(26))
        return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") === !0 && this.raise(Z.DecoratorBeforeExport,
        this.state.startLoc), this.parseClass(this.maybeTakeDecorators(this.parseDecorators(!1), this.startNode()), !0, !0);
      if (this.match(75) || this.match(74) || this.isLet())
        throw this.raise(Z.UnsupportedDefaultExport, this.state.startLoc);
      let r = this.parseMaybeAssignAllowIn();
      return this.semicolon(), r;
    }
    parseExportDeclaration(t) {
      return this.match(80) ? this.parseClass(this.startNode(), !0, !1) : this.parseStatementListItem();
    }
    isExportDefaultSpecifier() {
      let {
        type: t
      } = this.state;
      if (Ar(t)) {
        if (t === 95 && !this.state.containsEsc || t === 100)
          return !1;
        if ((t === 130 || t === 129) && !this.state.containsEsc) {
          let {
            type: n
          } = this.lookahead();
          if (Ar(n) && n !== 98 || n === 5)
            return this.expectOnePlugin(["flow", "typescript"]), !1;
        }
      } else if (!this.match(65))
        return !1;
      let r = this.nextTokenStart(), i = this.isUnparsedContextual(r, "from");
      if (this.input.charCodeAt(r) === 44 || Ar(this.state.type) && i)
        return !0;
      if (this.match(65) && i) {
        let n = this.input.charCodeAt(this.nextTokenStartSince(r + 4));
        return n === 34 || n === 39;
      }
      return !1;
    }
    parseExportFrom(t, r) {
      this.eatContextual(98) ? (t.source = this.parseImportSource(), this.checkExport(t), this.maybeParseImportAttributes(t), this.checkJSONModuleImport(
      t)) : r && this.unexpected(), this.semicolon();
    }
    shouldParseExportDeclaration() {
      let {
        type: t
      } = this.state;
      return t === 26 && (this.expectOnePlugin(["decorators", "decorators-legacy"]), this.hasPlugin("decorators")) ? (this.getPluginOption("\
decorators", "decoratorsBeforeExport") === !0 && this.raise(Z.DecoratorBeforeExport, this.state.startLoc), !0) : this.isContextual(107) ? (this.
      raise(Z.UsingDeclarationExport, this.state.startLoc), !0) : this.isContextual(96) && this.startsAwaitUsing() ? (this.raise(Z.UsingDeclarationExport,
      this.state.startLoc), !0) : t === 74 || t === 75 || t === 68 || t === 80 || this.isLet() || this.isAsyncFunction();
    }
    checkExport(t, r, i, n) {
      if (r) {
        var a;
        if (i) {
          if (this.checkDuplicateExports(t, "default"), this.hasPlugin("exportDefaultFrom")) {
            var o;
            let u = t.declaration;
            u.type === "Identifier" && u.name === "from" && u.end - u.start === 4 && !((o = u.extra) != null && o.parenthesized) && this.raise(
            Z.ExportDefaultFromAsIdentifier, u);
          }
        } else if ((a = t.specifiers) != null && a.length)
          for (let u of t.specifiers) {
            let {
              exported: l
            } = u, c = l.type === "Identifier" ? l.name : l.value;
            if (this.checkDuplicateExports(u, c), !n && u.local) {
              let {
                local: p
              } = u;
              p.type !== "Identifier" ? this.raise(Z.ExportBindingIsString, u, {
                localName: p.value,
                exportName: c
              }) : (this.checkReservedWord(p.name, p.loc.start, !0, !1), this.scope.checkLocalExport(p));
            }
          }
        else if (t.declaration) {
          let u = t.declaration;
          if (u.type === "FunctionDeclaration" || u.type === "ClassDeclaration") {
            let {
              id: l
            } = u;
            if (!l) throw new Error("Assertion failure");
            this.checkDuplicateExports(t, l.name);
          } else if (u.type === "VariableDeclaration")
            for (let l of u.declarations)
              this.checkDeclaration(l.id);
        }
      }
    }
    checkDeclaration(t) {
      if (t.type === "Identifier")
        this.checkDuplicateExports(t, t.name);
      else if (t.type === "ObjectPattern")
        for (let r of t.properties)
          this.checkDeclaration(r);
      else if (t.type === "ArrayPattern")
        for (let r of t.elements)
          r && this.checkDeclaration(r);
      else t.type === "ObjectProperty" ? this.checkDeclaration(t.value) : t.type === "RestElement" ? this.checkDeclaration(t.argument) : t.type ===
      "AssignmentPattern" && this.checkDeclaration(t.left);
    }
    checkDuplicateExports(t, r) {
      this.exportedIdentifiers.has(r) && (r === "default" ? this.raise(Z.DuplicateDefaultExport, t) : this.raise(Z.DuplicateExport, t, {
        exportName: r
      })), this.exportedIdentifiers.add(r);
    }
    parseExportSpecifiers(t) {
      let r = [], i = !0;
      for (this.expect(5); !this.eat(8); ) {
        if (i)
          i = !1;
        else if (this.expect(12), this.eat(8)) break;
        let n = this.isContextual(130), a = this.match(134), o = this.startNode();
        o.local = this.parseModuleExportName(), r.push(this.parseExportSpecifier(o, a, t, n));
      }
      return r;
    }
    parseExportSpecifier(t, r, i, n) {
      return this.eatContextual(93) ? t.exported = this.parseModuleExportName() : r ? t.exported = bqe(t.local) : t.exported || (t.exported =
      Au(t.local)), this.finishNode(t, "ExportSpecifier");
    }
    parseModuleExportName() {
      if (this.match(134)) {
        let t = this.parseStringLiteral(this.state.value), r = Uqe.exec(t.value);
        return r && this.raise(Z.ModuleExportNameHasLoneSurrogate, t, {
          surrogateCharCode: r[0].charCodeAt(0)
        }), t;
      }
      return this.parseIdentifier(!0);
    }
    isJSONModuleImport(t) {
      return t.assertions != null ? t.assertions.some(({
        key: r,
        value: i
      }) => i.value === "json" && (r.type === "Identifier" ? r.name === "type" : r.value === "type")) : !1;
    }
    checkImportReflection(t) {
      let {
        specifiers: r
      } = t, i = r.length === 1 ? r[0].type : null;
      if (t.phase === "source")
        i !== "ImportDefaultSpecifier" && this.raise(Z.SourcePhaseImportRequiresDefault, r[0].loc.start);
      else if (t.phase === "defer")
        i !== "ImportNamespaceSpecifier" && this.raise(Z.DeferImportRequiresNamespace, r[0].loc.start);
      else if (t.module) {
        var n;
        i !== "ImportDefaultSpecifier" && this.raise(Z.ImportReflectionNotBinding, r[0].loc.start), ((n = t.assertions) == null ? void 0 : n.
        length) > 0 && this.raise(Z.ImportReflectionHasAssertion, r[0].loc.start);
      }
    }
    checkJSONModuleImport(t) {
      if (this.isJSONModuleImport(t) && t.type !== "ExportAllDeclaration") {
        let {
          specifiers: r
        } = t;
        if (r != null) {
          let i = r.find((n) => {
            let a;
            if (n.type === "ExportSpecifier" ? a = n.local : n.type === "ImportSpecifier" && (a = n.imported), a !== void 0)
              return a.type === "Identifier" ? a.name !== "default" : a.value !== "default";
          });
          i !== void 0 && this.raise(Z.ImportJSONBindingNotDefault, i.loc.start);
        }
      }
    }
    isPotentialImportPhase(t) {
      return t ? !1 : this.isContextual(105) || this.isContextual(97) || this.isContextual(127);
    }
    applyImportPhase(t, r, i, n) {
      r || (i === "module" ? (this.expectPlugin("importReflection", n), t.module = !0) : this.hasPlugin("importReflection") && (t.module = !1),
      i === "source" ? (this.expectPlugin("sourcePhaseImports", n), t.phase = "source") : i === "defer" ? (this.expectPlugin("deferredImport\
Evaluation", n), t.phase = "defer") : this.hasPlugin("sourcePhaseImports") && (t.phase = null));
    }
    parseMaybeImportPhase(t, r) {
      if (!this.isPotentialImportPhase(r))
        return this.applyImportPhase(t, r, null), null;
      let i = this.parseIdentifier(!0), {
        type: n
      } = this.state;
      return (Ga(n) ? n !== 98 || this.lookaheadCharCode() === 102 : n !== 12) ? (this.resetPreviousIdentifierLeadingComments(i), this.applyImportPhase(
      t, r, i.name, i.loc.start), null) : (this.applyImportPhase(t, r, null), i);
    }
    isPrecedingIdImportPhase(t) {
      let {
        type: r
      } = this.state;
      return Ar(r) ? r !== 98 || this.lookaheadCharCode() === 102 : r !== 12;
    }
    parseImport(t) {
      return this.match(134) ? this.parseImportSourceAndAttributes(t) : this.parseImportSpecifiersAndAfter(t, this.parseMaybeImportPhase(t, !1));
    }
    parseImportSpecifiersAndAfter(t, r) {
      t.specifiers = [];
      let n = !this.maybeParseDefaultImportSpecifier(t, r) || this.eat(12), a = n && this.maybeParseStarImportSpecifier(t);
      return n && !a && this.parseNamedImportSpecifiers(t), this.expectContextual(98), this.parseImportSourceAndAttributes(t);
    }
    parseImportSourceAndAttributes(t) {
      var r;
      return (r = t.specifiers) != null || (t.specifiers = []), t.source = this.parseImportSource(), this.maybeParseImportAttributes(t), this.
      checkImportReflection(t), this.checkJSONModuleImport(t), this.semicolon(), this.sawUnambiguousESM = !0, this.finishNode(t, "ImportDecl\
aration");
    }
    parseImportSource() {
      return this.match(134) || this.unexpected(), this.parseExprAtom();
    }
    parseImportSpecifierLocal(t, r, i) {
      r.local = this.parseIdentifier(), t.specifiers.push(this.finishImportSpecifier(r, i));
    }
    finishImportSpecifier(t, r, i = 8201) {
      return this.checkLVal(t.local, {
        type: r
      }, i), this.finishNode(t, r);
    }
    parseImportAttributes() {
      this.expect(5);
      let t = [], r = /* @__PURE__ */ new Set();
      do {
        if (this.match(8))
          break;
        let i = this.startNode(), n = this.state.value;
        if (r.has(n) && this.raise(Z.ModuleAttributesWithDuplicateKeys, this.state.startLoc, {
          key: n
        }), r.add(n), this.match(134) ? i.key = this.parseStringLiteral(n) : i.key = this.parseIdentifier(!0), this.expect(14), !this.match(
        134))
          throw this.raise(Z.ModuleAttributeInvalidValue, this.state.startLoc);
        i.value = this.parseStringLiteral(this.state.value), t.push(this.finishNode(i, "ImportAttribute"));
      } while (this.eat(12));
      return this.expect(8), t;
    }
    parseModuleAttributes() {
      let t = [], r = /* @__PURE__ */ new Set();
      do {
        let i = this.startNode();
        if (i.key = this.parseIdentifier(!0), i.key.name !== "type" && this.raise(Z.ModuleAttributeDifferentFromType, i.key), r.has(i.key.name) &&
        this.raise(Z.ModuleAttributesWithDuplicateKeys, i.key, {
          key: i.key.name
        }), r.add(i.key.name), this.expect(14), !this.match(134))
          throw this.raise(Z.ModuleAttributeInvalidValue, this.state.startLoc);
        i.value = this.parseStringLiteral(this.state.value), t.push(this.finishNode(i, "ImportAttribute"));
      } while (this.eat(12));
      return t;
    }
    maybeParseImportAttributes(t) {
      let r;
      var i = !1;
      if (this.match(76)) {
        if (this.hasPrecedingLineBreak() && this.lookaheadCharCode() === 40)
          return;
        this.next(), this.hasPlugin("moduleAttributes") ? (r = this.parseModuleAttributes(), this.addExtra(t, "deprecatedWithLegacySyntax", !0)) :
        r = this.parseImportAttributes(), i = !0;
      } else this.isContextual(94) && !this.hasPrecedingLineBreak() ? (!this.hasPlugin("deprecatedImportAssert") && !this.hasPlugin("importA\
ssertions") && this.raise(Z.ImportAttributesUseAssert, this.state.startLoc), this.hasPlugin("importAssertions") || this.addExtra(t, "depreca\
tedAssertSyntax", !0), this.next(), r = this.parseImportAttributes()) : r = [];
      !i && this.hasPlugin("importAssertions") ? t.assertions = r : t.attributes = r;
    }
    maybeParseDefaultImportSpecifier(t, r) {
      if (r) {
        let i = this.startNodeAtNode(r);
        return i.local = r, t.specifiers.push(this.finishImportSpecifier(i, "ImportDefaultSpecifier")), !0;
      } else if (Ga(this.state.type))
        return this.parseImportSpecifierLocal(t, this.startNode(), "ImportDefaultSpecifier"), !0;
      return !1;
    }
    maybeParseStarImportSpecifier(t) {
      if (this.match(55)) {
        let r = this.startNode();
        return this.next(), this.expectContextual(93), this.parseImportSpecifierLocal(t, r, "ImportNamespaceSpecifier"), !0;
      }
      return !1;
    }
    parseNamedImportSpecifiers(t) {
      let r = !0;
      for (this.expect(5); !this.eat(8); ) {
        if (r)
          r = !1;
        else {
          if (this.eat(14))
            throw this.raise(Z.DestructureNamedImport, this.state.startLoc);
          if (this.expect(12), this.eat(8)) break;
        }
        let i = this.startNode(), n = this.match(134), a = this.isContextual(130);
        i.imported = this.parseModuleExportName();
        let o = this.parseImportSpecifier(i, n, t.importKind === "type" || t.importKind === "typeof", a, void 0);
        t.specifiers.push(o);
      }
    }
    parseImportSpecifier(t, r, i, n, a) {
      if (this.eatContextual(93))
        t.local = this.parseIdentifier();
      else {
        let {
          imported: o
        } = t;
        if (r)
          throw this.raise(Z.ImportBindingIsString, t, {
            importName: o.value
          });
        this.checkReservedWord(o.name, t.loc.start, !0, !0), t.local || (t.local = Au(o));
      }
      return this.finishImportSpecifier(t, "ImportSpecifier", a);
    }
    isThisParam(t) {
      return t.type === "Identifier" && t.name === "this";
    }
  }, H_ = class extends AP {
    static {
      s(this, "Parser");
    }
    constructor(t, r, i) {
      t = M3e(t), super(t, r), this.options = t, this.initializeScopes(), this.plugins = i, this.filename = t.sourceFilename, this.startIndex =
      t.startIndex;
      let n = 0;
      t.allowAwaitOutsideFunction && (n |= 1), t.allowReturnOutsideFunction && (n |= 2), t.allowImportExportEverywhere && (n |= 8), t.allowSuperOutsideMethod &&
      (n |= 16), t.allowUndeclaredExports && (n |= 64), t.allowNewTargetOutsideFunction && (n |= 4), t.allowYieldOutsideFunction && (n |= 32),
      t.ranges && (n |= 128), t.tokens && (n |= 256), t.createImportExpressions && (n |= 512), t.createParenthesizedExpressions && (n |= 1024),
      t.errorRecovery && (n |= 2048), t.attachComment && (n |= 4096), t.annexB && (n |= 8192), this.optionFlags = n;
    }
    getScopeHandler() {
      return Pd;
    }
    parse() {
      this.enterInitialScopes();
      let t = this.startNode(), r = this.startNode();
      return this.nextToken(), t.errors = null, this.parseTopLevel(t, r), t.errors = this.state.errors, t.comments.length = this.state.commentsLen,
      t;
    }
  };
  function Vqe(e, t) {
    var r;
    if (((r = t) == null ? void 0 : r.sourceType) === "unambiguous") {
      t = Object.assign({}, t);
      try {
        t.sourceType = "module";
        let i = Ad(t, e), n = i.parse();
        if (i.sawUnambiguousESM)
          return n;
        if (i.ambiguousScriptDifferentAst)
          try {
            return t.sourceType = "script", Ad(t, e).parse();
          } catch {
          }
        else
          n.program.sourceType = "script";
        return n;
      } catch (i) {
        try {
          return t.sourceType = "script", Ad(t, e).parse();
        } catch {
        }
        throw i;
      }
    } else
      return Ad(t, e).parse();
  }
  s(Vqe, "parse");
  function Kqe(e, t) {
    let r = Ad(t, e);
    return r.options.strictMode && (r.state.strict = !0), r.getExpression();
  }
  s(Kqe, "parseExpression");
  function Hqe(e) {
    let t = {};
    for (let r of Object.keys(e))
      t[r] = vu(e[r]);
    return t;
  }
  s(Hqe, "generateExportedTokenTypes");
  var zqe = Hqe(j3e);
  function Ad(e, t) {
    let r = H_, i = /* @__PURE__ */ new Map();
    if (e != null && e.plugins) {
      for (let n of e.plugins) {
        let a, o;
        typeof n == "string" ? a = n : [a, o] = n, i.has(a) || i.set(a, o || {});
      }
      Mqe(i), r = Gqe(i);
    }
    return new r(e, t, i);
  }
  s(Ad, "getParser");
  var k9 = /* @__PURE__ */ new Map();
  function Gqe(e) {
    let t = [];
    for (let n of Bqe)
      e.has(n) && t.push(n);
    let r = t.join("|"), i = k9.get(r);
    if (!i) {
      i = H_;
      for (let n of t)
        i = G9[n](i);
      k9.set(r, i);
    }
    return i;
  }
  s(Gqe, "getParserClass");
  wd.parse = Vqe;
  wd.parseExpression = Kqe;
  wd.tokTypes = zqe;
});

// ../node_modules/resolve.exports/dist/index.mjs
function $9(e, t, r) {
  throw new Error(r ? `No known conditions for "${t}" specifier in "${e}" package` : `Missing "${t}" specifier in "${e}" package`);
}
function Wqe(e, t, r, i) {
  let n, a, o = $qe(e, r), u = function(c) {
    let p = /* @__PURE__ */ new Set(["default", ...c.conditions || []]);
    return c.unsafe || p.add(c.require ? "require" : "import"), c.unsafe || p.add(c.browser ? "browser" : "node"), p;
  }(i || {}), l = t[o];
  if (l === void 0) {
    let c, p, h, y;
    for (y in t) p && y.length < p.length || (y[y.length - 1] === "/" && o.startsWith(y) ? (a = o.substring(y.length), p = y) : y.length > 1 &&
    (h = y.indexOf("*", 1), ~h && (c = RegExp("^" + y.substring(0, h) + "(.*)" + y.substring(1 + h) + "$").exec(o), c && c[1] && (a = c[1], p =
    y))));
    l = t[p];
  }
  return l || $9(e, o), n = LP(l, u), n || $9(e, o, 1), a && function(c, p) {
    let h, y = 0, _ = c.length, g = /[*]/g, m = /[/]$/;
    for (; y < _; y++) c[y] = g.test(h = c[y]) ? h.replace(g, p) : m.test(h) ? h + p : h;
  }(n, a), n;
}
function $qe(e, t, r) {
  if (e === t || t === ".") return ".";
  let i = e + "/", n = i.length, a = t.slice(0, n) === i, o = a ? t.slice(n) : t;
  return o[0] === "#" ? o : a || !r ? o.slice(0, 2) === "./" ? o : "./" + o : o;
}
function LP(e, t, r) {
  if (e) {
    if (typeof e == "string") return r && r.add(e), [e];
    let i, n;
    if (Array.isArray(e)) {
      for (n = r || /* @__PURE__ */ new Set(), i = 0; i < e.length; i++) LP(e[i], t, n);
      if (!r && n.size) return [...n];
    } else for (i in e) if (t.has(i)) return LP(e[i], t, r);
  }
}
function X9(e, t, r) {
  let i, n = e.exports;
  if (n) {
    if (typeof n == "string") n = { ".": n };
    else for (i in n) {
      i[0] !== "." && (n = { ".": n });
      break;
    }
    return Wqe(e.name, n, t || ".", r);
  }
}
var Y9 = at(() => {
  s($9, "e");
  s(Wqe, "n");
  s($qe, "r");
  s(LP, "t");
  s(X9, "o");
});

// src/core-server/mocking-utils/resolve.ts
function Xqe(e, t) {
  let r = require.resolve(`${e}/package.json`, { paths: [t] });
  return {
    path: r,
    data: JSON.parse((0, J9.readFileSync)(r, "utf-8"))
  };
}
function FP(e, t) {
  let r = e.split("/"), i = e.startsWith("@") ? `${r[0]}/${r[1]}` : r[0], n = `.${e.slice(i.length)}`, { path: a, data: o } = Xqe(i, t), u = Mg(
  a);
  if (o.exports) {
    let l = X9(o, n, {
      browser: !0
    });
    if (l)
      return px(u, l[0]);
  }
  return require.resolve(e, { paths: [t] });
}
function MP(e, t) {
  try {
    return !sl(e) && Z9(require.resolve(e, { paths: [t] }));
  } catch {
    return !1;
  }
}
function z_(e, t, r) {
  let i = MP(e, t), n = i ? e : null, a = i ? FP(e, t) : require.resolve(e, { paths: [Mg(r)] }), o = hx(a), u = (0, Q9.findMockRedirect)(t, o,
  n);
  return {
    absolutePath: o,
    redirectPath: u
    // will be null if no __mocks__ file is found
  };
}
var J9, Q9, BP = at(() => {
  "use strict";
  J9 = require("node:fs"), Q9 = require("@vitest/mocker/redirect");
  qg();
  Y9();
  G_();
  s(Xqe, "findPackageJson");
  s(FP, "resolveExternalModule");
  s(MP, "getIsExternal");
  s(z_, "resolveMock");
});

// src/core-server/mocking-utils/extract.ts
function Z9(e) {
  let t = Vf(e);
  return Yqe.some((r) => t.includes(r));
}
function o6(e) {
  let t = yc(e);
  return Gg(t, {
    enter(r) {
      r.type === "CallExpression" && r.callee.type === "MemberExpression" && r.callee.object.type === "Identifier" && r.callee.object.name ===
      "sb" && r.callee.property.type === "Identifier" && r.callee.property.name === "mock" && r.arguments.length > 0 && r.arguments[0].type ===
      "CallExpression" && r.arguments[0].callee.type === "Import" && r.arguments[0].arguments.length === 1 && r.arguments[0].arguments[0].type ===
      "StringLiteral" && (r.arguments[0] = n6.stringLiteral(r.arguments[0].arguments[0].value));
    }
  }), (0, r6.generate)(t, {}, e);
}
function Od(e, t, r) {
  try {
    let l = function(c) {
      if (!c || !c.properties)
        return !1;
      for (let p of c.properties)
        if (p.type === "ObjectProperty" && (p.key.type === "Identifier" && p.key.name === "spy" || p.key.type === "StringLiteral" && p.key.value ===
        "spy") && p.value.type === "BooleanLiteral" && p.value.value === !0)
          return !0;
      return !1;
    };
    var i = l;
    s(l, "hasSpyTrue");
    let n = (0, a6.readFileSync)(e.previewConfigPath, "utf-8"), { code: a } = (0, s6.transformSync)(n, { loader: "tsx", format: "esm" }), o = t(
    a), u = [];
    return Gg(o, {
      // @ts-expect-error - Node comes from babel
      async enter(c) {
        if (c.type !== "CallExpression" || c.callee.type !== "MemberExpression" || c.callee.object.type !== "Identifier" || c.callee.object.
        name !== "sb" || c.callee.property.type !== "Identifier" || c.callee.property.name !== "mock" || c.arguments.length === 0)
          return;
        let p;
        if (c.arguments[0].type === "StringLiteral")
          p = c.arguments[0].value;
        else if (c.arguments[0].type === "CallExpression" && c.arguments[0].callee.type === "Import" && c.arguments[0].arguments[0].type ===
        "StringLiteral")
          p = c.arguments[0].arguments[0].value;
        else
          return;
        let h = c.arguments.length > 1 && c.arguments[1].type === "ObjectExpression" && l(c.arguments[1]), { absolutePath: y, redirectPath: _ } = z_(
        p, r, e.previewConfigPath), g = p.replace(/\.[^/.]+$/, ""), m = Bg(y), f = Bg(p), d = m === f ? g : p;
        u.push({
          path: d,
          absolutePath: y,
          redirectPath: _,
          spy: h
        });
      }
    }), e.coreOptions?.disableTelemetry || (0, t6.telemetry)(
      "mocking",
      {
        modulesMocked: u.length,
        modulesSpied: u.map((c) => c.spy).filter(Boolean).length,
        modulesManuallyMocked: u.map((c) => !!c.redirectPath).filter(Boolean).length
      },
      { configDir: e.configDir }
    ), u;
  } catch (n) {
    return e6.logger.debug("Error extracting mock calls", n), [];
  }
}
var e6, t6, r6, i6, n6, s6, a6, Yqe, yc, G_ = at(() => {
  "use strict";
  e6 = require("storybook/internal/node-logger"), t6 = require("storybook/internal/telemetry"), r6 = Gt(y9(), 1), i6 = Gt(W9(), 1), n6 = Gt(Xn(), 1),
  s6 = require("esbuild");
  _x();
  a6 = require("fs");
  qg();
  BP();
  Yqe = ["/node_modules/"];
  s(Z9, "isModuleDirectory");
  yc = /* @__PURE__ */ s((e) => (0, i6.parse)(e, {
    sourceType: "module",
    // Enable plugins to handle modern JavaScript features, including TSX.
    plugins: ["typescript", "jsx", "classProperties", "objectRestSpread"],
    errorRecovery: !0
  }).program, "babelParser");
  s(o6, "rewriteSbMockImportCalls");
  s(Od, "extractMockCalls");
});

// src/core-server/presets/vitePlugins/vite-mock/utils.ts
function W_(e) {
  return e.replace(/^.*\/deps\//, "").replace(/\.js.*$/, "").replace(/_/g, "/");
}
function qP(e, t, r) {
  for (let i of e.moduleGraph.idToModuleMap.values())
    (i.id === t || i.id && W_(i.id) === r) && e.moduleGraph.invalidateModule(i);
}
function kd(e, t) {
  try {
    return t ? (0, u6.realpathSync)(e) : e;
  } catch {
    return e;
  }
}
var u6, l6 = at(() => {
  "use strict";
  u6 = require("fs");
  s(W_, "getCleanId");
  s(qP, "invalidateAllRelatedModules");
  s(kd, "normalizePathForComparison");
});

// src/core-server/presets/vitePlugins/vite-mock/plugin.ts
var f6 = {};
da(f6, {
  viteMockPlugin: () => Jqe
});
function Jqe(e) {
  let t, r = [], i = Vf(e.previewConfigPath);
  return [
    {
      name: "storybook:mock-loader",
      configResolved(n) {
        t = n;
      },
      buildStart() {
        r = Od(e, yc, t.root);
      },
      configureServer(n) {
        async function a(o) {
          if (o === e.previewConfigPath || o.includes("__mocks__")) {
            let u = r;
            r = Od(e, yc, t.root);
            let l = n.moduleGraph.getModuleById(e.previewConfigPath);
            l && n.moduleGraph.invalidateModule(l);
            for (let p of r)
              qP(n, p.absolutePath, p.path);
            let c = new Set(r.map((p) => p.absolutePath));
            for (let p of u)
              c.has(p.absolutePath) || qP(n, p.absolutePath, p.path);
            return n.ws.send({ type: "full-reload" }), [];
          }
        }
        s(a, "invalidateAffectedFiles"), n.watcher.on("change", a), n.watcher.on("add", a), n.watcher.on("unlink", a);
      },
      load: {
        order: "pre",
        handler(n) {
          let a = t.resolve.preserveSymlinks, o = kd(n, a), u = W_(o);
          for (let l of r)
            if (!(kd(l.absolutePath, a) !== o && l.path !== u) && l.redirectPath)
              return this.addWatchFile(l.redirectPath), (0, c6.readFileSync)(l.redirectPath, "utf-8");
          return null;
        }
      },
      transform: {
        order: "pre",
        handler(n, a) {
          for (let o of r) {
            let u = t.resolve.preserveSymlinks, l = kd(a, u), c = kd(o.absolutePath, u);
            if (t.command !== "serve") {
              if (c !== l)
                continue;
            } else {
              let p = W_(l);
              if (o.path !== p && c !== l)
                continue;
            }
            try {
              if (!o.redirectPath) {
                let p = s8(n, o.spy, yc);
                return {
                  code: p.toString(),
                  map: p.generateMap()
                };
              }
            } catch (p) {
              return UP.logger.error(`Error automocking ${a}: ${p}`), null;
            }
          }
          return null;
        }
      }
    },
    {
      name: "storybook:mock-loader-preview",
      transform(n, a) {
        if (a === i)
          try {
            return o6(n);
          } catch (o) {
            return UP.logger.debug(`Could not transform sb.mock(import(...)) calls in ${a}: ${o}`), null;
          }
        return null;
      }
    }
  ];
}
var c6, UP, p6 = at(() => {
  "use strict";
  c6 = require("node:fs"), UP = require("storybook/internal/node-logger");
  qg();
  a8();
  G_();
  l6();
  s(Jqe, "viteMockPlugin");
});

// src/core-server/presets/webpack/plugins/webpack-mock-plugin.ts
var h6 = {};
da(h6, {
  WebpackMockPlugin: () => jP
});
var Id, op, jP, d6 = at(() => {
  "use strict";
  Id = require("node:path");
  G_();
  BP();
  op = "storybook-mock-plugin", jP = class {
    constructor(t) {
      this.mockMap = /* @__PURE__ */ new Map();
      if (!t.previewConfigPath)
        throw new Error(`[${op}] \`previewConfigPath\` is required.`);
      this.options = t;
    }
    static {
      s(this, "WebpackMockPlugin");
    }
    /**
     * The main entry point for the Webpack plugin.
     *
     * @param {Compiler} compiler The Webpack compiler instance.
     */
    apply(t) {
      let r = t.getInfrastructureLogger(op), i = /* @__PURE__ */ s(() => {
        this.mockMap = new Map(
          this.extractAndResolveMocks(t).map((n) => [n.absolutePath, n])
        ), r.info(`Mock map updated with ${this.mockMap.size} mocks.`);
      }, "updateMocks");
      t.hooks.beforeRun.tap(op, i), t.hooks.watchRun.tap(op, i), new t.webpack.NormalModuleReplacementPlugin(/.*/, (n) => {
        try {
          let a = n.request, o = n.context, l = MP(a, o) ? FP(a, o) : require.resolve(a, { paths: [o] });
          if (this.mockMap.has(l)) {
            let c = this.mockMap.get(l);
            n.request = c.replacementResource;
          }
        } catch {
        }
      }).apply(t), t.hooks.afterCompile.tap(op, (n) => {
        n.fileDependencies.add(this.options.previewConfigPath);
        for (let a of this.mockMap.values())
          (0, Id.isAbsolute)(a.replacementResource) && a.replacementResource.includes("__mocks__") && n.contextDependencies.add((0, Id.dirname)(
          a.replacementResource));
      });
    }
    /**
     * Reads the preview config, parses it to find all `sb.mock()` calls, and resolves their
     * corresponding mock implementations.
     *
     * @param {Compiler} compiler The Webpack compiler instance.
     * @returns {ResolvedMock[]} An array of fully processed mocks.
     */
    extractAndResolveMocks(t) {
      let { previewConfigPath: r } = this.options, i = t.getInfrastructureLogger(op), n = Od(
        { previewConfigPath: r, configDir: (0, Id.dirname)(r) },
        yc,
        t.context
      ), a = [];
      for (let o of n)
        try {
          let { absolutePath: u, redirectPath: l } = z_(
            o.path,
            t.context,
            r
          ), c;
          l ? c = l : c = `${require.resolve("storybook/internal/core-server/presets/webpack/loaders/webpack-automock-loader")}?spy=${o.spy}\
!${u}`, a.push({
            ...o,
            absolutePath: u,
            replacementResource: c
          });
        } catch {
          i.warn(`Could not resolve mock for "${o.path}". It will be ignored.`);
        }
      return a;
    }
  };
});

// ../node_modules/lodash/_freeGlobal.js
var VP = b((_Ct, m6) => {
  var Qqe = typeof global == "object" && global && global.Object === Object && global;
  m6.exports = Qqe;
});

// ../node_modules/lodash/_root.js
var Wa = b((bCt, y6) => {
  var Zqe = VP(), e8e = typeof self == "object" && self && self.Object === Object && self, t8e = Zqe || e8e || Function("return this")();
  y6.exports = t8e;
});

// ../node_modules/lodash/_Symbol.js
var $_ = b((vCt, g6) => {
  var r8e = Wa(), i8e = r8e.Symbol;
  g6.exports = i8e;
});

// ../node_modules/lodash/_getRawTag.js
var S6 = b((SCt, v6) => {
  var _6 = $_(), b6 = Object.prototype, n8e = b6.hasOwnProperty, s8e = b6.toString, Rd = _6 ? _6.toStringTag : void 0;
  function a8e(e) {
    var t = n8e.call(e, Rd), r = e[Rd];
    try {
      e[Rd] = void 0;
      var i = !0;
    } catch {
    }
    var n = s8e.call(e);
    return i && (t ? e[Rd] = r : delete e[Rd]), n;
  }
  s(a8e, "getRawTag");
  v6.exports = a8e;
});

// ../node_modules/lodash/_objectToString.js
var E6 = b((ECt, T6) => {
  var o8e = Object.prototype, u8e = o8e.toString;
  function l8e(e) {
    return u8e.call(e);
  }
  s(l8e, "objectToString");
  T6.exports = l8e;
});

// ../node_modules/lodash/_baseGetTag.js
var up = b((xCt, C6) => {
  var A6 = $_(), c8e = S6(), f8e = E6(), p8e = "[object Null]", h8e = "[object Undefined]", x6 = A6 ? A6.toStringTag : void 0;
  function d8e(e) {
    return e == null ? e === void 0 ? h8e : p8e : x6 && x6 in Object(e) ? c8e(e) : f8e(e);
  }
  s(d8e, "baseGetTag");
  C6.exports = d8e;
});

// ../node_modules/lodash/isObject.js
var xu = b((PCt, P6) => {
  function m8e(e) {
    var t = typeof e;
    return e != null && (t == "object" || t == "function");
  }
  s(m8e, "isObject");
  P6.exports = m8e;
});

// ../node_modules/lodash/isFunction.js
var X_ = b((wCt, D6) => {
  var y8e = up(), g8e = xu(), _8e = "[object AsyncFunction]", b8e = "[object Function]", v8e = "[object GeneratorFunction]", S8e = "[object \
Proxy]";
  function T8e(e) {
    if (!g8e(e))
      return !1;
    var t = y8e(e);
    return t == b8e || t == v8e || t == _8e || t == S8e;
  }
  s(T8e, "isFunction");
  D6.exports = T8e;
});

// ../node_modules/lodash/_coreJsData.js
var O6 = b((kCt, w6) => {
  var E8e = Wa(), A8e = E8e["__core-js_shared__"];
  w6.exports = A8e;
});

// ../node_modules/lodash/_isMasked.js
var R6 = b((ICt, I6) => {
  var KP = O6(), k6 = function() {
    var e = /[^.]+$/.exec(KP && KP.keys && KP.keys.IE_PROTO || "");
    return e ? "Symbol(src)_1." + e : "";
  }();
  function x8e(e) {
    return !!k6 && k6 in e;
  }
  s(x8e, "isMasked");
  I6.exports = x8e;
});

// ../node_modules/lodash/_toSource.js
var HP = b((NCt, N6) => {
  var C8e = Function.prototype, P8e = C8e.toString;
  function D8e(e) {
    if (e != null) {
      try {
        return P8e.call(e);
      } catch {
      }
      try {
        return e + "";
      } catch {
      }
    }
    return "";
  }
  s(D8e, "toSource");
  N6.exports = D8e;
});

// ../node_modules/lodash/_baseIsNative.js
var F6 = b((FCt, L6) => {
  var w8e = X_(), O8e = R6(), k8e = xu(), I8e = HP(), R8e = /[\\^$.*+?()[\]{}|]/g, N8e = /^\[object .+?Constructor\]$/, L8e = Function.prototype,
  F8e = Object.prototype, M8e = L8e.toString, B8e = F8e.hasOwnProperty, q8e = RegExp(
    "^" + M8e.call(B8e).replace(R8e, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  );
  function U8e(e) {
    if (!k8e(e) || O8e(e))
      return !1;
    var t = w8e(e) ? q8e : N8e;
    return t.test(I8e(e));
  }
  s(U8e, "baseIsNative");
  L6.exports = U8e;
});

// ../node_modules/lodash/_getValue.js
var B6 = b((BCt, M6) => {
  function j8e(e, t) {
    return e?.[t];
  }
  s(j8e, "getValue");
  M6.exports = j8e;
});

// ../node_modules/lodash/_getNative.js
var yl = b((UCt, q6) => {
  var V8e = F6(), K8e = B6();
  function H8e(e, t) {
    var r = K8e(e, t);
    return V8e(r) ? r : void 0;
  }
  s(H8e, "getNative");
  q6.exports = H8e;
});

// ../node_modules/lodash/_nativeCreate.js
var Nd = b((VCt, U6) => {
  var z8e = yl(), G8e = z8e(Object, "create");
  U6.exports = G8e;
});

// ../node_modules/lodash/_hashClear.js
var K6 = b((KCt, V6) => {
  var j6 = Nd();
  function W8e() {
    this.__data__ = j6 ? j6(null) : {}, this.size = 0;
  }
  s(W8e, "hashClear");
  V6.exports = W8e;
});

// ../node_modules/lodash/_hashDelete.js
var z6 = b((zCt, H6) => {
  function $8e(e) {
    var t = this.has(e) && delete this.__data__[e];
    return this.size -= t ? 1 : 0, t;
  }
  s($8e, "hashDelete");
  H6.exports = $8e;
});

// ../node_modules/lodash/_hashGet.js
var W6 = b((WCt, G6) => {
  var X8e = Nd(), Y8e = "__lodash_hash_undefined__", J8e = Object.prototype, Q8e = J8e.hasOwnProperty;
  function Z8e(e) {
    var t = this.__data__;
    if (X8e) {
      var r = t[e];
      return r === Y8e ? void 0 : r;
    }
    return Q8e.call(t, e) ? t[e] : void 0;
  }
  s(Z8e, "hashGet");
  G6.exports = Z8e;
});

// ../node_modules/lodash/_hashHas.js
var X6 = b((XCt, $6) => {
  var e4e = Nd(), t4e = Object.prototype, r4e = t4e.hasOwnProperty;
  function i4e(e) {
    var t = this.__data__;
    return e4e ? t[e] !== void 0 : r4e.call(t, e);
  }
  s(i4e, "hashHas");
  $6.exports = i4e;
});

// ../node_modules/lodash/_hashSet.js
var J6 = b((JCt, Y6) => {
  var n4e = Nd(), s4e = "__lodash_hash_undefined__";
  function a4e(e, t) {
    var r = this.__data__;
    return this.size += this.has(e) ? 0 : 1, r[e] = n4e && t === void 0 ? s4e : t, this;
  }
  s(a4e, "hashSet");
  Y6.exports = a4e;
});

// ../node_modules/lodash/_Hash.js
var Z6 = b((ZCt, Q6) => {
  var o4e = K6(), u4e = z6(), l4e = W6(), c4e = X6(), f4e = J6();
  function lp(e) {
    var t = -1, r = e == null ? 0 : e.length;
    for (this.clear(); ++t < r; ) {
      var i = e[t];
      this.set(i[0], i[1]);
    }
  }
  s(lp, "Hash");
  lp.prototype.clear = o4e;
  lp.prototype.delete = u4e;
  lp.prototype.get = l4e;
  lp.prototype.has = c4e;
  lp.prototype.set = f4e;
  Q6.exports = lp;
});

// ../node_modules/lodash/_listCacheClear.js
var tU = b((tPt, eU) => {
  function p4e() {
    this.__data__ = [], this.size = 0;
  }
  s(p4e, "listCacheClear");
  eU.exports = p4e;
});

// ../node_modules/lodash/eq.js
var Ld = b((iPt, rU) => {
  function h4e(e, t) {
    return e === t || e !== e && t !== t;
  }
  s(h4e, "eq");
  rU.exports = h4e;
});

// ../node_modules/lodash/_assocIndexOf.js
var Fd = b((sPt, iU) => {
  var d4e = Ld();
  function m4e(e, t) {
    for (var r = e.length; r--; )
      if (d4e(e[r][0], t))
        return r;
    return -1;
  }
  s(m4e, "assocIndexOf");
  iU.exports = m4e;
});

// ../node_modules/lodash/_listCacheDelete.js
var sU = b((oPt, nU) => {
  var y4e = Fd(), g4e = Array.prototype, _4e = g4e.splice;
  function b4e(e) {
    var t = this.__data__, r = y4e(t, e);
    if (r < 0)
      return !1;
    var i = t.length - 1;
    return r == i ? t.pop() : _4e.call(t, r, 1), --this.size, !0;
  }
  s(b4e, "listCacheDelete");
  nU.exports = b4e;
});

// ../node_modules/lodash/_listCacheGet.js
var oU = b((lPt, aU) => {
  var v4e = Fd();
  function S4e(e) {
    var t = this.__data__, r = v4e(t, e);
    return r < 0 ? void 0 : t[r][1];
  }
  s(S4e, "listCacheGet");
  aU.exports = S4e;
});

// ../node_modules/lodash/_listCacheHas.js
var lU = b((fPt, uU) => {
  var T4e = Fd();
  function E4e(e) {
    return T4e(this.__data__, e) > -1;
  }
  s(E4e, "listCacheHas");
  uU.exports = E4e;
});

// ../node_modules/lodash/_listCacheSet.js
var fU = b((hPt, cU) => {
  var A4e = Fd();
  function x4e(e, t) {
    var r = this.__data__, i = A4e(r, e);
    return i < 0 ? (++this.size, r.push([e, t])) : r[i][1] = t, this;
  }
  s(x4e, "listCacheSet");
  cU.exports = x4e;
});

// ../node_modules/lodash/_ListCache.js
var Md = b((mPt, pU) => {
  var C4e = tU(), P4e = sU(), D4e = oU(), w4e = lU(), O4e = fU();
  function cp(e) {
    var t = -1, r = e == null ? 0 : e.length;
    for (this.clear(); ++t < r; ) {
      var i = e[t];
      this.set(i[0], i[1]);
    }
  }
  s(cp, "ListCache");
  cp.prototype.clear = C4e;
  cp.prototype.delete = P4e;
  cp.prototype.get = D4e;
  cp.prototype.has = w4e;
  cp.prototype.set = O4e;
  pU.exports = cp;
});

// ../node_modules/lodash/_Map.js
var Y_ = b((gPt, hU) => {
  var k4e = yl(), I4e = Wa(), R4e = k4e(I4e, "Map");
  hU.exports = R4e;
});

// ../node_modules/lodash/_mapCacheClear.js
var yU = b((_Pt, mU) => {
  var dU = Z6(), N4e = Md(), L4e = Y_();
  function F4e() {
    this.size = 0, this.__data__ = {
      hash: new dU(),
      map: new (L4e || N4e)(),
      string: new dU()
    };
  }
  s(F4e, "mapCacheClear");
  mU.exports = F4e;
});

// ../node_modules/lodash/_isKeyable.js
var _U = b((vPt, gU) => {
  function M4e(e) {
    var t = typeof e;
    return t == "string" || t == "number" || t == "symbol" || t == "boolean" ? e !== "__proto__" : e === null;
  }
  s(M4e, "isKeyable");
  gU.exports = M4e;
});

// ../node_modules/lodash/_getMapData.js
var Bd = b((TPt, bU) => {
  var B4e = _U();
  function q4e(e, t) {
    var r = e.__data__;
    return B4e(t) ? r[typeof t == "string" ? "string" : "hash"] : r.map;
  }
  s(q4e, "getMapData");
  bU.exports = q4e;
});

// ../node_modules/lodash/_mapCacheDelete.js
var SU = b((APt, vU) => {
  var U4e = Bd();
  function j4e(e) {
    var t = U4e(this, e).delete(e);
    return this.size -= t ? 1 : 0, t;
  }
  s(j4e, "mapCacheDelete");
  vU.exports = j4e;
});

// ../node_modules/lodash/_mapCacheGet.js
var EU = b((CPt, TU) => {
  var V4e = Bd();
  function K4e(e) {
    return V4e(this, e).get(e);
  }
  s(K4e, "mapCacheGet");
  TU.exports = K4e;
});

// ../node_modules/lodash/_mapCacheHas.js
var xU = b((DPt, AU) => {
  var H4e = Bd();
  function z4e(e) {
    return H4e(this, e).has(e);
  }
  s(z4e, "mapCacheHas");
  AU.exports = z4e;
});

// ../node_modules/lodash/_mapCacheSet.js
var PU = b((OPt, CU) => {
  var G4e = Bd();
  function W4e(e, t) {
    var r = G4e(this, e), i = r.size;
    return r.set(e, t), this.size += r.size == i ? 0 : 1, this;
  }
  s(W4e, "mapCacheSet");
  CU.exports = W4e;
});

// ../node_modules/lodash/_MapCache.js
var zP = b((IPt, DU) => {
  var $4e = yU(), X4e = SU(), Y4e = EU(), J4e = xU(), Q4e = PU();
  function fp(e) {
    var t = -1, r = e == null ? 0 : e.length;
    for (this.clear(); ++t < r; ) {
      var i = e[t];
      this.set(i[0], i[1]);
    }
  }
  s(fp, "MapCache");
  fp.prototype.clear = $4e;
  fp.prototype.delete = X4e;
  fp.prototype.get = Y4e;
  fp.prototype.has = J4e;
  fp.prototype.set = Q4e;
  DU.exports = fp;
});

// ../node_modules/lodash/_setCacheAdd.js
var OU = b((NPt, wU) => {
  var Z4e = "__lodash_hash_undefined__";
  function e5e(e) {
    return this.__data__.set(e, Z4e), this;
  }
  s(e5e, "setCacheAdd");
  wU.exports = e5e;
});

// ../node_modules/lodash/_setCacheHas.js
var IU = b((FPt, kU) => {
  function t5e(e) {
    return this.__data__.has(e);
  }
  s(t5e, "setCacheHas");
  kU.exports = t5e;
});

// ../node_modules/lodash/_SetCache.js
var NU = b((BPt, RU) => {
  var r5e = zP(), i5e = OU(), n5e = IU();
  function J_(e) {
    var t = -1, r = e == null ? 0 : e.length;
    for (this.__data__ = new r5e(); ++t < r; )
      this.add(e[t]);
  }
  s(J_, "SetCache");
  J_.prototype.add = J_.prototype.push = i5e;
  J_.prototype.has = n5e;
  RU.exports = J_;
});

// ../node_modules/lodash/_baseFindIndex.js
var FU = b((UPt, LU) => {
  function s5e(e, t, r, i) {
    for (var n = e.length, a = r + (i ? 1 : -1); i ? a-- : ++a < n; )
      if (t(e[a], a, e))
        return a;
    return -1;
  }
  s(s5e, "baseFindIndex");
  LU.exports = s5e;
});

// ../node_modules/lodash/_baseIsNaN.js
var BU = b((VPt, MU) => {
  function a5e(e) {
    return e !== e;
  }
  s(a5e, "baseIsNaN");
  MU.exports = a5e;
});

// ../node_modules/lodash/_strictIndexOf.js
var UU = b((HPt, qU) => {
  function o5e(e, t, r) {
    for (var i = r - 1, n = e.length; ++i < n; )
      if (e[i] === t)
        return i;
    return -1;
  }
  s(o5e, "strictIndexOf");
  qU.exports = o5e;
});

// ../node_modules/lodash/_baseIndexOf.js
var VU = b((GPt, jU) => {
  var u5e = FU(), l5e = BU(), c5e = UU();
  function f5e(e, t, r) {
    return t === t ? c5e(e, t, r) : u5e(e, l5e, r);
  }
  s(f5e, "baseIndexOf");
  jU.exports = f5e;
});

// ../node_modules/lodash/_arrayIncludes.js
var HU = b(($Pt, KU) => {
  var p5e = VU();
  function h5e(e, t) {
    var r = e == null ? 0 : e.length;
    return !!r && p5e(e, t, 0) > -1;
  }
  s(h5e, "arrayIncludes");
  KU.exports = h5e;
});

// ../node_modules/lodash/_arrayIncludesWith.js
var GU = b((YPt, zU) => {
  function d5e(e, t, r) {
    for (var i = -1, n = e == null ? 0 : e.length; ++i < n; )
      if (r(t, e[i]))
        return !0;
    return !1;
  }
  s(d5e, "arrayIncludesWith");
  zU.exports = d5e;
});

// ../node_modules/lodash/_cacheHas.js
var $U = b((QPt, WU) => {
  function m5e(e, t) {
    return e.has(t);
  }
  s(m5e, "cacheHas");
  WU.exports = m5e;
});

// ../node_modules/lodash/_Set.js
var GP = b((eDt, XU) => {
  var y5e = yl(), g5e = Wa(), _5e = y5e(g5e, "Set");
  XU.exports = _5e;
});

// ../node_modules/lodash/noop.js
var JU = b((tDt, YU) => {
  function b5e() {
  }
  s(b5e, "noop");
  YU.exports = b5e;
});

// ../node_modules/lodash/_setToArray.js
var WP = b((iDt, QU) => {
  function v5e(e) {
    var t = -1, r = Array(e.size);
    return e.forEach(function(i) {
      r[++t] = i;
    }), r;
  }
  s(v5e, "setToArray");
  QU.exports = v5e;
});

// ../node_modules/lodash/_createSet.js
var ej = b((sDt, ZU) => {
  var $P = GP(), S5e = JU(), T5e = WP(), E5e = 1 / 0, A5e = $P && 1 / T5e(new $P([, -0]))[1] == E5e ? function(e) {
    return new $P(e);
  } : S5e;
  ZU.exports = A5e;
});

// ../node_modules/lodash/_baseUniq.js
var rj = b((aDt, tj) => {
  var x5e = NU(), C5e = HU(), P5e = GU(), D5e = $U(), w5e = ej(), O5e = WP(), k5e = 200;
  function I5e(e, t, r) {
    var i = -1, n = C5e, a = e.length, o = !0, u = [], l = u;
    if (r)
      o = !1, n = P5e;
    else if (a >= k5e) {
      var c = t ? null : w5e(e);
      if (c)
        return O5e(c);
      o = !1, n = D5e, l = new x5e();
    } else
      l = t ? [] : u;
    e:
      for (; ++i < a; ) {
        var p = e[i], h = t ? t(p) : p;
        if (p = r || p !== 0 ? p : 0, o && h === h) {
          for (var y = l.length; y--; )
            if (l[y] === h)
              continue e;
          t && l.push(h), u.push(p);
        } else n(l, h, r) || (l !== u && l.push(h), u.push(p));
      }
    return u;
  }
  s(I5e, "baseUniq");
  tj.exports = I5e;
});

// ../node_modules/lodash/uniq.js
var nj = b((uDt, ij) => {
  var R5e = rj();
  function N5e(e) {
    return e && e.length ? R5e(e) : [];
  }
  s(N5e, "uniq");
  ij.exports = N5e;
});

// ../node_modules/html-webpack-plugin/lib/child-compiler.js
var aj = b((cDt, sj) => {
  "use strict";
  var XP = class {
    static {
      s(this, "HtmlWebpackChildCompiler");
    }
    /**
     *
     * @param {string[]} templates
     */
    constructor(t) {
      this.templates = t, this.compilationPromise, this.compilationStartedTimestamp, this.compilationEndedTimestamp, this.fileDependencies =
      {
        fileDependencies: [],
        contextDependencies: [],
        missingDependencies: []
      };
    }
    /**
     * Returns true if the childCompiler is currently compiling
     *
     * @returns {boolean}
     */
    isCompiling() {
      return !this.didCompile() && this.compilationStartedTimestamp !== void 0;
    }
    /**
     * Returns true if the childCompiler is done compiling
     *
     * @returns {boolean}
     */
    didCompile() {
      return this.compilationEndedTimestamp !== void 0;
    }
    /**
     * This function will start the template compilation
     * once it is started no more templates can be added
     *
     * @param {import('webpack').Compilation} mainCompilation
     * @returns {Promise<{[templatePath: string]: ChildCompilationTemplateResult}>}
     */
    compileTemplates(t) {
      let r = t.compiler.webpack, i = r.Compilation, n = r.node.NodeTemplatePlugin, a = r.node.NodeTargetPlugin, o = r.LoaderTargetPlugin, u = r.
      EntryPlugin;
      if (this.compilationPromise)
        return this.compilationPromise;
      let l = {
        filename: "__child-[name]",
        publicPath: "",
        library: {
          type: "var",
          name: "HTML_WEBPACK_PLUGIN_RESULT"
        },
        scriptType: (
          /** @type {'text/javascript'} */
          "text/javascript"
        ),
        iife: !0
      }, p = t.createChildCompiler(
        "HtmlWebpackCompiler",
        l,
        [
          // Compile the template to nodejs javascript
          new a(),
          new n(),
          new o("node"),
          new r.library.EnableLibraryPlugin("var")
        ]
      );
      p.context = t.compiler.context;
      let h = this.templates.map(
        (y, _) => `__child-HtmlWebpackPlugin_${_}-${y}`
      );
      return this.templates.forEach((y, _) => {
        new u(
          p.context,
          "data:text/javascript,__webpack_public_path__ = __webpack_base_uri__ = htmlWebpackPluginPublicPath;",
          `HtmlWebpackPlugin_${_}-${y}`
        ).apply(p), new u(
          p.context,
          y,
          `HtmlWebpackPlugin_${_}-${y}`
        ).apply(p);
      }), p.options.module = { ...p.options.module }, p.options.module.parser = {
        ...p.options.module.parser
      }, p.options.module.parser.javascript = {
        ...p.options.module.parser.javascript,
        url: "relative"
      }, this.compilationStartedTimestamp = (/* @__PURE__ */ new Date()).getTime(), this.compilationPromise = new Promise((y, _) => {
        let g = [];
        p.hooks.thisCompilation.tap(
          "HtmlWebpackPlugin",
          (m) => {
            m.hooks.processAssets.tap(
              {
                name: "HtmlWebpackPlugin",
                stage: i.PROCESS_ASSETS_STAGE_ADDITIONS
              },
              (f) => {
                h.forEach((d) => {
                  f[d] && (g.push(f[d]), m.deleteAsset(d));
                });
              }
            );
          }
        ), p.runAsChild((m, f, d) => {
          let v = f ? g.map((x) => x.source()) : [];
          if (f && d && (this.fileDependencies = {
            fileDependencies: Array.from(d.fileDependencies),
            contextDependencies: Array.from(
              d.contextDependencies
            ),
            missingDependencies: Array.from(
              d.missingDependencies
            )
          }), d && d.errors && d.errors.length) {
            let x = [];
            for (let z of d.errors) {
              let w = z.message;
              z.stack && (w += `
` + z.stack), x.push(w);
            }
            let C = x.join(`
`);
            _(new Error(`Child compilation failed:
` + C));
            return;
          }
          if (m) {
            _(m);
            return;
          }
          if (!d || !f) {
            _(new Error("Empty child compilation"));
            return;
          }
          let E = {}, S = {};
          for (let x of d.getAssets())
            S[x.name] = { source: x.source, info: x.info };
          v.forEach((x, C) => {
            E[this.templates[C]] = {
              // TODO, can we have Buffer here?
              content: (
                /** @type {string} */
                x
              ),
              hash: d.hash || "XXXX",
              entry: f[C],
              assets: S
            };
          }), this.compilationEndedTimestamp = (/* @__PURE__ */ new Date()).getTime(), y(E);
        });
      }), this.compilationPromise;
    }
  };
  sj.exports = {
    HtmlWebpackChildCompiler: XP
  };
});

// ../node_modules/html-webpack-plugin/lib/cached-child-compiler.js
var uj = b((pDt, oj) => {
  "use strict";
  var { HtmlWebpackChildCompiler: L5e } = aj(), Q_ = /* @__PURE__ */ new WeakMap(), YP = class {
    static {
      s(this, "CachedChildCompilation");
    }
    /**
     * @param {Compiler} compiler
     */
    constructor(t) {
      if (this.compiler = t, Q_.has(t))
        return;
      let r = new JP();
      Q_.set(t, r), r.apply(t);
    }
    /**
     * apply is called by the webpack main compiler during the start phase
     * @param {string} entry
     */
    addEntry(t) {
      let r = Q_.get(
        this.compiler
      );
      if (!r)
        throw new Error(
          "PersistentChildCompilerSingletonPlugin instance not found."
        );
      r.addEntry(t);
    }
    getCompilationResult() {
      let t = Q_.get(
        this.compiler
      );
      if (!t)
        throw new Error(
          "PersistentChildCompilerSingletonPlugin instance not found."
        );
      return t.getLatestResult();
    }
    /**
     * Returns the result for the given entry
     * @param {string} entry
     * @returns {
        | { mainCompilationHash: string, error: Error }
        | { mainCompilationHash: string, compiledEntry: ChildCompilationTemplateResult }
      }
     */
    getCompilationEntryResult(t) {
      let r = this.getCompilationResult(), i = r.compilationResult;
      return "error" in i ? {
        mainCompilationHash: r.mainCompilationHash,
        error: i.error
      } : {
        mainCompilationHash: r.mainCompilationHash,
        compiledEntry: i.compiledEntries[t]
      };
    }
  }, JP = class e {
    static {
      s(this, "PersistentChildCompilerSingletonPlugin");
    }
    /**
     *
     * @param {{fileDependencies: string[], contextDependencies: string[], missingDependencies: string[]}} fileDependencies
     * @param {Compilation} mainCompilation
     * @param {number} startTime
     */
    static createSnapshot(t, r, i) {
      return new Promise((n, a) => {
        r.fileSystemInfo.createSnapshot(
          i,
          t.fileDependencies,
          t.contextDependencies,
          t.missingDependencies,
          // @ts-ignore
          null,
          (o, u) => {
            if (o)
              return a(o);
            n(u);
          }
        );
      });
    }
    /**
     * Returns true if the files inside this snapshot
     * have not been changed
     *
     * @param {Snapshot} snapshot
     * @param {Compilation} mainCompilation
     * @returns {Promise<boolean | undefined>}
     */
    static isSnapshotValid(t, r) {
      return new Promise((i, n) => {
        r.fileSystemInfo.checkSnapshotValid(
          t,
          (a, o) => {
            a && n(a), i(o);
          }
        );
      });
    }
    static watchFiles(t, r) {
      Object.keys(r).forEach((i) => {
        r[i].forEach((n) => {
          t[i].add(n);
        });
      });
    }
    constructor() {
      this.compilationState = {
        isCompiling: !1,
        isVerifyingCache: !1,
        entries: [],
        compiledEntries: [],
        mainCompilationHash: "initial",
        compilationResult: {
          dependencies: {
            fileDependencies: [],
            contextDependencies: [],
            missingDependencies: []
          },
          compiledEntries: {}
        }
      };
    }
    /**
     * apply is called by the webpack main compiler during the start phase
     * @param {Compiler} compiler
     */
    apply(t) {
      let r = Promise.resolve({
        dependencies: {
          fileDependencies: [],
          contextDependencies: [],
          missingDependencies: []
        },
        compiledEntries: {}
      }), i = "", n, a = (/* @__PURE__ */ new Date()).getTime();
      t.hooks.make.tapAsync(
        "PersistentChildCompilerSingletonPlugin",
        (o, u) => {
          if (this.compilationState.isCompiling || this.compilationState.isVerifyingCache)
            return u(new Error("Child compilation has already started"));
          a = (/* @__PURE__ */ new Date()).getTime(), this.compilationState = {
            isCompiling: !1,
            isVerifyingCache: !0,
            previousEntries: this.compilationState.compiledEntries,
            previousResult: this.compilationState.compilationResult,
            entries: this.compilationState.entries
          };
          let l = this.isCacheValid(
            n,
            o
          ), c = r;
          r = l.then(
            (p) => {
              if (p)
                return c;
              let h = this.compileEntries(
                o,
                this.compilationState.entries
              );
              return h.then((y) => e.createSnapshot(
                y.dependencies,
                o,
                a
              )).then((y) => {
                n = y;
              }), h;
            }
          ), o.hooks.optimizeTree.tapAsync(
            "PersistentChildCompilerSingletonPlugin",
            (p, h, y) => {
              r.then((g) => {
                this.watchFiles(
                  o,
                  g.dependencies
                );
              }).then(
                // @ts-ignore
                () => y(null, p, h),
                y
              );
            }
          ), o.hooks.additionalAssets.tapAsync(
            "PersistentChildCompilerSingletonPlugin",
            (p) => {
              let h = Promise.all([
                r,
                c
              ]).then(([_, g]) => g !== _);
              Promise.all([
                r,
                h
              ]).then(([_, g]) => {
                g && (i = /** @type {string} */
                o.hash), this.compilationState = {
                  isCompiling: !1,
                  isVerifyingCache: !1,
                  entries: this.compilationState.entries,
                  compiledEntries: this.compilationState.entries,
                  compilationResult: _,
                  mainCompilationHash: i
                };
              }).then(() => p(null), p);
            }
          ), u(null);
        }
      );
    }
    /**
     * Add a new entry to the next compile run
     * @param {string} entry
     */
    addEntry(t) {
      if (this.compilationState.isCompiling || this.compilationState.isVerifyingCache)
        throw new Error(
          "The child compiler has already started to compile. Please add entries before the main compiler 'make' phase has started or after \
the compilation is done."
        );
      this.compilationState.entries.indexOf(t) === -1 && (this.compilationState.entries = [...this.compilationState.entries, t]);
    }
    getLatestResult() {
      if (this.compilationState.isCompiling || this.compilationState.isVerifyingCache)
        throw new Error(
          "The child compiler is not done compiling. Please access the result after the compiler 'make' phase has started or after the compi\
lation is done."
        );
      return {
        mainCompilationHash: this.compilationState.mainCompilationHash,
        compilationResult: this.compilationState.compilationResult
      };
    }
    /**
     * Verify that the cache is still valid
     * @private
     * @param {Snapshot | undefined} snapshot
     * @param {Compilation} mainCompilation
     * @returns {Promise<boolean | undefined>}
     */
    isCacheValid(t, r) {
      return this.compilationState.isVerifyingCache ? this.compilationState.entries.length === 0 ? Promise.resolve(!0) : this.compilationState.
      entries !== this.compilationState.previousEntries || !t ? Promise.resolve(!1) : e.isSnapshotValid(
        t,
        r
      ) : Promise.reject(
        new Error(
          "Cache validation can only be done right before the compilation starts"
        )
      );
    }
    /**
     * Start to compile all templates
     *
     * @private
     * @param {Compilation} mainCompilation
     * @param {string[]} entries
     * @returns {Promise<ChildCompilationResult>}
     */
    compileEntries(t, r) {
      let i = new L5e(r);
      return i.compileTemplates(t).then(
        (n) => ({
          // The compiled sources to render the content
          compiledEntries: n,
          // The file dependencies to find out if a
          // recompilation is required
          dependencies: i.fileDependencies,
          // The main compilation hash can be used to find out
          // if this compilation was done during the current compilation
          mainCompilationHash: t.hash
        }),
        (n) => ({
          // The compiled sources to render the content
          error: n,
          // The file dependencies to find out if a
          // recompilation is required
          dependencies: i.fileDependencies,
          // The main compilation hash can be used to find out
          // if this compilation was done during the current compilation
          mainCompilationHash: t.hash
        })
      );
    }
    /**
     * @private
     * @param {Compilation} mainCompilation
     * @param {FileDependencies} files
     */
    watchFiles(t, r) {
      e.watchFiles(t, r);
    }
  };
  oj.exports = {
    CachedChildCompilation: YP
  };
});

// ../node_modules/html-webpack-plugin/lib/html-tags.js
var cj = b((dDt, lj) => {
  var F5e = [
    "area",
    "base",
    "br",
    "col",
    "embed",
    "hr",
    "img",
    "input",
    "keygen",
    "link",
    "meta",
    "param",
    "source",
    "track",
    "wbr"
  ];
  function M5e(e, t) {
    let r = Object.keys(e.attributes || {}).filter(function(i) {
      return e.attributes[i] === "" || e.attributes[i];
    }).map(function(i) {
      return e.attributes[i] === !0 ? t ? i + '="' + i + '"' : i : i + '="' + e.attributes[i] + '"';
    });
    return "<" + [e.tagName].concat(r).join(" ") + (e.voidTag && t ? "/" : "") + ">" + (e.innerHTML || "") + (e.voidTag ? "" : "</" + e.tagName +
    ">");
  }
  s(M5e, "htmlTagObjectToString");
  function B5e(e, t, r, i) {
    return {
      tagName: e,
      voidTag: F5e.indexOf(e) !== -1,
      attributes: t || {},
      meta: i || {},
      innerHTML: r
    };
  }
  s(B5e, "createHtmlTagObject");
  var QP = class extends Array {
    static {
      s(this, "HtmlTagArray");
    }
    toString() {
      return this.join("");
    }
  };
  lj.exports = {
    HtmlTagArray: QP,
    createHtmlTagObject: B5e,
    htmlTagObjectToString: M5e
  };
});

// ../node_modules/lodash/_overArg.js
var ZP = b((yDt, fj) => {
  function q5e(e, t) {
    return function(r) {
      return e(t(r));
    };
  }
  s(q5e, "overArg");
  fj.exports = q5e;
});

// ../node_modules/lodash/_getPrototype.js
var Z_ = b((_Dt, pj) => {
  var U5e = ZP(), j5e = U5e(Object.getPrototypeOf, Object);
  pj.exports = j5e;
});

// ../node_modules/lodash/isObjectLike.js
var gl = b((bDt, hj) => {
  function V5e(e) {
    return e != null && typeof e == "object";
  }
  s(V5e, "isObjectLike");
  hj.exports = V5e;
});

// ../node_modules/lodash/isPlainObject.js
var qd = b((SDt, mj) => {
  var K5e = up(), H5e = Z_(), z5e = gl(), G5e = "[object Object]", W5e = Function.prototype, $5e = Object.prototype, dj = W5e.toString, X5e = $5e.
  hasOwnProperty, Y5e = dj.call(Object);
  function J5e(e) {
    if (!z5e(e) || K5e(e) != G5e)
      return !1;
    var t = H5e(e);
    if (t === null)
      return !0;
    var r = X5e.call(t, "constructor") && t.constructor;
    return typeof r == "function" && r instanceof r && dj.call(r) == Y5e;
  }
  s(J5e, "isPlainObject");
  mj.exports = J5e;
});

// ../node_modules/pretty-error/lib/defaultStyle.js
var gj = b((EDt, yj) => {
  yj.exports = function() {
    return {
      "pretty-error": {
        display: "block",
        marginLeft: "2"
      },
      "pretty-error > header": {
        display: "block"
      },
      "pretty-error > header > title > kind": {
        background: "red",
        color: "bright-white"
      },
      "pretty-error > header > title > wrapper": {
        marginRight: "1",
        color: "grey"
      },
      "pretty-error > header > colon": {
        color: "grey",
        marginRight: 1
      },
      "pretty-error > header > message": {
        color: "bright-white"
      },
      "pretty-error > trace": {
        display: "block",
        marginTop: 1
      },
      "pretty-error > trace > item": {
        display: "block",
        marginBottom: 1,
        marginLeft: 2,
        bullet: '"<grey>-</grey>"'
      },
      "pretty-error > trace > item > header": {
        display: "block"
      },
      "pretty-error > trace > item > header > pointer > file": {
        color: "bright-yellow"
      },
      "pretty-error > trace > item > header > pointer > colon": {
        color: "grey"
      },
      "pretty-error > trace > item > header > pointer > line": {
        color: "bright-yellow",
        marginRight: 1
      },
      "pretty-error > trace > item > header > what": {
        color: "white"
      },
      "pretty-error > trace > item > footer": {
        display: "block"
      },
      "pretty-error > trace > item > footer > addr": {
        display: "block",
        color: "grey"
      },
      "pretty-error > trace > item > footer > extra": {
        display: "block",
        color: "grey"
      }
    };
  };
});

// ../node_modules/pretty-error/lib/ParsedError.js
var Tj = b((ADt, Sj) => {
  var bj, Ud, eD, vj, eb, _j, tD;
  eD = require("path");
  Sj.exports = bj = function() {
    function e(t) {
      this.error = t, this._parse();
    }
    return s(e, "ParsedError"), e.prototype._parse = function() {
      var t;
      this._trace = [], this._kind = "Error", this._wrapper = "", this.error.wrapper != null && (this._wrapper = String(this.error.wrapper)),
      typeof this.error != "object" ? this._message = String(this.error) : (this._stack = this.error.stack, this.error.kind != null ? this._kind =
      String(this.error.kind) : typeof this._stack == "string" && (t = this._stack.match(/^([a-zA-Z0-9\_\$]+):\ /)) && (this._kind = t[1]), this.
      _message = this.error.message != null && String(this.error.message) || "", typeof this._stack == "string" && this._parseStack());
    }, e.prototype._parseStack = function() {
      var t, r, i, n, a, o, u;
      for (i = [], n = !1, u = this._stack.split(`
`), a = 0, o = u.length; a < o; a++)
        t = u[a], t.trim() !== "" && (n ? this._trace.push(this._parseTraceItem(t)) : t.match(/^\s*at\s.+/) ? (n = !0, this._trace.push(this.
        _parseTraceItem(t))) : this._message.split(`
`.indexOf(t)) || i.push(t));
      r = i.join(`
`), r.substr(0, this._kind.length) === this._kind && (r = r.substr(this._kind.length, r.length).replace(/^\:\s+/, "")), r.length && (this._message =
      this._message.length ? [this._message, r].join(`
`) : r);
    }, e.prototype._parseTraceItem = function(t) {
      var r, i, n, a, o, u, l, c, p, h, y, _, g, m, f, d, v, E;
      if (t = t.trim(), t !== "") {
        if (!t.match(/^at\ /))
          return t;
        if (t = t.replace(/^at /, ""), !(t === "Error (<anonymous>)" || t === "Error (<anonymous>:null:null)"))
          return h = t, E = null, r = null, g = null, a = null, o = null, c = null, i = null, l = null, u = null, v = null, d = null, y = "[\
current]", (p = t.match(/\(([^\)]+)\)$/)) && (r = p[1].trim()), r != null && (E = t.substr(0, t.length - r.length - 2), E = E.trim()), r == null &&
          (r = t.trim()), r = this._fixPath(r), f = r, (p = f.match(/\,\ <js>:(\d+):(\d+)$/)) && (l = p[1], u = p[2], f = f.substr(0, f.length -
          p[0].length)), (p = f.match(/:(\d+):(\d+)$/)) && (c = p[1], i = p[2], f = f.substr(0, f.length - p[0].length), g = f), g != null &&
          (o = eD.basename(g), a = eD.dirname(g), a === "." && (a = ""), g = this._fixPath(g), o = this._fixPath(o), a = this._fixPath(a)), a !=
          null && (n = a.replace(/[\\]{1,2}/g, "/"), (p = n.match(/node_modules\/([^\/]+)(?!.*node_modules.*)/)) && (y = p[1])), l == null &&
          (l = c, u = i), g != null && (m = this._rectifyPath(g), v = m.path, d = v + r.substr(g.length, r.length), _ = m.packages), {
            original: h,
            what: E,
            addr: r,
            path: g,
            dir: a,
            file: o,
            line: parseInt(c),
            col: parseInt(i),
            jsLine: parseInt(l),
            jsCol: parseInt(u),
            packageName: y,
            shortenedPath: v,
            shortenedAddr: d,
            packages: _ || []
          };
      }
    }, e.prototype._getMessage = function() {
      return this._message;
    }, e.prototype._getKind = function() {
      return this._kind;
    }, e.prototype._getWrapper = function() {
      return this._wrapper;
    }, e.prototype._getStack = function() {
      return this._stack;
    }, e.prototype._getArguments = function() {
      return this.error.arguments;
    }, e.prototype._getType = function() {
      return this.error.type;
    }, e.prototype._getTrace = function() {
      return this._trace;
    }, e.prototype._fixPath = function(t) {
      return t.replace(/[\\]{1,2}/g, "/");
    }, e.prototype._rectifyPath = function(t, r) {
      var i, n, a, o, u;
      if (t = String(t), o = t, !(i = t.match(/^(.+?)\/node_modules\/(.+)$/)))
        return {
          path: t,
          packages: []
        };
      for (a = [], n = [], typeof r == "string" ? (a.push("[" + r + "]"), n.push("[" + r + "]")) : (a.push("[" + i[1].match(/([^\/]+)$/)[1] +
      "]"), n.push(i[1].match(/([^\/]+)$/)[1])), u = i[2]; i = u.match(/([^\/]+)\/node_modules\/(.+)$/); )
        a.push("[" + i[1] + "]"), n.push(i[1]), u = i[2];
      return (i = u.match(/([^\/]+)\/(.+)$/)) && (a.push("[" + i[1] + "]"), n.push(i[1]), u = i[2]), a.push(u), {
        path: a.join("/"),
        packages: n
      };
    }, e;
  }();
  tD = ["message", "kind", "arguments", "type", "stack", "trace", "wrapper"];
  vj = /* @__PURE__ */ s(function() {
    var e;
    return e = "_get" + Ud[0].toUpperCase() + Ud.substr(1, Ud.length), Object.defineProperty(bj.prototype, Ud, {
      get: /* @__PURE__ */ s(function() {
        return this[e]();
      }, "get")
    });
  }, "_fn");
  for (eb = 0, _j = tD.length; eb < _j; eb++)
    Ud = tD[eb], vj();
});

// ../node_modules/pretty-error/lib/nodePaths.js
var Aj = b((CDt, Ej) => {
  Ej.exports = ["_debugger.js", "_http_agent.js", "_http_client.js", "_http_common.js", "_http_incoming.js", "_http_outgoing.js", "_http_ser\
ver.js", "_linklist.js", "_stream_duplex.js", "_stream_passthrough.js", "_stream_readable.js", "_stream_transform.js", "_stream_writable.js",
  "_tls_legacy.js", "_tls_wrap.js", "assert.js", "buffer.js", "child_process.js", "cluster.js", "console.js", "constants.js", "crypto.js", "\
dgram.js", "dns.js", "domain.js", "events.js", "freelist.js", "fs.js", "http.js", "https.js", "module.js", "net.js", "os.js", "path.js", "pu\
nycode.js", "querystring.js", "readline.js", "repl.js", "smalloc.js", "stream.js", "string_decoder.js", "sys.js", "timers.js", "tls.js", "tt\
y.js", "url.js", "util.js", "vm.js", "zlib.js", "node.js"];
});

// ../node_modules/entities/lib/maps/decode.json
var xj = b((PDt, Q5e) => {
  Q5e.exports = { "0": 65533, "128": 8364, "130": 8218, "131": 402, "132": 8222, "133": 8230, "134": 8224, "135": 8225, "136": 710, "137": 8240,
  "138": 352, "139": 8249, "140": 338, "142": 381, "145": 8216, "146": 8217, "147": 8220, "148": 8221, "149": 8226, "150": 8211, "151": 8212,
  "152": 732, "153": 8482, "154": 353, "155": 8250, "156": 339, "158": 382, "159": 376 };
});

// ../node_modules/entities/lib/decode_codepoint.js
var rD = b((jd) => {
  "use strict";
  var Z5e = jd && jd.__importDefault || function(e) {
    return e && e.__esModule ? e : { default: e };
  };
  Object.defineProperty(jd, "__esModule", { value: !0 });
  var Cj = Z5e(xj()), e9e = (
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    String.fromCodePoint || function(e) {
      var t = "";
      return e > 65535 && (e -= 65536, t += String.fromCharCode(e >>> 10 & 1023 | 55296), e = 56320 | e & 1023), t += String.fromCharCode(e),
      t;
    }
  );
  function t9e(e) {
    return e >= 55296 && e <= 57343 || e > 1114111 ? "\uFFFD" : (e in Cj.default && (e = Cj.default[e]), e9e(e));
  }
  s(t9e, "decodeCodePoint");
  jd.default = t9e;
});

// ../node_modules/entities/lib/maps/entities.json
var tb = b((ODt, r9e) => {
  r9e.exports = { Aacute: "\xC1", aacute: "\xE1", Abreve: "\u0102", abreve: "\u0103", ac: "\u223E", acd: "\u223F", acE: "\u223E\u0333", Acirc: "\
\xC2", acirc: "\xE2", acute: "\xB4", Acy: "\u0410", acy: "\u0430", AElig: "\xC6", aelig: "\xE6", af: "\u2061", Afr: "\u{1D504}", afr: "\u{1D51E}",
  Agrave: "\xC0", agrave: "\xE0", alefsym: "\u2135", aleph: "\u2135", Alpha: "\u0391", alpha: "\u03B1", Amacr: "\u0100", amacr: "\u0101", amalg: "\
\u2A3F", amp: "&", AMP: "&", andand: "\u2A55", And: "\u2A53", and: "\u2227", andd: "\u2A5C", andslope: "\u2A58", andv: "\u2A5A", ang: "\u2220",
  ange: "\u29A4", angle: "\u2220", angmsdaa: "\u29A8", angmsdab: "\u29A9", angmsdac: "\u29AA", angmsdad: "\u29AB", angmsdae: "\u29AC", angmsdaf: "\
\u29AD", angmsdag: "\u29AE", angmsdah: "\u29AF", angmsd: "\u2221", angrt: "\u221F", angrtvb: "\u22BE", angrtvbd: "\u299D", angsph: "\u2222",
  angst: "\xC5", angzarr: "\u237C", Aogon: "\u0104", aogon: "\u0105", Aopf: "\u{1D538}", aopf: "\u{1D552}", apacir: "\u2A6F", ap: "\u2248", apE: "\
\u2A70", ape: "\u224A", apid: "\u224B", apos: "'", ApplyFunction: "\u2061", approx: "\u2248", approxeq: "\u224A", Aring: "\xC5", aring: "\xE5",
  Ascr: "\u{1D49C}", ascr: "\u{1D4B6}", Assign: "\u2254", ast: "*", asymp: "\u2248", asympeq: "\u224D", Atilde: "\xC3", atilde: "\xE3", Auml: "\
\xC4", auml: "\xE4", awconint: "\u2233", awint: "\u2A11", backcong: "\u224C", backepsilon: "\u03F6", backprime: "\u2035", backsim: "\u223D",
  backsimeq: "\u22CD", Backslash: "\u2216", Barv: "\u2AE7", barvee: "\u22BD", barwed: "\u2305", Barwed: "\u2306", barwedge: "\u2305", bbrk: "\
\u23B5", bbrktbrk: "\u23B6", bcong: "\u224C", Bcy: "\u0411", bcy: "\u0431", bdquo: "\u201E", becaus: "\u2235", because: "\u2235", Because: "\
\u2235", bemptyv: "\u29B0", bepsi: "\u03F6", bernou: "\u212C", Bernoullis: "\u212C", Beta: "\u0392", beta: "\u03B2", beth: "\u2136", between: "\
\u226C", Bfr: "\u{1D505}", bfr: "\u{1D51F}", bigcap: "\u22C2", bigcirc: "\u25EF", bigcup: "\u22C3", bigodot: "\u2A00", bigoplus: "\u2A01", bigotimes: "\
\u2A02", bigsqcup: "\u2A06", bigstar: "\u2605", bigtriangledown: "\u25BD", bigtriangleup: "\u25B3", biguplus: "\u2A04", bigvee: "\u22C1", bigwedge: "\
\u22C0", bkarow: "\u290D", blacklozenge: "\u29EB", blacksquare: "\u25AA", blacktriangle: "\u25B4", blacktriangledown: "\u25BE", blacktriangleleft: "\
\u25C2", blacktriangleright: "\u25B8", blank: "\u2423", blk12: "\u2592", blk14: "\u2591", blk34: "\u2593", block: "\u2588", bne: "=\u20E5", bnequiv: "\
\u2261\u20E5", bNot: "\u2AED", bnot: "\u2310", Bopf: "\u{1D539}", bopf: "\u{1D553}", bot: "\u22A5", bottom: "\u22A5", bowtie: "\u22C8", boxbox: "\
\u29C9", boxdl: "\u2510", boxdL: "\u2555", boxDl: "\u2556", boxDL: "\u2557", boxdr: "\u250C", boxdR: "\u2552", boxDr: "\u2553", boxDR: "\u2554",
  boxh: "\u2500", boxH: "\u2550", boxhd: "\u252C", boxHd: "\u2564", boxhD: "\u2565", boxHD: "\u2566", boxhu: "\u2534", boxHu: "\u2567", boxhU: "\
\u2568", boxHU: "\u2569", boxminus: "\u229F", boxplus: "\u229E", boxtimes: "\u22A0", boxul: "\u2518", boxuL: "\u255B", boxUl: "\u255C", boxUL: "\
\u255D", boxur: "\u2514", boxuR: "\u2558", boxUr: "\u2559", boxUR: "\u255A", boxv: "\u2502", boxV: "\u2551", boxvh: "\u253C", boxvH: "\u256A",
  boxVh: "\u256B", boxVH: "\u256C", boxvl: "\u2524", boxvL: "\u2561", boxVl: "\u2562", boxVL: "\u2563", boxvr: "\u251C", boxvR: "\u255E", boxVr: "\
\u255F", boxVR: "\u2560", bprime: "\u2035", breve: "\u02D8", Breve: "\u02D8", brvbar: "\xA6", bscr: "\u{1D4B7}", Bscr: "\u212C", bsemi: "\u204F",
  bsim: "\u223D", bsime: "\u22CD", bsolb: "\u29C5", bsol: "\\", bsolhsub: "\u27C8", bull: "\u2022", bullet: "\u2022", bump: "\u224E", bumpE: "\
\u2AAE", bumpe: "\u224F", Bumpeq: "\u224E", bumpeq: "\u224F", Cacute: "\u0106", cacute: "\u0107", capand: "\u2A44", capbrcup: "\u2A49", capcap: "\
\u2A4B", cap: "\u2229", Cap: "\u22D2", capcup: "\u2A47", capdot: "\u2A40", CapitalDifferentialD: "\u2145", caps: "\u2229\uFE00", caret: "\u2041",
  caron: "\u02C7", Cayleys: "\u212D", ccaps: "\u2A4D", Ccaron: "\u010C", ccaron: "\u010D", Ccedil: "\xC7", ccedil: "\xE7", Ccirc: "\u0108", ccirc: "\
\u0109", Cconint: "\u2230", ccups: "\u2A4C", ccupssm: "\u2A50", Cdot: "\u010A", cdot: "\u010B", cedil: "\xB8", Cedilla: "\xB8", cemptyv: "\u29B2",
  cent: "\xA2", centerdot: "\xB7", CenterDot: "\xB7", cfr: "\u{1D520}", Cfr: "\u212D", CHcy: "\u0427", chcy: "\u0447", check: "\u2713", checkmark: "\
\u2713", Chi: "\u03A7", chi: "\u03C7", circ: "\u02C6", circeq: "\u2257", circlearrowleft: "\u21BA", circlearrowright: "\u21BB", circledast: "\
\u229B", circledcirc: "\u229A", circleddash: "\u229D", CircleDot: "\u2299", circledR: "\xAE", circledS: "\u24C8", CircleMinus: "\u2296", CirclePlus: "\
\u2295", CircleTimes: "\u2297", cir: "\u25CB", cirE: "\u29C3", cire: "\u2257", cirfnint: "\u2A10", cirmid: "\u2AEF", cirscir: "\u29C2", ClockwiseContourIntegral: "\
\u2232", CloseCurlyDoubleQuote: "\u201D", CloseCurlyQuote: "\u2019", clubs: "\u2663", clubsuit: "\u2663", colon: ":", Colon: "\u2237", Colone: "\
\u2A74", colone: "\u2254", coloneq: "\u2254", comma: ",", commat: "@", comp: "\u2201", compfn: "\u2218", complement: "\u2201", complexes: "\u2102",
  cong: "\u2245", congdot: "\u2A6D", Congruent: "\u2261", conint: "\u222E", Conint: "\u222F", ContourIntegral: "\u222E", copf: "\u{1D554}", Copf: "\
\u2102", coprod: "\u2210", Coproduct: "\u2210", copy: "\xA9", COPY: "\xA9", copysr: "\u2117", CounterClockwiseContourIntegral: "\u2233", crarr: "\
\u21B5", cross: "\u2717", Cross: "\u2A2F", Cscr: "\u{1D49E}", cscr: "\u{1D4B8}", csub: "\u2ACF", csube: "\u2AD1", csup: "\u2AD0", csupe: "\u2AD2",
  ctdot: "\u22EF", cudarrl: "\u2938", cudarrr: "\u2935", cuepr: "\u22DE", cuesc: "\u22DF", cularr: "\u21B6", cularrp: "\u293D", cupbrcap: "\u2A48",
  cupcap: "\u2A46", CupCap: "\u224D", cup: "\u222A", Cup: "\u22D3", cupcup: "\u2A4A", cupdot: "\u228D", cupor: "\u2A45", cups: "\u222A\uFE00",
  curarr: "\u21B7", curarrm: "\u293C", curlyeqprec: "\u22DE", curlyeqsucc: "\u22DF", curlyvee: "\u22CE", curlywedge: "\u22CF", curren: "\xA4",
  curvearrowleft: "\u21B6", curvearrowright: "\u21B7", cuvee: "\u22CE", cuwed: "\u22CF", cwconint: "\u2232", cwint: "\u2231", cylcty: "\u232D",
  dagger: "\u2020", Dagger: "\u2021", daleth: "\u2138", darr: "\u2193", Darr: "\u21A1", dArr: "\u21D3", dash: "\u2010", Dashv: "\u2AE4", dashv: "\
\u22A3", dbkarow: "\u290F", dblac: "\u02DD", Dcaron: "\u010E", dcaron: "\u010F", Dcy: "\u0414", dcy: "\u0434", ddagger: "\u2021", ddarr: "\u21CA",
  DD: "\u2145", dd: "\u2146", DDotrahd: "\u2911", ddotseq: "\u2A77", deg: "\xB0", Del: "\u2207", Delta: "\u0394", delta: "\u03B4", demptyv: "\
\u29B1", dfisht: "\u297F", Dfr: "\u{1D507}", dfr: "\u{1D521}", dHar: "\u2965", dharl: "\u21C3", dharr: "\u21C2", DiacriticalAcute: "\xB4", DiacriticalDot: "\
\u02D9", DiacriticalDoubleAcute: "\u02DD", DiacriticalGrave: "`", DiacriticalTilde: "\u02DC", diam: "\u22C4", diamond: "\u22C4", Diamond: "\u22C4",
  diamondsuit: "\u2666", diams: "\u2666", die: "\xA8", DifferentialD: "\u2146", digamma: "\u03DD", disin: "\u22F2", div: "\xF7", divide: "\xF7",
  divideontimes: "\u22C7", divonx: "\u22C7", DJcy: "\u0402", djcy: "\u0452", dlcorn: "\u231E", dlcrop: "\u230D", dollar: "$", Dopf: "\u{1D53B}",
  dopf: "\u{1D555}", Dot: "\xA8", dot: "\u02D9", DotDot: "\u20DC", doteq: "\u2250", doteqdot: "\u2251", DotEqual: "\u2250", dotminus: "\u2238",
  dotplus: "\u2214", dotsquare: "\u22A1", doublebarwedge: "\u2306", DoubleContourIntegral: "\u222F", DoubleDot: "\xA8", DoubleDownArrow: "\u21D3",
  DoubleLeftArrow: "\u21D0", DoubleLeftRightArrow: "\u21D4", DoubleLeftTee: "\u2AE4", DoubleLongLeftArrow: "\u27F8", DoubleLongLeftRightArrow: "\
\u27FA", DoubleLongRightArrow: "\u27F9", DoubleRightArrow: "\u21D2", DoubleRightTee: "\u22A8", DoubleUpArrow: "\u21D1", DoubleUpDownArrow: "\
\u21D5", DoubleVerticalBar: "\u2225", DownArrowBar: "\u2913", downarrow: "\u2193", DownArrow: "\u2193", Downarrow: "\u21D3", DownArrowUpArrow: "\
\u21F5", DownBreve: "\u0311", downdownarrows: "\u21CA", downharpoonleft: "\u21C3", downharpoonright: "\u21C2", DownLeftRightVector: "\u2950",
  DownLeftTeeVector: "\u295E", DownLeftVectorBar: "\u2956", DownLeftVector: "\u21BD", DownRightTeeVector: "\u295F", DownRightVectorBar: "\u2957",
  DownRightVector: "\u21C1", DownTeeArrow: "\u21A7", DownTee: "\u22A4", drbkarow: "\u2910", drcorn: "\u231F", drcrop: "\u230C", Dscr: "\u{1D49F}",
  dscr: "\u{1D4B9}", DScy: "\u0405", dscy: "\u0455", dsol: "\u29F6", Dstrok: "\u0110", dstrok: "\u0111", dtdot: "\u22F1", dtri: "\u25BF", dtrif: "\
\u25BE", duarr: "\u21F5", duhar: "\u296F", dwangle: "\u29A6", DZcy: "\u040F", dzcy: "\u045F", dzigrarr: "\u27FF", Eacute: "\xC9", eacute: "\xE9",
  easter: "\u2A6E", Ecaron: "\u011A", ecaron: "\u011B", Ecirc: "\xCA", ecirc: "\xEA", ecir: "\u2256", ecolon: "\u2255", Ecy: "\u042D", ecy: "\
\u044D", eDDot: "\u2A77", Edot: "\u0116", edot: "\u0117", eDot: "\u2251", ee: "\u2147", efDot: "\u2252", Efr: "\u{1D508}", efr: "\u{1D522}",
  eg: "\u2A9A", Egrave: "\xC8", egrave: "\xE8", egs: "\u2A96", egsdot: "\u2A98", el: "\u2A99", Element: "\u2208", elinters: "\u23E7", ell: "\
\u2113", els: "\u2A95", elsdot: "\u2A97", Emacr: "\u0112", emacr: "\u0113", empty: "\u2205", emptyset: "\u2205", EmptySmallSquare: "\u25FB",
  emptyv: "\u2205", EmptyVerySmallSquare: "\u25AB", emsp13: "\u2004", emsp14: "\u2005", emsp: "\u2003", ENG: "\u014A", eng: "\u014B", ensp: "\
\u2002", Eogon: "\u0118", eogon: "\u0119", Eopf: "\u{1D53C}", eopf: "\u{1D556}", epar: "\u22D5", eparsl: "\u29E3", eplus: "\u2A71", epsi: "\u03B5",
  Epsilon: "\u0395", epsilon: "\u03B5", epsiv: "\u03F5", eqcirc: "\u2256", eqcolon: "\u2255", eqsim: "\u2242", eqslantgtr: "\u2A96", eqslantless: "\
\u2A95", Equal: "\u2A75", equals: "=", EqualTilde: "\u2242", equest: "\u225F", Equilibrium: "\u21CC", equiv: "\u2261", equivDD: "\u2A78", eqvparsl: "\
\u29E5", erarr: "\u2971", erDot: "\u2253", escr: "\u212F", Escr: "\u2130", esdot: "\u2250", Esim: "\u2A73", esim: "\u2242", Eta: "\u0397", eta: "\
\u03B7", ETH: "\xD0", eth: "\xF0", Euml: "\xCB", euml: "\xEB", euro: "\u20AC", excl: "!", exist: "\u2203", Exists: "\u2203", expectation: "\u2130",
  exponentiale: "\u2147", ExponentialE: "\u2147", fallingdotseq: "\u2252", Fcy: "\u0424", fcy: "\u0444", female: "\u2640", ffilig: "\uFB03",
  fflig: "\uFB00", ffllig: "\uFB04", Ffr: "\u{1D509}", ffr: "\u{1D523}", filig: "\uFB01", FilledSmallSquare: "\u25FC", FilledVerySmallSquare: "\
\u25AA", fjlig: "fj", flat: "\u266D", fllig: "\uFB02", fltns: "\u25B1", fnof: "\u0192", Fopf: "\u{1D53D}", fopf: "\u{1D557}", forall: "\u2200",
  ForAll: "\u2200", fork: "\u22D4", forkv: "\u2AD9", Fouriertrf: "\u2131", fpartint: "\u2A0D", frac12: "\xBD", frac13: "\u2153", frac14: "\xBC",
  frac15: "\u2155", frac16: "\u2159", frac18: "\u215B", frac23: "\u2154", frac25: "\u2156", frac34: "\xBE", frac35: "\u2157", frac38: "\u215C",
  frac45: "\u2158", frac56: "\u215A", frac58: "\u215D", frac78: "\u215E", frasl: "\u2044", frown: "\u2322", fscr: "\u{1D4BB}", Fscr: "\u2131",
  gacute: "\u01F5", Gamma: "\u0393", gamma: "\u03B3", Gammad: "\u03DC", gammad: "\u03DD", gap: "\u2A86", Gbreve: "\u011E", gbreve: "\u011F",
  Gcedil: "\u0122", Gcirc: "\u011C", gcirc: "\u011D", Gcy: "\u0413", gcy: "\u0433", Gdot: "\u0120", gdot: "\u0121", ge: "\u2265", gE: "\u2267",
  gEl: "\u2A8C", gel: "\u22DB", geq: "\u2265", geqq: "\u2267", geqslant: "\u2A7E", gescc: "\u2AA9", ges: "\u2A7E", gesdot: "\u2A80", gesdoto: "\
\u2A82", gesdotol: "\u2A84", gesl: "\u22DB\uFE00", gesles: "\u2A94", Gfr: "\u{1D50A}", gfr: "\u{1D524}", gg: "\u226B", Gg: "\u22D9", ggg: "\u22D9",
  gimel: "\u2137", GJcy: "\u0403", gjcy: "\u0453", gla: "\u2AA5", gl: "\u2277", glE: "\u2A92", glj: "\u2AA4", gnap: "\u2A8A", gnapprox: "\u2A8A",
  gne: "\u2A88", gnE: "\u2269", gneq: "\u2A88", gneqq: "\u2269", gnsim: "\u22E7", Gopf: "\u{1D53E}", gopf: "\u{1D558}", grave: "`", GreaterEqual: "\
\u2265", GreaterEqualLess: "\u22DB", GreaterFullEqual: "\u2267", GreaterGreater: "\u2AA2", GreaterLess: "\u2277", GreaterSlantEqual: "\u2A7E",
  GreaterTilde: "\u2273", Gscr: "\u{1D4A2}", gscr: "\u210A", gsim: "\u2273", gsime: "\u2A8E", gsiml: "\u2A90", gtcc: "\u2AA7", gtcir: "\u2A7A",
  gt: ">", GT: ">", Gt: "\u226B", gtdot: "\u22D7", gtlPar: "\u2995", gtquest: "\u2A7C", gtrapprox: "\u2A86", gtrarr: "\u2978", gtrdot: "\u22D7",
  gtreqless: "\u22DB", gtreqqless: "\u2A8C", gtrless: "\u2277", gtrsim: "\u2273", gvertneqq: "\u2269\uFE00", gvnE: "\u2269\uFE00", Hacek: "\u02C7",
  hairsp: "\u200A", half: "\xBD", hamilt: "\u210B", HARDcy: "\u042A", hardcy: "\u044A", harrcir: "\u2948", harr: "\u2194", hArr: "\u21D4", harrw: "\
\u21AD", Hat: "^", hbar: "\u210F", Hcirc: "\u0124", hcirc: "\u0125", hearts: "\u2665", heartsuit: "\u2665", hellip: "\u2026", hercon: "\u22B9",
  hfr: "\u{1D525}", Hfr: "\u210C", HilbertSpace: "\u210B", hksearow: "\u2925", hkswarow: "\u2926", hoarr: "\u21FF", homtht: "\u223B", hookleftarrow: "\
\u21A9", hookrightarrow: "\u21AA", hopf: "\u{1D559}", Hopf: "\u210D", horbar: "\u2015", HorizontalLine: "\u2500", hscr: "\u{1D4BD}", Hscr: "\
\u210B", hslash: "\u210F", Hstrok: "\u0126", hstrok: "\u0127", HumpDownHump: "\u224E", HumpEqual: "\u224F", hybull: "\u2043", hyphen: "\u2010",
  Iacute: "\xCD", iacute: "\xED", ic: "\u2063", Icirc: "\xCE", icirc: "\xEE", Icy: "\u0418", icy: "\u0438", Idot: "\u0130", IEcy: "\u0415", iecy: "\
\u0435", iexcl: "\xA1", iff: "\u21D4", ifr: "\u{1D526}", Ifr: "\u2111", Igrave: "\xCC", igrave: "\xEC", ii: "\u2148", iiiint: "\u2A0C", iiint: "\
\u222D", iinfin: "\u29DC", iiota: "\u2129", IJlig: "\u0132", ijlig: "\u0133", Imacr: "\u012A", imacr: "\u012B", image: "\u2111", ImaginaryI: "\
\u2148", imagline: "\u2110", imagpart: "\u2111", imath: "\u0131", Im: "\u2111", imof: "\u22B7", imped: "\u01B5", Implies: "\u21D2", incare: "\
\u2105", in: "\u2208", infin: "\u221E", infintie: "\u29DD", inodot: "\u0131", intcal: "\u22BA", int: "\u222B", Int: "\u222C", integers: "\u2124",
  Integral: "\u222B", intercal: "\u22BA", Intersection: "\u22C2", intlarhk: "\u2A17", intprod: "\u2A3C", InvisibleComma: "\u2063", InvisibleTimes: "\
\u2062", IOcy: "\u0401", iocy: "\u0451", Iogon: "\u012E", iogon: "\u012F", Iopf: "\u{1D540}", iopf: "\u{1D55A}", Iota: "\u0399", iota: "\u03B9",
  iprod: "\u2A3C", iquest: "\xBF", iscr: "\u{1D4BE}", Iscr: "\u2110", isin: "\u2208", isindot: "\u22F5", isinE: "\u22F9", isins: "\u22F4", isinsv: "\
\u22F3", isinv: "\u2208", it: "\u2062", Itilde: "\u0128", itilde: "\u0129", Iukcy: "\u0406", iukcy: "\u0456", Iuml: "\xCF", iuml: "\xEF", Jcirc: "\
\u0134", jcirc: "\u0135", Jcy: "\u0419", jcy: "\u0439", Jfr: "\u{1D50D}", jfr: "\u{1D527}", jmath: "\u0237", Jopf: "\u{1D541}", jopf: "\u{1D55B}",
  Jscr: "\u{1D4A5}", jscr: "\u{1D4BF}", Jsercy: "\u0408", jsercy: "\u0458", Jukcy: "\u0404", jukcy: "\u0454", Kappa: "\u039A", kappa: "\u03BA",
  kappav: "\u03F0", Kcedil: "\u0136", kcedil: "\u0137", Kcy: "\u041A", kcy: "\u043A", Kfr: "\u{1D50E}", kfr: "\u{1D528}", kgreen: "\u0138", KHcy: "\
\u0425", khcy: "\u0445", KJcy: "\u040C", kjcy: "\u045C", Kopf: "\u{1D542}", kopf: "\u{1D55C}", Kscr: "\u{1D4A6}", kscr: "\u{1D4C0}", lAarr: "\
\u21DA", Lacute: "\u0139", lacute: "\u013A", laemptyv: "\u29B4", lagran: "\u2112", Lambda: "\u039B", lambda: "\u03BB", lang: "\u27E8", Lang: "\
\u27EA", langd: "\u2991", langle: "\u27E8", lap: "\u2A85", Laplacetrf: "\u2112", laquo: "\xAB", larrb: "\u21E4", larrbfs: "\u291F", larr: "\u2190",
  Larr: "\u219E", lArr: "\u21D0", larrfs: "\u291D", larrhk: "\u21A9", larrlp: "\u21AB", larrpl: "\u2939", larrsim: "\u2973", larrtl: "\u21A2",
  latail: "\u2919", lAtail: "\u291B", lat: "\u2AAB", late: "\u2AAD", lates: "\u2AAD\uFE00", lbarr: "\u290C", lBarr: "\u290E", lbbrk: "\u2772",
  lbrace: "{", lbrack: "[", lbrke: "\u298B", lbrksld: "\u298F", lbrkslu: "\u298D", Lcaron: "\u013D", lcaron: "\u013E", Lcedil: "\u013B", lcedil: "\
\u013C", lceil: "\u2308", lcub: "{", Lcy: "\u041B", lcy: "\u043B", ldca: "\u2936", ldquo: "\u201C", ldquor: "\u201E", ldrdhar: "\u2967", ldrushar: "\
\u294B", ldsh: "\u21B2", le: "\u2264", lE: "\u2266", LeftAngleBracket: "\u27E8", LeftArrowBar: "\u21E4", leftarrow: "\u2190", LeftArrow: "\u2190",
  Leftarrow: "\u21D0", LeftArrowRightArrow: "\u21C6", leftarrowtail: "\u21A2", LeftCeiling: "\u2308", LeftDoubleBracket: "\u27E6", LeftDownTeeVector: "\
\u2961", LeftDownVectorBar: "\u2959", LeftDownVector: "\u21C3", LeftFloor: "\u230A", leftharpoondown: "\u21BD", leftharpoonup: "\u21BC", leftleftarrows: "\
\u21C7", leftrightarrow: "\u2194", LeftRightArrow: "\u2194", Leftrightarrow: "\u21D4", leftrightarrows: "\u21C6", leftrightharpoons: "\u21CB",
  leftrightsquigarrow: "\u21AD", LeftRightVector: "\u294E", LeftTeeArrow: "\u21A4", LeftTee: "\u22A3", LeftTeeVector: "\u295A", leftthreetimes: "\
\u22CB", LeftTriangleBar: "\u29CF", LeftTriangle: "\u22B2", LeftTriangleEqual: "\u22B4", LeftUpDownVector: "\u2951", LeftUpTeeVector: "\u2960",
  LeftUpVectorBar: "\u2958", LeftUpVector: "\u21BF", LeftVectorBar: "\u2952", LeftVector: "\u21BC", lEg: "\u2A8B", leg: "\u22DA", leq: "\u2264",
  leqq: "\u2266", leqslant: "\u2A7D", lescc: "\u2AA8", les: "\u2A7D", lesdot: "\u2A7F", lesdoto: "\u2A81", lesdotor: "\u2A83", lesg: "\u22DA\uFE00",
  lesges: "\u2A93", lessapprox: "\u2A85", lessdot: "\u22D6", lesseqgtr: "\u22DA", lesseqqgtr: "\u2A8B", LessEqualGreater: "\u22DA", LessFullEqual: "\
\u2266", LessGreater: "\u2276", lessgtr: "\u2276", LessLess: "\u2AA1", lesssim: "\u2272", LessSlantEqual: "\u2A7D", LessTilde: "\u2272", lfisht: "\
\u297C", lfloor: "\u230A", Lfr: "\u{1D50F}", lfr: "\u{1D529}", lg: "\u2276", lgE: "\u2A91", lHar: "\u2962", lhard: "\u21BD", lharu: "\u21BC",
  lharul: "\u296A", lhblk: "\u2584", LJcy: "\u0409", ljcy: "\u0459", llarr: "\u21C7", ll: "\u226A", Ll: "\u22D8", llcorner: "\u231E", Lleftarrow: "\
\u21DA", llhard: "\u296B", lltri: "\u25FA", Lmidot: "\u013F", lmidot: "\u0140", lmoustache: "\u23B0", lmoust: "\u23B0", lnap: "\u2A89", lnapprox: "\
\u2A89", lne: "\u2A87", lnE: "\u2268", lneq: "\u2A87", lneqq: "\u2268", lnsim: "\u22E6", loang: "\u27EC", loarr: "\u21FD", lobrk: "\u27E6", longleftarrow: "\
\u27F5", LongLeftArrow: "\u27F5", Longleftarrow: "\u27F8", longleftrightarrow: "\u27F7", LongLeftRightArrow: "\u27F7", Longleftrightarrow: "\
\u27FA", longmapsto: "\u27FC", longrightarrow: "\u27F6", LongRightArrow: "\u27F6", Longrightarrow: "\u27F9", looparrowleft: "\u21AB", looparrowright: "\
\u21AC", lopar: "\u2985", Lopf: "\u{1D543}", lopf: "\u{1D55D}", loplus: "\u2A2D", lotimes: "\u2A34", lowast: "\u2217", lowbar: "_", LowerLeftArrow: "\
\u2199", LowerRightArrow: "\u2198", loz: "\u25CA", lozenge: "\u25CA", lozf: "\u29EB", lpar: "(", lparlt: "\u2993", lrarr: "\u21C6", lrcorner: "\
\u231F", lrhar: "\u21CB", lrhard: "\u296D", lrm: "\u200E", lrtri: "\u22BF", lsaquo: "\u2039", lscr: "\u{1D4C1}", Lscr: "\u2112", lsh: "\u21B0",
  Lsh: "\u21B0", lsim: "\u2272", lsime: "\u2A8D", lsimg: "\u2A8F", lsqb: "[", lsquo: "\u2018", lsquor: "\u201A", Lstrok: "\u0141", lstrok: "\
\u0142", ltcc: "\u2AA6", ltcir: "\u2A79", lt: "<", LT: "<", Lt: "\u226A", ltdot: "\u22D6", lthree: "\u22CB", ltimes: "\u22C9", ltlarr: "\u2976",
  ltquest: "\u2A7B", ltri: "\u25C3", ltrie: "\u22B4", ltrif: "\u25C2", ltrPar: "\u2996", lurdshar: "\u294A", luruhar: "\u2966", lvertneqq: "\
\u2268\uFE00", lvnE: "\u2268\uFE00", macr: "\xAF", male: "\u2642", malt: "\u2720", maltese: "\u2720", Map: "\u2905", map: "\u21A6", mapsto: "\
\u21A6", mapstodown: "\u21A7", mapstoleft: "\u21A4", mapstoup: "\u21A5", marker: "\u25AE", mcomma: "\u2A29", Mcy: "\u041C", mcy: "\u043C", mdash: "\
\u2014", mDDot: "\u223A", measuredangle: "\u2221", MediumSpace: "\u205F", Mellintrf: "\u2133", Mfr: "\u{1D510}", mfr: "\u{1D52A}", mho: "\u2127",
  micro: "\xB5", midast: "*", midcir: "\u2AF0", mid: "\u2223", middot: "\xB7", minusb: "\u229F", minus: "\u2212", minusd: "\u2238", minusdu: "\
\u2A2A", MinusPlus: "\u2213", mlcp: "\u2ADB", mldr: "\u2026", mnplus: "\u2213", models: "\u22A7", Mopf: "\u{1D544}", mopf: "\u{1D55E}", mp: "\
\u2213", mscr: "\u{1D4C2}", Mscr: "\u2133", mstpos: "\u223E", Mu: "\u039C", mu: "\u03BC", multimap: "\u22B8", mumap: "\u22B8", nabla: "\u2207",
  Nacute: "\u0143", nacute: "\u0144", nang: "\u2220\u20D2", nap: "\u2249", napE: "\u2A70\u0338", napid: "\u224B\u0338", napos: "\u0149", napprox: "\
\u2249", natural: "\u266E", naturals: "\u2115", natur: "\u266E", nbsp: "\xA0", nbump: "\u224E\u0338", nbumpe: "\u224F\u0338", ncap: "\u2A43",
  Ncaron: "\u0147", ncaron: "\u0148", Ncedil: "\u0145", ncedil: "\u0146", ncong: "\u2247", ncongdot: "\u2A6D\u0338", ncup: "\u2A42", Ncy: "\u041D",
  ncy: "\u043D", ndash: "\u2013", nearhk: "\u2924", nearr: "\u2197", neArr: "\u21D7", nearrow: "\u2197", ne: "\u2260", nedot: "\u2250\u0338",
  NegativeMediumSpace: "\u200B", NegativeThickSpace: "\u200B", NegativeThinSpace: "\u200B", NegativeVeryThinSpace: "\u200B", nequiv: "\u2262",
  nesear: "\u2928", nesim: "\u2242\u0338", NestedGreaterGreater: "\u226B", NestedLessLess: "\u226A", NewLine: `
`, nexist: "\u2204", nexists: "\u2204", Nfr: "\u{1D511}", nfr: "\u{1D52B}", ngE: "\u2267\u0338", nge: "\u2271", ngeq: "\u2271", ngeqq: "\u2267\u0338",
  ngeqslant: "\u2A7E\u0338", nges: "\u2A7E\u0338", nGg: "\u22D9\u0338", ngsim: "\u2275", nGt: "\u226B\u20D2", ngt: "\u226F", ngtr: "\u226F",
  nGtv: "\u226B\u0338", nharr: "\u21AE", nhArr: "\u21CE", nhpar: "\u2AF2", ni: "\u220B", nis: "\u22FC", nisd: "\u22FA", niv: "\u220B", NJcy: "\
\u040A", njcy: "\u045A", nlarr: "\u219A", nlArr: "\u21CD", nldr: "\u2025", nlE: "\u2266\u0338", nle: "\u2270", nleftarrow: "\u219A", nLeftarrow: "\
\u21CD", nleftrightarrow: "\u21AE", nLeftrightarrow: "\u21CE", nleq: "\u2270", nleqq: "\u2266\u0338", nleqslant: "\u2A7D\u0338", nles: "\u2A7D\u0338",
  nless: "\u226E", nLl: "\u22D8\u0338", nlsim: "\u2274", nLt: "\u226A\u20D2", nlt: "\u226E", nltri: "\u22EA", nltrie: "\u22EC", nLtv: "\u226A\u0338",
  nmid: "\u2224", NoBreak: "\u2060", NonBreakingSpace: "\xA0", nopf: "\u{1D55F}", Nopf: "\u2115", Not: "\u2AEC", not: "\xAC", NotCongruent: "\
\u2262", NotCupCap: "\u226D", NotDoubleVerticalBar: "\u2226", NotElement: "\u2209", NotEqual: "\u2260", NotEqualTilde: "\u2242\u0338", NotExists: "\
\u2204", NotGreater: "\u226F", NotGreaterEqual: "\u2271", NotGreaterFullEqual: "\u2267\u0338", NotGreaterGreater: "\u226B\u0338", NotGreaterLess: "\
\u2279", NotGreaterSlantEqual: "\u2A7E\u0338", NotGreaterTilde: "\u2275", NotHumpDownHump: "\u224E\u0338", NotHumpEqual: "\u224F\u0338", notin: "\
\u2209", notindot: "\u22F5\u0338", notinE: "\u22F9\u0338", notinva: "\u2209", notinvb: "\u22F7", notinvc: "\u22F6", NotLeftTriangleBar: "\u29CF\u0338",
  NotLeftTriangle: "\u22EA", NotLeftTriangleEqual: "\u22EC", NotLess: "\u226E", NotLessEqual: "\u2270", NotLessGreater: "\u2278", NotLessLess: "\
\u226A\u0338", NotLessSlantEqual: "\u2A7D\u0338", NotLessTilde: "\u2274", NotNestedGreaterGreater: "\u2AA2\u0338", NotNestedLessLess: "\u2AA1\u0338",
  notni: "\u220C", notniva: "\u220C", notnivb: "\u22FE", notnivc: "\u22FD", NotPrecedes: "\u2280", NotPrecedesEqual: "\u2AAF\u0338", NotPrecedesSlantEqual: "\
\u22E0", NotReverseElement: "\u220C", NotRightTriangleBar: "\u29D0\u0338", NotRightTriangle: "\u22EB", NotRightTriangleEqual: "\u22ED", NotSquareSubset: "\
\u228F\u0338", NotSquareSubsetEqual: "\u22E2", NotSquareSuperset: "\u2290\u0338", NotSquareSupersetEqual: "\u22E3", NotSubset: "\u2282\u20D2",
  NotSubsetEqual: "\u2288", NotSucceeds: "\u2281", NotSucceedsEqual: "\u2AB0\u0338", NotSucceedsSlantEqual: "\u22E1", NotSucceedsTilde: "\u227F\u0338",
  NotSuperset: "\u2283\u20D2", NotSupersetEqual: "\u2289", NotTilde: "\u2241", NotTildeEqual: "\u2244", NotTildeFullEqual: "\u2247", NotTildeTilde: "\
\u2249", NotVerticalBar: "\u2224", nparallel: "\u2226", npar: "\u2226", nparsl: "\u2AFD\u20E5", npart: "\u2202\u0338", npolint: "\u2A14", npr: "\
\u2280", nprcue: "\u22E0", nprec: "\u2280", npreceq: "\u2AAF\u0338", npre: "\u2AAF\u0338", nrarrc: "\u2933\u0338", nrarr: "\u219B", nrArr: "\
\u21CF", nrarrw: "\u219D\u0338", nrightarrow: "\u219B", nRightarrow: "\u21CF", nrtri: "\u22EB", nrtrie: "\u22ED", nsc: "\u2281", nsccue: "\u22E1",
  nsce: "\u2AB0\u0338", Nscr: "\u{1D4A9}", nscr: "\u{1D4C3}", nshortmid: "\u2224", nshortparallel: "\u2226", nsim: "\u2241", nsime: "\u2244",
  nsimeq: "\u2244", nsmid: "\u2224", nspar: "\u2226", nsqsube: "\u22E2", nsqsupe: "\u22E3", nsub: "\u2284", nsubE: "\u2AC5\u0338", nsube: "\u2288",
  nsubset: "\u2282\u20D2", nsubseteq: "\u2288", nsubseteqq: "\u2AC5\u0338", nsucc: "\u2281", nsucceq: "\u2AB0\u0338", nsup: "\u2285", nsupE: "\
\u2AC6\u0338", nsupe: "\u2289", nsupset: "\u2283\u20D2", nsupseteq: "\u2289", nsupseteqq: "\u2AC6\u0338", ntgl: "\u2279", Ntilde: "\xD1", ntilde: "\
\xF1", ntlg: "\u2278", ntriangleleft: "\u22EA", ntrianglelefteq: "\u22EC", ntriangleright: "\u22EB", ntrianglerighteq: "\u22ED", Nu: "\u039D",
  nu: "\u03BD", num: "#", numero: "\u2116", numsp: "\u2007", nvap: "\u224D\u20D2", nvdash: "\u22AC", nvDash: "\u22AD", nVdash: "\u22AE", nVDash: "\
\u22AF", nvge: "\u2265\u20D2", nvgt: ">\u20D2", nvHarr: "\u2904", nvinfin: "\u29DE", nvlArr: "\u2902", nvle: "\u2264\u20D2", nvlt: "<\u20D2",
  nvltrie: "\u22B4\u20D2", nvrArr: "\u2903", nvrtrie: "\u22B5\u20D2", nvsim: "\u223C\u20D2", nwarhk: "\u2923", nwarr: "\u2196", nwArr: "\u21D6",
  nwarrow: "\u2196", nwnear: "\u2927", Oacute: "\xD3", oacute: "\xF3", oast: "\u229B", Ocirc: "\xD4", ocirc: "\xF4", ocir: "\u229A", Ocy: "\u041E",
  ocy: "\u043E", odash: "\u229D", Odblac: "\u0150", odblac: "\u0151", odiv: "\u2A38", odot: "\u2299", odsold: "\u29BC", OElig: "\u0152", oelig: "\
\u0153", ofcir: "\u29BF", Ofr: "\u{1D512}", ofr: "\u{1D52C}", ogon: "\u02DB", Ograve: "\xD2", ograve: "\xF2", ogt: "\u29C1", ohbar: "\u29B5",
  ohm: "\u03A9", oint: "\u222E", olarr: "\u21BA", olcir: "\u29BE", olcross: "\u29BB", oline: "\u203E", olt: "\u29C0", Omacr: "\u014C", omacr: "\
\u014D", Omega: "\u03A9", omega: "\u03C9", Omicron: "\u039F", omicron: "\u03BF", omid: "\u29B6", ominus: "\u2296", Oopf: "\u{1D546}", oopf: "\
\u{1D560}", opar: "\u29B7", OpenCurlyDoubleQuote: "\u201C", OpenCurlyQuote: "\u2018", operp: "\u29B9", oplus: "\u2295", orarr: "\u21BB", Or: "\
\u2A54", or: "\u2228", ord: "\u2A5D", order: "\u2134", orderof: "\u2134", ordf: "\xAA", ordm: "\xBA", origof: "\u22B6", oror: "\u2A56", orslope: "\
\u2A57", orv: "\u2A5B", oS: "\u24C8", Oscr: "\u{1D4AA}", oscr: "\u2134", Oslash: "\xD8", oslash: "\xF8", osol: "\u2298", Otilde: "\xD5", otilde: "\
\xF5", otimesas: "\u2A36", Otimes: "\u2A37", otimes: "\u2297", Ouml: "\xD6", ouml: "\xF6", ovbar: "\u233D", OverBar: "\u203E", OverBrace: "\u23DE",
  OverBracket: "\u23B4", OverParenthesis: "\u23DC", para: "\xB6", parallel: "\u2225", par: "\u2225", parsim: "\u2AF3", parsl: "\u2AFD", part: "\
\u2202", PartialD: "\u2202", Pcy: "\u041F", pcy: "\u043F", percnt: "%", period: ".", permil: "\u2030", perp: "\u22A5", pertenk: "\u2031", Pfr: "\
\u{1D513}", pfr: "\u{1D52D}", Phi: "\u03A6", phi: "\u03C6", phiv: "\u03D5", phmmat: "\u2133", phone: "\u260E", Pi: "\u03A0", pi: "\u03C0", pitchfork: "\
\u22D4", piv: "\u03D6", planck: "\u210F", planckh: "\u210E", plankv: "\u210F", plusacir: "\u2A23", plusb: "\u229E", pluscir: "\u2A22", plus: "\
+", plusdo: "\u2214", plusdu: "\u2A25", pluse: "\u2A72", PlusMinus: "\xB1", plusmn: "\xB1", plussim: "\u2A26", plustwo: "\u2A27", pm: "\xB1",
  Poincareplane: "\u210C", pointint: "\u2A15", popf: "\u{1D561}", Popf: "\u2119", pound: "\xA3", prap: "\u2AB7", Pr: "\u2ABB", pr: "\u227A",
  prcue: "\u227C", precapprox: "\u2AB7", prec: "\u227A", preccurlyeq: "\u227C", Precedes: "\u227A", PrecedesEqual: "\u2AAF", PrecedesSlantEqual: "\
\u227C", PrecedesTilde: "\u227E", preceq: "\u2AAF", precnapprox: "\u2AB9", precneqq: "\u2AB5", precnsim: "\u22E8", pre: "\u2AAF", prE: "\u2AB3",
  precsim: "\u227E", prime: "\u2032", Prime: "\u2033", primes: "\u2119", prnap: "\u2AB9", prnE: "\u2AB5", prnsim: "\u22E8", prod: "\u220F", Product: "\
\u220F", profalar: "\u232E", profline: "\u2312", profsurf: "\u2313", prop: "\u221D", Proportional: "\u221D", Proportion: "\u2237", propto: "\
\u221D", prsim: "\u227E", prurel: "\u22B0", Pscr: "\u{1D4AB}", pscr: "\u{1D4C5}", Psi: "\u03A8", psi: "\u03C8", puncsp: "\u2008", Qfr: "\u{1D514}",
  qfr: "\u{1D52E}", qint: "\u2A0C", qopf: "\u{1D562}", Qopf: "\u211A", qprime: "\u2057", Qscr: "\u{1D4AC}", qscr: "\u{1D4C6}", quaternions: "\
\u210D", quatint: "\u2A16", quest: "?", questeq: "\u225F", quot: '"', QUOT: '"', rAarr: "\u21DB", race: "\u223D\u0331", Racute: "\u0154", racute: "\
\u0155", radic: "\u221A", raemptyv: "\u29B3", rang: "\u27E9", Rang: "\u27EB", rangd: "\u2992", range: "\u29A5", rangle: "\u27E9", raquo: "\xBB",
  rarrap: "\u2975", rarrb: "\u21E5", rarrbfs: "\u2920", rarrc: "\u2933", rarr: "\u2192", Rarr: "\u21A0", rArr: "\u21D2", rarrfs: "\u291E", rarrhk: "\
\u21AA", rarrlp: "\u21AC", rarrpl: "\u2945", rarrsim: "\u2974", Rarrtl: "\u2916", rarrtl: "\u21A3", rarrw: "\u219D", ratail: "\u291A", rAtail: "\
\u291C", ratio: "\u2236", rationals: "\u211A", rbarr: "\u290D", rBarr: "\u290F", RBarr: "\u2910", rbbrk: "\u2773", rbrace: "}", rbrack: "]",
  rbrke: "\u298C", rbrksld: "\u298E", rbrkslu: "\u2990", Rcaron: "\u0158", rcaron: "\u0159", Rcedil: "\u0156", rcedil: "\u0157", rceil: "\u2309",
  rcub: "}", Rcy: "\u0420", rcy: "\u0440", rdca: "\u2937", rdldhar: "\u2969", rdquo: "\u201D", rdquor: "\u201D", rdsh: "\u21B3", real: "\u211C",
  realine: "\u211B", realpart: "\u211C", reals: "\u211D", Re: "\u211C", rect: "\u25AD", reg: "\xAE", REG: "\xAE", ReverseElement: "\u220B", ReverseEquilibrium: "\
\u21CB", ReverseUpEquilibrium: "\u296F", rfisht: "\u297D", rfloor: "\u230B", rfr: "\u{1D52F}", Rfr: "\u211C", rHar: "\u2964", rhard: "\u21C1",
  rharu: "\u21C0", rharul: "\u296C", Rho: "\u03A1", rho: "\u03C1", rhov: "\u03F1", RightAngleBracket: "\u27E9", RightArrowBar: "\u21E5", rightarrow: "\
\u2192", RightArrow: "\u2192", Rightarrow: "\u21D2", RightArrowLeftArrow: "\u21C4", rightarrowtail: "\u21A3", RightCeiling: "\u2309", RightDoubleBracket: "\
\u27E7", RightDownTeeVector: "\u295D", RightDownVectorBar: "\u2955", RightDownVector: "\u21C2", RightFloor: "\u230B", rightharpoondown: "\u21C1",
  rightharpoonup: "\u21C0", rightleftarrows: "\u21C4", rightleftharpoons: "\u21CC", rightrightarrows: "\u21C9", rightsquigarrow: "\u219D", RightTeeArrow: "\
\u21A6", RightTee: "\u22A2", RightTeeVector: "\u295B", rightthreetimes: "\u22CC", RightTriangleBar: "\u29D0", RightTriangle: "\u22B3", RightTriangleEqual: "\
\u22B5", RightUpDownVector: "\u294F", RightUpTeeVector: "\u295C", RightUpVectorBar: "\u2954", RightUpVector: "\u21BE", RightVectorBar: "\u2953",
  RightVector: "\u21C0", ring: "\u02DA", risingdotseq: "\u2253", rlarr: "\u21C4", rlhar: "\u21CC", rlm: "\u200F", rmoustache: "\u23B1", rmoust: "\
\u23B1", rnmid: "\u2AEE", roang: "\u27ED", roarr: "\u21FE", robrk: "\u27E7", ropar: "\u2986", ropf: "\u{1D563}", Ropf: "\u211D", roplus: "\u2A2E",
  rotimes: "\u2A35", RoundImplies: "\u2970", rpar: ")", rpargt: "\u2994", rppolint: "\u2A12", rrarr: "\u21C9", Rrightarrow: "\u21DB", rsaquo: "\
\u203A", rscr: "\u{1D4C7}", Rscr: "\u211B", rsh: "\u21B1", Rsh: "\u21B1", rsqb: "]", rsquo: "\u2019", rsquor: "\u2019", rthree: "\u22CC", rtimes: "\
\u22CA", rtri: "\u25B9", rtrie: "\u22B5", rtrif: "\u25B8", rtriltri: "\u29CE", RuleDelayed: "\u29F4", ruluhar: "\u2968", rx: "\u211E", Sacute: "\
\u015A", sacute: "\u015B", sbquo: "\u201A", scap: "\u2AB8", Scaron: "\u0160", scaron: "\u0161", Sc: "\u2ABC", sc: "\u227B", sccue: "\u227D",
  sce: "\u2AB0", scE: "\u2AB4", Scedil: "\u015E", scedil: "\u015F", Scirc: "\u015C", scirc: "\u015D", scnap: "\u2ABA", scnE: "\u2AB6", scnsim: "\
\u22E9", scpolint: "\u2A13", scsim: "\u227F", Scy: "\u0421", scy: "\u0441", sdotb: "\u22A1", sdot: "\u22C5", sdote: "\u2A66", searhk: "\u2925",
  searr: "\u2198", seArr: "\u21D8", searrow: "\u2198", sect: "\xA7", semi: ";", seswar: "\u2929", setminus: "\u2216", setmn: "\u2216", sext: "\
\u2736", Sfr: "\u{1D516}", sfr: "\u{1D530}", sfrown: "\u2322", sharp: "\u266F", SHCHcy: "\u0429", shchcy: "\u0449", SHcy: "\u0428", shcy: "\u0448",
  ShortDownArrow: "\u2193", ShortLeftArrow: "\u2190", shortmid: "\u2223", shortparallel: "\u2225", ShortRightArrow: "\u2192", ShortUpArrow: "\
\u2191", shy: "\xAD", Sigma: "\u03A3", sigma: "\u03C3", sigmaf: "\u03C2", sigmav: "\u03C2", sim: "\u223C", simdot: "\u2A6A", sime: "\u2243",
  simeq: "\u2243", simg: "\u2A9E", simgE: "\u2AA0", siml: "\u2A9D", simlE: "\u2A9F", simne: "\u2246", simplus: "\u2A24", simrarr: "\u2972", slarr: "\
\u2190", SmallCircle: "\u2218", smallsetminus: "\u2216", smashp: "\u2A33", smeparsl: "\u29E4", smid: "\u2223", smile: "\u2323", smt: "\u2AAA",
  smte: "\u2AAC", smtes: "\u2AAC\uFE00", SOFTcy: "\u042C", softcy: "\u044C", solbar: "\u233F", solb: "\u29C4", sol: "/", Sopf: "\u{1D54A}", sopf: "\
\u{1D564}", spades: "\u2660", spadesuit: "\u2660", spar: "\u2225", sqcap: "\u2293", sqcaps: "\u2293\uFE00", sqcup: "\u2294", sqcups: "\u2294\uFE00",
  Sqrt: "\u221A", sqsub: "\u228F", sqsube: "\u2291", sqsubset: "\u228F", sqsubseteq: "\u2291", sqsup: "\u2290", sqsupe: "\u2292", sqsupset: "\
\u2290", sqsupseteq: "\u2292", square: "\u25A1", Square: "\u25A1", SquareIntersection: "\u2293", SquareSubset: "\u228F", SquareSubsetEqual: "\
\u2291", SquareSuperset: "\u2290", SquareSupersetEqual: "\u2292", SquareUnion: "\u2294", squarf: "\u25AA", squ: "\u25A1", squf: "\u25AA", srarr: "\
\u2192", Sscr: "\u{1D4AE}", sscr: "\u{1D4C8}", ssetmn: "\u2216", ssmile: "\u2323", sstarf: "\u22C6", Star: "\u22C6", star: "\u2606", starf: "\
\u2605", straightepsilon: "\u03F5", straightphi: "\u03D5", strns: "\xAF", sub: "\u2282", Sub: "\u22D0", subdot: "\u2ABD", subE: "\u2AC5", sube: "\
\u2286", subedot: "\u2AC3", submult: "\u2AC1", subnE: "\u2ACB", subne: "\u228A", subplus: "\u2ABF", subrarr: "\u2979", subset: "\u2282", Subset: "\
\u22D0", subseteq: "\u2286", subseteqq: "\u2AC5", SubsetEqual: "\u2286", subsetneq: "\u228A", subsetneqq: "\u2ACB", subsim: "\u2AC7", subsub: "\
\u2AD5", subsup: "\u2AD3", succapprox: "\u2AB8", succ: "\u227B", succcurlyeq: "\u227D", Succeeds: "\u227B", SucceedsEqual: "\u2AB0", SucceedsSlantEqual: "\
\u227D", SucceedsTilde: "\u227F", succeq: "\u2AB0", succnapprox: "\u2ABA", succneqq: "\u2AB6", succnsim: "\u22E9", succsim: "\u227F", SuchThat: "\
\u220B", sum: "\u2211", Sum: "\u2211", sung: "\u266A", sup1: "\xB9", sup2: "\xB2", sup3: "\xB3", sup: "\u2283", Sup: "\u22D1", supdot: "\u2ABE",
  supdsub: "\u2AD8", supE: "\u2AC6", supe: "\u2287", supedot: "\u2AC4", Superset: "\u2283", SupersetEqual: "\u2287", suphsol: "\u27C9", suphsub: "\
\u2AD7", suplarr: "\u297B", supmult: "\u2AC2", supnE: "\u2ACC", supne: "\u228B", supplus: "\u2AC0", supset: "\u2283", Supset: "\u22D1", supseteq: "\
\u2287", supseteqq: "\u2AC6", supsetneq: "\u228B", supsetneqq: "\u2ACC", supsim: "\u2AC8", supsub: "\u2AD4", supsup: "\u2AD6", swarhk: "\u2926",
  swarr: "\u2199", swArr: "\u21D9", swarrow: "\u2199", swnwar: "\u292A", szlig: "\xDF", Tab: "	", target: "\u2316", Tau: "\u03A4", tau: "\u03C4",
  tbrk: "\u23B4", Tcaron: "\u0164", tcaron: "\u0165", Tcedil: "\u0162", tcedil: "\u0163", Tcy: "\u0422", tcy: "\u0442", tdot: "\u20DB", telrec: "\
\u2315", Tfr: "\u{1D517}", tfr: "\u{1D531}", there4: "\u2234", therefore: "\u2234", Therefore: "\u2234", Theta: "\u0398", theta: "\u03B8", thetasym: "\
\u03D1", thetav: "\u03D1", thickapprox: "\u2248", thicksim: "\u223C", ThickSpace: "\u205F\u200A", ThinSpace: "\u2009", thinsp: "\u2009", thkap: "\
\u2248", thksim: "\u223C", THORN: "\xDE", thorn: "\xFE", tilde: "\u02DC", Tilde: "\u223C", TildeEqual: "\u2243", TildeFullEqual: "\u2245", TildeTilde: "\
\u2248", timesbar: "\u2A31", timesb: "\u22A0", times: "\xD7", timesd: "\u2A30", tint: "\u222D", toea: "\u2928", topbot: "\u2336", topcir: "\u2AF1",
  top: "\u22A4", Topf: "\u{1D54B}", topf: "\u{1D565}", topfork: "\u2ADA", tosa: "\u2929", tprime: "\u2034", trade: "\u2122", TRADE: "\u2122",
  triangle: "\u25B5", triangledown: "\u25BF", triangleleft: "\u25C3", trianglelefteq: "\u22B4", triangleq: "\u225C", triangleright: "\u25B9",
  trianglerighteq: "\u22B5", tridot: "\u25EC", trie: "\u225C", triminus: "\u2A3A", TripleDot: "\u20DB", triplus: "\u2A39", trisb: "\u29CD", tritime: "\
\u2A3B", trpezium: "\u23E2", Tscr: "\u{1D4AF}", tscr: "\u{1D4C9}", TScy: "\u0426", tscy: "\u0446", TSHcy: "\u040B", tshcy: "\u045B", Tstrok: "\
\u0166", tstrok: "\u0167", twixt: "\u226C", twoheadleftarrow: "\u219E", twoheadrightarrow: "\u21A0", Uacute: "\xDA", uacute: "\xFA", uarr: "\
\u2191", Uarr: "\u219F", uArr: "\u21D1", Uarrocir: "\u2949", Ubrcy: "\u040E", ubrcy: "\u045E", Ubreve: "\u016C", ubreve: "\u016D", Ucirc: "\xDB",
  ucirc: "\xFB", Ucy: "\u0423", ucy: "\u0443", udarr: "\u21C5", Udblac: "\u0170", udblac: "\u0171", udhar: "\u296E", ufisht: "\u297E", Ufr: "\
\u{1D518}", ufr: "\u{1D532}", Ugrave: "\xD9", ugrave: "\xF9", uHar: "\u2963", uharl: "\u21BF", uharr: "\u21BE", uhblk: "\u2580", ulcorn: "\u231C",
  ulcorner: "\u231C", ulcrop: "\u230F", ultri: "\u25F8", Umacr: "\u016A", umacr: "\u016B", uml: "\xA8", UnderBar: "_", UnderBrace: "\u23DF",
  UnderBracket: "\u23B5", UnderParenthesis: "\u23DD", Union: "\u22C3", UnionPlus: "\u228E", Uogon: "\u0172", uogon: "\u0173", Uopf: "\u{1D54C}",
  uopf: "\u{1D566}", UpArrowBar: "\u2912", uparrow: "\u2191", UpArrow: "\u2191", Uparrow: "\u21D1", UpArrowDownArrow: "\u21C5", updownarrow: "\
\u2195", UpDownArrow: "\u2195", Updownarrow: "\u21D5", UpEquilibrium: "\u296E", upharpoonleft: "\u21BF", upharpoonright: "\u21BE", uplus: "\u228E",
  UpperLeftArrow: "\u2196", UpperRightArrow: "\u2197", upsi: "\u03C5", Upsi: "\u03D2", upsih: "\u03D2", Upsilon: "\u03A5", upsilon: "\u03C5",
  UpTeeArrow: "\u21A5", UpTee: "\u22A5", upuparrows: "\u21C8", urcorn: "\u231D", urcorner: "\u231D", urcrop: "\u230E", Uring: "\u016E", uring: "\
\u016F", urtri: "\u25F9", Uscr: "\u{1D4B0}", uscr: "\u{1D4CA}", utdot: "\u22F0", Utilde: "\u0168", utilde: "\u0169", utri: "\u25B5", utrif: "\
\u25B4", uuarr: "\u21C8", Uuml: "\xDC", uuml: "\xFC", uwangle: "\u29A7", vangrt: "\u299C", varepsilon: "\u03F5", varkappa: "\u03F0", varnothing: "\
\u2205", varphi: "\u03D5", varpi: "\u03D6", varpropto: "\u221D", varr: "\u2195", vArr: "\u21D5", varrho: "\u03F1", varsigma: "\u03C2", varsubsetneq: "\
\u228A\uFE00", varsubsetneqq: "\u2ACB\uFE00", varsupsetneq: "\u228B\uFE00", varsupsetneqq: "\u2ACC\uFE00", vartheta: "\u03D1", vartriangleleft: "\
\u22B2", vartriangleright: "\u22B3", vBar: "\u2AE8", Vbar: "\u2AEB", vBarv: "\u2AE9", Vcy: "\u0412", vcy: "\u0432", vdash: "\u22A2", vDash: "\
\u22A8", Vdash: "\u22A9", VDash: "\u22AB", Vdashl: "\u2AE6", veebar: "\u22BB", vee: "\u2228", Vee: "\u22C1", veeeq: "\u225A", vellip: "\u22EE",
  verbar: "|", Verbar: "\u2016", vert: "|", Vert: "\u2016", VerticalBar: "\u2223", VerticalLine: "|", VerticalSeparator: "\u2758", VerticalTilde: "\
\u2240", VeryThinSpace: "\u200A", Vfr: "\u{1D519}", vfr: "\u{1D533}", vltri: "\u22B2", vnsub: "\u2282\u20D2", vnsup: "\u2283\u20D2", Vopf: "\
\u{1D54D}", vopf: "\u{1D567}", vprop: "\u221D", vrtri: "\u22B3", Vscr: "\u{1D4B1}", vscr: "\u{1D4CB}", vsubnE: "\u2ACB\uFE00", vsubne: "\u228A\uFE00",
  vsupnE: "\u2ACC\uFE00", vsupne: "\u228B\uFE00", Vvdash: "\u22AA", vzigzag: "\u299A", Wcirc: "\u0174", wcirc: "\u0175", wedbar: "\u2A5F", wedge: "\
\u2227", Wedge: "\u22C0", wedgeq: "\u2259", weierp: "\u2118", Wfr: "\u{1D51A}", wfr: "\u{1D534}", Wopf: "\u{1D54E}", wopf: "\u{1D568}", wp: "\
\u2118", wr: "\u2240", wreath: "\u2240", Wscr: "\u{1D4B2}", wscr: "\u{1D4CC}", xcap: "\u22C2", xcirc: "\u25EF", xcup: "\u22C3", xdtri: "\u25BD",
  Xfr: "\u{1D51B}", xfr: "\u{1D535}", xharr: "\u27F7", xhArr: "\u27FA", Xi: "\u039E", xi: "\u03BE", xlarr: "\u27F5", xlArr: "\u27F8", xmap: "\
\u27FC", xnis: "\u22FB", xodot: "\u2A00", Xopf: "\u{1D54F}", xopf: "\u{1D569}", xoplus: "\u2A01", xotime: "\u2A02", xrarr: "\u27F6", xrArr: "\
\u27F9", Xscr: "\u{1D4B3}", xscr: "\u{1D4CD}", xsqcup: "\u2A06", xuplus: "\u2A04", xutri: "\u25B3", xvee: "\u22C1", xwedge: "\u22C0", Yacute: "\
\xDD", yacute: "\xFD", YAcy: "\u042F", yacy: "\u044F", Ycirc: "\u0176", ycirc: "\u0177", Ycy: "\u042B", ycy: "\u044B", yen: "\xA5", Yfr: "\u{1D51C}",
  yfr: "\u{1D536}", YIcy: "\u0407", yicy: "\u0457", Yopf: "\u{1D550}", yopf: "\u{1D56A}", Yscr: "\u{1D4B4}", yscr: "\u{1D4CE}", YUcy: "\u042E",
  yucy: "\u044E", yuml: "\xFF", Yuml: "\u0178", Zacute: "\u0179", zacute: "\u017A", Zcaron: "\u017D", zcaron: "\u017E", Zcy: "\u0417", zcy: "\
\u0437", Zdot: "\u017B", zdot: "\u017C", zeetrf: "\u2128", ZeroWidthSpace: "\u200B", Zeta: "\u0396", zeta: "\u03B6", zfr: "\u{1D537}", Zfr: "\
\u2128", ZHcy: "\u0416", zhcy: "\u0436", zigrarr: "\u21DD", zopf: "\u{1D56B}", Zopf: "\u2124", Zscr: "\u{1D4B5}", zscr: "\u{1D4CF}", zwj: "\u200D",
  zwnj: "\u200C" };
});

// ../node_modules/entities/lib/maps/legacy.json
var iD = b((kDt, i9e) => {
  i9e.exports = { Aacute: "\xC1", aacute: "\xE1", Acirc: "\xC2", acirc: "\xE2", acute: "\xB4", AElig: "\xC6", aelig: "\xE6", Agrave: "\xC0",
  agrave: "\xE0", amp: "&", AMP: "&", Aring: "\xC5", aring: "\xE5", Atilde: "\xC3", atilde: "\xE3", Auml: "\xC4", auml: "\xE4", brvbar: "\xA6",
  Ccedil: "\xC7", ccedil: "\xE7", cedil: "\xB8", cent: "\xA2", copy: "\xA9", COPY: "\xA9", curren: "\xA4", deg: "\xB0", divide: "\xF7", Eacute: "\
\xC9", eacute: "\xE9", Ecirc: "\xCA", ecirc: "\xEA", Egrave: "\xC8", egrave: "\xE8", ETH: "\xD0", eth: "\xF0", Euml: "\xCB", euml: "\xEB", frac12: "\
\xBD", frac14: "\xBC", frac34: "\xBE", gt: ">", GT: ">", Iacute: "\xCD", iacute: "\xED", Icirc: "\xCE", icirc: "\xEE", iexcl: "\xA1", Igrave: "\
\xCC", igrave: "\xEC", iquest: "\xBF", Iuml: "\xCF", iuml: "\xEF", laquo: "\xAB", lt: "<", LT: "<", macr: "\xAF", micro: "\xB5", middot: "\xB7",
  nbsp: "\xA0", not: "\xAC", Ntilde: "\xD1", ntilde: "\xF1", Oacute: "\xD3", oacute: "\xF3", Ocirc: "\xD4", ocirc: "\xF4", Ograve: "\xD2", ograve: "\
\xF2", ordf: "\xAA", ordm: "\xBA", Oslash: "\xD8", oslash: "\xF8", Otilde: "\xD5", otilde: "\xF5", Ouml: "\xD6", ouml: "\xF6", para: "\xB6",
  plusmn: "\xB1", pound: "\xA3", quot: '"', QUOT: '"', raquo: "\xBB", reg: "\xAE", REG: "\xAE", sect: "\xA7", shy: "\xAD", sup1: "\xB9", sup2: "\
\xB2", sup3: "\xB3", szlig: "\xDF", THORN: "\xDE", thorn: "\xFE", times: "\xD7", Uacute: "\xDA", uacute: "\xFA", Ucirc: "\xDB", ucirc: "\xFB",
  Ugrave: "\xD9", ugrave: "\xF9", uml: "\xA8", Uuml: "\xDC", uuml: "\xFC", Yacute: "\xDD", yacute: "\xFD", yen: "\xA5", yuml: "\xFF" };
});

// ../node_modules/entities/lib/maps/xml.json
var rb = b((IDt, n9e) => {
  n9e.exports = { amp: "&", apos: "'", gt: ">", lt: "<", quot: '"' };
});

// ../node_modules/renderkid/node_modules/htmlparser2/lib/Tokenizer.js
var sD = b((Vd) => {
  "use strict";
  var ib = Vd && Vd.__importDefault || function(e) {
    return e && e.__esModule ? e : { default: e };
  };
  Object.defineProperty(Vd, "__esModule", { value: !0 });
  var s9e = ib(rD()), a9e = ib(tb()), nD = ib(iD()), o9e = ib(rb());
  function Ys(e) {
    return e === " " || e === `
` || e === "	" || e === "\f" || e === "\r";
  }
  s(Ys, "whitespace");
  function Pj(e) {
    return e >= "a" && e <= "z" || e >= "A" && e <= "Z";
  }
  s(Pj, "isASCIIAlpha");
  function Sn(e, t, r) {
    var i = e.toLowerCase();
    return e === i ? function(n, a) {
      a === i ? n._state = t : (n._state = r, n._index--);
    } : function(n, a) {
      a === i || a === e ? n._state = t : (n._state = r, n._index--);
    };
  }
  s(Sn, "ifElseState");
  function $a(e, t) {
    var r = e.toLowerCase();
    return function(i, n) {
      n === r || n === e ? i._state = t : (i._state = 3, i._index--);
    };
  }
  s($a, "consumeSpecialNameChar");
  var u9e = Sn(
    "C",
    24,
    16
    /* InDeclaration */
  ), l9e = Sn(
    "D",
    25,
    16
    /* InDeclaration */
  ), c9e = Sn(
    "A",
    26,
    16
    /* InDeclaration */
  ), f9e = Sn(
    "T",
    27,
    16
    /* InDeclaration */
  ), p9e = Sn(
    "A",
    28,
    16
    /* InDeclaration */
  ), h9e = $a(
    "R",
    35
    /* BeforeScript2 */
  ), d9e = $a(
    "I",
    36
    /* BeforeScript3 */
  ), m9e = $a(
    "P",
    37
    /* BeforeScript4 */
  ), y9e = $a(
    "T",
    38
    /* BeforeScript5 */
  ), g9e = Sn(
    "R",
    40,
    1
    /* Text */
  ), _9e = Sn(
    "I",
    41,
    1
    /* Text */
  ), b9e = Sn(
    "P",
    42,
    1
    /* Text */
  ), v9e = Sn(
    "T",
    43,
    1
    /* Text */
  ), S9e = $a(
    "Y",
    45
    /* BeforeStyle2 */
  ), T9e = $a(
    "L",
    46
    /* BeforeStyle3 */
  ), E9e = $a(
    "E",
    47
    /* BeforeStyle4 */
  ), A9e = Sn(
    "Y",
    49,
    1
    /* Text */
  ), x9e = Sn(
    "L",
    50,
    1
    /* Text */
  ), C9e = Sn(
    "E",
    51,
    1
    /* Text */
  ), P9e = $a(
    "I",
    54
    /* BeforeTitle1 */
  ), D9e = $a(
    "T",
    55
    /* BeforeTitle2 */
  ), w9e = $a(
    "L",
    56
    /* BeforeTitle3 */
  ), O9e = $a(
    "E",
    57
    /* BeforeTitle4 */
  ), k9e = Sn(
    "I",
    58,
    1
    /* Text */
  ), I9e = Sn(
    "T",
    59,
    1
    /* Text */
  ), R9e = Sn(
    "L",
    60,
    1
    /* Text */
  ), N9e = Sn(
    "E",
    61,
    1
    /* Text */
  ), L9e = Sn(
    "#",
    63,
    64
    /* InNamedEntity */
  ), F9e = Sn(
    "X",
    66,
    65
    /* InNumericEntity */
  ), M9e = (
    /** @class */
    function() {
      function e(t, r) {
        var i;
        this._state = 1, this.buffer = "", this.sectionStart = 0, this._index = 0, this.bufferOffset = 0, this.baseState = 1, this.special =
        1, this.running = !0, this.ended = !1, this.cbs = r, this.xmlMode = !!t?.xmlMode, this.decodeEntities = (i = t?.decodeEntities) !== null &&
        i !== void 0 ? i : !0;
      }
      return s(e, "Tokenizer"), e.prototype.reset = function() {
        this._state = 1, this.buffer = "", this.sectionStart = 0, this._index = 0, this.bufferOffset = 0, this.baseState = 1, this.special =
        1, this.running = !0, this.ended = !1;
      }, e.prototype.write = function(t) {
        this.ended && this.cbs.onerror(Error(".write() after done!")), this.buffer += t, this.parse();
      }, e.prototype.end = function(t) {
        this.ended && this.cbs.onerror(Error(".end() after done!")), t && this.write(t), this.ended = !0, this.running && this.finish();
      }, e.prototype.pause = function() {
        this.running = !1;
      }, e.prototype.resume = function() {
        this.running = !0, this._index < this.buffer.length && this.parse(), this.ended && this.finish();
      }, e.prototype.getAbsoluteIndex = function() {
        return this.bufferOffset + this._index;
      }, e.prototype.stateText = function(t) {
        t === "<" ? (this._index > this.sectionStart && this.cbs.ontext(this.getSection()), this._state = 2, this.sectionStart = this._index) :
        this.decodeEntities && t === "&" && (this.special === 1 || this.special === 4) && (this._index > this.sectionStart && this.cbs.ontext(
        this.getSection()), this.baseState = 1, this._state = 62, this.sectionStart = this._index);
      }, e.prototype.isTagStartChar = function(t) {
        return Pj(t) || this.xmlMode && !Ys(t) && t !== "/" && t !== ">";
      }, e.prototype.stateBeforeTagName = function(t) {
        t === "/" ? this._state = 5 : t === "<" ? (this.cbs.ontext(this.getSection()), this.sectionStart = this._index) : t === ">" || this.
        special !== 1 || Ys(t) ? this._state = 1 : t === "!" ? (this._state = 15, this.sectionStart = this._index + 1) : t === "?" ? (this._state =
        17, this.sectionStart = this._index + 1) : this.isTagStartChar(t) ? (this._state = !this.xmlMode && (t === "s" || t === "S") ? 32 : !this.
        xmlMode && (t === "t" || t === "T") ? 52 : 3, this.sectionStart = this._index) : this._state = 1;
      }, e.prototype.stateInTagName = function(t) {
        (t === "/" || t === ">" || Ys(t)) && (this.emitToken("onopentagname"), this._state = 8, this._index--);
      }, e.prototype.stateBeforeClosingTagName = function(t) {
        Ys(t) || (t === ">" ? this._state = 1 : this.special !== 1 ? this.special !== 4 && (t === "s" || t === "S") ? this._state = 33 : this.
        special === 4 && (t === "t" || t === "T") ? this._state = 53 : (this._state = 1, this._index--) : this.isTagStartChar(t) ? (this._state =
        6, this.sectionStart = this._index) : (this._state = 20, this.sectionStart = this._index));
      }, e.prototype.stateInClosingTagName = function(t) {
        (t === ">" || Ys(t)) && (this.emitToken("onclosetag"), this._state = 7, this._index--);
      }, e.prototype.stateAfterClosingTagName = function(t) {
        t === ">" && (this._state = 1, this.sectionStart = this._index + 1);
      }, e.prototype.stateBeforeAttributeName = function(t) {
        t === ">" ? (this.cbs.onopentagend(), this._state = 1, this.sectionStart = this._index + 1) : t === "/" ? this._state = 4 : Ys(t) ||
        (this._state = 9, this.sectionStart = this._index);
      }, e.prototype.stateInSelfClosingTag = function(t) {
        t === ">" ? (this.cbs.onselfclosingtag(), this._state = 1, this.sectionStart = this._index + 1, this.special = 1) : Ys(t) || (this._state =
        8, this._index--);
      }, e.prototype.stateInAttributeName = function(t) {
        (t === "=" || t === "/" || t === ">" || Ys(t)) && (this.cbs.onattribname(this.getSection()), this.sectionStart = -1, this._state = 10,
        this._index--);
      }, e.prototype.stateAfterAttributeName = function(t) {
        t === "=" ? this._state = 11 : t === "/" || t === ">" ? (this.cbs.onattribend(void 0), this._state = 8, this._index--) : Ys(t) || (this.
        cbs.onattribend(void 0), this._state = 9, this.sectionStart = this._index);
      }, e.prototype.stateBeforeAttributeValue = function(t) {
        t === '"' ? (this._state = 12, this.sectionStart = this._index + 1) : t === "'" ? (this._state = 13, this.sectionStart = this._index +
        1) : Ys(t) || (this._state = 14, this.sectionStart = this._index, this._index--);
      }, e.prototype.handleInAttributeValue = function(t, r) {
        t === r ? (this.emitToken("onattribdata"), this.cbs.onattribend(r), this._state = 8) : this.decodeEntities && t === "&" && (this.emitToken(
        "onattribdata"), this.baseState = this._state, this._state = 62, this.sectionStart = this._index);
      }, e.prototype.stateInAttributeValueDoubleQuotes = function(t) {
        this.handleInAttributeValue(t, '"');
      }, e.prototype.stateInAttributeValueSingleQuotes = function(t) {
        this.handleInAttributeValue(t, "'");
      }, e.prototype.stateInAttributeValueNoQuotes = function(t) {
        Ys(t) || t === ">" ? (this.emitToken("onattribdata"), this.cbs.onattribend(null), this._state = 8, this._index--) : this.decodeEntities &&
        t === "&" && (this.emitToken("onattribdata"), this.baseState = this._state, this._state = 62, this.sectionStart = this._index);
      }, e.prototype.stateBeforeDeclaration = function(t) {
        this._state = t === "[" ? 23 : t === "-" ? 18 : 16;
      }, e.prototype.stateInDeclaration = function(t) {
        t === ">" && (this.cbs.ondeclaration(this.getSection()), this._state = 1, this.sectionStart = this._index + 1);
      }, e.prototype.stateInProcessingInstruction = function(t) {
        t === ">" && (this.cbs.onprocessinginstruction(this.getSection()), this._state = 1, this.sectionStart = this._index + 1);
      }, e.prototype.stateBeforeComment = function(t) {
        t === "-" ? (this._state = 19, this.sectionStart = this._index + 1) : this._state = 16;
      }, e.prototype.stateInComment = function(t) {
        t === "-" && (this._state = 21);
      }, e.prototype.stateInSpecialComment = function(t) {
        t === ">" && (this.cbs.oncomment(this.buffer.substring(this.sectionStart, this._index)), this._state = 1, this.sectionStart = this._index +
        1);
      }, e.prototype.stateAfterComment1 = function(t) {
        t === "-" ? this._state = 22 : this._state = 19;
      }, e.prototype.stateAfterComment2 = function(t) {
        t === ">" ? (this.cbs.oncomment(this.buffer.substring(this.sectionStart, this._index - 2)), this._state = 1, this.sectionStart = this.
        _index + 1) : t !== "-" && (this._state = 19);
      }, e.prototype.stateBeforeCdata6 = function(t) {
        t === "[" ? (this._state = 29, this.sectionStart = this._index + 1) : (this._state = 16, this._index--);
      }, e.prototype.stateInCdata = function(t) {
        t === "]" && (this._state = 30);
      }, e.prototype.stateAfterCdata1 = function(t) {
        t === "]" ? this._state = 31 : this._state = 29;
      }, e.prototype.stateAfterCdata2 = function(t) {
        t === ">" ? (this.cbs.oncdata(this.buffer.substring(this.sectionStart, this._index - 2)), this._state = 1, this.sectionStart = this.
        _index + 1) : t !== "]" && (this._state = 29);
      }, e.prototype.stateBeforeSpecialS = function(t) {
        t === "c" || t === "C" ? this._state = 34 : t === "t" || t === "T" ? this._state = 44 : (this._state = 3, this._index--);
      }, e.prototype.stateBeforeSpecialSEnd = function(t) {
        this.special === 2 && (t === "c" || t === "C") ? this._state = 39 : this.special === 3 && (t === "t" || t === "T") ? this._state = 48 :
        this._state = 1;
      }, e.prototype.stateBeforeSpecialLast = function(t, r) {
        (t === "/" || t === ">" || Ys(t)) && (this.special = r), this._state = 3, this._index--;
      }, e.prototype.stateAfterSpecialLast = function(t, r) {
        t === ">" || Ys(t) ? (this.special = 1, this._state = 6, this.sectionStart = this._index - r, this._index--) : this._state = 1;
      }, e.prototype.parseFixedEntity = function(t) {
        if (t === void 0 && (t = this.xmlMode ? o9e.default : a9e.default), this.sectionStart + 1 < this._index) {
          var r = this.buffer.substring(this.sectionStart + 1, this._index);
          Object.prototype.hasOwnProperty.call(t, r) && (this.emitPartial(t[r]), this.sectionStart = this._index + 1);
        }
      }, e.prototype.parseLegacyEntity = function() {
        for (var t = this.sectionStart + 1, r = Math.min(this._index - t, 6); r >= 2; ) {
          var i = this.buffer.substr(t, r);
          if (Object.prototype.hasOwnProperty.call(nD.default, i)) {
            this.emitPartial(nD.default[i]), this.sectionStart += r + 1;
            return;
          }
          r--;
        }
      }, e.prototype.stateInNamedEntity = function(t) {
        t === ";" ? (this.parseFixedEntity(), this.baseState === 1 && this.sectionStart + 1 < this._index && !this.xmlMode && this.parseLegacyEntity(),
        this._state = this.baseState) : (t < "0" || t > "9") && !Pj(t) && (this.xmlMode || this.sectionStart + 1 === this._index || (this.baseState !==
        1 ? t !== "=" && this.parseFixedEntity(nD.default) : this.parseLegacyEntity()), this._state = this.baseState, this._index--);
      }, e.prototype.decodeNumericEntity = function(t, r, i) {
        var n = this.sectionStart + t;
        if (n !== this._index) {
          var a = this.buffer.substring(n, this._index), o = parseInt(a, r);
          this.emitPartial(s9e.default(o)), this.sectionStart = i ? this._index + 1 : this._index;
        }
        this._state = this.baseState;
      }, e.prototype.stateInNumericEntity = function(t) {
        t === ";" ? this.decodeNumericEntity(2, 10, !0) : (t < "0" || t > "9") && (this.xmlMode ? this._state = this.baseState : this.decodeNumericEntity(
        2, 10, !1), this._index--);
      }, e.prototype.stateInHexEntity = function(t) {
        t === ";" ? this.decodeNumericEntity(3, 16, !0) : (t < "a" || t > "f") && (t < "A" || t > "F") && (t < "0" || t > "9") && (this.xmlMode ?
        this._state = this.baseState : this.decodeNumericEntity(3, 16, !1), this._index--);
      }, e.prototype.cleanup = function() {
        this.sectionStart < 0 ? (this.buffer = "", this.bufferOffset += this._index, this._index = 0) : this.running && (this._state === 1 ?
        (this.sectionStart !== this._index && this.cbs.ontext(this.buffer.substr(this.sectionStart)), this.buffer = "", this.bufferOffset +=
        this._index, this._index = 0) : this.sectionStart === this._index ? (this.buffer = "", this.bufferOffset += this._index, this._index =
        0) : (this.buffer = this.buffer.substr(this.sectionStart), this._index -= this.sectionStart, this.bufferOffset += this.sectionStart),
        this.sectionStart = 0);
      }, e.prototype.parse = function() {
        for (; this._index < this.buffer.length && this.running; ) {
          var t = this.buffer.charAt(this._index);
          this._state === 1 ? this.stateText(t) : this._state === 12 ? this.stateInAttributeValueDoubleQuotes(t) : this._state === 9 ? this.
          stateInAttributeName(t) : this._state === 19 ? this.stateInComment(t) : this._state === 20 ? this.stateInSpecialComment(t) : this.
          _state === 8 ? this.stateBeforeAttributeName(t) : this._state === 3 ? this.stateInTagName(t) : this._state === 6 ? this.stateInClosingTagName(
          t) : this._state === 2 ? this.stateBeforeTagName(t) : this._state === 10 ? this.stateAfterAttributeName(t) : this._state === 13 ? this.
          stateInAttributeValueSingleQuotes(t) : this._state === 11 ? this.stateBeforeAttributeValue(t) : this._state === 5 ? this.stateBeforeClosingTagName(
          t) : this._state === 7 ? this.stateAfterClosingTagName(t) : this._state === 32 ? this.stateBeforeSpecialS(t) : this._state === 21 ?
          this.stateAfterComment1(t) : this._state === 14 ? this.stateInAttributeValueNoQuotes(t) : this._state === 4 ? this.stateInSelfClosingTag(
          t) : this._state === 16 ? this.stateInDeclaration(t) : this._state === 15 ? this.stateBeforeDeclaration(t) : this._state === 22 ? this.
          stateAfterComment2(t) : this._state === 18 ? this.stateBeforeComment(t) : this._state === 33 ? this.stateBeforeSpecialSEnd(t) : this.
          _state === 53 ? k9e(this, t) : this._state === 39 ? g9e(this, t) : this._state === 40 ? _9e(this, t) : this._state === 41 ? b9e(this,
          t) : this._state === 34 ? h9e(this, t) : this._state === 35 ? d9e(this, t) : this._state === 36 ? m9e(this, t) : this._state === 37 ?
          y9e(this, t) : this._state === 38 ? this.stateBeforeSpecialLast(
            t,
            2
            /* Script */
          ) : this._state === 42 ? v9e(this, t) : this._state === 43 ? this.stateAfterSpecialLast(t, 6) : this._state === 44 ? S9e(this, t) :
          this._state === 29 ? this.stateInCdata(t) : this._state === 45 ? T9e(this, t) : this._state === 46 ? E9e(this, t) : this._state ===
          47 ? this.stateBeforeSpecialLast(
            t,
            3
            /* Style */
          ) : this._state === 48 ? A9e(this, t) : this._state === 49 ? x9e(this, t) : this._state === 50 ? C9e(this, t) : this._state === 51 ?
          this.stateAfterSpecialLast(t, 5) : this._state === 52 ? P9e(this, t) : this._state === 54 ? D9e(this, t) : this._state === 55 ? w9e(
          this, t) : this._state === 56 ? O9e(this, t) : this._state === 57 ? this.stateBeforeSpecialLast(
            t,
            4
            /* Title */
          ) : this._state === 58 ? I9e(this, t) : this._state === 59 ? R9e(this, t) : this._state === 60 ? N9e(this, t) : this._state === 61 ?
          this.stateAfterSpecialLast(t, 5) : this._state === 17 ? this.stateInProcessingInstruction(t) : this._state === 64 ? this.stateInNamedEntity(
          t) : this._state === 23 ? u9e(this, t) : this._state === 62 ? L9e(this, t) : this._state === 24 ? l9e(this, t) : this._state === 25 ?
          c9e(this, t) : this._state === 30 ? this.stateAfterCdata1(t) : this._state === 31 ? this.stateAfterCdata2(t) : this._state === 26 ?
          f9e(this, t) : this._state === 27 ? p9e(this, t) : this._state === 28 ? this.stateBeforeCdata6(t) : this._state === 66 ? this.stateInHexEntity(
          t) : this._state === 65 ? this.stateInNumericEntity(t) : this._state === 63 ? F9e(this, t) : this.cbs.onerror(Error("unknown _stat\
e"), this._state), this._index++;
        }
        this.cleanup();
      }, e.prototype.finish = function() {
        this.sectionStart < this._index && this.handleTrailingData(), this.cbs.onend();
      }, e.prototype.handleTrailingData = function() {
        var t = this.buffer.substr(this.sectionStart);
        this._state === 29 || this._state === 30 || this._state === 31 ? this.cbs.oncdata(t) : this._state === 19 || this._state === 21 || this.
        _state === 22 ? this.cbs.oncomment(t) : this._state === 64 && !this.xmlMode ? (this.parseLegacyEntity(), this.sectionStart < this._index &&
        (this._state = this.baseState, this.handleTrailingData())) : this._state === 65 && !this.xmlMode ? (this.decodeNumericEntity(2, 10, !1),
        this.sectionStart < this._index && (this._state = this.baseState, this.handleTrailingData())) : this._state === 66 && !this.xmlMode ?
        (this.decodeNumericEntity(3, 16, !1), this.sectionStart < this._index && (this._state = this.baseState, this.handleTrailingData())) :
        this._state !== 3 && this._state !== 8 && this._state !== 11 && this._state !== 10 && this._state !== 9 && this._state !== 13 && this.
        _state !== 12 && this._state !== 14 && this._state !== 6 && this.cbs.ontext(t);
      }, e.prototype.getSection = function() {
        return this.buffer.substring(this.sectionStart, this._index);
      }, e.prototype.emitToken = function(t) {
        this.cbs[t](this.getSection()), this.sectionStart = -1;
      }, e.prototype.emitPartial = function(t) {
        this.baseState !== 1 ? this.cbs.onattribdata(t) : this.cbs.ontext(t);
      }, e;
    }()
  );
  Vd.default = M9e;
});

// ../node_modules/renderkid/node_modules/htmlparser2/lib/Parser.js
var oD = b((hp) => {
  "use strict";
  var B9e = hp && hp.__importDefault || function(e) {
    return e && e.__esModule ? e : { default: e };
  };
  Object.defineProperty(hp, "__esModule", { value: !0 });
  hp.Parser = void 0;
  var q9e = B9e(sD()), pp = /* @__PURE__ */ new Set([
    "input",
    "option",
    "optgroup",
    "select",
    "button",
    "datalist",
    "textarea"
  ]), Ur = /* @__PURE__ */ new Set(["p"]), Dj = {
    tr: /* @__PURE__ */ new Set(["tr", "th", "td"]),
    th: /* @__PURE__ */ new Set(["th"]),
    td: /* @__PURE__ */ new Set(["thead", "th", "td"]),
    body: /* @__PURE__ */ new Set(["head", "link", "script"]),
    li: /* @__PURE__ */ new Set(["li"]),
    p: Ur,
    h1: Ur,
    h2: Ur,
    h3: Ur,
    h4: Ur,
    h5: Ur,
    h6: Ur,
    select: pp,
    input: pp,
    output: pp,
    button: pp,
    datalist: pp,
    textarea: pp,
    option: /* @__PURE__ */ new Set(["option"]),
    optgroup: /* @__PURE__ */ new Set(["optgroup", "option"]),
    dd: /* @__PURE__ */ new Set(["dt", "dd"]),
    dt: /* @__PURE__ */ new Set(["dt", "dd"]),
    address: Ur,
    article: Ur,
    aside: Ur,
    blockquote: Ur,
    details: Ur,
    div: Ur,
    dl: Ur,
    fieldset: Ur,
    figcaption: Ur,
    figure: Ur,
    footer: Ur,
    form: Ur,
    header: Ur,
    hr: Ur,
    main: Ur,
    nav: Ur,
    ol: Ur,
    pre: Ur,
    section: Ur,
    table: Ur,
    ul: Ur,
    rt: /* @__PURE__ */ new Set(["rt", "rp"]),
    rp: /* @__PURE__ */ new Set(["rt", "rp"]),
    tbody: /* @__PURE__ */ new Set(["thead", "tbody"]),
    tfoot: /* @__PURE__ */ new Set(["thead", "tbody"])
  }, aD = /* @__PURE__ */ new Set([
    "area",
    "base",
    "basefont",
    "br",
    "col",
    "command",
    "embed",
    "frame",
    "hr",
    "img",
    "input",
    "isindex",
    "keygen",
    "link",
    "meta",
    "param",
    "source",
    "track",
    "wbr"
  ]), wj = /* @__PURE__ */ new Set(["math", "svg"]), Oj = /* @__PURE__ */ new Set([
    "mi",
    "mo",
    "mn",
    "ms",
    "mtext",
    "annotation-xml",
    "foreignObject",
    "desc",
    "title"
  ]), U9e = /\s|\//, j9e = (
    /** @class */
    function() {
      function e(t, r) {
        r === void 0 && (r = {});
        var i, n, a, o, u;
        this.startIndex = 0, this.endIndex = null, this.tagname = "", this.attribname = "", this.attribvalue = "", this.attribs = null, this.
        stack = [], this.foreignContext = [], this.options = r, this.cbs = t ?? {}, this.lowerCaseTagNames = (i = r.lowerCaseTags) !== null &&
        i !== void 0 ? i : !r.xmlMode, this.lowerCaseAttributeNames = (n = r.lowerCaseAttributeNames) !== null && n !== void 0 ? n : !r.xmlMode,
        this.tokenizer = new ((a = r.Tokenizer) !== null && a !== void 0 ? a : q9e.default)(this.options, this), (u = (o = this.cbs).onparserinit) ===
        null || u === void 0 || u.call(o, this);
      }
      return s(e, "Parser"), e.prototype.updatePosition = function(t) {
        this.endIndex === null ? this.tokenizer.sectionStart <= t ? this.startIndex = 0 : this.startIndex = this.tokenizer.sectionStart - t :
        this.startIndex = this.endIndex + 1, this.endIndex = this.tokenizer.getAbsoluteIndex();
      }, e.prototype.ontext = function(t) {
        var r, i;
        this.updatePosition(1), this.endIndex--, (i = (r = this.cbs).ontext) === null || i === void 0 || i.call(r, t);
      }, e.prototype.onopentagname = function(t) {
        var r, i;
        if (this.lowerCaseTagNames && (t = t.toLowerCase()), this.tagname = t, !this.options.xmlMode && Object.prototype.hasOwnProperty.call(
        Dj, t))
          for (var n = void 0; this.stack.length > 0 && Dj[t].has(n = this.stack[this.stack.length - 1]); )
            this.onclosetag(n);
        (this.options.xmlMode || !aD.has(t)) && (this.stack.push(t), wj.has(t) ? this.foreignContext.push(!0) : Oj.has(t) && this.foreignContext.
        push(!1)), (i = (r = this.cbs).onopentagname) === null || i === void 0 || i.call(r, t), this.cbs.onopentag && (this.attribs = {});
      }, e.prototype.onopentagend = function() {
        var t, r;
        this.updatePosition(1), this.attribs && ((r = (t = this.cbs).onopentag) === null || r === void 0 || r.call(t, this.tagname, this.attribs),
        this.attribs = null), !this.options.xmlMode && this.cbs.onclosetag && aD.has(this.tagname) && this.cbs.onclosetag(this.tagname), this.
        tagname = "";
      }, e.prototype.onclosetag = function(t) {
        if (this.updatePosition(1), this.lowerCaseTagNames && (t = t.toLowerCase()), (wj.has(t) || Oj.has(t)) && this.foreignContext.pop(), this.
        stack.length && (this.options.xmlMode || !aD.has(t))) {
          var r = this.stack.lastIndexOf(t);
          if (r !== -1)
            if (this.cbs.onclosetag)
              for (r = this.stack.length - r; r--; )
                this.cbs.onclosetag(this.stack.pop());
            else
              this.stack.length = r;
          else t === "p" && !this.options.xmlMode && (this.onopentagname(t), this.closeCurrentTag());
        } else !this.options.xmlMode && (t === "br" || t === "p") && (this.onopentagname(t), this.closeCurrentTag());
      }, e.prototype.onselfclosingtag = function() {
        this.options.xmlMode || this.options.recognizeSelfClosing || this.foreignContext[this.foreignContext.length - 1] ? this.closeCurrentTag() :
        this.onopentagend();
      }, e.prototype.closeCurrentTag = function() {
        var t, r, i = this.tagname;
        this.onopentagend(), this.stack[this.stack.length - 1] === i && ((r = (t = this.cbs).onclosetag) === null || r === void 0 || r.call(
        t, i), this.stack.pop());
      }, e.prototype.onattribname = function(t) {
        this.lowerCaseAttributeNames && (t = t.toLowerCase()), this.attribname = t;
      }, e.prototype.onattribdata = function(t) {
        this.attribvalue += t;
      }, e.prototype.onattribend = function(t) {
        var r, i;
        (i = (r = this.cbs).onattribute) === null || i === void 0 || i.call(r, this.attribname, this.attribvalue, t), this.attribs && !Object.
        prototype.hasOwnProperty.call(this.attribs, this.attribname) && (this.attribs[this.attribname] = this.attribvalue), this.attribname =
        "", this.attribvalue = "";
      }, e.prototype.getInstructionName = function(t) {
        var r = t.search(U9e), i = r < 0 ? t : t.substr(0, r);
        return this.lowerCaseTagNames && (i = i.toLowerCase()), i;
      }, e.prototype.ondeclaration = function(t) {
        if (this.cbs.onprocessinginstruction) {
          var r = this.getInstructionName(t);
          this.cbs.onprocessinginstruction("!" + r, "!" + t);
        }
      }, e.prototype.onprocessinginstruction = function(t) {
        if (this.cbs.onprocessinginstruction) {
          var r = this.getInstructionName(t);
          this.cbs.onprocessinginstruction("?" + r, "?" + t);
        }
      }, e.prototype.oncomment = function(t) {
        var r, i, n, a;
        this.updatePosition(4), (i = (r = this.cbs).oncomment) === null || i === void 0 || i.call(r, t), (a = (n = this.cbs).oncommentend) ===
        null || a === void 0 || a.call(n);
      }, e.prototype.oncdata = function(t) {
        var r, i, n, a, o, u;
        this.updatePosition(1), this.options.xmlMode || this.options.recognizeCDATA ? ((i = (r = this.cbs).oncdatastart) === null || i === void 0 ||
        i.call(r), (a = (n = this.cbs).ontext) === null || a === void 0 || a.call(n, t), (u = (o = this.cbs).oncdataend) === null || u === void 0 ||
        u.call(o)) : this.oncomment("[CDATA[" + t + "]]");
      }, e.prototype.onerror = function(t) {
        var r, i;
        (i = (r = this.cbs).onerror) === null || i === void 0 || i.call(r, t);
      }, e.prototype.onend = function() {
        var t, r;
        if (this.cbs.onclosetag)
          for (var i = this.stack.length; i > 0; this.cbs.onclosetag(this.stack[--i]))
            ;
        (r = (t = this.cbs).onend) === null || r === void 0 || r.call(t);
      }, e.prototype.reset = function() {
        var t, r, i, n;
        (r = (t = this.cbs).onreset) === null || r === void 0 || r.call(t), this.tokenizer.reset(), this.tagname = "", this.attribname = "",
        this.attribs = null, this.stack = [], (n = (i = this.cbs).onparserinit) === null || n === void 0 || n.call(i, this);
      }, e.prototype.parseComplete = function(t) {
        this.reset(), this.end(t);
      }, e.prototype.write = function(t) {
        this.tokenizer.write(t);
      }, e.prototype.end = function(t) {
        this.tokenizer.end(t);
      }, e.prototype.pause = function() {
        this.tokenizer.pause();
      }, e.prototype.resume = function() {
        this.tokenizer.resume();
      }, e.prototype.parseChunk = function(t) {
        this.write(t);
      }, e.prototype.done = function(t) {
        this.end(t);
      }, e;
    }()
  );
  hp.Parser = j9e;
});

// ../node_modules/domelementtype/lib/index.js
var dp = b((ni) => {
  "use strict";
  Object.defineProperty(ni, "__esModule", { value: !0 });
  ni.Doctype = ni.CDATA = ni.Tag = ni.Style = ni.Script = ni.Comment = ni.Directive = ni.Text = ni.Root = ni.isTag = ni.ElementType = void 0;
  var Js;
  (function(e) {
    e.Root = "root", e.Text = "text", e.Directive = "directive", e.Comment = "comment", e.Script = "script", e.Style = "style", e.Tag = "tag",
    e.CDATA = "cdata", e.Doctype = "doctype";
  })(Js = ni.ElementType || (ni.ElementType = {}));
  function V9e(e) {
    return e.type === Js.Tag || e.type === Js.Script || e.type === Js.Style;
  }
  s(V9e, "isTag");
  ni.isTag = V9e;
  ni.Root = Js.Root;
  ni.Text = Js.Text;
  ni.Directive = Js.Directive;
  ni.Comment = Js.Comment;
  ni.Script = Js.Script;
  ni.Style = Js.Style;
  ni.Tag = Js.Tag;
  ni.CDATA = Js.CDATA;
  ni.Doctype = Js.Doctype;
});

// ../node_modules/domhandler/lib/node.js
var fD = b((Jt) => {
  "use strict";
  var gc = Jt && Jt.__extends || /* @__PURE__ */ function() {
    var e = /* @__PURE__ */ s(function(t, r) {
      return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, n) {
        i.__proto__ = n;
      } || function(i, n) {
        for (var a in n) Object.prototype.hasOwnProperty.call(n, a) && (i[a] = n[a]);
      }, e(t, r);
    }, "extendStatics");
    return function(t, r) {
      if (typeof r != "function" && r !== null)
        throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
      e(t, r);
      function i() {
        this.constructor = t;
      }
      s(i, "__"), t.prototype = r === null ? Object.create(r) : (i.prototype = r.prototype, new i());
    };
  }(), Kd = Jt && Jt.__assign || function() {
    return Kd = Object.assign || function(e) {
      for (var t, r = 1, i = arguments.length; r < i; r++) {
        t = arguments[r];
        for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
      }
      return e;
    }, Kd.apply(this, arguments);
  };
  Object.defineProperty(Jt, "__esModule", { value: !0 });
  Jt.cloneNode = Jt.hasChildren = Jt.isDocument = Jt.isDirective = Jt.isComment = Jt.isText = Jt.isCDATA = Jt.isTag = Jt.Element = Jt.Document =
  Jt.NodeWithChildren = Jt.ProcessingInstruction = Jt.Comment = Jt.Text = Jt.DataNode = Jt.Node = void 0;
  var Ni = dp(), K9e = /* @__PURE__ */ new Map([
    [Ni.ElementType.Tag, 1],
    [Ni.ElementType.Script, 1],
    [Ni.ElementType.Style, 1],
    [Ni.ElementType.Directive, 1],
    [Ni.ElementType.Text, 3],
    [Ni.ElementType.CDATA, 4],
    [Ni.ElementType.Comment, 8],
    [Ni.ElementType.Root, 9]
  ]), lD = (
    /** @class */
    function() {
      function e(t) {
        this.type = t, this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
      }
      return s(e, "Node"), Object.defineProperty(e.prototype, "nodeType", {
        // Read-only aliases
        /**
         * [DOM spec](https://dom.spec.whatwg.org/#dom-node-nodetype)-compatible
         * node {@link type}.
         */
        get: /* @__PURE__ */ s(function() {
          var t;
          return (t = K9e.get(this.type)) !== null && t !== void 0 ? t : 1;
        }, "get"),
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(e.prototype, "parentNode", {
        // Read-write aliases for properties
        /**
         * Same as {@link parent}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */
        get: /* @__PURE__ */ s(function() {
          return this.parent;
        }, "get"),
        set: /* @__PURE__ */ s(function(t) {
          this.parent = t;
        }, "set"),
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(e.prototype, "previousSibling", {
        /**
         * Same as {@link prev}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */
        get: /* @__PURE__ */ s(function() {
          return this.prev;
        }, "get"),
        set: /* @__PURE__ */ s(function(t) {
          this.prev = t;
        }, "set"),
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(e.prototype, "nextSibling", {
        /**
         * Same as {@link next}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */
        get: /* @__PURE__ */ s(function() {
          return this.next;
        }, "get"),
        set: /* @__PURE__ */ s(function(t) {
          this.next = t;
        }, "set"),
        enumerable: !1,
        configurable: !0
      }), e.prototype.cloneNode = function(t) {
        return t === void 0 && (t = !1), cD(this, t);
      }, e;
    }()
  );
  Jt.Node = lD;
  var nb = (
    /** @class */
    function(e) {
      gc(t, e);
      function t(r, i) {
        var n = e.call(this, r) || this;
        return n.data = i, n;
      }
      return s(t, "DataNode"), Object.defineProperty(t.prototype, "nodeValue", {
        /**
         * Same as {@link data}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */
        get: /* @__PURE__ */ s(function() {
          return this.data;
        }, "get"),
        set: /* @__PURE__ */ s(function(r) {
          this.data = r;
        }, "set"),
        enumerable: !1,
        configurable: !0
      }), t;
    }(lD)
  );
  Jt.DataNode = nb;
  var kj = (
    /** @class */
    function(e) {
      gc(t, e);
      function t(r) {
        return e.call(this, Ni.ElementType.Text, r) || this;
      }
      return s(t, "Text"), t;
    }(nb)
  );
  Jt.Text = kj;
  var Ij = (
    /** @class */
    function(e) {
      gc(t, e);
      function t(r) {
        return e.call(this, Ni.ElementType.Comment, r) || this;
      }
      return s(t, "Comment"), t;
    }(nb)
  );
  Jt.Comment = Ij;
  var Rj = (
    /** @class */
    function(e) {
      gc(t, e);
      function t(r, i) {
        var n = e.call(this, Ni.ElementType.Directive, i) || this;
        return n.name = r, n;
      }
      return s(t, "ProcessingInstruction"), t;
    }(nb)
  );
  Jt.ProcessingInstruction = Rj;
  var sb = (
    /** @class */
    function(e) {
      gc(t, e);
      function t(r, i) {
        var n = e.call(this, r) || this;
        return n.children = i, n;
      }
      return s(t, "NodeWithChildren"), Object.defineProperty(t.prototype, "firstChild", {
        // Aliases
        /** First child of the node. */
        get: /* @__PURE__ */ s(function() {
          var r;
          return (r = this.children[0]) !== null && r !== void 0 ? r : null;
        }, "get"),
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(t.prototype, "lastChild", {
        /** Last child of the node. */
        get: /* @__PURE__ */ s(function() {
          return this.children.length > 0 ? this.children[this.children.length - 1] : null;
        }, "get"),
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(t.prototype, "childNodes", {
        /**
         * Same as {@link children}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */
        get: /* @__PURE__ */ s(function() {
          return this.children;
        }, "get"),
        set: /* @__PURE__ */ s(function(r) {
          this.children = r;
        }, "set"),
        enumerable: !1,
        configurable: !0
      }), t;
    }(lD)
  );
  Jt.NodeWithChildren = sb;
  var Nj = (
    /** @class */
    function(e) {
      gc(t, e);
      function t(r) {
        return e.call(this, Ni.ElementType.Root, r) || this;
      }
      return s(t, "Document"), t;
    }(sb)
  );
  Jt.Document = Nj;
  var Lj = (
    /** @class */
    function(e) {
      gc(t, e);
      function t(r, i, n, a) {
        n === void 0 && (n = []), a === void 0 && (a = r === "script" ? Ni.ElementType.Script : r === "style" ? Ni.ElementType.Style : Ni.ElementType.
        Tag);
        var o = e.call(this, a, n) || this;
        return o.name = r, o.attribs = i, o;
      }
      return s(t, "Element"), Object.defineProperty(t.prototype, "tagName", {
        // DOM Level 1 aliases
        /**
         * Same as {@link name}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */
        get: /* @__PURE__ */ s(function() {
          return this.name;
        }, "get"),
        set: /* @__PURE__ */ s(function(r) {
          this.name = r;
        }, "set"),
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(t.prototype, "attributes", {
        get: /* @__PURE__ */ s(function() {
          var r = this;
          return Object.keys(this.attribs).map(function(i) {
            var n, a;
            return {
              name: i,
              value: r.attribs[i],
              namespace: (n = r["x-attribsNamespace"]) === null || n === void 0 ? void 0 : n[i],
              prefix: (a = r["x-attribsPrefix"]) === null || a === void 0 ? void 0 : a[i]
            };
          });
        }, "get"),
        enumerable: !1,
        configurable: !0
      }), t;
    }(sb)
  );
  Jt.Element = Lj;
  function Fj(e) {
    return (0, Ni.isTag)(e);
  }
  s(Fj, "isTag");
  Jt.isTag = Fj;
  function Mj(e) {
    return e.type === Ni.ElementType.CDATA;
  }
  s(Mj, "isCDATA");
  Jt.isCDATA = Mj;
  function Bj(e) {
    return e.type === Ni.ElementType.Text;
  }
  s(Bj, "isText");
  Jt.isText = Bj;
  function qj(e) {
    return e.type === Ni.ElementType.Comment;
  }
  s(qj, "isComment");
  Jt.isComment = qj;
  function Uj(e) {
    return e.type === Ni.ElementType.Directive;
  }
  s(Uj, "isDirective");
  Jt.isDirective = Uj;
  function jj(e) {
    return e.type === Ni.ElementType.Root;
  }
  s(jj, "isDocument");
  Jt.isDocument = jj;
  function H9e(e) {
    return Object.prototype.hasOwnProperty.call(e, "children");
  }
  s(H9e, "hasChildren");
  Jt.hasChildren = H9e;
  function cD(e, t) {
    t === void 0 && (t = !1);
    var r;
    if (Bj(e))
      r = new kj(e.data);
    else if (qj(e))
      r = new Ij(e.data);
    else if (Fj(e)) {
      var i = t ? uD(e.children) : [], n = new Lj(e.name, Kd({}, e.attribs), i);
      i.forEach(function(l) {
        return l.parent = n;
      }), e.namespace != null && (n.namespace = e.namespace), e["x-attribsNamespace"] && (n["x-attribsNamespace"] = Kd({}, e["x-attribsNames\
pace"])), e["x-attribsPrefix"] && (n["x-attribsPrefix"] = Kd({}, e["x-attribsPrefix"])), r = n;
    } else if (Mj(e)) {
      var i = t ? uD(e.children) : [], a = new sb(Ni.ElementType.CDATA, i);
      i.forEach(function(c) {
        return c.parent = a;
      }), r = a;
    } else if (jj(e)) {
      var i = t ? uD(e.children) : [], o = new Nj(i);
      i.forEach(function(c) {
        return c.parent = o;
      }), e["x-mode"] && (o["x-mode"] = e["x-mode"]), r = o;
    } else if (Uj(e)) {
      var u = new Rj(e.name, e.data);
      e["x-name"] != null && (u["x-name"] = e["x-name"], u["x-publicId"] = e["x-publicId"], u["x-systemId"] = e["x-systemId"]), r = u;
    } else
      throw new Error("Not implemented yet: ".concat(e.type));
    return r.startIndex = e.startIndex, r.endIndex = e.endIndex, e.sourceCodeLocation != null && (r.sourceCodeLocation = e.sourceCodeLocation),
    r;
  }
  s(cD, "cloneNode");
  Jt.cloneNode = cD;
  function uD(e) {
    for (var t = e.map(function(i) {
      return cD(i, !0);
    }), r = 1; r < t.length; r++)
      t[r].prev = t[r - 1], t[r - 1].next = t[r];
    return t;
  }
  s(uD, "cloneChildren");
});

// ../node_modules/domhandler/lib/index.js
var Cu = b((Fo) => {
  "use strict";
  var z9e = Fo && Fo.__createBinding || (Object.create ? function(e, t, r, i) {
    i === void 0 && (i = r);
    var n = Object.getOwnPropertyDescriptor(t, r);
    (!n || ("get" in n ? !t.__esModule : n.writable || n.configurable)) && (n = { enumerable: !0, get: /* @__PURE__ */ s(function() {
      return t[r];
    }, "get") }), Object.defineProperty(e, i, n);
  } : function(e, t, r, i) {
    i === void 0 && (i = r), e[i] = t[r];
  }), G9e = Fo && Fo.__exportStar || function(e, t) {
    for (var r in e) r !== "default" && !Object.prototype.hasOwnProperty.call(t, r) && z9e(t, e, r);
  };
  Object.defineProperty(Fo, "__esModule", { value: !0 });
  Fo.DomHandler = void 0;
  var ab = dp(), _l = fD();
  G9e(fD(), Fo);
  var Vj = /\s+/g, Kj = {
    normalizeWhitespace: !1,
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, Hj = (
    /** @class */
    function() {
      function e(t, r, i) {
        this.dom = [], this.root = new _l.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser =
        null, typeof r == "function" && (i = r, r = Kj), typeof t == "object" && (r = t, t = void 0), this.callback = t ?? null, this.options =
        r ?? Kj, this.elementCB = i ?? null;
      }
      return s(e, "DomHandler"), e.prototype.onparserinit = function(t) {
        this.parser = t;
      }, e.prototype.onreset = function() {
        this.dom = [], this.root = new _l.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser =
        null;
      }, e.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, e.prototype.onerror = function(t) {
        this.handleCallback(t);
      }, e.prototype.onclosetag = function() {
        this.lastNode = null;
        var t = this.tagStack.pop();
        this.options.withEndIndices && (t.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(t);
      }, e.prototype.onopentag = function(t, r) {
        var i = this.options.xmlMode ? ab.ElementType.Tag : void 0, n = new _l.Element(t, r, void 0, i);
        this.addNode(n), this.tagStack.push(n);
      }, e.prototype.ontext = function(t) {
        var r = this.options.normalizeWhitespace, i = this.lastNode;
        if (i && i.type === ab.ElementType.Text)
          r ? i.data = (i.data + t).replace(Vj, " ") : i.data += t, this.options.withEndIndices && (i.endIndex = this.parser.endIndex);
        else {
          r && (t = t.replace(Vj, " "));
          var n = new _l.Text(t);
          this.addNode(n), this.lastNode = n;
        }
      }, e.prototype.oncomment = function(t) {
        if (this.lastNode && this.lastNode.type === ab.ElementType.Comment) {
          this.lastNode.data += t;
          return;
        }
        var r = new _l.Comment(t);
        this.addNode(r), this.lastNode = r;
      }, e.prototype.oncommentend = function() {
        this.lastNode = null;
      }, e.prototype.oncdatastart = function() {
        var t = new _l.Text(""), r = new _l.NodeWithChildren(ab.ElementType.CDATA, [t]);
        this.addNode(r), t.parent = r, this.lastNode = t;
      }, e.prototype.oncdataend = function() {
        this.lastNode = null;
      }, e.prototype.onprocessinginstruction = function(t, r) {
        var i = new _l.ProcessingInstruction(t, r);
        this.addNode(i);
      }, e.prototype.handleCallback = function(t) {
        if (typeof this.callback == "function")
          this.callback(t, this.dom);
        else if (t)
          throw t;
      }, e.prototype.addNode = function(t) {
        var r = this.tagStack[this.tagStack.length - 1], i = r.children[r.children.length - 1];
        this.options.withStartIndices && (t.startIndex = this.parser.startIndex), this.options.withEndIndices && (t.endIndex = this.parser.endIndex),
        r.children.push(t), i && (t.prev = i, i.next = t), t.parent = r, this.lastNode = null;
      }, e;
    }()
  );
  Fo.DomHandler = Hj;
  Fo.default = Hj;
});

// ../node_modules/entities/lib/decode.js
var hD = b((Mo) => {
  "use strict";
  var ob = Mo && Mo.__importDefault || function(e) {
    return e && e.__esModule ? e : { default: e };
  };
  Object.defineProperty(Mo, "__esModule", { value: !0 });
  Mo.decodeHTML = Mo.decodeHTMLStrict = Mo.decodeXML = void 0;
  var pD = ob(tb()), W9e = ob(iD()), $9e = ob(rb()), zj = ob(rD()), X9e = /&(?:[a-zA-Z0-9]+|#[xX][\da-fA-F]+|#\d+);/g;
  Mo.decodeXML = Wj($9e.default);
  Mo.decodeHTMLStrict = Wj(pD.default);
  function Wj(e) {
    var t = $j(e);
    return function(r) {
      return String(r).replace(X9e, t);
    };
  }
  s(Wj, "getStrictDecoder");
  var Gj = /* @__PURE__ */ s(function(e, t) {
    return e < t ? 1 : -1;
  }, "sorter");
  Mo.decodeHTML = function() {
    for (var e = Object.keys(W9e.default).sort(Gj), t = Object.keys(pD.default).sort(Gj), r = 0, i = 0; r < t.length; r++)
      e[i] === t[r] ? (t[r] += ";?", i++) : t[r] += ";";
    var n = new RegExp("&(?:" + t.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g"), a = $j(pD.default);
    function o(u) {
      return u.substr(-1) !== ";" && (u += ";"), a(u);
    }
    return s(o, "replacer"), function(u) {
      return String(u).replace(n, o);
    };
  }();
  function $j(e) {
    return /* @__PURE__ */ s(function(r) {
      if (r.charAt(1) === "#") {
        var i = r.charAt(2);
        return i === "X" || i === "x" ? zj.default(parseInt(r.substr(3), 16)) : zj.default(parseInt(r.substr(2), 10));
      }
      return e[r.slice(1, -1)] || r;
    }, "replace");
  }
  s($j, "getReplacer");
});

// ../node_modules/entities/lib/encode.js
var mD = b((Ls) => {
  "use strict";
  var Xj = Ls && Ls.__importDefault || function(e) {
    return e && e.__esModule ? e : { default: e };
  };
  Object.defineProperty(Ls, "__esModule", { value: !0 });
  Ls.escapeUTF8 = Ls.escape = Ls.encodeNonAsciiHTML = Ls.encodeHTML = Ls.encodeXML = void 0;
  var Y9e = Xj(rb()), Yj = Qj(Y9e.default), Jj = Zj(Yj);
  Ls.encodeXML = rV(Yj);
  var J9e = Xj(tb()), dD = Qj(J9e.default), Q9e = Zj(dD);
  Ls.encodeHTML = e6e(dD, Q9e);
  Ls.encodeNonAsciiHTML = rV(dD);
  function Qj(e) {
    return Object.keys(e).sort().reduce(function(t, r) {
      return t[e[r]] = "&" + r + ";", t;
    }, {});
  }
  s(Qj, "getInverseObj");
  function Zj(e) {
    for (var t = [], r = [], i = 0, n = Object.keys(e); i < n.length; i++) {
      var a = n[i];
      a.length === 1 ? t.push("\\" + a) : r.push(a);
    }
    t.sort();
    for (var o = 0; o < t.length - 1; o++) {
      for (var u = o; u < t.length - 1 && t[u].charCodeAt(1) + 1 === t[u + 1].charCodeAt(1); )
        u += 1;
      var l = 1 + u - o;
      l < 3 || t.splice(o, l, t[o] + "-" + t[u]);
    }
    return r.unshift("[" + t.join("") + "]"), new RegExp(r.join("|"), "g");
  }
  s(Zj, "getInverseReplacer");
  var eV = /(?:[\x80-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g,
  Z9e = (
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    String.prototype.codePointAt != null ? (
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      function(e) {
        return e.codePointAt(0);
      }
    ) : (
      // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
      function(e) {
        return (e.charCodeAt(0) - 55296) * 1024 + e.charCodeAt(1) - 56320 + 65536;
      }
    )
  );
  function ub(e) {
    return "&#x" + (e.length > 1 ? Z9e(e) : e.charCodeAt(0)).toString(16).toUpperCase() + ";";
  }
  s(ub, "singleCharReplacer");
  function e6e(e, t) {
    return function(r) {
      return r.replace(t, function(i) {
        return e[i];
      }).replace(eV, ub);
    };
  }
  s(e6e, "getInverse");
  var tV = new RegExp(Jj.source + "|" + eV.source, "g");
  function t6e(e) {
    return e.replace(tV, ub);
  }
  s(t6e, "escape");
  Ls.escape = t6e;
  function r6e(e) {
    return e.replace(Jj, ub);
  }
  s(r6e, "escapeUTF8");
  Ls.escapeUTF8 = r6e;
  function rV(e) {
    return function(t) {
      return t.replace(tV, function(r) {
        return e[r] || ub(r);
      });
    };
  }
  s(rV, "getASCIIEncoder");
});

// ../node_modules/entities/lib/index.js
var nV = b((Qt) => {
  "use strict";
  Object.defineProperty(Qt, "__esModule", { value: !0 });
  Qt.decodeXMLStrict = Qt.decodeHTML5Strict = Qt.decodeHTML4Strict = Qt.decodeHTML5 = Qt.decodeHTML4 = Qt.decodeHTMLStrict = Qt.decodeHTML =
  Qt.decodeXML = Qt.encodeHTML5 = Qt.encodeHTML4 = Qt.escapeUTF8 = Qt.escape = Qt.encodeNonAsciiHTML = Qt.encodeHTML = Qt.encodeXML = Qt.encode =
  Qt.decodeStrict = Qt.decode = void 0;
  var lb = hD(), iV = mD();
  function i6e(e, t) {
    return (!t || t <= 0 ? lb.decodeXML : lb.decodeHTML)(e);
  }
  s(i6e, "decode");
  Qt.decode = i6e;
  function n6e(e, t) {
    return (!t || t <= 0 ? lb.decodeXML : lb.decodeHTMLStrict)(e);
  }
  s(n6e, "decodeStrict");
  Qt.decodeStrict = n6e;
  function s6e(e, t) {
    return (!t || t <= 0 ? iV.encodeXML : iV.encodeHTML)(e);
  }
  s(s6e, "encode");
  Qt.encode = s6e;
  var _c = mD();
  Object.defineProperty(Qt, "encodeXML", { enumerable: !0, get: /* @__PURE__ */ s(function() {
    return _c.encodeXML;
  }, "get") });
  Object.defineProperty(Qt, "encodeHTML", { enumerable: !0, get: /* @__PURE__ */ s(function() {
    return _c.encodeHTML;
  }, "get") });
  Object.defineProperty(Qt, "encodeNonAsciiHTML", { enumerable: !0, get: /* @__PURE__ */ s(function() {
    return _c.encodeNonAsciiHTML;
  }, "get") });
  Object.defineProperty(Qt, "escape", { enumerable: !0, get: /* @__PURE__ */ s(function() {
    return _c.escape;
  }, "get") });
  Object.defineProperty(Qt, "escapeUTF8", { enumerable: !0, get: /* @__PURE__ */ s(function() {
    return _c.escapeUTF8;
  }, "get") });
  Object.defineProperty(Qt, "encodeHTML4", { enumerable: !0, get: /* @__PURE__ */ s(function() {
    return _c.encodeHTML;
  }, "get") });
  Object.defineProperty(Qt, "encodeHTML5", { enumerable: !0, get: /* @__PURE__ */ s(function() {
    return _c.encodeHTML;
  }, "get") });
  var bl = hD();
  Object.defineProperty(Qt, "decodeXML", { enumerable: !0, get: /* @__PURE__ */ s(function() {
    return bl.decodeXML;
  }, "get") });
  Object.defineProperty(Qt, "decodeHTML", { enumerable: !0, get: /* @__PURE__ */ s(function() {
    return bl.decodeHTML;
  }, "get") });
  Object.defineProperty(Qt, "decodeHTMLStrict", { enumerable: !0, get: /* @__PURE__ */ s(function() {
    return bl.decodeHTMLStrict;
  }, "get") });
  Object.defineProperty(Qt, "decodeHTML4", { enumerable: !0, get: /* @__PURE__ */ s(function() {
    return bl.decodeHTML;
  }, "get") });
  Object.defineProperty(Qt, "decodeHTML5", { enumerable: !0, get: /* @__PURE__ */ s(function() {
    return bl.decodeHTML;
  }, "get") });
  Object.defineProperty(Qt, "decodeHTML4Strict", { enumerable: !0, get: /* @__PURE__ */ s(function() {
    return bl.decodeHTMLStrict;
  }, "get") });
  Object.defineProperty(Qt, "decodeHTML5Strict", { enumerable: !0, get: /* @__PURE__ */ s(function() {
    return bl.decodeHTMLStrict;
  }, "get") });
  Object.defineProperty(Qt, "decodeXMLStrict", { enumerable: !0, get: /* @__PURE__ */ s(function() {
    return bl.decodeXML;
  }, "get") });
});

// ../node_modules/domutils/node_modules/dom-serializer/lib/foreignNames.js
var sV = b((mp) => {
  "use strict";
  Object.defineProperty(mp, "__esModule", { value: !0 });
  mp.attributeNames = mp.elementNames = void 0;
  mp.elementNames = /* @__PURE__ */ new Map([
    ["altglyph", "altGlyph"],
    ["altglyphdef", "altGlyphDef"],
    ["altglyphitem", "altGlyphItem"],
    ["animatecolor", "animateColor"],
    ["animatemotion", "animateMotion"],
    ["animatetransform", "animateTransform"],
    ["clippath", "clipPath"],
    ["feblend", "feBlend"],
    ["fecolormatrix", "feColorMatrix"],
    ["fecomponenttransfer", "feComponentTransfer"],
    ["fecomposite", "feComposite"],
    ["feconvolvematrix", "feConvolveMatrix"],
    ["fediffuselighting", "feDiffuseLighting"],
    ["fedisplacementmap", "feDisplacementMap"],
    ["fedistantlight", "feDistantLight"],
    ["fedropshadow", "feDropShadow"],
    ["feflood", "feFlood"],
    ["fefunca", "feFuncA"],
    ["fefuncb", "feFuncB"],
    ["fefuncg", "feFuncG"],
    ["fefuncr", "feFuncR"],
    ["fegaussianblur", "feGaussianBlur"],
    ["feimage", "feImage"],
    ["femerge", "feMerge"],
    ["femergenode", "feMergeNode"],
    ["femorphology", "feMorphology"],
    ["feoffset", "feOffset"],
    ["fepointlight", "fePointLight"],
    ["fespecularlighting", "feSpecularLighting"],
    ["fespotlight", "feSpotLight"],
    ["fetile", "feTile"],
    ["feturbulence", "feTurbulence"],
    ["foreignobject", "foreignObject"],
    ["glyphref", "glyphRef"],
    ["lineargradient", "linearGradient"],
    ["radialgradient", "radialGradient"],
    ["textpath", "textPath"]
  ]);
  mp.attributeNames = /* @__PURE__ */ new Map([
    ["definitionurl", "definitionURL"],
    ["attributename", "attributeName"],
    ["attributetype", "attributeType"],
    ["basefrequency", "baseFrequency"],
    ["baseprofile", "baseProfile"],
    ["calcmode", "calcMode"],
    ["clippathunits", "clipPathUnits"],
    ["diffuseconstant", "diffuseConstant"],
    ["edgemode", "edgeMode"],
    ["filterunits", "filterUnits"],
    ["glyphref", "glyphRef"],
    ["gradienttransform", "gradientTransform"],
    ["gradientunits", "gradientUnits"],
    ["kernelmatrix", "kernelMatrix"],
    ["kernelunitlength", "kernelUnitLength"],
    ["keypoints", "keyPoints"],
    ["keysplines", "keySplines"],
    ["keytimes", "keyTimes"],
    ["lengthadjust", "lengthAdjust"],
    ["limitingconeangle", "limitingConeAngle"],
    ["markerheight", "markerHeight"],
    ["markerunits", "markerUnits"],
    ["markerwidth", "markerWidth"],
    ["maskcontentunits", "maskContentUnits"],
    ["maskunits", "maskUnits"],
    ["numoctaves", "numOctaves"],
    ["pathlength", "pathLength"],
    ["patterncontentunits", "patternContentUnits"],
    ["patterntransform", "patternTransform"],
    ["patternunits", "patternUnits"],
    ["pointsatx", "pointsAtX"],
    ["pointsaty", "pointsAtY"],
    ["pointsatz", "pointsAtZ"],
    ["preservealpha", "preserveAlpha"],
    ["preserveaspectratio", "preserveAspectRatio"],
    ["primitiveunits", "primitiveUnits"],
    ["refx", "refX"],
    ["refy", "refY"],
    ["repeatcount", "repeatCount"],
    ["repeatdur", "repeatDur"],
    ["requiredextensions", "requiredExtensions"],
    ["requiredfeatures", "requiredFeatures"],
    ["specularconstant", "specularConstant"],
    ["specularexponent", "specularExponent"],
    ["spreadmethod", "spreadMethod"],
    ["startoffset", "startOffset"],
    ["stddeviation", "stdDeviation"],
    ["stitchtiles", "stitchTiles"],
    ["surfacescale", "surfaceScale"],
    ["systemlanguage", "systemLanguage"],
    ["tablevalues", "tableValues"],
    ["targetx", "targetX"],
    ["targety", "targetY"],
    ["textlength", "textLength"],
    ["viewbox", "viewBox"],
    ["viewtarget", "viewTarget"],
    ["xchannelselector", "xChannelSelector"],
    ["ychannelselector", "yChannelSelector"],
    ["zoomandpan", "zoomAndPan"]
  ]);
});

// ../node_modules/domutils/node_modules/dom-serializer/lib/index.js
var lV = b((Xa) => {
  "use strict";
  var yp = Xa && Xa.__assign || function() {
    return yp = Object.assign || function(e) {
      for (var t, r = 1, i = arguments.length; r < i; r++) {
        t = arguments[r];
        for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
      }
      return e;
    }, yp.apply(this, arguments);
  }, a6e = Xa && Xa.__createBinding || (Object.create ? function(e, t, r, i) {
    i === void 0 && (i = r), Object.defineProperty(e, i, { enumerable: !0, get: /* @__PURE__ */ s(function() {
      return t[r];
    }, "get") });
  } : function(e, t, r, i) {
    i === void 0 && (i = r), e[i] = t[r];
  }), o6e = Xa && Xa.__setModuleDefault || (Object.create ? function(e, t) {
    Object.defineProperty(e, "default", { enumerable: !0, value: t });
  } : function(e, t) {
    e.default = t;
  }), u6e = Xa && Xa.__importStar || function(e) {
    if (e && e.__esModule) return e;
    var t = {};
    if (e != null) for (var r in e) r !== "default" && Object.prototype.hasOwnProperty.call(e, r) && a6e(t, e, r);
    return o6e(t, e), t;
  };
  Object.defineProperty(Xa, "__esModule", { value: !0 });
  var Pu = u6e(dp()), oV = nV(), uV = sV(), l6e = /* @__PURE__ */ new Set([
    "style",
    "script",
    "xmp",
    "iframe",
    "noembed",
    "noframes",
    "plaintext",
    "noscript"
  ]);
  function c6e(e, t) {
    if (e)
      return Object.keys(e).map(function(r) {
        var i, n, a = (i = e[r]) !== null && i !== void 0 ? i : "";
        return t.xmlMode === "foreign" && (r = (n = uV.attributeNames.get(r)) !== null && n !== void 0 ? n : r), !t.emptyAttrs && !t.xmlMode &&
        a === "" ? r : r + '="' + (t.decodeEntities !== !1 ? oV.encodeXML(a) : a.replace(/"/g, "&quot;")) + '"';
      }).join(" ");
  }
  s(c6e, "formatAttributes");
  var aV = /* @__PURE__ */ new Set([
    "area",
    "base",
    "basefont",
    "br",
    "col",
    "command",
    "embed",
    "frame",
    "hr",
    "img",
    "input",
    "isindex",
    "keygen",
    "link",
    "meta",
    "param",
    "source",
    "track",
    "wbr"
  ]);
  function yD(e, t) {
    t === void 0 && (t = {});
    for (var r = ("length" in e) ? e : [e], i = "", n = 0; n < r.length; n++)
      i += f6e(r[n], t);
    return i;
  }
  s(yD, "render");
  Xa.default = yD;
  function f6e(e, t) {
    switch (e.type) {
      case Pu.Root:
        return yD(e.children, t);
      case Pu.Directive:
      case Pu.Doctype:
        return m6e(e);
      case Pu.Comment:
        return _6e(e);
      case Pu.CDATA:
        return g6e(e);
      case Pu.Script:
      case Pu.Style:
      case Pu.Tag:
        return d6e(e, t);
      case Pu.Text:
        return y6e(e, t);
    }
  }
  s(f6e, "renderNode");
  var p6e = /* @__PURE__ */ new Set([
    "mi",
    "mo",
    "mn",
    "ms",
    "mtext",
    "annotation-xml",
    "foreignObject",
    "desc",
    "title"
  ]), h6e = /* @__PURE__ */ new Set(["svg", "math"]);
  function d6e(e, t) {
    var r;
    t.xmlMode === "foreign" && (e.name = (r = uV.elementNames.get(e.name)) !== null && r !== void 0 ? r : e.name, e.parent && p6e.has(e.parent.
    name) && (t = yp(yp({}, t), { xmlMode: !1 }))), !t.xmlMode && h6e.has(e.name) && (t = yp(yp({}, t), { xmlMode: "foreign" }));
    var i = "<" + e.name, n = c6e(e.attribs, t);
    return n && (i += " " + n), e.children.length === 0 && (t.xmlMode ? (
      // In XML mode or foreign mode, and user hasn't explicitly turned off self-closing tags
      t.selfClosingTags !== !1
    ) : (
      // User explicitly asked for self-closing tags, even in HTML mode
      t.selfClosingTags && aV.has(e.name)
    )) ? (t.xmlMode || (i += " "), i += "/>") : (i += ">", e.children.length > 0 && (i += yD(e.children, t)), (t.xmlMode || !aV.has(e.name)) &&
    (i += "</" + e.name + ">")), i;
  }
  s(d6e, "renderTag");
  function m6e(e) {
    return "<" + e.data + ">";
  }
  s(m6e, "renderDirective");
  function y6e(e, t) {
    var r = e.data || "";
    return t.decodeEntities !== !1 && !(!t.xmlMode && e.parent && l6e.has(e.parent.name)) && (r = oV.encodeXML(r)), r;
  }
  s(y6e, "renderText");
  function g6e(e) {
    return "<![CDATA[" + e.children[0].data + "]]>";
  }
  s(g6e, "renderCdata");
  function _6e(e) {
    return "<!--" + e.data + "-->";
  }
  s(_6e, "renderComment");
});

// ../node_modules/domutils/lib/stringify.js
var bD = b((Fs) => {
  "use strict";
  var b6e = Fs && Fs.__importDefault || function(e) {
    return e && e.__esModule ? e : { default: e };
  };
  Object.defineProperty(Fs, "__esModule", { value: !0 });
  Fs.innerText = Fs.textContent = Fs.getText = Fs.getInnerHTML = Fs.getOuterHTML = void 0;
  var Bo = Cu(), v6e = b6e(lV()), S6e = dp();
  function cV(e, t) {
    return (0, v6e.default)(e, t);
  }
  s(cV, "getOuterHTML");
  Fs.getOuterHTML = cV;
  function T6e(e, t) {
    return (0, Bo.hasChildren)(e) ? e.children.map(function(r) {
      return cV(r, t);
    }).join("") : "";
  }
  s(T6e, "getInnerHTML");
  Fs.getInnerHTML = T6e;
  function cb(e) {
    return Array.isArray(e) ? e.map(cb).join("") : (0, Bo.isTag)(e) ? e.name === "br" ? `
` : cb(e.children) : (0, Bo.isCDATA)(e) ? cb(e.children) : (0, Bo.isText)(e) ? e.data : "";
  }
  s(cb, "getText");
  Fs.getText = cb;
  function gD(e) {
    return Array.isArray(e) ? e.map(gD).join("") : (0, Bo.hasChildren)(e) && !(0, Bo.isComment)(e) ? gD(e.children) : (0, Bo.isText)(e) ? e.
    data : "";
  }
  s(gD, "textContent");
  Fs.textContent = gD;
  function _D(e) {
    return Array.isArray(e) ? e.map(_D).join("") : (0, Bo.hasChildren)(e) && (e.type === S6e.ElementType.Tag || (0, Bo.isCDATA)(e)) ? _D(e.children) :
    (0, Bo.isText)(e) ? e.data : "";
  }
  s(_D, "innerText");
  Fs.innerText = _D;
});

// ../node_modules/domutils/lib/traversal.js
var dV = b((Tn) => {
  "use strict";
  Object.defineProperty(Tn, "__esModule", { value: !0 });
  Tn.prevElementSibling = Tn.nextElementSibling = Tn.getName = Tn.hasAttrib = Tn.getAttributeValue = Tn.getSiblings = Tn.getParent = Tn.getChildren =
  void 0;
  var fV = Cu(), E6e = [];
  function pV(e) {
    var t;
    return (t = e.children) !== null && t !== void 0 ? t : E6e;
  }
  s(pV, "getChildren");
  Tn.getChildren = pV;
  function hV(e) {
    return e.parent || null;
  }
  s(hV, "getParent");
  Tn.getParent = hV;
  function A6e(e) {
    var t, r, i = hV(e);
    if (i != null)
      return pV(i);
    for (var n = [e], a = e.prev, o = e.next; a != null; )
      n.unshift(a), t = a, a = t.prev;
    for (; o != null; )
      n.push(o), r = o, o = r.next;
    return n;
  }
  s(A6e, "getSiblings");
  Tn.getSiblings = A6e;
  function x6e(e, t) {
    var r;
    return (r = e.attribs) === null || r === void 0 ? void 0 : r[t];
  }
  s(x6e, "getAttributeValue");
  Tn.getAttributeValue = x6e;
  function C6e(e, t) {
    return e.attribs != null && Object.prototype.hasOwnProperty.call(e.attribs, t) && e.attribs[t] != null;
  }
  s(C6e, "hasAttrib");
  Tn.hasAttrib = C6e;
  function P6e(e) {
    return e.name;
  }
  s(P6e, "getName");
  Tn.getName = P6e;
  function D6e(e) {
    for (var t, r = e.next; r !== null && !(0, fV.isTag)(r); )
      t = r, r = t.next;
    return r;
  }
  s(D6e, "nextElementSibling");
  Tn.nextElementSibling = D6e;
  function w6e(e) {
    for (var t, r = e.prev; r !== null && !(0, fV.isTag)(r); )
      t = r, r = t.prev;
    return r;
  }
  s(w6e, "prevElementSibling");
  Tn.prevElementSibling = w6e;
});

// ../node_modules/domutils/lib/manipulation.js
var mV = b((Ms) => {
  "use strict";
  Object.defineProperty(Ms, "__esModule", { value: !0 });
  Ms.prepend = Ms.prependChild = Ms.append = Ms.appendChild = Ms.replaceElement = Ms.removeElement = void 0;
  function Hd(e) {
    if (e.prev && (e.prev.next = e.next), e.next && (e.next.prev = e.prev), e.parent) {
      var t = e.parent.children;
      t.splice(t.lastIndexOf(e), 1);
    }
  }
  s(Hd, "removeElement");
  Ms.removeElement = Hd;
  function O6e(e, t) {
    var r = t.prev = e.prev;
    r && (r.next = t);
    var i = t.next = e.next;
    i && (i.prev = t);
    var n = t.parent = e.parent;
    if (n) {
      var a = n.children;
      a[a.lastIndexOf(e)] = t;
    }
  }
  s(O6e, "replaceElement");
  Ms.replaceElement = O6e;
  function k6e(e, t) {
    if (Hd(t), t.next = null, t.parent = e, e.children.push(t) > 1) {
      var r = e.children[e.children.length - 2];
      r.next = t, t.prev = r;
    } else
      t.prev = null;
  }
  s(k6e, "appendChild");
  Ms.appendChild = k6e;
  function I6e(e, t) {
    Hd(t);
    var r = e.parent, i = e.next;
    if (t.next = i, t.prev = e, e.next = t, t.parent = r, i) {
      if (i.prev = t, r) {
        var n = r.children;
        n.splice(n.lastIndexOf(i), 0, t);
      }
    } else r && r.children.push(t);
  }
  s(I6e, "append");
  Ms.append = I6e;
  function R6e(e, t) {
    if (Hd(t), t.parent = e, t.prev = null, e.children.unshift(t) !== 1) {
      var r = e.children[1];
      r.prev = t, t.next = r;
    } else
      t.next = null;
  }
  s(R6e, "prependChild");
  Ms.prependChild = R6e;
  function N6e(e, t) {
    Hd(t);
    var r = e.parent;
    if (r) {
      var i = r.children;
      i.splice(i.indexOf(e), 0, t);
    }
    e.prev && (e.prev.next = t), t.parent = r, t.prev = e.prev, t.next = e, e.prev = t;
  }
  s(N6e, "prepend");
  Ms.prepend = N6e;
});

// ../node_modules/domutils/lib/querying.js
var SD = b((Bs) => {
  "use strict";
  Object.defineProperty(Bs, "__esModule", { value: !0 });
  Bs.findAll = Bs.existsOne = Bs.findOne = Bs.findOneChild = Bs.find = Bs.filter = void 0;
  var zd = Cu();
  function L6e(e, t, r, i) {
    return r === void 0 && (r = !0), i === void 0 && (i = 1 / 0), Array.isArray(t) || (t = [t]), vD(e, t, r, i);
  }
  s(L6e, "filter");
  Bs.filter = L6e;
  function vD(e, t, r, i) {
    for (var n = [], a = 0, o = t; a < o.length; a++) {
      var u = o[a];
      if (e(u) && (n.push(u), --i <= 0))
        break;
      if (r && (0, zd.hasChildren)(u) && u.children.length > 0) {
        var l = vD(e, u.children, r, i);
        if (n.push.apply(n, l), i -= l.length, i <= 0)
          break;
      }
    }
    return n;
  }
  s(vD, "find");
  Bs.find = vD;
  function F6e(e, t) {
    return t.find(e);
  }
  s(F6e, "findOneChild");
  Bs.findOneChild = F6e;
  function yV(e, t, r) {
    r === void 0 && (r = !0);
    for (var i = null, n = 0; n < t.length && !i; n++) {
      var a = t[n];
      if ((0, zd.isTag)(a))
        e(a) ? i = a : r && a.children.length > 0 && (i = yV(e, a.children));
      else continue;
    }
    return i;
  }
  s(yV, "findOne");
  Bs.findOne = yV;
  function gV(e, t) {
    return t.some(function(r) {
      return (0, zd.isTag)(r) && (e(r) || r.children.length > 0 && gV(e, r.children));
    });
  }
  s(gV, "existsOne");
  Bs.existsOne = gV;
  function M6e(e, t) {
    for (var r, i = [], n = t.filter(zd.isTag), a; a = n.shift(); ) {
      var o = (r = a.children) === null || r === void 0 ? void 0 : r.filter(zd.isTag);
      o && o.length > 0 && n.unshift.apply(n, o), e(a) && i.push(a);
    }
    return i;
  }
  s(M6e, "findAll");
  Bs.findAll = M6e;
});

// ../node_modules/domutils/lib/legacy.js
var TD = b((Ca) => {
  "use strict";
  Object.defineProperty(Ca, "__esModule", { value: !0 });
  Ca.getElementsByTagType = Ca.getElementsByTagName = Ca.getElementById = Ca.getElements = Ca.testElement = void 0;
  var bc = Cu(), pb = SD(), fb = {
    tag_name: /* @__PURE__ */ s(function(e) {
      return typeof e == "function" ? function(t) {
        return (0, bc.isTag)(t) && e(t.name);
      } : e === "*" ? bc.isTag : function(t) {
        return (0, bc.isTag)(t) && t.name === e;
      };
    }, "tag_name"),
    tag_type: /* @__PURE__ */ s(function(e) {
      return typeof e == "function" ? function(t) {
        return e(t.type);
      } : function(t) {
        return t.type === e;
      };
    }, "tag_type"),
    tag_contains: /* @__PURE__ */ s(function(e) {
      return typeof e == "function" ? function(t) {
        return (0, bc.isText)(t) && e(t.data);
      } : function(t) {
        return (0, bc.isText)(t) && t.data === e;
      };
    }, "tag_contains")
  };
  function _V(e, t) {
    return typeof t == "function" ? function(r) {
      return (0, bc.isTag)(r) && t(r.attribs[e]);
    } : function(r) {
      return (0, bc.isTag)(r) && r.attribs[e] === t;
    };
  }
  s(_V, "getAttribCheck");
  function B6e(e, t) {
    return function(r) {
      return e(r) || t(r);
    };
  }
  s(B6e, "combineFuncs");
  function bV(e) {
    var t = Object.keys(e).map(function(r) {
      var i = e[r];
      return Object.prototype.hasOwnProperty.call(fb, r) ? fb[r](i) : _V(r, i);
    });
    return t.length === 0 ? null : t.reduce(B6e);
  }
  s(bV, "compileTest");
  function q6e(e, t) {
    var r = bV(e);
    return r ? r(t) : !0;
  }
  s(q6e, "testElement");
  Ca.testElement = q6e;
  function U6e(e, t, r, i) {
    i === void 0 && (i = 1 / 0);
    var n = bV(e);
    return n ? (0, pb.filter)(n, t, r, i) : [];
  }
  s(U6e, "getElements");
  Ca.getElements = U6e;
  function j6e(e, t, r) {
    return r === void 0 && (r = !0), Array.isArray(t) || (t = [t]), (0, pb.findOne)(_V("id", e), t, r);
  }
  s(j6e, "getElementById");
  Ca.getElementById = j6e;
  function V6e(e, t, r, i) {
    return r === void 0 && (r = !0), i === void 0 && (i = 1 / 0), (0, pb.filter)(fb.tag_name(e), t, r, i);
  }
  s(V6e, "getElementsByTagName");
  Ca.getElementsByTagName = V6e;
  function K6e(e, t, r, i) {
    return r === void 0 && (r = !0), i === void 0 && (i = 1 / 0), (0, pb.filter)(fb.tag_type(e), t, r, i);
  }
  s(K6e, "getElementsByTagType");
  Ca.getElementsByTagType = K6e;
});

// ../node_modules/domutils/lib/helpers.js
var TV = b((vl) => {
  "use strict";
  Object.defineProperty(vl, "__esModule", { value: !0 });
  vl.uniqueSort = vl.compareDocumentPosition = vl.removeSubsets = void 0;
  var vV = Cu();
  function H6e(e) {
    for (var t = e.length; --t >= 0; ) {
      var r = e[t];
      if (t > 0 && e.lastIndexOf(r, t - 1) >= 0) {
        e.splice(t, 1);
        continue;
      }
      for (var i = r.parent; i; i = i.parent)
        if (e.includes(i)) {
          e.splice(t, 1);
          break;
        }
    }
    return e;
  }
  s(H6e, "removeSubsets");
  vl.removeSubsets = H6e;
  function SV(e, t) {
    var r = [], i = [];
    if (e === t)
      return 0;
    for (var n = (0, vV.hasChildren)(e) ? e : e.parent; n; )
      r.unshift(n), n = n.parent;
    for (n = (0, vV.hasChildren)(t) ? t : t.parent; n; )
      i.unshift(n), n = n.parent;
    for (var a = Math.min(r.length, i.length), o = 0; o < a && r[o] === i[o]; )
      o++;
    if (o === 0)
      return 1;
    var u = r[o - 1], l = u.children, c = r[o], p = i[o];
    return l.indexOf(c) > l.indexOf(p) ? u === t ? 20 : 4 : u === e ? 10 : 2;
  }
  s(SV, "compareDocumentPosition");
  vl.compareDocumentPosition = SV;
  function z6e(e) {
    return e = e.filter(function(t, r, i) {
      return !i.includes(t, r + 1);
    }), e.sort(function(t, r) {
      var i = SV(t, r);
      return i & 2 ? -1 : i & 4 ? 1 : 0;
    }), e;
  }
  s(z6e, "uniqueSort");
  vl.uniqueSort = z6e;
});

// ../node_modules/domutils/lib/feeds.js
var AV = b((db) => {
  "use strict";
  Object.defineProperty(db, "__esModule", { value: !0 });
  db.getFeed = void 0;
  var G6e = bD(), Gd = TD();
  function W6e(e) {
    var t = hb(Q6e, e);
    return t ? t.name === "feed" ? $6e(t) : X6e(t) : null;
  }
  s(W6e, "getFeed");
  db.getFeed = W6e;
  function $6e(e) {
    var t, r = e.children, i = {
      type: "atom",
      items: (0, Gd.getElementsByTagName)("entry", r).map(function(o) {
        var u, l = o.children, c = { media: EV(l) };
        qs(c, "id", "id", l), qs(c, "title", "title", l);
        var p = (u = hb("link", l)) === null || u === void 0 ? void 0 : u.attribs.href;
        p && (c.link = p);
        var h = vc("summary", l) || vc("content", l);
        h && (c.description = h);
        var y = vc("updated", l);
        return y && (c.pubDate = new Date(y)), c;
      })
    };
    qs(i, "id", "id", r), qs(i, "title", "title", r);
    var n = (t = hb("link", r)) === null || t === void 0 ? void 0 : t.attribs.href;
    n && (i.link = n), qs(i, "description", "subtitle", r);
    var a = vc("updated", r);
    return a && (i.updated = new Date(a)), qs(i, "author", "email", r, !0), i;
  }
  s($6e, "getAtomFeed");
  function X6e(e) {
    var t, r, i = (r = (t = hb("channel", e.children)) === null || t === void 0 ? void 0 : t.children) !== null && r !== void 0 ? r : [], n = {
      type: e.name.substr(0, 3),
      id: "",
      items: (0, Gd.getElementsByTagName)("item", e.children).map(function(o) {
        var u = o.children, l = { media: EV(u) };
        qs(l, "id", "guid", u), qs(l, "title", "title", u), qs(l, "link", "link", u), qs(l, "description", "description", u);
        var c = vc("pubDate", u);
        return c && (l.pubDate = new Date(c)), l;
      })
    };
    qs(n, "title", "title", i), qs(n, "link", "link", i), qs(n, "description", "description", i);
    var a = vc("lastBuildDate", i);
    return a && (n.updated = new Date(a)), qs(n, "author", "managingEditor", i, !0), n;
  }
  s(X6e, "getRssFeed");
  var Y6e = ["url", "type", "lang"], J6e = [
    "fileSize",
    "bitrate",
    "framerate",
    "samplingrate",
    "channels",
    "duration",
    "height",
    "width"
  ];
  function EV(e) {
    return (0, Gd.getElementsByTagName)("media:content", e).map(function(t) {
      for (var r = t.attribs, i = {
        medium: r.medium,
        isDefault: !!r.isDefault
      }, n = 0, a = Y6e; n < a.length; n++) {
        var o = a[n];
        r[o] && (i[o] = r[o]);
      }
      for (var u = 0, l = J6e; u < l.length; u++) {
        var o = l[u];
        r[o] && (i[o] = parseInt(r[o], 10));
      }
      return r.expression && (i.expression = r.expression), i;
    });
  }
  s(EV, "getMediaElements");
  function hb(e, t) {
    return (0, Gd.getElementsByTagName)(e, t, !0, 1)[0];
  }
  s(hb, "getOneElement");
  function vc(e, t, r) {
    return r === void 0 && (r = !1), (0, G6e.textContent)((0, Gd.getElementsByTagName)(e, t, r, 1)).trim();
  }
  s(vc, "fetch");
  function qs(e, t, r, i, n) {
    n === void 0 && (n = !1);
    var a = vc(r, i, n);
    a && (e[t] = a);
  }
  s(qs, "addConditionally");
  function Q6e(e) {
    return e === "rss" || e === "feed" || e === "rdf:RDF";
  }
  s(Q6e, "isValidFeed");
});

// ../node_modules/domutils/lib/index.js
var mb = b((si) => {
  "use strict";
  var Z6e = si && si.__createBinding || (Object.create ? function(e, t, r, i) {
    i === void 0 && (i = r), Object.defineProperty(e, i, { enumerable: !0, get: /* @__PURE__ */ s(function() {
      return t[r];
    }, "get") });
  } : function(e, t, r, i) {
    i === void 0 && (i = r), e[i] = t[r];
  }), Sc = si && si.__exportStar || function(e, t) {
    for (var r in e) r !== "default" && !Object.prototype.hasOwnProperty.call(t, r) && Z6e(t, e, r);
  };
  Object.defineProperty(si, "__esModule", { value: !0 });
  si.hasChildren = si.isDocument = si.isComment = si.isText = si.isCDATA = si.isTag = void 0;
  Sc(bD(), si);
  Sc(dV(), si);
  Sc(mV(), si);
  Sc(SD(), si);
  Sc(TD(), si);
  Sc(TV(), si);
  Sc(AV(), si);
  var gp = Cu();
  Object.defineProperty(si, "isTag", { enumerable: !0, get: /* @__PURE__ */ s(function() {
    return gp.isTag;
  }, "get") });
  Object.defineProperty(si, "isCDATA", { enumerable: !0, get: /* @__PURE__ */ s(function() {
    return gp.isCDATA;
  }, "get") });
  Object.defineProperty(si, "isText", { enumerable: !0, get: /* @__PURE__ */ s(function() {
    return gp.isText;
  }, "get") });
  Object.defineProperty(si, "isComment", { enumerable: !0, get: /* @__PURE__ */ s(function() {
    return gp.isComment;
  }, "get") });
  Object.defineProperty(si, "isDocument", { enumerable: !0, get: /* @__PURE__ */ s(function() {
    return gp.isDocument;
  }, "get") });
  Object.defineProperty(si, "hasChildren", { enumerable: !0, get: /* @__PURE__ */ s(function() {
    return gp.hasChildren;
  }, "get") });
});

// ../node_modules/renderkid/node_modules/htmlparser2/lib/FeedHandler.js
var AD = b((Yn) => {
  "use strict";
  var eUe = Yn && Yn.__extends || /* @__PURE__ */ function() {
    var e = /* @__PURE__ */ s(function(t, r) {
      return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, n) {
        i.__proto__ = n;
      } || function(i, n) {
        for (var a in n) Object.prototype.hasOwnProperty.call(n, a) && (i[a] = n[a]);
      }, e(t, r);
    }, "extendStatics");
    return function(t, r) {
      if (typeof r != "function" && r !== null)
        throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
      e(t, r);
      function i() {
        this.constructor = t;
      }
      s(i, "__"), t.prototype = r === null ? Object.create(r) : (i.prototype = r.prototype, new i());
    };
  }(), tUe = Yn && Yn.__createBinding || (Object.create ? function(e, t, r, i) {
    i === void 0 && (i = r), Object.defineProperty(e, i, { enumerable: !0, get: /* @__PURE__ */ s(function() {
      return t[r];
    }, "get") });
  } : function(e, t, r, i) {
    i === void 0 && (i = r), e[i] = t[r];
  }), rUe = Yn && Yn.__setModuleDefault || (Object.create ? function(e, t) {
    Object.defineProperty(e, "default", { enumerable: !0, value: t });
  } : function(e, t) {
    e.default = t;
  }), iUe = Yn && Yn.__importStar || function(e) {
    if (e && e.__esModule) return e;
    var t = {};
    if (e != null) for (var r in e) r !== "default" && Object.prototype.hasOwnProperty.call(e, r) && tUe(t, e, r);
    return rUe(t, e), t;
  }, nUe = Yn && Yn.__importDefault || function(e) {
    return e && e.__esModule ? e : { default: e };
  };
  Object.defineProperty(Yn, "__esModule", { value: !0 });
  Yn.parseFeed = Yn.FeedHandler = void 0;
  var sUe = nUe(Cu()), gb = iUe(mb()), aUe = oD(), xV;
  (function(e) {
    e[e.image = 0] = "image", e[e.audio = 1] = "audio", e[e.video = 2] = "video", e[e.document = 3] = "document", e[e.executable = 4] = "exe\
cutable";
  })(xV || (xV = {}));
  var CV;
  (function(e) {
    e[e.sample = 0] = "sample", e[e.full = 1] = "full", e[e.nonstop = 2] = "nonstop";
  })(CV || (CV = {}));
  var wV = (
    /** @class */
    function(e) {
      eUe(t, e);
      function t(r, i) {
        var n = this;
        return typeof r == "object" && (r = void 0, i = r), n = e.call(this, r, i) || this, n;
      }
      return s(t, "FeedHandler"), t.prototype.onend = function() {
        var r, i, n = yb(oUe, this.dom);
        if (!n) {
          this.handleCallback(new Error("couldn't find root of feed"));
          return;
        }
        var a = {};
        if (n.name === "feed") {
          var o = n.children;
          a.type = "atom", Us(a, "id", "id", o), Us(a, "title", "title", o);
          var u = DV("href", yb("link", o));
          u && (a.link = u), Us(a, "description", "subtitle", o);
          var l = Tc("updated", o);
          l && (a.updated = new Date(l)), Us(a, "author", "email", o, !0), a.items = ED("entry", o).map(function(c) {
            var p = {}, h = c.children;
            Us(p, "id", "id", h), Us(p, "title", "title", h);
            var y = DV("href", yb("link", h));
            y && (p.link = y);
            var _ = Tc("summary", h) || Tc("content", h);
            _ && (p.description = _);
            var g = Tc("updated", h);
            return g && (p.pubDate = new Date(g)), p.media = PV(h), p;
          });
        } else {
          var o = (i = (r = yb("channel", n.children)) === null || r === void 0 ? void 0 : r.children) !== null && i !== void 0 ? i : [];
          a.type = n.name.substr(0, 3), a.id = "", Us(a, "title", "title", o), Us(a, "link", "link", o), Us(a, "description", "description",
          o);
          var l = Tc("lastBuildDate", o);
          l && (a.updated = new Date(l)), Us(a, "author", "managingEditor", o, !0), a.items = ED("item", n.children).map(function(h) {
            var y = {}, _ = h.children;
            Us(y, "id", "guid", _), Us(y, "title", "title", _), Us(y, "link", "link", _), Us(y, "description", "description", _);
            var g = Tc("pubDate", _);
            return g && (y.pubDate = new Date(g)), y.media = PV(_), y;
          });
        }
        this.feed = a, this.handleCallback(null);
      }, t;
    }(sUe.default)
  );
  Yn.FeedHandler = wV;
  function PV(e) {
    return ED("media:content", e).map(function(t) {
      var r = {
        medium: t.attribs.medium,
        isDefault: !!t.attribs.isDefault
      };
      return t.attribs.url && (r.url = t.attribs.url), t.attribs.fileSize && (r.fileSize = parseInt(t.attribs.fileSize, 10)), t.attribs.type &&
      (r.type = t.attribs.type), t.attribs.expression && (r.expression = t.attribs.expression), t.attribs.bitrate && (r.bitrate = parseInt(t.
      attribs.bitrate, 10)), t.attribs.framerate && (r.framerate = parseInt(t.attribs.framerate, 10)), t.attribs.samplingrate && (r.samplingrate =
      parseInt(t.attribs.samplingrate, 10)), t.attribs.channels && (r.channels = parseInt(t.attribs.channels, 10)), t.attribs.duration && (r.
      duration = parseInt(t.attribs.duration, 10)), t.attribs.height && (r.height = parseInt(t.attribs.height, 10)), t.attribs.width && (r.width =
      parseInt(t.attribs.width, 10)), t.attribs.lang && (r.lang = t.attribs.lang), r;
    });
  }
  s(PV, "getMediaElements");
  function ED(e, t) {
    return gb.getElementsByTagName(e, t, !0);
  }
  s(ED, "getElements");
  function yb(e, t) {
    return gb.getElementsByTagName(e, t, !0, 1)[0];
  }
  s(yb, "getOneElement");
  function Tc(e, t, r) {
    return r === void 0 && (r = !1), gb.getText(gb.getElementsByTagName(e, t, r, 1)).trim();
  }
  s(Tc, "fetch");
  function DV(e, t) {
    if (!t)
      return null;
    var r = t.attribs;
    return r[e];
  }
  s(DV, "getAttribute");
  function Us(e, t, r, i, n) {
    n === void 0 && (n = !1);
    var a = Tc(r, i, n);
    a && (e[t] = a);
  }
  s(Us, "addConditionally");
  function oUe(e) {
    return e === "rss" || e === "feed" || e === "rdf:RDF";
  }
  s(oUe, "isValidFeed");
  function uUe(e, t) {
    t === void 0 && (t = { xmlMode: !0 });
    var r = new wV(t);
    return new aUe.Parser(r, t).end(e), r.feed;
  }
  s(uUe, "parseFeed");
  Yn.parseFeed = uUe;
});

// ../node_modules/renderkid/node_modules/htmlparser2/lib/index.js
var RV = b((Sr) => {
  "use strict";
  var OV = Sr && Sr.__createBinding || (Object.create ? function(e, t, r, i) {
    i === void 0 && (i = r), Object.defineProperty(e, i, { enumerable: !0, get: /* @__PURE__ */ s(function() {
      return t[r];
    }, "get") });
  } : function(e, t, r, i) {
    i === void 0 && (i = r), e[i] = t[r];
  }), lUe = Sr && Sr.__setModuleDefault || (Object.create ? function(e, t) {
    Object.defineProperty(e, "default", { enumerable: !0, value: t });
  } : function(e, t) {
    e.default = t;
  }), kV = Sr && Sr.__importStar || function(e) {
    if (e && e.__esModule) return e;
    var t = {};
    if (e != null) for (var r in e) r !== "default" && Object.prototype.hasOwnProperty.call(e, r) && OV(t, e, r);
    return lUe(t, e), t;
  }, cUe = Sr && Sr.__exportStar || function(e, t) {
    for (var r in e) r !== "default" && !Object.prototype.hasOwnProperty.call(t, r) && OV(t, e, r);
  }, fUe = Sr && Sr.__importDefault || function(e) {
    return e && e.__esModule ? e : { default: e };
  };
  Object.defineProperty(Sr, "__esModule", { value: !0 });
  Sr.RssHandler = Sr.DefaultHandler = Sr.DomUtils = Sr.ElementType = Sr.Tokenizer = Sr.createDomStream = Sr.parseDOM = Sr.parseDocument = Sr.
  DomHandler = Sr.Parser = void 0;
  var xD = oD();
  Object.defineProperty(Sr, "Parser", { enumerable: !0, get: /* @__PURE__ */ s(function() {
    return xD.Parser;
  }, "get") });
  var _b = Cu();
  Object.defineProperty(Sr, "DomHandler", { enumerable: !0, get: /* @__PURE__ */ s(function() {
    return _b.DomHandler;
  }, "get") });
  Object.defineProperty(Sr, "DefaultHandler", { enumerable: !0, get: /* @__PURE__ */ s(function() {
    return _b.DomHandler;
  }, "get") });
  function IV(e, t) {
    var r = new _b.DomHandler(void 0, t);
    return new xD.Parser(r, t).end(e), r.root;
  }
  s(IV, "parseDocument");
  Sr.parseDocument = IV;
  function pUe(e, t) {
    return IV(e, t).children;
  }
  s(pUe, "parseDOM");
  Sr.parseDOM = pUe;
  function hUe(e, t, r) {
    var i = new _b.DomHandler(e, t, r);
    return new xD.Parser(i, t);
  }
  s(hUe, "createDomStream");
  Sr.createDomStream = hUe;
  var dUe = sD();
  Object.defineProperty(Sr, "Tokenizer", { enumerable: !0, get: /* @__PURE__ */ s(function() {
    return fUe(dUe).default;
  }, "get") });
  var mUe = kV(dp());
  Sr.ElementType = mUe;
  cUe(AD(), Sr);
  Sr.DomUtils = kV(mb());
  var yUe = AD();
  Object.defineProperty(Sr, "RssHandler", { enumerable: !0, get: /* @__PURE__ */ s(function() {
    return yUe.FeedHandler;
  }, "get") });
});

// ../node_modules/utila/lib/array.js
var CD = b((_wt, NV) => {
  var gUe;
  NV.exports = gUe = {
    /*
    	Tries to turn anything into an array.
    */
    from: /* @__PURE__ */ s(function(e) {
      return Array.prototype.slice.call(e);
    }, "from"),
    /*
    	Clone of an array. Properties will be shallow copies.
    */
    simpleClone: /* @__PURE__ */ s(function(e) {
      return e.slice(0);
    }, "simpleClone"),
    shallowEqual: /* @__PURE__ */ s(function(e, t) {
      var r, i, n, a;
      if (!(Array.isArray(e) && Array.isArray(t) && e.length === t.length))
        return !1;
      for (r = n = 0, a = e.length; n < a; r = ++n)
        if (i = e[r], t[r] !== i)
          return !1;
      return !0;
    }, "shallowEqual"),
    pluck: /* @__PURE__ */ s(function(e, t) {
      var r, i, n, a;
      if (e.length < 1)
        return e;
      for (r = n = 0, a = e.length; n < a; r = ++n)
        i = e[r], r > t && (e[r - 1] = e[r]);
      return e.length = e.length - 1, e;
    }, "pluck"),
    pluckItem: /* @__PURE__ */ s(function(e, t) {
      var r, i, n, a, o;
      if (e.length < 1)
        return e;
      for (i = 0, r = a = 0, o = e.length; a < o; r = ++a) {
        if (n = e[r], n === t) {
          i++;
          continue;
        }
        i !== 0 && (e[r - i] = e[r]);
      }
      return i > 0 && (e.length = e.length - i), e;
    }, "pluckItem"),
    pluckOneItem: /* @__PURE__ */ s(function(e, t) {
      var r, i, n, a, o;
      if (e.length < 1)
        return e;
      for (i = !1, r = a = 0, o = e.length; a < o; r = ++a)
        if (n = e[r], i)
          e[r - 1] = e[r];
        else if (n === t) {
          i = !0;
          continue;
        }
      return i && (e.length = e.length - 1), e;
    }, "pluckOneItem"),
    pluckByCallback: /* @__PURE__ */ s(function(e, t) {
      var r, i, n, a, o;
      if (e.length < 1)
        return e;
      for (i = 0, r = a = 0, o = e.length; a < o; r = ++a) {
        if (n = e[r], t(n, r)) {
          i++;
          continue;
        }
        i !== 0 && (e[r - i] = e[r]);
      }
      return i > 0 && (e.length = e.length - i), e;
    }, "pluckByCallback"),
    pluckMultiple: /* @__PURE__ */ s(function(e, t) {
      var r, i, n, a;
      if (e.length < 1)
        return e;
      for (i = 0, t.sort(), n = 0, a = t.length; n < a; n++)
        r = t[n], this.pluck(e, r - i), i++;
      return e;
    }, "pluckMultiple"),
    injectByCallback: /* @__PURE__ */ s(function(e, t, r) {
      var i, n, a, o, u, l, c;
      if (o = null, u = null, n = e.length, n < 1)
        return e.push(t), e;
      for (i = l = 0, c = e.length; l < c; i = ++l)
        if (a = e[i], o = u, u = a, r(o, u, t))
          return e.splice(i, 0, t);
      return e.push(t), e;
    }, "injectByCallback"),
    injectInIndex: /* @__PURE__ */ s(function(e, t, r) {
      var i, n, a, o;
      if (n = e.length, i = t, n < 1)
        return e.push(r), e;
      for (a = r, o = null; i <= n; i++)
        o = e[i], e[i] = a, a = o;
      return null;
    }, "injectInIndex")
  };
});

// ../node_modules/utila/lib/classic.js
var MV = b((vwt, FV) => {
  var PD, LV = [].slice;
  FV.exports = PD = {};
  PD.implement = function() {
    var e, t, r, i, n, a, o, u, l;
    for (a = 2 <= arguments.length ? LV.call(arguments, 0, o = arguments.length - 1) : (o = 0, []), t = arguments[o++], u = 0, l = a.length; u <
    l; u++) {
      n = a[u], e = t.prototype;
      for (i in n.prototype)
        Object.getOwnPropertyDescriptor(e, i) || (r = Object.getOwnPropertyDescriptor(n.prototype, i), Object.defineProperty(e, i, r));
    }
    return t;
  };
  PD.mix = function() {
    var e, t, r, i, n, a, o, u, l;
    for (a = 2 <= arguments.length ? LV.call(arguments, 0, o = arguments.length - 1) : (o = 0, []), t = arguments[o++], e = t.prototype, t.__mixinCloners =
    [], t.__applyClonersFor = function(c, p) {
      var h, y, _, g;
      for (p == null && (p = null), g = t.__mixinCloners, y = 0, _ = g.length; y < _; y++)
        h = g[y], h.apply(c, p);
    }, t.__mixinInitializers = [], t.__initMixinsFor = function(c, p) {
      var h, y, _, g;
      for (p == null && (p = null), g = t.__mixinInitializers, y = 0, _ = g.length; y < _; y++)
        h = g[y], h.apply(c, p);
    }, t.__mixinQuitters = [], t.__applyQuittersFor = function(c, p) {
      var h, y, _, g;
      for (p == null && (p = null), g = t.__mixinQuitters, y = 0, _ = g.length; y < _; y++)
        h = g[y], h.apply(c, p);
    }, u = 0, l = a.length; u < l; u++) {
      if (n = a[u], !(n.constructor instanceof Function))
        throw Error("Mixin should be a function");
      for (i in n.prototype) {
        if (i.substr(0, 11) === "__initMixin") {
          t.__mixinInitializers.push(n.prototype[i]);
          continue;
        } else if (i.substr(0, 11) === "__clonerFor") {
          t.__mixinCloners.push(n.prototype[i]);
          continue;
        } else if (i.substr(0, 12) === "__quitterFor") {
          t.__mixinQuitters.push(n.prototype[i]);
          continue;
        }
        Object.getOwnPropertyDescriptor(e, i) || (r = Object.getOwnPropertyDescriptor(n.prototype, i), Object.defineProperty(e, i, r));
      }
    }
    return t;
  };
});

// ../node_modules/utila/lib/_common.js
var qV = b((Swt, BV) => {
  var Sl;
  BV.exports = Sl = {
    /*
    	Checks to see if o is an object, and it isn't an instance
    	of some class.
    */
    isBareObject: /* @__PURE__ */ s(function(e) {
      return e != null && e.constructor === Object;
    }, "isBareObject"),
    /*
    	Returns type of an object, including:
    	undefined, null, string, number, array,
    	arguments, element, textnode, whitespace, and object
    */
    typeOf: /* @__PURE__ */ s(function(e) {
      var t;
      if (e === null)
        return "null";
      if (typeof e != "object")
        return typeof e;
      if (Array.isArray(e))
        return "array";
      if (e.nodeName) {
        if (e.nodeType === 1)
          return "element";
        if (e.nodeType === 3)
          return (t = /\S/.test(e.nodeValue)) != null ? t : {
            textnode: "whitespace"
          };
      } else if (typeof e.length == "number" && e.callee)
        return "arguments";
      return typeof e;
    }, "typeOf"),
    clone: /* @__PURE__ */ s(function(e, t) {
      switch (t == null && (t = !1), Sl.typeOf(e)) {
        case "array":
          return Sl._cloneArray(e, t);
        case "object":
          return Sl._cloneObject(e, t);
        default:
          return e;
      }
    }, "clone"),
    /*
    	Deep clone of an object.
    	From MooTools
    */
    _cloneObject: /* @__PURE__ */ s(function(e, t) {
      var r, i;
      if (t == null && (t = !1), Sl.isBareObject(e)) {
        r = {};
        for (i in e)
          r[i] = Sl.clone(e[i], t);
        return r;
      } else {
        if (!t || e instanceof Function)
          return e;
        r = Object.create(e.constructor.prototype);
        for (i in e)
          e.hasOwnProperty(i) && (r[i] = Sl.clone(e[i], t));
        return r;
      }
    }, "_cloneObject"),
    /*
    	Deep clone of an array.
    	From MooTools
    */
    _cloneArray: /* @__PURE__ */ s(function(e, t) {
      var r, i;
      for (t == null && (t = !1), i = e.length, r = new Array(i); i--; )
        r[i] = Sl.clone(e[i], t);
      return r;
    }, "_cloneArray")
  };
});

// ../node_modules/utila/lib/object.js
var jV = b((Ewt, UV) => {
  var _Ue, Ec, bUe = {}.hasOwnProperty;
  Ec = qV();
  UV.exports = _Ue = {
    isBareObject: Ec.isBareObject.bind(Ec),
    /*
    	if object is an instance of a class
    */
    isInstance: /* @__PURE__ */ s(function(e) {
      return !this.isBareObject(e);
    }, "isInstance"),
    /*
    	Alias to _common.typeOf
    */
    typeOf: Ec.typeOf.bind(Ec),
    /*
    	Alias to _common.clone
    */
    clone: Ec.clone.bind(Ec),
    /*
    	Empties an object of its properties.
    */
    empty: /* @__PURE__ */ s(function(e) {
      var t;
      for (t in e)
        e.hasOwnProperty(t) && delete e[t];
      return e;
    }, "empty"),
    /*
    	Empties an object. Doesn't check for hasOwnProperty, so it's a tiny
    	bit faster. Use it for plain objects.
    */
    fastEmpty: /* @__PURE__ */ s(function(e) {
      var t;
      for (t in e)
        delete e[t];
      return e;
    }, "fastEmpty"),
    /*
    	Overrides values fomr `newValues` on `base`, as long as they
    	already exist in base.
    */
    overrideOnto: /* @__PURE__ */ s(function(e, t) {
      var r, i, n;
      if (!this.isBareObject(t) || !this.isBareObject(e))
        return e;
      for (r in e)
        n = e[r], i = t[r], i !== void 0 && (typeof i != "object" || this.isInstance(i) ? e[r] = this.clone(i) : typeof n != "object" || this.
        isInstance(n) ? e[r] = this.clone(i) : this.overrideOnto(n, i));
      return e;
    }, "overrideOnto"),
    /*
    	Takes a clone of 'base' and runs #overrideOnto on it
    */
    override: /* @__PURE__ */ s(function(e, t) {
      return this.overrideOnto(this.clone(e), t);
    }, "override"),
    append: /* @__PURE__ */ s(function(e, t) {
      return this.appendOnto(this.clone(e), t);
    }, "append"),
    appendOnto: /* @__PURE__ */ s(function(e, t) {
      var r, i, n;
      if (!this.isBareObject(t) || !this.isBareObject(e))
        return e;
      for (r in t)
        bUe.call(t, r) && (i = t[r], i !== void 0 && (typeof i != "object" || this.isInstance(i) ? e[r] = i : (n = e[r], typeof n != "object" ||
        this.isInstance(n) ? e[r] = this.clone(i) : this.appendOnto(n, i))));
      return e;
    }, "appendOnto"),
    groupProps: /* @__PURE__ */ s(function(e, t) {
      var r, i, n, a, o, u, l, c, p;
      n = {};
      for (o in t)
        i = t[o], n[o] = {};
      n.rest = {};
      e:
        for (a in e) {
          l = e[a], u = !1;
          for (o in t)
            for (i = t[o], Array.isArray(i) || (i = [i]), c = 0, p = i.length; c < p; c++) {
              if (r = i[c], typeof r == "string")
                a === r && (u = !0);
              else if (r instanceof RegExp)
                r.test(a) && (u = !0);
              else if (r instanceof Function)
                r(a) && (u = !0);
              else
                throw Error("Group definitions must either						be strings, regexes, or functions.");
              if (u) {
                n[o][a] = l;
                continue e;
              }
            }
          n.rest[a] = l;
        }
      return n;
    }, "groupProps")
  };
});

// ../node_modules/utila/lib/string.js
var KV = b((xwt, VV) => {
  VV.exports = {
    pad: /* @__PURE__ */ s(function(e, t, r) {
      return r == null && (r = "0"), e = e + "", e.length >= t ? e : new Array(t - e.length + 1).join(r) + e;
    }, "pad")
  };
});

// ../node_modules/utila/lib/Emitter.js
var GV = b((Pwt, zV) => {
  var vUe, HV;
  HV = CD();
  zV.exports = vUe = function() {
    function e() {
      this._listeners = {}, this._listenersForAnyEvent = [], this._disabledEmitters = {};
    }
    return s(e, "Emitter"), e.prototype.on = function(t, r) {
      return this._listeners[t] == null && (this._listeners[t] = []), this._listeners[t].push(r), this;
    }, e.prototype.once = function(t, r) {
      var i, n, a = this;
      return n = !1, i = /* @__PURE__ */ s(function() {
        if (!n)
          return n = !0, r(), setTimeout(function() {
            return a.removeEvent(t, i);
          }, 0);
      }, "cb"), this.on(t, i), this;
    }, e.prototype.onAnyEvent = function(t) {
      return this._listenersForAnyEvent.push(t), this;
    }, e.prototype.removeEvent = function(t, r) {
      return this._listeners[t] == null ? this : (HV.pluckOneItem(this._listeners[t], r), this);
    }, e.prototype.removeListeners = function(t) {
      return this._listeners[t] == null ? this : (this._listeners[t].length = 0, this);
    }, e.prototype.removeAllListeners = function() {
      var t, r, i;
      i = this._listeners;
      for (r in i)
        t = i[r], t.length = 0;
      return this;
    }, e.prototype._emit = function(t, r) {
      var i, n, a, o, u, l, c;
      for (l = this._listenersForAnyEvent, n = 0, o = l.length; n < o; n++)
        i = l[n], i.call(this, r, t);
      if (this._listeners[t] != null)
        for (c = this._listeners[t], a = 0, u = c.length; a < u; a++)
          i = c[a], i.call(this, r);
    }, e.prototype._throttleEmitterMethod = function(t, r) {
      var i, n, a, o, u, l, c = this;
      if (r == null && (r = 1e3), n = this[t], typeof n != "function")
        throw Error("this class does not have a method called '" + t + "'");
      return i = null, o = !1, l = null, this[t] = function() {
        return i = arguments, a();
      }, a = /* @__PURE__ */ s(function() {
        return o && clearTimeout(l), l = setTimeout(u, r), o = !0;
      }, "pend"), u = /* @__PURE__ */ s(function() {
        return o = !1, n.apply(c, i);
      }, "runIt");
    }, e.prototype._disableEmitter = function(t) {
      if (this._disabledEmitters[t] != null)
        throw Error("" + t + " is already a disabled emitter");
      return this._disabledEmitters[t] = this[t], this[t] = function() {
      };
    }, e.prototype._enableEmitter = function(t) {
      var r;
      if (r = this._disabledEmitters[t], r == null)
        throw Error("" + t + " is not a disabled emitter");
      return this[t] = r, delete this._disabledEmitters[t];
    }, e;
  }();
});

// ../node_modules/utila/lib/utila.js
var DD = b((wwt, WV) => {
  var SUe;
  WV.exports = SUe = {
    array: CD(),
    classic: MV(),
    object: jV(),
    string: KV(),
    Emitter: GV()
  };
});

// ../node_modules/dom-converter/lib/objectToSaneObject.js
var XV = b((Owt, $V) => {
  var wD, Ac, TUe = {}.hasOwnProperty;
  wD = DD().object;
  $V.exports = Ac = {
    sanitize: /* @__PURE__ */ s(function(e) {
      return Ac._toChildren(e);
    }, "sanitize"),
    _toChildren: /* @__PURE__ */ s(function(e) {
      var t;
      if (wD.isBareObject(e))
        return Ac._objectToChildren(e);
      if (Array.isArray(e))
        return Ac._arrayToChildren(e);
      if (e === null || typeof e > "u")
        return [];
      if ((t = typeof e) == "string" || t === "number")
        return [String(e)];
      throw Error("not a valid child node: `" + e);
    }, "_toChildren"),
    _objectToChildren: /* @__PURE__ */ s(function(e) {
      var t, r, i, n;
      t = [];
      for (i in e)
        TUe.call(e, i) && (n = e[i], r = {}, r[i] = Ac.sanitize(n), t.push(r));
      return t;
    }, "_objectToChildren"),
    _arrayToChildren: /* @__PURE__ */ s(function(e) {
      var t, r, i, n;
      for (i = [], t = 0, r = e.length; t < r; t++)
        n = e[t], i.push(Ac._toNode(n));
      return i;
    }, "_arrayToChildren"),
    _toNode: /* @__PURE__ */ s(function(e) {
      var t, r, i, n;
      if ((n = typeof e) == "string" || n === "number")
        return String(e);
      if (wD.isBareObject(e)) {
        if (r = Object.keys(e), r.length !== 1)
          throw Error("a node must only have one key as tag name");
        return t = r[0], i = {}, i[t] = Ac._toChildren(e[t]), i;
      } else
        throw Error("not a valid node: `" + e + "`");
    }, "_toNode")
  };
});

// ../node_modules/dom-converter/lib/saneObjectToDom.js
var JV = b((Iwt, YV) => {
  var qo, EUe = {}.hasOwnProperty;
  YV.exports = qo = {
    convert: /* @__PURE__ */ s(function(e) {
      return qo._arrayToChildren(e);
    }, "convert"),
    _arrayToChildren: /* @__PURE__ */ s(function(e, t) {
      var r, i, n, a, o, u;
      for (t == null && (t = null), r = [], o = null, i = 0, n = e.length; i < n; i++)
        u = e[i], typeof u == "string" ? a = qo._getTextNodeFor(u) : (a = qo._objectToNode(u, t), a.prev = null, a.next = null, a.parent = t,
        o != null && (a.prev = o, o.next = a), o = a), r.push(a);
      return r;
    }, "_arrayToChildren"),
    _objectToNode: /* @__PURE__ */ s(function(e) {
      var t, r, i, n, a, o, u, l, c, p;
      i = 0;
      for (n in e)
        if (EUe.call(e, n)) {
          if (c = e[n], i > 0)
            throw Error("_objectToNode() only accepts an object with one key/value");
          a = n, p = c, i++;
        }
      if (u = {}, typeof a != "string")
        throw Error("_objectToNode()'s key must be a string of tag name and classes");
      if (typeof p == "string")
        r = [qo._getTextNodeFor(p)];
      else if (Array.isArray(p))
        r = qo._arrayToChildren(p, u);
      else
        throw inspect(e), Error("_objectToNode()'s key's value must only be a string or an array");
      return u.type = "tag", l = qo._parseTag(a), o = l.name, t = l.attribs, u.name = o, u.attribs = t, u.children = r, u;
    }, "_objectToNode"),
    _getTextNodeFor: /* @__PURE__ */ s(function(e) {
      return {
        type: "text",
        data: e
      };
    }, "_getTextNodeFor"),
    _nameRx: /^[a-zA-Z\-\_]{1}[a-zA-Z0-9\-\_]*$/,
    _parseTag: /* @__PURE__ */ s(function(e) {
      var t, r, i, n, a, o, u;
      if (!e.match(/^[a-zA-Z0-9\#\-\_\.\[\]\"\'\=\,\s]+$/) || e.match(/^[0-9]+/))
        throw Error("cannot parse tag `" + e + "`");
      if (t = {}, u = {
        name: "",
        attribs: t
      }, a = e.match(/^([^\.#]+)/)) {
        if (o = a[1], !o.match(qo._nameRx))
          throw Error("tag name `" + o + "` is not valid");
        u.name = o, e = e.substr(o.length, e.length);
      }
      if (a = e.match(/^#([a-zA-Z0-9\-]+)/)) {
        if (n = a[1], !n.match(qo._nameRx))
          throw Error("tag id `" + n + "` is not valid");
        t.id = n, e = e.substr(n.length + 1, e.length);
      }
      for (r = []; a = e.match(/\.([a-zA-Z0-9\-\_]+)/); ) {
        if (i = a[1], !i.match(qo._nameRx))
          throw Error("tag class `" + i + "` is not valid");
        r.push(i), e = e.replace("." + i, "");
      }
      return r.length && (t.class = r.join(" ")), u;
    }, "_parseTag")
  };
});

// ../node_modules/dom-converter/lib/domToMarkup.js
var QV = b(() => {
});

// ../node_modules/dom-converter/lib/domConverter.js
var i7 = b((Fwt, r7) => {
  var kD, ZV, e7, t7, OD;
  e7 = XV();
  t7 = JV();
  kD = QV();
  ZV = DD().object;
  r7.exports = OD = {
    objectToDom: /* @__PURE__ */ s(function(e) {
      return e = OD._object2SaneObject(e), t7.convert(e);
    }, "objectToDom"),
    object2markup: /* @__PURE__ */ s(function(e) {
      var t;
      return t = OD.objectToDom(e), kD.convert(t);
    }, "object2markup"),
    domToMarkup: /* @__PURE__ */ s(function(e) {
      return kD.convert(e);
    }, "domToMarkup"),
    _object2SaneObject: /* @__PURE__ */ s(function(e) {
      if (!Array.isArray(e) && !ZV.isBareObject(e))
        throw Error("toDom() only accepts arrays and bare objects as input");
      return e7.sanitize(e);
    }, "_object2SaneObject")
  };
});

// ../node_modules/lodash/_stackClear.js
var s7 = b((Bwt, n7) => {
  var AUe = Md();
  function xUe() {
    this.__data__ = new AUe(), this.size = 0;
  }
  s(xUe, "stackClear");
  n7.exports = xUe;
});

// ../node_modules/lodash/_stackDelete.js
var o7 = b((Uwt, a7) => {
  function CUe(e) {
    var t = this.__data__, r = t.delete(e);
    return this.size = t.size, r;
  }
  s(CUe, "stackDelete");
  a7.exports = CUe;
});

// ../node_modules/lodash/_stackGet.js
var l7 = b((Vwt, u7) => {
  function PUe(e) {
    return this.__data__.get(e);
  }
  s(PUe, "stackGet");
  u7.exports = PUe;
});

// ../node_modules/lodash/_stackHas.js
var f7 = b((Hwt, c7) => {
  function DUe(e) {
    return this.__data__.has(e);
  }
  s(DUe, "stackHas");
  c7.exports = DUe;
});

// ../node_modules/lodash/_stackSet.js
var h7 = b((Gwt, p7) => {
  var wUe = Md(), OUe = Y_(), kUe = zP(), IUe = 200;
  function RUe(e, t) {
    var r = this.__data__;
    if (r instanceof wUe) {
      var i = r.__data__;
      if (!OUe || i.length < IUe - 1)
        return i.push([e, t]), this.size = ++r.size, this;
      r = this.__data__ = new kUe(i);
    }
    return r.set(e, t), this.size = r.size, this;
  }
  s(RUe, "stackSet");
  p7.exports = RUe;
});

// ../node_modules/lodash/_Stack.js
var ID = b(($wt, d7) => {
  var NUe = Md(), LUe = s7(), FUe = o7(), MUe = l7(), BUe = f7(), qUe = h7();
  function _p(e) {
    var t = this.__data__ = new NUe(e);
    this.size = t.size;
  }
  s(_p, "Stack");
  _p.prototype.clear = LUe;
  _p.prototype.delete = FUe;
  _p.prototype.get = MUe;
  _p.prototype.has = BUe;
  _p.prototype.set = qUe;
  d7.exports = _p;
});

// ../node_modules/lodash/_defineProperty.js
var RD = b((Ywt, m7) => {
  var UUe = yl(), jUe = function() {
    try {
      var e = UUe(Object, "defineProperty");
      return e({}, "", {}), e;
    } catch {
    }
  }();
  m7.exports = jUe;
});

// ../node_modules/lodash/_baseAssignValue.js
var bb = b((Jwt, g7) => {
  var y7 = RD();
  function VUe(e, t, r) {
    t == "__proto__" && y7 ? y7(e, t, {
      configurable: !0,
      enumerable: !0,
      value: r,
      writable: !0
    }) : e[t] = r;
  }
  s(VUe, "baseAssignValue");
  g7.exports = VUe;
});

// ../node_modules/lodash/_assignMergeValue.js
var ND = b((Zwt, _7) => {
  var KUe = bb(), HUe = Ld();
  function zUe(e, t, r) {
    (r !== void 0 && !HUe(e[t], r) || r === void 0 && !(t in e)) && KUe(e, t, r);
  }
  s(zUe, "assignMergeValue");
  _7.exports = zUe;
});

// ../node_modules/lodash/_createBaseFor.js
var v7 = b((t2t, b7) => {
  function GUe(e) {
    return function(t, r, i) {
      for (var n = -1, a = Object(t), o = i(t), u = o.length; u--; ) {
        var l = o[e ? u : ++n];
        if (r(a[l], l, a) === !1)
          break;
      }
      return t;
    };
  }
  s(GUe, "createBaseFor");
  b7.exports = GUe;
});

// ../node_modules/lodash/_baseFor.js
var T7 = b((i2t, S7) => {
  var WUe = v7(), $Ue = WUe();
  S7.exports = $Ue;
});

// ../node_modules/lodash/_cloneBuffer.js
var LD = b((Wd, bp) => {
  var XUe = Wa(), C7 = typeof Wd == "object" && Wd && !Wd.nodeType && Wd, E7 = C7 && typeof bp == "object" && bp && !bp.nodeType && bp, YUe = E7 &&
  E7.exports === C7, A7 = YUe ? XUe.Buffer : void 0, x7 = A7 ? A7.allocUnsafe : void 0;
  function JUe(e, t) {
    if (t)
      return e.slice();
    var r = e.length, i = x7 ? x7(r) : new e.constructor(r);
    return e.copy(i), i;
  }
  s(JUe, "cloneBuffer");
  bp.exports = JUe;
});

// ../node_modules/lodash/_Uint8Array.js
var D7 = b((s2t, P7) => {
  var QUe = Wa(), ZUe = QUe.Uint8Array;
  P7.exports = ZUe;
});

// ../node_modules/lodash/_cloneArrayBuffer.js
var vb = b((a2t, O7) => {
  var w7 = D7();
  function eje(e) {
    var t = new e.constructor(e.byteLength);
    return new w7(t).set(new w7(e)), t;
  }
  s(eje, "cloneArrayBuffer");
  O7.exports = eje;
});

// ../node_modules/lodash/_cloneTypedArray.js
var FD = b((u2t, k7) => {
  var tje = vb();
  function rje(e, t) {
    var r = t ? tje(e.buffer) : e.buffer;
    return new e.constructor(r, e.byteOffset, e.length);
  }
  s(rje, "cloneTypedArray");
  k7.exports = rje;
});

// ../node_modules/lodash/_copyArray.js
var MD = b((c2t, I7) => {
  function ije(e, t) {
    var r = -1, i = e.length;
    for (t || (t = Array(i)); ++r < i; )
      t[r] = e[r];
    return t;
  }
  s(ije, "copyArray");
  I7.exports = ije;
});

// ../node_modules/lodash/_baseCreate.js
var L7 = b((p2t, N7) => {
  var nje = xu(), R7 = Object.create, sje = function() {
    function e() {
    }
    return s(e, "object"), function(t) {
      if (!nje(t))
        return {};
      if (R7)
        return R7(t);
      e.prototype = t;
      var r = new e();
      return e.prototype = void 0, r;
    };
  }();
  N7.exports = sje;
});

// ../node_modules/lodash/_isPrototype.js
var Sb = b((d2t, F7) => {
  var aje = Object.prototype;
  function oje(e) {
    var t = e && e.constructor, r = typeof t == "function" && t.prototype || aje;
    return e === r;
  }
  s(oje, "isPrototype");
  F7.exports = oje;
});

// ../node_modules/lodash/_initCloneObject.js
var BD = b((y2t, M7) => {
  var uje = L7(), lje = Z_(), cje = Sb();
  function fje(e) {
    return typeof e.constructor == "function" && !cje(e) ? uje(lje(e)) : {};
  }
  s(fje, "initCloneObject");
  M7.exports = fje;
});

// ../node_modules/lodash/_baseIsArguments.js
var q7 = b((_2t, B7) => {
  var pje = up(), hje = gl(), dje = "[object Arguments]";
  function mje(e) {
    return hje(e) && pje(e) == dje;
  }
  s(mje, "baseIsArguments");
  B7.exports = mje;
});

// ../node_modules/lodash/isArguments.js
var qD = b((v2t, V7) => {
  var U7 = q7(), yje = gl(), j7 = Object.prototype, gje = j7.hasOwnProperty, _je = j7.propertyIsEnumerable, bje = U7(/* @__PURE__ */ function() {
    return arguments;
  }()) ? U7 : function(e) {
    return yje(e) && gje.call(e, "callee") && !_je.call(e, "callee");
  };
  V7.exports = bje;
});

// ../node_modules/lodash/isArray.js
var $d = b((S2t, K7) => {
  var vje = Array.isArray;
  K7.exports = vje;
});

// ../node_modules/lodash/isLength.js
var UD = b((T2t, H7) => {
  var Sje = 9007199254740991;
  function Tje(e) {
    return typeof e == "number" && e > -1 && e % 1 == 0 && e <= Sje;
  }
  s(Tje, "isLength");
  H7.exports = Tje;
});

// ../node_modules/lodash/isArrayLike.js
var Xd = b((A2t, z7) => {
  var Eje = X_(), Aje = UD();
  function xje(e) {
    return e != null && Aje(e.length) && !Eje(e);
  }
  s(xje, "isArrayLike");
  z7.exports = xje;
});

// ../node_modules/lodash/isArrayLikeObject.js
var W7 = b((C2t, G7) => {
  var Cje = Xd(), Pje = gl();
  function Dje(e) {
    return Pje(e) && Cje(e);
  }
  s(Dje, "isArrayLikeObject");
  G7.exports = Dje;
});

// ../node_modules/lodash/stubFalse.js
var X7 = b((D2t, $7) => {
  function wje() {
    return !1;
  }
  s(wje, "stubFalse");
  $7.exports = wje;
});

// ../node_modules/lodash/isBuffer.js
var Tb = b((Yd, vp) => {
  var Oje = Wa(), kje = X7(), Q7 = typeof Yd == "object" && Yd && !Yd.nodeType && Yd, Y7 = Q7 && typeof vp == "object" && vp && !vp.nodeType &&
  vp, Ije = Y7 && Y7.exports === Q7, J7 = Ije ? Oje.Buffer : void 0, Rje = J7 ? J7.isBuffer : void 0, Nje = Rje || kje;
  vp.exports = Nje;
});

// ../node_modules/lodash/_baseIsTypedArray.js
var eK = b((O2t, Z7) => {
  var Lje = up(), Fje = UD(), Mje = gl(), Bje = "[object Arguments]", qje = "[object Array]", Uje = "[object Boolean]", jje = "[object Date]",
  Vje = "[object Error]", Kje = "[object Function]", Hje = "[object Map]", zje = "[object Number]", Gje = "[object Object]", Wje = "[object \
RegExp]", $je = "[object Set]", Xje = "[object String]", Yje = "[object WeakMap]", Jje = "[object ArrayBuffer]", Qje = "[object DataView]", Zje = "\
[object Float32Array]", eVe = "[object Float64Array]", tVe = "[object Int8Array]", rVe = "[object Int16Array]", iVe = "[object Int32Array]",
  nVe = "[object Uint8Array]", sVe = "[object Uint8ClampedArray]", aVe = "[object Uint16Array]", oVe = "[object Uint32Array]", ai = {};
  ai[Zje] = ai[eVe] = ai[tVe] = ai[rVe] = ai[iVe] = ai[nVe] = ai[sVe] = ai[aVe] = ai[oVe] = !0;
  ai[Bje] = ai[qje] = ai[Jje] = ai[Uje] = ai[Qje] = ai[jje] = ai[Vje] = ai[Kje] = ai[Hje] = ai[zje] = ai[Gje] = ai[Wje] = ai[$je] = ai[Xje] =
  ai[Yje] = !1;
  function uVe(e) {
    return Mje(e) && Fje(e.length) && !!ai[Lje(e)];
  }
  s(uVe, "baseIsTypedArray");
  Z7.exports = uVe;
});

// ../node_modules/lodash/_baseUnary.js
var Eb = b((I2t, tK) => {
  function lVe(e) {
    return function(t) {
      return e(t);
    };
  }
  s(lVe, "baseUnary");
  tK.exports = lVe;
});

// ../node_modules/lodash/_nodeUtil.js
var Ab = b((Jd, Sp) => {
  var cVe = VP(), rK = typeof Jd == "object" && Jd && !Jd.nodeType && Jd, Qd = rK && typeof Sp == "object" && Sp && !Sp.nodeType && Sp, fVe = Qd &&
  Qd.exports === rK, jD = fVe && cVe.process, pVe = function() {
    try {
      var e = Qd && Qd.require && Qd.require("util").types;
      return e || jD && jD.binding && jD.binding("util");
    } catch {
    }
  }();
  Sp.exports = pVe;
});

// ../node_modules/lodash/isTypedArray.js
var VD = b((N2t, sK) => {
  var hVe = eK(), dVe = Eb(), iK = Ab(), nK = iK && iK.isTypedArray, mVe = nK ? dVe(nK) : hVe;
  sK.exports = mVe;
});

// ../node_modules/lodash/_safeGet.js
var KD = b((L2t, aK) => {
  function yVe(e, t) {
    if (!(t === "constructor" && typeof e[t] == "function") && t != "__proto__")
      return e[t];
  }
  s(yVe, "safeGet");
  aK.exports = yVe;
});

// ../node_modules/lodash/_assignValue.js
var HD = b((M2t, oK) => {
  var gVe = bb(), _Ve = Ld(), bVe = Object.prototype, vVe = bVe.hasOwnProperty;
  function SVe(e, t, r) {
    var i = e[t];
    (!(vVe.call(e, t) && _Ve(i, r)) || r === void 0 && !(t in e)) && gVe(e, t, r);
  }
  s(SVe, "assignValue");
  oK.exports = SVe;
});

// ../node_modules/lodash/_copyObject.js
var Tp = b((q2t, uK) => {
  var TVe = HD(), EVe = bb();
  function AVe(e, t, r, i) {
    var n = !r;
    r || (r = {});
    for (var a = -1, o = t.length; ++a < o; ) {
      var u = t[a], l = i ? i(r[u], e[u], u, r, e) : void 0;
      l === void 0 && (l = e[u]), n ? EVe(r, u, l) : TVe(r, u, l);
    }
    return r;
  }
  s(AVe, "copyObject");
  uK.exports = AVe;
});

// ../node_modules/lodash/_baseTimes.js
var cK = b((j2t, lK) => {
  function xVe(e, t) {
    for (var r = -1, i = Array(e); ++r < e; )
      i[r] = t(r);
    return i;
  }
  s(xVe, "baseTimes");
  lK.exports = xVe;
});

// ../node_modules/lodash/_isIndex.js
var zD = b((K2t, fK) => {
  var CVe = 9007199254740991, PVe = /^(?:0|[1-9]\d*)$/;
  function DVe(e, t) {
    var r = typeof e;
    return t = t ?? CVe, !!t && (r == "number" || r != "symbol" && PVe.test(e)) && e > -1 && e % 1 == 0 && e < t;
  }
  s(DVe, "isIndex");
  fK.exports = DVe;
});

// ../node_modules/lodash/_arrayLikeKeys.js
var GD = b((z2t, pK) => {
  var wVe = cK(), OVe = qD(), kVe = $d(), IVe = Tb(), RVe = zD(), NVe = VD(), LVe = Object.prototype, FVe = LVe.hasOwnProperty;
  function MVe(e, t) {
    var r = kVe(e), i = !r && OVe(e), n = !r && !i && IVe(e), a = !r && !i && !n && NVe(e), o = r || i || n || a, u = o ? wVe(e.length, String) :
    [], l = u.length;
    for (var c in e)
      (t || FVe.call(e, c)) && !(o && // Safari 9 has enumerable `arguments.length` in strict mode.
      (c == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      n && (c == "offset" || c == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      a && (c == "buffer" || c == "byteLength" || c == "byteOffset") || // Skip index properties.
      RVe(c, l))) && u.push(c);
    return u;
  }
  s(MVe, "arrayLikeKeys");
  pK.exports = MVe;
});

// ../node_modules/lodash/_nativeKeysIn.js
var dK = b((W2t, hK) => {
  function BVe(e) {
    var t = [];
    if (e != null)
      for (var r in Object(e))
        t.push(r);
    return t;
  }
  s(BVe, "nativeKeysIn");
  hK.exports = BVe;
});

// ../node_modules/lodash/_baseKeysIn.js
var yK = b((X2t, mK) => {
  var qVe = xu(), UVe = Sb(), jVe = dK(), VVe = Object.prototype, KVe = VVe.hasOwnProperty;
  function HVe(e) {
    if (!qVe(e))
      return jVe(e);
    var t = UVe(e), r = [];
    for (var i in e)
      i == "constructor" && (t || !KVe.call(e, i)) || r.push(i);
    return r;
  }
  s(HVe, "baseKeysIn");
  mK.exports = HVe;
});

// ../node_modules/lodash/keysIn.js
var Ep = b((J2t, gK) => {
  var zVe = GD(), GVe = yK(), WVe = Xd();
  function $Ve(e) {
    return WVe(e) ? zVe(e, !0) : GVe(e);
  }
  s($Ve, "keysIn");
  gK.exports = $Ve;
});

// ../node_modules/lodash/toPlainObject.js
var bK = b((Z2t, _K) => {
  var XVe = Tp(), YVe = Ep();
  function JVe(e) {
    return XVe(e, YVe(e));
  }
  s(JVe, "toPlainObject");
  _K.exports = JVe;
});

// ../node_modules/lodash/_baseMergeDeep.js
var xK = b((tOt, AK) => {
  var vK = ND(), QVe = LD(), ZVe = FD(), e7e = MD(), t7e = BD(), SK = qD(), TK = $d(), r7e = W7(), i7e = Tb(), n7e = X_(), s7e = xu(), a7e = qd(),
  o7e = VD(), EK = KD(), u7e = bK();
  function l7e(e, t, r, i, n, a, o) {
    var u = EK(e, r), l = EK(t, r), c = o.get(l);
    if (c) {
      vK(e, r, c);
      return;
    }
    var p = a ? a(u, l, r + "", e, t, o) : void 0, h = p === void 0;
    if (h) {
      var y = TK(l), _ = !y && i7e(l), g = !y && !_ && o7e(l);
      p = l, y || _ || g ? TK(u) ? p = u : r7e(u) ? p = e7e(u) : _ ? (h = !1, p = QVe(l, !0)) : g ? (h = !1, p = ZVe(l, !0)) : p = [] : a7e(
      l) || SK(l) ? (p = u, SK(u) ? p = u7e(u) : (!s7e(u) || n7e(u)) && (p = t7e(l))) : h = !1;
    }
    h && (o.set(l, p), n(p, l, i, a, o), o.delete(l)), vK(e, r, p);
  }
  s(l7e, "baseMergeDeep");
  AK.exports = l7e;
});

// ../node_modules/lodash/_baseMerge.js
var DK = b((iOt, PK) => {
  var c7e = ID(), f7e = ND(), p7e = T7(), h7e = xK(), d7e = xu(), m7e = Ep(), y7e = KD();
  function CK(e, t, r, i, n) {
    e !== t && p7e(t, function(a, o) {
      if (n || (n = new c7e()), d7e(a))
        h7e(e, t, o, r, CK, i, n);
      else {
        var u = i ? i(y7e(e, o), a, o + "", e, t, n) : void 0;
        u === void 0 && (u = a), f7e(e, o, u);
      }
    }, m7e);
  }
  s(CK, "baseMerge");
  PK.exports = CK;
});

// ../node_modules/lodash/identity.js
var WD = b((sOt, wK) => {
  function g7e(e) {
    return e;
  }
  s(g7e, "identity");
  wK.exports = g7e;
});

// ../node_modules/lodash/_apply.js
var kK = b((oOt, OK) => {
  function _7e(e, t, r) {
    switch (r.length) {
      case 0:
        return e.call(t);
      case 1:
        return e.call(t, r[0]);
      case 2:
        return e.call(t, r[0], r[1]);
      case 3:
        return e.call(t, r[0], r[1], r[2]);
    }
    return e.apply(t, r);
  }
  s(_7e, "apply");
  OK.exports = _7e;
});

// ../node_modules/lodash/_overRest.js
var NK = b((lOt, RK) => {
  var b7e = kK(), IK = Math.max;
  function v7e(e, t, r) {
    return t = IK(t === void 0 ? e.length - 1 : t, 0), function() {
      for (var i = arguments, n = -1, a = IK(i.length - t, 0), o = Array(a); ++n < a; )
        o[n] = i[t + n];
      n = -1;
      for (var u = Array(t + 1); ++n < t; )
        u[n] = i[n];
      return u[t] = r(o), b7e(e, this, u);
    };
  }
  s(v7e, "overRest");
  RK.exports = v7e;
});

// ../node_modules/lodash/constant.js
var FK = b((fOt, LK) => {
  function S7e(e) {
    return function() {
      return e;
    };
  }
  s(S7e, "constant");
  LK.exports = S7e;
});

// ../node_modules/lodash/_baseSetToString.js
var qK = b((hOt, BK) => {
  var T7e = FK(), MK = RD(), E7e = WD(), A7e = MK ? function(e, t) {
    return MK(e, "toString", {
      configurable: !0,
      enumerable: !1,
      value: T7e(t),
      writable: !0
    });
  } : E7e;
  BK.exports = A7e;
});

// ../node_modules/lodash/_shortOut.js
var jK = b((dOt, UK) => {
  var x7e = 800, C7e = 16, P7e = Date.now;
  function D7e(e) {
    var t = 0, r = 0;
    return function() {
      var i = P7e(), n = C7e - (i - r);
      if (r = i, n > 0) {
        if (++t >= x7e)
          return arguments[0];
      } else
        t = 0;
      return e.apply(void 0, arguments);
    };
  }
  s(D7e, "shortOut");
  UK.exports = D7e;
});

// ../node_modules/lodash/_setToString.js
var KK = b((yOt, VK) => {
  var w7e = qK(), O7e = jK(), k7e = O7e(w7e);
  VK.exports = k7e;
});

// ../node_modules/lodash/_baseRest.js
var zK = b((gOt, HK) => {
  var I7e = WD(), R7e = NK(), N7e = KK();
  function L7e(e, t) {
    return N7e(R7e(e, t, I7e), e + "");
  }
  s(L7e, "baseRest");
  HK.exports = L7e;
});

// ../node_modules/lodash/_isIterateeCall.js
var WK = b((bOt, GK) => {
  var F7e = Ld(), M7e = Xd(), B7e = zD(), q7e = xu();
  function U7e(e, t, r) {
    if (!q7e(r))
      return !1;
    var i = typeof t;
    return (i == "number" ? M7e(r) && B7e(t, r.length) : i == "string" && t in r) ? F7e(r[t], e) : !1;
  }
  s(U7e, "isIterateeCall");
  GK.exports = U7e;
});

// ../node_modules/lodash/_createAssigner.js
var XK = b((SOt, $K) => {
  var j7e = zK(), V7e = WK();
  function K7e(e) {
    return j7e(function(t, r) {
      var i = -1, n = r.length, a = n > 1 ? r[n - 1] : void 0, o = n > 2 ? r[2] : void 0;
      for (a = e.length > 3 && typeof a == "function" ? (n--, a) : void 0, o && V7e(r[0], r[1], o) && (a = n < 3 ? void 0 : a, n = 1), t = Object(
      t); ++i < n; ) {
        var u = r[i];
        u && e(t, u, i, a);
      }
      return t;
    });
  }
  s(K7e, "createAssigner");
  $K.exports = K7e;
});

// ../node_modules/lodash/merge.js
var xb = b((EOt, YK) => {
  var H7e = DK(), z7e = XK(), G7e = z7e(function(e, t, r) {
    H7e(e, t, r);
  });
  YK.exports = G7e;
});

// ../node_modules/lodash/_arrayEach.js
var QK = b((AOt, JK) => {
  function W7e(e, t) {
    for (var r = -1, i = e == null ? 0 : e.length; ++r < i && t(e[r], r, e) !== !1; )
      ;
    return e;
  }
  s(W7e, "arrayEach");
  JK.exports = W7e;
});

// ../node_modules/lodash/_nativeKeys.js
var eH = b((COt, ZK) => {
  var $7e = ZP(), X7e = $7e(Object.keys, Object);
  ZK.exports = X7e;
});

// ../node_modules/lodash/_baseKeys.js
var rH = b((POt, tH) => {
  var Y7e = Sb(), J7e = eH(), Q7e = Object.prototype, Z7e = Q7e.hasOwnProperty;
  function eKe(e) {
    if (!Y7e(e))
      return J7e(e);
    var t = [];
    for (var r in Object(e))
      Z7e.call(e, r) && r != "constructor" && t.push(r);
    return t;
  }
  s(eKe, "baseKeys");
  tH.exports = eKe;
});

// ../node_modules/lodash/keys.js
var Cb = b((wOt, iH) => {
  var tKe = GD(), rKe = rH(), iKe = Xd();
  function nKe(e) {
    return iKe(e) ? tKe(e) : rKe(e);
  }
  s(nKe, "keys");
  iH.exports = nKe;
});

// ../node_modules/lodash/_baseAssign.js
var sH = b((kOt, nH) => {
  var sKe = Tp(), aKe = Cb();
  function oKe(e, t) {
    return e && sKe(t, aKe(t), e);
  }
  s(oKe, "baseAssign");
  nH.exports = oKe;
});

// ../node_modules/lodash/_baseAssignIn.js
var oH = b((ROt, aH) => {
  var uKe = Tp(), lKe = Ep();
  function cKe(e, t) {
    return e && uKe(t, lKe(t), e);
  }
  s(cKe, "baseAssignIn");
  aH.exports = cKe;
});

// ../node_modules/lodash/_arrayFilter.js
var lH = b((LOt, uH) => {
  function fKe(e, t) {
    for (var r = -1, i = e == null ? 0 : e.length, n = 0, a = []; ++r < i; ) {
      var o = e[r];
      t(o, r, e) && (a[n++] = o);
    }
    return a;
  }
  s(fKe, "arrayFilter");
  uH.exports = fKe;
});

// ../node_modules/lodash/stubArray.js
var $D = b((MOt, cH) => {
  function pKe() {
    return [];
  }
  s(pKe, "stubArray");
  cH.exports = pKe;
});

// ../node_modules/lodash/_getSymbols.js
var Pb = b((qOt, pH) => {
  var hKe = lH(), dKe = $D(), mKe = Object.prototype, yKe = mKe.propertyIsEnumerable, fH = Object.getOwnPropertySymbols, gKe = fH ? function(e) {
    return e == null ? [] : (e = Object(e), hKe(fH(e), function(t) {
      return yKe.call(e, t);
    }));
  } : dKe;
  pH.exports = gKe;
});

// ../node_modules/lodash/_copySymbols.js
var dH = b((UOt, hH) => {
  var _Ke = Tp(), bKe = Pb();
  function vKe(e, t) {
    return _Ke(e, bKe(e), t);
  }
  s(vKe, "copySymbols");
  hH.exports = vKe;
});

// ../node_modules/lodash/_arrayPush.js
var XD = b((VOt, mH) => {
  function SKe(e, t) {
    for (var r = -1, i = t.length, n = e.length; ++r < i; )
      e[n + r] = t[r];
    return e;
  }
  s(SKe, "arrayPush");
  mH.exports = SKe;
});

// ../node_modules/lodash/_getSymbolsIn.js
var YD = b((HOt, yH) => {
  var TKe = XD(), EKe = Z_(), AKe = Pb(), xKe = $D(), CKe = Object.getOwnPropertySymbols, PKe = CKe ? function(e) {
    for (var t = []; e; )
      TKe(t, AKe(e)), e = EKe(e);
    return t;
  } : xKe;
  yH.exports = PKe;
});

// ../node_modules/lodash/_copySymbolsIn.js
var _H = b((zOt, gH) => {
  var DKe = Tp(), wKe = YD();
  function OKe(e, t) {
    return DKe(e, wKe(e), t);
  }
  s(OKe, "copySymbolsIn");
  gH.exports = OKe;
});

// ../node_modules/lodash/_baseGetAllKeys.js
var JD = b((WOt, bH) => {
  var kKe = XD(), IKe = $d();
  function RKe(e, t, r) {
    var i = t(e);
    return IKe(e) ? i : kKe(i, r(e));
  }
  s(RKe, "baseGetAllKeys");
  bH.exports = RKe;
});

// ../node_modules/lodash/_getAllKeys.js
var SH = b((XOt, vH) => {
  var NKe = JD(), LKe = Pb(), FKe = Cb();
  function MKe(e) {
    return NKe(e, FKe, LKe);
  }
  s(MKe, "getAllKeys");
  vH.exports = MKe;
});

// ../node_modules/lodash/_getAllKeysIn.js
var EH = b((JOt, TH) => {
  var BKe = JD(), qKe = YD(), UKe = Ep();
  function jKe(e) {
    return BKe(e, UKe, qKe);
  }
  s(jKe, "getAllKeysIn");
  TH.exports = jKe;
});

// ../node_modules/lodash/_DataView.js
var xH = b((ZOt, AH) => {
  var VKe = yl(), KKe = Wa(), HKe = VKe(KKe, "DataView");
  AH.exports = HKe;
});

// ../node_modules/lodash/_Promise.js
var PH = b((ekt, CH) => {
  var zKe = yl(), GKe = Wa(), WKe = zKe(GKe, "Promise");
  CH.exports = WKe;
});

// ../node_modules/lodash/_WeakMap.js
var wH = b((tkt, DH) => {
  var $Ke = yl(), XKe = Wa(), YKe = $Ke(XKe, "WeakMap");
  DH.exports = YKe;
});

// ../node_modules/lodash/_getTag.js
var Db = b((rkt, FH) => {
  var QD = xH(), ZD = Y_(), ew = PH(), tw = GP(), rw = wH(), LH = up(), Ap = HP(), OH = "[object Map]", JKe = "[object Object]", kH = "[obje\
ct Promise]", IH = "[object Set]", RH = "[object WeakMap]", NH = "[object DataView]", QKe = Ap(QD), ZKe = Ap(ZD), eHe = Ap(ew), tHe = Ap(tw),
  rHe = Ap(rw), xc = LH;
  (QD && xc(new QD(new ArrayBuffer(1))) != NH || ZD && xc(new ZD()) != OH || ew && xc(ew.resolve()) != kH || tw && xc(new tw()) != IH || rw &&
  xc(new rw()) != RH) && (xc = /* @__PURE__ */ s(function(e) {
    var t = LH(e), r = t == JKe ? e.constructor : void 0, i = r ? Ap(r) : "";
    if (i)
      switch (i) {
        case QKe:
          return NH;
        case ZKe:
          return OH;
        case eHe:
          return kH;
        case tHe:
          return IH;
        case rHe:
          return RH;
      }
    return t;
  }, "getTag"));
  FH.exports = xc;
});

// ../node_modules/lodash/_initCloneArray.js
var BH = b((nkt, MH) => {
  var iHe = Object.prototype, nHe = iHe.hasOwnProperty;
  function sHe(e) {
    var t = e.length, r = new e.constructor(t);
    return t && typeof e[0] == "string" && nHe.call(e, "index") && (r.index = e.index, r.input = e.input), r;
  }
  s(sHe, "initCloneArray");
  MH.exports = sHe;
});

// ../node_modules/lodash/_cloneDataView.js
var UH = b((akt, qH) => {
  var aHe = vb();
  function oHe(e, t) {
    var r = t ? aHe(e.buffer) : e.buffer;
    return new e.constructor(r, e.byteOffset, e.byteLength);
  }
  s(oHe, "cloneDataView");
  qH.exports = oHe;
});

// ../node_modules/lodash/_cloneRegExp.js
var VH = b((ukt, jH) => {
  var uHe = /\w*$/;
  function lHe(e) {
    var t = new e.constructor(e.source, uHe.exec(e));
    return t.lastIndex = e.lastIndex, t;
  }
  s(lHe, "cloneRegExp");
  jH.exports = lHe;
});

// ../node_modules/lodash/_cloneSymbol.js
var WH = b((ckt, GH) => {
  var KH = $_(), HH = KH ? KH.prototype : void 0, zH = HH ? HH.valueOf : void 0;
  function cHe(e) {
    return zH ? Object(zH.call(e)) : {};
  }
  s(cHe, "cloneSymbol");
  GH.exports = cHe;
});

// ../node_modules/lodash/_initCloneByTag.js
var XH = b((pkt, $H) => {
  var fHe = vb(), pHe = UH(), hHe = VH(), dHe = WH(), mHe = FD(), yHe = "[object Boolean]", gHe = "[object Date]", _He = "[object Map]", bHe = "\
[object Number]", vHe = "[object RegExp]", SHe = "[object Set]", THe = "[object String]", EHe = "[object Symbol]", AHe = "[object ArrayBuffe\
r]", xHe = "[object DataView]", CHe = "[object Float32Array]", PHe = "[object Float64Array]", DHe = "[object Int8Array]", wHe = "[object Int\
16Array]", OHe = "[object Int32Array]", kHe = "[object Uint8Array]", IHe = "[object Uint8ClampedArray]", RHe = "[object Uint16Array]", NHe = "\
[object Uint32Array]";
  function LHe(e, t, r) {
    var i = e.constructor;
    switch (t) {
      case AHe:
        return fHe(e);
      case yHe:
      case gHe:
        return new i(+e);
      case xHe:
        return pHe(e, r);
      case CHe:
      case PHe:
      case DHe:
      case wHe:
      case OHe:
      case kHe:
      case IHe:
      case RHe:
      case NHe:
        return mHe(e, r);
      case _He:
        return new i();
      case bHe:
      case THe:
        return new i(e);
      case vHe:
        return hHe(e);
      case SHe:
        return new i();
      case EHe:
        return dHe(e);
    }
  }
  s(LHe, "initCloneByTag");
  $H.exports = LHe;
});

// ../node_modules/lodash/_baseIsMap.js
var JH = b((dkt, YH) => {
  var FHe = Db(), MHe = gl(), BHe = "[object Map]";
  function qHe(e) {
    return MHe(e) && FHe(e) == BHe;
  }
  s(qHe, "baseIsMap");
  YH.exports = qHe;
});

// ../node_modules/lodash/isMap.js
var tz = b((ykt, ez) => {
  var UHe = JH(), jHe = Eb(), QH = Ab(), ZH = QH && QH.isMap, VHe = ZH ? jHe(ZH) : UHe;
  ez.exports = VHe;
});

// ../node_modules/lodash/_baseIsSet.js
var iz = b((gkt, rz) => {
  var KHe = Db(), HHe = gl(), zHe = "[object Set]";
  function GHe(e) {
    return HHe(e) && KHe(e) == zHe;
  }
  s(GHe, "baseIsSet");
  rz.exports = GHe;
});

// ../node_modules/lodash/isSet.js
var oz = b((bkt, az) => {
  var WHe = iz(), $He = Eb(), nz = Ab(), sz = nz && nz.isSet, XHe = sz ? $He(sz) : WHe;
  az.exports = XHe;
});

// ../node_modules/lodash/_baseClone.js
var pz = b((vkt, fz) => {
  var YHe = ID(), JHe = QK(), QHe = HD(), ZHe = sH(), eze = oH(), tze = LD(), rze = MD(), ize = dH(), nze = _H(), sze = SH(), aze = EH(), oze = Db(),
  uze = BH(), lze = XH(), cze = BD(), fze = $d(), pze = Tb(), hze = tz(), dze = xu(), mze = oz(), yze = Cb(), gze = Ep(), _ze = 1, bze = 2, vze = 4,
  uz = "[object Arguments]", Sze = "[object Array]", Tze = "[object Boolean]", Eze = "[object Date]", Aze = "[object Error]", lz = "[object \
Function]", xze = "[object GeneratorFunction]", Cze = "[object Map]", Pze = "[object Number]", cz = "[object Object]", Dze = "[object RegExp\
]", wze = "[object Set]", Oze = "[object String]", kze = "[object Symbol]", Ize = "[object WeakMap]", Rze = "[object ArrayBuffer]", Nze = "[\
object DataView]", Lze = "[object Float32Array]", Fze = "[object Float64Array]", Mze = "[object Int8Array]", Bze = "[object Int16Array]", qze = "\
[object Int32Array]", Uze = "[object Uint8Array]", jze = "[object Uint8ClampedArray]", Vze = "[object Uint16Array]", Kze = "[object Uint32Ar\
ray]", Jr = {};
  Jr[uz] = Jr[Sze] = Jr[Rze] = Jr[Nze] = Jr[Tze] = Jr[Eze] = Jr[Lze] = Jr[Fze] = Jr[Mze] = Jr[Bze] = Jr[qze] = Jr[Cze] = Jr[Pze] = Jr[cz] = Jr[Dze] =
  Jr[wze] = Jr[Oze] = Jr[kze] = Jr[Uze] = Jr[jze] = Jr[Vze] = Jr[Kze] = !0;
  Jr[Aze] = Jr[lz] = Jr[Ize] = !1;
  function wb(e, t, r, i, n, a) {
    var o, u = t & _ze, l = t & bze, c = t & vze;
    if (r && (o = n ? r(e, i, n, a) : r(e)), o !== void 0)
      return o;
    if (!dze(e))
      return e;
    var p = fze(e);
    if (p) {
      if (o = uze(e), !u)
        return rze(e, o);
    } else {
      var h = oze(e), y = h == lz || h == xze;
      if (pze(e))
        return tze(e, u);
      if (h == cz || h == uz || y && !n) {
        if (o = l || y ? {} : cze(e), !u)
          return l ? nze(e, eze(o, e)) : ize(e, ZHe(o, e));
      } else {
        if (!Jr[h])
          return n ? e : {};
        o = lze(e, h, u);
      }
    }
    a || (a = new YHe());
    var _ = a.get(e);
    if (_)
      return _;
    a.set(e, o), mze(e) ? e.forEach(function(f) {
      o.add(wb(f, t, r, f, e, a));
    }) : hze(e) && e.forEach(function(f, d) {
      o.set(d, wb(f, t, r, d, e, a));
    });
    var g = c ? l ? aze : sze : l ? gze : yze, m = p ? void 0 : g(e);
    return JHe(m || e, function(f, d) {
      m && (d = f, f = e[d]), QHe(o, d, wb(f, t, r, d, e, a));
    }), o;
  }
  s(wb, "baseClone");
  fz.exports = wb;
});

// ../node_modules/lodash/cloneDeep.js
var dz = b((Tkt, hz) => {
  var Hze = pz(), zze = 1, Gze = 4;
  function Wze(e) {
    return Hze(e, zze | Gze);
  }
  s(Wze, "cloneDeep");
  hz.exports = Wze;
});

// ../node_modules/renderkid/lib/tools.js
var ys = b((Akt, _z) => {
  "use strict";
  var mz, iw, nw, yz, gz, Cc;
  iw = RV();
  var $ze = i7();
  gz = $ze.objectToDom;
  yz = xb();
  mz = dz();
  nw = qd();
  _z.exports = Cc = {
    repeatString: /* @__PURE__ */ s(function(t, r) {
      var i, n, a, o;
      for (a = "", i = n = 0, o = r; 0 <= o ? n < o : n > o; i = 0 <= o ? ++n : --n)
        a += t;
      return a;
    }, "repeatString"),
    cloneAndMergeDeep: /* @__PURE__ */ s(function(t, r) {
      return yz(mz(t), r);
    }, "cloneAndMergeDeep"),
    toDom: /* @__PURE__ */ s(function(t) {
      if (typeof t == "string")
        return Cc.stringToDom(t);
      if (nw(t))
        return Cc._objectToDom(t);
      throw Error("tools.toDom() only supports strings and objects");
    }, "toDom"),
    stringToDom: /* @__PURE__ */ s(function(t) {
      var r, i;
      return r = new iw.DomHandler(), i = new iw.Parser(r), i.write(t), i.end(), r.dom;
    }, "stringToDom"),
    _fixQuotesInDom: /* @__PURE__ */ s(function(t) {
      var r, i, n;
      if (Array.isArray(t)) {
        for (r = 0, i = t.length; r < i; r++)
          n = t[r], Cc._fixQuotesInDom(n);
        return t;
      }
      return n = t, n.type === "text" ? n.data = Cc._quoteNodeText(n.data) : Cc._fixQuotesInDom(n.children);
    }, "_fixQuotesInDom"),
    objectToDom: /* @__PURE__ */ s(function(t) {
      if (!Array.isArray(t) && !nw(t))
        throw Error("objectToDom() only accepts a bare object or an array");
      return Cc._fixQuotesInDom(gz(t));
    }, "objectToDom"),
    quote: /* @__PURE__ */ s(function(t) {
      return String(t).replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\"/g, "&quot;").replace(/\ /g, "&sp;").replace(/\n/g, "<br />");
    }, "quote"),
    _quoteNodeText: /* @__PURE__ */ s(function(t) {
      return String(t).replace(/\&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\"/g, "&quot;").replace(/\ /g, "&sp;").replace(
      /\n/g, "&nl;");
    }, "_quoteNodeText"),
    getCols: /* @__PURE__ */ s(function() {
      var t, r;
      return r = require("tty"), t = function() {
        try {
          if (r.isatty(1) && r.isatty(2)) {
            if (process.stdout.getWindowSize)
              return process.stdout.getWindowSize(1)[0];
            if (r.getWindowSize)
              return r.getWindowSize()[1];
            if (process.stdout.columns)
              return process.stdout.columns;
          }
        } catch {
        }
      }(), typeof t == "number" && t > 30 ? t : 80;
    }, "getCols")
  };
});

// ../node_modules/renderkid/lib/ansiPainter/tags.js
var Sz = b((Ckt, vz) => {
  "use strict";
  var Pc, sw, Ob, bz, kb;
  vz.exports = kb = {
    none: {
      color: "none",
      bg: "none"
    },
    "bg-none": {
      color: "inherit",
      bg: "none"
    },
    "color-none": {
      color: "none",
      bg: "inherit"
    }
  };
  sw = ["black", "red", "green", "yellow", "blue", "magenta", "cyan", "white", "grey", "bright-red", "bright-green", "bright-yellow", "brigh\
t-blue", "bright-magenta", "bright-cyan", "bright-white"];
  for (Ob = 0, bz = sw.length; Ob < bz; Ob++)
    Pc = sw[Ob], kb[Pc] = {
      color: Pc,
      bg: "inherit"
    }, kb["color-".concat(Pc)] = {
      color: Pc,
      bg: "inherit"
    }, kb["bg-".concat(Pc)] = {
      color: "inherit",
      bg: Pc
    };
});

// ../node_modules/renderkid/lib/ansiPainter/styles.js
var Ez = b((Pkt, Tz) => {
  "use strict";
  var Ib, Zd;
  Tz.exports = Zd = {};
  Zd.codes = Ib = {
    none: 0,
    black: 30,
    red: 31,
    green: 32,
    yellow: 33,
    blue: 34,
    magenta: 35,
    cyan: 36,
    white: 37,
    grey: 90,
    "bright-red": 91,
    "bright-green": 92,
    "bright-yellow": 93,
    "bright-blue": 94,
    "bright-magenta": 95,
    "bright-cyan": 96,
    "bright-white": 97,
    "bg-black": 40,
    "bg-red": 41,
    "bg-green": 42,
    "bg-yellow": 43,
    "bg-blue": 44,
    "bg-magenta": 45,
    "bg-cyan": 46,
    "bg-white": 47,
    "bg-grey": 100,
    "bg-bright-red": 101,
    "bg-bright-green": 102,
    "bg-bright-yellow": 103,
    "bg-bright-blue": 104,
    "bg-bright-magenta": 105,
    "bg-bright-cyan": 106,
    "bg-bright-white": 107
  };
  Zd.color = function(e) {
    var t;
    if (e === "none")
      return "";
    if (t = Ib[e], t == null)
      throw Error("Unknown color `".concat(e, "`"));
    return "\x1B[" + t + "m";
  };
  Zd.bg = function(e) {
    var t;
    if (e === "none")
      return "";
    if (t = Ib["bg-" + e], t == null)
      throw Error("Unknown bg color `".concat(e, "`"));
    return "\x1B[" + t + "m";
  };
  Zd.none = function(e) {
    return "\x1B[" + Ib.none + "m";
  };
});

// ../node_modules/renderkid/lib/AnsiPainter.js
var aw = b((Dkt, Pz) => {
  "use strict";
  function Xze(e, t) {
    if (!(e instanceof t))
      throw new TypeError("Cannot call a class as a function");
  }
  s(Xze, "_classCallCheck");
  function Az(e, t) {
    for (var r = 0; r < t.length; r++) {
      var i = t[r];
      i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);
    }
  }
  s(Az, "_defineProperties");
  function Yze(e, t, r) {
    return t && Az(e.prototype, t), r && Az(e, r), e;
  }
  s(Yze, "_createClass");
  var Jze, Rb, Nb, Cz, xz = {}.hasOwnProperty;
  Cz = ys();
  Nb = Sz();
  Rb = Ez();
  Pz.exports = Jze = function() {
    var e, t = /* @__PURE__ */ function() {
      function r() {
        Xze(this, r);
      }
      return s(r, "AnsiPainter"), Yze(r, [{
        key: "paint",
        value: /* @__PURE__ */ s(function(n) {
          return this._replaceSpecialStrings(this._renderDom(this._parse(n)));
        }, "paint")
      }, {
        key: "_replaceSpecialStrings",
        value: /* @__PURE__ */ s(function(n) {
          return n.replace(/&sp;/g, " ").replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&quot;/g, '"').replace(/&amp;/g, "&");
        }, "_replaceSpecialStrings")
      }, {
        key: "_parse",
        value: /* @__PURE__ */ s(function(n) {
          var a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
          return a && (n = "<none>" + n + "</none>"), Cz.toDom(n);
        }, "_parse")
      }, {
        key: "_renderDom",
        value: /* @__PURE__ */ s(function(n) {
          var a;
          return a = {
            bg: "none",
            color: "none"
          }, this._renderChildren(n, a);
        }, "_renderDom")
      }, {
        key: "_renderChildren",
        value: /* @__PURE__ */ s(function(n, a) {
          var o, u, l;
          l = "";
          for (u in n)
            xz.call(n, u) && (o = n[u], l += this._renderNode(o, a));
          return l;
        }, "_renderChildren")
      }, {
        key: "_renderNode",
        value: /* @__PURE__ */ s(function(n, a) {
          return n.type === "text" ? this._renderTextNode(n, a) : this._renderTag(n, a);
        }, "_renderNode")
      }, {
        key: "_renderTextNode",
        value: /* @__PURE__ */ s(function(n, a) {
          return this._wrapInStyle(n.data, a);
        }, "_renderTextNode")
      }, {
        key: "_wrapInStyle",
        value: /* @__PURE__ */ s(function(n, a) {
          return Rb.color(a.color) + Rb.bg(a.bg) + n + Rb.none();
        }, "_wrapInStyle")
      }, {
        key: "_renderTag",
        value: /* @__PURE__ */ s(function(n, a) {
          var o, u;
          return u = this._getStylesForTagName(n.name), o = this._mixStyles(a, u), this._renderChildren(n.children, o);
        }, "_renderTag")
      }, {
        key: "_mixStyles",
        value: /* @__PURE__ */ s(function() {
          var n, a, o, u, l, c;
          n = {};
          for (var p = arguments.length, h = new Array(p), y = 0; y < p; y++)
            h[y] = arguments[y];
          for (a = 0, u = h.length; a < u; a++) {
            l = h[a];
            for (o in l)
              xz.call(l, o) && (c = l[o], (n[o] == null || c !== "inherit") && (n[o] = c));
          }
          return n;
        }, "_mixStyles")
      }, {
        key: "_getStylesForTagName",
        value: /* @__PURE__ */ s(function(n) {
          if (Nb[n] == null)
            throw Error("Unknown tag name `".concat(n, "`"));
          return Nb[n];
        }, "_getStylesForTagName")
      }], [{
        key: "getInstance",
        value: /* @__PURE__ */ s(function() {
          return e._instance == null && (e._instance = new e()), e._instance;
        }, "getInstance")
      }, {
        key: "paint",
        value: /* @__PURE__ */ s(function(n) {
          return e.getInstance().paint(n);
        }, "paint")
      }, {
        key: "strip",
        value: /* @__PURE__ */ s(function(n) {
          return n.replace(/\x1b\[[0-9]+m/g, "");
        }, "strip")
      }]), r;
    }();
    return t.tags = Nb, e = t, t;
  }.call(void 0);
});

// ../node_modules/renderkid/lib/renderKid/styleApplier/_common.js
var uw = b((Okt, Dz) => {
  "use strict";
  var ow, Qze;
  ow = aw();
  Dz.exports = Qze = {
    getStyleTagsFor: /* @__PURE__ */ s(function(t) {
      var r, i, n, a, o, u;
      if (u = [], t.color != null) {
        if (o = "color-" + t.color, ow.tags[o] == null)
          throw Error("Unknown color `".concat(t.color, "`"));
        u.push(o);
      }
      if (t.background != null) {
        if (o = "bg-" + t.background, ow.tags[o] == null)
          throw Error("Unknown background `".concat(t.background, "`"));
        u.push(o);
      }
      for (n = {
        before: "",
        after: ""
      }, r = 0, i = u.length; r < i; r++)
        a = u[r], n.before = "<".concat(a, ">") + n.before, n.after = n.after + "</".concat(a, ">");
      return n;
    }, "getStyleTagsFor")
  };
});

// ../node_modules/renderkid/lib/renderKid/styleApplier/inline.js
var kz = b((Ikt, Oz) => {
  "use strict";
  var wz, Zze, eGe, em;
  em = ys();
  wz = uw();
  Oz.exports = Zze = eGe = {
    applyTo: /* @__PURE__ */ s(function(t, r) {
      var i;
      return i = wz.getStyleTagsFor(r), r.marginLeft != null && (i.before = em.repeatString("&sp;", parseInt(r.marginLeft)) + i.before), r.marginRight !=
      null && (i.after += em.repeatString("&sp;", parseInt(r.marginRight))), r.paddingLeft != null && (i.before += em.repeatString("&sp;", parseInt(
      r.paddingLeft))), r.paddingRight != null && (i.after = em.repeatString("&sp;", parseInt(r.paddingRight)) + i.after), i;
    }, "applyTo")
  };
});

// ../node_modules/renderkid/lib/renderKid/styleApplier/block.js
var Rz = b((Nkt, Iz) => {
  "use strict";
  var lw, tGe, xp, rGe;
  lw = uw();
  xp = xb();
  Iz.exports = tGe = rGe = {
    applyTo: /* @__PURE__ */ s(function(t, r) {
      var i, n;
      return n = lw.getStyleTagsFor(r), n.blockConfig = i = {}, this._margins(r, i), this._bullet(r, i), this._dims(r, i), n;
    }, "applyTo"),
    _margins: /* @__PURE__ */ s(function(t, r) {
      t.marginLeft != null && xp(r, {
        linePrependor: {
          options: {
            amount: parseInt(t.marginLeft)
          }
        }
      }), t.marginRight != null && xp(r, {
        lineAppendor: {
          options: {
            amount: parseInt(t.marginRight)
          }
        }
      }), t.marginTop != null && xp(r, {
        blockPrependor: {
          options: {
            amount: parseInt(t.marginTop)
          }
        }
      }), t.marginBottom != null && xp(r, {
        blockAppendor: {
          options: {
            amount: parseInt(t.marginBottom)
          }
        }
      });
    }, "_margins"),
    _bullet: /* @__PURE__ */ s(function(t, r) {
      var i, n, a, o;
      if (t.bullet != null && t.bullet.enabled) {
        a = t.bullet, o = {}, o.alignment = t.bullet.alignment;
        var u = lw.getStyleTagsFor({
          color: a.color,
          background: a.background
        });
        n = u.before, i = u.after, o.char = n + a.char + i, xp(r, {
          linePrependor: {
            options: {
              bullet: o
            }
          }
        });
      }
    }, "_bullet"),
    _dims: /* @__PURE__ */ s(function(t, r) {
      var i;
      t.width != null && (i = parseInt(t.width), r.width = i);
    }, "_dims")
  };
});

// ../node_modules/boolbase/index.js
var Tl = b((Fkt, Nz) => {
  Nz.exports = {
    trueFunc: /* @__PURE__ */ s(function() {
      return !0;
    }, "trueFunc"),
    falseFunc: /* @__PURE__ */ s(function() {
      return !1;
    }, "falseFunc")
  };
});

// ../node_modules/css-what/lib/commonjs/types.js
var Lb = b((Uo) => {
  "use strict";
  Object.defineProperty(Uo, "__esModule", { value: !0 });
  Uo.AttributeAction = Uo.IgnoreCaseMode = Uo.SelectorType = void 0;
  var iGe;
  (function(e) {
    e.Attribute = "attribute", e.Pseudo = "pseudo", e.PseudoElement = "pseudo-element", e.Tag = "tag", e.Universal = "universal", e.Adjacent =
    "adjacent", e.Child = "child", e.Descendant = "descendant", e.Parent = "parent", e.Sibling = "sibling", e.ColumnCombinator = "column-com\
binator";
  })(iGe = Uo.SelectorType || (Uo.SelectorType = {}));
  Uo.IgnoreCaseMode = {
    Unknown: null,
    QuirksMode: "quirks",
    IgnoreCase: !0,
    CaseSensitive: !1
  };
  var nGe;
  (function(e) {
    e.Any = "any", e.Element = "element", e.End = "end", e.Equals = "equals", e.Exists = "exists", e.Hyphen = "hyphen", e.Not = "not", e.Start =
    "start";
  })(nGe = Uo.AttributeAction || (Uo.AttributeAction = {}));
});

// ../node_modules/css-what/lib/commonjs/parse.js
var qz = b((Cp) => {
  "use strict";
  Object.defineProperty(Cp, "__esModule", { value: !0 });
  Cp.parse = Cp.isTraversal = void 0;
  var Pr = Lb(), Lz = /^[^\\#]?(?:\\(?:[\da-f]{1,6}\s?|.)|[\w\-\u00b0-\uFFFF])+/, sGe = /\\([\da-f]{1,6}\s?|(\s)|.)/gi, aGe = /* @__PURE__ */ new Map(
  [
    [126, Pr.AttributeAction.Element],
    [94, Pr.AttributeAction.Start],
    [36, Pr.AttributeAction.End],
    [42, Pr.AttributeAction.Any],
    [33, Pr.AttributeAction.Not],
    [124, Pr.AttributeAction.Hyphen]
  ]), oGe = /* @__PURE__ */ new Set([
    "has",
    "not",
    "matches",
    "is",
    "where",
    "host",
    "host-context"
  ]);
  function Mz(e) {
    switch (e.type) {
      case Pr.SelectorType.Adjacent:
      case Pr.SelectorType.Child:
      case Pr.SelectorType.Descendant:
      case Pr.SelectorType.Parent:
      case Pr.SelectorType.Sibling:
      case Pr.SelectorType.ColumnCombinator:
        return !0;
      default:
        return !1;
    }
  }
  s(Mz, "isTraversal");
  Cp.isTraversal = Mz;
  var uGe = /* @__PURE__ */ new Set(["contains", "icontains"]);
  function lGe(e, t, r) {
    var i = parseInt(t, 16) - 65536;
    return i !== i || r ? t : i < 0 ? (
      // BMP codepoint
      String.fromCharCode(i + 65536)
    ) : (
      // Supplemental Plane codepoint (surrogate pair)
      String.fromCharCode(i >> 10 | 55296, i & 1023 | 56320)
    );
  }
  s(lGe, "funescape");
  function tm(e) {
    return e.replace(sGe, lGe);
  }
  s(tm, "unescapeCSS");
  function cw(e) {
    return e === 39 || e === 34;
  }
  s(cw, "isQuote");
  function Fz(e) {
    return e === 32 || e === 9 || e === 10 || e === 12 || e === 13;
  }
  s(Fz, "isWhitespace");
  function cGe(e) {
    var t = [], r = Bz(t, "".concat(e), 0);
    if (r < e.length)
      throw new Error("Unmatched selector: ".concat(e.slice(r)));
    return t;
  }
  s(cGe, "parse");
  Cp.parse = cGe;
  function Bz(e, t, r) {
    var i = [];
    function n(j) {
      var J = t.slice(r + j).match(Lz);
      if (!J)
        throw new Error("Expected name, found ".concat(t.slice(r)));
      var H = J[0];
      return r += j + H.length, tm(H);
    }
    s(n, "getName");
    function a(j) {
      for (r += j; r < t.length && Fz(t.charCodeAt(r)); )
        r++;
    }
    s(a, "stripWhitespace");
    function o() {
      r += 1;
      for (var j = r, J = 1; J > 0 && r < t.length; r++)
        t.charCodeAt(r) === 40 && !u(r) ? J++ : t.charCodeAt(r) === 41 && !u(r) && J--;
      if (J)
        throw new Error("Parenthesis not matched");
      return tm(t.slice(j, r - 1));
    }
    s(o, "readValueWithParenthesis");
    function u(j) {
      for (var J = 0; t.charCodeAt(--j) === 92; )
        J++;
      return (J & 1) === 1;
    }
    s(u, "isEscaped");
    function l() {
      if (i.length > 0 && Mz(i[i.length - 1]))
        throw new Error("Did not expect successive traversals.");
    }
    s(l, "ensureNotTraversal");
    function c(j) {
      if (i.length > 0 && i[i.length - 1].type === Pr.SelectorType.Descendant) {
        i[i.length - 1].type = j;
        return;
      }
      l(), i.push({ type: j });
    }
    s(c, "addTraversal");
    function p(j, J) {
      i.push({
        type: Pr.SelectorType.Attribute,
        name: j,
        action: J,
        value: n(1),
        namespace: null,
        ignoreCase: "quirks"
      });
    }
    s(p, "addSpecialAttribute");
    function h() {
      if (i.length && i[i.length - 1].type === Pr.SelectorType.Descendant && i.pop(), i.length === 0)
        throw new Error("Empty sub-selector");
      e.push(i);
    }
    if (s(h, "finalizeSubselector"), a(0), t.length === r)
      return r;
    e: for (; r < t.length; ) {
      var y = t.charCodeAt(r);
      switch (y) {
        // Whitespace
        case 32:
        case 9:
        case 10:
        case 12:
        case 13: {
          (i.length === 0 || i[0].type !== Pr.SelectorType.Descendant) && (l(), i.push({ type: Pr.SelectorType.Descendant })), a(1);
          break;
        }
        // Traversals
        case 62: {
          c(Pr.SelectorType.Child), a(1);
          break;
        }
        case 60: {
          c(Pr.SelectorType.Parent), a(1);
          break;
        }
        case 126: {
          c(Pr.SelectorType.Sibling), a(1);
          break;
        }
        case 43: {
          c(Pr.SelectorType.Adjacent), a(1);
          break;
        }
        // Special attribute selectors: .class, #id
        case 46: {
          p("class", Pr.AttributeAction.Element);
          break;
        }
        case 35: {
          p("id", Pr.AttributeAction.Equals);
          break;
        }
        case 91: {
          a(1);
          var _ = void 0, g = null;
          t.charCodeAt(r) === 124 ? _ = n(1) : t.startsWith("*|", r) ? (g = "*", _ = n(2)) : (_ = n(0), t.charCodeAt(r) === 124 && t.charCodeAt(
          r + 1) !== 61 && (g = _, _ = n(1))), a(0);
          var m = Pr.AttributeAction.Exists, f = aGe.get(t.charCodeAt(r));
          if (f) {
            if (m = f, t.charCodeAt(r + 1) !== 61)
              throw new Error("Expected `=`");
            a(2);
          } else t.charCodeAt(r) === 61 && (m = Pr.AttributeAction.Equals, a(1));
          var d = "", v = null;
          if (m !== "exists") {
            if (cw(t.charCodeAt(r))) {
              for (var E = t.charCodeAt(r), S = r + 1; S < t.length && (t.charCodeAt(S) !== E || u(S)); )
                S += 1;
              if (t.charCodeAt(S) !== E)
                throw new Error("Attribute value didn't end");
              d = tm(t.slice(r + 1, S)), r = S + 1;
            } else {
              for (var x = r; r < t.length && (!Fz(t.charCodeAt(r)) && t.charCodeAt(r) !== 93 || u(r)); )
                r += 1;
              d = tm(t.slice(x, r));
            }
            a(0);
            var C = t.charCodeAt(r) | 32;
            C === 115 ? (v = !1, a(1)) : C === 105 && (v = !0, a(1));
          }
          if (t.charCodeAt(r) !== 93)
            throw new Error("Attribute selector didn't terminate");
          r += 1;
          var z = {
            type: Pr.SelectorType.Attribute,
            name: _,
            action: m,
            value: d,
            namespace: g,
            ignoreCase: v
          };
          i.push(z);
          break;
        }
        case 58: {
          if (t.charCodeAt(r + 1) === 58) {
            i.push({
              type: Pr.SelectorType.PseudoElement,
              name: n(2).toLowerCase(),
              data: t.charCodeAt(r) === 40 ? o() : null
            });
            continue;
          }
          var w = n(1).toLowerCase(), D = null;
          if (t.charCodeAt(r) === 40)
            if (oGe.has(w)) {
              if (cw(t.charCodeAt(r + 1)))
                throw new Error("Pseudo-selector ".concat(w, " cannot be quoted"));
              if (D = [], r = Bz(D, t, r + 1), t.charCodeAt(r) !== 41)
                throw new Error("Missing closing parenthesis in :".concat(w, " (").concat(t, ")"));
              r += 1;
            } else {
              if (D = o(), uGe.has(w)) {
                var N = D.charCodeAt(0);
                N === D.charCodeAt(D.length - 1) && cw(N) && (D = D.slice(1, -1));
              }
              D = tm(D);
            }
          i.push({ type: Pr.SelectorType.Pseudo, name: w, data: D });
          break;
        }
        case 44: {
          h(), i = [], a(1);
          break;
        }
        default: {
          if (t.startsWith("/*", r)) {
            var T = t.indexOf("*/", r + 2);
            if (T < 0)
              throw new Error("Comment was not terminated");
            r = T + 2, i.length === 0 && a(0);
            break;
          }
          var g = null, R = void 0;
          if (y === 42)
            r += 1, R = "*";
          else if (y === 124) {
            if (R = "", t.charCodeAt(r + 1) === 124) {
              c(Pr.SelectorType.ColumnCombinator), a(2);
              break;
            }
          } else if (Lz.test(t.slice(r)))
            R = n(0);
          else
            break e;
          t.charCodeAt(r) === 124 && t.charCodeAt(r + 1) !== 124 && (g = R, t.charCodeAt(r + 1) === 42 ? (R = "*", r += 2) : R = n(1)), i.push(
          R === "*" ? { type: Pr.SelectorType.Universal, namespace: g } : { type: Pr.SelectorType.Tag, name: R, namespace: g });
        }
      }
    }
    return h(), r;
  }
  s(Bz, "parseSelector");
});

// ../node_modules/css-what/lib/commonjs/stringify.js
var Gz = b((Dp) => {
  "use strict";
  var Fb = Dp && Dp.__spreadArray || function(e, t, r) {
    if (r || arguments.length === 2) for (var i = 0, n = t.length, a; i < n; i++)
      (a || !(i in t)) && (a || (a = Array.prototype.slice.call(t, 0, i)), a[i] = t[i]);
    return e.concat(a || Array.prototype.slice.call(t));
  };
  Object.defineProperty(Dp, "__esModule", { value: !0 });
  Dp.stringify = void 0;
  var Li = Lb(), Vz = ["\\", '"'], Kz = Fb(Fb([], Vz, !0), ["(", ")"], !1), fGe = new Set(Vz.map(function(e) {
    return e.charCodeAt(0);
  })), Uz = new Set(Kz.map(function(e) {
    return e.charCodeAt(0);
  })), Pp = new Set(Fb(Fb([], Kz, !0), [
    "~",
    "^",
    "$",
    "*",
    "+",
    "!",
    "|",
    ":",
    "[",
    "]",
    " ",
    "."
  ], !1).map(function(e) {
    return e.charCodeAt(0);
  }));
  function Hz(e) {
    return e.map(function(t) {
      return t.map(pGe).join("");
    }).join(", ");
  }
  s(Hz, "stringify");
  Dp.stringify = Hz;
  function pGe(e, t, r) {
    switch (e.type) {
      // Simple types
      case Li.SelectorType.Child:
        return t === 0 ? "> " : " > ";
      case Li.SelectorType.Parent:
        return t === 0 ? "< " : " < ";
      case Li.SelectorType.Sibling:
        return t === 0 ? "~ " : " ~ ";
      case Li.SelectorType.Adjacent:
        return t === 0 ? "+ " : " + ";
      case Li.SelectorType.Descendant:
        return " ";
      case Li.SelectorType.ColumnCombinator:
        return t === 0 ? "|| " : " || ";
      case Li.SelectorType.Universal:
        return e.namespace === "*" && t + 1 < r.length && "name" in r[t + 1] ? "" : "".concat(zz(e.namespace), "*");
      case Li.SelectorType.Tag:
        return jz(e);
      case Li.SelectorType.PseudoElement:
        return "::".concat(Du(e.name, Pp)).concat(e.data === null ? "" : "(".concat(Du(e.data, Uz), ")"));
      case Li.SelectorType.Pseudo:
        return ":".concat(Du(e.name, Pp)).concat(e.data === null ? "" : "(".concat(typeof e.data == "string" ? Du(e.data, Uz) : Hz(e.data), "\
)"));
      case Li.SelectorType.Attribute: {
        if (e.name === "id" && e.action === Li.AttributeAction.Equals && e.ignoreCase === "quirks" && !e.namespace)
          return "#".concat(Du(e.value, Pp));
        if (e.name === "class" && e.action === Li.AttributeAction.Element && e.ignoreCase === "quirks" && !e.namespace)
          return ".".concat(Du(e.value, Pp));
        var i = jz(e);
        return e.action === Li.AttributeAction.Exists ? "[".concat(i, "]") : "[".concat(i).concat(hGe(e.action), '="').concat(Du(e.value, fGe),
        '"').concat(e.ignoreCase === null ? "" : e.ignoreCase ? " i" : " s", "]");
      }
    }
  }
  s(pGe, "stringifyToken");
  function hGe(e) {
    switch (e) {
      case Li.AttributeAction.Equals:
        return "";
      case Li.AttributeAction.Element:
        return "~";
      case Li.AttributeAction.Start:
        return "^";
      case Li.AttributeAction.End:
        return "$";
      case Li.AttributeAction.Any:
        return "*";
      case Li.AttributeAction.Not:
        return "!";
      case Li.AttributeAction.Hyphen:
        return "|";
      case Li.AttributeAction.Exists:
        throw new Error("Shouldn't be here");
    }
  }
  s(hGe, "getActionValue");
  function jz(e) {
    return "".concat(zz(e.namespace)).concat(Du(e.name, Pp));
  }
  s(jz, "getNamespacedName");
  function zz(e) {
    return e !== null ? "".concat(e === "*" ? "*" : Du(e, Pp), "|") : "";
  }
  s(zz, "getNamespace");
  function Du(e, t) {
    for (var r = 0, i = "", n = 0; n < e.length; n++)
      t.has(e.charCodeAt(n)) && (i += "".concat(e.slice(r, n), "\\").concat(e.charAt(n)), r = n + 1);
    return i.length > 0 ? i + e.slice(r) : e;
  }
  s(Du, "escapeName");
});

// ../node_modules/css-what/lib/commonjs/index.js
var rm = b((Qs) => {
  "use strict";
  var dGe = Qs && Qs.__createBinding || (Object.create ? function(e, t, r, i) {
    i === void 0 && (i = r);
    var n = Object.getOwnPropertyDescriptor(t, r);
    (!n || ("get" in n ? !t.__esModule : n.writable || n.configurable)) && (n = { enumerable: !0, get: /* @__PURE__ */ s(function() {
      return t[r];
    }, "get") }), Object.defineProperty(e, i, n);
  } : function(e, t, r, i) {
    i === void 0 && (i = r), e[i] = t[r];
  }), mGe = Qs && Qs.__exportStar || function(e, t) {
    for (var r in e) r !== "default" && !Object.prototype.hasOwnProperty.call(t, r) && dGe(t, e, r);
  };
  Object.defineProperty(Qs, "__esModule", { value: !0 });
  Qs.stringify = Qs.parse = Qs.isTraversal = void 0;
  mGe(Lb(), Qs);
  var Wz = qz();
  Object.defineProperty(Qs, "isTraversal", { enumerable: !0, get: /* @__PURE__ */ s(function() {
    return Wz.isTraversal;
  }, "get") });
  Object.defineProperty(Qs, "parse", { enumerable: !0, get: /* @__PURE__ */ s(function() {
    return Wz.parse;
  }, "get") });
  var yGe = Gz();
  Object.defineProperty(Qs, "stringify", { enumerable: !0, get: /* @__PURE__ */ s(function() {
    return yGe.stringify;
  }, "get") });
});

// ../node_modules/renderkid/node_modules/css-select/lib/procedure.js
var Mb = b((Dc) => {
  "use strict";
  Object.defineProperty(Dc, "__esModule", { value: !0 });
  Dc.isTraversal = Dc.procedure = void 0;
  Dc.procedure = {
    universal: 50,
    tag: 30,
    attribute: 1,
    pseudo: 0,
    "pseudo-element": 0,
    "column-combinator": -1,
    descendant: -1,
    child: -1,
    parent: -1,
    sibling: -1,
    adjacent: -1,
    _flexibleDescendant: -1
  };
  function gGe(e) {
    return Dc.procedure[e.type] < 0;
  }
  s(gGe, "isTraversal");
  Dc.isTraversal = gGe;
});

// ../node_modules/renderkid/node_modules/css-select/lib/sort.js
var Jz = b((fw) => {
  "use strict";
  Object.defineProperty(fw, "__esModule", { value: !0 });
  var $z = rm(), _Ge = Mb(), Xz = {
    exists: 10,
    equals: 8,
    not: 7,
    start: 6,
    end: 6,
    any: 5,
    hyphen: 4,
    element: 4
  };
  function bGe(e) {
    for (var t = e.map(Yz), r = 1; r < e.length; r++) {
      var i = t[r];
      if (!(i < 0))
        for (var n = r - 1; n >= 0 && i < t[n]; n--) {
          var a = e[n + 1];
          e[n + 1] = e[n], e[n] = a, t[n + 1] = t[n], t[n] = i;
        }
    }
  }
  s(bGe, "sortByProcedure");
  fw.default = bGe;
  function Yz(e) {
    var t = _Ge.procedure[e.type];
    if (e.type === $z.SelectorType.Attribute)
      t = Xz[e.action], t === Xz.equals && e.name === "id" && (t = 9), e.ignoreCase && (t >>= 1);
    else if (e.type === $z.SelectorType.Pseudo)
      if (!e.data)
        t = 3;
      else if (e.name === "has" || e.name === "contains")
        t = 0;
      else if (Array.isArray(e.data)) {
        t = 0;
        for (var r = 0; r < e.data.length; r++)
          if (e.data[r].length === 1) {
            var i = Yz(e.data[r][0]);
            if (i === 0) {
              t = 0;
              break;
            }
            i > t && (t = i);
          }
        e.data.length > 1 && t > 0 && (t -= 1);
      } else
        t = 1;
    return t;
  }
  s(Yz, "getProcedure");
});

// ../node_modules/renderkid/node_modules/css-select/lib/attributes.js
var Zz = b((qb) => {
  "use strict";
  Object.defineProperty(qb, "__esModule", { value: !0 });
  qb.attributeRules = void 0;
  var Bb = Tl(), vGe = /[-[\]{}()*+?.,\\^$|#\s]/g;
  function Qz(e) {
    return e.replace(vGe, "\\$&");
  }
  s(Qz, "escapeRegex");
  var SGe = /* @__PURE__ */ new Set([
    "accept",
    "accept-charset",
    "align",
    "alink",
    "axis",
    "bgcolor",
    "charset",
    "checked",
    "clear",
    "codetype",
    "color",
    "compact",
    "declare",
    "defer",
    "dir",
    "direction",
    "disabled",
    "enctype",
    "face",
    "frame",
    "hreflang",
    "http-equiv",
    "lang",
    "language",
    "link",
    "media",
    "method",
    "multiple",
    "nohref",
    "noresize",
    "noshade",
    "nowrap",
    "readonly",
    "rel",
    "rev",
    "rules",
    "scope",
    "scrolling",
    "selected",
    "shape",
    "target",
    "text",
    "type",
    "valign",
    "valuetype",
    "vlink"
  ]);
  function wc(e, t) {
    return typeof e.ignoreCase == "boolean" ? e.ignoreCase : e.ignoreCase === "quirks" ? !!t.quirksMode : !t.xmlMode && SGe.has(e.name);
  }
  s(wc, "shouldIgnoreCase");
  qb.attributeRules = {
    equals: /* @__PURE__ */ s(function(e, t, r) {
      var i = r.adapter, n = t.name, a = t.value;
      return wc(t, r) ? (a = a.toLowerCase(), function(o) {
        var u = i.getAttributeValue(o, n);
        return u != null && u.length === a.length && u.toLowerCase() === a && e(o);
      }) : function(o) {
        return i.getAttributeValue(o, n) === a && e(o);
      };
    }, "equals"),
    hyphen: /* @__PURE__ */ s(function(e, t, r) {
      var i = r.adapter, n = t.name, a = t.value, o = a.length;
      return wc(t, r) ? (a = a.toLowerCase(), /* @__PURE__ */ s(function(l) {
        var c = i.getAttributeValue(l, n);
        return c != null && (c.length === o || c.charAt(o) === "-") && c.substr(0, o).toLowerCase() === a && e(l);
      }, "hyphenIC")) : /* @__PURE__ */ s(function(l) {
        var c = i.getAttributeValue(l, n);
        return c != null && (c.length === o || c.charAt(o) === "-") && c.substr(0, o) === a && e(l);
      }, "hyphen");
    }, "hyphen"),
    element: /* @__PURE__ */ s(function(e, t, r) {
      var i = r.adapter, n = t.name, a = t.value;
      if (/\s/.test(a))
        return Bb.falseFunc;
      var o = new RegExp("(?:^|\\s)".concat(Qz(a), "(?:$|\\s)"), wc(t, r) ? "i" : "");
      return /* @__PURE__ */ s(function(l) {
        var c = i.getAttributeValue(l, n);
        return c != null && c.length >= a.length && o.test(c) && e(l);
      }, "element");
    }, "element"),
    exists: /* @__PURE__ */ s(function(e, t, r) {
      var i = t.name, n = r.adapter;
      return function(a) {
        return n.hasAttrib(a, i) && e(a);
      };
    }, "exists"),
    start: /* @__PURE__ */ s(function(e, t, r) {
      var i = r.adapter, n = t.name, a = t.value, o = a.length;
      return o === 0 ? Bb.falseFunc : wc(t, r) ? (a = a.toLowerCase(), function(u) {
        var l = i.getAttributeValue(u, n);
        return l != null && l.length >= o && l.substr(0, o).toLowerCase() === a && e(u);
      }) : function(u) {
        var l;
        return !!(!((l = i.getAttributeValue(u, n)) === null || l === void 0) && l.startsWith(a)) && e(u);
      };
    }, "start"),
    end: /* @__PURE__ */ s(function(e, t, r) {
      var i = r.adapter, n = t.name, a = t.value, o = -a.length;
      return o === 0 ? Bb.falseFunc : wc(t, r) ? (a = a.toLowerCase(), function(u) {
        var l;
        return ((l = i.getAttributeValue(u, n)) === null || l === void 0 ? void 0 : l.substr(o).toLowerCase()) === a && e(u);
      }) : function(u) {
        var l;
        return !!(!((l = i.getAttributeValue(u, n)) === null || l === void 0) && l.endsWith(a)) && e(u);
      };
    }, "end"),
    any: /* @__PURE__ */ s(function(e, t, r) {
      var i = r.adapter, n = t.name, a = t.value;
      if (a === "")
        return Bb.falseFunc;
      if (wc(t, r)) {
        var o = new RegExp(Qz(a), "i");
        return /* @__PURE__ */ s(function(l) {
          var c = i.getAttributeValue(l, n);
          return c != null && c.length >= a.length && o.test(c) && e(l);
        }, "anyIC");
      }
      return function(u) {
        var l;
        return !!(!((l = i.getAttributeValue(u, n)) === null || l === void 0) && l.includes(a)) && e(u);
      };
    }, "any"),
    not: /* @__PURE__ */ s(function(e, t, r) {
      var i = r.adapter, n = t.name, a = t.value;
      return a === "" ? function(o) {
        return !!i.getAttributeValue(o, n) && e(o);
      } : wc(t, r) ? (a = a.toLowerCase(), function(o) {
        var u = i.getAttributeValue(o, n);
        return (u == null || u.length !== a.length || u.toLowerCase() !== a) && e(o);
      }) : function(o) {
        return i.getAttributeValue(o, n) !== a && e(o);
      };
    }, "not")
  };
});

// ../node_modules/nth-check/lib/parse.js
var tG = b((Ub) => {
  "use strict";
  Object.defineProperty(Ub, "__esModule", { value: !0 });
  Ub.parse = void 0;
  var TGe = /* @__PURE__ */ new Set([9, 10, 12, 13, 32]), eG = 48, EGe = 57;
  function AGe(e) {
    if (e = e.trim().toLowerCase(), e === "even")
      return [2, 0];
    if (e === "odd")
      return [2, 1];
    var t = 0, r = 0, i = a(), n = o();
    if (t < e.length && e.charAt(t) === "n" && (t++, r = i * (n ?? 1), u(), t < e.length ? (i = a(), u(), n = o()) : i = n = 0), n === null ||
    t < e.length)
      throw new Error("n-th rule couldn't be parsed ('".concat(e, "')"));
    return [r, i * n];
    function a() {
      return e.charAt(t) === "-" ? (t++, -1) : (e.charAt(t) === "+" && t++, 1);
    }
    function o() {
      for (var l = t, c = 0; t < e.length && e.charCodeAt(t) >= eG && e.charCodeAt(t) <= EGe; )
        c = c * 10 + (e.charCodeAt(t) - eG), t++;
      return t === l ? null : c;
    }
    function u() {
      for (; t < e.length && TGe.has(e.charCodeAt(t)); )
        t++;
    }
  }
  s(AGe, "parse");
  Ub.parse = AGe;
});

// ../node_modules/nth-check/lib/compile.js
var iG = b((El) => {
  "use strict";
  var xGe = El && El.__importDefault || function(e) {
    return e && e.__esModule ? e : { default: e };
  };
  Object.defineProperty(El, "__esModule", { value: !0 });
  El.generate = El.compile = void 0;
  var rG = xGe(Tl());
  function CGe(e) {
    var t = e[0], r = e[1] - 1;
    if (r < 0 && t <= 0)
      return rG.default.falseFunc;
    if (t === -1)
      return function(a) {
        return a <= r;
      };
    if (t === 0)
      return function(a) {
        return a === r;
      };
    if (t === 1)
      return r < 0 ? rG.default.trueFunc : function(a) {
        return a >= r;
      };
    var i = Math.abs(t), n = (r % i + i) % i;
    return t > 1 ? function(a) {
      return a >= r && a % i === n;
    } : function(a) {
      return a <= r && a % i === n;
    };
  }
  s(CGe, "compile");
  El.compile = CGe;
  function PGe(e) {
    var t = e[0], r = e[1] - 1, i = 0;
    if (t < 0) {
      var n = -t, a = (r % n + n) % n;
      return function() {
        var o = a + n * i++;
        return o > r ? null : o;
      };
    }
    return t === 0 ? r < 0 ? (
      // There are no result — always return `null`
      function() {
        return null;
      }
    ) : (
      // Return `b` exactly once
      function() {
        return i++ === 0 ? r : null;
      }
    ) : (r < 0 && (r += t * Math.ceil(-r / t)), function() {
      return t * i++ + r;
    });
  }
  s(PGe, "generate");
  El.generate = PGe;
});

// ../node_modules/nth-check/lib/index.js
var nG = b((Ya) => {
  "use strict";
  Object.defineProperty(Ya, "__esModule", { value: !0 });
  Ya.sequence = Ya.generate = Ya.compile = Ya.parse = void 0;
  var pw = tG();
  Object.defineProperty(Ya, "parse", { enumerable: !0, get: /* @__PURE__ */ s(function() {
    return pw.parse;
  }, "get") });
  var jb = iG();
  Object.defineProperty(Ya, "compile", { enumerable: !0, get: /* @__PURE__ */ s(function() {
    return jb.compile;
  }, "get") });
  Object.defineProperty(Ya, "generate", { enumerable: !0, get: /* @__PURE__ */ s(function() {
    return jb.generate;
  }, "get") });
  function DGe(e) {
    return (0, jb.compile)((0, pw.parse)(e));
  }
  s(DGe, "nthCheck");
  Ya.default = DGe;
  function wGe(e) {
    return (0, jb.generate)((0, pw.parse)(e));
  }
  s(wGe, "sequence");
  Ya.sequence = wGe;
});

// ../node_modules/renderkid/node_modules/css-select/lib/pseudo-selectors/filters.js
var sG = b((Oc) => {
  "use strict";
  var OGe = Oc && Oc.__importDefault || function(e) {
    return e && e.__esModule ? e : { default: e };
  };
  Object.defineProperty(Oc, "__esModule", { value: !0 });
  Oc.filters = void 0;
  var Vb = OGe(nG()), Zs = Tl();
  function Kb(e, t) {
    return function(r) {
      var i = t.getParent(r);
      return i != null && t.isTag(i) && e(r);
    };
  }
  s(Kb, "getChildFunc");
  Oc.filters = {
    contains: /* @__PURE__ */ s(function(e, t, r) {
      var i = r.adapter;
      return /* @__PURE__ */ s(function(a) {
        return e(a) && i.getText(a).includes(t);
      }, "contains");
    }, "contains"),
    icontains: /* @__PURE__ */ s(function(e, t, r) {
      var i = r.adapter, n = t.toLowerCase();
      return /* @__PURE__ */ s(function(o) {
        return e(o) && i.getText(o).toLowerCase().includes(n);
      }, "icontains");
    }, "icontains"),
    // Location specific methods
    "nth-child": /* @__PURE__ */ s(function(e, t, r) {
      var i = r.adapter, n = r.equals, a = (0, Vb.default)(t);
      return a === Zs.falseFunc ? Zs.falseFunc : a === Zs.trueFunc ? Kb(e, i) : /* @__PURE__ */ s(function(u) {
        for (var l = i.getSiblings(u), c = 0, p = 0; p < l.length && !n(u, l[p]); p++)
          i.isTag(l[p]) && c++;
        return a(c) && e(u);
      }, "nthChild");
    }, "nth-child"),
    "nth-last-child": /* @__PURE__ */ s(function(e, t, r) {
      var i = r.adapter, n = r.equals, a = (0, Vb.default)(t);
      return a === Zs.falseFunc ? Zs.falseFunc : a === Zs.trueFunc ? Kb(e, i) : /* @__PURE__ */ s(function(u) {
        for (var l = i.getSiblings(u), c = 0, p = l.length - 1; p >= 0 && !n(u, l[p]); p--)
          i.isTag(l[p]) && c++;
        return a(c) && e(u);
      }, "nthLastChild");
    }, "nth-last-child"),
    "nth-of-type": /* @__PURE__ */ s(function(e, t, r) {
      var i = r.adapter, n = r.equals, a = (0, Vb.default)(t);
      return a === Zs.falseFunc ? Zs.falseFunc : a === Zs.trueFunc ? Kb(e, i) : /* @__PURE__ */ s(function(u) {
        for (var l = i.getSiblings(u), c = 0, p = 0; p < l.length; p++) {
          var h = l[p];
          if (n(u, h))
            break;
          i.isTag(h) && i.getName(h) === i.getName(u) && c++;
        }
        return a(c) && e(u);
      }, "nthOfType");
    }, "nth-of-type"),
    "nth-last-of-type": /* @__PURE__ */ s(function(e, t, r) {
      var i = r.adapter, n = r.equals, a = (0, Vb.default)(t);
      return a === Zs.falseFunc ? Zs.falseFunc : a === Zs.trueFunc ? Kb(e, i) : /* @__PURE__ */ s(function(u) {
        for (var l = i.getSiblings(u), c = 0, p = l.length - 1; p >= 0; p--) {
          var h = l[p];
          if (n(u, h))
            break;
          i.isTag(h) && i.getName(h) === i.getName(u) && c++;
        }
        return a(c) && e(u);
      }, "nthLastOfType");
    }, "nth-last-of-type"),
    // TODO determine the actual root element
    root: /* @__PURE__ */ s(function(e, t, r) {
      var i = r.adapter;
      return function(n) {
        var a = i.getParent(n);
        return (a == null || !i.isTag(a)) && e(n);
      };
    }, "root"),
    scope: /* @__PURE__ */ s(function(e, t, r, i) {
      var n = r.equals;
      return !i || i.length === 0 ? Oc.filters.root(e, t, r) : i.length === 1 ? function(a) {
        return n(i[0], a) && e(a);
      } : function(a) {
        return i.includes(a) && e(a);
      };
    }, "scope"),
    hover: hw("isHovered"),
    visited: hw("isVisited"),
    active: hw("isActive")
  };
  function hw(e) {
    return /* @__PURE__ */ s(function(r, i, n) {
      var a = n.adapter, o = a[e];
      return typeof o != "function" ? Zs.falseFunc : /* @__PURE__ */ s(function(l) {
        return o(l) && r(l);
      }, "active");
    }, "dynamicPseudo");
  }
  s(hw, "dynamicStatePseudo");
});

// ../node_modules/renderkid/node_modules/css-select/lib/pseudo-selectors/pseudos.js
var aG = b((wp) => {
  "use strict";
  Object.defineProperty(wp, "__esModule", { value: !0 });
  wp.verifyPseudoArgs = wp.pseudos = void 0;
  wp.pseudos = {
    empty: /* @__PURE__ */ s(function(e, t) {
      var r = t.adapter;
      return !r.getChildren(e).some(function(i) {
        return r.isTag(i) || r.getText(i) !== "";
      });
    }, "empty"),
    "first-child": /* @__PURE__ */ s(function(e, t) {
      var r = t.adapter, i = t.equals, n = r.getSiblings(e).find(function(a) {
        return r.isTag(a);
      });
      return n != null && i(e, n);
    }, "first-child"),
    "last-child": /* @__PURE__ */ s(function(e, t) {
      for (var r = t.adapter, i = t.equals, n = r.getSiblings(e), a = n.length - 1; a >= 0; a--) {
        if (i(e, n[a]))
          return !0;
        if (r.isTag(n[a]))
          break;
      }
      return !1;
    }, "last-child"),
    "first-of-type": /* @__PURE__ */ s(function(e, t) {
      for (var r = t.adapter, i = t.equals, n = r.getSiblings(e), a = r.getName(e), o = 0; o < n.length; o++) {
        var u = n[o];
        if (i(e, u))
          return !0;
        if (r.isTag(u) && r.getName(u) === a)
          break;
      }
      return !1;
    }, "first-of-type"),
    "last-of-type": /* @__PURE__ */ s(function(e, t) {
      for (var r = t.adapter, i = t.equals, n = r.getSiblings(e), a = r.getName(e), o = n.length - 1; o >= 0; o--) {
        var u = n[o];
        if (i(e, u))
          return !0;
        if (r.isTag(u) && r.getName(u) === a)
          break;
      }
      return !1;
    }, "last-of-type"),
    "only-of-type": /* @__PURE__ */ s(function(e, t) {
      var r = t.adapter, i = t.equals, n = r.getName(e);
      return r.getSiblings(e).every(function(a) {
        return i(e, a) || !r.isTag(a) || r.getName(a) !== n;
      });
    }, "only-of-type"),
    "only-child": /* @__PURE__ */ s(function(e, t) {
      var r = t.adapter, i = t.equals;
      return r.getSiblings(e).every(function(n) {
        return i(e, n) || !r.isTag(n);
      });
    }, "only-child")
  };
  function kGe(e, t, r) {
    if (r === null) {
      if (e.length > 2)
        throw new Error("pseudo-selector :".concat(t, " requires an argument"));
    } else if (e.length === 2)
      throw new Error("pseudo-selector :".concat(t, " doesn't have any arguments"));
  }
  s(kGe, "verifyPseudoArgs");
  wp.verifyPseudoArgs = kGe;
});

// ../node_modules/renderkid/node_modules/css-select/lib/pseudo-selectors/aliases.js
var oG = b((Hb) => {
  "use strict";
  Object.defineProperty(Hb, "__esModule", { value: !0 });
  Hb.aliases = void 0;
  Hb.aliases = {
    // Links
    "any-link": ":is(a, area, link)[href]",
    link: ":any-link:not(:visited)",
    // Forms
    // https://html.spec.whatwg.org/multipage/scripting.html#disabled-elements
    disabled: `:is(
        :is(button, input, select, textarea, optgroup, option)[disabled],
        optgroup[disabled] > option,
        fieldset[disabled]:not(fieldset[disabled] legend:first-of-type *)
    )`,
    enabled: ":not(:disabled)",
    checked: ":is(:is(input[type=radio], input[type=checkbox])[checked], option:selected)",
    required: ":is(input, select, textarea)[required]",
    optional: ":is(input, select, textarea):not([required])",
    // JQuery extensions
    // https://html.spec.whatwg.org/multipage/form-elements.html#concept-option-selectedness
    selected: "option:is([selected], select:not([multiple]):not(:has(> option[selected])) > :first-of-type)",
    checkbox: "[type=checkbox]",
    file: "[type=file]",
    password: "[type=password]",
    radio: "[type=radio]",
    reset: "[type=reset]",
    image: "[type=image]",
    submit: "[type=submit]",
    parent: ":not(:empty)",
    header: ":is(h1, h2, h3, h4, h5, h6)",
    button: ":is(button, input[type=button])",
    input: ":is(input, textarea, select, button)",
    text: "input:is(:not([type!='']), [type=text])"
  };
});

// ../node_modules/renderkid/node_modules/css-select/lib/pseudo-selectors/subselects.js
var zb = b((ea) => {
  "use strict";
  var uG = ea && ea.__spreadArray || function(e, t, r) {
    if (r || arguments.length === 2) for (var i = 0, n = t.length, a; i < n; i++)
      (a || !(i in t)) && (a || (a = Array.prototype.slice.call(t, 0, i)), a[i] = t[i]);
    return e.concat(a || Array.prototype.slice.call(t));
  };
  Object.defineProperty(ea, "__esModule", { value: !0 });
  ea.subselects = ea.getNextSiblings = ea.ensureIsTag = ea.PLACEHOLDER_ELEMENT = void 0;
  var Al = Tl(), IGe = Mb();
  ea.PLACEHOLDER_ELEMENT = {};
  function lG(e, t) {
    return e === Al.falseFunc ? Al.falseFunc : function(r) {
      return t.isTag(r) && e(r);
    };
  }
  s(lG, "ensureIsTag");
  ea.ensureIsTag = lG;
  function cG(e, t) {
    var r = t.getSiblings(e);
    if (r.length <= 1)
      return [];
    var i = r.indexOf(e);
    return i < 0 || i === r.length - 1 ? [] : r.slice(i + 1).filter(t.isTag);
  }
  s(cG, "getNextSiblings");
  ea.getNextSiblings = cG;
  var dw = /* @__PURE__ */ s(function(e, t, r, i, n) {
    var a = {
      xmlMode: !!r.xmlMode,
      adapter: r.adapter,
      equals: r.equals
    }, o = n(t, a, i);
    return function(u) {
      return o(u) && e(u);
    };
  }, "is");
  ea.subselects = {
    is: dw,
    /**
     * `:matches` and `:where` are aliases for `:is`.
     */
    matches: dw,
    where: dw,
    not: /* @__PURE__ */ s(function(e, t, r, i, n) {
      var a = {
        xmlMode: !!r.xmlMode,
        adapter: r.adapter,
        equals: r.equals
      }, o = n(t, a, i);
      return o === Al.falseFunc ? e : o === Al.trueFunc ? Al.falseFunc : /* @__PURE__ */ s(function(l) {
        return !o(l) && e(l);
      }, "not");
    }, "not"),
    has: /* @__PURE__ */ s(function(e, t, r, i, n) {
      var a = r.adapter, o = {
        xmlMode: !!r.xmlMode,
        adapter: a,
        equals: r.equals
      }, u = t.some(function(y) {
        return y.some(IGe.isTraversal);
      }) ? [ea.PLACEHOLDER_ELEMENT] : void 0, l = n(t, o, u);
      if (l === Al.falseFunc)
        return Al.falseFunc;
      if (l === Al.trueFunc)
        return function(y) {
          return a.getChildren(y).some(a.isTag) && e(y);
        };
      var c = lG(l, a), p = l.shouldTestNextSiblings, h = p === void 0 ? !1 : p;
      return u ? function(y) {
        u[0] = y;
        var _ = a.getChildren(y), g = h ? uG(uG([], _, !0), cG(y, a), !0) : _;
        return e(y) && a.existsOne(c, g);
      } : function(y) {
        return e(y) && a.existsOne(c, a.getChildren(y));
      };
    }, "has")
  };
});

// ../node_modules/renderkid/node_modules/css-select/lib/pseudo-selectors/index.js
var _w = b((jo) => {
  "use strict";
  Object.defineProperty(jo, "__esModule", { value: !0 });
  jo.compilePseudoSelector = jo.aliases = jo.pseudos = jo.filters = void 0;
  var mw = Tl(), RGe = rm(), yw = sG();
  Object.defineProperty(jo, "filters", { enumerable: !0, get: /* @__PURE__ */ s(function() {
    return yw.filters;
  }, "get") });
  var Gb = aG();
  Object.defineProperty(jo, "pseudos", { enumerable: !0, get: /* @__PURE__ */ s(function() {
    return Gb.pseudos;
  }, "get") });
  var gw = oG();
  Object.defineProperty(jo, "aliases", { enumerable: !0, get: /* @__PURE__ */ s(function() {
    return gw.aliases;
  }, "get") });
  var fG = zb();
  function NGe(e, t, r, i, n) {
    var a = t.name, o = t.data;
    if (Array.isArray(o))
      return fG.subselects[a](e, o, r, i, n);
    if (a in gw.aliases) {
      if (o != null)
        throw new Error("Pseudo ".concat(a, " doesn't have any arguments"));
      var u = (0, RGe.parse)(gw.aliases[a]);
      return fG.subselects.is(e, u, r, i, n);
    }
    if (a in yw.filters)
      return yw.filters[a](e, o, r, i);
    if (a in Gb.pseudos) {
      var l = Gb.pseudos[a];
      return (0, Gb.verifyPseudoArgs)(l, a, o), l === mw.falseFunc ? mw.falseFunc : e === mw.trueFunc ? function(c) {
        return l(c, r, o);
      } : function(c) {
        return l(c, r, o) && e(c);
      };
    }
    throw new Error("unmatched pseudo-class :".concat(a));
  }
  s(NGe, "compilePseudoSelector");
  jo.compilePseudoSelector = NGe;
});

// ../node_modules/renderkid/node_modules/css-select/lib/general.js
var pG = b((Wb) => {
  "use strict";
  Object.defineProperty(Wb, "__esModule", { value: !0 });
  Wb.compileGeneralSelector = void 0;
  var LGe = Zz(), FGe = _w(), Ja = rm();
  function MGe(e, t, r, i, n) {
    var a = r.adapter, o = r.equals;
    switch (t.type) {
      case Ja.SelectorType.PseudoElement:
        throw new Error("Pseudo-elements are not supported by css-select");
      case Ja.SelectorType.ColumnCombinator:
        throw new Error("Column combinators are not yet supported by css-select");
      case Ja.SelectorType.Attribute: {
        if (t.namespace != null)
          throw new Error("Namespaced attributes are not yet supported by css-select");
        return (!r.xmlMode || r.lowerCaseAttributeNames) && (t.name = t.name.toLowerCase()), LGe.attributeRules[t.action](e, t, r);
      }
      case Ja.SelectorType.Pseudo:
        return (0, FGe.compilePseudoSelector)(e, t, r, i, n);
      // Tags
      case Ja.SelectorType.Tag: {
        if (t.namespace != null)
          throw new Error("Namespaced tag names are not yet supported by css-select");
        var u = t.name;
        return (!r.xmlMode || r.lowerCaseTags) && (u = u.toLowerCase()), /* @__PURE__ */ s(function(p) {
          return a.getName(p) === u && e(p);
        }, "tag");
      }
      // Traversal
      case Ja.SelectorType.Descendant: {
        if (r.cacheResults === !1 || typeof WeakSet > "u")
          return /* @__PURE__ */ s(function(p) {
            for (var h = p; h = a.getParent(h); )
              if (a.isTag(h) && e(h))
                return !0;
            return !1;
          }, "descendant");
        var l = /* @__PURE__ */ new WeakSet();
        return /* @__PURE__ */ s(function(p) {
          for (var h = p; h = a.getParent(h); )
            if (!l.has(h)) {
              if (a.isTag(h) && e(h))
                return !0;
              l.add(h);
            }
          return !1;
        }, "cachedDescendant");
      }
      case "_flexibleDescendant":
        return /* @__PURE__ */ s(function(p) {
          var h = p;
          do
            if (a.isTag(h) && e(h))
              return !0;
          while (h = a.getParent(h));
          return !1;
        }, "flexibleDescendant");
      case Ja.SelectorType.Parent:
        return /* @__PURE__ */ s(function(p) {
          return a.getChildren(p).some(function(h) {
            return a.isTag(h) && e(h);
          });
        }, "parent");
      case Ja.SelectorType.Child:
        return /* @__PURE__ */ s(function(p) {
          var h = a.getParent(p);
          return h != null && a.isTag(h) && e(h);
        }, "child");
      case Ja.SelectorType.Sibling:
        return /* @__PURE__ */ s(function(p) {
          for (var h = a.getSiblings(p), y = 0; y < h.length; y++) {
            var _ = h[y];
            if (o(p, _))
              break;
            if (a.isTag(_) && e(_))
              return !0;
          }
          return !1;
        }, "sibling");
      case Ja.SelectorType.Adjacent:
        return a.prevElementSibling ? /* @__PURE__ */ s(function(p) {
          var h = a.prevElementSibling(p);
          return h != null && e(h);
        }, "adjacent") : /* @__PURE__ */ s(function(p) {
          for (var h = a.getSiblings(p), y, _ = 0; _ < h.length; _++) {
            var g = h[_];
            if (o(p, g))
              break;
            a.isTag(g) && (y = g);
          }
          return !!y && e(y);
        }, "adjacent");
      case Ja.SelectorType.Universal: {
        if (t.namespace != null && t.namespace !== "*")
          throw new Error("Namespaced universal selectors are not yet supported by css-select");
        return e;
      }
    }
  }
  s(MGe, "compileGeneralSelector");
  Wb.compileGeneralSelector = MGe;
});

// ../node_modules/renderkid/node_modules/css-select/lib/compile.js
var yG = b((Vo) => {
  "use strict";
  var BGe = Vo && Vo.__importDefault || function(e) {
    return e && e.__esModule ? e : { default: e };
  };
  Object.defineProperty(Vo, "__esModule", { value: !0 });
  Vo.compileToken = Vo.compileUnsafe = Vo.compile = void 0;
  var bw = rm(), xl = Tl(), qGe = BGe(Jz()), UGe = Mb(), jGe = pG(), hG = zb();
  function VGe(e, t, r) {
    var i = dG(e, t, r);
    return (0, hG.ensureIsTag)(i, t.adapter);
  }
  s(VGe, "compile");
  Vo.compile = VGe;
  function dG(e, t, r) {
    var i = typeof e == "string" ? (0, bw.parse)(e) : e;
    return vw(i, t, r);
  }
  s(dG, "compileUnsafe");
  Vo.compileUnsafe = dG;
  function mG(e) {
    return e.type === "pseudo" && (e.name === "scope" || Array.isArray(e.data) && e.data.some(function(t) {
      return t.some(mG);
    }));
  }
  s(mG, "includesScopePseudo");
  var KGe = { type: bw.SelectorType.Descendant }, HGe = {
    type: "_flexibleDescendant"
  }, zGe = {
    type: bw.SelectorType.Pseudo,
    name: "scope",
    data: null
  };
  function GGe(e, t, r) {
    for (var i = t.adapter, n = !!r?.every(function(l) {
      var c = i.isTag(l) && i.getParent(l);
      return l === hG.PLACEHOLDER_ELEMENT || c && i.isTag(c);
    }), a = 0, o = e; a < o.length; a++) {
      var u = o[a];
      if (!(u.length > 0 && (0, UGe.isTraversal)(u[0]) && u[0].type !== "descendant"))
        if (n && !u.some(mG))
          u.unshift(KGe);
        else
          continue;
      u.unshift(zGe);
    }
  }
  s(GGe, "absolutize");
  function vw(e, t, r) {
    var i;
    e = e.filter(function(l) {
      return l.length > 0;
    }), e.forEach(qGe.default), r = (i = t.context) !== null && i !== void 0 ? i : r;
    var n = Array.isArray(r), a = r && (Array.isArray(r) ? r : [r]);
    GGe(e, t, a);
    var o = !1, u = e.map(function(l) {
      if (l.length >= 2) {
        var c = l[0], p = l[1];
        c.type !== "pseudo" || c.name !== "scope" || (n && p.type === "descendant" ? l[1] = HGe : (p.type === "adjacent" || p.type === "sibl\
ing") && (o = !0));
      }
      return WGe(l, t, a);
    }).reduce($Ge, xl.falseFunc);
    return u.shouldTestNextSiblings = o, u;
  }
  s(vw, "compileToken");
  Vo.compileToken = vw;
  function WGe(e, t, r) {
    var i;
    return e.reduce(function(n, a) {
      return n === xl.falseFunc ? xl.falseFunc : (0, jGe.compileGeneralSelector)(n, a, t, r, vw);
    }, (i = t.rootFunc) !== null && i !== void 0 ? i : xl.trueFunc);
  }
  s(WGe, "compileRules");
  function $Ge(e, t) {
    return t === xl.falseFunc || e === xl.trueFunc ? e : e === xl.falseFunc || t === xl.trueFunc ? t : /* @__PURE__ */ s(function(i) {
      return e(i) || t(i);
    }, "combine");
  }
  s($Ge, "reduceRules");
});

// ../node_modules/renderkid/node_modules/css-select/lib/index.js
var TG = b((Dr) => {
  "use strict";
  var XGe = Dr && Dr.__createBinding || (Object.create ? function(e, t, r, i) {
    i === void 0 && (i = r);
    var n = Object.getOwnPropertyDescriptor(t, r);
    (!n || ("get" in n ? !t.__esModule : n.writable || n.configurable)) && (n = { enumerable: !0, get: /* @__PURE__ */ s(function() {
      return t[r];
    }, "get") }), Object.defineProperty(e, i, n);
  } : function(e, t, r, i) {
    i === void 0 && (i = r), e[i] = t[r];
  }), YGe = Dr && Dr.__setModuleDefault || (Object.create ? function(e, t) {
    Object.defineProperty(e, "default", { enumerable: !0, value: t });
  } : function(e, t) {
    e.default = t;
  }), JGe = Dr && Dr.__importStar || function(e) {
    if (e && e.__esModule) return e;
    var t = {};
    if (e != null) for (var r in e) r !== "default" && Object.prototype.hasOwnProperty.call(e, r) && XGe(t, e, r);
    return YGe(t, e), t;
  };
  Object.defineProperty(Dr, "__esModule", { value: !0 });
  Dr.aliases = Dr.pseudos = Dr.filters = Dr.is = Dr.selectOne = Dr.selectAll = Dr.prepareContext = Dr._compileToken = Dr._compileUnsafe = Dr.
  compile = void 0;
  var gG = JGe(mb()), _G = Tl(), im = yG(), QGe = zb(), bG = /* @__PURE__ */ s(function(e, t) {
    return e === t;
  }, "defaultEquals"), ZGe = {
    adapter: gG,
    equals: bG
  };
  function Sw(e) {
    var t, r, i, n, a = e ?? ZGe;
    return (t = a.adapter) !== null && t !== void 0 || (a.adapter = gG), (r = a.equals) !== null && r !== void 0 || (a.equals = (n = (i = a.
    adapter) === null || i === void 0 ? void 0 : i.equals) !== null && n !== void 0 ? n : bG), a;
  }
  s(Sw, "convertOptionFormats");
  function Tw(e) {
    return /* @__PURE__ */ s(function(r, i, n) {
      var a = Sw(i);
      return e(r, a, n);
    }, "addAdapter");
  }
  s(Tw, "wrapCompile");
  Dr.compile = Tw(im.compile);
  Dr._compileUnsafe = Tw(im.compileUnsafe);
  Dr._compileToken = Tw(im.compileToken);
  function vG(e) {
    return /* @__PURE__ */ s(function(r, i, n) {
      var a = Sw(n);
      typeof r != "function" && (r = (0, im.compileUnsafe)(r, a, i));
      var o = SG(i, a.adapter, r.shouldTestNextSiblings);
      return e(r, o, a);
    }, "select");
  }
  s(vG, "getSelectorFunc");
  function SG(e, t, r) {
    return r === void 0 && (r = !1), r && (e = eWe(e, t)), Array.isArray(e) ? t.removeSubsets(e) : t.getChildren(e);
  }
  s(SG, "prepareContext");
  Dr.prepareContext = SG;
  function eWe(e, t) {
    for (var r = Array.isArray(e) ? e.slice(0) : [e], i = r.length, n = 0; n < i; n++) {
      var a = (0, QGe.getNextSiblings)(r[n], t);
      r.push.apply(r, a);
    }
    return r;
  }
  s(eWe, "appendNextSiblings");
  Dr.selectAll = vG(function(e, t, r) {
    return e === _G.falseFunc || !t || t.length === 0 ? [] : r.adapter.findAll(e, t);
  });
  Dr.selectOne = vG(function(e, t, r) {
    return e === _G.falseFunc || !t || t.length === 0 ? null : r.adapter.findOne(e, t);
  });
  function tWe(e, t, r) {
    var i = Sw(r);
    return (typeof t == "function" ? t : (0, im.compile)(t, i))(e);
  }
  s(tWe, "is");
  Dr.is = tWe;
  Dr.default = Dr.selectAll;
  var Ew = _w();
  Object.defineProperty(Dr, "filters", { enumerable: !0, get: /* @__PURE__ */ s(function() {
    return Ew.filters;
  }, "get") });
  Object.defineProperty(Dr, "pseudos", { enumerable: !0, get: /* @__PURE__ */ s(function() {
    return Ew.pseudos;
  }, "get") });
  Object.defineProperty(Dr, "aliases", { enumerable: !0, get: /* @__PURE__ */ s(function() {
    return Ew.aliases;
  }, "get") });
});

// ../node_modules/renderkid/lib/renderKid/styles/rule/Selector.js
var xG = b((_It, AG) => {
  "use strict";
  function rWe(e, t) {
    if (!(e instanceof t))
      throw new TypeError("Cannot call a class as a function");
  }
  s(rWe, "_classCallCheck");
  function EG(e, t) {
    for (var r = 0; r < t.length; r++) {
      var i = t[r];
      i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);
    }
  }
  s(EG, "_defineProperties");
  function iWe(e, t, r) {
    return t && EG(e.prototype, t), r && EG(e, r), e;
  }
  s(iWe, "_createClass");
  var Aw, nWe;
  Aw = TG();
  AG.exports = nWe = function() {
    var e, t = /* @__PURE__ */ function() {
      function r(i) {
        rWe(this, r), this.text = i, this._fn = Aw.compile(this.text), this.priority = e.calculatePriority(this.text);
      }
      return s(r, "Selector"), iWe(r, [{
        key: "matches",
        value: /* @__PURE__ */ s(function(n) {
          return Aw.is(n, this._fn);
        }, "matches")
        // This stupid piece of code is supposed to calculate
        // selector priority, somehow according to
        // http://www.w3.org/wiki/CSS/Training/Priority_level_of_selector
      }], [{
        key: "calculatePriority",
        value: /* @__PURE__ */ s(function(n) {
          var a, o;
          return o = 0, (a = n.match(/[\#]{1}/g)) && (o += 100 * a.length), (a = n.match(/[a-zA-Z]+/g)) && (o += 2 * a.length), (a = n.match(
          /\*/g)) && (o += 1 * a.length), o;
        }, "calculatePriority")
      }]), r;
    }();
    return e = t, t;
  }.call(void 0);
});

// ../node_modules/renderkid/lib/renderKid/styles/rule/declarationBlock/_Declaration.js
var wu = b((vIt, PG) => {
  "use strict";
  function sWe(e, t) {
    if (!(e instanceof t))
      throw new TypeError("Cannot call a class as a function");
  }
  s(sWe, "_classCallCheck");
  function CG(e, t) {
    for (var r = 0; r < t.length; r++) {
      var i = t[r];
      i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);
    }
  }
  s(CG, "_defineProperties");
  function aWe(e, t, r) {
    return t && CG(e.prototype, t), r && CG(e, r), e;
  }
  s(aWe, "_createClass");
  var oWe;
  PG.exports = oWe = function() {
    var e, t = /* @__PURE__ */ function() {
      function r(i, n) {
        sWe(this, r), this.prop = i, this.important = !1, this.set(n);
      }
      return s(r, "_Declaration"), aWe(r, [{
        key: "get",
        value: /* @__PURE__ */ s(function() {
          return this._get();
        }, "get")
      }, {
        key: "_get",
        value: /* @__PURE__ */ s(function() {
          return this.val;
        }, "_get")
      }, {
        key: "_pickImportantClause",
        value: /* @__PURE__ */ s(function(n) {
          return e.importantClauseRx.test(String(n)) ? (this.important = !0, n.replace(e.importantClauseRx, "")) : (this.important = !1, n);
        }, "_pickImportantClause")
      }, {
        key: "set",
        value: /* @__PURE__ */ s(function(n) {
          return n = e.sanitizeValue(n), n = this._pickImportantClause(n), n = n.trim(), this._handleNullOrInherit(n) ? this : (this._set(n),
          this);
        }, "set")
      }, {
        key: "_set",
        value: /* @__PURE__ */ s(function(n) {
          return this.val = n;
        }, "_set")
      }, {
        key: "_handleNullOrInherit",
        value: /* @__PURE__ */ s(function(n) {
          if (n === "")
            return this.val = "", !0;
          if (n === "inherit") {
            if (this.constructor.inheritAllowed)
              this.val = "inherit";
            else
              throw Error("Inherit is not allowed for `".concat(this.prop, "`"));
            return !0;
          } else
            return !1;
        }, "_handleNullOrInherit")
      }], [{
        key: "setOnto",
        value: /* @__PURE__ */ s(function(n, a, o) {
          var u;
          return (u = n[a]) ? u.set(o) : n[a] = new this(a, o);
        }, "setOnto")
      }, {
        key: "sanitizeValue",
        value: /* @__PURE__ */ s(function(n) {
          return String(n).trim().replace(/[\s]+/g, " ");
        }, "sanitizeValue")
      }]), r;
    }();
    return e = t, t.importantClauseRx = /(\s\!important)$/, t.inheritAllowed = !1, t;
  }.call(void 0);
});

// ../node_modules/renderkid/lib/renderKid/styles/rule/declarationBlock/Arbitrary.js
var OG = b((TIt, wG) => {
  "use strict";
  function $b(e) {
    "@babel/helpers - typeof";
    return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? $b = /* @__PURE__ */ s(function(r) {
      return typeof r;
    }, "_typeof") : $b = /* @__PURE__ */ s(function(r) {
      return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
    }, "_typeof"), $b(e);
  }
  s($b, "_typeof");
  function uWe(e, t) {
    if (!(e instanceof t))
      throw new TypeError("Cannot call a class as a function");
  }
  s(uWe, "_classCallCheck");
  function lWe(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Super expression must either be null or a function");
    e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), t && xw(e, t);
  }
  s(lWe, "_inherits");
  function xw(e, t) {
    return xw = Object.setPrototypeOf || /* @__PURE__ */ s(function(i, n) {
      return i.__proto__ = n, i;
    }, "_setPrototypeOf"), xw(e, t);
  }
  s(xw, "_setPrototypeOf");
  function cWe(e) {
    var t = hWe();
    return /* @__PURE__ */ s(function() {
      var i = Xb(e), n;
      if (t) {
        var a = Xb(this).constructor;
        n = Reflect.construct(i, arguments, a);
      } else
        n = i.apply(this, arguments);
      return fWe(this, n);
    }, "_createSuperInternal");
  }
  s(cWe, "_createSuper");
  function fWe(e, t) {
    return t && ($b(t) === "object" || typeof t == "function") ? t : pWe(e);
  }
  s(fWe, "_possibleConstructorReturn");
  function pWe(e) {
    if (e === void 0)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e;
  }
  s(pWe, "_assertThisInitialized");
  function hWe() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
    if (typeof Proxy == "function") return !0;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      })), !0;
    } catch {
      return !1;
    }
  }
  s(hWe, "_isNativeReflectConstruct");
  function Xb(e) {
    return Xb = Object.setPrototypeOf ? Object.getPrototypeOf : /* @__PURE__ */ s(function(r) {
      return r.__proto__ || Object.getPrototypeOf(r);
    }, "_getPrototypeOf"), Xb(e);
  }
  s(Xb, "_getPrototypeOf");
  var dWe, DG;
  DG = wu();
  wG.exports = dWe = /* @__PURE__ */ function(e) {
    lWe(r, e);
    var t = cWe(r);
    function r() {
      return uWe(this, r), t.apply(this, arguments);
    }
    return s(r, "Arbitrary"), r;
  }(DG);
});

// ../node_modules/renderkid/lib/renderKid/styles/rule/declarationBlock/Color.js
var RG = b((AIt, IG) => {
  "use strict";
  function Yb(e) {
    "@babel/helpers - typeof";
    return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Yb = /* @__PURE__ */ s(function(r) {
      return typeof r;
    }, "_typeof") : Yb = /* @__PURE__ */ s(function(r) {
      return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
    }, "_typeof"), Yb(e);
  }
  s(Yb, "_typeof");
  function mWe(e, t) {
    if (!(e instanceof t))
      throw new TypeError("Cannot call a class as a function");
  }
  s(mWe, "_classCallCheck");
  function yWe(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Super expression must either be null or a function");
    e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), t && Cw(e, t);
  }
  s(yWe, "_inherits");
  function Cw(e, t) {
    return Cw = Object.setPrototypeOf || /* @__PURE__ */ s(function(i, n) {
      return i.__proto__ = n, i;
    }, "_setPrototypeOf"), Cw(e, t);
  }
  s(Cw, "_setPrototypeOf");
  function gWe(e) {
    var t = vWe();
    return /* @__PURE__ */ s(function() {
      var i = Jb(e), n;
      if (t) {
        var a = Jb(this).constructor;
        n = Reflect.construct(i, arguments, a);
      } else
        n = i.apply(this, arguments);
      return _We(this, n);
    }, "_createSuperInternal");
  }
  s(gWe, "_createSuper");
  function _We(e, t) {
    return t && (Yb(t) === "object" || typeof t == "function") ? t : bWe(e);
  }
  s(_We, "_possibleConstructorReturn");
  function bWe(e) {
    if (e === void 0)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e;
  }
  s(bWe, "_assertThisInitialized");
  function vWe() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
    if (typeof Proxy == "function") return !0;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      })), !0;
    } catch {
      return !1;
    }
  }
  s(vWe, "_isNativeReflectConstruct");
  function Jb(e) {
    return Jb = Object.setPrototypeOf ? Object.getPrototypeOf : /* @__PURE__ */ s(function(r) {
      return r.__proto__ || Object.getPrototypeOf(r);
    }, "_getPrototypeOf"), Jb(e);
  }
  s(Jb, "_getPrototypeOf");
  var SWe, kG;
  kG = wu();
  IG.exports = SWe = /* @__PURE__ */ function(e) {
    yWe(r, e);
    var t = gWe(r);
    function r() {
      return mWe(this, r), t.apply(this, arguments);
    }
    return s(r, "Color"), r;
  }(kG);
});

// ../node_modules/renderkid/lib/renderKid/styles/rule/declarationBlock/Background.js
var FG = b((CIt, LG) => {
  "use strict";
  function Qb(e) {
    "@babel/helpers - typeof";
    return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Qb = /* @__PURE__ */ s(function(r) {
      return typeof r;
    }, "_typeof") : Qb = /* @__PURE__ */ s(function(r) {
      return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
    }, "_typeof"), Qb(e);
  }
  s(Qb, "_typeof");
  function TWe(e, t) {
    if (!(e instanceof t))
      throw new TypeError("Cannot call a class as a function");
  }
  s(TWe, "_classCallCheck");
  function EWe(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Super expression must either be null or a function");
    e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), t && Pw(e, t);
  }
  s(EWe, "_inherits");
  function Pw(e, t) {
    return Pw = Object.setPrototypeOf || /* @__PURE__ */ s(function(i, n) {
      return i.__proto__ = n, i;
    }, "_setPrototypeOf"), Pw(e, t);
  }
  s(Pw, "_setPrototypeOf");
  function AWe(e) {
    var t = PWe();
    return /* @__PURE__ */ s(function() {
      var i = Zb(e), n;
      if (t) {
        var a = Zb(this).constructor;
        n = Reflect.construct(i, arguments, a);
      } else
        n = i.apply(this, arguments);
      return xWe(this, n);
    }, "_createSuperInternal");
  }
  s(AWe, "_createSuper");
  function xWe(e, t) {
    return t && (Qb(t) === "object" || typeof t == "function") ? t : CWe(e);
  }
  s(xWe, "_possibleConstructorReturn");
  function CWe(e) {
    if (e === void 0)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e;
  }
  s(CWe, "_assertThisInitialized");
  function PWe() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
    if (typeof Proxy == "function") return !0;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      })), !0;
    } catch {
      return !1;
    }
  }
  s(PWe, "_isNativeReflectConstruct");
  function Zb(e) {
    return Zb = Object.setPrototypeOf ? Object.getPrototypeOf : /* @__PURE__ */ s(function(r) {
      return r.__proto__ || Object.getPrototypeOf(r);
    }, "_getPrototypeOf"), Zb(e);
  }
  s(Zb, "_getPrototypeOf");
  var DWe, NG;
  NG = wu();
  LG.exports = DWe = /* @__PURE__ */ function(e) {
    EWe(r, e);
    var t = AWe(r);
    function r() {
      return TWe(this, r), t.apply(this, arguments);
    }
    return s(r, "Background"), r;
  }(NG);
});

// ../node_modules/renderkid/lib/renderKid/styles/rule/declarationBlock/_Length.js
var Qa = b((DIt, qG) => {
  "use strict";
  function ev(e) {
    "@babel/helpers - typeof";
    return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? ev = /* @__PURE__ */ s(function(r) {
      return typeof r;
    }, "_typeof") : ev = /* @__PURE__ */ s(function(r) {
      return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
    }, "_typeof"), ev(e);
  }
  s(ev, "_typeof");
  function wWe(e, t) {
    if (!(e instanceof t))
      throw new TypeError("Cannot call a class as a function");
  }
  s(wWe, "_classCallCheck");
  function MG(e, t) {
    for (var r = 0; r < t.length; r++) {
      var i = t[r];
      i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);
    }
  }
  s(MG, "_defineProperties");
  function OWe(e, t, r) {
    return t && MG(e.prototype, t), r && MG(e, r), e;
  }
  s(OWe, "_createClass");
  function kWe(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Super expression must either be null or a function");
    e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), t && Dw(e, t);
  }
  s(kWe, "_inherits");
  function Dw(e, t) {
    return Dw = Object.setPrototypeOf || /* @__PURE__ */ s(function(i, n) {
      return i.__proto__ = n, i;
    }, "_setPrototypeOf"), Dw(e, t);
  }
  s(Dw, "_setPrototypeOf");
  function IWe(e) {
    var t = LWe();
    return /* @__PURE__ */ s(function() {
      var i = tv(e), n;
      if (t) {
        var a = tv(this).constructor;
        n = Reflect.construct(i, arguments, a);
      } else
        n = i.apply(this, arguments);
      return RWe(this, n);
    }, "_createSuperInternal");
  }
  s(IWe, "_createSuper");
  function RWe(e, t) {
    return t && (ev(t) === "object" || typeof t == "function") ? t : NWe(e);
  }
  s(RWe, "_possibleConstructorReturn");
  function NWe(e) {
    if (e === void 0)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e;
  }
  s(NWe, "_assertThisInitialized");
  function LWe() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
    if (typeof Proxy == "function") return !0;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      })), !0;
    } catch {
      return !1;
    }
  }
  s(LWe, "_isNativeReflectConstruct");
  function tv(e) {
    return tv = Object.setPrototypeOf ? Object.getPrototypeOf : /* @__PURE__ */ s(function(r) {
      return r.__proto__ || Object.getPrototypeOf(r);
    }, "_getPrototypeOf"), tv(e);
  }
  s(tv, "_getPrototypeOf");
  var BG, FWe;
  BG = wu();
  qG.exports = FWe = /* @__PURE__ */ function(e) {
    kWe(r, e);
    var t = IWe(r);
    function r() {
      return wWe(this, r), t.apply(this, arguments);
    }
    return s(r, "_Length"), OWe(r, [{
      key: "_set",
      value: /* @__PURE__ */ s(function(n) {
        if (!/^[0-9]+$/.test(String(n)))
          throw Error("`".concat(this.prop, "` only takes an integer for value"));
        return this.val = parseInt(n);
      }, "_set")
    }]), r;
  }(BG);
});

// ../node_modules/renderkid/lib/renderKid/styles/rule/declarationBlock/Width.js
var VG = b((OIt, jG) => {
  "use strict";
  function rv(e) {
    "@babel/helpers - typeof";
    return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? rv = /* @__PURE__ */ s(function(r) {
      return typeof r;
    }, "_typeof") : rv = /* @__PURE__ */ s(function(r) {
      return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
    }, "_typeof"), rv(e);
  }
  s(rv, "_typeof");
  function MWe(e, t) {
    if (!(e instanceof t))
      throw new TypeError("Cannot call a class as a function");
  }
  s(MWe, "_classCallCheck");
  function BWe(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Super expression must either be null or a function");
    e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), t && ww(e, t);
  }
  s(BWe, "_inherits");
  function ww(e, t) {
    return ww = Object.setPrototypeOf || /* @__PURE__ */ s(function(i, n) {
      return i.__proto__ = n, i;
    }, "_setPrototypeOf"), ww(e, t);
  }
  s(ww, "_setPrototypeOf");
  function qWe(e) {
    var t = VWe();
    return /* @__PURE__ */ s(function() {
      var i = iv(e), n;
      if (t) {
        var a = iv(this).constructor;
        n = Reflect.construct(i, arguments, a);
      } else
        n = i.apply(this, arguments);
      return UWe(this, n);
    }, "_createSuperInternal");
  }
  s(qWe, "_createSuper");
  function UWe(e, t) {
    return t && (rv(t) === "object" || typeof t == "function") ? t : jWe(e);
  }
  s(UWe, "_possibleConstructorReturn");
  function jWe(e) {
    if (e === void 0)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e;
  }
  s(jWe, "_assertThisInitialized");
  function VWe() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
    if (typeof Proxy == "function") return !0;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      })), !0;
    } catch {
      return !1;
    }
  }
  s(VWe, "_isNativeReflectConstruct");
  function iv(e) {
    return iv = Object.setPrototypeOf ? Object.getPrototypeOf : /* @__PURE__ */ s(function(r) {
      return r.__proto__ || Object.getPrototypeOf(r);
    }, "_getPrototypeOf"), iv(e);
  }
  s(iv, "_getPrototypeOf");
  var KWe, UG;
  UG = Qa();
  jG.exports = KWe = /* @__PURE__ */ function(e) {
    BWe(r, e);
    var t = qWe(r);
    function r() {
      return MWe(this, r), t.apply(this, arguments);
    }
    return s(r, "Width"), r;
  }(UG);
});

// ../node_modules/renderkid/lib/renderKid/styles/rule/declarationBlock/Height.js
var zG = b((IIt, HG) => {
  "use strict";
  function nv(e) {
    "@babel/helpers - typeof";
    return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? nv = /* @__PURE__ */ s(function(r) {
      return typeof r;
    }, "_typeof") : nv = /* @__PURE__ */ s(function(r) {
      return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
    }, "_typeof"), nv(e);
  }
  s(nv, "_typeof");
  function HWe(e, t) {
    if (!(e instanceof t))
      throw new TypeError("Cannot call a class as a function");
  }
  s(HWe, "_classCallCheck");
  function zWe(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Super expression must either be null or a function");
    e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), t && Ow(e, t);
  }
  s(zWe, "_inherits");
  function Ow(e, t) {
    return Ow = Object.setPrototypeOf || /* @__PURE__ */ s(function(i, n) {
      return i.__proto__ = n, i;
    }, "_setPrototypeOf"), Ow(e, t);
  }
  s(Ow, "_setPrototypeOf");
  function GWe(e) {
    var t = XWe();
    return /* @__PURE__ */ s(function() {
      var i = sv(e), n;
      if (t) {
        var a = sv(this).constructor;
        n = Reflect.construct(i, arguments, a);
      } else
        n = i.apply(this, arguments);
      return WWe(this, n);
    }, "_createSuperInternal");
  }
  s(GWe, "_createSuper");
  function WWe(e, t) {
    return t && (nv(t) === "object" || typeof t == "function") ? t : $We(e);
  }
  s(WWe, "_possibleConstructorReturn");
  function $We(e) {
    if (e === void 0)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e;
  }
  s($We, "_assertThisInitialized");
  function XWe() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
    if (typeof Proxy == "function") return !0;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      })), !0;
    } catch {
      return !1;
    }
  }
  s(XWe, "_isNativeReflectConstruct");
  function sv(e) {
    return sv = Object.setPrototypeOf ? Object.getPrototypeOf : /* @__PURE__ */ s(function(r) {
      return r.__proto__ || Object.getPrototypeOf(r);
    }, "_getPrototypeOf"), sv(e);
  }
  s(sv, "_getPrototypeOf");
  var YWe, KG;
  KG = Qa();
  HG.exports = YWe = /* @__PURE__ */ function(e) {
    zWe(r, e);
    var t = GWe(r);
    function r() {
      return HWe(this, r), t.apply(this, arguments);
    }
    return s(r, "Height"), r;
  }(KG);
});

// ../node_modules/renderkid/lib/renderKid/styles/rule/declarationBlock/Bullet.js
var XG = b((NIt, $G) => {
  "use strict";
  function av(e) {
    "@babel/helpers - typeof";
    return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? av = /* @__PURE__ */ s(function(r) {
      return typeof r;
    }, "_typeof") : av = /* @__PURE__ */ s(function(r) {
      return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
    }, "_typeof"), av(e);
  }
  s(av, "_typeof");
  function JWe(e, t) {
    if (!(e instanceof t))
      throw new TypeError("Cannot call a class as a function");
  }
  s(JWe, "_classCallCheck");
  function GG(e, t) {
    for (var r = 0; r < t.length; r++) {
      var i = t[r];
      i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);
    }
  }
  s(GG, "_defineProperties");
  function QWe(e, t, r) {
    return t && GG(e.prototype, t), r && GG(e, r), e;
  }
  s(QWe, "_createClass");
  function ZWe(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Super expression must either be null or a function");
    e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), t && kw(e, t);
  }
  s(ZWe, "_inherits");
  function kw(e, t) {
    return kw = Object.setPrototypeOf || /* @__PURE__ */ s(function(i, n) {
      return i.__proto__ = n, i;
    }, "_setPrototypeOf"), kw(e, t);
  }
  s(kw, "_setPrototypeOf");
  function e$e(e) {
    var t = i$e();
    return /* @__PURE__ */ s(function() {
      var i = ov(e), n;
      if (t) {
        var a = ov(this).constructor;
        n = Reflect.construct(i, arguments, a);
      } else
        n = i.apply(this, arguments);
      return t$e(this, n);
    }, "_createSuperInternal");
  }
  s(e$e, "_createSuper");
  function t$e(e, t) {
    return t && (av(t) === "object" || typeof t == "function") ? t : r$e(e);
  }
  s(t$e, "_possibleConstructorReturn");
  function r$e(e) {
    if (e === void 0)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e;
  }
  s(r$e, "_assertThisInitialized");
  function i$e() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
    if (typeof Proxy == "function") return !0;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      })), !0;
    } catch {
      return !1;
    }
  }
  s(i$e, "_isNativeReflectConstruct");
  function ov(e) {
    return ov = Object.setPrototypeOf ? Object.getPrototypeOf : /* @__PURE__ */ s(function(r) {
      return r.__proto__ || Object.getPrototypeOf(r);
    }, "_getPrototypeOf"), ov(e);
  }
  s(ov, "_getPrototypeOf");
  var n$e, WG;
  WG = wu();
  $G.exports = n$e = function() {
    var e, t = /* @__PURE__ */ function(r) {
      ZWe(n, r);
      var i = e$e(n);
      function n() {
        return JWe(this, n), i.apply(this, arguments);
      }
      return s(n, "Bullet"), QWe(n, [{
        key: "_set",
        value: /* @__PURE__ */ s(function(o) {
          var u, l, c, p, h, y, _;
          if (o = String(o), _ = o, c = null, h = !1, p = "none", l = "none", (y = o.match(/\"([^"]+)\"/) || (y = o.match(/\'([^']+)\'/))) &&
          (c = y[1], o = o.replace(y[0], ""), h = !0), (y = o.match(/(none|left|right|center)/)) ? (u = y[1], o = o.replace(y[0], "")) : u =
          "left", u === "none" && (h = !1), (y = o.match(/color\:([\w\-]+)/)) && (p = y[1], o = o.replace(y[0], "")), (y = o.match(/bg\:([\w\-]+)/)) &&
          (l = y[1], o = o.replace(y[0], "")), o.trim() !== "")
            throw Error("Unrecognizable value `".concat(_, "` for `").concat(this.prop, "`"));
          return this.val = {
            enabled: h,
            char: c,
            alignment: u,
            background: l,
            color: p
          };
        }, "_set")
      }]), n;
    }(WG);
    return e = t, t;
  }.call(void 0);
});

// ../node_modules/renderkid/lib/renderKid/styles/rule/declarationBlock/Display.js
var ZG = b((FIt, QG) => {
  "use strict";
  function uv(e) {
    "@babel/helpers - typeof";
    return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? uv = /* @__PURE__ */ s(function(r) {
      return typeof r;
    }, "_typeof") : uv = /* @__PURE__ */ s(function(r) {
      return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
    }, "_typeof"), uv(e);
  }
  s(uv, "_typeof");
  function s$e(e, t) {
    if (!(e instanceof t))
      throw new TypeError("Cannot call a class as a function");
  }
  s(s$e, "_classCallCheck");
  function YG(e, t) {
    for (var r = 0; r < t.length; r++) {
      var i = t[r];
      i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);
    }
  }
  s(YG, "_defineProperties");
  function a$e(e, t, r) {
    return t && YG(e.prototype, t), r && YG(e, r), e;
  }
  s(a$e, "_createClass");
  function o$e(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Super expression must either be null or a function");
    e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), t && Iw(e, t);
  }
  s(o$e, "_inherits");
  function Iw(e, t) {
    return Iw = Object.setPrototypeOf || /* @__PURE__ */ s(function(i, n) {
      return i.__proto__ = n, i;
    }, "_setPrototypeOf"), Iw(e, t);
  }
  s(Iw, "_setPrototypeOf");
  function u$e(e) {
    var t = f$e();
    return /* @__PURE__ */ s(function() {
      var i = lv(e), n;
      if (t) {
        var a = lv(this).constructor;
        n = Reflect.construct(i, arguments, a);
      } else
        n = i.apply(this, arguments);
      return l$e(this, n);
    }, "_createSuperInternal");
  }
  s(u$e, "_createSuper");
  function l$e(e, t) {
    return t && (uv(t) === "object" || typeof t == "function") ? t : c$e(e);
  }
  s(l$e, "_possibleConstructorReturn");
  function c$e(e) {
    if (e === void 0)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e;
  }
  s(c$e, "_assertThisInitialized");
  function f$e() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
    if (typeof Proxy == "function") return !0;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      })), !0;
    } catch {
      return !1;
    }
  }
  s(f$e, "_isNativeReflectConstruct");
  function lv(e) {
    return lv = Object.setPrototypeOf ? Object.getPrototypeOf : /* @__PURE__ */ s(function(r) {
      return r.__proto__ || Object.getPrototypeOf(r);
    }, "_getPrototypeOf"), lv(e);
  }
  s(lv, "_getPrototypeOf");
  var p$e, JG, h$e = [].indexOf;
  JG = wu();
  QG.exports = p$e = function() {
    var e, t = /* @__PURE__ */ function(r) {
      o$e(n, r);
      var i = u$e(n);
      function n() {
        return s$e(this, n), i.apply(this, arguments);
      }
      return s(n, "Display"), a$e(n, [{
        key: "_set",
        value: /* @__PURE__ */ s(function(o) {
          if (o = String(o).toLowerCase(), h$e.call(e._allowed, o) < 0)
            throw Error("Unrecognizable value `".concat(o, "` for `").concat(this.prop, "`"));
          return this.val = o;
        }, "_set")
      }]), n;
    }(JG);
    return e = t, t._allowed = ["inline", "block", "none"], t;
  }.call(void 0);
});

// ../node_modules/renderkid/lib/renderKid/styles/rule/declarationBlock/MarginTop.js
var Nw = b((BIt, tW) => {
  "use strict";
  function cv(e) {
    "@babel/helpers - typeof";
    return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? cv = /* @__PURE__ */ s(function(r) {
      return typeof r;
    }, "_typeof") : cv = /* @__PURE__ */ s(function(r) {
      return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
    }, "_typeof"), cv(e);
  }
  s(cv, "_typeof");
  function d$e(e, t) {
    if (!(e instanceof t))
      throw new TypeError("Cannot call a class as a function");
  }
  s(d$e, "_classCallCheck");
  function m$e(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Super expression must either be null or a function");
    e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), t && Rw(e, t);
  }
  s(m$e, "_inherits");
  function Rw(e, t) {
    return Rw = Object.setPrototypeOf || /* @__PURE__ */ s(function(i, n) {
      return i.__proto__ = n, i;
    }, "_setPrototypeOf"), Rw(e, t);
  }
  s(Rw, "_setPrototypeOf");
  function y$e(e) {
    var t = b$e();
    return /* @__PURE__ */ s(function() {
      var i = fv(e), n;
      if (t) {
        var a = fv(this).constructor;
        n = Reflect.construct(i, arguments, a);
      } else
        n = i.apply(this, arguments);
      return g$e(this, n);
    }, "_createSuperInternal");
  }
  s(y$e, "_createSuper");
  function g$e(e, t) {
    return t && (cv(t) === "object" || typeof t == "function") ? t : _$e(e);
  }
  s(g$e, "_possibleConstructorReturn");
  function _$e(e) {
    if (e === void 0)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e;
  }
  s(_$e, "_assertThisInitialized");
  function b$e() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
    if (typeof Proxy == "function") return !0;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      })), !0;
    } catch {
      return !1;
    }
  }
  s(b$e, "_isNativeReflectConstruct");
  function fv(e) {
    return fv = Object.setPrototypeOf ? Object.getPrototypeOf : /* @__PURE__ */ s(function(r) {
      return r.__proto__ || Object.getPrototypeOf(r);
    }, "_getPrototypeOf"), fv(e);
  }
  s(fv, "_getPrototypeOf");
  var v$e, eW;
  eW = Qa();
  tW.exports = v$e = /* @__PURE__ */ function(e) {
    m$e(r, e);
    var t = y$e(r);
    function r() {
      return d$e(this, r), t.apply(this, arguments);
    }
    return s(r, "MarginTop"), r;
  }(eW);
});

// ../node_modules/renderkid/lib/renderKid/styles/rule/declarationBlock/MarginLeft.js
var Fw = b((UIt, iW) => {
  "use strict";
  function pv(e) {
    "@babel/helpers - typeof";
    return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? pv = /* @__PURE__ */ s(function(r) {
      return typeof r;
    }, "_typeof") : pv = /* @__PURE__ */ s(function(r) {
      return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
    }, "_typeof"), pv(e);
  }
  s(pv, "_typeof");
  function S$e(e, t) {
    if (!(e instanceof t))
      throw new TypeError("Cannot call a class as a function");
  }
  s(S$e, "_classCallCheck");
  function T$e(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Super expression must either be null or a function");
    e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), t && Lw(e, t);
  }
  s(T$e, "_inherits");
  function Lw(e, t) {
    return Lw = Object.setPrototypeOf || /* @__PURE__ */ s(function(i, n) {
      return i.__proto__ = n, i;
    }, "_setPrototypeOf"), Lw(e, t);
  }
  s(Lw, "_setPrototypeOf");
  function E$e(e) {
    var t = C$e();
    return /* @__PURE__ */ s(function() {
      var i = hv(e), n;
      if (t) {
        var a = hv(this).constructor;
        n = Reflect.construct(i, arguments, a);
      } else
        n = i.apply(this, arguments);
      return A$e(this, n);
    }, "_createSuperInternal");
  }
  s(E$e, "_createSuper");
  function A$e(e, t) {
    return t && (pv(t) === "object" || typeof t == "function") ? t : x$e(e);
  }
  s(A$e, "_possibleConstructorReturn");
  function x$e(e) {
    if (e === void 0)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e;
  }
  s(x$e, "_assertThisInitialized");
  function C$e() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
    if (typeof Proxy == "function") return !0;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      })), !0;
    } catch {
      return !1;
    }
  }
  s(C$e, "_isNativeReflectConstruct");
  function hv(e) {
    return hv = Object.setPrototypeOf ? Object.getPrototypeOf : /* @__PURE__ */ s(function(r) {
      return r.__proto__ || Object.getPrototypeOf(r);
    }, "_getPrototypeOf"), hv(e);
  }
  s(hv, "_getPrototypeOf");
  var P$e, rW;
  rW = Qa();
  iW.exports = P$e = /* @__PURE__ */ function(e) {
    T$e(r, e);
    var t = E$e(r);
    function r() {
      return S$e(this, r), t.apply(this, arguments);
    }
    return s(r, "MarginLeft"), r;
  }(rW);
});

// ../node_modules/renderkid/lib/renderKid/styles/rule/declarationBlock/MarginRight.js
var Bw = b((VIt, sW) => {
  "use strict";
  function dv(e) {
    "@babel/helpers - typeof";
    return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? dv = /* @__PURE__ */ s(function(r) {
      return typeof r;
    }, "_typeof") : dv = /* @__PURE__ */ s(function(r) {
      return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
    }, "_typeof"), dv(e);
  }
  s(dv, "_typeof");
  function D$e(e, t) {
    if (!(e instanceof t))
      throw new TypeError("Cannot call a class as a function");
  }
  s(D$e, "_classCallCheck");
  function w$e(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Super expression must either be null or a function");
    e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), t && Mw(e, t);
  }
  s(w$e, "_inherits");
  function Mw(e, t) {
    return Mw = Object.setPrototypeOf || /* @__PURE__ */ s(function(i, n) {
      return i.__proto__ = n, i;
    }, "_setPrototypeOf"), Mw(e, t);
  }
  s(Mw, "_setPrototypeOf");
  function O$e(e) {
    var t = R$e();
    return /* @__PURE__ */ s(function() {
      var i = mv(e), n;
      if (t) {
        var a = mv(this).constructor;
        n = Reflect.construct(i, arguments, a);
      } else
        n = i.apply(this, arguments);
      return k$e(this, n);
    }, "_createSuperInternal");
  }
  s(O$e, "_createSuper");
  function k$e(e, t) {
    return t && (dv(t) === "object" || typeof t == "function") ? t : I$e(e);
  }
  s(k$e, "_possibleConstructorReturn");
  function I$e(e) {
    if (e === void 0)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e;
  }
  s(I$e, "_assertThisInitialized");
  function R$e() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
    if (typeof Proxy == "function") return !0;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      })), !0;
    } catch {
      return !1;
    }
  }
  s(R$e, "_isNativeReflectConstruct");
  function mv(e) {
    return mv = Object.setPrototypeOf ? Object.getPrototypeOf : /* @__PURE__ */ s(function(r) {
      return r.__proto__ || Object.getPrototypeOf(r);
    }, "_getPrototypeOf"), mv(e);
  }
  s(mv, "_getPrototypeOf");
  var N$e, nW;
  nW = Qa();
  sW.exports = N$e = /* @__PURE__ */ function(e) {
    w$e(r, e);
    var t = O$e(r);
    function r() {
      return D$e(this, r), t.apply(this, arguments);
    }
    return s(r, "MarginRight"), r;
  }(nW);
});

// ../node_modules/renderkid/lib/renderKid/styles/rule/declarationBlock/MarginBottom.js
var Uw = b((HIt, oW) => {
  "use strict";
  function yv(e) {
    "@babel/helpers - typeof";
    return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? yv = /* @__PURE__ */ s(function(r) {
      return typeof r;
    }, "_typeof") : yv = /* @__PURE__ */ s(function(r) {
      return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
    }, "_typeof"), yv(e);
  }
  s(yv, "_typeof");
  function L$e(e, t) {
    if (!(e instanceof t))
      throw new TypeError("Cannot call a class as a function");
  }
  s(L$e, "_classCallCheck");
  function F$e(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Super expression must either be null or a function");
    e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), t && qw(e, t);
  }
  s(F$e, "_inherits");
  function qw(e, t) {
    return qw = Object.setPrototypeOf || /* @__PURE__ */ s(function(i, n) {
      return i.__proto__ = n, i;
    }, "_setPrototypeOf"), qw(e, t);
  }
  s(qw, "_setPrototypeOf");
  function M$e(e) {
    var t = U$e();
    return /* @__PURE__ */ s(function() {
      var i = gv(e), n;
      if (t) {
        var a = gv(this).constructor;
        n = Reflect.construct(i, arguments, a);
      } else
        n = i.apply(this, arguments);
      return B$e(this, n);
    }, "_createSuperInternal");
  }
  s(M$e, "_createSuper");
  function B$e(e, t) {
    return t && (yv(t) === "object" || typeof t == "function") ? t : q$e(e);
  }
  s(B$e, "_possibleConstructorReturn");
  function q$e(e) {
    if (e === void 0)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e;
  }
  s(q$e, "_assertThisInitialized");
  function U$e() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
    if (typeof Proxy == "function") return !0;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      })), !0;
    } catch {
      return !1;
    }
  }
  s(U$e, "_isNativeReflectConstruct");
  function gv(e) {
    return gv = Object.setPrototypeOf ? Object.getPrototypeOf : /* @__PURE__ */ s(function(r) {
      return r.__proto__ || Object.getPrototypeOf(r);
    }, "_getPrototypeOf"), gv(e);
  }
  s(gv, "_getPrototypeOf");
  var j$e, aW;
  aW = Qa();
  oW.exports = j$e = /* @__PURE__ */ function(e) {
    F$e(r, e);
    var t = M$e(r);
    function r() {
      return L$e(this, r), t.apply(this, arguments);
    }
    return s(r, "MarginBottom"), r;
  }(aW);
});

// ../node_modules/renderkid/lib/renderKid/styles/rule/declarationBlock/Margin.js
var cW = b((GIt, lW) => {
  "use strict";
  function _v(e) {
    "@babel/helpers - typeof";
    return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _v = /* @__PURE__ */ s(function(r) {
      return typeof r;
    }, "_typeof") : _v = /* @__PURE__ */ s(function(r) {
      return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
    }, "_typeof"), _v(e);
  }
  s(_v, "_typeof");
  function V$e(e, t) {
    if (!(e instanceof t))
      throw new TypeError("Cannot call a class as a function");
  }
  s(V$e, "_classCallCheck");
  function uW(e, t) {
    for (var r = 0; r < t.length; r++) {
      var i = t[r];
      i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);
    }
  }
  s(uW, "_defineProperties");
  function K$e(e, t, r) {
    return t && uW(e.prototype, t), r && uW(e, r), e;
  }
  s(K$e, "_createClass");
  function H$e(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Super expression must either be null or a function");
    e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), t && jw(e, t);
  }
  s(H$e, "_inherits");
  function jw(e, t) {
    return jw = Object.setPrototypeOf || /* @__PURE__ */ s(function(i, n) {
      return i.__proto__ = n, i;
    }, "_setPrototypeOf"), jw(e, t);
  }
  s(jw, "_setPrototypeOf");
  function z$e(e) {
    var t = $$e();
    return /* @__PURE__ */ s(function() {
      var i = bv(e), n;
      if (t) {
        var a = bv(this).constructor;
        n = Reflect.construct(i, arguments, a);
      } else
        n = i.apply(this, arguments);
      return G$e(this, n);
    }, "_createSuperInternal");
  }
  s(z$e, "_createSuper");
  function G$e(e, t) {
    return t && (_v(t) === "object" || typeof t == "function") ? t : W$e(e);
  }
  s(G$e, "_possibleConstructorReturn");
  function W$e(e) {
    if (e === void 0)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e;
  }
  s(W$e, "_assertThisInitialized");
  function $$e() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
    if (typeof Proxy == "function") return !0;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      })), !0;
    } catch {
      return !1;
    }
  }
  s($$e, "_isNativeReflectConstruct");
  function bv(e) {
    return bv = Object.setPrototypeOf ? Object.getPrototypeOf : /* @__PURE__ */ s(function(r) {
      return r.__proto__ || Object.getPrototypeOf(r);
    }, "_getPrototypeOf"), bv(e);
  }
  s(bv, "_getPrototypeOf");
  var X$e, Y$e, J$e, Q$e, nm, sm;
  sm = wu();
  nm = Nw();
  J$e = Fw();
  Q$e = Bw();
  Y$e = Uw();
  lW.exports = X$e = function() {
    var e, t = /* @__PURE__ */ function(r) {
      H$e(n, r);
      var i = z$e(n);
      function n() {
        return V$e(this, n), i.apply(this, arguments);
      }
      return s(n, "Margin"), K$e(n, null, [{
        key: "setOnto",
        value: /* @__PURE__ */ s(function(o, u, l) {
          var c, p, h;
          if (c = "", p = sm.sanitizeValue(l), sm.importantClauseRx.test(String(p)) && (c = " !important", p = p.replace(sm.importantClauseRx,
          "")), p = p.trim(), p.length === 0)
            return e._setAllDirections(o, c, c, c, c);
          if (h = p.split(" ").map(function(y) {
            return y + c;
          }), h.length === 1)
            return e._setAllDirections(o, h[0], h[0], h[0], h[0]);
          if (h.length === 2)
            return e._setAllDirections(o, h[0], h[1], h[0], h[1]);
          if (h.length === 3)
            return e._setAllDirections(o, h[0], h[1], h[2], h[1]);
          if (h.length === 4)
            return e._setAllDirections(o, h[0], h[1], h[2], h[3]);
          throw Error("Can't understand value for margin: `".concat(l, "`"));
        }, "setOnto")
      }, {
        key: "_setAllDirections",
        value: /* @__PURE__ */ s(function(o, u, l, c, p) {
          nm.setOnto(o, "marginTop", u), nm.setOnto(o, "marginRight", l), nm.setOnto(o, "marginBottom", c), nm.setOnto(o, "marginLeft", p);
        }, "_setAllDirections")
      }]), n;
    }(sm);
    return e = t, t;
  }.call(void 0);
});

// ../node_modules/renderkid/lib/renderKid/styles/rule/declarationBlock/PaddingTop.js
var Kw = b(($It, pW) => {
  "use strict";
  function vv(e) {
    "@babel/helpers - typeof";
    return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? vv = /* @__PURE__ */ s(function(r) {
      return typeof r;
    }, "_typeof") : vv = /* @__PURE__ */ s(function(r) {
      return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
    }, "_typeof"), vv(e);
  }
  s(vv, "_typeof");
  function Z$e(e, t) {
    if (!(e instanceof t))
      throw new TypeError("Cannot call a class as a function");
  }
  s(Z$e, "_classCallCheck");
  function eXe(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Super expression must either be null or a function");
    e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), t && Vw(e, t);
  }
  s(eXe, "_inherits");
  function Vw(e, t) {
    return Vw = Object.setPrototypeOf || /* @__PURE__ */ s(function(i, n) {
      return i.__proto__ = n, i;
    }, "_setPrototypeOf"), Vw(e, t);
  }
  s(Vw, "_setPrototypeOf");
  function tXe(e) {
    var t = nXe();
    return /* @__PURE__ */ s(function() {
      var i = Sv(e), n;
      if (t) {
        var a = Sv(this).constructor;
        n = Reflect.construct(i, arguments, a);
      } else
        n = i.apply(this, arguments);
      return rXe(this, n);
    }, "_createSuperInternal");
  }
  s(tXe, "_createSuper");
  function rXe(e, t) {
    return t && (vv(t) === "object" || typeof t == "function") ? t : iXe(e);
  }
  s(rXe, "_possibleConstructorReturn");
  function iXe(e) {
    if (e === void 0)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e;
  }
  s(iXe, "_assertThisInitialized");
  function nXe() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
    if (typeof Proxy == "function") return !0;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      })), !0;
    } catch {
      return !1;
    }
  }
  s(nXe, "_isNativeReflectConstruct");
  function Sv(e) {
    return Sv = Object.setPrototypeOf ? Object.getPrototypeOf : /* @__PURE__ */ s(function(r) {
      return r.__proto__ || Object.getPrototypeOf(r);
    }, "_getPrototypeOf"), Sv(e);
  }
  s(Sv, "_getPrototypeOf");
  var sXe, fW;
  fW = Qa();
  pW.exports = sXe = /* @__PURE__ */ function(e) {
    eXe(r, e);
    var t = tXe(r);
    function r() {
      return Z$e(this, r), t.apply(this, arguments);
    }
    return s(r, "PaddingTop"), r;
  }(fW);
});

// ../node_modules/renderkid/lib/renderKid/styles/rule/declarationBlock/PaddingLeft.js
var zw = b((YIt, dW) => {
  "use strict";
  function Tv(e) {
    "@babel/helpers - typeof";
    return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Tv = /* @__PURE__ */ s(function(r) {
      return typeof r;
    }, "_typeof") : Tv = /* @__PURE__ */ s(function(r) {
      return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
    }, "_typeof"), Tv(e);
  }
  s(Tv, "_typeof");
  function aXe(e, t) {
    if (!(e instanceof t))
      throw new TypeError("Cannot call a class as a function");
  }
  s(aXe, "_classCallCheck");
  function oXe(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Super expression must either be null or a function");
    e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), t && Hw(e, t);
  }
  s(oXe, "_inherits");
  function Hw(e, t) {
    return Hw = Object.setPrototypeOf || /* @__PURE__ */ s(function(i, n) {
      return i.__proto__ = n, i;
    }, "_setPrototypeOf"), Hw(e, t);
  }
  s(Hw, "_setPrototypeOf");
  function uXe(e) {
    var t = fXe();
    return /* @__PURE__ */ s(function() {
      var i = Ev(e), n;
      if (t) {
        var a = Ev(this).constructor;
        n = Reflect.construct(i, arguments, a);
      } else
        n = i.apply(this, arguments);
      return lXe(this, n);
    }, "_createSuperInternal");
  }
  s(uXe, "_createSuper");
  function lXe(e, t) {
    return t && (Tv(t) === "object" || typeof t == "function") ? t : cXe(e);
  }
  s(lXe, "_possibleConstructorReturn");
  function cXe(e) {
    if (e === void 0)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e;
  }
  s(cXe, "_assertThisInitialized");
  function fXe() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
    if (typeof Proxy == "function") return !0;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      })), !0;
    } catch {
      return !1;
    }
  }
  s(fXe, "_isNativeReflectConstruct");
  function Ev(e) {
    return Ev = Object.setPrototypeOf ? Object.getPrototypeOf : /* @__PURE__ */ s(function(r) {
      return r.__proto__ || Object.getPrototypeOf(r);
    }, "_getPrototypeOf"), Ev(e);
  }
  s(Ev, "_getPrototypeOf");
  var pXe, hW;
  hW = Qa();
  dW.exports = pXe = /* @__PURE__ */ function(e) {
    oXe(r, e);
    var t = uXe(r);
    function r() {
      return aXe(this, r), t.apply(this, arguments);
    }
    return s(r, "PaddingLeft"), r;
  }(hW);
});

// ../node_modules/renderkid/lib/renderKid/styles/rule/declarationBlock/PaddingRight.js
var Ww = b((QIt, yW) => {
  "use strict";
  function Av(e) {
    "@babel/helpers - typeof";
    return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Av = /* @__PURE__ */ s(function(r) {
      return typeof r;
    }, "_typeof") : Av = /* @__PURE__ */ s(function(r) {
      return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
    }, "_typeof"), Av(e);
  }
  s(Av, "_typeof");
  function hXe(e, t) {
    if (!(e instanceof t))
      throw new TypeError("Cannot call a class as a function");
  }
  s(hXe, "_classCallCheck");
  function dXe(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Super expression must either be null or a function");
    e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), t && Gw(e, t);
  }
  s(dXe, "_inherits");
  function Gw(e, t) {
    return Gw = Object.setPrototypeOf || /* @__PURE__ */ s(function(i, n) {
      return i.__proto__ = n, i;
    }, "_setPrototypeOf"), Gw(e, t);
  }
  s(Gw, "_setPrototypeOf");
  function mXe(e) {
    var t = _Xe();
    return /* @__PURE__ */ s(function() {
      var i = xv(e), n;
      if (t) {
        var a = xv(this).constructor;
        n = Reflect.construct(i, arguments, a);
      } else
        n = i.apply(this, arguments);
      return yXe(this, n);
    }, "_createSuperInternal");
  }
  s(mXe, "_createSuper");
  function yXe(e, t) {
    return t && (Av(t) === "object" || typeof t == "function") ? t : gXe(e);
  }
  s(yXe, "_possibleConstructorReturn");
  function gXe(e) {
    if (e === void 0)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e;
  }
  s(gXe, "_assertThisInitialized");
  function _Xe() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
    if (typeof Proxy == "function") return !0;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      })), !0;
    } catch {
      return !1;
    }
  }
  s(_Xe, "_isNativeReflectConstruct");
  function xv(e) {
    return xv = Object.setPrototypeOf ? Object.getPrototypeOf : /* @__PURE__ */ s(function(r) {
      return r.__proto__ || Object.getPrototypeOf(r);
    }, "_getPrototypeOf"), xv(e);
  }
  s(xv, "_getPrototypeOf");
  var bXe, mW;
  mW = Qa();
  yW.exports = bXe = /* @__PURE__ */ function(e) {
    dXe(r, e);
    var t = mXe(r);
    function r() {
      return hXe(this, r), t.apply(this, arguments);
    }
    return s(r, "PaddingRight"), r;
  }(mW);
});

// ../node_modules/renderkid/lib/renderKid/styles/rule/declarationBlock/PaddingBottom.js
var Xw = b((eRt, _W) => {
  "use strict";
  function Cv(e) {
    "@babel/helpers - typeof";
    return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Cv = /* @__PURE__ */ s(function(r) {
      return typeof r;
    }, "_typeof") : Cv = /* @__PURE__ */ s(function(r) {
      return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
    }, "_typeof"), Cv(e);
  }
  s(Cv, "_typeof");
  function vXe(e, t) {
    if (!(e instanceof t))
      throw new TypeError("Cannot call a class as a function");
  }
  s(vXe, "_classCallCheck");
  function SXe(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Super expression must either be null or a function");
    e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), t && $w(e, t);
  }
  s(SXe, "_inherits");
  function $w(e, t) {
    return $w = Object.setPrototypeOf || /* @__PURE__ */ s(function(i, n) {
      return i.__proto__ = n, i;
    }, "_setPrototypeOf"), $w(e, t);
  }
  s($w, "_setPrototypeOf");
  function TXe(e) {
    var t = xXe();
    return /* @__PURE__ */ s(function() {
      var i = Pv(e), n;
      if (t) {
        var a = Pv(this).constructor;
        n = Reflect.construct(i, arguments, a);
      } else
        n = i.apply(this, arguments);
      return EXe(this, n);
    }, "_createSuperInternal");
  }
  s(TXe, "_createSuper");
  function EXe(e, t) {
    return t && (Cv(t) === "object" || typeof t == "function") ? t : AXe(e);
  }
  s(EXe, "_possibleConstructorReturn");
  function AXe(e) {
    if (e === void 0)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e;
  }
  s(AXe, "_assertThisInitialized");
  function xXe() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
    if (typeof Proxy == "function") return !0;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      })), !0;
    } catch {
      return !1;
    }
  }
  s(xXe, "_isNativeReflectConstruct");
  function Pv(e) {
    return Pv = Object.setPrototypeOf ? Object.getPrototypeOf : /* @__PURE__ */ s(function(r) {
      return r.__proto__ || Object.getPrototypeOf(r);
    }, "_getPrototypeOf"), Pv(e);
  }
  s(Pv, "_getPrototypeOf");
  var CXe, gW;
  gW = Qa();
  _W.exports = CXe = /* @__PURE__ */ function(e) {
    SXe(r, e);
    var t = TXe(r);
    function r() {
      return vXe(this, r), t.apply(this, arguments);
    }
    return s(r, "PaddingBottom"), r;
  }(gW);
});

// ../node_modules/renderkid/lib/renderKid/styles/rule/declarationBlock/Padding.js
var SW = b((rRt, vW) => {
  "use strict";
  function Dv(e) {
    "@babel/helpers - typeof";
    return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Dv = /* @__PURE__ */ s(function(r) {
      return typeof r;
    }, "_typeof") : Dv = /* @__PURE__ */ s(function(r) {
      return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
    }, "_typeof"), Dv(e);
  }
  s(Dv, "_typeof");
  function PXe(e, t) {
    if (!(e instanceof t))
      throw new TypeError("Cannot call a class as a function");
  }
  s(PXe, "_classCallCheck");
  function bW(e, t) {
    for (var r = 0; r < t.length; r++) {
      var i = t[r];
      i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);
    }
  }
  s(bW, "_defineProperties");
  function DXe(e, t, r) {
    return t && bW(e.prototype, t), r && bW(e, r), e;
  }
  s(DXe, "_createClass");
  function wXe(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Super expression must either be null or a function");
    e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), t && Yw(e, t);
  }
  s(wXe, "_inherits");
  function Yw(e, t) {
    return Yw = Object.setPrototypeOf || /* @__PURE__ */ s(function(i, n) {
      return i.__proto__ = n, i;
    }, "_setPrototypeOf"), Yw(e, t);
  }
  s(Yw, "_setPrototypeOf");
  function OXe(e) {
    var t = RXe();
    return /* @__PURE__ */ s(function() {
      var i = wv(e), n;
      if (t) {
        var a = wv(this).constructor;
        n = Reflect.construct(i, arguments, a);
      } else
        n = i.apply(this, arguments);
      return kXe(this, n);
    }, "_createSuperInternal");
  }
  s(OXe, "_createSuper");
  function kXe(e, t) {
    return t && (Dv(t) === "object" || typeof t == "function") ? t : IXe(e);
  }
  s(kXe, "_possibleConstructorReturn");
  function IXe(e) {
    if (e === void 0)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e;
  }
  s(IXe, "_assertThisInitialized");
  function RXe() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
    if (typeof Proxy == "function") return !0;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      })), !0;
    } catch {
      return !1;
    }
  }
  s(RXe, "_isNativeReflectConstruct");
  function wv(e) {
    return wv = Object.setPrototypeOf ? Object.getPrototypeOf : /* @__PURE__ */ s(function(r) {
      return r.__proto__ || Object.getPrototypeOf(r);
    }, "_getPrototypeOf"), wv(e);
  }
  s(wv, "_getPrototypeOf");
  var NXe, LXe, FXe, MXe, am, om;
  om = wu();
  am = Kw();
  FXe = zw();
  MXe = Ww();
  LXe = Xw();
  vW.exports = NXe = function() {
    var e, t = /* @__PURE__ */ function(r) {
      wXe(n, r);
      var i = OXe(n);
      function n() {
        return PXe(this, n), i.apply(this, arguments);
      }
      return s(n, "Padding"), DXe(n, null, [{
        key: "setOnto",
        value: /* @__PURE__ */ s(function(o, u, l) {
          var c, p, h;
          if (c = "", p = om.sanitizeValue(l), om.importantClauseRx.test(String(p)) && (c = " !important", p = p.replace(om.importantClauseRx,
          "")), p = p.trim(), p.length === 0)
            return e._setAllDirections(o, c, c, c, c);
          if (h = p.split(" ").map(function(y) {
            return y + c;
          }), h.length === 1)
            return e._setAllDirections(o, h[0], h[0], h[0], h[0]);
          if (h.length === 2)
            return e._setAllDirections(o, h[0], h[1], h[0], h[1]);
          if (h.length === 3)
            return e._setAllDirections(o, h[0], h[1], h[2], h[1]);
          if (h.length === 4)
            return e._setAllDirections(o, h[0], h[1], h[2], h[3]);
          throw Error("Can't understand value for padding: `".concat(l, "`"));
        }, "setOnto")
      }, {
        key: "_setAllDirections",
        value: /* @__PURE__ */ s(function(o, u, l, c, p) {
          am.setOnto(o, "paddingTop", u), am.setOnto(o, "paddingRight", l), am.setOnto(o, "paddingBottom", c), am.setOnto(o, "paddingLeft", p);
        }, "_setAllDirections")
      }]), n;
    }(om);
    return e = t, t;
  }.call(void 0);
});

// ../node_modules/renderkid/lib/renderKid/styles/rule/DeclarationBlock.js
var CW = b((nRt, xW) => {
  "use strict";
  function Ov(e) {
    "@babel/helpers - typeof";
    return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Ov = /* @__PURE__ */ s(function(r) {
      return typeof r;
    }, "_typeof") : Ov = /* @__PURE__ */ s(function(r) {
      return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
    }, "_typeof"), Ov(e);
  }
  s(Ov, "_typeof");
  function BXe(e, t) {
    if (!(e instanceof t))
      throw new TypeError("Cannot call a class as a function");
  }
  s(BXe, "_classCallCheck");
  function TW(e, t) {
    for (var r = 0; r < t.length; r++) {
      var i = t[r];
      i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);
    }
  }
  s(TW, "_defineProperties");
  function qXe(e, t, r) {
    return t && TW(e.prototype, t), r && TW(e, r), e;
  }
  s(qXe, "_createClass");
  var EW, UXe, AW;
  xW.exports = UXe = function() {
    var e, t = /* @__PURE__ */ function() {
      function r() {
        BXe(this, r), this._declarations = {};
      }
      return s(r, "DeclarationBlock"), qXe(r, [{
        key: "set",
        value: /* @__PURE__ */ s(function(n, a) {
          var o, u;
          if (Ov(n) === "object") {
            for (o in n)
              u = n[o], this.set(o, u);
            return this;
          }
          return n = e.sanitizeProp(n), this._getDeclarationClass(n).setOnto(this._declarations, n, a), this;
        }, "set")
      }, {
        key: "_getDeclarationClass",
        value: /* @__PURE__ */ s(function(n) {
          var a;
          if (n[0] === "_")
            return EW;
          if (!(a = AW[n]))
            throw Error("Unknown property `".concat(n, "`. Write it as `_").concat(n, "` if you're defining a custom property"));
          return a;
        }, "_getDeclarationClass")
      }], [{
        key: "sanitizeProp",
        value: /* @__PURE__ */ s(function(n) {
          return String(n).trim();
        }, "sanitizeProp")
      }]), r;
    }();
    return e = t, t;
  }.call(void 0);
  EW = OG();
  AW = {
    color: RG(),
    background: FG(),
    width: VG(),
    height: zG(),
    bullet: XG(),
    display: ZG(),
    margin: cW(),
    marginTop: Nw(),
    marginLeft: Fw(),
    marginRight: Bw(),
    marginBottom: Uw(),
    padding: SW(),
    paddingTop: Kw(),
    paddingLeft: zw(),
    paddingRight: Ww(),
    paddingBottom: Xw()
  };
});

// ../node_modules/renderkid/lib/renderKid/styles/Rule.js
var kW = b((aRt, OW) => {
  "use strict";
  function jXe(e, t) {
    if (!(e instanceof t))
      throw new TypeError("Cannot call a class as a function");
  }
  s(jXe, "_classCallCheck");
  function PW(e, t) {
    for (var r = 0; r < t.length; r++) {
      var i = t[r];
      i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);
    }
  }
  s(PW, "_defineProperties");
  function VXe(e, t, r) {
    return t && PW(e.prototype, t), r && PW(e, r), e;
  }
  s(VXe, "_createClass");
  var DW, KXe, wW;
  wW = xG();
  DW = CW();
  OW.exports = KXe = /* @__PURE__ */ function() {
    function e(t) {
      jXe(this, e), this.selector = new wW(t), this.styles = new DW();
    }
    return s(e, "Rule"), VXe(e, [{
      key: "setStyles",
      value: /* @__PURE__ */ s(function(r) {
        return this.styles.set(r), this;
      }, "setStyles")
    }]), e;
  }();
});

// ../node_modules/renderkid/lib/renderKid/styles/StyleSheet.js
var LW = b((uRt, NW) => {
  "use strict";
  function kv(e) {
    "@babel/helpers - typeof";
    return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? kv = /* @__PURE__ */ s(function(r) {
      return typeof r;
    }, "_typeof") : kv = /* @__PURE__ */ s(function(r) {
      return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
    }, "_typeof"), kv(e);
  }
  s(kv, "_typeof");
  function HXe(e, t) {
    if (!(e instanceof t))
      throw new TypeError("Cannot call a class as a function");
  }
  s(HXe, "_classCallCheck");
  function IW(e, t) {
    for (var r = 0; r < t.length; r++) {
      var i = t[r];
      i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);
    }
  }
  s(IW, "_defineProperties");
  function zXe(e, t, r) {
    return t && IW(e.prototype, t), r && IW(e, r), e;
  }
  s(zXe, "_createClass");
  var RW, GXe;
  RW = kW();
  NW.exports = GXe = function() {
    var e, t = /* @__PURE__ */ function() {
      function r() {
        HXe(this, r), this._rulesBySelector = {};
      }
      return s(r, "StyleSheet"), zXe(r, [{
        key: "setRule",
        value: /* @__PURE__ */ s(function(n, a) {
          var o, u;
          if (typeof n == "string")
            this._setRule(n, a);
          else if (kv(n) === "object")
            for (o in n)
              u = n[o], this._setRule(o, u);
          return this;
        }, "setRule")
      }, {
        key: "_setRule",
        value: /* @__PURE__ */ s(function(n, a) {
          var o, u, l, c;
          for (l = e.splitSelectors(n), o = 0, u = l.length; o < u; o++)
            c = l[o], this._setSingleRule(c, a);
          return this;
        }, "_setRule")
      }, {
        key: "_setSingleRule",
        value: /* @__PURE__ */ s(function(n, a) {
          var o, u;
          return u = e.normalizeSelector(n), (o = this._rulesBySelector[u]) || (o = new RW(u), this._rulesBySelector[u] = o), o.setStyles(a),
          this;
        }, "_setSingleRule")
      }, {
        key: "getRulesFor",
        value: /* @__PURE__ */ s(function(n) {
          var a, o, u, l;
          u = [], a = this._rulesBySelector;
          for (l in a)
            o = a[l], o.selector.matches(n) && u.push(o);
          return u;
        }, "getRulesFor")
      }], [{
        key: "normalizeSelector",
        value: /* @__PURE__ */ s(function(n) {
          return n.replace(/[\s]+/g, " ").replace(/[\s]*([>\,\+]{1})[\s]*/g, "$1").trim();
        }, "normalizeSelector")
      }, {
        key: "splitSelectors",
        value: /* @__PURE__ */ s(function(n) {
          return n.trim().split(",");
        }, "splitSelectors")
      }]), r;
    }();
    return e = t, t;
  }.call(void 0);
});

// ../node_modules/renderkid/lib/renderKid/styles/rule/MixedDeclarationSet.js
var BW = b((cRt, MW) => {
  "use strict";
  function WXe(e, t) {
    if (!(e instanceof t))
      throw new TypeError("Cannot call a class as a function");
  }
  s(WXe, "_classCallCheck");
  function FW(e, t) {
    for (var r = 0; r < t.length; r++) {
      var i = t[r];
      i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);
    }
  }
  s(FW, "_defineProperties");
  function $Xe(e, t, r) {
    return t && FW(e.prototype, t), r && FW(e, r), e;
  }
  s($Xe, "_createClass");
  var XXe;
  MW.exports = XXe = function() {
    var e, t = /* @__PURE__ */ function() {
      function r() {
        WXe(this, r), this._declarations = {};
      }
      return s(r, "MixedDeclarationSet"), $Xe(r, [{
        key: "mixWithList",
        value: /* @__PURE__ */ s(function(n) {
          var a, o, u;
          for (n.sort(function(l, c) {
            return l.selector.priority > c.selector.priority;
          }), a = 0, o = n.length; a < o; a++)
            u = n[a], this._mixWithRule(u);
          return this;
        }, "mixWithList")
      }, {
        key: "_mixWithRule",
        value: /* @__PURE__ */ s(function(n) {
          var a, o, u;
          u = n.styles._declarations;
          for (o in u)
            a = u[o], this._mixWithDeclaration(a);
        }, "_mixWithRule")
      }, {
        key: "_mixWithDeclaration",
        value: /* @__PURE__ */ s(function(n) {
          var a;
          a = this._declarations[n.prop], !(a != null && a.important && !n.important) && (this._declarations[n.prop] = n);
        }, "_mixWithDeclaration")
      }, {
        key: "get",
        value: /* @__PURE__ */ s(function(n) {
          return n == null ? this._declarations : this._declarations[n] == null ? null : this._declarations[n].val;
        }, "get")
      }, {
        key: "toObject",
        value: /* @__PURE__ */ s(function() {
          var n, a, o, u;
          a = {}, u = this._declarations;
          for (o in u)
            n = u[o], a[o] = n.val;
          return a;
        }, "toObject")
      }], [{
        key: "mix",
        value: /* @__PURE__ */ s(function() {
          var n, a, o, u;
          o = new e();
          for (var l = arguments.length, c = new Array(l), p = 0; p < l; p++)
            c[p] = arguments[p];
          for (n = 0, a = c.length; n < a; n++)
            u = c[n], o.mixWithList(u);
          return o;
        }, "mix")
      }]), r;
    }();
    return e = t, t;
  }.call(void 0);
});

// ../node_modules/renderkid/lib/renderKid/Styles.js
var KW = b((pRt, VW) => {
  "use strict";
  function YXe(e, t) {
    if (!(e instanceof t))
      throw new TypeError("Cannot call a class as a function");
  }
  s(YXe, "_classCallCheck");
  function qW(e, t) {
    for (var r = 0; r < t.length; r++) {
      var i = t[r];
      i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);
    }
  }
  s(qW, "_defineProperties");
  function JXe(e, t, r) {
    return t && qW(e.prototype, t), r && qW(e, r), e;
  }
  s(JXe, "_createClass");
  var UW, Jw, QXe, jW;
  Jw = LW();
  UW = BW();
  jW = ys().getCols();
  VW.exports = QXe = function() {
    var e, t = /* @__PURE__ */ function() {
      function r() {
        YXe(this, r), this._defaultStyles = new Jw(), this._userStyles = new Jw(), this._setDefaultStyles();
      }
      return s(r, "Styles"), JXe(r, [{
        key: "_setDefaultStyles",
        value: /* @__PURE__ */ s(function() {
          this._defaultStyles.setRule(e.defaultRules);
        }, "_setDefaultStyles")
      }, {
        key: "setRule",
        value: /* @__PURE__ */ s(function(n, a) {
          return this._userStyles.setRule.apply(this._userStyles, arguments), this;
        }, "setRule")
      }, {
        key: "getStyleFor",
        value: /* @__PURE__ */ s(function(n) {
          var a;
          return a = n.styles, a == null && (n.styles = a = this._getComputedStyleFor(n)), a;
        }, "getStyleFor")
      }, {
        key: "_getRawStyleFor",
        value: /* @__PURE__ */ s(function(n) {
          var a, o;
          return a = this._defaultStyles.getRulesFor(n), o = this._userStyles.getRulesFor(n), UW.mix(a, o).toObject();
        }, "_getRawStyleFor")
      }, {
        key: "_getComputedStyleFor",
        value: /* @__PURE__ */ s(function(n) {
          var a, o, u, l, c;
          a = {}, o = n.parent, l = this._getRawStyleFor(n);
          for (u in l)
            if (c = l[u], c !== "inherit")
              a[u] = c;
            else
              throw Error("Inherited styles are not supported yet.");
          return a;
        }, "_getComputedStyleFor")
      }]), r;
    }();
    return e = t, t.defaultRules = {
      "*": {
        display: "inline"
      },
      body: {
        background: "none",
        color: "white",
        display: "block",
        width: jW + " !important"
      }
    }, t;
  }.call(void 0);
});

// ../node_modules/renderkid/lib/layout/SpecialString.js
var Rv = b((dRt, WW) => {
  "use strict";
  function ZXe(e, t) {
    if (!(e instanceof t))
      throw new TypeError("Cannot call a class as a function");
  }
  s(ZXe, "_classCallCheck");
  function HW(e, t) {
    for (var r = 0; r < t.length; r++) {
      var i = t[r];
      i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);
    }
  }
  s(HW, "_defineProperties");
  function eYe(e, t, r) {
    return t && HW(e.prototype, t), r && HW(e, r), e;
  }
  s(eYe, "_createClass");
  var GW, Iv, zW, um, Qw;
  WW.exports = GW = function() {
    var e, t = /* @__PURE__ */ function() {
      function r(i) {
        if (ZXe(this, r), !(this instanceof e))
          return new e(i);
        this._str = String(i), this._len = 0;
      }
      return s(r, "SpecialString"), eYe(r, [{
        key: "_getStr",
        value: /* @__PURE__ */ s(function() {
          return this._str;
        }, "_getStr")
      }, {
        key: "set",
        value: /* @__PURE__ */ s(function(n) {
          return this._str = String(n), this;
        }, "set")
      }, {
        key: "clone",
        value: /* @__PURE__ */ s(function() {
          return new r(this._str);
        }, "clone")
      }, {
        key: "isEmpty",
        value: /* @__PURE__ */ s(function() {
          return this._str === "";
        }, "isEmpty")
      }, {
        key: "isOnlySpecialChars",
        value: /* @__PURE__ */ s(function() {
          return !this.isEmpty() && this.length === 0;
        }, "isOnlySpecialChars")
      }, {
        key: "_reset",
        value: /* @__PURE__ */ s(function() {
          return this._len = 0;
        }, "_reset")
      }, {
        key: "splitIn",
        value: /* @__PURE__ */ s(function(n) {
          var a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, o, u, l, c;
          return o = "", u = 0, c = [], l = !1, e._countChars(this._str, function(p, h) {
            return (u > n || u + h > n) && (c.push(o), o = "", u = 0), u === 0 && p === " " && !l && a ? l = !0 : (o += p, u += h, l = !1);
          }), o.length > 0 && c.push(o), c;
        }, "splitIn")
      }, {
        key: "trim",
        value: /* @__PURE__ */ s(function() {
          return new r(this.str.trim());
        }, "trim")
      }, {
        key: "_getLength",
        value: /* @__PURE__ */ s(function() {
          var n;
          return n = 0, e._countChars(this._str, function(a, o) {
            n += o;
          }), n;
        }, "_getLength")
      }, {
        key: "cut",
        value: /* @__PURE__ */ s(function(n, a) {
          var o = this, u = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, l, c, p, h;
          if (a == null && (a = this.length), n = parseInt(n), n >= a)
            throw Error("`from` shouldn't be larger than `to`");
          return c = "", l = "", h = "", p = 0, e._countChars(this._str, function(y, _) {
            o.str === "ab<tag>" && console.log(_, y), !(p === n && y.match(/^\s+$/) && u) && (p < n ? c += y : p < a || p + _ <= a ? h += y :
            l += y, p += _);
          }), this._str = c + l, this._reset(), new r(h);
        }, "cut")
      }], [{
        key: "_countChars",
        value: /* @__PURE__ */ s(function(n, a) {
          for (var o, u, l; n.length !== 0; )
            (l = n.match(e._tagRx)) ? (o = l[0], u = 0, n = n.substr(o.length, n.length)) : (l = n.match(e._quotedHtmlRx)) ? (o = l[0], u = 1,
            n = n.substr(o.length, n.length)) : n.match(e._tabRx) ? (o = "	", u = 8, n = n.substr(1, n.length)) : (o = n[0], u = 1, n = n.substr(
            1, n.length)), a.call(null, o, u);
        }, "_countChars")
      }]), r;
    }();
    return e = t, t._tabRx = /^\t/, t._tagRx = /^<[^>]+>/, t._quotedHtmlRx = /^&(gt|lt|quot|amp|apos|sp);/, t;
  }.call(void 0);
  Qw = ["str", "length"];
  for (Iv = 0, zW = Qw.length; Iv < zW; Iv++)
    um = Qw[Iv], function() {
      var e;
      return e = "_get" + um[0].toUpperCase() + um.substr(1, um.length), GW.prototype.__defineGetter__(um, function() {
        return this[e]();
      });
    }();
});

// ../node_modules/renderkid/lib/layout/block/blockPrependor/_BlockPrependor.js
var YW = b((yRt, XW) => {
  "use strict";
  function tYe(e, t) {
    if (!(e instanceof t))
      throw new TypeError("Cannot call a class as a function");
  }
  s(tYe, "_classCallCheck");
  function $W(e, t) {
    for (var r = 0; r < t.length; r++) {
      var i = t[r];
      i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);
    }
  }
  s($W, "_defineProperties");
  function rYe(e, t, r) {
    return t && $W(e.prototype, t), r && $W(e, r), e;
  }
  s(rYe, "_createClass");
  var iYe;
  XW.exports = iYe = /* @__PURE__ */ function() {
    function e(t) {
      tYe(this, e), this._config = t;
    }
    return s(e, "_BlockPrependor"), rYe(e, [{
      key: "render",
      value: /* @__PURE__ */ s(function(r) {
        return this._render(r);
      }, "render")
    }]), e;
  }();
});

// ../node_modules/renderkid/lib/layout/block/blockPrependor/Default.js
var e$ = b((_Rt, ZW) => {
  "use strict";
  function Nv(e) {
    "@babel/helpers - typeof";
    return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Nv = /* @__PURE__ */ s(function(r) {
      return typeof r;
    }, "_typeof") : Nv = /* @__PURE__ */ s(function(r) {
      return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
    }, "_typeof"), Nv(e);
  }
  s(Nv, "_typeof");
  function nYe(e, t) {
    if (!(e instanceof t))
      throw new TypeError("Cannot call a class as a function");
  }
  s(nYe, "_classCallCheck");
  function JW(e, t) {
    for (var r = 0; r < t.length; r++) {
      var i = t[r];
      i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);
    }
  }
  s(JW, "_defineProperties");
  function sYe(e, t, r) {
    return t && JW(e.prototype, t), r && JW(e, r), e;
  }
  s(sYe, "_createClass");
  function aYe(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Super expression must either be null or a function");
    e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), t && Zw(e, t);
  }
  s(aYe, "_inherits");
  function Zw(e, t) {
    return Zw = Object.setPrototypeOf || /* @__PURE__ */ s(function(i, n) {
      return i.__proto__ = n, i;
    }, "_setPrototypeOf"), Zw(e, t);
  }
  s(Zw, "_setPrototypeOf");
  function oYe(e) {
    var t = cYe();
    return /* @__PURE__ */ s(function() {
      var i = Lv(e), n;
      if (t) {
        var a = Lv(this).constructor;
        n = Reflect.construct(i, arguments, a);
      } else
        n = i.apply(this, arguments);
      return uYe(this, n);
    }, "_createSuperInternal");
  }
  s(oYe, "_createSuper");
  function uYe(e, t) {
    return t && (Nv(t) === "object" || typeof t == "function") ? t : lYe(e);
  }
  s(uYe, "_possibleConstructorReturn");
  function lYe(e) {
    if (e === void 0)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e;
  }
  s(lYe, "_assertThisInitialized");
  function cYe() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
    if (typeof Proxy == "function") return !0;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      })), !0;
    } catch {
      return !1;
    }
  }
  s(cYe, "_isNativeReflectConstruct");
  function Lv(e) {
    return Lv = Object.setPrototypeOf ? Object.getPrototypeOf : /* @__PURE__ */ s(function(r) {
      return r.__proto__ || Object.getPrototypeOf(r);
    }, "_getPrototypeOf"), Lv(e);
  }
  s(Lv, "_getPrototypeOf");
  var fYe, QW;
  QW = ys();
  ZW.exports = fYe = /* @__PURE__ */ function(e) {
    aYe(r, e);
    var t = oYe(r);
    function r() {
      return nYe(this, r), t.apply(this, arguments);
    }
    return s(r, "DefaultBlockPrependor"), sYe(r, [{
      key: "_render",
      value: /* @__PURE__ */ s(function(n) {
        return QW.repeatString(`
`, this._config.amount);
      }, "_render")
    }]), r;
  }(YW());
});

// ../node_modules/renderkid/lib/layout/block/blockAppendor/_BlockAppendor.js
var i$ = b((vRt, r$) => {
  "use strict";
  function pYe(e, t) {
    if (!(e instanceof t))
      throw new TypeError("Cannot call a class as a function");
  }
  s(pYe, "_classCallCheck");
  function t$(e, t) {
    for (var r = 0; r < t.length; r++) {
      var i = t[r];
      i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);
    }
  }
  s(t$, "_defineProperties");
  function hYe(e, t, r) {
    return t && t$(e.prototype, t), r && t$(e, r), e;
  }
  s(hYe, "_createClass");
  var dYe;
  r$.exports = dYe = /* @__PURE__ */ function() {
    function e(t) {
      pYe(this, e), this._config = t;
    }
    return s(e, "_BlockAppendor"), hYe(e, [{
      key: "render",
      value: /* @__PURE__ */ s(function(r) {
        return this._render(r);
      }, "render")
    }]), e;
  }();
});

// ../node_modules/renderkid/lib/layout/block/blockAppendor/Default.js
var o$ = b((TRt, a$) => {
  "use strict";
  function Fv(e) {
    "@babel/helpers - typeof";
    return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Fv = /* @__PURE__ */ s(function(r) {
      return typeof r;
    }, "_typeof") : Fv = /* @__PURE__ */ s(function(r) {
      return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
    }, "_typeof"), Fv(e);
  }
  s(Fv, "_typeof");
  function mYe(e, t) {
    if (!(e instanceof t))
      throw new TypeError("Cannot call a class as a function");
  }
  s(mYe, "_classCallCheck");
  function n$(e, t) {
    for (var r = 0; r < t.length; r++) {
      var i = t[r];
      i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);
    }
  }
  s(n$, "_defineProperties");
  function yYe(e, t, r) {
    return t && n$(e.prototype, t), r && n$(e, r), e;
  }
  s(yYe, "_createClass");
  function gYe(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Super expression must either be null or a function");
    e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), t && e2(e, t);
  }
  s(gYe, "_inherits");
  function e2(e, t) {
    return e2 = Object.setPrototypeOf || /* @__PURE__ */ s(function(i, n) {
      return i.__proto__ = n, i;
    }, "_setPrototypeOf"), e2(e, t);
  }
  s(e2, "_setPrototypeOf");
  function _Ye(e) {
    var t = SYe();
    return /* @__PURE__ */ s(function() {
      var i = Mv(e), n;
      if (t) {
        var a = Mv(this).constructor;
        n = Reflect.construct(i, arguments, a);
      } else
        n = i.apply(this, arguments);
      return bYe(this, n);
    }, "_createSuperInternal");
  }
  s(_Ye, "_createSuper");
  function bYe(e, t) {
    return t && (Fv(t) === "object" || typeof t == "function") ? t : vYe(e);
  }
  s(bYe, "_possibleConstructorReturn");
  function vYe(e) {
    if (e === void 0)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e;
  }
  s(vYe, "_assertThisInitialized");
  function SYe() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
    if (typeof Proxy == "function") return !0;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      })), !0;
    } catch {
      return !1;
    }
  }
  s(SYe, "_isNativeReflectConstruct");
  function Mv(e) {
    return Mv = Object.setPrototypeOf ? Object.getPrototypeOf : /* @__PURE__ */ s(function(r) {
      return r.__proto__ || Object.getPrototypeOf(r);
    }, "_getPrototypeOf"), Mv(e);
  }
  s(Mv, "_getPrototypeOf");
  var TYe, s$;
  s$ = ys();
  a$.exports = TYe = /* @__PURE__ */ function(e) {
    gYe(r, e);
    var t = _Ye(r);
    function r() {
      return mYe(this, r), t.apply(this, arguments);
    }
    return s(r, "DefaultBlockAppendor"), yYe(r, [{
      key: "_render",
      value: /* @__PURE__ */ s(function(n) {
        return s$.repeatString(`
`, this._config.amount);
      }, "_render")
    }]), r;
  }(i$());
});

// ../node_modules/renderkid/lib/layout/block/linePrependor/_LinePrependor.js
var c$ = b((ARt, l$) => {
  "use strict";
  function EYe(e, t) {
    if (!(e instanceof t))
      throw new TypeError("Cannot call a class as a function");
  }
  s(EYe, "_classCallCheck");
  function u$(e, t) {
    for (var r = 0; r < t.length; r++) {
      var i = t[r];
      i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);
    }
  }
  s(u$, "_defineProperties");
  function AYe(e, t, r) {
    return t && u$(e.prototype, t), r && u$(e, r), e;
  }
  s(AYe, "_createClass");
  var xYe;
  l$.exports = xYe = /* @__PURE__ */ function() {
    function e(t) {
      EYe(this, e), this._config = t, this._lineNo = -1;
    }
    return s(e, "_LinePrependor"), AYe(e, [{
      key: "render",
      value: /* @__PURE__ */ s(function(r, i) {
        return this._lineNo++, "<none>" + this._render(r, i) + "</none>";
      }, "render")
    }]), e;
  }();
});

// ../node_modules/renderkid/lib/layout/block/linePrependor/Default.js
var m$ = b((CRt, d$) => {
  "use strict";
  function Bv(e) {
    "@babel/helpers - typeof";
    return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Bv = /* @__PURE__ */ s(function(r) {
      return typeof r;
    }, "_typeof") : Bv = /* @__PURE__ */ s(function(r) {
      return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
    }, "_typeof"), Bv(e);
  }
  s(Bv, "_typeof");
  function CYe(e, t) {
    if (!(e instanceof t))
      throw new TypeError("Cannot call a class as a function");
  }
  s(CYe, "_classCallCheck");
  function f$(e, t) {
    for (var r = 0; r < t.length; r++) {
      var i = t[r];
      i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);
    }
  }
  s(f$, "_defineProperties");
  function PYe(e, t, r) {
    return t && f$(e.prototype, t), r && f$(e, r), e;
  }
  s(PYe, "_createClass");
  function DYe(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Super expression must either be null or a function");
    e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), t && t2(e, t);
  }
  s(DYe, "_inherits");
  function t2(e, t) {
    return t2 = Object.setPrototypeOf || /* @__PURE__ */ s(function(i, n) {
      return i.__proto__ = n, i;
    }, "_setPrototypeOf"), t2(e, t);
  }
  s(t2, "_setPrototypeOf");
  function wYe(e) {
    var t = IYe();
    return /* @__PURE__ */ s(function() {
      var i = qv(e), n;
      if (t) {
        var a = qv(this).constructor;
        n = Reflect.construct(i, arguments, a);
      } else
        n = i.apply(this, arguments);
      return OYe(this, n);
    }, "_createSuperInternal");
  }
  s(wYe, "_createSuper");
  function OYe(e, t) {
    return t && (Bv(t) === "object" || typeof t == "function") ? t : kYe(e);
  }
  s(OYe, "_possibleConstructorReturn");
  function kYe(e) {
    if (e === void 0)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e;
  }
  s(kYe, "_assertThisInitialized");
  function IYe() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
    if (typeof Proxy == "function") return !0;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      })), !0;
    } catch {
      return !1;
    }
  }
  s(IYe, "_isNativeReflectConstruct");
  function qv(e) {
    return qv = Object.setPrototypeOf ? Object.getPrototypeOf : /* @__PURE__ */ s(function(r) {
      return r.__proto__ || Object.getPrototypeOf(r);
    }, "_getPrototypeOf"), qv(e);
  }
  s(qv, "_getPrototypeOf");
  var RYe, p$, h$;
  h$ = ys();
  p$ = Rv();
  d$.exports = RYe = function() {
    var e, t = /* @__PURE__ */ function(r) {
      DYe(n, r);
      var i = wYe(n);
      function n() {
        return CYe(this, n), i.apply(this, arguments);
      }
      return s(n, "DefaultLinePrependor"), PYe(n, [{
        key: "_render",
        value: /* @__PURE__ */ s(function(o, u) {
          var l, c, p, h, y, _, g, m, f, d, v;
          if (this._lineNo === 0 && (h = this._config.bullet)) {
            if (y = h.char, _ = new p$(y).length, p = h.alignment, d = this._config.amount, v = y, l = "", c = "", d > _)
              if (g = d - _, p === "right")
                l = e.pad(g);
              else if (p === "left")
                c = e.pad(g);
              else if (p === "center")
                m = Math.round(g / 2), l = e.pad(m), c = e.pad(g - m);
              else
                throw Error("Unknown alignment `".concat(p, "`"));
            f = l + y + c;
          } else
            f = e.pad(this._config.amount);
          return o + f;
        }, "_render")
      }], [{
        key: "pad",
        value: /* @__PURE__ */ s(function(o) {
          return h$.repeatString(" ", o);
        }, "pad")
      }]), n;
    }(c$());
    return e = t, t;
  }.call(void 0);
});

// ../node_modules/renderkid/lib/layout/block/lineAppendor/_LineAppendor.js
var _$ = b((DRt, g$) => {
  "use strict";
  function NYe(e, t) {
    if (!(e instanceof t))
      throw new TypeError("Cannot call a class as a function");
  }
  s(NYe, "_classCallCheck");
  function y$(e, t) {
    for (var r = 0; r < t.length; r++) {
      var i = t[r];
      i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);
    }
  }
  s(y$, "_defineProperties");
  function LYe(e, t, r) {
    return t && y$(e.prototype, t), r && y$(e, r), e;
  }
  s(LYe, "_createClass");
  var FYe;
  g$.exports = FYe = /* @__PURE__ */ function() {
    function e(t) {
      NYe(this, e), this._config = t, this._lineNo = 0;
    }
    return s(e, "_LineAppendor"), LYe(e, [{
      key: "render",
      value: /* @__PURE__ */ s(function(r, i) {
        return this._lineNo++, "<none>" + this._render(r, i) + "</none>";
      }, "render")
    }]), e;
  }();
});

// ../node_modules/renderkid/lib/layout/block/lineAppendor/Default.js
var T$ = b((ORt, S$) => {
  "use strict";
  function Uv(e) {
    "@babel/helpers - typeof";
    return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Uv = /* @__PURE__ */ s(function(r) {
      return typeof r;
    }, "_typeof") : Uv = /* @__PURE__ */ s(function(r) {
      return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
    }, "_typeof"), Uv(e);
  }
  s(Uv, "_typeof");
  function MYe(e, t) {
    if (!(e instanceof t))
      throw new TypeError("Cannot call a class as a function");
  }
  s(MYe, "_classCallCheck");
  function b$(e, t) {
    for (var r = 0; r < t.length; r++) {
      var i = t[r];
      i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);
    }
  }
  s(b$, "_defineProperties");
  function BYe(e, t, r) {
    return t && b$(e.prototype, t), r && b$(e, r), e;
  }
  s(BYe, "_createClass");
  function qYe(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Super expression must either be null or a function");
    e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), t && r2(e, t);
  }
  s(qYe, "_inherits");
  function r2(e, t) {
    return r2 = Object.setPrototypeOf || /* @__PURE__ */ s(function(i, n) {
      return i.__proto__ = n, i;
    }, "_setPrototypeOf"), r2(e, t);
  }
  s(r2, "_setPrototypeOf");
  function UYe(e) {
    var t = KYe();
    return /* @__PURE__ */ s(function() {
      var i = jv(e), n;
      if (t) {
        var a = jv(this).constructor;
        n = Reflect.construct(i, arguments, a);
      } else
        n = i.apply(this, arguments);
      return jYe(this, n);
    }, "_createSuperInternal");
  }
  s(UYe, "_createSuper");
  function jYe(e, t) {
    return t && (Uv(t) === "object" || typeof t == "function") ? t : VYe(e);
  }
  s(jYe, "_possibleConstructorReturn");
  function VYe(e) {
    if (e === void 0)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e;
  }
  s(VYe, "_assertThisInitialized");
  function KYe() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
    if (typeof Proxy == "function") return !0;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      })), !0;
    } catch {
      return !1;
    }
  }
  s(KYe, "_isNativeReflectConstruct");
  function jv(e) {
    return jv = Object.setPrototypeOf ? Object.getPrototypeOf : /* @__PURE__ */ s(function(r) {
      return r.__proto__ || Object.getPrototypeOf(r);
    }, "_getPrototypeOf"), jv(e);
  }
  s(jv, "_getPrototypeOf");
  var HYe, v$;
  v$ = ys();
  S$.exports = HYe = /* @__PURE__ */ function(e) {
    qYe(r, e);
    var t = UYe(r);
    function r() {
      return MYe(this, r), t.apply(this, arguments);
    }
    return s(r, "DefaultLineAppendor"), BYe(r, [{
      key: "_render",
      value: /* @__PURE__ */ s(function(n, a) {
        return n + v$.repeatString(" ", this._config.amount);
      }, "_render")
    }]), r;
  }(_$());
});

// ../node_modules/renderkid/lib/layout/block/lineWrapper/_LineWrapper.js
var x$ = b((IRt, A$) => {
  "use strict";
  function zYe(e, t) {
    if (!(e instanceof t))
      throw new TypeError("Cannot call a class as a function");
  }
  s(zYe, "_classCallCheck");
  function E$(e, t) {
    for (var r = 0; r < t.length; r++) {
      var i = t[r];
      i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);
    }
  }
  s(E$, "_defineProperties");
  function GYe(e, t, r) {
    return t && E$(e.prototype, t), r && E$(e, r), e;
  }
  s(GYe, "_createClass");
  var WYe;
  A$.exports = WYe = /* @__PURE__ */ function() {
    function e() {
      zYe(this, e);
    }
    return s(e, "_LineWrapper"), GYe(e, [{
      key: "render",
      value: /* @__PURE__ */ s(function(r, i) {
        return this._render(r, i);
      }, "render")
    }]), e;
  }();
});

// ../node_modules/renderkid/lib/layout/block/lineWrapper/Default.js
var D$ = b((NRt, P$) => {
  "use strict";
  function Vv(e) {
    "@babel/helpers - typeof";
    return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Vv = /* @__PURE__ */ s(function(r) {
      return typeof r;
    }, "_typeof") : Vv = /* @__PURE__ */ s(function(r) {
      return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
    }, "_typeof"), Vv(e);
  }
  s(Vv, "_typeof");
  function $Ye(e, t) {
    if (!(e instanceof t))
      throw new TypeError("Cannot call a class as a function");
  }
  s($Ye, "_classCallCheck");
  function C$(e, t) {
    for (var r = 0; r < t.length; r++) {
      var i = t[r];
      i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);
    }
  }
  s(C$, "_defineProperties");
  function XYe(e, t, r) {
    return t && C$(e.prototype, t), r && C$(e, r), e;
  }
  s(XYe, "_createClass");
  function YYe(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Super expression must either be null or a function");
    e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), t && i2(e, t);
  }
  s(YYe, "_inherits");
  function i2(e, t) {
    return i2 = Object.setPrototypeOf || /* @__PURE__ */ s(function(i, n) {
      return i.__proto__ = n, i;
    }, "_setPrototypeOf"), i2(e, t);
  }
  s(i2, "_setPrototypeOf");
  function JYe(e) {
    var t = eJe();
    return /* @__PURE__ */ s(function() {
      var i = Kv(e), n;
      if (t) {
        var a = Kv(this).constructor;
        n = Reflect.construct(i, arguments, a);
      } else
        n = i.apply(this, arguments);
      return QYe(this, n);
    }, "_createSuperInternal");
  }
  s(JYe, "_createSuper");
  function QYe(e, t) {
    return t && (Vv(t) === "object" || typeof t == "function") ? t : ZYe(e);
  }
  s(QYe, "_possibleConstructorReturn");
  function ZYe(e) {
    if (e === void 0)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e;
  }
  s(ZYe, "_assertThisInitialized");
  function eJe() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
    if (typeof Proxy == "function") return !0;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      })), !0;
    } catch {
      return !1;
    }
  }
  s(eJe, "_isNativeReflectConstruct");
  function Kv(e) {
    return Kv = Object.setPrototypeOf ? Object.getPrototypeOf : /* @__PURE__ */ s(function(r) {
      return r.__proto__ || Object.getPrototypeOf(r);
    }, "_getPrototypeOf"), Kv(e);
  }
  s(Kv, "_getPrototypeOf");
  var tJe;
  P$.exports = tJe = /* @__PURE__ */ function(e) {
    YYe(r, e);
    var t = JYe(r);
    function r() {
      return $Ye(this, r), t.apply(this, arguments);
    }
    return s(r, "DefaultLineWrapper"), XYe(r, [{
      key: "_render",
      value: /* @__PURE__ */ s(function() {
      }, "_render")
    }]), r;
  }(x$());
});

// ../node_modules/renderkid/lib/layout/Block.js
var R$ = b((FRt, I$) => {
  "use strict";
  function rJe(e, t) {
    if (!(e instanceof t))
      throw new TypeError("Cannot call a class as a function");
  }
  s(rJe, "_classCallCheck");
  function w$(e, t) {
    for (var r = 0; r < t.length; r++) {
      var i = t[r];
      i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);
    }
  }
  s(w$, "_defineProperties");
  function iJe(e, t, r) {
    return t && w$(e.prototype, t), r && w$(e, r), e;
  }
  s(iJe, "_createClass");
  var nJe, lm, O$, k$;
  lm = Rv();
  k$ = ys().getCols();
  var sJe = ys();
  O$ = sJe.cloneAndMergeDeep;
  I$.exports = nJe = function() {
    var e, t = /* @__PURE__ */ function() {
      function r(i, n) {
        var a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] :
        "";
        rJe(this, r), this._layout = i, this._parent = n, this._name = o, this._config = O$(e.defaultConfig, a), this._closed = !1, this._wasOpenOnce =
        !1, this._active = !1, this._buffer = "", this._didSeparateBlock = !1, this._linePrependor = new this._config.linePrependor.fn(this.
        _config.linePrependor.options), this._lineAppendor = new this._config.lineAppendor.fn(this._config.lineAppendor.options), this._blockPrependor =
        new this._config.blockPrependor.fn(this._config.blockPrependor.options), this._blockAppendor = new this._config.blockAppendor.fn(this.
        _config.blockAppendor.options);
      }
      return s(r, "Block"), iJe(r, [{
        key: "_activate",
        value: /* @__PURE__ */ s(function() {
          var n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
          if (this._active)
            throw Error("This block is already active. This is probably a bug in RenderKid itself");
          if (this._closed)
            throw Error("This block is closed and cannot be activated. This is probably a bug in RenderKid itself");
          return this._active = !0, this._layout._activeBlock = this, n && this._parent != null && this._parent._deactivate(!1), this;
        }, "_activate")
      }, {
        key: "_deactivate",
        value: /* @__PURE__ */ s(function() {
          var n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
          return this._ensureActive(), this._flushBuffer(), n && this._parent != null && this._parent._activate(!1), this._active = !1, this;
        }, "_deactivate")
      }, {
        key: "_ensureActive",
        value: /* @__PURE__ */ s(function() {
          if (!this._wasOpenOnce)
            throw Error("This block has never been open before. This is probably a bug in RenderKid itself.");
          if (!this._active)
            throw Error("This block is not active. This is probably a bug in RenderKid itself.");
          if (this._closed)
            throw Error("This block is already closed. This is probably a bug in RenderKid itself.");
        }, "_ensureActive")
      }, {
        key: "_open",
        value: /* @__PURE__ */ s(function() {
          if (this._wasOpenOnce)
            throw Error("Block._open() has been called twice. This is probably a RenderKid bug.");
          return this._wasOpenOnce = !0, this._parent != null && this._parent.write(this._whatToPrependToBlock()), this._activate(), this;
        }, "_open")
      }, {
        key: "close",
        value: /* @__PURE__ */ s(function() {
          return this._deactivate(), this._closed = !0, this._parent != null && this._parent.write(this._whatToAppendToBlock()), this;
        }, "close")
      }, {
        key: "isOpen",
        value: /* @__PURE__ */ s(function() {
          return this._wasOpenOnce && !this._closed;
        }, "isOpen")
      }, {
        key: "write",
        value: /* @__PURE__ */ s(function(n) {
          if (this._ensureActive(), n !== "")
            return n = String(n), this._buffer += n, this;
        }, "write")
      }, {
        key: "openBlock",
        value: /* @__PURE__ */ s(function(n, a) {
          var o;
          return this._ensureActive(), o = new r(this._layout, this, n, a), o._open(), o;
        }, "openBlock")
      }, {
        key: "_flushBuffer",
        value: /* @__PURE__ */ s(function() {
          var n;
          this._buffer !== "" && (n = this._buffer, this._buffer = "", this._writeInline(n));
        }, "_flushBuffer")
      }, {
        key: "_toPrependToLine",
        value: /* @__PURE__ */ s(function() {
          var n;
          return n = "", this._parent != null && (n = this._parent._toPrependToLine()), this._linePrependor.render(n);
        }, "_toPrependToLine")
      }, {
        key: "_toAppendToLine",
        value: /* @__PURE__ */ s(function() {
          var n;
          return n = "", this._parent != null && (n = this._parent._toAppendToLine()), this._lineAppendor.render(n);
        }, "_toAppendToLine")
      }, {
        key: "_whatToPrependToBlock",
        value: /* @__PURE__ */ s(function() {
          return this._blockPrependor.render();
        }, "_whatToPrependToBlock")
      }, {
        key: "_whatToAppendToBlock",
        value: /* @__PURE__ */ s(function() {
          return this._blockAppendor.render();
        }, "_whatToAppendToBlock")
      }, {
        key: "_writeInline",
        value: /* @__PURE__ */ s(function(n) {
          var a, o, u, l, c, p, h, y, _, g;
          if (new lm(n).isOnlySpecialChars()) {
            this._layout._append(n);
            return;
          }
          if (g = n, c = 0, p = g.match(/^\n+/)) {
            for (a = o = 1, h = p[0].length; 1 <= h ? o <= h : o >= h; a = 1 <= h ? ++o : --o)
              this._writeLine("");
            g = g.substr(p[0].length, g.length);
          }
          for ((p = g.match(/\n+$/)) && (c = p[0].length, g = g.substr(0, g.length - p[0].length)); g.length > 0; )
            if (p = g.match(/^[^\n]+/))
              this._writeLine(p[0]), g = g.substr(p[0].length, g.length);
            else if (p = g.match(/^\n+/)) {
              for (a = u = 1, y = p[0].length; 1 <= y ? u < y : u > y; a = 1 <= y ? ++u : --u)
                this._writeLine("");
              g = g.substr(p[0].length, g.length);
            }
          if (c > 0)
            for (a = l = 1, _ = c; 1 <= _ ? l <= _ : l >= _; a = 1 <= _ ? ++l : --l)
              this._writeLine("");
        }, "_writeInline")
        // wraps a line into multiple lines if necessary, adds horizontal margins,
        // etc, and appends it to the layout.
      }, {
        key: "_writeLine",
        value: /* @__PURE__ */ s(function(n) {
          var a, o, u, l, c, p, h, y, _;
          for (l = new lm(n); y = this._toPrependToLine(), _ = new lm(y).length, p = this._toAppendToLine(), h = new lm(p).length, c = this.
          _layout._config.terminalWidth - (_ + h), u = Math.min(this._config.width, c), o = l.cut(0, u, !0), a = y + o.str + p, this._layout.
          _appendLine(a), !l.isEmpty(); )
            ;
        }, "_writeLine")
      }]), r;
    }();
    return e = t, t.defaultConfig = {
      blockPrependor: {
        fn: e$(),
        options: {
          amount: 0
        }
      },
      blockAppendor: {
        fn: o$(),
        options: {
          amount: 0
        }
      },
      linePrependor: {
        fn: m$(),
        options: {
          amount: 0
        }
      },
      lineAppendor: {
        fn: T$(),
        options: {
          amount: 0
        }
      },
      lineWrapper: {
        fn: D$(),
        options: {
          lineWidth: null
        }
      },
      width: k$,
      prefixRaw: "",
      suffixRaw: ""
    }, t;
  }.call(void 0);
});

// ../node_modules/renderkid/lib/Layout.js
var V$ = b((BRt, j$) => {
  "use strict";
  function aJe(e, t) {
    if (!(e instanceof t))
      throw new TypeError("Cannot call a class as a function");
  }
  s(aJe, "_classCallCheck");
  function N$(e, t) {
    for (var r = 0; r < t.length; r++) {
      var i = t[r];
      i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);
    }
  }
  s(N$, "_defineProperties");
  function oJe(e, t, r) {
    return t && N$(e.prototype, t), r && N$(e, r), e;
  }
  s(oJe, "_createClass");
  var M$, B$, q$, n2, Hv, L$, F$, s2, U$;
  M$ = R$();
  var uJe = ys();
  n2 = uJe.cloneAndMergeDeep;
  q$ = Rv();
  U$ = ys().getCols();
  j$.exports = B$ = function() {
    var e, t = /* @__PURE__ */ function() {
      function r() {
        var i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] :
        {};
        aJe(this, r);
        var a;
        this._written = [], this._activeBlock = null, this._config = n2(e._defaultConfig, i), a = n2(e._rootBlockDefaultConfig, n), this._root =
        new M$(this, null, a, "__root"), this._root._open();
      }
      return s(r, "Layout"), oJe(r, [{
        key: "getRootBlock",
        value: /* @__PURE__ */ s(function() {
          return this._root;
        }, "getRootBlock")
      }, {
        key: "_append",
        value: /* @__PURE__ */ s(function(n) {
          return this._written.push(n);
        }, "_append")
      }, {
        key: "_appendLine",
        value: /* @__PURE__ */ s(function(n) {
          var a;
          return this._append(n), a = new q$(n), a.length < this._config.terminalWidth && this._append(`<none>
</none>`), this;
        }, "_appendLine")
      }, {
        key: "get",
        value: /* @__PURE__ */ s(function() {
          return this._ensureClosed(), this._written[this._written.length - 1] === `<none>
</none>` && this._written.pop(), this._written.join("");
        }, "get")
      }, {
        key: "_ensureClosed",
        value: /* @__PURE__ */ s(function() {
          if (this._activeBlock !== this._root)
            throw Error("Not all the blocks have been closed. Please call block.close() on all open blocks.");
          this._root.isOpen() && this._root.close();
        }, "_ensureClosed")
      }]), r;
    }();
    return e = t, t._rootBlockDefaultConfig = {
      linePrependor: {
        options: {
          amount: 0
        }
      },
      lineAppendor: {
        options: {
          amount: 0
        }
      },
      blockPrependor: {
        options: {
          amount: 0
        }
      },
      blockAppendor: {
        options: {
          amount: 0
        }
      }
    }, t._defaultConfig = {
      terminalWidth: U$
    }, t;
  }.call(void 0);
  s2 = ["openBlock", "write"];
  for (Hv = 0, L$ = s2.length; Hv < L$; Hv++)
    F$ = s2[Hv], function() {
      var e;
      return e = F$, B$.prototype[e] = function() {
        return this._root[e].apply(this._root, arguments);
      };
    }();
});

// ../node_modules/renderkid/node_modules/ansi-regex/index.js
var H$ = b((URt, K$) => {
  "use strict";
  K$.exports = ({ onlyFirst: e = !1 } = {}) => {
    let t = [
      "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
      "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
    ].join("|");
    return new RegExp(t, e ? void 0 : "g");
  };
});

// ../node_modules/renderkid/node_modules/strip-ansi/index.js
var G$ = b((jRt, z$) => {
  "use strict";
  var lJe = H$();
  z$.exports = (e) => typeof e == "string" ? e.replace(lJe(), "") : e;
});

// ../node_modules/renderkid/lib/RenderKid.js
var rX = b((VRt, tX) => {
  "use strict";
  function cJe(e, t) {
    if (!(e instanceof t))
      throw new TypeError("Cannot call a class as a function");
  }
  s(cJe, "_classCallCheck");
  function W$(e, t) {
    for (var r = 0; r < t.length; r++) {
      var i = t[r];
      i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);
    }
  }
  s(W$, "_defineProperties");
  function fJe(e, t, r) {
    return t && W$(e.prototype, t), r && W$(e, r), e;
  }
  s(fJe, "_createClass");
  var a2, o2, pJe, $$, X$, Y$, J$, Q$, Z$, eX, cm;
  J$ = kz();
  X$ = Rz();
  Q$ = qd();
  var hJe = ys();
  Y$ = hJe.cloneAndMergeDeep;
  a2 = aw();
  $$ = KW();
  o2 = V$();
  cm = ys();
  Z$ = G$();
  eX = ys().getCols();
  tX.exports = pJe = function() {
    var e, t = /* @__PURE__ */ function() {
      function r() {
        var i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        cJe(this, r), this.tools = e.tools, this._config = Y$(e._defaultConfig, i), this._initStyles();
      }
      return s(r, "RenderKid"), fJe(r, [{
        key: "_initStyles",
        value: /* @__PURE__ */ s(function() {
          return this._styles = new $$();
        }, "_initStyles")
      }, {
        key: "style",
        value: /* @__PURE__ */ s(function() {
          return this._styles.setRule.apply(this._styles, arguments);
        }, "style")
      }, {
        key: "_getStyleFor",
        value: /* @__PURE__ */ s(function(n) {
          return this._styles.getStyleFor(n);
        }, "_getStyleFor")
      }, {
        key: "render",
        value: /* @__PURE__ */ s(function(n) {
          var a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
          return this._paint(this._renderDom(this._toDom(n)), a);
        }, "render")
      }, {
        key: "_toDom",
        value: /* @__PURE__ */ s(function(n) {
          if (typeof n == "string")
            return this._parse(n);
          if (Q$(n) || Array.isArray(n))
            return this._objToDom(n);
          throw Error("Invalid input type. Only strings, arrays and objects are accepted");
        }, "_toDom")
      }, {
        key: "_objToDom",
        value: /* @__PURE__ */ s(function(n) {
          var a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
          return a && (n = {
            body: n
          }), cm.objectToDom(n);
        }, "_objToDom")
      }, {
        key: "_paint",
        value: /* @__PURE__ */ s(function(n, a) {
          var o;
          return o = a2.paint(n), a ? o : Z$(o);
        }, "_paint")
      }, {
        key: "_parse",
        value: /* @__PURE__ */ s(function(n) {
          var a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
          return a && (n = "<body>" + n + "</body>"), cm.stringToDom(n);
        }, "_parse")
      }, {
        key: "_renderDom",
        value: /* @__PURE__ */ s(function(n) {
          var a, o, u;
          return a = n[0], o = new o2(this._config.layout), u = o.getRootBlock(), this._renderBlockNode(a, null, u), o.get();
        }, "_renderDom")
      }, {
        key: "_renderChildrenOf",
        value: /* @__PURE__ */ s(function(n, a) {
          var o, u, l, c;
          for (c = n.children, o = 0, u = c.length; o < u; o++)
            l = c[o], this._renderNode(l, n, a);
        }, "_renderChildrenOf")
      }, {
        key: "_renderNode",
        value: /* @__PURE__ */ s(function(n, a, o) {
          if (n.type === "text")
            this._renderText(n, a, o);
          else if (n.name === "br")
            this._renderBr(n, a, o);
          else if (this._isBlock(n))
            this._renderBlockNode(n, a, o);
          else {
            if (this._isNone(n))
              return;
            this._renderInlineNode(n, a, o);
          }
        }, "_renderNode")
      }, {
        key: "_renderText",
        value: /* @__PURE__ */ s(function(n, a, o) {
          var u, l;
          if (l = n.data, l = l.replace(/\s+/g, " "), (a != null && (u = a.styles) != null ? u.display : void 0) !== "inline" && (l = l.trim()),
          l.length !== 0)
            return l = l.replace(/&nl;/g, `
`), o.write(l);
        }, "_renderText")
      }, {
        key: "_renderBlockNode",
        value: /* @__PURE__ */ s(function(n, a, o) {
          var u, l, c, p, h = X$.applyTo(n, this._getStyleFor(n));
          return l = h.before, u = h.after, p = h.blockConfig, c = o.openBlock(p), l !== "" && c.write(l), this._renderChildrenOf(n, c), u !==
          "" && c.write(u), c.close();
        }, "_renderBlockNode")
      }, {
        key: "_renderInlineNode",
        value: /* @__PURE__ */ s(function(n, a, o) {
          var u, l, c = J$.applyTo(n, this._getStyleFor(n));
          if (l = c.before, u = c.after, l !== "" && o.write(l), this._renderChildrenOf(n, o), u !== "")
            return o.write(u);
        }, "_renderInlineNode")
      }, {
        key: "_renderBr",
        value: /* @__PURE__ */ s(function(n, a, o) {
          return o.write(`
`);
        }, "_renderBr")
      }, {
        key: "_isBlock",
        value: /* @__PURE__ */ s(function(n) {
          return !(n.type === "text" || n.name === "br" || this._getStyleFor(n).display !== "block");
        }, "_isBlock")
      }, {
        key: "_isNone",
        value: /* @__PURE__ */ s(function(n) {
          return !(n.type === "text" || n.name === "br" || this._getStyleFor(n).display !== "none");
        }, "_isNone")
      }]), r;
    }();
    return e = t, t.AnsiPainter = a2, t.Layout = o2, t.quote = cm.quote, t.tools = cm, t._defaultConfig = {
      layout: {
        terminalWidth: eX
      }
    }, t;
  }.call(void 0);
});

// ../node_modules/pretty-error/lib/PrettyError.js
var fX = b((HRt, cX) => {
  var l2, nX, sX, kc, aX, Ic, oX, uX, c2, fm, lX, zv, iX, f2, Ko = [].slice, u2 = [].indexOf || function(e) {
    for (var t = 0, r = this.length; t < r; t++)
      if (t in this && this[t] === e) return t;
    return -1;
  };
  oX = qd();
  aX = gj();
  l2 = Tj();
  c2 = Aj();
  sX = rX();
  uX = xb();
  kc = {
    pluckByCallback: /* @__PURE__ */ s(function(e, t) {
      var r, i, n, a, o;
      if (e.length < 1)
        return e;
      for (i = 0, r = a = 0, o = e.length; a < o; r = ++a) {
        if (n = e[r], t(n, r)) {
          i++;
          continue;
        }
        i !== 0 && (e[r - i] = e[r]);
      }
      return i > 0 && (e.length = e.length - i), e;
    }, "pluckByCallback"),
    pluckOneItem: /* @__PURE__ */ s(function(e, t) {
      var r, i, n, a, o;
      if (e.length < 1)
        return e;
      for (i = !1, r = a = 0, o = e.length; a < o; r = ++a)
        if (n = e[r], i)
          e[r - 1] = e[r];
        else if (n === t) {
          i = !0;
          continue;
        }
      return i && (e.length = e.length - 1), e;
    }, "pluckOneItem")
  };
  Ic = null;
  cX.exports = nX = function() {
    var e;
    e = t, t._filters = {
      "module.exports": /* @__PURE__ */ s(function(r) {
        r.what != null && (r.what = r.what.replace(/\.module\.exports\./g, " - "));
      }, "module.exports")
    }, t._getDefaultStyle = function() {
      return aX();
    }, t.start = function() {
      return Ic == null && (Ic = new e(), Ic.start()), Ic;
    }, t.stop = function() {
      return Ic?.stop();
    };
    function t() {
      this._useColors = !0, this._maxItems = 50, this._packagesToSkip = [], this._pathsToSkip = [], this._skipCallbacks = [], this._filterCallbacks =
      [], this._parsedErrorFilters = [], this._aliases = [], this._renderer = new sX(), this._style = e._getDefaultStyle(), this._renderer.style(
      this._style);
    }
    return s(t, "PrettyError"), t.prototype.start = function() {
      var r;
      return this._oldPrepareStackTrace = Error.prepareStackTrace, r = this._oldPrepareStackTrace || function(i, n) {
        var a;
        return a = i.toString(), n = n.map(function(o) {
          return "  at " + o.toString();
        }), a + `
` + n.join(`
`);
      }, Error.prepareStackTrace = /* @__PURE__ */ function(i) {
        return function(n, a) {
          var o;
          return o = r.apply(null, arguments), i.render({
            stack: o,
            message: n.toString().replace(/^.*: /, "")
          }, !1);
        };
      }(this), this;
    }, t.prototype.stop = function() {
      return Error.prepareStackTrace = this._oldPrepareStackTrace, this._oldPrepareStackTrace = null;
    }, t.prototype.config = function(r) {
      var i, n, a;
      if (r.skipPackages != null && (r.skipPackages === !1 ? this.unskipAllPackages() : this.skipPackage.apply(this, r.skipPackages)), r.skipPaths !=
      null && (r.skipPaths === !1 ? this.unskipAllPaths() : this.skipPath.apply(this, r.skipPaths)), r.skip != null && (r.skip === !1 ? this.
      unskipAll() : this.skip.apply(this, r.skip)), r.maxItems != null && this.setMaxItems(r.maxItems), r.skipNodeFiles === !0 ? this.skipNodeFiles() :
      r.skipNodeFiles === !1 && this.unskipNodeFiles(), r.filters != null && (r.filters === !1 ? this.removeAllFilters() : this.filter.apply(
      this, r.filters)), r.parsedErrorFilters != null && (r.parsedErrorFilters === !1 ? this.removeAllParsedErrorFilters() : this.filterParsedError.
      apply(this, r.parsedErrorFilters)), r.aliases != null)
        if (oX(r.aliases)) {
          a = r.aliases;
          for (n in a)
            i = a[n], this.alias(n, i);
        } else r.aliases === !1 && this.removeAllAliases();
      return this;
    }, t.prototype.withoutColors = function() {
      return this._useColors = !1, this;
    }, t.prototype.withColors = function() {
      return this._useColors = !0, this;
    }, t.prototype.skipPackage = function() {
      var r, i, n, a;
      for (r = 1 <= arguments.length ? Ko.call(arguments, 0) : [], n = 0, a = r.length; n < a; n++)
        i = r[n], this._packagesToSkip.push(String(i));
      return this;
    }, t.prototype.unskipPackage = function() {
      var r, i, n, a;
      for (r = 1 <= arguments.length ? Ko.call(arguments, 0) : [], n = 0, a = r.length; n < a; n++)
        i = r[n], kc.pluckOneItem(this._packagesToSkip, i);
      return this;
    }, t.prototype.unskipAllPackages = function() {
      return this._packagesToSkip.length = 0, this;
    }, t.prototype.skipPath = function() {
      var r, i, n, a;
      for (i = 1 <= arguments.length ? Ko.call(arguments, 0) : [], n = 0, a = i.length; n < a; n++)
        r = i[n], this._pathsToSkip.push(r);
      return this;
    }, t.prototype.unskipPath = function() {
      var r, i, n, a;
      for (i = 1 <= arguments.length ? Ko.call(arguments, 0) : [], n = 0, a = i.length; n < a; n++)
        r = i[n], kc.pluckOneItem(this._pathsToSkip, r);
      return this;
    }, t.prototype.unskipAllPaths = function() {
      return this._pathsToSkip.length = 0, this;
    }, t.prototype.skip = function() {
      var r, i, n, a;
      for (r = 1 <= arguments.length ? Ko.call(arguments, 0) : [], n = 0, a = r.length; n < a; n++)
        i = r[n], this._skipCallbacks.push(i);
      return this;
    }, t.prototype.unskip = function() {
      var r, i, n, a;
      for (r = 1 <= arguments.length ? Ko.call(arguments, 0) : [], n = 0, a = r.length; n < a; n++)
        i = r[n], kc.pluckOneItem(this._skipCallbacks, i);
      return this;
    }, t.prototype.unskipAll = function() {
      return this._skipCallbacks.length = 0, this;
    }, t.prototype.skipNodeFiles = function() {
      return this.skipPath.apply(this, c2);
    }, t.prototype.unskipNodeFiles = function() {
      return this.unskipPath.apply(this, c2);
    }, t.prototype.filter = function() {
      var r, i, n, a;
      for (r = 1 <= arguments.length ? Ko.call(arguments, 0) : [], n = 0, a = r.length; n < a; n++)
        i = r[n], this._filterCallbacks.push(i);
      return this;
    }, t.prototype.removeFilter = function() {
      var r, i, n, a;
      for (r = 1 <= arguments.length ? Ko.call(arguments, 0) : [], n = 0, a = r.length; n < a; n++)
        i = r[n], kc.pluckOneItem(this._filterCallbacks, i);
      return this;
    }, t.prototype.removeAllFilters = function() {
      return this._filterCallbacks.length = 0, this;
    }, t.prototype.filterParsedError = function() {
      var r, i, n, a;
      for (r = 1 <= arguments.length ? Ko.call(arguments, 0) : [], n = 0, a = r.length; n < a; n++)
        i = r[n], this._parsedErrorFilters.push(i);
      return this;
    }, t.prototype.removeParsedErrorFilter = function() {
      var r, i, n, a;
      for (r = 1 <= arguments.length ? Ko.call(arguments, 0) : [], n = 0, a = r.length; n < a; n++)
        i = r[n], kc.pluckOneItem(this._parsedErrorFilters, i);
      return this;
    }, t.prototype.removeAllParsedErrorFilters = function() {
      return this._parsedErrorFilters.length = 0, this;
    }, t.prototype.setMaxItems = function(r) {
      return r == null && (r = 50), r === 0 && (r = 50), this._maxItems = r | 0, this;
    }, t.prototype.alias = function(r, i) {
      return this._aliases.push({
        stringOrRx: r,
        alias: i
      }), this;
    }, t.prototype.removeAlias = function(r) {
      return kc.pluckByCallback(this._aliases, function(i) {
        return i.stringOrRx === r;
      }), this;
    }, t.prototype.removeAllAliases = function() {
      return this._aliases.length = 0, this;
    }, t.prototype._getStyle = function() {
      return this._style;
    }, t.prototype.appendStyle = function(r) {
      return uX(this._style, r), this._renderer.style(r), this;
    }, t.prototype._getRenderer = function() {
      return this._renderer;
    }, t.prototype.render = function(r, i, n) {
      var a, o;
      return i == null && (i = !1), n == null && (n = this._useColors), a = this.getObject(r), o = this._renderer.render(a, n), i === !0 && console.
      error(o), o;
    }, t.prototype.getObject = function(r) {
      var i, n, a, o, u, l, c, p, h;
      for (r instanceof l2 || (r = new l2(r)), this._applyParsedErrorFiltersOn(r), n = {
        title: function() {
          var y;
          return y = {}, r.wrapper !== "" && (y.wrapper = "" + r.wrapper), y.kind = r.kind, y;
        }(),
        colon: ":",
        message: String(r.message).trim()
      }, l = [], i = -1, h = r.trace, a = c = 0, p = h.length; c < p; a = ++c)
        if (o = h[a], o != null && this._skipOrFilter(o, a) !== !0) {
          if (i++, i > this._maxItems)
            break;
          if (typeof o == "string") {
            l.push({
              item: {
                custom: o
              }
            });
            continue;
          }
          l.push(function() {
            var y;
            return y = {
              item: {
                header: {
                  pointer: function() {
                    return o.file == null ? "" : {
                      file: o.file,
                      colon: ":",
                      line: o.line
                    };
                  }()
                },
                footer: function() {
                  var _;
                  return _ = {
                    addr: o.shortenedAddr
                  }, o.extra != null && (_.extra = o.extra), _;
                }()
              }
            }, typeof o.what == "string" && o.what.trim().length > 0 && (y.item.header.what = o.what), y;
          }());
        }
      return u = {
        "pretty-error": {
          header: n
        }
      }, l.length > 0 && (u["pretty-error"].trace = l), u;
    }, t.prototype._skipOrFilter = function(r, i) {
      var n, a, o, u, l, c, p, h, y, _, g, m, f, d, v, E, S;
      if (typeof r == "object") {
        if (m = r.modName, u2.call(this._packagesToSkip, m) >= 0 || (f = r.path, u2.call(this._pathsToSkip, f) >= 0))
          return !0;
        for (d = r.packages, u = 0, h = d.length; u < h; u++)
          if (a = d[u], u2.call(this._packagesToSkip, a) >= 0)
            return !0;
        if (typeof r.shortenedAddr == "string")
          for (v = this._aliases, l = 0, y = v.length; l < y; l++)
            o = v[l], r.shortenedAddr = r.shortenedAddr.replace(o.stringOrRx, o.alias);
      }
      for (E = this._skipCallbacks, c = 0, _ = E.length; c < _; c++)
        if (n = E[c], n(r, i) === !0)
          return !0;
      for (S = this._filterCallbacks, p = 0, g = S.length; p < g; p++)
        n = S[p], n(r, i);
      return !1;
    }, t.prototype._applyParsedErrorFiltersOn = function(r) {
      var i, n, a, o;
      for (o = this._parsedErrorFilters, n = 0, a = o.length; n < a; n++)
        i = o[n], i(r);
    }, t;
  }();
  f2 = ["renderer", "style"];
  lX = /* @__PURE__ */ s(function() {
    var e;
    return e = "_get" + fm[0].toUpperCase() + fm.substr(1, fm.length), nX.prototype.__defineGetter__(fm, function() {
      return this[e]();
    });
  }, "_fn");
  for (zv = 0, iX = f2.length; zv < iX; zv++)
    fm = f2[zv], lX();
});

// ../node_modules/html-webpack-plugin/lib/errors.js
var hX = b((GRt, pX) => {
  "use strict";
  var Rc;
  function dJe() {
    if (!Rc) {
      let e = fX();
      Rc = new e(), Rc.withoutColors(), Rc.skipPackage("html-plugin-evaluation"), Rc.skipNodeFiles(), Rc.skip(function(t) {
        return t.path === "html-plugin-evaluation";
      });
    }
    return Rc;
  }
  s(dJe, "getPrettyError");
  pX.exports = function(e, t) {
    return {
      toHtml: /* @__PURE__ */ s(function() {
        return `Html Webpack Plugin:
<pre>
` + this.toString() + "</pre>";
      }, "toHtml"),
      toJsonHtml: /* @__PURE__ */ s(function() {
        return JSON.stringify(this.toHtml());
      }, "toJsonHtml"),
      toString: /* @__PURE__ */ s(function() {
        try {
          return dJe().render(e).replace(/webpack:\/\/\/\./g, t);
        } catch {
          return e;
        }
      }, "toString")
    };
  };
});

// ../node_modules/html-webpack-plugin/lib/chunksorter.js
var dX = b(($Rt, Op) => {
  "use strict";
  Op.exports = {};
  Op.exports.none = (e) => e;
  Op.exports.manual = (e, t, r) => {
    let i = r.chunks;
    return Array.isArray(i) ? i.filter((n) => t.entrypoints.has(n)) : e;
  };
  Op.exports.auto = Op.exports.none;
});

// ../node_modules/tapable/lib/Hook.js
var Pa = b((XRt, _X) => {
  "use strict";
  var mJe = require("util"), yJe = mJe.deprecate(
    () => {
    },
    "Hook.context is deprecated and will be removed"
  ), mX = /* @__PURE__ */ s(function(...e) {
    return this.call = this._createCall("sync"), this.call(...e);
  }, "CALL_DELEGATE"), yX = /* @__PURE__ */ s(function(...e) {
    return this.callAsync = this._createCall("async"), this.callAsync(...e);
  }, "CALL_ASYNC_DELEGATE"), gX = /* @__PURE__ */ s(function(...e) {
    return this.promise = this._createCall("promise"), this.promise(...e);
  }, "PROMISE_DELEGATE"), Gv = class {
    static {
      s(this, "Hook");
    }
    constructor(t = [], r = void 0) {
      this._args = t, this.name = r, this.taps = [], this.interceptors = [], this._call = mX, this.call = mX, this._callAsync = yX, this.callAsync =
      yX, this._promise = gX, this.promise = gX, this._x = void 0, this.compile = this.compile, this.tap = this.tap, this.tapAsync = this.tapAsync,
      this.tapPromise = this.tapPromise;
    }
    compile(t) {
      throw new Error("Abstract: should be overridden");
    }
    _createCall(t) {
      return this.compile({
        taps: this.taps,
        interceptors: this.interceptors,
        args: this._args,
        type: t
      });
    }
    _tap(t, r, i) {
      if (typeof r == "string")
        r = {
          name: r.trim()
        };
      else if (typeof r != "object" || r === null)
        throw new Error("Invalid tap options");
      if (typeof r.name != "string" || r.name === "")
        throw new Error("Missing name for tap");
      typeof r.context < "u" && yJe(), r = Object.assign({ type: t, fn: i }, r), r = this._runRegisterInterceptors(r), this._insert(r);
    }
    tap(t, r) {
      this._tap("sync", t, r);
    }
    tapAsync(t, r) {
      this._tap("async", t, r);
    }
    tapPromise(t, r) {
      this._tap("promise", t, r);
    }
    _runRegisterInterceptors(t) {
      for (let r of this.interceptors)
        if (r.register) {
          let i = r.register(t);
          i !== void 0 && (t = i);
        }
      return t;
    }
    withOptions(t) {
      let r = /* @__PURE__ */ s((i) => Object.assign({}, t, typeof i == "string" ? { name: i } : i), "mergeOptions");
      return {
        name: this.name,
        tap: /* @__PURE__ */ s((i, n) => this.tap(r(i), n), "tap"),
        tapAsync: /* @__PURE__ */ s((i, n) => this.tapAsync(r(i), n), "tapAsync"),
        tapPromise: /* @__PURE__ */ s((i, n) => this.tapPromise(r(i), n), "tapPromise"),
        intercept: /* @__PURE__ */ s((i) => this.intercept(i), "intercept"),
        isUsed: /* @__PURE__ */ s(() => this.isUsed(), "isUsed"),
        withOptions: /* @__PURE__ */ s((i) => this.withOptions(r(i)), "withOptions")
      };
    }
    isUsed() {
      return this.taps.length > 0 || this.interceptors.length > 0;
    }
    intercept(t) {
      if (this._resetCompilation(), this.interceptors.push(Object.assign({}, t)), t.register)
        for (let r = 0; r < this.taps.length; r++)
          this.taps[r] = t.register(this.taps[r]);
    }
    _resetCompilation() {
      this.call = this._call, this.callAsync = this._callAsync, this.promise = this._promise;
    }
    _insert(t) {
      this._resetCompilation();
      let r;
      typeof t.before == "string" ? r = /* @__PURE__ */ new Set([t.before]) : Array.isArray(t.before) && (r = new Set(t.before));
      let i = 0;
      typeof t.stage == "number" && (i = t.stage);
      let n = this.taps.length;
      for (; n > 0; ) {
        n--;
        let a = this.taps[n];
        this.taps[n + 1] = a;
        let o = a.stage || 0;
        if (r) {
          if (r.has(a.name)) {
            r.delete(a.name);
            continue;
          }
          if (r.size > 0)
            continue;
        }
        if (!(o > i)) {
          n++;
          break;
        }
      }
      this.taps[n] = t;
    }
  };
  Object.setPrototypeOf(Gv.prototype, null);
  _X.exports = Gv;
});

// ../node_modules/tapable/lib/HookCodeFactory.js
var Za = b((JRt, bX) => {
  "use strict";
  var p2 = class {
    static {
      s(this, "HookCodeFactory");
    }
    constructor(t) {
      this.config = t, this.options = void 0, this._args = void 0;
    }
    create(t) {
      this.init(t);
      let r;
      switch (this.options.type) {
        case "sync":
          r = new Function(
            this.args(),
            `"use strict";
` + this.header() + this.contentWithInterceptors({
              onError: /* @__PURE__ */ s((o) => `throw ${o};
`, "onError"),
              onResult: /* @__PURE__ */ s((o) => `return ${o};
`, "onResult"),
              resultReturns: !0,
              onDone: /* @__PURE__ */ s(() => "", "onDone"),
              rethrowIfPossible: !0
            })
          );
          break;
        case "async":
          r = new Function(
            this.args({
              after: "_callback"
            }),
            `"use strict";
` + this.header() + this.contentWithInterceptors({
              onError: /* @__PURE__ */ s((o) => `_callback(${o});
`, "onError"),
              onResult: /* @__PURE__ */ s((o) => `_callback(null, ${o});
`, "onResult"),
              onDone: /* @__PURE__ */ s(() => `_callback();
`, "onDone")
            })
          );
          break;
        case "promise":
          let i = !1, n = this.contentWithInterceptors({
            onError: /* @__PURE__ */ s((o) => (i = !0, `_error(${o});
`), "onError"),
            onResult: /* @__PURE__ */ s((o) => `_resolve(${o});
`, "onResult"),
            onDone: /* @__PURE__ */ s(() => `_resolve();
`, "onDone")
          }), a = "";
          a += `"use strict";
`, a += this.header(), a += `return new Promise((function(_resolve, _reject) {
`, i && (a += `var _sync = true;
`, a += `function _error(_err) {
`, a += `if(_sync)
`, a += `_resolve(Promise.resolve().then((function() { throw _err; })));
`, a += `else
`, a += `_reject(_err);
`, a += `};
`), a += n, i && (a += `_sync = false;
`), a += `}));
`, r = new Function(this.args(), a);
          break;
      }
      return this.deinit(), r;
    }
    setup(t, r) {
      t._x = r.taps.map((i) => i.fn);
    }
    /**
     * @param {{ type: "sync" | "promise" | "async", taps: Array<Tap>, interceptors: Array<Interceptor> }} options
     */
    init(t) {
      this.options = t, this._args = t.args.slice();
    }
    deinit() {
      this.options = void 0, this._args = void 0;
    }
    contentWithInterceptors(t) {
      if (this.options.interceptors.length > 0) {
        let r = t.onError, i = t.onResult, n = t.onDone, a = "";
        for (let o = 0; o < this.options.interceptors.length; o++) {
          let u = this.options.interceptors[o];
          u.call && (a += `${this.getInterceptor(o)}.call(${this.args({
            before: u.context ? "_context" : void 0
          })});
`);
        }
        return a += this.content(
          Object.assign(t, {
            onError: r && ((o) => {
              let u = "";
              for (let l = 0; l < this.options.interceptors.length; l++)
                this.options.interceptors[l].error && (u += `${this.getInterceptor(l)}.error(${o});
`);
              return u += r(o), u;
            }),
            onResult: i && ((o) => {
              let u = "";
              for (let l = 0; l < this.options.interceptors.length; l++)
                this.options.interceptors[l].result && (u += `${this.getInterceptor(l)}.result(${o});
`);
              return u += i(o), u;
            }),
            onDone: n && (() => {
              let o = "";
              for (let u = 0; u < this.options.interceptors.length; u++)
                this.options.interceptors[u].done && (o += `${this.getInterceptor(u)}.done();
`);
              return o += n(), o;
            })
          })
        ), a;
      } else
        return this.content(t);
    }
    header() {
      let t = "";
      return this.needContext() ? t += `var _context = {};
` : t += `var _context;
`, t += `var _x = this._x;
`, this.options.interceptors.length > 0 && (t += `var _taps = this.taps;
`, t += `var _interceptors = this.interceptors;
`), t;
    }
    needContext() {
      for (let t of this.options.taps) if (t.context) return !0;
      return !1;
    }
    callTap(t, { onError: r, onResult: i, onDone: n, rethrowIfPossible: a }) {
      let o = "", u = !1;
      for (let c = 0; c < this.options.interceptors.length; c++) {
        let p = this.options.interceptors[c];
        p.tap && (u || (o += `var _tap${t} = ${this.getTap(t)};
`, u = !0), o += `${this.getInterceptor(c)}.tap(${p.context ? "_context, " : ""}_tap${t});
`);
      }
      o += `var _fn${t} = ${this.getTapFn(t)};
`;
      let l = this.options.taps[t];
      switch (l.type) {
        case "sync":
          a || (o += `var _hasError${t} = false;
`, o += `try {
`), i ? o += `var _result${t} = _fn${t}(${this.args({
            before: l.context ? "_context" : void 0
          })});
` : o += `_fn${t}(${this.args({
            before: l.context ? "_context" : void 0
          })});
`, a || (o += `} catch(_err) {
`, o += `_hasError${t} = true;
`, o += r("_err"), o += `}
`, o += `if(!_hasError${t}) {
`), i && (o += i(`_result${t}`)), n && (o += n()), a || (o += `}
`);
          break;
        case "async":
          let c = "";
          i ? c += `(function(_err${t}, _result${t}) {
` : c += `(function(_err${t}) {
`, c += `if(_err${t}) {
`, c += r(`_err${t}`), c += `} else {
`, i && (c += i(`_result${t}`)), n && (c += n()), c += `}
`, c += "})", o += `_fn${t}(${this.args({
            before: l.context ? "_context" : void 0,
            after: c
          })});
`;
          break;
        case "promise":
          o += `var _hasResult${t} = false;
`, o += `var _promise${t} = _fn${t}(${this.args({
            before: l.context ? "_context" : void 0
          })});
`, o += `if (!_promise${t} || !_promise${t}.then)
`, o += `  throw new Error('Tap function (tapPromise) did not return promise (returned ' + _promise${t} + ')');
`, o += `_promise${t}.then((function(_result${t}) {
`, o += `_hasResult${t} = true;
`, i && (o += i(`_result${t}`)), n && (o += n()), o += `}), function(_err${t}) {
`, o += `if(_hasResult${t}) throw _err${t};
`, o += r(`_err${t}`), o += `});
`;
          break;
      }
      return o;
    }
    callTapsSeries({
      onError: t,
      onResult: r,
      resultReturns: i,
      onDone: n,
      doneReturns: a,
      rethrowIfPossible: o
    }) {
      if (this.options.taps.length === 0) return n();
      let u = this.options.taps.findIndex((y) => y.type !== "sync"), l = i || a, c = "", p = n, h = 0;
      for (let y = this.options.taps.length - 1; y >= 0; y--) {
        let _ = y;
        p !== n && (this.options.taps[_].type !== "sync" || h++ > 20) && (h = 0, c += `function _next${_}() {
`, c += p(), c += `}
`, p = /* @__PURE__ */ s(() => `${l ? "return " : ""}_next${_}();
`, "current"));
        let m = p, f = /* @__PURE__ */ s((v) => v ? "" : n(), "doneBreak"), d = this.callTap(_, {
          onError: /* @__PURE__ */ s((v) => t(_, v, m, f), "onError"),
          onResult: r && ((v) => r(_, v, m, f)),
          onDone: !r && m,
          rethrowIfPossible: o && (u < 0 || _ < u)
        });
        p = /* @__PURE__ */ s(() => d, "current");
      }
      return c += p(), c;
    }
    callTapsLooping({ onError: t, onDone: r, rethrowIfPossible: i }) {
      if (this.options.taps.length === 0) return r();
      let n = this.options.taps.every((o) => o.type === "sync"), a = "";
      n || (a += `var _looper = (function() {
`, a += `var _loopAsync = false;
`), a += `var _loop;
`, a += `do {
`, a += `_loop = false;
`;
      for (let o = 0; o < this.options.interceptors.length; o++) {
        let u = this.options.interceptors[o];
        u.loop && (a += `${this.getInterceptor(o)}.loop(${this.args({
          before: u.context ? "_context" : void 0
        })});
`);
      }
      return a += this.callTapsSeries({
        onError: t,
        onResult: /* @__PURE__ */ s((o, u, l, c) => {
          let p = "";
          return p += `if(${u} !== undefined) {
`, p += `_loop = true;
`, n || (p += `if(_loopAsync) _looper();
`), p += c(!0), p += `} else {
`, p += l(), p += `}
`, p;
        }, "onResult"),
        onDone: r && (() => {
          let o = "";
          return o += `if(!_loop) {
`, o += r(), o += `}
`, o;
        }),
        rethrowIfPossible: i && n
      }), a += `} while(_loop);
`, n || (a += `_loopAsync = true;
`, a += `});
`, a += `_looper();
`), a;
    }
    callTapsParallel({
      onError: t,
      onResult: r,
      onDone: i,
      rethrowIfPossible: n,
      onTap: a = /* @__PURE__ */ s((o, u) => u(), "onTap")
    }) {
      if (this.options.taps.length <= 1)
        return this.callTapsSeries({
          onError: t,
          onResult: r,
          onDone: i,
          rethrowIfPossible: n
        });
      let o = "";
      o += `do {
`, o += `var _counter = ${this.options.taps.length};
`, i && (o += `var _done = (function() {
`, o += i(), o += `});
`);
      for (let u = 0; u < this.options.taps.length; u++) {
        let l = /* @__PURE__ */ s(() => i ? `if(--_counter === 0) _done();
` : "--_counter;", "done"), c = /* @__PURE__ */ s((p) => p || !i ? `_counter = 0;
` : `_counter = 0;
_done();
`, "doneBreak");
        o += `if(_counter <= 0) break;
`, o += a(
          u,
          () => this.callTap(u, {
            onError: /* @__PURE__ */ s((p) => {
              let h = "";
              return h += `if(_counter > 0) {
`, h += t(u, p, l, c), h += `}
`, h;
            }, "onError"),
            onResult: r && ((p) => {
              let h = "";
              return h += `if(_counter > 0) {
`, h += r(u, p, l, c), h += `}
`, h;
            }),
            onDone: !r && (() => l()),
            rethrowIfPossible: n
          }),
          l,
          c
        );
      }
      return o += `} while(false);
`, o;
    }
    args({ before: t, after: r } = {}) {
      let i = this._args;
      return t && (i = [t].concat(i)), r && (i = i.concat(r)), i.length === 0 ? "" : i.join(", ");
    }
    getTapFn(t) {
      return `_x[${t}]`;
    }
    getTap(t) {
      return `_taps[${t}]`;
    }
    getInterceptor(t) {
      return `_interceptors[${t}]`;
    }
  };
  bX.exports = p2;
});

// ../node_modules/tapable/lib/SyncHook.js
var TX = b((ZRt, SX) => {
  "use strict";
  var gJe = Pa(), _Je = Za(), h2 = class extends _Je {
    static {
      s(this, "SyncHookCodeFactory");
    }
    content({ onError: t, onDone: r, rethrowIfPossible: i }) {
      return this.callTapsSeries({
        onError: /* @__PURE__ */ s((n, a) => t(a), "onError"),
        onDone: r,
        rethrowIfPossible: i
      });
    }
  }, vX = new h2(), bJe = /* @__PURE__ */ s(() => {
    throw new Error("tapAsync is not supported on a SyncHook");
  }, "TAP_ASYNC"), vJe = /* @__PURE__ */ s(() => {
    throw new Error("tapPromise is not supported on a SyncHook");
  }, "TAP_PROMISE"), SJe = /* @__PURE__ */ s(function(e) {
    return vX.setup(this, e), vX.create(e);
  }, "COMPILE");
  function d2(e = [], t = void 0) {
    let r = new gJe(e, t);
    return r.constructor = d2, r.tapAsync = bJe, r.tapPromise = vJe, r.compile = SJe, r;
  }
  s(d2, "SyncHook");
  d2.prototype = null;
  SX.exports = d2;
});

// ../node_modules/tapable/lib/SyncBailHook.js
var xX = b((tNt, AX) => {
  "use strict";
  var TJe = Pa(), EJe = Za(), m2 = class extends EJe {
    static {
      s(this, "SyncBailHookCodeFactory");
    }
    content({ onError: t, onResult: r, resultReturns: i, onDone: n, rethrowIfPossible: a }) {
      return this.callTapsSeries({
        onError: /* @__PURE__ */ s((o, u) => t(u), "onError"),
        onResult: /* @__PURE__ */ s((o, u, l) => `if(${u} !== undefined) {
${r(
          u
        )};
} else {
${l()}}
`, "onResult"),
        resultReturns: i,
        onDone: n,
        rethrowIfPossible: a
      });
    }
  }, EX = new m2(), AJe = /* @__PURE__ */ s(() => {
    throw new Error("tapAsync is not supported on a SyncBailHook");
  }, "TAP_ASYNC"), xJe = /* @__PURE__ */ s(() => {
    throw new Error("tapPromise is not supported on a SyncBailHook");
  }, "TAP_PROMISE"), CJe = /* @__PURE__ */ s(function(e) {
    return EX.setup(this, e), EX.create(e);
  }, "COMPILE");
  function y2(e = [], t = void 0) {
    let r = new TJe(e, t);
    return r.constructor = y2, r.tapAsync = AJe, r.tapPromise = xJe, r.compile = CJe, r;
  }
  s(y2, "SyncBailHook");
  y2.prototype = null;
  AX.exports = y2;
});

// ../node_modules/tapable/lib/SyncWaterfallHook.js
var DX = b((iNt, PX) => {
  "use strict";
  var PJe = Pa(), DJe = Za(), g2 = class extends DJe {
    static {
      s(this, "SyncWaterfallHookCodeFactory");
    }
    content({ onError: t, onResult: r, resultReturns: i, rethrowIfPossible: n }) {
      return this.callTapsSeries({
        onError: /* @__PURE__ */ s((a, o) => t(o), "onError"),
        onResult: /* @__PURE__ */ s((a, o, u) => {
          let l = "";
          return l += `if(${o} !== undefined) {
`, l += `${this._args[0]} = ${o};
`, l += `}
`, l += u(), l;
        }, "onResult"),
        onDone: /* @__PURE__ */ s(() => r(this._args[0]), "onDone"),
        doneReturns: i,
        rethrowIfPossible: n
      });
    }
  }, CX = new g2(), wJe = /* @__PURE__ */ s(() => {
    throw new Error("tapAsync is not supported on a SyncWaterfallHook");
  }, "TAP_ASYNC"), OJe = /* @__PURE__ */ s(() => {
    throw new Error("tapPromise is not supported on a SyncWaterfallHook");
  }, "TAP_PROMISE"), kJe = /* @__PURE__ */ s(function(e) {
    return CX.setup(this, e), CX.create(e);
  }, "COMPILE");
  function _2(e = [], t = void 0) {
    if (e.length < 1)
      throw new Error("Waterfall hooks must have at least one argument");
    let r = new PJe(e, t);
    return r.constructor = _2, r.tapAsync = wJe, r.tapPromise = OJe, r.compile = kJe, r;
  }
  s(_2, "SyncWaterfallHook");
  _2.prototype = null;
  PX.exports = _2;
});

// ../node_modules/tapable/lib/SyncLoopHook.js
var kX = b((sNt, OX) => {
  "use strict";
  var IJe = Pa(), RJe = Za(), b2 = class extends RJe {
    static {
      s(this, "SyncLoopHookCodeFactory");
    }
    content({ onError: t, onDone: r, rethrowIfPossible: i }) {
      return this.callTapsLooping({
        onError: /* @__PURE__ */ s((n, a) => t(a), "onError"),
        onDone: r,
        rethrowIfPossible: i
      });
    }
  }, wX = new b2(), NJe = /* @__PURE__ */ s(() => {
    throw new Error("tapAsync is not supported on a SyncLoopHook");
  }, "TAP_ASYNC"), LJe = /* @__PURE__ */ s(() => {
    throw new Error("tapPromise is not supported on a SyncLoopHook");
  }, "TAP_PROMISE"), FJe = /* @__PURE__ */ s(function(e) {
    return wX.setup(this, e), wX.create(e);
  }, "COMPILE");
  function v2(e = [], t = void 0) {
    let r = new IJe(e, t);
    return r.constructor = v2, r.tapAsync = NJe, r.tapPromise = LJe, r.compile = FJe, r;
  }
  s(v2, "SyncLoopHook");
  v2.prototype = null;
  OX.exports = v2;
});

// ../node_modules/tapable/lib/AsyncParallelHook.js
var NX = b((oNt, RX) => {
  "use strict";
  var MJe = Pa(), BJe = Za(), S2 = class extends BJe {
    static {
      s(this, "AsyncParallelHookCodeFactory");
    }
    content({ onError: t, onDone: r }) {
      return this.callTapsParallel({
        onError: /* @__PURE__ */ s((i, n, a, o) => t(n) + o(!0), "onError"),
        onDone: r
      });
    }
  }, IX = new S2(), qJe = /* @__PURE__ */ s(function(e) {
    return IX.setup(this, e), IX.create(e);
  }, "COMPILE");
  function T2(e = [], t = void 0) {
    let r = new MJe(e, t);
    return r.constructor = T2, r.compile = qJe, r._call = void 0, r.call = void 0, r;
  }
  s(T2, "AsyncParallelHook");
  T2.prototype = null;
  RX.exports = T2;
});

// ../node_modules/tapable/lib/AsyncParallelBailHook.js
var MX = b((lNt, FX) => {
  "use strict";
  var UJe = Pa(), jJe = Za(), E2 = class extends jJe {
    static {
      s(this, "AsyncParallelBailHookCodeFactory");
    }
    content({ onError: t, onResult: r, onDone: i }) {
      let n = "";
      return n += `var _results = new Array(${this.options.taps.length});
`, n += `var _checkDone = function() {
`, n += `for(var i = 0; i < _results.length; i++) {
`, n += `var item = _results[i];
`, n += `if(item === undefined) return false;
`, n += `if(item.result !== undefined) {
`, n += r("item.result"), n += `return true;
`, n += `}
`, n += `if(item.error) {
`, n += t("item.error"), n += `return true;
`, n += `}
`, n += `}
`, n += `return false;
`, n += `}
`, n += this.callTapsParallel({
        onError: /* @__PURE__ */ s((a, o, u, l) => {
          let c = "";
          return c += `if(${a} < _results.length && ((_results.length = ${a + 1}), (_results[${a}] = { error: ${o} }), _checkDone())) {
`, c += l(!0), c += `} else {
`, c += u(), c += `}
`, c;
        }, "onError"),
        onResult: /* @__PURE__ */ s((a, o, u, l) => {
          let c = "";
          return c += `if(${a} < _results.length && (${o} !== undefined && (_results.length = ${a + 1}), (_results[${a}] = { result: ${o} })\
, _checkDone())) {
`, c += l(!0), c += `} else {
`, c += u(), c += `}
`, c;
        }, "onResult"),
        onTap: /* @__PURE__ */ s((a, o, u, l) => {
          let c = "";
          return a > 0 && (c += `if(${a} >= _results.length) {
`, c += u(), c += `} else {
`), c += o(), a > 0 && (c += `}
`), c;
        }, "onTap"),
        onDone: i
      }), n;
    }
  }, LX = new E2(), VJe = /* @__PURE__ */ s(function(e) {
    return LX.setup(this, e), LX.create(e);
  }, "COMPILE");
  function A2(e = [], t = void 0) {
    let r = new UJe(e, t);
    return r.constructor = A2, r.compile = VJe, r._call = void 0, r.call = void 0, r;
  }
  s(A2, "AsyncParallelBailHook");
  A2.prototype = null;
  FX.exports = A2;
});

// ../node_modules/tapable/lib/AsyncSeriesHook.js
var UX = b((fNt, qX) => {
  "use strict";
  var KJe = Pa(), HJe = Za(), x2 = class extends HJe {
    static {
      s(this, "AsyncSeriesHookCodeFactory");
    }
    content({ onError: t, onDone: r }) {
      return this.callTapsSeries({
        onError: /* @__PURE__ */ s((i, n, a, o) => t(n) + o(!0), "onError"),
        onDone: r
      });
    }
  }, BX = new x2(), zJe = /* @__PURE__ */ s(function(e) {
    return BX.setup(this, e), BX.create(e);
  }, "COMPILE");
  function C2(e = [], t = void 0) {
    let r = new KJe(e, t);
    return r.constructor = C2, r.compile = zJe, r._call = void 0, r.call = void 0, r;
  }
  s(C2, "AsyncSeriesHook");
  C2.prototype = null;
  qX.exports = C2;
});

// ../node_modules/tapable/lib/AsyncSeriesBailHook.js
var KX = b((hNt, VX) => {
  "use strict";
  var GJe = Pa(), WJe = Za(), P2 = class extends WJe {
    static {
      s(this, "AsyncSeriesBailHookCodeFactory");
    }
    content({ onError: t, onResult: r, resultReturns: i, onDone: n }) {
      return this.callTapsSeries({
        onError: /* @__PURE__ */ s((a, o, u, l) => t(o) + l(!0), "onError"),
        onResult: /* @__PURE__ */ s((a, o, u) => `if(${o} !== undefined) {
${r(
          o
        )}
} else {
${u()}}
`, "onResult"),
        resultReturns: i,
        onDone: n
      });
    }
  }, jX = new P2(), $Je = /* @__PURE__ */ s(function(e) {
    return jX.setup(this, e), jX.create(e);
  }, "COMPILE");
  function D2(e = [], t = void 0) {
    let r = new GJe(e, t);
    return r.constructor = D2, r.compile = $Je, r._call = void 0, r.call = void 0, r;
  }
  s(D2, "AsyncSeriesBailHook");
  D2.prototype = null;
  VX.exports = D2;
});

// ../node_modules/tapable/lib/AsyncSeriesLoopHook.js
var GX = b((mNt, zX) => {
  "use strict";
  var XJe = Pa(), YJe = Za(), w2 = class extends YJe {
    static {
      s(this, "AsyncSeriesLoopHookCodeFactory");
    }
    content({ onError: t, onDone: r }) {
      return this.callTapsLooping({
        onError: /* @__PURE__ */ s((i, n, a, o) => t(n) + o(!0), "onError"),
        onDone: r
      });
    }
  }, HX = new w2(), JJe = /* @__PURE__ */ s(function(e) {
    return HX.setup(this, e), HX.create(e);
  }, "COMPILE");
  function O2(e = [], t = void 0) {
    let r = new XJe(e, t);
    return r.constructor = O2, r.compile = JJe, r._call = void 0, r.call = void 0, r;
  }
  s(O2, "AsyncSeriesLoopHook");
  O2.prototype = null;
  zX.exports = O2;
});

// ../node_modules/tapable/lib/AsyncSeriesWaterfallHook.js
var XX = b((gNt, $X) => {
  "use strict";
  var QJe = Pa(), ZJe = Za(), k2 = class extends ZJe {
    static {
      s(this, "AsyncSeriesWaterfallHookCodeFactory");
    }
    content({ onError: t, onResult: r, onDone: i }) {
      return this.callTapsSeries({
        onError: /* @__PURE__ */ s((n, a, o, u) => t(a) + u(!0), "onError"),
        onResult: /* @__PURE__ */ s((n, a, o) => {
          let u = "";
          return u += `if(${a} !== undefined) {
`, u += `${this._args[0]} = ${a};
`, u += `}
`, u += o(), u;
        }, "onResult"),
        onDone: /* @__PURE__ */ s(() => r(this._args[0]), "onDone")
      });
    }
  }, WX = new k2(), eQe = /* @__PURE__ */ s(function(e) {
    return WX.setup(this, e), WX.create(e);
  }, "COMPILE");
  function I2(e = [], t = void 0) {
    if (e.length < 1)
      throw new Error("Waterfall hooks must have at least one argument");
    let r = new QJe(e, t);
    return r.constructor = I2, r.compile = eQe, r._call = void 0, r.call = void 0, r;
  }
  s(I2, "AsyncSeriesWaterfallHook");
  I2.prototype = null;
  $X.exports = I2;
});

// ../node_modules/tapable/lib/HookMap.js
var JX = b((bNt, YX) => {
  "use strict";
  var R2 = require("util"), tQe = /* @__PURE__ */ s((e, t) => t, "defaultFactory"), kp = class {
    static {
      s(this, "HookMap");
    }
    constructor(t, r = void 0) {
      this._map = /* @__PURE__ */ new Map(), this.name = r, this._factory = t, this._interceptors = [];
    }
    get(t) {
      return this._map.get(t);
    }
    for(t) {
      let r = this.get(t);
      if (r !== void 0)
        return r;
      let i = this._factory(t), n = this._interceptors;
      for (let a = 0; a < n.length; a++)
        i = n[a].factory(t, i);
      return this._map.set(t, i), i;
    }
    intercept(t) {
      this._interceptors.push(
        Object.assign(
          {
            factory: tQe
          },
          t
        )
      );
    }
  };
  kp.prototype.tap = R2.deprecate(function(e, t, r) {
    return this.for(e).tap(t, r);
  }, "HookMap#tap(key,\u2026) is deprecated. Use HookMap#for(key).tap(\u2026) instead.");
  kp.prototype.tapAsync = R2.deprecate(function(e, t, r) {
    return this.for(e).tapAsync(t, r);
  }, "HookMap#tapAsync(key,\u2026) is deprecated. Use HookMap#for(key).tapAsync(\u2026) instead.");
  kp.prototype.tapPromise = R2.deprecate(function(e, t, r) {
    return this.for(e).tapPromise(t, r);
  }, "HookMap#tapPromise(key,\u2026) is deprecated. Use HookMap#for(key).tapPromise(\u2026) instead.");
  YX.exports = kp;
});

// ../node_modules/tapable/lib/MultiHook.js
var ZX = b((TNt, QX) => {
  "use strict";
  var SNt = Pa(), N2 = class e {
    static {
      s(this, "MultiHook");
    }
    constructor(t, r = void 0) {
      this.hooks = t, this.name = r;
    }
    tap(t, r) {
      for (let i of this.hooks)
        i.tap(t, r);
    }
    tapAsync(t, r) {
      for (let i of this.hooks)
        i.tapAsync(t, r);
    }
    tapPromise(t, r) {
      for (let i of this.hooks)
        i.tapPromise(t, r);
    }
    isUsed() {
      for (let t of this.hooks)
        if (t.isUsed()) return !0;
      return !1;
    }
    intercept(t) {
      for (let r of this.hooks)
        r.intercept(t);
    }
    withOptions(t) {
      return new e(
        this.hooks.map((r) => r.withOptions(t)),
        this.name
      );
    }
  };
  QX.exports = N2;
});

// ../node_modules/tapable/lib/index.js
var eY = b((js) => {
  "use strict";
  js.__esModule = !0;
  js.SyncHook = TX();
  js.SyncBailHook = xX();
  js.SyncWaterfallHook = DX();
  js.SyncLoopHook = kX();
  js.AsyncParallelHook = NX();
  js.AsyncParallelBailHook = MX();
  js.AsyncSeriesHook = UX();
  js.AsyncSeriesBailHook = KX();
  js.AsyncSeriesLoopHook = GX();
  js.AsyncSeriesWaterfallHook = XX();
  js.HookMap = JX();
  js.MultiHook = ZX();
});

// ../node_modules/clean-css/lib/optimizer/level-0/optimize.js
var rY = b((xNt, tY) => {
  function rQe(e) {
    return e;
  }
  s(rQe, "level0Optimize");
  tY.exports = rQe;
});

// ../node_modules/clean-css/lib/utils/natural-compare.js
var aY = b((PNt, sY) => {
  var iY = /([0-9]+)/;
  function iQe(e, t) {
    var r = ("" + e).split(iY).map(nY), i = ("" + t).split(iY).map(nY), n, a, o = Math.min(r.length, i.length), u, l;
    for (u = 0, l = o; u < l; u++)
      if (n = r[u], a = i[u], n != a)
        return n > a ? 1 : -1;
    return r.length > i.length ? 1 : r.length == i.length ? 0 : -1;
  }
  s(iQe, "naturalCompare");
  function nY(e) {
    return "" + parseInt(e) == e ? parseInt(e) : e;
  }
  s(nY, "tryParseInt");
  sY.exports = iQe;
});

// ../node_modules/clean-css/lib/optimizer/level-1/sort-selectors.js
var Wv = b((wNt, oY) => {
  var nQe = aY();
  function sQe(e, t) {
    return nQe(e[1], t[1]);
  }
  s(sQe, "naturalSorter");
  function aQe(e, t) {
    return e[1] > t[1] ? 1 : -1;
  }
  s(aQe, "standardSorter");
  function oQe(e, t) {
    switch (t) {
      case "natural":
        return e.sort(sQe);
      case "standard":
        return e.sort(aQe);
      case "none":
      case !1:
        return e;
    }
  }
  s(oQe, "sortSelectors");
  oY.exports = oQe;
});

// ../node_modules/clean-css/lib/utils/override.js
var Nc = b((kNt, uY) => {
  function L2(e, t) {
    var r = {}, i, n, a;
    for (i in e)
      a = e[i], Array.isArray(a) ? r[i] = a.slice(0) : typeof a == "object" && a !== null ? r[i] = L2(a, {}) : r[i] = a;
    for (n in t)
      a = t[n], n in r && Array.isArray(a) ? r[n] = a.slice(0) : n in r && typeof a == "object" && a !== null ? r[n] = L2(r[n], a) : r[n] = a;
    return r;
  }
  s(L2, "override");
  uY.exports = L2;
});

// ../node_modules/clean-css/lib/options/format.js
var hm = b((RNt, hY) => {
  var Lc = Nc();
  function uQe() {
    var e = `
`;
    try {
      var t = require("os");
      e = t.EOL;
    } catch {
    }
    return e;
  }
  s(uQe, "getSystemLineBreak");
  var Da = {
    AfterAtRule: "afterAtRule",
    AfterBlockBegins: "afterBlockBegins",
    AfterBlockEnds: "afterBlockEnds",
    AfterComment: "afterComment",
    AfterProperty: "afterProperty",
    AfterRuleBegins: "afterRuleBegins",
    AfterRuleEnds: "afterRuleEnds",
    BeforeBlockEnds: "beforeBlockEnds",
    BetweenSelectors: "betweenSelectors"
  }, Ip = {
    CarriageReturnLineFeed: `\r
`,
    LineFeed: `
`,
    System: uQe()
  }, F2 = {
    Space: " ",
    Tab: "	"
  }, Xv = {
    AroundSelectorRelation: "aroundSelectorRelation",
    BeforeBlockBegins: "beforeBlockBegins",
    BeforeValue: "beforeValue"
  }, pm = {
    breaks: lY(!1),
    breakWith: Ip.System,
    indentBy: 0,
    indentWith: F2.Space,
    spaces: cY(!1),
    wrapAt: !1,
    semicolonAfterLastProperty: !1
  }, lQe = "beautify", cQe = "keep-breaks", fQe = ";", pQe = ":", hQe = ",", dQe = "=", mQe = "false", yQe = "off", gQe = "true", _Qe = "on";
  function lY(e) {
    var t = {};
    return t[Da.AfterAtRule] = e, t[Da.AfterBlockBegins] = e, t[Da.AfterBlockEnds] = e, t[Da.AfterComment] = e, t[Da.AfterProperty] = e, t[Da.
    AfterRuleBegins] = e, t[Da.AfterRuleEnds] = e, t[Da.BeforeBlockEnds] = e, t[Da.BetweenSelectors] = e, t;
  }
  s(lY, "breaks");
  function cY(e) {
    var t = {};
    return t[Xv.AroundSelectorRelation] = e, t[Xv.BeforeBlockBegins] = e, t[Xv.BeforeValue] = e, t;
  }
  s(cY, "spaces");
  function bQe(e) {
    return e === void 0 || e === !1 ? !1 : (typeof e == "object" && "breakWith" in e && (e = Lc(e, { breakWith: fY(e.breakWith) })), typeof e ==
    "object" && "indentBy" in e && (e = Lc(e, { indentBy: parseInt(e.indentBy) })), typeof e == "object" && "indentWith" in e && (e = Lc(e, {
    indentWith: pY(e.indentWith) })), typeof e == "object" ? $v(Lc(pm, e)) : typeof e == "string" && e == lQe ? $v(
      Lc(pm, {
        breaks: lY(!0),
        indentBy: 2,
        spaces: cY(!0)
      })
    ) : typeof e == "string" && e == cQe ? $v(
      Lc(pm, {
        breaks: {
          afterAtRule: !0,
          afterBlockBegins: !0,
          afterBlockEnds: !0,
          afterComment: !0,
          afterRuleEnds: !0,
          beforeBlockEnds: !0
        }
      })
    ) : typeof e == "string" ? $v(Lc(pm, vQe(e))) : pm);
  }
  s(bQe, "formatFrom");
  function vQe(e) {
    return e.split(fQe).reduce(function(t, r) {
      var i = r.split(pQe), n = i[0], a = i[1];
      return n == "breaks" || n == "spaces" ? t[n] = SQe(a) : n == "indentBy" || n == "wrapAt" ? t[n] = parseInt(a) : n == "indentWith" ? t[n] =
      pY(a) : n == "breakWith" && (t[n] = fY(a)), t;
    }, {});
  }
  s(vQe, "toHash");
  function SQe(e) {
    return e.split(hQe).reduce(function(t, r) {
      var i = r.split(dQe), n = i[0], a = i[1];
      return t[n] = TQe(a), t;
    }, {});
  }
  s(SQe, "hashValuesToHash");
  function TQe(e) {
    switch (e) {
      case mQe:
      case yQe:
        return !1;
      case gQe:
      case _Qe:
        return !0;
      default:
        return e;
    }
  }
  s(TQe, "normalizeValue");
  function fY(e) {
    switch (e) {
      case "windows":
      case "crlf":
      case Ip.CarriageReturnLineFeed:
        return Ip.CarriageReturnLineFeed;
      case "unix":
      case "lf":
      case Ip.LineFeed:
        return Ip.LineFeed;
      default:
        return Ip.System;
    }
  }
  s(fY, "mapBreakWith");
  function pY(e) {
    switch (e) {
      case "space":
        return F2.Space;
      case "tab":
        return F2.Tab;
      default:
        return e;
    }
  }
  s(pY, "mapIndentWith");
  function $v(e) {
    for (var t in Da) {
      var r = Da[t], i = e.breaks[r];
      i === !0 ? e.breaks[r] = e.breakWith : i === !1 ? e.breaks[r] = "" : e.breaks[r] = e.breakWith.repeat(parseInt(i));
    }
    return e;
  }
  s($v, "remapBreaks");
  hY.exports = {
    Breaks: Da,
    Spaces: Xv,
    formatFrom: bQe
  };
});

// ../node_modules/clean-css/lib/tokenizer/marker.js
var Ln = b((LNt, dY) => {
  var EQe = {
    ASTERISK: "*",
    AT: "@",
    BACK_SLASH: "\\",
    CARRIAGE_RETURN: "\r",
    CLOSE_CURLY_BRACKET: "}",
    CLOSE_ROUND_BRACKET: ")",
    CLOSE_SQUARE_BRACKET: "]",
    COLON: ":",
    COMMA: ",",
    DOUBLE_QUOTE: '"',
    EXCLAMATION: "!",
    FORWARD_SLASH: "/",
    INTERNAL: "-clean-css-",
    NEW_LINE_NIX: `
`,
    OPEN_CURLY_BRACKET: "{",
    OPEN_ROUND_BRACKET: "(",
    OPEN_SQUARE_BRACKET: "[",
    SEMICOLON: ";",
    SINGLE_QUOTE: "'",
    SPACE: " ",
    TAB: "	",
    UNDERSCORE: "_"
  };
  dY.exports = EQe;
});

// ../node_modules/clean-css/lib/utils/format-position.js
var dm = b((FNt, mY) => {
  function AQe(e) {
    var t = e[0], r = e[1], i = e[2];
    return i ? i + ":" + t + ":" + r : t + ":" + r;
  }
  s(AQe, "formatPosition");
  mY.exports = AQe;
});

// ../node_modules/clean-css/lib/optimizer/level-1/tidy-rules.js
var Yv = b((BNt, gY) => {
  var xQe = hm().Spaces, oi = Ln(), M2 = dm(), CQe = /[\s"'][iI]\s*\]/, PQe = /([\d\w])([iI])\]/g, DQe = /="([a-zA-Z][a-zA-Z\d\-_]+)"([iI])/g,
  wQe = /="([a-zA-Z][a-zA-Z\d\-_]+)"(\s|\])/g, OQe = /^(?:(?:<!--|-->)\s*)+/, kQe = /='([a-zA-Z][a-zA-Z\d\-_]+)'([iI])/g, IQe = /='([a-zA-Z][a-zA-Z\d\-_]+)'(\s|\])/g,
  yY = /[>+~]/, RQe = /\s/, NQe = "*+html ", LQe = "*:first-child+html ", FQe = "<", MQe = [
    ":current",
    ":future",
    ":has",
    ":host",
    ":host-context",
    ":is",
    ":not",
    ":past",
    ":where"
  ];
  function BQe(e) {
    var t, r = !1, i, n = !1, a, o;
    for (a = 0, o = e.length; a < o; a++) {
      if (i = e[a], !t) {
        if (i == oi.SINGLE_QUOTE || i == oi.DOUBLE_QUOTE)
          n = !n;
        else if (!n && (i == oi.CLOSE_CURLY_BRACKET || i == oi.EXCLAMATION || i == FQe || i == oi.SEMICOLON)) {
          r = !0;
          break;
        } else if (!n && a === 0 && yY.test(i)) {
          r = !0;
          break;
        }
      }
      t = i == oi.BACK_SLASH;
    }
    return r;
  }
  s(BQe, "hasInvalidCharacters");
  function qQe(e, t) {
    var r = [], i, n, a, o, u, l, c, p, h, y, _, g, m = 0, f = !1, d = !1, v = !1, E = CQe.test(e), S = t && t.spaces[xQe.AroundSelectorRelation],
    x, C;
    for (x = 0, C = e.length; x < C; x++) {
      if (i = e[x], n = i == oi.NEW_LINE_NIX, a = i == oi.NEW_LINE_NIX && e[x - 1] == oi.CARRIAGE_RETURN, l = c || p, y = !h && !o && m === 0 &&
      yY.test(i), _ = RQe.test(i), g = m == 1 && i == oi.CLOSE_ROUND_BRACKET ? !1 : g || m === 0 && i == oi.COLON && UQe(e, x), u && l && a)
        r.pop(), r.pop();
      else if (o && l && n)
        r.pop();
      else if (o)
        r.push(i);
      else if (i == oi.OPEN_SQUARE_BRACKET && !l)
        r.push(i), h = !0;
      else if (i == oi.CLOSE_SQUARE_BRACKET && !l)
        r.push(i), h = !1;
      else if (i == oi.OPEN_ROUND_BRACKET && !l)
        r.push(i), m++;
      else if (i == oi.CLOSE_ROUND_BRACKET && !l)
        r.push(i), m--;
      else if (i == oi.SINGLE_QUOTE && !l)
        r.push(i), c = !0;
      else if (i == oi.DOUBLE_QUOTE && !l)
        r.push(i), p = !0;
      else if (i == oi.SINGLE_QUOTE && l)
        r.push(i), c = !1;
      else if (i == oi.DOUBLE_QUOTE && l)
        r.push(i), p = !1;
      else {
        if (_ && d && !S)
          continue;
        !_ && d && S ? (r.push(oi.SPACE), r.push(i)) : _ && !v && f && m > 0 && g || (_ && !v && m > 0 && g ? r.push(i) : _ && (h || m > 0) &&
        !l || _ && v && !l || (a || n) && (h || m > 0) && l || (y && v && !S ? (r.pop(), r.push(i)) : y && !v && S ? (r.push(oi.SPACE), r.push(
        i)) : _ ? r.push(oi.SPACE) : r.push(i)));
      }
      u = o, o = i == oi.BACK_SLASH, d = y, v = _, f = i == oi.COMMA;
    }
    return E ? r.join("").replace(PQe, "$1 $2]") : r.join("");
  }
  s(qQe, "removeWhitespace");
  function UQe(e, t) {
    var r = e.substring(t, e.indexOf(oi.OPEN_ROUND_BRACKET, t));
    return MQe.indexOf(r) > -1;
  }
  s(UQe, "isPseudoClassWithSelectors");
  function jQe(e) {
    return e.indexOf("'") == -1 && e.indexOf('"') == -1 ? e : e.replace(kQe, "=$1 $2").replace(IQe, "=$1$2").replace(DQe, "=$1 $2").replace(
    wQe, "=$1$2");
  }
  s(jQe, "removeQuotes");
  function VQe(e) {
    return e.replace("nth-child(1)", "first-child").replace("nth-of-type(1)", "first-of-type").replace("nth-of-type(even)", "nth-of-type(2n)").
    replace("nth-child(even)", "nth-child(2n)").replace("nth-of-type(2n+1)", "nth-of-type(odd)").replace("nth-child(2n+1)", "nth-child(odd)").
    replace("nth-last-child(1)", "last-child").replace("nth-last-of-type(1)", "last-of-type").replace("nth-last-of-type(even)", "nth-last-of\
-type(2n)").replace("nth-last-child(even)", "nth-last-child(2n)").replace("nth-last-of-type(2n+1)", "nth-last-of-type(odd)").replace("nth-la\
st-child(2n+1)", "nth-last-child(odd)");
  }
  s(VQe, "replacePseudoClasses");
  function KQe(e, t, r, i, n) {
    var a = [], o = [];
    function u(y, _) {
      return n.push("HTML comment '" + _ + "' at " + M2(y[2][0]) + ". Removing."), "";
    }
    s(u, "removeHTMLComment");
    for (var l = 0, c = e.length; l < c; l++) {
      var p = e[l], h = p[1];
      if (h = h.replace(OQe, u.bind(null, p)), BQe(h)) {
        n.push("Invalid selector '" + p[1] + "' at " + M2(p[2][0]) + ". Ignoring.");
        continue;
      }
      h = qQe(h, i), h = jQe(h), r && h.indexOf("nav") > 0 && (h = h.replace(/\+nav(\S|$)/, "+ nav$1")), !(t && h.indexOf(NQe) > -1) && (t &&
      h.indexOf(LQe) > -1 || (h.indexOf("*") > -1 && (h = h.replace(/\*([:#.[])/g, "$1").replace(/^(:first-child)?\+html/, "*$1+html")), !(o.
      indexOf(h) > -1) && (h = VQe(h), p[1] = h, o.push(h), a.push(p))));
    }
    return a.length == 1 && a[0][1].length === 0 && (n.push("Empty selector '" + a[0][1] + "' at " + M2(a[0][2][0]) + ". Ignoring."), a = []),
    a;
  }
  s(KQe, "tidyRules");
  gY.exports = KQe;
});

// ../node_modules/clean-css/lib/optimizer/level-1/tidy-block.js
var bY = b((UNt, _Y) => {
  var HQe = /^@media\W/, zQe = /^@(?:keyframes|-moz-keyframes|-o-keyframes|-webkit-keyframes)\W/;
  function GQe(e, t) {
    var r, i, n;
    for (n = e.length - 1; n >= 0; n--)
      r = !t && HQe.test(e[n][1]), i = zQe.test(e[n][1]), e[n][1] = e[n][1].replace(/\n|\r\n/g, " ").replace(/\s+/g, " ").replace(/(,|:|\() /g,
      "$1").replace(/ \)/g, ")"), i && (e[n][1] = e[n][1].replace(/'([a-zA-Z][a-zA-Z\d\-_]+)'/, "$1").replace(/"([a-zA-Z][a-zA-Z\d\-_]+)"/, "\
$1")), r && (e[n][1] = e[n][1].replace(/\) /g, ")"));
    return e;
  }
  s(GQe, "tidyBlock");
  _Y.exports = GQe;
});

// ../node_modules/clean-css/lib/optimizer/level-1/tidy-at-rule.js
var SY = b((VNt, vY) => {
  function WQe(e) {
    return e.replace(/\s+/g, " ").replace(/url\(\s+/g, "url(").replace(/\s+\)/g, ")").trim();
  }
  s(WQe, "tidyAtRule");
  vY.exports = WQe;
});

// ../node_modules/clean-css/lib/optimizer/hack.js
var Jv = b((HNt, TY) => {
  var $Qe = {
    ASTERISK: "asterisk",
    BANG: "bang",
    BACKSLASH: "backslash",
    UNDERSCORE: "underscore"
  };
  TY.exports = $Qe;
});

// ../node_modules/clean-css/lib/optimizer/remove-unused.js
var B2 = b((zNt, EY) => {
  function XQe(e) {
    for (var t = e.length - 1; t >= 0; t--) {
      var r = e[t];
      r.unused && r.all.splice(r.position, 1);
    }
  }
  s(XQe, "removeUnused");
  EY.exports = XQe;
});

// ../node_modules/clean-css/lib/optimizer/restore-from-optimizing.js
var Rp = b((WNt, xY) => {
  var Qv = Jv(), YQe = Ln(), JQe = "*", QQe = "\\", ZQe = "!important", eZe = "_", tZe = "!ie";
  function rZe(e, t) {
    var r, i, n, a;
    for (a = e.length - 1; a >= 0; a--) {
      if (r = e[a], r.dynamic && r.important) {
        AY(r);
        continue;
      }
      r.dynamic || r.unused || !r.dirty && !r.important && !r.hack || (r.optimizable && t ? (i = t(r), r.value = i) : i = r.value, r.important &&
      AY(r), r.hack && iZe(r), "all" in r && (n = r.all[r.position], n[1][1] = r.name, n.splice(2, n.length - 1), Array.prototype.push.apply(
      n, i)));
    }
  }
  s(rZe, "restoreFromOptimizing");
  function AY(e) {
    e.value[e.value.length - 1][1] += ZQe;
  }
  s(AY, "restoreImportant");
  function iZe(e) {
    e.hack[0] == Qv.UNDERSCORE ? e.name = eZe + e.name : e.hack[0] == Qv.ASTERISK ? e.name = JQe + e.name : e.hack[0] == Qv.BACKSLASH ? e.value[e.
    value.length - 1][1] += QQe + e.hack[1] : e.hack[0] == Qv.BANG && (e.value[e.value.length - 1][1] += YQe.SPACE + tZe);
  }
  s(iZe, "restoreHack");
  xY.exports = rZe;
});

// ../node_modules/clean-css/lib/tokenizer/token.js
var ui = b((XNt, CY) => {
  var nZe = {
    AT_RULE: "at-rule",
    // e.g. `@import`, `@charset`
    AT_RULE_BLOCK: "at-rule-block",
    // e.g. `@font-face{...}`
    AT_RULE_BLOCK_SCOPE: "at-rule-block-scope",
    // e.g. `@font-face`
    COMMENT: "comment",
    // e.g. `/* comment */`
    NESTED_BLOCK: "nested-block",
    // e.g. `@media screen{...}`, `@keyframes animation {...}`
    NESTED_BLOCK_SCOPE: "nested-block-scope",
    // e.g. `@media`, `@keyframes`
    PROPERTY: "property",
    // e.g. `color:red`
    PROPERTY_BLOCK: "property-block",
    // e.g. `--var:{color:red}`
    PROPERTY_NAME: "property-name",
    // e.g. `color`
    PROPERTY_VALUE: "property-value",
    // e.g. `red`
    RAW: "raw",
    // e.g. anything between /* clean-css ignore:start */ and /* clean-css ignore:end */ comments
    RULE: "rule",
    // e.g `div > a{...}`
    RULE_SCOPE: "rule-scope"
    // e.g `div > a`
  };
  CY.exports = nZe;
});

// ../node_modules/clean-css/lib/optimizer/wrap-for-optimizing.js
var Fc = b((YNt, wY) => {
  var eo = Jv(), PY = Ln(), Zv = ui(), Fi = {
    ASTERISK: "*",
    BACKSLASH: "\\",
    BANG: "!",
    BANG_SUFFIX_PATTERN: /!\w+$/,
    IMPORTANT_TOKEN: "!important",
    IMPORTANT_TOKEN_PATTERN: new RegExp("!important$", "i"),
    IMPORTANT_WORD: "important",
    IMPORTANT_WORD_PATTERN: new RegExp("important$", "i"),
    SUFFIX_BANG_PATTERN: /!$/,
    UNDERSCORE: "_",
    VARIABLE_REFERENCE_PATTERN: /var\(--.+\)$/
  };
  function sZe(e, t) {
    var r = [], i, n, a;
    for (a = e.length - 1; a >= 0; a--)
      n = e[a], n[0] == Zv.PROPERTY && (t && t.indexOf(n[1][1]) > -1 || (i = DY(n), i.all = e, i.position = a, r.unshift(i)));
    return r;
  }
  s(sZe, "wrapAll");
  function aZe(e) {
    var t, r, i;
    for (t = 2, r = e.length; t < r; t++)
      if (i = e[t], i[0] == Zv.PROPERTY_VALUE && oZe(i[1]))
        return !0;
    return !1;
  }
  s(aZe, "someVariableReferences");
  function oZe(e) {
    return Fi.VARIABLE_REFERENCE_PATTERN.test(e);
  }
  s(oZe, "isVariableReference");
  function uZe(e) {
    var t, r, i;
    for (r = 3, i = e.length; r < i; r++)
      if (t = e[r], t[0] == Zv.PROPERTY_VALUE && (t[1] == PY.COMMA || t[1] == PY.FORWARD_SLASH))
        return !0;
    return !1;
  }
  s(uZe, "isMultiplex");
  function lZe(e) {
    var t = !1, r = e[1][1], i = e[e.length - 1];
    return r[0] == Fi.UNDERSCORE ? t = [eo.UNDERSCORE] : r[0] == Fi.ASTERISK ? t = [eo.ASTERISK] : i[1][0] == Fi.BANG && !i[1].match(Fi.IMPORTANT_WORD_PATTERN) ?
    t = [eo.BANG] : i[1].indexOf(Fi.BANG) > 0 && !i[1].match(Fi.IMPORTANT_WORD_PATTERN) && Fi.BANG_SUFFIX_PATTERN.test(i[1]) ? t = [eo.BANG] :
    i[1].indexOf(Fi.BACKSLASH) > 0 && i[1].indexOf(Fi.BACKSLASH) == i[1].length - Fi.BACKSLASH.length - 1 ? t = [eo.BACKSLASH, i[1].substring(
    i[1].indexOf(Fi.BACKSLASH) + 1)] : i[1].indexOf(Fi.BACKSLASH) === 0 && i[1].length == 2 && (t = [eo.BACKSLASH, i[1].substring(1)]), t;
  }
  s(lZe, "hackFrom");
  function cZe(e) {
    if (e.length < 3)
      return !1;
    var t = e[e.length - 1];
    return !!(Fi.IMPORTANT_TOKEN_PATTERN.test(t[1]) || Fi.IMPORTANT_WORD_PATTERN.test(t[1]) && Fi.SUFFIX_BANG_PATTERN.test(e[e.length - 2][1]));
  }
  s(cZe, "isImportant");
  function fZe(e) {
    var t = e[e.length - 1], r = e[e.length - 2];
    Fi.IMPORTANT_TOKEN_PATTERN.test(t[1]) ? t[1] = t[1].replace(Fi.IMPORTANT_TOKEN_PATTERN, "") : (t[1] = t[1].replace(Fi.IMPORTANT_WORD_PATTERN,
    ""), r[1] = r[1].replace(Fi.SUFFIX_BANG_PATTERN, "")), t[1].length === 0 && e.pop(), r[1].length === 0 && e.pop();
  }
  s(fZe, "stripImportant");
  function pZe(e) {
    e[1][1] = e[1][1].substring(1);
  }
  s(pZe, "stripPrefixHack");
  function hZe(e, t) {
    var r = e[e.length - 1];
    r[1] = r[1].substring(0, r[1].indexOf(t[0] == eo.BACKSLASH ? Fi.BACKSLASH : Fi.BANG)).trim(), r[1].length === 0 && e.pop();
  }
  s(hZe, "stripSuffixHack");
  function DY(e) {
    var t = cZe(e);
    t && fZe(e);
    var r = lZe(e);
    return r[0] == eo.ASTERISK || r[0] == eo.UNDERSCORE ? pZe(e) : (r[0] == eo.BACKSLASH || r[0] == eo.BANG) && hZe(e, r), {
      block: e[2] && e[2][0] == Zv.PROPERTY_BLOCK,
      components: [],
      dirty: !1,
      dynamic: aZe(e),
      hack: r,
      important: t,
      name: e[1][1],
      multiplex: e.length > 3 ? uZe(e) : !1,
      optimizable: !0,
      position: 0,
      shorthand: !1,
      unused: !1,
      value: e.slice(2)
    };
  }
  s(DY, "wrapSingle");
  wY.exports = {
    all: sZe,
    single: DY
  };
});

// ../node_modules/clean-css/lib/optimizer/invalid-property-error.js
var q2 = b((QNt, OY) => {
  function eS(e) {
    this.name = "InvalidPropertyError", this.message = e, this.stack = new Error().stack;
  }
  s(eS, "InvalidPropertyError");
  eS.prototype = Object.create(Error.prototype);
  eS.prototype.constructor = eS;
  OY.exports = eS;
});

// ../node_modules/clean-css/lib/optimizer/configuration/break-up.js
var RY = b((eLt, IY) => {
  var ra = q2(), tS = Fc().single, ta = ui(), Cl = Ln(), ia = dm();
  function j2(e) {
    var t, r;
    for (t = 0, r = e.length; t < r; t++)
      if (e[t][1] == "inherit")
        return !0;
    return !1;
  }
  s(j2, "_anyIsInherit");
  function dZe(e) {
    return function(t) {
      return t[1] == "invert" || e.isColor(t[1]) || e.isPrefixed(t[1]);
    };
  }
  s(dZe, "_colorFilter");
  function mZe(e) {
    return function(t) {
      return t[1] != "inherit" && e.isStyleKeyword(t[1]) && !e.isColorFunction(t[1]);
    };
  }
  s(mZe, "_styleFilter");
  function nr(e, t, r) {
    var i = r[e];
    return i.doubleValues && i.defaultValue.length == 2 ? tS([
      ta.PROPERTY,
      [ta.PROPERTY_NAME, e],
      [ta.PROPERTY_VALUE, i.defaultValue[0]],
      [ta.PROPERTY_VALUE, i.defaultValue[1]]
    ]) : i.doubleValues && i.defaultValue.length == 1 ? tS([
      ta.PROPERTY,
      [ta.PROPERTY_NAME, e],
      [ta.PROPERTY_VALUE, i.defaultValue[0]]
    ]) : tS([
      ta.PROPERTY,
      [ta.PROPERTY_NAME, e],
      [ta.PROPERTY_VALUE, i.defaultValue]
    ]);
  }
  s(nr, "_wrapDefault");
  function yZe(e) {
    return function(t) {
      return t[1] != "inherit" && (e.isWidth(t[1]) || e.isUnit(t[1]) || e.isDynamicUnit(t[1])) && !e.isStyleKeyword(t[1]) && !e.isColorFunction(
      t[1]);
    };
  }
  s(yZe, "_widthFilter");
  function gZe(e, t, r) {
    var i = nr(e.name + "-duration", e, t), n = nr(e.name + "-timing-function", e, t), a = nr(e.name + "-delay", e, t), o = nr(e.name + "-it\
eration-count", e, t), u = nr(e.name + "-direction", e, t), l = nr(e.name + "-fill-mode", e, t), c = nr(e.name + "-play-state", e, t), p = nr(
    e.name + "-name", e, t), h = [i, n, a, o, u, l, c, p], y = e.value, _, g = !1, m = !1, f = !1, d = !1, v = !1, E = !1, S = !1, x = !1, C,
    z;
    if (e.value.length == 1 && e.value[0][1] == "inherit")
      return i.value = n.value = a.value = o.value = u.value = l.value = c.value = p.value = e.value, h;
    if (y.length > 1 && j2(y))
      throw new ra("Invalid animation values at " + ia(y[0][2][0]) + ". Ignoring.");
    for (C = 0, z = y.length; C < z; C++)
      if (_ = y[C], r.isTime(_[1]) && !g)
        i.value = [_], g = !0;
      else if (r.isTime(_[1]) && !f)
        a.value = [_], f = !0;
      else if ((r.isGlobal(_[1]) || r.isTimingFunction(_[1])) && !m)
        n.value = [_], m = !0;
      else if ((r.isAnimationIterationCountKeyword(_[1]) || r.isPositiveNumber(_[1])) && !d)
        o.value = [_], d = !0;
      else if (r.isAnimationDirectionKeyword(_[1]) && !v)
        u.value = [_], v = !0;
      else if (r.isAnimationFillModeKeyword(_[1]) && !E)
        l.value = [_], E = !0;
      else if (r.isAnimationPlayStateKeyword(_[1]) && !S)
        c.value = [_], S = !0;
      else if ((r.isAnimationNameKeyword(_[1]) || r.isIdentifier(_[1])) && !x)
        p.value = [_], x = !0;
      else
        throw new ra("Invalid animation value at " + ia(_[2][0]) + ". Ignoring.");
    return h;
  }
  s(gZe, "animation");
  function _Ze(e, t, r) {
    var i = nr("background-image", e, t), n = nr("background-position", e, t), a = nr("background-size", e, t), o = nr("background-repeat", e,
    t), u = nr("background-attachment", e, t), l = nr("background-origin", e, t), c = nr("background-clip", e, t), p = nr("background-color",
    e, t), h = [i, n, a, o, u, l, c, p], y = e.value, _ = !1, g = !1, m = !1, f = !1, d = !1;
    if (e.value.length == 1 && e.value[0][1] == "inherit")
      return p.value = i.value = o.value = n.value = a.value = l.value = c.value = e.value, h;
    if (e.value.length == 1 && e.value[0][1] == "0 0")
      return h;
    for (var v = y.length - 1; v >= 0; v--) {
      var E = y[v];
      if (r.isBackgroundAttachmentKeyword(E[1]))
        u.value = [E], d = !0;
      else if (r.isBackgroundClipKeyword(E[1]) || r.isBackgroundOriginKeyword(E[1]))
        g ? (l.value = [E], m = !0) : (c.value = [E], g = !0), d = !0;
      else if (r.isBackgroundRepeatKeyword(E[1]))
        f ? o.value.unshift(E) : (o.value = [E], f = !0), d = !0;
      else if (r.isBackgroundPositionKeyword(E[1]) || r.isBackgroundSizeKeyword(E[1]) || r.isUnit(E[1]) || r.isDynamicUnit(E[1])) {
        if (v > 0) {
          var S = y[v - 1];
          S[1] == Cl.FORWARD_SLASH ? a.value = [E] : v > 1 && y[v - 2][1] == Cl.FORWARD_SLASH ? (a.value = [S, E], v -= 2) : (_ || (n.value =
          []), n.value.unshift(E), _ = !0);
        } else
          _ || (n.value = []), n.value.unshift(E), _ = !0;
        d = !0;
      } else (p.value[0][1] == t[p.name].defaultValue || p.value[0][1] == "none") && (r.isColor(E[1]) || r.isPrefixed(E[1])) ? (p.value = [E],
      d = !0) : (r.isUrl(E[1]) || r.isFunction(E[1])) && (i.value = [E], d = !0);
    }
    if (g && !m && (l.value = c.value.slice(0)), !d)
      throw new ra("Invalid background value at " + ia(y[0][2][0]) + ". Ignoring.");
    return h;
  }
  s(_Ze, "background");
  function bZe(e, t) {
    for (var r = e.value, i = -1, n = 0, a = r.length; n < a; n++)
      if (r[n][1] == Cl.FORWARD_SLASH) {
        i = n;
        break;
      }
    if (i === 0 || i === r.length - 1)
      throw new ra("Invalid border-radius value at " + ia(r[0][2][0]) + ". Ignoring.");
    var o = nr(e.name, e, t);
    o.value = i > -1 ? r.slice(0, i) : r.slice(0), o.components = U2(o, t);
    var u = nr(e.name, e, t);
    u.value = i > -1 ? r.slice(i + 1) : r.slice(0), u.components = U2(u, t);
    for (var l = 0; l < 4; l++)
      o.components[l].multiplex = !0, o.components[l].value = o.components[l].value.concat(u.components[l].value);
    return o.components;
  }
  s(bZe, "borderRadius");
  function vZe(e, t, r) {
    var i = nr("font-style", e, t), n = nr("font-variant", e, t), a = nr("font-weight", e, t), o = nr("font-stretch", e, t), u = nr("font-si\
ze", e, t), l = nr("line-height", e, t), c = nr("font-family", e, t), p = [i, n, a, o, u, l, c], h = e.value, y = 4, _ = 0, g = !1, m, f = !1,
    d, v = !1, E, S = !1, x, C = !1;
    if (!h[_])
      throw new ra("Missing font values at " + ia(e.all[e.position][1][2][0]) + ". Ignoring.");
    if (h.length == 1 && h[0][1] == "inherit")
      return i.value = n.value = a.value = o.value = u.value = l.value = c.value = h, p;
    if (h.length == 1 && (r.isFontKeyword(h[0][1]) || r.isGlobal(h[0][1]) || r.isPrefixed(h[0][1])))
      return h[0][1] = Cl.INTERNAL + h[0][1], i.value = n.value = a.value = o.value = u.value = l.value = c.value = h, p;
    if (h.length < 2 || !SZe(h, r) || !TZe(h, r))
      throw new ra("Invalid font values at " + ia(e.all[e.position][1][2][0]) + ". Ignoring.");
    if (h.length > 1 && j2(h))
      throw new ra("Invalid font values at " + ia(h[0][2][0]) + ". Ignoring.");
    for (; _ < y; ) {
      if (m = r.isFontStretchKeyword(h[_][1]) || r.isGlobal(h[_][1]), d = r.isFontStyleKeyword(h[_][1]) || r.isGlobal(h[_][1]), E = r.isFontVariantKeyword(
      h[_][1]) || r.isGlobal(h[_][1]), x = r.isFontWeightKeyword(h[_][1]) || r.isGlobal(h[_][1]), d && !f)
        i.value = [h[_]], f = !0;
      else if (E && !v)
        n.value = [h[_]], v = !0;
      else if (x && !S)
        a.value = [h[_]], S = !0;
      else if (m && !g)
        o.value = [h[_]], g = !0;
      else {
        if (d && f || E && v || x && S || m && g)
          throw new ra("Invalid font style / variant / weight / stretch value at " + ia(h[0][2][0]) + ". Ignoring.");
        break;
      }
      _++;
    }
    if (r.isFontSizeKeyword(h[_][1]) || r.isUnit(h[_][1]) && !r.isDynamicUnit(h[_][1]))
      u.value = [h[_]], _++;
    else
      throw new ra("Missing font size at " + ia(h[0][2][0]) + ". Ignoring.");
    if (!h[_])
      throw new ra("Missing font family at " + ia(h[0][2][0]) + ". Ignoring.");
    for (h[_] && h[_][1] == Cl.FORWARD_SLASH && h[_ + 1] && (r.isLineHeightKeyword(h[_ + 1][1]) || r.isUnit(h[_ + 1][1]) || r.isNumber(h[_ +
    1][1])) && (l.value = [h[_ + 1]], _++, _++), c.value = []; h[_]; )
      h[_][1] == Cl.COMMA ? C = !1 : (C ? c.value[c.value.length - 1][1] += Cl.SPACE + h[_][1] : c.value.push(h[_]), C = !0), _++;
    if (c.value.length === 0)
      throw new ra("Missing font family at " + ia(h[0][2][0]) + ". Ignoring.");
    return p;
  }
  s(vZe, "font");
  function SZe(e, t) {
    var r, i, n;
    for (i = 0, n = e.length; i < n; i++)
      if (r = e[i], t.isFontSizeKeyword(r[1]) || t.isUnit(r[1]) && !t.isDynamicUnit(r[1]) || t.isFunction(r[1]))
        return !0;
    return !1;
  }
  s(SZe, "_anyIsFontSize");
  function TZe(e, t) {
    var r, i, n;
    for (i = 0, n = e.length; i < n; i++)
      if (r = e[i], t.isIdentifier(r[1]) || t.isQuotedText(r[1]))
        return !0;
    return !1;
  }
  s(TZe, "_anyIsFontFamily");
  function U2(e, t) {
    var r = t[e.name].components, i = [], n = e.value;
    if (n.length < 1)
      return [];
    n.length < 2 && (n[1] = n[0].slice(0)), n.length < 3 && (n[2] = n[0].slice(0)), n.length < 4 && (n[3] = n[1].slice(0));
    for (var a = r.length - 1; a >= 0; a--) {
      var o = tS([
        ta.PROPERTY,
        [ta.PROPERTY_NAME, r[a]]
      ]);
      o.value = [n[a]], i.unshift(o);
    }
    return i;
  }
  s(U2, "fourValues");
  function EZe(e) {
    return function(t, r, i) {
      var n = [], a = t.value, o, u, l, c;
      for (o = 0, l = a.length; o < l; o++)
        a[o][1] == "," && n.push(o);
      if (n.length === 0)
        return e(t, r, i);
      var p = [];
      for (o = 0, l = n.length; o <= l; o++) {
        var h = o === 0 ? 0 : n[o - 1] + 1, y = o < l ? n[o] : a.length, _ = nr(t.name, t, r);
        _.value = a.slice(h, y), _.value.length > 0 && p.push(e(_, r, i));
      }
      var g = p[0];
      for (o = 0, l = g.length; o < l; o++)
        for (g[o].multiplex = !0, u = 1, c = p.length; u < c; u++)
          g[o].value.push([ta.PROPERTY_VALUE, Cl.COMMA]), Array.prototype.push.apply(g[o].value, p[u][o].value);
      return g;
    };
  }
  s(EZe, "multiplex");
  function AZe(e, t, r) {
    var i = nr("list-style-type", e, t), n = nr("list-style-position", e, t), a = nr("list-style-image", e, t), o = [i, n, a];
    if (e.value.length == 1 && e.value[0][1] == "inherit")
      return i.value = n.value = a.value = [e.value[0]], o;
    var u = e.value.slice(0), l = u.length, c = 0;
    for (c = 0, l = u.length; c < l; c++)
      if (r.isUrl(u[c][1]) || u[c][1] == "0") {
        a.value = [u[c]], u.splice(c, 1);
        break;
      }
    for (c = 0, l = u.length; c < l; c++)
      if (r.isListStylePositionKeyword(u[c][1])) {
        n.value = [u[c]], u.splice(c, 1);
        break;
      }
    return u.length > 0 && (r.isListStyleTypeKeyword(u[0][1]) || r.isIdentifier(u[0][1])) && (i.value = [u[0]]), o;
  }
  s(AZe, "listStyle");
  function xZe(e, t, r) {
    var i = nr(e.name + "-property", e, t), n = nr(e.name + "-duration", e, t), a = nr(e.name + "-timing-function", e, t), o = nr(e.name + "\
-delay", e, t), u = [i, n, a, o], l = e.value, c, p = !1, h = !1, y = !1, _ = !1, g, m;
    if (e.value.length == 1 && e.value[0][1] == "inherit")
      return i.value = n.value = a.value = o.value = e.value, u;
    if (l.length > 1 && j2(l))
      throw new ra("Invalid animation values at " + ia(l[0][2][0]) + ". Ignoring.");
    for (g = 0, m = l.length; g < m; g++)
      if (c = l[g], r.isTime(c[1]) && !p)
        n.value = [c], p = !0;
      else if (r.isTime(c[1]) && !h)
        o.value = [c], h = !0;
      else if ((r.isGlobal(c[1]) || r.isTimingFunction(c[1])) && !_)
        a.value = [c], _ = !0;
      else if (r.isIdentifier(c[1]) && !y)
        i.value = [c], y = !0;
      else
        throw new ra("Invalid animation value at " + ia(c[2][0]) + ". Ignoring.");
    return u;
  }
  s(xZe, "transition");
  function kY(e, t, r) {
    for (var i = t[e.name], n = [
      nr(i.components[0], e, t),
      nr(i.components[1], e, t),
      nr(i.components[2], e, t)
    ], a, o, u, l = 0; l < 3; l++) {
      var c = n[l];
      c.name.indexOf("color") > 0 ? a = c : c.name.indexOf("style") > 0 ? o = c : u = c;
    }
    if (e.value.length == 1 && e.value[0][1] == "inherit" || e.value.length == 3 && e.value[0][1] == "inherit" && e.value[1][1] == "inherit" &&
    e.value[2][1] == "inherit")
      return a.value = o.value = u.value = [e.value[0]], n;
    var p = e.value.slice(0), h, y;
    return p.length > 0 && (y = p.filter(yZe(r)), h = y.length > 1 && (y[0][1] == "none" || y[0][1] == "auto") ? y[1] : y[0], h && (u.value =
    [h], p.splice(p.indexOf(h), 1))), p.length > 0 && (h = p.filter(mZe(r))[0], h && (o.value = [h], p.splice(p.indexOf(h), 1))), p.length >
    0 && (h = p.filter(dZe(r))[0], h && (a.value = [h], p.splice(p.indexOf(h), 1))), n;
  }
  s(kY, "widthStyleColor");
  IY.exports = {
    animation: gZe,
    background: _Ze,
    border: kY,
    borderRadius: bZe,
    font: vZe,
    fourValues: U2,
    listStyle: AZe,
    multiplex: EZe,
    outline: kY,
    transition: xZe
  };
});

// ../node_modules/clean-css/lib/optimizer/vendor-prefixes.js
var K2 = b((rLt, NY) => {
  var CZe = /(?:^|\W)(-\w+-)/g;
  function V2(e) {
    for (var t = [], r; (r = CZe.exec(e)) !== null; )
      t.indexOf(r[0]) == -1 && t.push(r[0]);
    return t;
  }
  s(V2, "unique");
  function PZe(e, t) {
    return V2(e).sort().join(",") == V2(t).sort().join(",");
  }
  s(PZe, "same");
  NY.exports = {
    unique: V2,
    same: PZe
  };
});

// ../node_modules/clean-css/lib/optimizer/configuration/properties/understandable.js
var FY = b((nLt, LY) => {
  var DZe = K2().same;
  function wZe(e, t, r, i, n) {
    return !(!DZe(t, r) || n && e.isVariable(t) !== e.isVariable(r));
  }
  s(wZe, "understandable");
  LY.exports = wZe;
});

// ../node_modules/clean-css/lib/optimizer/configuration/can-override.js
var qY = b((aLt, BY) => {
  var Jn = FY();
  function OZe(e, t, r) {
    return !Jn(e, t, r, 0, !0) && !(e.isAnimationIterationCountKeyword(r) || e.isPositiveNumber(r)) ? !1 : e.isVariable(t) && e.isVariable(r) ?
    !0 : e.isAnimationIterationCountKeyword(r) || e.isPositiveNumber(r);
  }
  s(OZe, "animationIterationCount");
  function kZe(e, t, r) {
    return !Jn(e, t, r, 0, !0) && !(e.isAnimationNameKeyword(r) || e.isIdentifier(r)) ? !1 : e.isVariable(t) && e.isVariable(r) ? !0 : e.isAnimationNameKeyword(
    r) || e.isIdentifier(r);
  }
  s(kZe, "animationName");
  function MY(e, t, r) {
    if (!e.isFunction(t) || !e.isFunction(r))
      return !1;
    var i = t.substring(0, t.indexOf("(")), n = r.substring(0, r.indexOf("(")), a = t.substring(i.length + 1, t.length - 1), o = r.substring(
    n.length + 1, r.length - 1);
    return e.isFunction(a) || e.isFunction(o) ? i === n && MY(e, a, o) : i === n;
  }
  s(MY, "areSameFunction");
  function IZe(e, t, r) {
    return !Jn(e, t, r, 0, !0) && !(e.isBackgroundPositionKeyword(r) || e.isGlobal(r)) ? !1 : e.isVariable(t) && e.isVariable(r) || e.isBackgroundPositionKeyword(
    r) || e.isGlobal(r) ? !0 : rS(e, t, r);
  }
  s(IZe, "backgroundPosition");
  function RZe(e, t, r) {
    return !Jn(e, t, r, 0, !0) && !(e.isBackgroundSizeKeyword(r) || e.isGlobal(r)) ? !1 : e.isVariable(t) && e.isVariable(r) || e.isBackgroundSizeKeyword(
    r) || e.isGlobal(r) ? !0 : rS(e, t, r);
  }
  s(RZe, "backgroundSize");
  function NZe(e, t, r) {
    return !Jn(e, t, r, 0, !0) && !e.isColor(r) ? !1 : e.isVariable(t) && e.isVariable(r) ? !0 : !e.colorOpacity && (e.isRgbColor(t) || e.isHslColor(
    t)) || !e.colorOpacity && (e.isRgbColor(r) || e.isHslColor(r)) || !e.colorHexAlpha && (e.isHexAlphaColor(t) || e.isHexAlphaColor(r)) ? !1 :
    e.isColor(t) && e.isColor(r) ? !0 : Np(e, t, r);
  }
  s(NZe, "color");
  function LZe(e) {
    return function(t, r, i, n) {
      return e[n](t, r, i);
    };
  }
  s(LZe, "components");
  function FZe(e, t, r) {
    return Jn(e, t, r, 0, !0);
  }
  s(FZe, "fontFamily");
  function MZe(e, t, r) {
    return !Jn(e, t, r, 0, !0) && !e.isImage(r) ? !1 : e.isVariable(t) && e.isVariable(r) || e.isImage(r) ? !0 : e.isImage(t) ? !1 : Np(e, t,
    r);
  }
  s(MZe, "image");
  function mm(e) {
    return function(t, r, i) {
      return !Jn(t, r, i, 0, !0) && !t.isKeyword(e)(i) ? !1 : t.isVariable(r) && t.isVariable(i) ? !0 : t.isKeyword(e)(i);
    };
  }
  s(mm, "keyword");
  function Ci(e) {
    return function(t, r, i) {
      return !Jn(t, r, i, 0, !0) && !(t.isKeyword(e)(i) || t.isGlobal(i)) ? !1 : t.isVariable(r) && t.isVariable(i) ? !0 : t.isKeyword(e)(i) ||
      t.isGlobal(i);
    };
  }
  s(Ci, "keywordWithGlobal");
  function BZe(e, t, r) {
    return !Jn(e, t, r, 0, !0) && !e.isIdentifier(r) ? !1 : e.isVariable(t) && e.isVariable(r) ? !0 : e.isIdentifier(r);
  }
  s(BZe, "propertyName");
  function Np(e, t, r) {
    return MY(e, t, r) ? !0 : t === r;
  }
  s(Np, "sameFunctionOrValue");
  function qZe(e, t, r) {
    return !Jn(e, t, r, 0, !0) && !(e.isUnit(r) || e.isColor(r) || e.isGlobal(r)) ? !1 : e.isVariable(t) && e.isVariable(r) ? !0 : e.isUnit(
    r) || e.isColor(r) || e.isGlobal(r);
  }
  s(qZe, "textShadow");
  function UZe(e, t, r) {
    return !Jn(e, t, r, 0, !0) && !e.isTime(r) ? !1 : e.isVariable(t) && e.isVariable(r) ? !0 : e.isTime(t) && !e.isTime(r) ? !1 : e.isTime(
    r) ? !0 : e.isTime(t) ? !1 : e.isFunction(t) && !e.isPrefixed(t) && e.isFunction(r) && !e.isPrefixed(r) ? !0 : Np(e, t, r);
  }
  s(UZe, "time");
  function jZe(e, t, r) {
    return !Jn(e, t, r, 0, !0) && !(e.isTimingFunction(r) || e.isGlobal(r)) ? !1 : e.isVariable(t) && e.isVariable(r) ? !0 : e.isTimingFunction(
    r) || e.isGlobal(r);
  }
  s(jZe, "timingFunction");
  function rS(e, t, r) {
    return !Jn(e, t, r, 0, !0) && !e.isUnit(r) ? !1 : e.isVariable(t) && e.isVariable(r) ? !0 : e.isUnit(t) && !e.isUnit(r) ? !1 : e.isUnit(
    r) ? !0 : e.isUnit(t) ? !1 : e.isFunction(t) && !e.isPrefixed(t) && e.isFunction(r) && !e.isPrefixed(r) ? !0 : Np(e, t, r);
  }
  s(rS, "unit");
  function ym(e) {
    var t = Ci(e);
    return function(r, i, n) {
      return rS(r, i, n) || t(r, i, n);
    };
  }
  s(ym, "unitOrKeywordWithGlobal");
  function VZe(e, t, r) {
    return !Jn(e, t, r, 0, !0) && !(e.isUnit(r) || e.isNumber(r)) ? !1 : e.isVariable(t) && e.isVariable(r) ? !0 : (e.isUnit(t) || e.isNumber(
    t)) && !(e.isUnit(r) || e.isNumber(r)) ? !1 : e.isUnit(r) || e.isNumber(r) ? !0 : e.isUnit(t) || e.isNumber(t) ? !1 : e.isFunction(t) &&
    !e.isPrefixed(t) && e.isFunction(r) && !e.isPrefixed(r) ? !0 : Np(e, t, r);
  }
  s(VZe, "unitOrNumber");
  function KZe(e, t, r) {
    return !Jn(e, t, r, 0, !0) && !e.isZIndex(r) ? !1 : e.isVariable(t) && e.isVariable(r) ? !0 : e.isZIndex(r);
  }
  s(KZe, "zIndex");
  BY.exports = {
    generic: {
      color: NZe,
      components: LZe,
      image: MZe,
      propertyName: BZe,
      time: UZe,
      timingFunction: jZe,
      unit: rS,
      unitOrNumber: VZe
    },
    property: {
      animationDirection: Ci("animation-direction"),
      animationFillMode: mm("animation-fill-mode"),
      animationIterationCount: OZe,
      animationName: kZe,
      animationPlayState: Ci("animation-play-state"),
      backgroundAttachment: mm("background-attachment"),
      backgroundClip: Ci("background-clip"),
      backgroundOrigin: mm("background-origin"),
      backgroundPosition: IZe,
      backgroundRepeat: mm("background-repeat"),
      backgroundSize: RZe,
      bottom: ym("bottom"),
      borderCollapse: mm("border-collapse"),
      borderStyle: Ci("*-style"),
      clear: Ci("clear"),
      cursor: Ci("cursor"),
      display: Ci("display"),
      float: Ci("float"),
      left: ym("left"),
      fontFamily: FZe,
      fontStretch: Ci("font-stretch"),
      fontStyle: Ci("font-style"),
      fontVariant: Ci("font-variant"),
      fontWeight: Ci("font-weight"),
      listStyleType: Ci("list-style-type"),
      listStylePosition: Ci("list-style-position"),
      outlineStyle: Ci("*-style"),
      overflow: Ci("overflow"),
      position: Ci("position"),
      right: ym("right"),
      textAlign: Ci("text-align"),
      textDecoration: Ci("text-decoration"),
      textOverflow: Ci("text-overflow"),
      textShadow: qZe,
      top: ym("top"),
      transform: Np,
      verticalAlign: ym("vertical-align"),
      visibility: Ci("visibility"),
      whiteSpace: Ci("white-space"),
      zIndex: KZe
    }
  };
});

// ../node_modules/clean-css/lib/optimizer/clone.js
var gm = b((uLt, jY) => {
  var HZe = Fc().single, UY = ui();
  function zZe(e) {
    for (var t = H2(e), r = e.components.length - 1; r >= 0; r--) {
      var i = H2(e.components[r]);
      i.value = e.components[r].value.slice(0), t.components.unshift(i);
    }
    return t.dirty = !0, t.value = e.value.slice(0), t;
  }
  s(zZe, "deep");
  function H2(e) {
    var t = HZe([
      UY.PROPERTY,
      [UY.PROPERTY_NAME, e.name]
    ]);
    return t.important = e.important, t.hack = e.hack, t.unused = !1, t;
  }
  s(H2, "shallow");
  jY.exports = {
    deep: zZe,
    shallow: H2
  };
});

// ../node_modules/clean-css/lib/optimizer/configuration/restore.js
var KY = b((cLt, VY) => {
  var Lp = gm().shallow, Mc = ui(), to = Ln();
  function z2(e) {
    for (var t = 0, r = e.length; t < r; t++) {
      var i = e[t][1];
      if (i != "inherit" && i != to.COMMA && i != to.FORWARD_SLASH)
        return !1;
    }
    return !0;
  }
  s(z2, "isInheritOnly");
  function GZe(e, t, r) {
    var i = e.components, n = [], a, o;
    function u(f) {
      Array.prototype.unshift.apply(n, f.value);
    }
    s(u, "restoreValue");
    function l(f) {
      var d = t[f.name];
      return d.doubleValues && d.defaultValue.length == 1 ? f.value[0][1] == d.defaultValue[0] && (f.value[1] ? f.value[1][1] == d.defaultValue[0] :
      !0) : d.doubleValues && d.defaultValue.length != 1 ? f.value[0][1] == d.defaultValue[0] && (f.value[1] ? f.value[1][1] : f.value[0][1]) ==
      d.defaultValue[1] : f.value[0][1] == d.defaultValue;
    }
    s(l, "isDefaultValue");
    for (var c = i.length - 1; c >= 0; c--) {
      var p = i[c], h = l(p);
      if (p.name == "background-clip") {
        var y = i[c - 1], _ = l(y);
        a = p.value[0][1] == y.value[0][1], o = !a && (_ && !h || !_ && !h || !_ && h && p.value[0][1] != y.value[0][1]), a ? u(y) : o && (u(
        p), u(y)), c--;
      } else if (p.name == "background-size") {
        var g = i[c - 1], m = l(g);
        a = !m && h, o = !a && (m && !h || !m && !h), a ? u(g) : o ? (u(p), n.unshift([Mc.PROPERTY_VALUE, to.FORWARD_SLASH]), u(g)) : g.value.
        length == 1 && u(g), c--;
      } else {
        if (h || t[p.name].multiplexLastOnly && !r)
          continue;
        u(p);
      }
    }
    return n.length === 0 && e.value.length == 1 && e.value[0][1] == "0" && n.push(e.value[0]), n.length === 0 && n.push([Mc.PROPERTY_VALUE,
    t[e.name].defaultValue]), z2(n) ? [n[0]] : n;
  }
  s(GZe, "background");
  function WZe(e) {
    if (e.multiplex) {
      for (var t = Lp(e), r = Lp(e), i = 0; i < 4; i++) {
        var n = e.components[i], a = Lp(e);
        a.value = [n.value[0]], t.components.push(a);
        var o = Lp(e);
        o.value = [n.value[1] || n.value[0]], r.components.push(o);
      }
      var u = iS(t), l = iS(r);
      return u.length == l.length && u[0][1] == l[0][1] && (!(u.length > 1) || u[1][1] == l[1][1]) && (!(u.length > 2) || u[2][1] == l[2][1]) &&
      (!(u.length > 3) || u[3][1] == l[3][1]) ? u : u.concat([[Mc.PROPERTY_VALUE, to.FORWARD_SLASH]]).concat(l);
    }
    return iS(e);
  }
  s(WZe, "borderRadius");
  function $Ze(e, t) {
    var r = e.components, i = [], n, a = 0, o = 0;
    if (e.value[0][1].indexOf(to.INTERNAL) === 0)
      return e.value[0][1] = e.value[0][1].substring(to.INTERNAL.length), e.value;
    for (; a < 4; )
      n = r[a], n.value[0][1] != t[n.name].defaultValue && Array.prototype.push.apply(i, n.value), a++;
    for (Array.prototype.push.apply(i, r[a].value), a++, r[a].value[0][1] != t[r[a].name].defaultValue && (Array.prototype.push.apply(i, [[Mc.
    PROPERTY_VALUE, to.FORWARD_SLASH]]), Array.prototype.push.apply(i, r[a].value)), a++; r[a].value[o]; )
      i.push(r[a].value[o]), r[a].value[o + 1] && i.push([Mc.PROPERTY_VALUE, to.COMMA]), o++;
    return z2(i) ? [i[0]] : i;
  }
  s($Ze, "font");
  function iS(e) {
    var t = e.components, r = t[0].value[0], i = t[1].value[0], n = t[2].value[0], a = t[3].value[0];
    return r[1] == i[1] && r[1] == n[1] && r[1] == a[1] ? [r] : r[1] == n[1] && i[1] == a[1] ? [r, i] : i[1] == a[1] ? [r, i, n] : [r, i, n,
    a];
  }
  s(iS, "fourValues");
  function XZe(e) {
    return function(t, r) {
      if (!t.multiplex)
        return e(t, r, !0);
      var i = 0, n = [], a = {}, o, u;
      for (o = 0, u = t.components[0].value.length; o < u; o++)
        t.components[0].value[o][1] == to.COMMA && i++;
      for (o = 0; o <= i; o++) {
        for (var l = Lp(t), c = 0, p = t.components.length; c < p; c++) {
          var h = t.components[c], y = Lp(h);
          l.components.push(y);
          for (var _ = a[y.name] || 0, g = h.value.length; _ < g; _++) {
            if (h.value[_][1] == to.COMMA) {
              a[y.name] = _ + 1;
              break;
            }
            y.value.push(h.value[_]);
          }
        }
        var m = o == i, f = e(l, r, m);
        Array.prototype.push.apply(n, f), o < i && n.push([Mc.PROPERTY_VALUE, to.COMMA]);
      }
      return n;
    };
  }
  s(XZe, "multiplex");
  function YZe(e, t) {
    for (var r = e.components, i = [], n = r.length - 1; n >= 0; n--) {
      var a = r[n], o = t[a.name];
      (a.value[0][1] != o.defaultValue || "keepUnlessDefault" in o && !JZe(r, t, o.keepUnlessDefault)) && i.unshift(a.value[0]);
    }
    return i.length === 0 && i.push([Mc.PROPERTY_VALUE, t[e.name].defaultValue]), z2(i) ? [i[0]] : i;
  }
  s(YZe, "withoutDefaults");
  function JZe(e, t, r) {
    var i, n, a;
    for (n = 0, a = e.length; n < a; n++)
      if (i = e[n], i.name == r && i.value[0][1] == t[r].defaultValue)
        return !0;
    return !1;
  }
  s(JZe, "isDefault");
  VY.exports = {
    background: GZe,
    borderRadius: WZe,
    font: $Ze,
    fourValues: iS,
    multiplex: XZe,
    withoutDefaults: YZe
  };
});

// ../node_modules/clean-css/lib/options/rounding-precision.js
var G2 = b((pLt, zY) => {
  var HY = Nc(), QZe = /^\d+$/, ZZe = ["*", "all"], Mp = "off", eet = ",", tet = "=";
  function ret(e) {
    return HY(Fp(Mp), iet(e));
  }
  s(ret, "roundingPrecisionFrom");
  function Fp(e) {
    return {
      ch: e,
      cm: e,
      em: e,
      ex: e,
      in: e,
      mm: e,
      pc: e,
      pt: e,
      px: e,
      q: e,
      rem: e,
      vh: e,
      vmax: e,
      vmin: e,
      vw: e,
      "%": e
    };
  }
  s(Fp, "defaults");
  function iet(e) {
    return e == null ? {} : typeof e == "boolean" ? {} : typeof e == "number" && e == -1 ? Fp(Mp) : typeof e == "number" ? Fp(e) : typeof e ==
    "string" && QZe.test(e) ? Fp(parseInt(e)) : typeof e == "string" && e == Mp ? Fp(Mp) : typeof e == "object" ? e : e.split(eet).reduce(function(t, r) {
      var i = r.split(tet), n = i[0], a = parseInt(i[1]);
      return (Number.isNaN(a) || a == -1) && (a = Mp), ZZe.indexOf(n) > -1 ? t = HY(t, Fp(a)) : t[n] = a, t;
    }, {});
  }
  s(iet, "buildPrecisionFrom");
  zY.exports = {
    DEFAULT: Mp,
    roundingPrecisionFrom: ret
  };
});

// ../node_modules/clean-css/lib/options/optimization-level.js
var Ki = b((dLt, WY) => {
  var GY = G2().roundingPrecisionFrom, ro = Nc(), Uc = {
    Zero: "0",
    One: "1",
    Two: "2"
  }, vm = {};
  vm[Uc.Zero] = {};
  vm[Uc.One] = {
    cleanupCharsets: !0,
    normalizeUrls: !0,
    optimizeBackground: !0,
    optimizeBorderRadius: !0,
    optimizeFilter: !0,
    optimizeFontWeight: !0,
    optimizeOutline: !0,
    removeEmpty: !0,
    removeNegativePaddings: !0,
    removeQuotes: !0,
    removeWhitespace: !0,
    replaceMultipleZeros: !0,
    replaceTimeUnits: !0,
    replaceZeroUnits: !0,
    roundingPrecision: GY(void 0),
    selectorsSortingMethod: "standard",
    specialComments: "all",
    tidyAtRules: !0,
    tidyBlockScopes: !0,
    tidySelectors: !0,
    variableValueOptimizers: []
  };
  vm[Uc.Two] = {
    mergeAdjacentRules: !0,
    mergeIntoShorthands: !0,
    mergeMedia: !0,
    mergeNonAdjacentRules: !0,
    mergeSemantically: !1,
    overrideProperties: !0,
    removeEmpty: !0,
    reduceNonAdjacentRules: !0,
    removeDuplicateFontRules: !0,
    removeDuplicateMediaBlocks: !0,
    removeDuplicateRules: !0,
    removeUnusedAtRules: !1,
    restructureRules: !1,
    skipProperties: []
  };
  var Bc = "*", qc = "all", net = "false", set = "off", aet = "true", oet = "on", uet = ",", cet = ";", fet = ":";
  function pet(e) {
    var t = ro(vm, {}), r = Uc.Zero, i = Uc.One, n = Uc.Two;
    return e === void 0 ? (delete t[n], t) : (typeof e == "string" && (e = parseInt(e)), typeof e == "number" && e === parseInt(n) ? t : typeof e ==
    "number" && e === parseInt(i) ? (delete t[n], t) : typeof e == "number" && e === parseInt(r) ? (delete t[n], delete t[i], t) : (typeof e ==
    "object" && (e = het(e)), i in e && "roundingPrecision" in e[i] && (e[i].roundingPrecision = GY(e[i].roundingPrecision)), n in e && "ski\
pProperties" in e[n] && typeof e[n].skipProperties == "string" && (e[n].skipProperties = e[n].skipProperties.split(uet)), (r in e || i in e ||
    n in e) && (t[r] = ro(t[r], e[r])), i in e && Bc in e[i] && (t[i] = ro(t[i], _m(i, bm(e[i][Bc]))), delete e[i][Bc]), i in e && qc in e[i] &&
    (t[i] = ro(t[i], _m(i, bm(e[i][qc]))), delete e[i][qc]), i in e || n in e ? t[i] = ro(t[i], e[i]) : delete t[i], n in e && Bc in e[n] &&
    (t[n] = ro(t[n], _m(n, bm(e[n][Bc]))), delete e[n][Bc]), n in e && qc in e[n] && (t[n] = ro(t[n], _m(n, bm(e[n][qc]))), delete e[n][qc]),
    n in e ? t[n] = ro(t[n], e[n]) : delete t[n], t));
  }
  s(pet, "optimizationLevelFrom");
  function _m(e, t) {
    var r = ro(vm[e], {}), i;
    for (i in r)
      typeof r[i] == "boolean" && (r[i] = t);
    return r;
  }
  s(_m, "defaults");
  function bm(e) {
    switch (e) {
      case net:
      case set:
        return !1;
      case aet:
      case oet:
        return !0;
      default:
        return e;
    }
  }
  s(bm, "normalizeValue");
  function het(e) {
    var t = ro(e, {}), r, i;
    for (i = 0; i <= 2; i++)
      r = "" + i, r in t && (t[r] === void 0 || t[r] === !1) && delete t[r], r in t && t[r] === !0 && (t[r] = {}), r in t && typeof t[r] == "\
string" && (t[r] = det(t[r], r));
    return t;
  }
  s(het, "covertValuesToHashes");
  function det(e, t) {
    return e.split(cet).reduce(function(r, i) {
      var n = i.split(fet), a = n[0], o = n[1], u = bm(o);
      return Bc == a || qc == a ? r = ro(r, _m(t, u)) : r[a] = u, r;
    }, {});
  }
  s(det, "covertToHash");
  WY.exports = {
    OptimizationLevel: Uc,
    optimizationLevelFrom: pet
  };
});

// ../node_modules/clean-css/lib/optimizer/level-1/property-optimizers/background.js
var XY = b((yLt, $Y) => {
  var met = Ki().OptimizationLevel, yet = {
    level1: {
      property: /* @__PURE__ */ s(function(t, r, i) {
        var n = r.value;
        i.level[met.One].optimizeBackground && (n.length == 1 && n[0][1] == "none" && (n[0][1] = "0 0"), n.length == 1 && n[0][1] == "transp\
arent" && (n[0][1] = "0 0"));
      }, "background")
    }
  };
  $Y.exports = yet;
});

// ../node_modules/clean-css/lib/optimizer/level-1/property-optimizers/box-shadow.js
var JY = b((_Lt, YY) => {
  var get = {
    level1: {
      property: /* @__PURE__ */ s(function(t, r) {
        var i = r.value;
        i.length == 4 && i[0][1] === "0" && i[1][1] === "0" && i[2][1] === "0" && i[3][1] === "0" && (r.value.splice(2), r.dirty = !0);
      }, "boxShadow")
    }
  };
  YY.exports = get;
});

// ../node_modules/clean-css/lib/optimizer/level-1/property-optimizers/border-radius.js
var ZY = b((vLt, QY) => {
  var _et = Ki().OptimizationLevel, bet = {
    level1: {
      property: /* @__PURE__ */ s(function(t, r, i) {
        var n = r.value;
        i.level[_et.One].optimizeBorderRadius && (n.length == 3 && n[1][1] == "/" && n[0][1] == n[2][1] ? (r.value.splice(1), r.dirty = !0) :
        n.length == 5 && n[2][1] == "/" && n[0][1] == n[3][1] && n[1][1] == n[4][1] ? (r.value.splice(2), r.dirty = !0) : n.length == 7 && n[3][1] ==
        "/" && n[0][1] == n[4][1] && n[1][1] == n[5][1] && n[2][1] == n[6][1] ? (r.value.splice(3), r.dirty = !0) : n.length == 9 && n[4][1] ==
        "/" && n[0][1] == n[5][1] && n[1][1] == n[6][1] && n[2][1] == n[7][1] && n[3][1] == n[8][1] && (r.value.splice(4), r.dirty = !0));
      }, "borderRadius")
    }
  };
  QY.exports = bet;
});

// ../node_modules/clean-css/lib/optimizer/level-1/property-optimizers/filter.js
var tJ = b((TLt, eJ) => {
  var vet = Ki().OptimizationLevel, Tet = /progid:DXImageTransform\.Microsoft\.(Alpha|Chroma)(\W)/, Eet = /,(\S)/g, Aet = / ?= ?/g, xet = {
    level1: {
      property: /* @__PURE__ */ s(function(t, r, i) {
        i.compatibility.properties.ieFilters && i.level[vet.One].optimizeFilter && (r.value.length == 1 && (r.value[0][1] = r.value[0][1].replace(
          Tet,
          function(n, a, o) {
            return a.toLowerCase() + o;
          }
        )), r.value[0][1] = r.value[0][1].replace(Eet, ", $1").replace(Aet, "="));
      }, "filter")
    }
  };
  eJ.exports = xet;
});

// ../node_modules/clean-css/lib/optimizer/level-1/property-optimizers/font-weight.js
var iJ = b((ALt, rJ) => {
  var Cet = Ki().OptimizationLevel, Pet = {
    level1: {
      property: /* @__PURE__ */ s(function(t, r, i) {
        var n = r.value[0][1];
        i.level[Cet.One].optimizeFontWeight && (n == "normal" ? n = "400" : n == "bold" && (n = "700"), r.value[0][1] = n);
      }, "fontWeight")
    }
  };
  rJ.exports = Pet;
});

// ../node_modules/clean-css/lib/optimizer/level-1/property-optimizers/margin.js
var sJ = b((CLt, nJ) => {
  var Det = Ki().OptimizationLevel, wet = {
    level1: {
      property: /* @__PURE__ */ s(function(t, r, i) {
        var n = r.value;
        i.level[Det.One].replaceMultipleZeros && n.length == 4 && n[0][1] === "0" && n[1][1] === "0" && n[2][1] === "0" && n[3][1] === "0" &&
        (r.value.splice(1), r.dirty = !0);
      }, "margin")
    }
  };
  nJ.exports = wet;
});

// ../node_modules/clean-css/lib/optimizer/level-1/property-optimizers/outline.js
var oJ = b((DLt, aJ) => {
  var Oet = Ki().OptimizationLevel, ket = {
    level1: {
      property: /* @__PURE__ */ s(function(t, r, i) {
        var n = r.value;
        i.level[Oet.One].optimizeOutline && n.length == 1 && n[0][1] == "none" && (n[0][1] = "0");
      }, "outline")
    }
  };
  aJ.exports = ket;
});

// ../node_modules/clean-css/lib/optimizer/level-1/property-optimizers/padding.js
var lJ = b((OLt, uJ) => {
  var Iet = Ki().OptimizationLevel;
  function nS(e) {
    return e && e[1][0] == "-" && parseFloat(e[1]) < 0;
  }
  s(nS, "isNegative");
  var Ret = {
    level1: {
      property: /* @__PURE__ */ s(function(t, r, i) {
        var n = r.value;
        n.length == 4 && n[0][1] === "0" && n[1][1] === "0" && n[2][1] === "0" && n[3][1] === "0" && (r.value.splice(1), r.dirty = !0), i.level[Iet.
        One].removeNegativePaddings && (nS(r.value[0]) || nS(r.value[1]) || nS(r.value[2]) || nS(r.value[3])) && (r.unused = !0);
      }, "padding")
    }
  };
  uJ.exports = Ret;
});

// ../node_modules/clean-css/lib/optimizer/level-1/property-optimizers.js
var fJ = b((ILt, cJ) => {
  cJ.exports = {
    background: XY().level1.property,
    boxShadow: JY().level1.property,
    borderRadius: ZY().level1.property,
    filter: tJ().level1.property,
    fontWeight: iJ().level1.property,
    margin: sJ().level1.property,
    outline: oJ().level1.property,
    padding: lJ().level1.property
  };
});

// ../node_modules/clean-css/lib/optimizer/level-1/value-optimizers/color/shorten-hex.js
var yJ = b((RLt, mJ) => {
  var pJ = {
    aliceblue: "#f0f8ff",
    antiquewhite: "#faebd7",
    aqua: "#0ff",
    aquamarine: "#7fffd4",
    azure: "#f0ffff",
    beige: "#f5f5dc",
    bisque: "#ffe4c4",
    black: "#000",
    blanchedalmond: "#ffebcd",
    blue: "#00f",
    blueviolet: "#8a2be2",
    brown: "#a52a2a",
    burlywood: "#deb887",
    cadetblue: "#5f9ea0",
    chartreuse: "#7fff00",
    chocolate: "#d2691e",
    coral: "#ff7f50",
    cornflowerblue: "#6495ed",
    cornsilk: "#fff8dc",
    crimson: "#dc143c",
    cyan: "#0ff",
    darkblue: "#00008b",
    darkcyan: "#008b8b",
    darkgoldenrod: "#b8860b",
    darkgray: "#a9a9a9",
    darkgreen: "#006400",
    darkgrey: "#a9a9a9",
    darkkhaki: "#bdb76b",
    darkmagenta: "#8b008b",
    darkolivegreen: "#556b2f",
    darkorange: "#ff8c00",
    darkorchid: "#9932cc",
    darkred: "#8b0000",
    darksalmon: "#e9967a",
    darkseagreen: "#8fbc8f",
    darkslateblue: "#483d8b",
    darkslategray: "#2f4f4f",
    darkslategrey: "#2f4f4f",
    darkturquoise: "#00ced1",
    darkviolet: "#9400d3",
    deeppink: "#ff1493",
    deepskyblue: "#00bfff",
    dimgray: "#696969",
    dimgrey: "#696969",
    dodgerblue: "#1e90ff",
    firebrick: "#b22222",
    floralwhite: "#fffaf0",
    forestgreen: "#228b22",
    fuchsia: "#f0f",
    gainsboro: "#dcdcdc",
    ghostwhite: "#f8f8ff",
    gold: "#ffd700",
    goldenrod: "#daa520",
    gray: "#808080",
    green: "#008000",
    greenyellow: "#adff2f",
    grey: "#808080",
    honeydew: "#f0fff0",
    hotpink: "#ff69b4",
    indianred: "#cd5c5c",
    indigo: "#4b0082",
    ivory: "#fffff0",
    khaki: "#f0e68c",
    lavender: "#e6e6fa",
    lavenderblush: "#fff0f5",
    lawngreen: "#7cfc00",
    lemonchiffon: "#fffacd",
    lightblue: "#add8e6",
    lightcoral: "#f08080",
    lightcyan: "#e0ffff",
    lightgoldenrodyellow: "#fafad2",
    lightgray: "#d3d3d3",
    lightgreen: "#90ee90",
    lightgrey: "#d3d3d3",
    lightpink: "#ffb6c1",
    lightsalmon: "#ffa07a",
    lightseagreen: "#20b2aa",
    lightskyblue: "#87cefa",
    lightslategray: "#778899",
    lightslategrey: "#778899",
    lightsteelblue: "#b0c4de",
    lightyellow: "#ffffe0",
    lime: "#0f0",
    limegreen: "#32cd32",
    linen: "#faf0e6",
    magenta: "#ff00ff",
    maroon: "#800000",
    mediumaquamarine: "#66cdaa",
    mediumblue: "#0000cd",
    mediumorchid: "#ba55d3",
    mediumpurple: "#9370db",
    mediumseagreen: "#3cb371",
    mediumslateblue: "#7b68ee",
    mediumspringgreen: "#00fa9a",
    mediumturquoise: "#48d1cc",
    mediumvioletred: "#c71585",
    midnightblue: "#191970",
    mintcream: "#f5fffa",
    mistyrose: "#ffe4e1",
    moccasin: "#ffe4b5",
    navajowhite: "#ffdead",
    navy: "#000080",
    oldlace: "#fdf5e6",
    olive: "#808000",
    olivedrab: "#6b8e23",
    orange: "#ffa500",
    orangered: "#ff4500",
    orchid: "#da70d6",
    palegoldenrod: "#eee8aa",
    palegreen: "#98fb98",
    paleturquoise: "#afeeee",
    palevioletred: "#db7093",
    papayawhip: "#ffefd5",
    peachpuff: "#ffdab9",
    peru: "#cd853f",
    pink: "#ffc0cb",
    plum: "#dda0dd",
    powderblue: "#b0e0e6",
    purple: "#800080",
    rebeccapurple: "#663399",
    red: "#f00",
    rosybrown: "#bc8f8f",
    royalblue: "#4169e1",
    saddlebrown: "#8b4513",
    salmon: "#fa8072",
    sandybrown: "#f4a460",
    seagreen: "#2e8b57",
    seashell: "#fff5ee",
    sienna: "#a0522d",
    silver: "#c0c0c0",
    skyblue: "#87ceeb",
    slateblue: "#6a5acd",
    slategray: "#708090",
    slategrey: "#708090",
    snow: "#fffafa",
    springgreen: "#00ff7f",
    steelblue: "#4682b4",
    tan: "#d2b48c",
    teal: "#008080",
    thistle: "#d8bfd8",
    tomato: "#ff6347",
    turquoise: "#40e0d0",
    violet: "#ee82ee",
    wheat: "#f5deb3",
    white: "#fff",
    whitesmoke: "#f5f5f5",
    yellow: "#ff0",
    yellowgreen: "#9acd32"
  }, W2 = {}, $2 = {};
  for (Sm in pJ)
    sS = pJ[Sm], Sm.length < sS.length ? $2[sS] = Sm : W2[Sm] = sS;
  var sS, Sm, hJ = new RegExp("(^| |,|\\))(" + Object.keys(W2).join("|") + ")( |,|\\)|$)", "ig"), Net = new RegExp("(" + Object.keys($2).join(
  "|") + ")([^a-f0-9]|$)", "ig");
  function dJ(e, t, r, i) {
    return t + W2[r.toLowerCase()] + i;
  }
  s(dJ, "hexConverter");
  function Let(e, t, r) {
    return $2[t.toLowerCase()] + r;
  }
  s(Let, "nameConverter");
  function Fet(e) {
    var t = e.indexOf("#") > -1, r = e.replace(hJ, dJ);
    return r != e && (r = r.replace(hJ, dJ)), t ? r.replace(Net, Let) : r;
  }
  s(Fet, "shortenHex");
  mJ.exports = Fet;
});

// ../node_modules/clean-css/lib/optimizer/level-1/value-optimizers/color/shorten-hsl.js
var _J = b((LLt, gJ) => {
  function Met(e, t, r) {
    var i, n, a;
    if (e %= 360, e < 0 && (e += 360), e = ~~e / 360, t < 0 ? t = 0 : t > 100 && (t = 100), t = ~~t / 100, r < 0 ? r = 0 : r > 100 && (r = 100),
    r = ~~r / 100, t === 0)
      i = n = a = r;
    else {
      var o = r < 0.5 ? r * (1 + t) : r + t - r * t, u = 2 * r - o;
      i = X2(u, o, e + 1 / 3), n = X2(u, o, e), a = X2(u, o, e - 1 / 3);
    }
    return [~~(i * 255), ~~(n * 255), ~~(a * 255)];
  }
  s(Met, "hslToRgb");
  function X2(e, t, r) {
    return r < 0 && (r += 1), r > 1 && (r -= 1), r < 1 / 6 ? e + (t - e) * 6 * r : r < 1 / 2 ? t : r < 2 / 3 ? e + (t - e) * (2 / 3 - r) * 6 :
    e;
  }
  s(X2, "hueToRgb");
  function Bet(e, t, r) {
    var i = Met(e, t, r), n = i[0].toString(16), a = i[1].toString(16), o = i[2].toString(16);
    return "#" + ((n.length == 1 ? "0" : "") + n) + ((a.length == 1 ? "0" : "") + a) + ((o.length == 1 ? "0" : "") + o);
  }
  s(Bet, "shortenHsl");
  gJ.exports = Bet;
});

// ../node_modules/clean-css/lib/optimizer/level-1/value-optimizers/color/shorten-rgb.js
var vJ = b((MLt, bJ) => {
  function qet(e, t, r) {
    var i = Math.max(0, Math.min(parseInt(e), 255)), n = Math.max(0, Math.min(parseInt(t), 255)), a = Math.max(0, Math.min(parseInt(r), 255));
    return "#" + ("00000" + (i << 16 | n << 8 | a).toString(16)).slice(-6);
  }
  s(qet, "shortenRgb");
  bJ.exports = qet;
});

// ../node_modules/clean-css/lib/utils/split.js
var Bp = b((qLt, EJ) => {
  var SJ = Ln();
  function TJ(e, t, r) {
    return r ? t.test(e) : e === t;
  }
  s(TJ, "is");
  function Uet(e, t) {
    var r = SJ.OPEN_ROUND_BRACKET, i = SJ.CLOSE_ROUND_BRACKET, n = 0, a = 0, o = 0, u, l, c = e.length, p = [], h = typeof t == "object" && "\
exec" in t;
    if (!h && e.indexOf(t) == -1)
      return [e];
    if (e.indexOf(r) == -1)
      return e.split(t);
    for (; a < c; )
      e[a] == r ? n++ : e[a] == i && n--, n === 0 && a > 0 && a + 1 < c && TJ(e[a], t, h) && (p.push(e.substring(o, a)), h && t.exec(e[a]).length >
      1 && p.push(e[a]), o = a + 1), a++;
    return o < a + 1 && (u = e.substring(o), l = u[u.length - 1], TJ(l, t, h) && (u = u.substring(0, u.length - 1)), p.push(u)), p;
  }
  s(Uet, "split");
  EJ.exports = Uet;
});

// ../node_modules/clean-css/lib/optimizer/level-1/value-optimizers/color.js
var CJ = b((jLt, xJ) => {
  var AJ = yJ(), jet = _J(), Vet = vJ(), Ket = Bp(), Het = /(rgb|rgba|hsl|hsla)\(([^()]+)\)/gi, zet = /#|rgb|hsl/gi, Get = /(^|[^='"])#([0-9a-f]{6})/gi,
  Wet = /(^|[^='"])#([0-9a-f]{3})/gi, $et = /[0-9a-f]/i, Xet = /hsl\((-?\d+),(-?\d+)%?,(-?\d+)%?\)/gi, Yet = /(rgb|hsl)a?\((-?\d+),(-?\d+%?),(-?\d+%?),(0*[1-9]+[0-9]*(\.?\d*)?)\)/gi,
  Jet = /rgb\((-?\d+),(-?\d+),(-?\d+)\)/gi, Qet = /(?:rgba|hsla)\(0,0%?,0%?,0\)/g, Zet = {
    level1: {
      value: /* @__PURE__ */ s(function(t, r, i) {
        return i.compatibility.properties.colors ? (r.match(zet) && (r = r.replace(Yet, function(n, a, o, u, l, c) {
          return parseInt(c) >= 1 ? a + "(" + [o, u, l].join(",") + ")" : n;
        }).replace(Jet, function(n, a, o, u) {
          return Vet(a, o, u);
        }).replace(Xet, function(n, a, o, u) {
          return jet(a, o, u);
        }).replace(Get, function(n, a, o, u, l) {
          var c = l[u + n.length];
          return c && $et.test(c) ? n : o[0] == o[1] && o[2] == o[3] && o[4] == o[5] ? (a + "#" + o[0] + o[2] + o[4]).toLowerCase() : (a + "\
#" + o).toLowerCase();
        }).replace(Wet, function(n, a, o) {
          return a + "#" + o.toLowerCase();
        }).replace(Het, function(n, a, o) {
          var u = o.split(","), l = a && a.toLowerCase(), c = l == "hsl" && u.length == 3 || l == "hsla" && u.length == 4 || l == "rgb" && u.
          length === 3 && o.indexOf("%") > 0 || l == "rgba" && u.length == 4 && u[0].indexOf("%") > 0;
          return c ? (u[1].indexOf("%") == -1 && (u[1] += "%"), u[2].indexOf("%") == -1 && (u[2] += "%"), a + "(" + u.join(",") + ")") : n;
        }), i.compatibility.colors.opacity && t.indexOf("background") == -1 && (r = r.replace(Qet, function(n) {
          return Ket(r, ",").pop().indexOf("gradient(") > -1 ? n : "transparent";
        }))), AJ(r)) : r;
      }, "color")
    }
  };
  xJ.exports = Zet;
});

// ../node_modules/clean-css/lib/optimizer/level-1/value-optimizers/degrees.js
var DJ = b((KLt, PJ) => {
  var ett = /\(0deg\)/g, ttt = {
    level1: {
      value: /* @__PURE__ */ s(function(t, r, i) {
        return !i.compatibility.properties.zeroUnits || r.indexOf("0deg") == -1 ? r : r.replace(ett, "(0)");
      }, "degrees")
    }
  };
  PJ.exports = ttt;
});

// ../node_modules/clean-css/lib/optimizer/level-1/value-optimizers/starts-as-url.js
var aS = b((zLt, wJ) => {
  var rtt = /^url\(/i;
  function itt(e) {
    return rtt.test(e);
  }
  s(itt, "startsAsUrl");
  wJ.exports = itt;
});

// ../node_modules/clean-css/lib/optimizer/level-1/value-optimizers/fraction.js
var RJ = b((WLt, IJ) => {
  var ntt = Bp(), stt = aS(), att = Ki().OptimizationLevel, ott = /^expression\(.*\)$/, utt = /^(-(?:moz|ms|o|webkit)-[a-z-]+|[a-z-]+)\((.+)\)$/,
  ltt = /([\s,/])/, ctt = /(^|\D)\.0+(\D|$)/g, ftt = /\.([1-9]*)0+(\D|$)/g, ptt = /(^|\D)0\.(\d)/g, OJ = /([^\w\d-]|^)-0([^.]|$)/g, htt = /(^|\s)0+([1-9])/g;
  function kJ(e) {
    var t, r;
    return stt(e) || ott.test(e) ? e : (t = utt.exec(e), t ? (r = ntt(t[2], ltt).map(function(i) {
      return kJ(i);
    }), t[1] + "(" + r.join("") + ")") : dtt(e));
  }
  s(kJ, "optimizeRecursively");
  function dtt(e) {
    return e.indexOf("0") == -1 ? e : (e.indexOf("-") > -1 && (e = e.replace(OJ, "$10$2").replace(OJ, "$10$2")), e.replace(htt, "$1$2").replace(
    ctt, "$10$2").replace(ftt, function(t, r, i) {
      return (r.length > 0 ? "." : "") + r + i;
    }).replace(ptt, "$1.$2"));
  }
  s(dtt, "optimizeFractions");
  var mtt = {
    level1: {
      value: /* @__PURE__ */ s(function(t, r, i) {
        return i.level[att.One].replaceZeroUnits ? kJ(r) : r;
      }, "fraction")
    }
  };
  IJ.exports = mtt;
});

// ../node_modules/clean-css/lib/optimizer/level-1/value-optimizers/precision.js
var LJ = b((XLt, NJ) => {
  var ytt = {
    level1: {
      value: /* @__PURE__ */ s(function(t, r, i) {
        return !i.precision.enabled || r.indexOf(".") === -1 ? r : r.replace(i.precision.decimalPointMatcher, "$1$2$3").replace(i.precision.
        zeroMatcher, function(n, a, o, u) {
          var l = i.precision.units[u].multiplier, c = parseInt(a), p = Number.isNaN(c) ? 0 : c, h = parseFloat(o);
          return Math.round((p + h) * l) / l + u;
        });
      }, "precision")
    }
  };
  NJ.exports = ytt;
});

// ../node_modules/clean-css/lib/optimizer/level-1/value-optimizers/text-quotes.js
var MJ = b((JLt, FJ) => {
  var gtt = Ki().OptimizationLevel, _tt = /^local\(/i, btt = /^('.*'|".*")$/, vtt = /^['"][a-zA-Z][a-zA-Z\d\-_]+['"]$/, Stt = /^['"](?:cursive|default|emoji|fangsong|fantasy|inherit|initial|math|monospace|revert|revert-layer|sans-serif|serif|system-ui|ui-monospace|ui-rounded|ui-sans-serif|ui-serif|unset)['"]$/,
  Ttt = {
    level1: {
      value: /* @__PURE__ */ s(function(t, r, i) {
        return (t == "font-family" || t == "font") && Stt.test(r) || !i.level[gtt.One].removeQuotes || !btt.test(r) && !_tt.test(r) ? r : vtt.
        test(r) ? r.substring(1, r.length - 1) : r;
      }, "textQuotes")
    }
  };
  FJ.exports = Ttt;
});

// ../node_modules/clean-css/lib/optimizer/level-1/value-optimizers/time.js
var UJ = b((ZLt, qJ) => {
  var Ett = Ki().OptimizationLevel, BJ = /^(-?[\d.]+)(m?s)$/, Att = {
    level1: {
      value: /* @__PURE__ */ s(function(t, r, i) {
        return !i.level[Ett.One].replaceTimeUnits || !BJ.test(r) ? r : r.replace(BJ, function(n, a, o) {
          var u;
          return o == "ms" ? u = parseInt(a) / 1e3 + "s" : o == "s" && (u = parseFloat(a) * 1e3 + "ms"), u.length < n.length ? u : n;
        });
      }, "time")
    }
  };
  qJ.exports = Att;
});

// ../node_modules/clean-css/lib/optimizer/level-1/value-optimizers/unit.js
var KJ = b((tFt, VJ) => {
  var jJ = /(?:^|\s|\()(-?\d+)px/, xtt = {
    level1: {
      value: /* @__PURE__ */ s(function(t, r, i) {
        return jJ.test(r) ? r.replace(jJ, function(n, a) {
          var o, u = parseInt(a);
          return u === 0 ? n : (i.compatibility.properties.shorterLengthUnits && i.compatibility.units.pt && u * 3 % 4 === 0 && (o = u * 3 /
          4 + "pt"), i.compatibility.properties.shorterLengthUnits && i.compatibility.units.pc && u % 16 === 0 && (o = u / 16 + "pc"), i.compatibility.
          properties.shorterLengthUnits && i.compatibility.units.in && u % 96 === 0 && (o = u / 96 + "in"), o && (o = n.substring(0, n.indexOf(
          a)) + o), o && o.length < n.length ? o : n);
        }) : r;
      }, "unit")
    }
  };
  VJ.exports = xtt;
});

// ../node_modules/clean-css/lib/optimizer/level-1/value-optimizers/url-prefix.js
var zJ = b((iFt, HJ) => {
  var Ctt = aS(), Ptt = Ki().OptimizationLevel, Dtt = /^url\(/i, wtt = {
    level1: {
      value: /* @__PURE__ */ s(function(t, r, i) {
        return !i.level[Ptt.One].normalizeUrls || !Ctt(r) ? r : r.replace(Dtt, "url(");
      }, "urlPrefix")
    }
  };
  HJ.exports = wtt;
});

// ../node_modules/clean-css/lib/optimizer/level-1/value-optimizers/url-quotes.js
var WJ = b((sFt, GJ) => {
  var Ott = /^url\(['"].+['"]\)$/, ktt = /^url\(['"].*[*\s()'"].*['"]\)$/, Itt = /["']/g, Rtt = /^url\(['"]data:[^;]+;charset/, Ntt = {
    level1: {
      value: /* @__PURE__ */ s(function(t, r, i) {
        return i.compatibility.properties.urlQuotes ? r : Ott.test(r) && !ktt.test(r) && !Rtt.test(r) ? r.replace(Itt, "") : r;
      }, "urlQuotes")
    }
  };
  GJ.exports = Ntt;
});

// ../node_modules/clean-css/lib/optimizer/level-1/value-optimizers/url-whitespace.js
var XJ = b((oFt, $J) => {
  var Ltt = aS(), Ftt = /\\?\n|\\?\r\n/g, Mtt = /(\()\s+/g, Btt = /\s+(\))/g, qtt = {
    level1: {
      value: /* @__PURE__ */ s(function(t, r) {
        return Ltt(r) ? r.replace(Ftt, "").replace(Mtt, "$1").replace(Btt, "$1") : r;
      }, "urlWhitespace")
    }
  };
  $J.exports = qtt;
});

// ../node_modules/clean-css/lib/optimizer/level-1/value-optimizers/whitespace.js
var QJ = b((lFt, JJ) => {
  var Utt = Ki().OptimizationLevel, YJ = Ln(), jtt = /\) ?\/ ?/g, Vtt = /, /g, Ktt = /\r?\n/g, Htt = /\s+/g, ztt = /\s+(;?\))/g, Gtt = /(\(;?)\s+/g,
  Wtt = /^--\S+$/, $tt = /^var\(\s*--\S+\s*\)$/, Xtt = {
    level1: {
      value: /* @__PURE__ */ s(function(t, r, i) {
        return !i.level[Utt.One].removeWhitespace || Wtt.test(t) && !$tt.test(r) || r.indexOf(" ") == -1 && r.indexOf(`
`) == -1 || r.indexOf("expression") === 0 || r.indexOf(YJ.SINGLE_QUOTE) > -1 || r.indexOf(YJ.DOUBLE_QUOTE) > -1 ? r : (r = r.replace(Ktt, ""),
        r = r.replace(Htt, " "), r.indexOf("calc") > -1 && (r = r.replace(jtt, ")/ ")), r.replace(Gtt, "$1").replace(ztt, "$1").replace(Vtt,
        ","));
      }, "whitespace")
    }
  };
  JJ.exports = Xtt;
});

// ../node_modules/clean-css/lib/optimizer/level-1/value-optimizers/zero.js
var tQ = b((fFt, eQ) => {
  var Ytt = Bp(), Jtt = /^(-(?:moz|ms|o|webkit)-[a-z-]+|[a-z-]+)\((.+)\)$/, Qtt = /^(?:-moz-calc|-webkit-calc|calc|rgb|hsl|rgba|hsla|min|max|clamp|expression)\(/,
  Ztt = /([\s,/])/;
  function ZJ(e, t) {
    var r, i;
    return Qtt.test(e) ? e : (r = Jtt.exec(e), r ? (i = Ytt(r[2], Ztt).map(function(n) {
      return ZJ(n, t);
    }), r[1] + "(" + i.join("") + ")") : ert(e, t));
  }
  s(ZJ, "removeRecursively");
  function ert(e, t) {
    return e.replace(t.unitsRegexp, "$10$2").replace(t.unitsRegexp, "$10$2");
  }
  s(ert, "removeZeros");
  var trt = {
    level1: {
      value: /* @__PURE__ */ s(function(t, r, i) {
        return !i.compatibility.properties.zeroUnits || r.indexOf("%") > 0 && (t == "height" || t == "max-height" || t == "width" || t == "m\
ax-width") ? r : ZJ(r, i);
      }, "zero")
    }
  };
  eQ.exports = trt;
});

// ../node_modules/clean-css/lib/optimizer/level-1/value-optimizers.js
var Y2 = b((hFt, rQ) => {
  rQ.exports = {
    color: CJ().level1.value,
    degrees: DJ().level1.value,
    fraction: RJ().level1.value,
    precision: LJ().level1.value,
    textQuotes: MJ().level1.value,
    time: UJ().level1.value,
    unit: KJ().level1.value,
    urlPrefix: zJ().level1.value,
    urlQuotes: WJ().level1.value,
    urlWhiteSpace: XJ().level1.value,
    whiteSpace: QJ().level1.value,
    zero: tQ().level1.value
  };
});

// ../node_modules/clean-css/lib/optimizer/configuration.js
var Ou = b((dFt, sQ) => {
  var Qi = RY(), ne = qY(), Zi = KY(), en = fJ(), L = Y2(), iQ = Nc(), lS = {
    animation: {
      canOverride: ne.generic.components([
        ne.generic.time,
        ne.generic.timingFunction,
        ne.generic.time,
        ne.property.animationIterationCount,
        ne.property.animationDirection,
        ne.property.animationFillMode,
        ne.property.animationPlayState,
        ne.property.animationName
      ]),
      components: [
        "animation-duration",
        "animation-timing-function",
        "animation-delay",
        "animation-iteration-count",
        "animation-direction",
        "animation-fill-mode",
        "animation-play-state",
        "animation-name"
      ],
      breakUp: Qi.multiplex(Qi.animation),
      defaultValue: "none",
      restore: Zi.multiplex(Zi.withoutDefaults),
      shorthand: !0,
      valueOptimizers: [
        L.whiteSpace,
        L.textQuotes,
        L.time,
        L.fraction,
        L.precision,
        L.unit,
        L.zero
      ],
      vendorPrefixes: [
        "-moz-",
        "-o-",
        "-webkit-"
      ]
    },
    "animation-delay": {
      canOverride: ne.generic.time,
      componentOf: [
        "animation"
      ],
      defaultValue: "0s",
      intoMultiplexMode: "real",
      valueOptimizers: [
        L.time,
        L.fraction,
        L.precision,
        L.unit,
        L.zero
      ],
      vendorPrefixes: [
        "-moz-",
        "-o-",
        "-webkit-"
      ]
    },
    "animation-direction": {
      canOverride: ne.property.animationDirection,
      componentOf: [
        "animation"
      ],
      defaultValue: "normal",
      intoMultiplexMode: "real",
      vendorPrefixes: [
        "-moz-",
        "-o-",
        "-webkit-"
      ]
    },
    "animation-duration": {
      canOverride: ne.generic.time,
      componentOf: [
        "animation"
      ],
      defaultValue: "0s",
      intoMultiplexMode: "real",
      keepUnlessDefault: "animation-delay",
      valueOptimizers: [
        L.time,
        L.fraction,
        L.precision,
        L.unit,
        L.zero
      ],
      vendorPrefixes: [
        "-moz-",
        "-o-",
        "-webkit-"
      ]
    },
    "animation-fill-mode": {
      canOverride: ne.property.animationFillMode,
      componentOf: [
        "animation"
      ],
      defaultValue: "none",
      intoMultiplexMode: "real",
      vendorPrefixes: [
        "-moz-",
        "-o-",
        "-webkit-"
      ]
    },
    "animation-iteration-count": {
      canOverride: ne.property.animationIterationCount,
      componentOf: [
        "animation"
      ],
      defaultValue: "1",
      intoMultiplexMode: "real",
      vendorPrefixes: [
        "-moz-",
        "-o-",
        "-webkit-"
      ]
    },
    "animation-name": {
      canOverride: ne.property.animationName,
      componentOf: [
        "animation"
      ],
      defaultValue: "none",
      intoMultiplexMode: "real",
      valueOptimizers: [
        L.textQuotes
      ],
      vendorPrefixes: [
        "-moz-",
        "-o-",
        "-webkit-"
      ]
    },
    "animation-play-state": {
      canOverride: ne.property.animationPlayState,
      componentOf: [
        "animation"
      ],
      defaultValue: "running",
      intoMultiplexMode: "real",
      vendorPrefixes: [
        "-moz-",
        "-o-",
        "-webkit-"
      ]
    },
    "animation-timing-function": {
      canOverride: ne.generic.timingFunction,
      componentOf: [
        "animation"
      ],
      defaultValue: "ease",
      intoMultiplexMode: "real",
      vendorPrefixes: [
        "-moz-",
        "-o-",
        "-webkit-"
      ]
    },
    background: {
      canOverride: ne.generic.components([
        ne.generic.image,
        ne.property.backgroundPosition,
        ne.property.backgroundSize,
        ne.property.backgroundRepeat,
        ne.property.backgroundAttachment,
        ne.property.backgroundOrigin,
        ne.property.backgroundClip,
        ne.generic.color
      ]),
      components: [
        "background-image",
        "background-position",
        "background-size",
        "background-repeat",
        "background-attachment",
        "background-origin",
        "background-clip",
        "background-color"
      ],
      breakUp: Qi.multiplex(Qi.background),
      defaultValue: "0 0",
      propertyOptimizer: en.background,
      restore: Zi.multiplex(Zi.background),
      shortestValue: "0",
      shorthand: !0,
      valueOptimizers: [
        L.whiteSpace,
        L.urlWhiteSpace,
        L.fraction,
        L.zero,
        L.color,
        L.urlPrefix,
        L.urlQuotes
      ]
    },
    "background-attachment": {
      canOverride: ne.property.backgroundAttachment,
      componentOf: [
        "background"
      ],
      defaultValue: "scroll",
      intoMultiplexMode: "real"
    },
    "background-clip": {
      canOverride: ne.property.backgroundClip,
      componentOf: [
        "background"
      ],
      defaultValue: "border-box",
      intoMultiplexMode: "real",
      shortestValue: "border-box"
    },
    "background-color": {
      canOverride: ne.generic.color,
      componentOf: [
        "background"
      ],
      defaultValue: "transparent",
      intoMultiplexMode: "real",
      // otherwise real color will turn into default since color appears in last multiplex only
      multiplexLastOnly: !0,
      nonMergeableValue: "none",
      shortestValue: "red",
      valueOptimizers: [
        L.whiteSpace,
        L.fraction,
        L.color
      ]
    },
    "background-image": {
      canOverride: ne.generic.image,
      componentOf: [
        "background"
      ],
      defaultValue: "none",
      intoMultiplexMode: "default",
      valueOptimizers: [
        L.urlWhiteSpace,
        L.urlPrefix,
        L.urlQuotes,
        L.whiteSpace,
        L.fraction,
        L.precision,
        L.unit,
        L.zero,
        L.color
      ]
    },
    "background-origin": {
      canOverride: ne.property.backgroundOrigin,
      componentOf: [
        "background"
      ],
      defaultValue: "padding-box",
      intoMultiplexMode: "real",
      shortestValue: "border-box"
    },
    "background-position": {
      canOverride: ne.property.backgroundPosition,
      componentOf: [
        "background"
      ],
      defaultValue: ["0", "0"],
      doubleValues: !0,
      intoMultiplexMode: "real",
      shortestValue: "0",
      valueOptimizers: [
        L.whiteSpace,
        L.fraction,
        L.precision,
        L.unit,
        L.zero
      ]
    },
    "background-repeat": {
      canOverride: ne.property.backgroundRepeat,
      componentOf: [
        "background"
      ],
      defaultValue: ["repeat"],
      doubleValues: !0,
      intoMultiplexMode: "real"
    },
    "background-size": {
      canOverride: ne.property.backgroundSize,
      componentOf: [
        "background"
      ],
      defaultValue: ["auto"],
      doubleValues: !0,
      intoMultiplexMode: "real",
      shortestValue: "0 0",
      valueOptimizers: [
        L.whiteSpace,
        L.fraction,
        L.precision,
        L.unit,
        L.zero
      ]
    },
    bottom: {
      canOverride: ne.property.bottom,
      defaultValue: "auto",
      valueOptimizers: [
        L.whiteSpace,
        L.fraction,
        L.precision,
        L.unit,
        L.zero
      ]
    },
    border: {
      breakUp: Qi.border,
      canOverride: ne.generic.components([
        ne.generic.unit,
        ne.property.borderStyle,
        ne.generic.color
      ]),
      components: [
        "border-width",
        "border-style",
        "border-color"
      ],
      defaultValue: "none",
      overridesShorthands: [
        "border-bottom",
        "border-left",
        "border-right",
        "border-top"
      ],
      restore: Zi.withoutDefaults,
      shorthand: !0,
      shorthandComponents: !0,
      valueOptimizers: [
        L.whiteSpace,
        L.fraction,
        L.zero,
        L.color
      ]
    },
    "border-bottom": {
      breakUp: Qi.border,
      canOverride: ne.generic.components([
        ne.generic.unit,
        ne.property.borderStyle,
        ne.generic.color
      ]),
      components: [
        "border-bottom-width",
        "border-bottom-style",
        "border-bottom-color"
      ],
      defaultValue: "none",
      restore: Zi.withoutDefaults,
      shorthand: !0,
      valueOptimizers: [
        L.whiteSpace,
        L.fraction,
        L.zero,
        L.color
      ]
    },
    "border-bottom-color": {
      canOverride: ne.generic.color,
      componentOf: [
        "border-bottom",
        "border-color"
      ],
      defaultValue: "none",
      valueOptimizers: [
        L.whiteSpace,
        L.fraction,
        L.color
      ]
    },
    "border-bottom-left-radius": {
      canOverride: ne.generic.unit,
      componentOf: [
        "border-radius"
      ],
      defaultValue: "0",
      propertyOptimizer: en.borderRadius,
      valueOptimizers: [
        L.whiteSpace,
        L.fraction,
        L.precision,
        L.unit,
        L.zero
      ],
      vendorPrefixes: [
        "-moz-",
        "-o-"
      ]
    },
    "border-bottom-right-radius": {
      canOverride: ne.generic.unit,
      componentOf: [
        "border-radius"
      ],
      defaultValue: "0",
      propertyOptimizer: en.borderRadius,
      valueOptimizers: [
        L.whiteSpace,
        L.fraction,
        L.precision,
        L.unit,
        L.zero
      ],
      vendorPrefixes: [
        "-moz-",
        "-o-"
      ]
    },
    "border-bottom-style": {
      canOverride: ne.property.borderStyle,
      componentOf: [
        "border-bottom",
        "border-style"
      ],
      defaultValue: "none"
    },
    "border-bottom-width": {
      canOverride: ne.generic.unit,
      componentOf: [
        "border-bottom",
        "border-width"
      ],
      defaultValue: "medium",
      oppositeTo: "border-top-width",
      shortestValue: "0",
      valueOptimizers: [
        L.whiteSpace,
        L.fraction,
        L.precision,
        L.unit,
        L.zero
      ]
    },
    "border-collapse": {
      canOverride: ne.property.borderCollapse,
      defaultValue: "separate"
    },
    "border-color": {
      breakUp: Qi.fourValues,
      canOverride: ne.generic.components([
        ne.generic.color,
        ne.generic.color,
        ne.generic.color,
        ne.generic.color
      ]),
      componentOf: [
        "border"
      ],
      components: [
        "border-top-color",
        "border-right-color",
        "border-bottom-color",
        "border-left-color"
      ],
      defaultValue: "none",
      restore: Zi.fourValues,
      shortestValue: "red",
      shorthand: !0,
      singleTypeComponents: !0,
      valueOptimizers: [
        L.whiteSpace,
        L.fraction,
        L.color
      ]
    },
    "border-left": {
      breakUp: Qi.border,
      canOverride: ne.generic.components([
        ne.generic.unit,
        ne.property.borderStyle,
        ne.generic.color
      ]),
      components: [
        "border-left-width",
        "border-left-style",
        "border-left-color"
      ],
      defaultValue: "none",
      restore: Zi.withoutDefaults,
      shorthand: !0,
      valueOptimizers: [
        L.whiteSpace,
        L.fraction,
        L.zero,
        L.color
      ]
    },
    "border-left-color": {
      canOverride: ne.generic.color,
      componentOf: [
        "border-color",
        "border-left"
      ],
      defaultValue: "none",
      valueOptimizers: [
        L.whiteSpace,
        L.fraction,
        L.color
      ]
    },
    "border-left-style": {
      canOverride: ne.property.borderStyle,
      componentOf: [
        "border-left",
        "border-style"
      ],
      defaultValue: "none"
    },
    "border-left-width": {
      canOverride: ne.generic.unit,
      componentOf: [
        "border-left",
        "border-width"
      ],
      defaultValue: "medium",
      oppositeTo: "border-right-width",
      shortestValue: "0",
      valueOptimizers: [
        L.whiteSpace,
        L.fraction,
        L.precision,
        L.unit,
        L.zero
      ]
    },
    "border-radius": {
      breakUp: Qi.borderRadius,
      canOverride: ne.generic.components([
        ne.generic.unit,
        ne.generic.unit,
        ne.generic.unit,
        ne.generic.unit
      ]),
      components: [
        "border-top-left-radius",
        "border-top-right-radius",
        "border-bottom-right-radius",
        "border-bottom-left-radius"
      ],
      defaultValue: "0",
      propertyOptimizer: en.borderRadius,
      restore: Zi.borderRadius,
      shorthand: !0,
      valueOptimizers: [
        L.whiteSpace,
        L.fraction,
        L.precision,
        L.unit,
        L.zero
      ],
      vendorPrefixes: [
        "-moz-",
        "-o-"
      ]
    },
    "border-right": {
      breakUp: Qi.border,
      canOverride: ne.generic.components([
        ne.generic.unit,
        ne.property.borderStyle,
        ne.generic.color
      ]),
      components: [
        "border-right-width",
        "border-right-style",
        "border-right-color"
      ],
      defaultValue: "none",
      restore: Zi.withoutDefaults,
      shorthand: !0,
      valueOptimizers: [
        L.whiteSpace,
        L.fraction,
        L.color
      ]
    },
    "border-right-color": {
      canOverride: ne.generic.color,
      componentOf: [
        "border-color",
        "border-right"
      ],
      defaultValue: "none",
      valueOptimizers: [
        L.whiteSpace,
        L.fraction,
        L.color
      ]
    },
    "border-right-style": {
      canOverride: ne.property.borderStyle,
      componentOf: [
        "border-right",
        "border-style"
      ],
      defaultValue: "none"
    },
    "border-right-width": {
      canOverride: ne.generic.unit,
      componentOf: [
        "border-right",
        "border-width"
      ],
      defaultValue: "medium",
      oppositeTo: "border-left-width",
      shortestValue: "0",
      valueOptimizers: [
        L.whiteSpace,
        L.fraction,
        L.precision,
        L.unit,
        L.zero
      ]
    },
    "border-style": {
      breakUp: Qi.fourValues,
      canOverride: ne.generic.components([
        ne.property.borderStyle,
        ne.property.borderStyle,
        ne.property.borderStyle,
        ne.property.borderStyle
      ]),
      componentOf: [
        "border"
      ],
      components: [
        "border-top-style",
        "border-right-style",
        "border-bottom-style",
        "border-left-style"
      ],
      defaultValue: "none",
      restore: Zi.fourValues,
      shorthand: !0,
      singleTypeComponents: !0
    },
    "border-top": {
      breakUp: Qi.border,
      canOverride: ne.generic.components([
        ne.generic.unit,
        ne.property.borderStyle,
        ne.generic.color
      ]),
      components: [
        "border-top-width",
        "border-top-style",
        "border-top-color"
      ],
      defaultValue: "none",
      restore: Zi.withoutDefaults,
      shorthand: !0,
      valueOptimizers: [
        L.whiteSpace,
        L.fraction,
        L.precision,
        L.zero,
        L.color,
        L.unit
      ]
    },
    "border-top-color": {
      canOverride: ne.generic.color,
      componentOf: [
        "border-color",
        "border-top"
      ],
      defaultValue: "none",
      valueOptimizers: [
        L.whiteSpace,
        L.fraction,
        L.color
      ]
    },
    "border-top-left-radius": {
      canOverride: ne.generic.unit,
      componentOf: [
        "border-radius"
      ],
      defaultValue: "0",
      propertyOptimizer: en.borderRadius,
      valueOptimizers: [
        L.whiteSpace,
        L.fraction,
        L.precision,
        L.unit,
        L.zero
      ],
      vendorPrefixes: [
        "-moz-",
        "-o-"
      ]
    },
    "border-top-right-radius": {
      canOverride: ne.generic.unit,
      componentOf: [
        "border-radius"
      ],
      defaultValue: "0",
      propertyOptimizer: en.borderRadius,
      valueOptimizers: [
        L.whiteSpace,
        L.fraction,
        L.precision,
        L.unit,
        L.zero
      ],
      vendorPrefixes: [
        "-moz-",
        "-o-"
      ]
    },
    "border-top-style": {
      canOverride: ne.property.borderStyle,
      componentOf: [
        "border-style",
        "border-top"
      ],
      defaultValue: "none"
    },
    "border-top-width": {
      canOverride: ne.generic.unit,
      componentOf: [
        "border-top",
        "border-width"
      ],
      defaultValue: "medium",
      oppositeTo: "border-bottom-width",
      shortestValue: "0",
      valueOptimizers: [
        L.whiteSpace,
        L.fraction,
        L.precision,
        L.unit,
        L.zero
      ]
    },
    "border-width": {
      breakUp: Qi.fourValues,
      canOverride: ne.generic.components([
        ne.generic.unit,
        ne.generic.unit,
        ne.generic.unit,
        ne.generic.unit
      ]),
      componentOf: [
        "border"
      ],
      components: [
        "border-top-width",
        "border-right-width",
        "border-bottom-width",
        "border-left-width"
      ],
      defaultValue: "medium",
      restore: Zi.fourValues,
      shortestValue: "0",
      shorthand: !0,
      singleTypeComponents: !0,
      valueOptimizers: [
        L.whiteSpace,
        L.fraction,
        L.precision,
        L.unit,
        L.zero
      ]
    },
    "box-shadow": {
      propertyOptimizer: en.boxShadow,
      valueOptimizers: [
        L.whiteSpace,
        L.fraction,
        L.precision,
        L.unit,
        L.zero,
        L.color
      ],
      vendorPrefixes: [
        "-moz-",
        "-ms-",
        "-o-",
        "-webkit-"
      ]
    },
    clear: {
      canOverride: ne.property.clear,
      defaultValue: "none"
    },
    clip: {
      valueOptimizers: [
        L.whiteSpace,
        L.fraction,
        L.precision,
        L.unit,
        L.zero
      ]
    },
    color: {
      canOverride: ne.generic.color,
      defaultValue: "transparent",
      shortestValue: "red",
      valueOptimizers: [
        L.whiteSpace,
        L.fraction,
        L.color
      ]
    },
    "column-gap": {
      valueOptimizers: [
        L.whiteSpace,
        L.fraction,
        L.precision,
        L.unit,
        L.zero
      ]
    },
    cursor: {
      canOverride: ne.property.cursor,
      defaultValue: "auto"
    },
    display: { canOverride: ne.property.display },
    filter: {
      propertyOptimizer: en.filter,
      valueOptimizers: [
        L.fraction
      ]
    },
    float: {
      canOverride: ne.property.float,
      defaultValue: "none"
    },
    font: {
      breakUp: Qi.font,
      canOverride: ne.generic.components([
        ne.property.fontStyle,
        ne.property.fontVariant,
        ne.property.fontWeight,
        ne.property.fontStretch,
        ne.generic.unit,
        ne.generic.unit,
        ne.property.fontFamily
      ]),
      components: [
        "font-style",
        "font-variant",
        "font-weight",
        "font-stretch",
        "font-size",
        "line-height",
        "font-family"
      ],
      restore: Zi.font,
      shorthand: !0,
      valueOptimizers: [
        L.textQuotes
      ]
    },
    "font-family": {
      canOverride: ne.property.fontFamily,
      defaultValue: "user|agent|specific",
      valueOptimizers: [
        L.textQuotes
      ]
    },
    "font-size": {
      canOverride: ne.generic.unit,
      defaultValue: "medium",
      shortestValue: "0",
      valueOptimizers: [
        L.fraction
      ]
    },
    "font-stretch": {
      canOverride: ne.property.fontStretch,
      defaultValue: "normal"
    },
    "font-style": {
      canOverride: ne.property.fontStyle,
      defaultValue: "normal"
    },
    "font-variant": {
      canOverride: ne.property.fontVariant,
      defaultValue: "normal"
    },
    "font-weight": {
      canOverride: ne.property.fontWeight,
      defaultValue: "normal",
      propertyOptimizer: en.fontWeight,
      shortestValue: "400"
    },
    gap: {
      valueOptimizers: [
        L.whiteSpace,
        L.fraction,
        L.precision,
        L.unit,
        L.zero
      ]
    },
    height: {
      canOverride: ne.generic.unit,
      defaultValue: "auto",
      shortestValue: "0",
      valueOptimizers: [
        L.whiteSpace,
        L.fraction,
        L.precision,
        L.unit,
        L.zero
      ]
    },
    left: {
      canOverride: ne.property.left,
      defaultValue: "auto",
      valueOptimizers: [
        L.whiteSpace,
        L.fraction,
        L.precision,
        L.unit,
        L.zero
      ]
    },
    "letter-spacing": {
      valueOptimizers: [
        L.fraction,
        L.zero
      ]
    },
    "line-height": {
      canOverride: ne.generic.unitOrNumber,
      defaultValue: "normal",
      shortestValue: "0",
      valueOptimizers: [
        L.fraction,
        L.zero
      ]
    },
    "list-style": {
      canOverride: ne.generic.components([
        ne.property.listStyleType,
        ne.property.listStylePosition,
        ne.property.listStyleImage
      ]),
      components: [
        "list-style-type",
        "list-style-position",
        "list-style-image"
      ],
      breakUp: Qi.listStyle,
      restore: Zi.withoutDefaults,
      defaultValue: "outside",
      // can't use 'disc' because that'd override default 'decimal' for <ol>
      shortestValue: "none",
      shorthand: !0
    },
    "list-style-image": {
      canOverride: ne.generic.image,
      componentOf: [
        "list-style"
      ],
      defaultValue: "none"
    },
    "list-style-position": {
      canOverride: ne.property.listStylePosition,
      componentOf: [
        "list-style"
      ],
      defaultValue: "outside",
      shortestValue: "inside"
    },
    "list-style-type": {
      canOverride: ne.property.listStyleType,
      componentOf: [
        "list-style"
      ],
      // NOTE: we can't tell the real default value here, it's 'disc' for <ul> and 'decimal' for <ol>
      // this is a hack, but it doesn't matter because this value will be either overridden or
      // it will disappear at the final step anyway
      defaultValue: "decimal|disc",
      shortestValue: "none"
    },
    margin: {
      breakUp: Qi.fourValues,
      canOverride: ne.generic.components([
        ne.generic.unit,
        ne.generic.unit,
        ne.generic.unit,
        ne.generic.unit
      ]),
      components: [
        "margin-top",
        "margin-right",
        "margin-bottom",
        "margin-left"
      ],
      defaultValue: "0",
      propertyOptimizer: en.margin,
      restore: Zi.fourValues,
      shorthand: !0,
      valueOptimizers: [
        L.whiteSpace,
        L.fraction,
        L.precision,
        L.unit,
        L.zero
      ]
    },
    "margin-bottom": {
      canOverride: ne.generic.unit,
      componentOf: [
        "margin"
      ],
      defaultValue: "0",
      oppositeTo: "margin-top",
      propertyOptimizer: en.margin,
      valueOptimizers: [
        L.whiteSpace,
        L.fraction,
        L.precision,
        L.unit,
        L.zero
      ]
    },
    "margin-inline-end": {
      valueOptimizers: [
        L.whiteSpace,
        L.fraction,
        L.precision,
        L.unit,
        L.zero
      ]
    },
    "margin-inline-start": {
      valueOptimizers: [
        L.whiteSpace,
        L.fraction,
        L.precision,
        L.unit,
        L.zero
      ]
    },
    "margin-left": {
      canOverride: ne.generic.unit,
      componentOf: [
        "margin"
      ],
      defaultValue: "0",
      oppositeTo: "margin-right",
      propertyOptimizer: en.margin,
      valueOptimizers: [
        L.whiteSpace,
        L.fraction,
        L.precision,
        L.unit,
        L.zero
      ]
    },
    "margin-right": {
      canOverride: ne.generic.unit,
      componentOf: [
        "margin"
      ],
      defaultValue: "0",
      oppositeTo: "margin-left",
      propertyOptimizer: en.margin,
      valueOptimizers: [
        L.whiteSpace,
        L.fraction,
        L.precision,
        L.unit,
        L.zero
      ]
    },
    "margin-top": {
      canOverride: ne.generic.unit,
      componentOf: [
        "margin"
      ],
      defaultValue: "0",
      oppositeTo: "margin-bottom",
      propertyOptimizer: en.margin,
      valueOptimizers: [
        L.whiteSpace,
        L.fraction,
        L.precision,
        L.unit,
        L.zero
      ]
    },
    "max-height": {
      canOverride: ne.generic.unit,
      defaultValue: "none",
      shortestValue: "0",
      valueOptimizers: [
        L.whiteSpace,
        L.fraction,
        L.precision,
        L.unit,
        L.zero
      ]
    },
    "max-width": {
      canOverride: ne.generic.unit,
      defaultValue: "none",
      shortestValue: "0",
      valueOptimizers: [
        L.whiteSpace,
        L.fraction,
        L.precision,
        L.unit,
        L.zero
      ]
    },
    "min-height": {
      canOverride: ne.generic.unit,
      defaultValue: "0",
      shortestValue: "0",
      valueOptimizers: [
        L.whiteSpace,
        L.fraction,
        L.precision,
        L.unit,
        L.zero
      ]
    },
    "min-width": {
      canOverride: ne.generic.unit,
      defaultValue: "0",
      shortestValue: "0",
      valueOptimizers: [
        L.whiteSpace,
        L.fraction,
        L.precision,
        L.unit,
        L.zero
      ]
    },
    opacity: {
      valueOptimizers: [
        L.fraction,
        L.precision
      ]
    },
    outline: {
      canOverride: ne.generic.components([
        ne.generic.color,
        ne.property.outlineStyle,
        ne.generic.unit
      ]),
      components: [
        "outline-color",
        "outline-style",
        "outline-width"
      ],
      breakUp: Qi.outline,
      restore: Zi.withoutDefaults,
      defaultValue: "0",
      propertyOptimizer: en.outline,
      shorthand: !0,
      valueOptimizers: [
        L.whiteSpace,
        L.fraction,
        L.precision,
        L.unit,
        L.zero
      ]
    },
    "outline-color": {
      canOverride: ne.generic.color,
      componentOf: [
        "outline"
      ],
      defaultValue: "invert",
      shortestValue: "red",
      valueOptimizers: [
        L.whiteSpace,
        L.fraction,
        L.color
      ]
    },
    "outline-style": {
      canOverride: ne.property.outlineStyle,
      componentOf: [
        "outline"
      ],
      defaultValue: "none"
    },
    "outline-width": {
      canOverride: ne.generic.unit,
      componentOf: [
        "outline"
      ],
      defaultValue: "medium",
      shortestValue: "0",
      valueOptimizers: [
        L.whiteSpace,
        L.fraction,
        L.precision,
        L.unit,
        L.zero
      ]
    },
    overflow: {
      canOverride: ne.property.overflow,
      defaultValue: "visible"
    },
    "overflow-x": {
      canOverride: ne.property.overflow,
      defaultValue: "visible"
    },
    "overflow-y": {
      canOverride: ne.property.overflow,
      defaultValue: "visible"
    },
    padding: {
      breakUp: Qi.fourValues,
      canOverride: ne.generic.components([
        ne.generic.unit,
        ne.generic.unit,
        ne.generic.unit,
        ne.generic.unit
      ]),
      components: [
        "padding-top",
        "padding-right",
        "padding-bottom",
        "padding-left"
      ],
      defaultValue: "0",
      propertyOptimizer: en.padding,
      restore: Zi.fourValues,
      shorthand: !0,
      valueOptimizers: [
        L.whiteSpace,
        L.fraction,
        L.precision,
        L.unit,
        L.zero
      ]
    },
    "padding-bottom": {
      canOverride: ne.generic.unit,
      componentOf: [
        "padding"
      ],
      defaultValue: "0",
      oppositeTo: "padding-top",
      propertyOptimizer: en.padding,
      valueOptimizers: [
        L.whiteSpace,
        L.fraction,
        L.precision,
        L.unit,
        L.zero
      ]
    },
    "padding-left": {
      canOverride: ne.generic.unit,
      componentOf: [
        "padding"
      ],
      defaultValue: "0",
      oppositeTo: "padding-right",
      propertyOptimizer: en.padding,
      valueOptimizers: [
        L.whiteSpace,
        L.fraction,
        L.precision,
        L.unit,
        L.zero
      ]
    },
    "padding-right": {
      canOverride: ne.generic.unit,
      componentOf: [
        "padding"
      ],
      defaultValue: "0",
      oppositeTo: "padding-left",
      propertyOptimizer: en.padding,
      valueOptimizers: [
        L.whiteSpace,
        L.fraction,
        L.precision,
        L.unit,
        L.zero
      ]
    },
    "padding-top": {
      canOverride: ne.generic.unit,
      componentOf: [
        "padding"
      ],
      defaultValue: "0",
      oppositeTo: "padding-bottom",
      propertyOptimizer: en.padding,
      valueOptimizers: [
        L.whiteSpace,
        L.fraction,
        L.precision,
        L.unit,
        L.zero
      ]
    },
    position: {
      canOverride: ne.property.position,
      defaultValue: "static"
    },
    right: {
      canOverride: ne.property.right,
      defaultValue: "auto",
      valueOptimizers: [
        L.whiteSpace,
        L.fraction,
        L.precision,
        L.unit,
        L.zero
      ]
    },
    "row-gap": {
      valueOptimizers: [
        L.whiteSpace,
        L.fraction,
        L.precision,
        L.unit,
        L.zero
      ]
    },
    src: {
      valueOptimizers: [
        L.urlWhiteSpace,
        L.urlPrefix,
        L.urlQuotes
      ]
    },
    "stroke-width": {
      valueOptimizers: [
        L.whiteSpace,
        L.fraction,
        L.precision,
        L.unit,
        L.zero
      ]
    },
    "text-align": {
      canOverride: ne.property.textAlign,
      // NOTE: we can't tell the real default value here, as it depends on default text direction
      // this is a hack, but it doesn't matter because this value will be either overridden or
      // it will disappear anyway
      defaultValue: "left|right"
    },
    "text-decoration": {
      canOverride: ne.property.textDecoration,
      defaultValue: "none"
    },
    "text-indent": {
      canOverride: ne.property.textOverflow,
      defaultValue: "none",
      valueOptimizers: [
        L.fraction,
        L.zero
      ]
    },
    "text-overflow": {
      canOverride: ne.property.textOverflow,
      defaultValue: "none"
    },
    "text-shadow": {
      canOverride: ne.property.textShadow,
      defaultValue: "none",
      valueOptimizers: [
        L.whiteSpace,
        L.fraction,
        L.zero,
        L.color
      ]
    },
    top: {
      canOverride: ne.property.top,
      defaultValue: "auto",
      valueOptimizers: [
        L.whiteSpace,
        L.fraction,
        L.precision,
        L.unit,
        L.zero
      ]
    },
    transform: {
      canOverride: ne.property.transform,
      valueOptimizers: [
        L.whiteSpace,
        L.degrees,
        L.fraction,
        L.precision,
        L.unit,
        L.zero
      ],
      vendorPrefixes: [
        "-moz-",
        "-ms-",
        "-o-",
        "-webkit-"
      ]
    },
    transition: {
      breakUp: Qi.multiplex(Qi.transition),
      canOverride: ne.generic.components([
        ne.property.transitionProperty,
        ne.generic.time,
        ne.generic.timingFunction,
        ne.generic.time
      ]),
      components: [
        "transition-property",
        "transition-duration",
        "transition-timing-function",
        "transition-delay"
      ],
      defaultValue: "none",
      restore: Zi.multiplex(Zi.withoutDefaults),
      shorthand: !0,
      valueOptimizers: [
        L.time,
        L.fraction
      ],
      vendorPrefixes: [
        "-moz-",
        "-ms-",
        "-o-",
        "-webkit-"
      ]
    },
    "transition-delay": {
      canOverride: ne.generic.time,
      componentOf: [
        "transition"
      ],
      defaultValue: "0s",
      intoMultiplexMode: "real",
      valueOptimizers: [
        L.time
      ],
      vendorPrefixes: [
        "-moz-",
        "-ms-",
        "-o-",
        "-webkit-"
      ]
    },
    "transition-duration": {
      canOverride: ne.generic.time,
      componentOf: [
        "transition"
      ],
      defaultValue: "0s",
      intoMultiplexMode: "real",
      keepUnlessDefault: "transition-delay",
      valueOptimizers: [
        L.time,
        L.fraction
      ],
      vendorPrefixes: [
        "-moz-",
        "-ms-",
        "-o-",
        "-webkit-"
      ]
    },
    "transition-property": {
      canOverride: ne.generic.propertyName,
      componentOf: [
        "transition"
      ],
      defaultValue: "all",
      intoMultiplexMode: "placeholder",
      placeholderValue: "_",
      // it's a short value that won't match any property and still be a valid `transition-property`
      vendorPrefixes: [
        "-moz-",
        "-ms-",
        "-o-",
        "-webkit-"
      ]
    },
    "transition-timing-function": {
      canOverride: ne.generic.timingFunction,
      componentOf: [
        "transition"
      ],
      defaultValue: "ease",
      intoMultiplexMode: "real",
      vendorPrefixes: [
        "-moz-",
        "-ms-",
        "-o-",
        "-webkit-"
      ]
    },
    "vertical-align": {
      canOverride: ne.property.verticalAlign,
      defaultValue: "baseline",
      valueOptimizers: [
        L.whiteSpace,
        L.fraction,
        L.precision,
        L.unit,
        L.zero
      ]
    },
    visibility: {
      canOverride: ne.property.visibility,
      defaultValue: "visible"
    },
    "-webkit-tap-highlight-color": {
      valueOptimizers: [
        L.whiteSpace,
        L.color
      ]
    },
    "-webkit-margin-end": {
      valueOptimizers: [
        L.whiteSpace,
        L.fraction,
        L.precision,
        L.unit,
        L.zero
      ]
    },
    "white-space": {
      canOverride: ne.property.whiteSpace,
      defaultValue: "normal"
    },
    width: {
      canOverride: ne.generic.unit,
      defaultValue: "auto",
      shortestValue: "0",
      valueOptimizers: [
        L.whiteSpace,
        L.fraction,
        L.precision,
        L.unit,
        L.zero
      ]
    },
    "z-index": {
      canOverride: ne.property.zIndex,
      defaultValue: "auto"
    }
  }, nQ = {};
  function rrt(e, t) {
    var r = iQ(lS[e], {});
    return "componentOf" in r && (r.componentOf = r.componentOf.map(function(i) {
      return t + i;
    })), "components" in r && (r.components = r.components.map(function(i) {
      return t + i;
    })), "keepUnlessDefault" in r && (r.keepUnlessDefault = t + r.keepUnlessDefault), r;
  }
  s(rrt, "cloneDescriptor");
  for (oS in lS)
    if (Tm = lS[oS], "vendorPrefixes" in Tm) {
      for (uS = 0; uS < Tm.vendorPrefixes.length; uS++)
        J2 = Tm.vendorPrefixes[uS], Q2 = rrt(oS, J2), delete Q2.vendorPrefixes, nQ[J2 + oS] = Q2;
      delete Tm.vendorPrefixes;
    }
  var Tm, J2, Q2, uS, oS;
  sQ.exports = iQ(lS, nQ);
});

// ../node_modules/clean-css/lib/writer/helpers.js
var cS = b((yFt, fQ) => {
  var qp = "", En = hm().Breaks, aQ = hm().Spaces, An = Ln(), Vs = ui();
  function irt(e) {
    return e[1][1] == "background" || e[1][1] == "transform" || e[1][1] == "src";
  }
  s(irt, "supportsAfterClosingBrace");
  function nrt(e, t) {
    return e[t][1][e[t][1].length - 1] == An.CLOSE_ROUND_BRACKET;
  }
  s(nrt, "afterClosingBrace");
  function srt(e, t) {
    return e[t][1] == An.COMMA;
  }
  s(srt, "afterComma");
  function art(e, t) {
    return e[t][1] == An.FORWARD_SLASH;
  }
  s(art, "afterSlash");
  function ort(e, t) {
    return e[t + 1] && e[t + 1][1] == An.COMMA;
  }
  s(ort, "beforeComma");
  function urt(e, t) {
    return e[t + 1] && e[t + 1][1] == An.FORWARD_SLASH;
  }
  s(urt, "beforeSlash");
  function lrt(e) {
    return e[1][1] == "filter" || e[1][1] == "-ms-filter";
  }
  s(lrt, "inFilter");
  function crt(e, t, r) {
    return !e.spaceAfterClosingBrace && irt(t) && nrt(t, r) || urt(t, r) || art(t, r) || ort(t, r) || srt(t, r);
  }
  s(crt, "disallowsSpace");
  function Em(e, t) {
    for (var r = e.store, i = 0, n = t.length; i < n; i++)
      r(e, t[i]), i < n - 1 && r(e, hrt(e));
  }
  s(Em, "rules");
  function Cm(e, t) {
    for (var r = frt(t), i = 0, n = t.length; i < n; i++)
      oQ(e, t, i, r);
  }
  s(Cm, "body");
  function frt(e) {
    for (var t = e.length - 1; t >= 0 && e[t][0] == Vs.COMMENT; t--)
      ;
    return t;
  }
  s(frt, "lastPropertyIndex");
  function oQ(e, t, r, i) {
    var n = e.store, a = t[r], o = a[2], u = o && o[0] === Vs.PROPERTY_BLOCK, l;
    e.format ? e.format.semicolonAfterLastProperty || u || r < i ? l = !0 : l = !1 : l = r < i || u;
    var c = r === i;
    switch (a[0]) {
      case Vs.AT_RULE:
        n(e, a), n(e, Z2(e, En.AfterProperty, !1));
        break;
      case Vs.AT_RULE_BLOCK:
        Em(e, a[1]), n(e, Am(e, En.AfterRuleBegins, !0)), Cm(e, a[2]), n(e, xm(e, En.AfterRuleEnds, !1, c));
        break;
      case Vs.COMMENT:
        n(e, a), n(e, Pl(e, En.AfterComment) + e.indentWith);
        break;
      case Vs.PROPERTY:
        n(e, a[1]), n(e, prt(e)), o && uQ(e, a), n(
          e,
          l ? Z2(e, En.AfterProperty, c) : qp
        );
        break;
      case Vs.RAW:
        n(e, a);
    }
  }
  s(oQ, "property");
  function uQ(e, t) {
    var r = e.store, i, n;
    if (t[2][0] == Vs.PROPERTY_BLOCK)
      r(e, Am(e, En.AfterBlockBegins, !1)), Cm(e, t[2][1]), r(e, xm(e, En.AfterBlockEnds, !1, !0));
    else
      for (i = 2, n = t.length; i < n; i++)
        r(e, t[i]), i < n - 1 && (lrt(t) || !crt(e, t, i)) && r(e, An.SPACE);
  }
  s(uQ, "value");
  function Pl(e, t) {
    return e.format ? e.format.breaks[t] : qp;
  }
  s(Pl, "breakFor");
  function lQ(e, t) {
    return e.format && e.format.spaces[t];
  }
  s(lQ, "allowsSpace");
  function Am(e, t, r) {
    return e.format ? (e.indentBy += e.format.indentBy, e.indentWith = e.format.indentWith.repeat(e.indentBy), (r && lQ(e, aQ.BeforeBlockBegins) ?
    An.SPACE : qp) + An.OPEN_CURLY_BRACKET + Pl(e, t) + e.indentWith) : An.OPEN_CURLY_BRACKET;
  }
  s(Am, "openBrace");
  function xm(e, t, r, i) {
    return e.format ? (e.indentBy -= e.format.indentBy, e.indentWith = e.format.indentWith.repeat(e.indentBy), (r ? Pl(e, En.BeforeBlockEnds) :
    Pl(e, En.AfterProperty)) + e.indentWith + An.CLOSE_CURLY_BRACKET + (i ? qp : Pl(e, t) + e.indentWith)) : An.CLOSE_CURLY_BRACKET;
  }
  s(xm, "closeBrace");
  function prt(e) {
    return e.format ? An.COLON + (lQ(e, aQ.BeforeValue) ? An.SPACE : qp) : An.COLON;
  }
  s(prt, "colon");
  function Z2(e, t, r) {
    return e.format ? An.SEMICOLON + (r ? qp : Pl(e, t) + e.indentWith) : An.SEMICOLON;
  }
  s(Z2, "semicolon");
  function hrt(e) {
    return e.format ? An.COMMA + Pl(e, En.BetweenSelectors) + e.indentWith : An.COMMA;
  }
  s(hrt, "comma");
  function cQ(e, t) {
    var r = e.store, i, n, a, o;
    for (a = 0, o = t.length; a < o; a++)
      switch (i = t[a], n = a == o - 1, i[0]) {
        case Vs.AT_RULE:
          r(e, i), r(e, Z2(e, En.AfterAtRule, n));
          break;
        case Vs.AT_RULE_BLOCK:
          Em(e, i[1]), r(e, Am(e, En.AfterRuleBegins, !0)), Cm(e, i[2]), r(e, xm(e, En.AfterRuleEnds, !1, n));
          break;
        case Vs.NESTED_BLOCK:
          Em(e, i[1]), r(e, Am(e, En.AfterBlockBegins, !0)), cQ(e, i[2]), r(e, xm(e, En.AfterBlockEnds, !0, n));
          break;
        case Vs.COMMENT:
          r(e, i), r(e, Pl(e, En.AfterComment) + e.indentWith);
          break;
        case Vs.RAW:
          r(e, i);
          break;
        case Vs.RULE:
          Em(e, i[1]), r(e, Am(e, En.AfterRuleBegins, !0)), Cm(e, i[2]), r(e, xm(e, En.AfterRuleEnds, !1, n));
          break;
      }
  }
  s(cQ, "all");
  fQ.exports = {
    all: cQ,
    body: Cm,
    property: oQ,
    rules: Em,
    value: uQ
  };
});

// ../node_modules/clean-css/lib/writer/one-time.js
var Hi = b((_Ft, pQ) => {
  var Pm = cS();
  function drt(e, t) {
    e.output.push(typeof t == "string" ? t : t[1]);
  }
  s(drt, "store");
  function Dm() {
    var e = {
      output: [],
      store: drt
    };
    return e;
  }
  s(Dm, "context");
  function mrt(e) {
    var t = Dm();
    return Pm.all(t, e), t.output.join("");
  }
  s(mrt, "all");
  function yrt(e) {
    var t = Dm();
    return Pm.body(t, e), t.output.join("");
  }
  s(yrt, "body");
  function grt(e, t) {
    var r = Dm();
    return Pm.property(r, e, t, !0), r.output.join("");
  }
  s(grt, "property");
  function _rt(e) {
    var t = Dm();
    return Pm.rules(t, e), t.output.join("");
  }
  s(_rt, "rules");
  function brt(e) {
    var t = Dm();
    return Pm.value(t, e), t.output.join("");
  }
  s(brt, "value");
  pQ.exports = {
    all: mrt,
    body: yrt,
    property: grt,
    rules: _rt,
    value: brt
  };
});

// ../node_modules/clean-css/lib/optimizer/level-1/optimize.js
var gQ = b((vFt, yQ) => {
  var vrt = Wv(), Srt = Yv(), Trt = bY(), Ert = SY(), fS = Jv(), Art = B2(), xrt = Rp(), Crt = Fc().all, pS = Ou(), eO = Y2(), dS = Ki().OptimizationLevel,
  Ho = ui(), Prt = Ln(), hS = dm(), Drt = Hi().rules, tO = "@charset", hQ = new RegExp("^" + tO, "i"), wrt = G2().DEFAULT, Ort = /^--\S+$/, krt = /^(?:-chrome-|-[\w-]+\w|\w[\w-]+\w|\w{1,})$/,
  Irt = /^@import/i, Rrt = /^url\(/i;
  function Nrt(e) {
    return Rrt.test(e);
  }
  s(Nrt, "startsAsUrl");
  function Lrt(e) {
    return Irt.test(e[1]);
  }
  s(Lrt, "isImport");
  function Frt(e) {
    var t;
    return e.name == "filter" || e.name == "-ms-filter" ? (t = e.value[0][1], t.indexOf("progid") > -1 || t.indexOf("alpha") === 0 || t.indexOf(
    "chroma") === 0) : !1;
  }
  s(Frt, "isLegacyFilter");
  function Mrt() {
  }
  s(Mrt, "noop");
  function Brt(e, t, r) {
    return t;
  }
  s(Brt, "noopValueOptimizer");
  function rO(e, t, r) {
    var i = r.options, n, a, o, u, l, c, p, h = Drt(e), y = Crt(t), _ = r.options.plugins.level1Value, g = r.options.plugins.level1Property,
    m, f, d;
    for (f = 0, d = y.length; f < d; f++) {
      var v, E, S, x;
      if (a = y[f], o = a.name, p = pS[o] && pS[o].propertyOptimizer || Mrt, n = pS[o] && pS[o].valueOptimizers || [eO.whiteSpace], m = Ort.
      test(o), m && (n = i.variableOptimizers.length > 0 ? i.variableOptimizers : [eO.whiteSpace]), !m && !krt.test(o)) {
        c = a.all[a.position], r.warnings.push("Invalid property name '" + o + "' at " + hS(c[1][2][0]) + ". Ignoring."), a.unused = !0;
        continue;
      }
      if (a.value.length === 0) {
        c = a.all[a.position], r.warnings.push("Empty property '" + o + "' at " + hS(c[1][2][0]) + ". Ignoring."), a.unused = !0;
        continue;
      }
      if (a.hack && ((a.hack[0] == fS.ASTERISK || a.hack[0] == fS.UNDERSCORE) && !i.compatibility.properties.iePrefixHack || a.hack[0] == fS.
      BACKSLASH && !i.compatibility.properties.ieSuffixHack || a.hack[0] == fS.BANG && !i.compatibility.properties.ieBangHack)) {
        a.unused = !0;
        continue;
      }
      if (!i.compatibility.properties.ieFilters && Frt(a)) {
        a.unused = !0;
        continue;
      }
      if (a.block) {
        rO(e, a.value[0][1], r);
        continue;
      }
      for (v = 0, S = a.value.length; v < S; v++) {
        if (u = a.value[v][0], l = a.value[v][1], u == Ho.PROPERTY_BLOCK) {
          a.unused = !0, r.warnings.push("Invalid value token at " + hS(l[0][1][2][0]) + ". Ignoring.");
          break;
        }
        if (Nrt(l) && !r.validator.isUrl(l)) {
          a.unused = !0, r.warnings.push("Broken URL '" + l + "' at " + hS(a.value[v][2][0]) + ". Ignoring.");
          break;
        }
        for (E = 0, x = n.length; E < x; E++)
          l = n[E](o, l, i);
        for (E = 0, x = _.length; E < x; E++)
          l = _[E](o, l, i);
        a.value[v][1] = l;
      }
      for (p(h, a, i), v = 0, S = g.length; v < S; v++)
        g[v](h, a, i);
    }
    xrt(y), Art(y), qrt(t, i);
  }
  s(rO, "optimizeBody");
  function qrt(e, t) {
    var r, i;
    for (i = 0; i < e.length; i++)
      r = e[i], r[0] == Ho.COMMENT && (dQ(r, t), r[1].length === 0 && (e.splice(i, 1), i--));
  }
  s(qrt, "removeComments");
  function dQ(e, t) {
    if (e[1][2] == Prt.EXCLAMATION && (t.level[dS.One].specialComments == "all" || t.commentsKept < t.level[dS.One].specialComments)) {
      t.commentsKept++;
      return;
    }
    e[1] = [];
  }
  s(dQ, "optimizeComment");
  function Urt(e) {
    for (var t = !1, r = 0, i = e.length; r < i; r++) {
      var n = e[r];
      n[0] == Ho.AT_RULE && hQ.test(n[1]) && (t || n[1].indexOf(tO) == -1 ? (e.splice(r, 1), r--, i--) : (t = !0, e.splice(r, 1), e.unshift(
      [Ho.AT_RULE, n[1].replace(hQ, tO)])));
    }
  }
  s(Urt, "cleanupCharsets");
  function jrt(e) {
    var t = ["px", "em", "ex", "cm", "mm", "in", "pt", "pc", "%"], r = ["ch", "rem", "vh", "vm", "vmax", "vmin", "vw"];
    return r.forEach(function(i) {
      e.compatibility.units[i] && t.push(i);
    }), new RegExp("(^|\\s|\\(|,)0(?:" + t.join("|") + ")(\\W|$)", "g");
  }
  s(jrt, "buildUnitRegexp");
  function Vrt(e) {
    var t = {
      matcher: null,
      units: {}
    }, r = [], i, n;
    for (i in e)
      n = e[i], n != wrt && (t.units[i] = {}, t.units[i].value = n, t.units[i].multiplier = 10 ** n, r.push(i));
    return r.length > 0 && (t.enabled = !0, t.decimalPointMatcher = new RegExp("(\\d)\\.($|" + r.join("|") + ")($|\\W)", "g"), t.zeroMatcher =
    new RegExp("(\\d*)(\\.\\d+)(" + r.join("|") + ")", "g")), t;
  }
  s(Vrt, "buildPrecisionOptions");
  function Krt(e) {
    return e.level[dS.One].variableValueOptimizers.map(function(t) {
      return typeof t == "string" ? eO[t] || Brt : t;
    });
  }
  s(Krt, "buildVariableOptimizers");
  function mQ(e, t) {
    var r = t.options, i = r.level[dS.One], n = r.compatibility.selectors.ie7Hack, a = r.compatibility.selectors.adjacentSpace, o = r.compatibility.
    properties.spaceAfterClosingBrace, u = r.format, l = !1, c = !1;
    r.unitsRegexp = r.unitsRegexp || jrt(r), r.precision = r.precision || Vrt(i.roundingPrecision), r.commentsKept = r.commentsKept || 0, r.
    variableOptimizers = r.variableOptimizers || Krt(r);
    for (var p = 0, h = e.length; p < h; p++) {
      var y = e[p];
      switch (y[0]) {
        case Ho.AT_RULE:
          y[1] = Lrt(y) && c ? "" : y[1], y[1] = i.tidyAtRules ? Ert(y[1]) : y[1], l = !0;
          break;
        case Ho.AT_RULE_BLOCK:
          rO(y[1], y[2], t), c = !0;
          break;
        case Ho.NESTED_BLOCK:
          y[1] = i.tidyBlockScopes ? Trt(y[1], o) : y[1], mQ(y[2], t), c = !0;
          break;
        case Ho.COMMENT:
          dQ(y, r);
          break;
        case Ho.RULE:
          y[1] = i.tidySelectors ? Srt(y[1], !n, a, u, t.warnings) : y[1], y[1] = y[1].length > 1 ? vrt(y[1], i.selectorsSortingMethod) : y[1],
          rO(y[1], y[2], t), c = !0;
          break;
      }
      (y[0] == Ho.COMMENT && y[1].length === 0 || i.removeEmpty && (y[1].length === 0 || y[2] && y[2].length === 0)) && (e.splice(p, 1), p--,
      h--);
    }
    return i.cleanupCharsets && l && Urt(e), e;
  }
  s(mQ, "level1Optimize");
  yQ.exports = mQ;
});

// ../node_modules/clean-css/lib/optimizer/level-2/is-mergeable.js
var wm = b((TFt, vQ) => {
  var zi = Ln(), Hrt = Bp(), zrt = /\/deep\//, Grt = /^::/, Wrt = /:(-moz-|-ms-|-o-|-webkit-)/, _Q = ":not", bQ = [
    ":dir",
    ":lang",
    ":not",
    ":nth-child",
    ":nth-last-child",
    ":nth-last-of-type",
    ":nth-of-type"
  ], $rt = /[>+~]/, Xrt = [
    ":after",
    ":before",
    ":first-letter",
    ":first-line",
    ":lang"
  ], Yrt = [
    "::after",
    "::before",
    "::first-letter",
    "::first-line"
  ], io = {
    DOUBLE_QUOTE: "double-quote",
    SINGLE_QUOTE: "single-quote",
    ROOT: "root"
  };
  function Jrt(e, t, r, i) {
    var n = Hrt(e, zi.COMMA), a, o, u;
    for (o = 0, u = n.length; o < u; o++)
      if (a = n[o], a.length === 0 || Qrt(a) || Zrt(a) || a.indexOf(zi.COLON) > -1 && !tit(
        a,
        eit(a),
        t,
        r,
        i
      ))
        return !1;
    return !0;
  }
  s(Jrt, "isMergeable");
  function Qrt(e) {
    return zrt.test(e);
  }
  s(Qrt, "isDeepSelector");
  function Zrt(e) {
    return Wrt.test(e);
  }
  s(Zrt, "isVendorPrefixed");
  function eit(e) {
    var t = [], r, i = [], n = io.ROOT, a = 0, o, u, l = !1, c, p = !1, h, y;
    for (h = 0, y = e.length; h < y; h++)
      r = e[h], c = !u && $rt.test(r), o = n == io.DOUBLE_QUOTE || n == io.SINGLE_QUOTE, u ? i.push(r) : r == zi.DOUBLE_QUOTE && n == io.ROOT ?
      (i.push(r), n = io.DOUBLE_QUOTE) : r == zi.DOUBLE_QUOTE && n == io.DOUBLE_QUOTE ? (i.push(r), n = io.ROOT) : r == zi.SINGLE_QUOTE && n ==
      io.ROOT ? (i.push(r), n = io.SINGLE_QUOTE) : r == zi.SINGLE_QUOTE && n == io.SINGLE_QUOTE ? (i.push(r), n = io.ROOT) : o ? i.push(r) :
      r == zi.OPEN_ROUND_BRACKET ? (i.push(r), a++) : r == zi.CLOSE_ROUND_BRACKET && a == 1 && l ? (i.push(r), t.push(i.join("")), a--, i = [],
      l = !1) : r == zi.CLOSE_ROUND_BRACKET ? (i.push(r), a--) : r == zi.COLON && a === 0 && l && !p ? (t.push(i.join("")), i = [], i.push(r)) :
      r == zi.COLON && a === 0 && !p ? (i = [], i.push(r), l = !0) : r == zi.SPACE && a === 0 && l ? (t.push(i.join("")), i = [], l = !1) : c &&
      a === 0 && l ? (t.push(i.join("")), i = [], l = !1) : i.push(r), u = r == zi.BACK_SLASH, p = r == zi.COLON;
    return i.length > 0 && l && t.push(i.join("")), t;
  }
  s(eit, "extractPseudoFrom");
  function tit(e, t, r, i, n) {
    return rit(t, r, i) && iit(t) && (t.length < 2 || !nit(e, t)) && (t.length < 2 || n && sit(t));
  }
  s(tit, "areMergeable");
  function rit(e, t, r) {
    var i, n, a, o;
    for (a = 0, o = e.length; a < o; a++)
      if (i = e[a], n = i.indexOf(zi.OPEN_ROUND_BRACKET) > -1 ? i.substring(0, i.indexOf(zi.OPEN_ROUND_BRACKET)) : i, t.indexOf(n) === -1 &&
      r.indexOf(n) === -1)
        return !1;
    return !0;
  }
  s(rit, "areAllowed");
  function iit(e) {
    var t, r, i, n, a, o;
    for (a = 0, o = e.length; a < o; a++)
      if (t = e[a], i = t.indexOf(zi.OPEN_ROUND_BRACKET), n = i > -1, r = n ? t.substring(0, i) : t, n && bQ.indexOf(r) == -1 || !n && bQ.indexOf(
      r) > -1)
        return !1;
    return !0;
  }
  s(iit, "needArguments");
  function nit(e, t) {
    var r = 0, i, n, a, o, u, l, c, p, h;
    for (p = 0, h = t.length; p < h && (i = t[p], a = t[p + 1], !!a); p++)
      if (n = e.indexOf(i, r), o = e.indexOf(i, n + 1), r = o, c = n + i.length == o, c && (u = i.indexOf(zi.OPEN_ROUND_BRACKET) > -1 ? i.substring(
      0, i.indexOf(zi.OPEN_ROUND_BRACKET)) : i, l = a.indexOf(zi.OPEN_ROUND_BRACKET) > -1 ? a.substring(0, a.indexOf(zi.OPEN_ROUND_BRACKET)) :
      a, u != _Q || l != _Q))
        return !0;
    return !1;
  }
  s(nit, "someIncorrectlyChained");
  function sit(e) {
    var t = 0, r, i, n;
    for (i = 0, n = e.length; i < n; i++)
      if (r = e[i], ait(r) ? t += Yrt.indexOf(r) > -1 ? 1 : 0 : t += Xrt.indexOf(r) > -1 ? 1 : 0, t > 1)
        return !1;
    return !0;
  }
  s(sit, "allMixable");
  function ait(e) {
    return Grt.test(e);
  }
  s(ait, "isPseudoElement");
  vQ.exports = Jrt;
});

// ../node_modules/clean-css/lib/optimizer/level-2/properties/every-values-pair.js
var iO = b((AFt, TQ) => {
  var SQ = Ln();
  function oit(e, t, r) {
    var i = t.value.length, n = r.value.length, a = Math.max(i, n), o = Math.min(i, n) - 1, u, l, c;
    for (c = 0; c < a; c++)
      if (u = t.value[c] && t.value[c][1] || u, l = r.value[c] && r.value[c][1] || l, !(u == SQ.COMMA || l == SQ.COMMA) && !e(u, l, c, c <= o))
        return !1;
    return !0;
  }
  s(oit, "everyValuesPair");
  TQ.exports = oit;
});

// ../node_modules/clean-css/lib/optimizer/level-2/properties/has-inherit.js
var nO = b((CFt, EQ) => {
  function uit(e) {
    for (var t = e.value.length - 1; t >= 0; t--)
      if (e.value[t][1] == "inherit")
        return !0;
    return !1;
  }
  s(uit, "hasInherit");
  EQ.exports = uit;
});

// ../node_modules/clean-css/lib/optimizer/level-2/properties/has-same-values.js
var xQ = b((DFt, AQ) => {
  function lit(e) {
    var t = e.value[0][1], r, i;
    for (r = 1, i = e.value.length; r < i; r++)
      if (e.value[r][1] != t)
        return !1;
    return !0;
  }
  s(lit, "hasSameValues");
  AQ.exports = lit;
});

// ../node_modules/clean-css/lib/optimizer/level-2/properties/populate-components.js
var yS = b((OFt, CQ) => {
  var mS = Ou(), cit = q2();
  function fit(e, t, r) {
    for (var i, n, a, o = e.length - 1; o >= 0; o--) {
      var u = e[o], l = mS[u.name];
      if (!u.dynamic && l && l.shorthand) {
        if (pit(u, t) || hit(u, t)) {
          u.optimizable = !1;
          continue;
        }
        u.shorthand = !0, u.dirty = !0;
        try {
          if (u.components = l.breakUp(u, mS, t), l.shorthandComponents)
            for (n = 0, a = u.components.length; n < a; n++)
              i = u.components[n], i.components = mS[i.name].breakUp(i, mS, t);
        } catch (c) {
          if (c instanceof cit)
            u.components = [], r.push(c.message);
          else
            throw c;
        }
        u.components.length > 0 ? u.multiplex = u.components[0].multiplex : u.unused = !0;
      }
    }
  }
  s(fit, "populateComponents");
  function pit(e, t) {
    return e.value.length == 1 && t.isVariable(e.value[0][1]);
  }
  s(pit, "onlyValueIsVariable");
  function hit(e, t) {
    return e.value.length > 1 && e.value.filter(
      function(r) {
        return t.isVariable(r[1]);
      }
    ).length > 1;
  }
  s(hit, "moreThanOneValueIsVariable");
  CQ.exports = fit;
});

// ../node_modules/clean-css/lib/optimizer/level-2/restore-with-components.js
var gS = b((IFt, DQ) => {
  var PQ = Ou();
  function dit(e) {
    var t = PQ[e.name];
    return t && t.shorthand ? t.restore(e, PQ) : e.value;
  }
  s(dit, "restoreWithComponents");
  DQ.exports = dit;
});

// ../node_modules/clean-css/lib/optimizer/level-2/properties/merge-into-shorthands.js
var NQ = b((NFt, RQ) => {
  var mit = iO(), sO = nO(), yit = xQ(), _S = yS(), wa = Ou(), Om = gm().deep, kQ = gS(), IQ = Rp(), bS = Fc().single, wQ = Hi().body, na = ui();
  function git(e, t) {
    var r = {}, i, n, a, o, u, l, c;
    if (!(e.length < 3)) {
      for (o = 0, u = e.length; o < u; o++)
        if (a = e[o], i = wa[a.name], !a.dynamic && !a.unused && !a.hack && !a.block && !(i && i.singleTypeComponents && !yit(a)) && (OQ(e, o,
        r, t), i && i.componentOf))
          for (l = 0, c = i.componentOf.length; l < c; l++)
            n = i.componentOf[l], r[n] = r[n] || {}, r[n][a.name] = a;
      OQ(e, o, r, t);
    }
  }
  s(git, "mergeIntoShorthands");
  function OQ(e, t, r, i) {
    var n = e[t], a, o, u, l = [], c;
    for (a in r)
      if (!(n !== void 0 && a == n.name)) {
        if (o = wa[a], u = r[a], n && _it(r, a, n)) {
          delete r[a];
          continue;
        }
        o.components.length > Object.keys(u).length || bit(u) || vit(u, a, i) && Tit(u) && (Eit(u) ? Ait(e, u, a, i) : Oit(e, u, a, i), l.push(
        a));
      }
    for (c = l.length - 1; c >= 0; c--)
      delete r[l[c]];
  }
  s(OQ, "invalidateOrCompact");
  function _it(e, t, r) {
    var i = wa[t], n = wa[r.name], a;
    if ("overridesShorthands" in i && i.overridesShorthands.indexOf(r.name) > -1)
      return !0;
    if (n && "componentOf" in n) {
      for (a in e[t])
        if (n.componentOf.indexOf(a) > -1)
          return !0;
    }
    return !1;
  }
  s(_it, "invalidates");
  function bit(e) {
    var t, r;
    for (r in e) {
      if (t !== void 0 && e[r].important != t)
        return !0;
      t = e[r].important;
    }
    return !1;
  }
  s(bit, "mixedImportance");
  function vit(e, t, r) {
    var i = wa[t], n = [
      na.PROPERTY,
      [na.PROPERTY_NAME, t],
      [na.PROPERTY_VALUE, i.defaultValue]
    ], a = bS(n), o, u, l, c;
    for (_S([a], r, []), l = 0, c = i.components.length; l < c; l++)
      if (o = e[i.components[l]], u = wa[o.name].canOverride || Sit, !mit(u.bind(null, r), a.components[l], o))
        return !1;
    return !0;
  }
  s(vit, "overridable");
  function Sit(e, t, r) {
    return t === r;
  }
  s(Sit, "sameValue");
  function Tit(e) {
    var t = null, r, i, n, a, o;
    for (i in e)
      if (n = e[i], a = wa[i], "restore" in a) {
        if (IQ([n.all[n.position]], kQ), o = a.restore(n, wa), r = o.length, t !== null && r !== t)
          return !1;
        t = r;
      }
    return !0;
  }
  s(Tit, "mergeable");
  function Eit(e) {
    var t, r = null, i;
    for (t in e) {
      if (i = sO(e[t]), r !== null && r !== i)
        return !0;
      r = i;
    }
    return !1;
  }
  s(Eit, "mixedInherit");
  function Ait(e, t, r, i) {
    var n = xit(t, r, i), a = Dit(t, r, i), o = n[0], u = a[0], l = wQ(o).length < wQ(u).length, c = l ? o : u, p = l ? n[1] : a[1], h = l ?
    n[2] : a[2], y = t[Object.keys(t).pop()], _ = y.all, g = y.position, m, f, d, v;
    p.position = g, p.shorthand = !0, p.important = y.important, p.multiplex = !1, p.dirty = !0, p.all = _, p.all[g] = c[0], e.splice(g, 1, p);
    for (m in t)
      f = t[m], f.unused = !0, p.multiplex = p.multiplex || f.multiplex, f.name in h && (d = h[f.name], v = wit(c, m), d.position = _.length,
      d.all = _, d.all.push(v), e.push(d));
  }
  s(Ait, "replaceWithInheritBestFit");
  function xit(e, t, r) {
    var i = [], n = {}, a = {}, o = wa[t], u = [
      na.PROPERTY,
      [na.PROPERTY_NAME, t],
      [na.PROPERTY_VALUE, o.defaultValue]
    ], l = bS(u), c, p, h, y, _, g;
    for (_S([l], r, []), _ = 0, g = o.components.length; _ < g; _++)
      c = e[o.components[_]], sO(c) ? (p = c.all[c.position].slice(0, 2), Array.prototype.push.apply(p, c.value), i.push(p), h = Om(c), h.value =
      Cit(e, h.name), l.components[_] = h, n[c.name] = Om(c)) : (h = Om(c), h.all = c.all, l.components[_] = h, a[c.name] = c);
    return l.important = e[Object.keys(e).pop()].important, y = km(a, 1), u[1].push(y), IQ([l], kQ), u = u.slice(0, 2), Array.prototype.push.
    apply(u, l.value), i.unshift(u), [i, l, n];
  }
  s(xit, "buildSequenceWithInheritLonghands");
  function Cit(e, t) {
    var r = wa[t];
    return "oppositeTo" in r ? e[r.oppositeTo].value : [[na.PROPERTY_VALUE, r.defaultValue]];
  }
  s(Cit, "inferComponentValue");
  function km(e, t) {
    var r = [], i, n, a, o;
    for (o in e)
      i = e[o], n = i.all[i.position], a = n[t][n[t].length - 1], Array.prototype.push.apply(r, a);
    return r.sort(Pit);
  }
  s(km, "joinMetadata");
  function Pit(e, t) {
    var r = e[0], i = t[0], n = e[1], a = t[1];
    return r < i || r === i && n < a ? -1 : 1;
  }
  s(Pit, "metadataSorter");
  function Dit(e, t, r) {
    var i = [], n = {}, a = {}, o = wa[t], u = [
      na.PROPERTY,
      [na.PROPERTY_NAME, t],
      [na.PROPERTY_VALUE, "inherit"]
    ], l = bS(u), c, p, h, y, _, g;
    for (_S([l], r, []), _ = 0, g = o.components.length; _ < g; _++)
      c = e[o.components[_]], sO(c) ? n[c.name] = c : (p = c.all[c.position].slice(0, 2), Array.prototype.push.apply(p, c.value), i.push(p),
      a[c.name] = Om(c));
    return h = km(n, 1), u[1].push(h), y = km(n, 2), u[2].push(y), i.unshift(u), [i, l, a];
  }
  s(Dit, "buildSequenceWithInheritShorthand");
  function wit(e, t) {
    var r, i;
    for (r = 0, i = e.length; r < i; r++)
      if (e[r][1][1] == t)
        return e[r];
  }
  s(wit, "findTokenIn");
  function Oit(e, t, r, i) {
    var n = wa[r], a, o, u = [
      na.PROPERTY,
      [na.PROPERTY_NAME, r],
      [na.PROPERTY_VALUE, n.defaultValue]
    ], l, c = kit(e, t, r), p = bS(u);
    p.shorthand = !0, p.dirty = !0, p.multiplex = !1, _S([p], i, []);
    for (var h = 0, y = n.components.length; h < y; h++) {
      var _ = t[n.components[h]];
      p.components[h] = Om(_), p.important = _.important, p.multiplex = p.multiplex || _.multiplex, l = _.all;
    }
    for (var g in t)
      t[g].unused = !0;
    a = km(t, 1), u[1].push(a), o = km(t, 2), u[2].push(o), p.position = c, p.all = l, p.all[c] = u, e.splice(c, 1, p);
  }
  s(Oit, "replaceWithShorthand");
  function kit(e, t, r) {
    var i = Object.keys(t), n = t[i[0]].position, a = t[i[i.length - 1]].position;
    return r == "border" && Iit(e.slice(n, a), "border-image") ? n : a;
  }
  s(kit, "inferInsertAtFrom");
  function Iit(e, t) {
    for (var r = e.length - 1; r >= 0; r--)
      if (e[r].name == t)
        return !0;
    return !1;
  }
  s(Iit, "traversesVia");
  RQ.exports = git;
});

// ../node_modules/clean-css/lib/optimizer/level-2/properties/has-unset.js
var FQ = b((FFt, LQ) => {
  function Rit(e) {
    for (var t = e.value.length - 1; t >= 0; t--)
      if (e.value[t][1] == "unset")
        return !0;
    return !1;
  }
  s(Rit, "hasUnset");
  LQ.exports = Rit;
});

// ../node_modules/clean-css/lib/optimizer/level-2/properties/find-component-in.js
var qQ = b((BFt, BQ) => {
  var Nit = Ou();
  function Lit(e, t) {
    var r = Fit(t);
    return MQ(e, r) || Mit(e, r);
  }
  s(Lit, "findComponentIn");
  function Fit(e) {
    return function(t) {
      return e.name === t.name;
    };
  }
  s(Fit, "nameComparator");
  function MQ(e, t) {
    return e.components.filter(t)[0];
  }
  s(MQ, "findInDirectComponents");
  function Mit(e, t) {
    var r, i, n, a;
    if (Nit[e.name].shorthandComponents) {
      for (n = 0, a = e.components.length; n < a; n++)
        if (r = e.components[n], i = MQ(r, t), i)
          return i;
    }
  }
  s(Mit, "findInSubComponents");
  BQ.exports = Lit;
});

// ../node_modules/clean-css/lib/optimizer/level-2/properties/is-component-of.js
var KQ = b((UFt, VQ) => {
  var UQ = Ou();
  function Bit(e, t, r) {
    return jQ(e, t) || !r && !!UQ[e.name].shorthandComponents && qit(e, t);
  }
  s(Bit, "isComponentOf");
  function jQ(e, t) {
    var r = UQ[e.name];
    return "components" in r && r.components.indexOf(t.name) > -1;
  }
  s(jQ, "isDirectComponentOf");
  function qit(e, t) {
    return e.components.some(function(r) {
      return jQ(r, t);
    });
  }
  s(qit, "isSubComponentOf");
  VQ.exports = Bit;
});

// ../node_modules/clean-css/lib/optimizer/level-2/properties/is-mergeable-shorthand.js
var zQ = b((VFt, HQ) => {
  var Uit = Ln();
  function jit(e) {
    return e.name != "font" ? !0 : e.value[0][1].indexOf(Uit.INTERNAL) == -1;
  }
  s(jit, "isMergeableShorthand");
  HQ.exports = jit;
});

// ../node_modules/clean-css/lib/optimizer/level-2/properties/overrides-non-component-shorthand.js
var WQ = b((HFt, GQ) => {
  var aO = Ou();
  function Vit(e, t) {
    return e.name in aO && "overridesShorthands" in aO[e.name] && aO[e.name].overridesShorthands.indexOf(t.name) > -1;
  }
  s(Vit, "overridesNonComponentShorthand");
  GQ.exports = Vit;
});

// ../node_modules/clean-css/lib/optimizer/level-2/properties/override-properties.js
var rZ = b((GFt, tZ) => {
  var oO = nO(), $Q = FQ(), Dl = iO(), jc = qQ(), uO = KQ(), lO = zQ(), Kit = WQ(), XQ = K2().same, Ks = Ou(), YQ = gm().deep, cO = gS(), Hit = gm().
  shallow, fO = Rp(), Up = ui(), SS = Ln(), zit = Hi().property;
  function wl(e, t, r) {
    return t === r;
  }
  s(wl, "sameValue");
  function Git(e, t) {
    for (var r = 0; r < e.components.length; r++) {
      var i = e.components[r], n = Ks[i.name], a = n && n.canOverride || wl, o = Hit(i);
      if (o.value = [[Up.PROPERTY_VALUE, n.defaultValue]], !Dl(a.bind(null, t), o, i))
        return !0;
    }
    return !1;
  }
  s(Git, "wouldBreakCompatibility");
  function QQ(e, t) {
    t.unused = !0, mO(t, TS(e)), e.value = t.value;
  }
  s(QQ, "overrideIntoMultiplex");
  function ZQ(e, t) {
    t.unused = !0, e.multiplex = !0, e.value = t.value;
  }
  s(ZQ, "overrideByMultiplex");
  function Wit(e, t) {
    t.unused = !0, e.value = t.value;
  }
  s(Wit, "overrideSimple");
  function dO(e, t) {
    t.multiplex ? ZQ(e, t) : e.multiplex ? QQ(e, t) : Wit(e, t);
  }
  s(dO, "override");
  function $it(e, t) {
    t.unused = !0;
    for (var r = 0, i = e.components.length; r < i; r++)
      dO(e.components[r], t.components[r]);
  }
  s($it, "overrideShorthand");
  function mO(e, t) {
    e.multiplex = !0, Ks[e.name].shorthand ? Xit(e, t) : eZ(e, t);
  }
  s(mO, "turnIntoMultiplex");
  function Xit(e, t) {
    var r, i, n;
    for (i = 0, n = e.components.length; i < n; i++)
      r = e.components[i], r.multiplex || eZ(r, t);
  }
  s(Xit, "turnShorthandValueIntoMultiplex");
  function eZ(e, t) {
    for (var r = Ks[e.name], i = r.intoMultiplexMode == "real", n = r.intoMultiplexMode == "real" ? e.value.slice(0) : r.intoMultiplexMode ==
    "placeholder" ? r.placeholderValue : r.defaultValue, a = TS(e), o, u = n.length; a < t; a++)
      if (e.value.push([Up.PROPERTY_VALUE, SS.COMMA]), Array.isArray(n))
        for (o = 0; o < u; o++)
          e.value.push(i ? n[o] : [Up.PROPERTY_VALUE, n[o]]);
      else
        e.value.push(i ? n : [Up.PROPERTY_VALUE, n]);
  }
  s(eZ, "turnLonghandValueIntoMultiplex");
  function TS(e) {
    for (var t = 0, r = 0, i = e.value.length; r < i; r++)
      e.value[r][1] == SS.COMMA && t++;
    return t + 1;
  }
  s(TS, "multiplexSize");
  function pO(e) {
    var t = [
      Up.PROPERTY,
      [Up.PROPERTY_NAME, e.name]
    ].concat(e.value);
    return zit([t], 0).length;
  }
  s(pO, "lengthOf");
  function Yit(e, t, r) {
    for (var i = 0, n = t; n >= 0 && (e[n].name == r && !e[n].unused && i++, !(i > 1)); n--)
      ;
    return i > 1;
  }
  s(Yit, "moreSameShorthands");
  function hO(e, t) {
    for (var r = 0, i = e.components.length; r < i; r++)
      if (!vS(t.isUrl, e.components[r]) && vS(t.isFunction, e.components[r]))
        return !0;
    return !1;
  }
  s(hO, "overridingFunction");
  function vS(e, t) {
    for (var r = 0, i = t.value.length; r < i; r++)
      if (t.value[r][1] != SS.COMMA && e(t.value[r][1]))
        return !0;
    return !1;
  }
  s(vS, "anyValue");
  function Jit(e, t) {
    if (!e.multiplex && !t.multiplex || e.multiplex && t.multiplex)
      return !1;
    var r = e.multiplex ? e : t, i = e.multiplex ? t : e, n, a = YQ(r);
    fO([a], cO);
    var o = YQ(i);
    fO([o], cO);
    var u = pO(a) + 1 + pO(o);
    e.multiplex ? (n = jc(a, o), QQ(n, o)) : (n = jc(o, a), mO(o, TS(a)), ZQ(n, a)), fO([o], cO);
    var l = pO(o);
    return u <= l;
  }
  s(Jit, "wouldResultInLongerValue");
  function JQ(e) {
    return e.name in Ks;
  }
  s(JQ, "isCompactable");
  function Qit(e, t) {
    return !e.multiplex && (e.name == "background" || e.name == "background-image") && t.multiplex && (t.name == "background" || t.name == "\
background-image") && Zit(t.value);
  }
  s(Qit, "noneOverrideHack");
  function Zit(e) {
    for (var t = ent(e), r = 0, i = t.length; r < i; r++)
      if (t[r].length == 1 && t[r][0][1] == "none")
        return !0;
    return !1;
  }
  s(Zit, "anyLayerIsNone");
  function ent(e) {
    for (var t = [], r = 0, i = [], n = e.length; r < n; r++) {
      var a = e[r];
      a[1] == SS.COMMA ? (t.push(i), i = []) : i.push(a);
    }
    return t.push(i), t;
  }
  s(ent, "intoLayers");
  function tnt(e, t, r, i) {
    var n, a, o, u, l, c, p, h, y, _, g;
    e:
      for (y = e.length - 1; y >= 0; y--)
        if (a = e[y], !!JQ(a) && !a.block) {
          n = Ks[a.name].canOverride || wl;
          t:
            for (_ = y - 1; _ >= 0; _--)
              if (o = e[_], !!JQ(o) && !o.block && !(o.dynamic || a.dynamic) && !(o.unused || a.unused) && !(o.hack && !a.hack && !a.important ||
              !o.hack && !o.important && a.hack) && !(o.important == a.important && o.hack[0] != a.hack[0]) && !(o.important == a.important &&
              (o.hack[0] != a.hack[0] || o.hack[1] && o.hack[1] != a.hack[1])) && !oO(a) && !Qit(o, a)) {
                if (a.shorthand && uO(a, o)) {
                  if (!a.important && o.important || !XQ([o], a.components) || !vS(i.isFunction, o) && hO(a, i))
                    continue;
                  if (!lO(a)) {
                    o.unused = !0;
                    continue;
                  }
                  u = jc(a, o), n = Ks[o.name].canOverride || wl, Dl(n.bind(null, i), o, u) && (o.unused = !0);
                } else if (a.shorthand && Kit(a, o)) {
                  if (!a.important && o.important || !XQ([o], a.components) || !vS(i.isFunction, o) && hO(a, i))
                    continue;
                  for (l = o.shorthand ? o.components : [o], g = l.length - 1; g >= 0; g--)
                    if (c = l[g], p = jc(a, c), n = Ks[c.name].canOverride || wl, !Dl(n.bind(null, i), o, p))
                      continue t;
                  o.unused = !0;
                } else if (t && o.shorthand && !a.shorthand && uO(o, a, !0)) {
                  if (a.important && !o.important)
                    continue;
                  if (!a.important && o.important) {
                    a.unused = !0;
                    continue;
                  }
                  if (Yit(e, y - 1, o.name) || hO(o, i) || !lO(o) || $Q(o) || $Q(a))
                    continue;
                  if (u = jc(o, a), Dl(n.bind(null, i), u, a)) {
                    var m = !r.properties.backgroundClipMerging && u.name.indexOf("background-clip") > -1 || !r.properties.backgroundOriginMerging &&
                    u.name.indexOf("background-origin") > -1 || !r.properties.backgroundSizeMerging && u.name.indexOf("background-size") > -1,
                    f = Ks[a.name].nonMergeableValue === a.value[0][1];
                    if (m || f || !r.properties.merging && Git(o, i) || u.value[0][1] != a.value[0][1] && (oO(o) || oO(a)) || Jit(o, a))
                      continue;
                    !o.multiplex && a.multiplex && mO(o, TS(a)), dO(u, a), o.dirty = !0;
                  }
                } else if (t && o.shorthand && a.shorthand && o.name == a.name) {
                  if (!o.multiplex && a.multiplex)
                    continue;
                  if (!a.important && o.important) {
                    a.unused = !0;
                    continue e;
                  }
                  if (a.important && !o.important) {
                    o.unused = !0;
                    continue;
                  }
                  if (!lO(a)) {
                    o.unused = !0;
                    continue;
                  }
                  for (g = o.components.length - 1; g >= 0; g--) {
                    var d = o.components[g], v = a.components[g];
                    if (n = Ks[d.name].canOverride || wl, !Dl(n.bind(null, i), d, v))
                      continue e;
                  }
                  $it(o, a), o.dirty = !0;
                } else if (t && o.shorthand && a.shorthand && uO(o, a)) {
                  if (!o.important && a.important || (u = jc(o, a), n = Ks[a.name].canOverride || wl, !Dl(n.bind(null, i), u, a)))
                    continue;
                  if (o.important && !a.important) {
                    a.unused = !0;
                    continue;
                  }
                  var E = Ks[a.name].restore(a, Ks);
                  if (E.length > 1)
                    continue;
                  u = jc(o, a), dO(u, a), a.dirty = !0;
                } else if (o.name == a.name) {
                  if (h = !0, a.shorthand)
                    for (g = a.components.length - 1; g >= 0 && h; g--)
                      c = o.components[g], p = a.components[g], n = Ks[p.name].canOverride || wl, h = Dl(n.bind(null, i), c, p);
                  else
                    n = Ks[a.name].canOverride || wl, h = Dl(n.bind(null, i), o, a);
                  if (o.important && !a.important && h) {
                    a.unused = !0;
                    continue;
                  }
                  if (!o.important && a.important && h) {
                    o.unused = !0;
                    continue;
                  }
                  if (!h)
                    continue;
                  o.unused = !0;
                }
              }
        }
  }
  s(tnt, "overrideProperties");
  tZ.exports = tnt;
});

// ../node_modules/clean-css/lib/optimizer/level-2/properties/optimize.js
var Im = b(($Ft, nZ) => {
  var rnt = NQ(), int = rZ(), nnt = yS(), snt = gS(), ant = Fc().all, ont = B2(), unt = Rp(), lnt = Ki().OptimizationLevel;
  function iZ(e, t, r, i) {
    var n = i.options.level[lnt.Two], a = ant(e, n.skipProperties), o, u, l;
    for (nnt(a, i.validator, i.warnings), u = 0, l = a.length; u < l; u++)
      o = a[u], o.block && iZ(o.value[0][1], t, r, i);
    r && n.mergeIntoShorthands && rnt(a, i.validator), t && n.overrideProperties && int(a, r, i.options.compatibility, i.validator), unt(a, snt),
    ont(a);
  }
  s(iZ, "optimizeProperties");
  nZ.exports = iZ;
});

// ../node_modules/clean-css/lib/optimizer/level-2/merge-adjacent.js
var uZ = b((YFt, oZ) => {
  var sZ = wm(), cnt = Im(), fnt = Wv(), pnt = Yv(), hnt = Ki().OptimizationLevel, aZ = Hi().body, ES = Hi().rules, yO = ui();
  function dnt(e, t) {
    for (var r = [null, [], []], i = t.options, n = i.compatibility.selectors.adjacentSpace, a = i.level[hnt.One].selectorsSortingMethod, o = i.
    compatibility.selectors.mergeablePseudoClasses, u = i.compatibility.selectors.mergeablePseudoElements, l = i.compatibility.selectors.mergeLimit,
    c = i.compatibility.selectors.multiplePseudoMerging, p = 0, h = e.length; p < h; p++) {
      var y = e[p];
      if (y[0] != yO.RULE) {
        r = [null, [], []];
        continue;
      }
      r[0] == yO.RULE && ES(y[1]) == ES(r[1]) ? (Array.prototype.push.apply(r[2], y[2]), cnt(r[2], !0, !0, t), y[2] = []) : r[0] == yO.RULE &&
      aZ(y[2]) == aZ(r[2]) && sZ(ES(y[1]), o, u, c) && sZ(
        ES(r[1]),
        o,
        u,
        c
      ) && r[1].length < l ? (r[1] = pnt(r[1].concat(y[1]), !1, n, !1, t.warnings), r[1] = r.length > 1 ? fnt(r[1], a) : r[1], y[2] = []) : r =
      y;
    }
  }
  s(dnt, "mergeAdjacent");
  oZ.exports = dnt;
});

// ../node_modules/clean-css/lib/optimizer/level-2/rules-overlap.js
var gO = b((QFt, cZ) => {
  var mnt = /--.+$/;
  function ynt(e, t, r) {
    var i, n, a, o, u, l;
    for (a = 0, o = e.length; a < o; a++)
      for (i = e[a][1], u = 0, l = t.length; u < l; u++)
        if (n = t[u][1], i == n || r && lZ(i) == lZ(n))
          return !0;
    return !1;
  }
  s(ynt, "rulesOverlap");
  function lZ(e) {
    return e.replace(mnt, "");
  }
  s(lZ, "withoutModifiers");
  cZ.exports = ynt;
});

// ../node_modules/clean-css/lib/optimizer/level-2/specificity.js
var pZ = b((eMt, fZ) => {
  var ku = Ln(), Rm = {
    ADJACENT_SIBLING: "+",
    DESCENDANT: ">",
    DOT: ".",
    HASH: "#",
    NON_ADJACENT_SIBLING: "~",
    PSEUDO: ":"
  }, gnt = /[a-zA-Z]/, _nt = ":not(", bnt = /[\s,(>~+]/;
  function vnt(e) {
    var t = [0, 0, 0], r, i, n, a, o = 0, u, l = !1, c = !1, p, h;
    for (p = 0, h = e.length; p < h; p++) {
      if (r = e[p], !i)
        if (r == ku.SINGLE_QUOTE && !a && !n)
          n = !0;
        else if (r == ku.SINGLE_QUOTE && !a && n)
          n = !1;
        else if (r == ku.DOUBLE_QUOTE && !a && !n)
          a = !0;
        else if (r == ku.DOUBLE_QUOTE && a && !n)
          a = !1;
        else {
          if (n || a)
            continue;
          o > 0 && !l || (r == ku.OPEN_ROUND_BRACKET ? o++ : r == ku.CLOSE_ROUND_BRACKET && o == 1 ? (o--, l = !1) : r == ku.CLOSE_ROUND_BRACKET ?
          o-- : r == Rm.HASH ? t[0]++ : r == Rm.DOT || r == ku.OPEN_SQUARE_BRACKET ? t[1]++ : r == Rm.PSEUDO && !c && !Snt(e, p) ? (t[1]++, l =
          !1) : r == Rm.PSEUDO ? l = !0 : (p === 0 || u) && gnt.test(r) && t[2]++);
        }
      i = r == ku.BACK_SLASH, c = r == Rm.PSEUDO, u = !i && bnt.test(r);
    }
    return t;
  }
  s(vnt, "specificity");
  function Snt(e, t) {
    return e.indexOf(_nt, t) === t;
  }
  s(Snt, "isNotPseudoClass");
  fZ.exports = vnt;
});

// ../node_modules/clean-css/lib/optimizer/level-2/specificities-overlap.js
var mZ = b((rMt, dZ) => {
  var Tnt = pZ();
  function Ent(e, t, r) {
    var i, n, a, o, u, l;
    for (a = 0, o = e.length; a < o; a++)
      for (i = hZ(e[a][1], r), u = 0, l = t.length; u < l; u++)
        if (n = hZ(t[u][1], r), i[0] === n[0] && i[1] === n[1] && i[2] === n[2])
          return !0;
    return !1;
  }
  s(Ent, "specificitiesOverlap");
  function hZ(e, t) {
    var r;
    return e in t || (t[e] = r = Tnt(e)), r || t[e];
  }
  s(hZ, "findSpecificity");
  dZ.exports = Ent;
});

// ../node_modules/clean-css/lib/optimizer/level-2/reorderable.js
var Nm = b((nMt, AZ) => {
  var Ant = gO(), xnt = mZ(), yZ = /align-items|box-align|box-pack|flex|justify/, gZ = /^border-(top|right|bottom|left|color|style|width|radius)/;
  function Cnt(e, t, r) {
    for (var i = t.length - 1; i >= 0; i--)
      for (var n = e.length - 1; n >= 0; n--)
        if (!EZ(e[n], t[i], r))
          return !1;
    return !0;
  }
  s(Cnt, "canReorder");
  function EZ(e, t, r) {
    var i = e[0], n = e[1], a = e[2], o = e[5], u = e[6], l = t[0], c = t[1], p = t[2], h = t[5], y = t[6];
    return i == "font" && l == "line-height" || l == "font" && i == "line-height" || yZ.test(i) && yZ.test(l) || a == p && _Z(i) == _Z(l) &&
    AS(i) ^ AS(l) || a == "border" && gZ.test(p) && (i == "border" || i == p || n != c && bZ(i, l)) || p == "border" && gZ.test(a) && (l == "\
border" || l == a || n != c && bZ(i, l)) || a == "border" && p == "border" && i != l && (vZ(i) && SZ(l) || SZ(i) && vZ(l)) ? !1 : !!(a != p ||
    i == l && a == p && (n == c || Pnt(n, c)) || i != l && a == p && i != a && l != p || i != l && a == p && n == c || y && u && !TZ(a) && !TZ(
    p) && !Ant(h, o, !1) || !xnt(o, h, r));
  }
  s(EZ, "canReorderSingle");
  function AS(e) {
    return /^-(?:moz|webkit|ms|o)-/.test(e);
  }
  s(AS, "vendorPrefixed");
  function _Z(e) {
    return e.replace(/^-(?:moz|webkit|ms|o)-/, "");
  }
  s(_Z, "unprefixed");
  function bZ(e, t) {
    return e.split("-").pop() == t.split("-").pop();
  }
  s(bZ, "sameBorderComponent");
  function vZ(e) {
    return e == "border-top" || e == "border-right" || e == "border-bottom" || e == "border-left";
  }
  s(vZ, "isSideBorder");
  function SZ(e) {
    return e == "border-color" || e == "border-style" || e == "border-width";
  }
  s(SZ, "isStyleBorder");
  function Pnt(e, t) {
    return AS(e) && AS(t) && e.split("-")[1] != t.split("-")[2];
  }
  s(Pnt, "withDifferentVendorPrefix");
  function TZ(e) {
    return e == "font" || e == "line-height" || e == "list-style";
  }
  s(TZ, "inheritable");
  AZ.exports = {
    canReorder: Cnt,
    canReorderSingle: EZ
  };
});

// ../node_modules/clean-css/lib/optimizer/level-2/extract-properties.js
var xS = b((aMt, CZ) => {
  var _O = ui(), Dnt = Hi().rules, wnt = Hi().value;
  function xZ(e) {
    var t = [], r, i, n, a, o, u;
    if (e[0] == _O.RULE)
      for (r = !/[.+>~]/.test(Dnt(e[1])), o = 0, u = e[2].length; o < u; o++)
        i = e[2][o], i[0] == _O.PROPERTY && (n = i[1][1], n.length !== 0 && (a = wnt(i, o), t.push([
          n,
          a,
          Ont(n),
          e[2][o],
          n + ":" + a,
          e[1],
          r
        ])));
    else if (e[0] == _O.NESTED_BLOCK)
      for (o = 0, u = e[2].length; o < u; o++)
        t = t.concat(xZ(e[2][o]));
    return t;
  }
  s(xZ, "extractProperties");
  function Ont(e) {
    return e == "list-style" ? e : e.indexOf("-radius") > 0 ? "border-radius" : e == "border-collapse" || e == "border-spacing" || e == "bor\
der-image" ? e : e.indexOf("border-") === 0 && /^border-\w+-\w+$/.test(e) ? e.match(/border-\w+/)[0] : e.indexOf("border-") === 0 && /^border-\w+$/.
    test(e) ? "border" : e.indexOf("text-") === 0 || e == "-chrome-" ? e : e.replace(/^-\w+-/, "").match(/([a-zA-Z]+)/)[0].toLowerCase();
  }
  s(Ont, "findNameRoot");
  CZ.exports = xZ;
});

// ../node_modules/clean-css/lib/optimizer/level-2/merge-media-queries.js
var wZ = b((uMt, DZ) => {
  var knt = Nm().canReorder, Int = Nm().canReorderSingle, PZ = xS(), Rnt = gO(), Nnt = Hi().rules, Lnt = Ki().OptimizationLevel, Fnt = ui();
  function Mnt(e, t) {
    for (var r = t.options.level[Lnt.Two].mergeSemantically, i = t.cache.specificity, n = {}, a = [], o = e.length - 1; o >= 0; o--) {
      var u = e[o];
      if (u[0] == Fnt.NESTED_BLOCK) {
        var l = Nnt(u[1]), c = n[l];
        c || (c = [], n[l] = c), c.push(o);
      }
    }
    for (var p in n) {
      var h = n[p];
      e:
        for (var y = h.length - 1; y > 0; y--) {
          var _ = h[y], g = e[_], m = h[y - 1], f = e[m];
          t:
            for (var d = 1; d >= -1; d -= 2) {
              for (var v = d == 1, E = v ? _ + 1 : m - 1, S = v ? m : _, x = v ? 1 : -1, C = v ? g : f, z = v ? f : g, w = PZ(C); E != S; ) {
                var D = PZ(e[E]);
                if (E += x, !(r && Bnt(w, D, i)) && !knt(w, D, i))
                  continue t;
              }
              z[2] = v ? C[2].concat(z[2]) : z[2].concat(C[2]), C[2] = [], a.push(z);
              continue e;
            }
        }
    }
    return a;
  }
  s(Mnt, "mergeMediaQueries");
  function Bnt(e, t, r) {
    var i, n, a, o, u, l, c, p;
    for (u = 0, l = e.length; u < l; u++)
      for (i = e[u], n = i[5], c = 0, p = t.length; c < p; c++)
        if (a = t[c], o = a[5], Rnt(n, o, !0) && !Int(i, a, r))
          return !1;
    return !0;
  }
  s(Bnt, "allSameRulePropertiesCanBeReordered");
  DZ.exports = Mnt;
});

// ../node_modules/clean-css/lib/optimizer/level-2/merge-non-adjacent-by-body.js
var LZ = b((cMt, NZ) => {
  var OZ = wm(), qnt = Wv(), Unt = Yv(), kZ = Ki().OptimizationLevel, IZ = Hi().body, jp = Hi().rules, jnt = ui();
  function Vnt(e) {
    return /\.|\*| :/.test(e);
  }
  s(Vnt, "unsafeSelector");
  function Knt(e) {
    var t = jp(e[1]);
    return t.indexOf("__") > -1 || t.indexOf("--") > -1;
  }
  s(Knt, "isBemElement");
  function RZ(e) {
    return e.replace(/--[^ ,>+~:]+/g, "");
  }
  s(RZ, "withoutModifier");
  function Hnt(e, t) {
    var r = RZ(jp(e[1]));
    for (var i in t) {
      var n = t[i], a = RZ(jp(n[1]));
      (a.indexOf(r) > -1 || r.indexOf(a) > -1) && delete t[i];
    }
  }
  s(Hnt, "removeAnyUnsafeElements");
  function znt(e, t) {
    for (var r = t.options, i = r.level[kZ.Two].mergeSemantically, n = r.compatibility.selectors.adjacentSpace, a = r.level[kZ.One].selectorsSortingMethod,
    o = r.compatibility.selectors.mergeablePseudoClasses, u = r.compatibility.selectors.mergeablePseudoElements, l = r.compatibility.selectors.
    multiplePseudoMerging, c = {}, p = e.length - 1; p >= 0; p--) {
      var h = e[p];
      if (h[0] == jnt.RULE) {
        h[2].length > 0 && !i && Vnt(jp(h[1])) && (c = {}), h[2].length > 0 && i && Knt(h) && Hnt(h, c);
        var y = IZ(h[2]), _ = c[y];
        _ && OZ(
          jp(h[1]),
          o,
          u,
          l
        ) && OZ(
          jp(_[1]),
          o,
          u,
          l
        ) && (h[2].length > 0 ? (h[1] = Unt(_[1].concat(h[1]), !1, n, !1, t.warnings), h[1] = h[1].length > 1 ? qnt(h[1], a) : h[1]) : h[1] =
        _[1].concat(h[1]), _[2] = [], c[y] = null), c[IZ(h[2])] = h;
      }
    }
  }
  s(znt, "mergeNonAdjacentByBody");
  NZ.exports = znt;
});

// ../node_modules/clean-css/lib/optimizer/level-2/merge-non-adjacent-by-selector.js
var qZ = b((pMt, BZ) => {
  var FZ = Nm().canReorder, MZ = xS(), Gnt = Im(), Wnt = Hi().rules, $nt = ui();
  function Xnt(e, t) {
    var r = t.cache.specificity, i = {}, n = [], a;
    for (a = e.length - 1; a >= 0; a--)
      if (e[a][0] == $nt.RULE && e[a][2].length !== 0) {
        var o = Wnt(e[a][1]);
        i[o] = [a].concat(i[o] || []), i[o].length == 2 && n.push(o);
      }
    for (a = n.length - 1; a >= 0; a--) {
      var u = i[n[a]];
      e:
        for (var l = u.length - 1; l > 0; l--) {
          var c = u[l - 1], p = e[c], h = u[l], y = e[h];
          t:
            for (var _ = 1; _ >= -1; _ -= 2) {
              for (var g = _ == 1, m = g ? c + 1 : h - 1, f = g ? h : c, d = g ? 1 : -1, v = g ? p : y, E = g ? y : p, S = MZ(v); m != f; ) {
                var x = MZ(e[m]);
                m += d;
                var C = g ? FZ(S, x, r) : FZ(x, S, r);
                if (!C && !g)
                  continue e;
                if (!C && g)
                  continue t;
              }
              g ? (Array.prototype.push.apply(v[2], E[2]), E[2] = v[2]) : Array.prototype.push.apply(E[2], v[2]), Gnt(E[2], !0, !0, t), v[2] =
              [];
            }
        }
    }
  }
  s(Xnt, "mergeNonAdjacentBySelector");
  BZ.exports = Xnt;
});

// ../node_modules/clean-css/lib/utils/clone-array.js
var bO = b((dMt, jZ) => {
  function UZ(e) {
    for (var t = e.slice(0), r = 0, i = t.length; r < i; r++)
      Array.isArray(t[r]) && (t[r] = UZ(t[r]));
    return t;
  }
  s(UZ, "cloneArray");
  jZ.exports = UZ;
});

// ../node_modules/clean-css/lib/optimizer/level-2/reduce-non-adjacent.js
var GZ = b((yMt, zZ) => {
  var KZ = wm(), Ynt = Im(), Jnt = bO(), Qnt = ui(), VZ = Hi().body, Znt = Hi().rules;
  function est(e, t) {
    for (var r = t.options, i = r.compatibility.selectors.mergeablePseudoClasses, n = r.compatibility.selectors.mergeablePseudoElements, a = r.
    compatibility.selectors.multiplePseudoMerging, o = {}, u = [], l = e.length - 1; l >= 0; l--) {
      var c = e[l];
      if (c[0] == Qnt.RULE && c[2].length !== 0)
        for (var p = Znt(c[1]), h = c[1].length > 1 && KZ(p, i, n, a), y = tst(c[1]), _ = h ? [p].concat(y) : [p], g = 0, m = _.length; g < m; g++) {
          var f = _[g];
          o[f] ? u.push(f) : o[f] = [], o[f].push({
            where: l,
            list: y,
            isPartial: h && g > 0,
            isComplex: h && g === 0
          });
        }
    }
    rst(e, u, o, r, t), ist(e, o, r, t);
  }
  s(est, "reduceNonAdjacent");
  function tst(e) {
    for (var t = [], r = 0; r < e.length; r++)
      t.push([e[r][1]]);
    return t;
  }
  s(tst, "wrappedSelectorsFrom");
  function rst(e, t, r, i, n) {
    function a(h, y) {
      return p[h].isPartial && y.length === 0;
    }
    s(a, "filterOut");
    function o(h, y, _, g) {
      p[_ - g - 1].isPartial || (h[2] = y);
    }
    s(o, "reduceBody");
    for (var u = 0, l = t.length; u < l; u++) {
      var c = t[u], p = r[c];
      HZ(e, p, {
        filterOut: a,
        callback: o
      }, i, n);
    }
  }
  s(rst, "reduceSimpleNonAdjacentCases");
  function ist(e, t, r, i) {
    var n = r.compatibility.selectors.mergeablePseudoClasses, a = r.compatibility.selectors.mergeablePseudoElements, o = r.compatibility.selectors.
    multiplePseudoMerging, u = {};
    function l(S) {
      return u.data[S].where < u.intoPosition;
    }
    s(l, "filterOut");
    function c(S, x, C, z) {
      z === 0 && u.reducedBodies.push(x);
    }
    s(c, "collectReducedBodies");
    e:
      for (var p in t) {
        var h = t[p];
        if (h[0].isComplex) {
          var y = h[h.length - 1].where, _ = e[y], g = [], m = KZ(p, n, a, o) ? h[0].list : [p];
          u.intoPosition = y, u.reducedBodies = g;
          for (var f = 0, d = m.length; f < d; f++) {
            var v = m[f], E = t[v];
            if (E.length < 2 || (u.data = E, HZ(e, E, {
              filterOut: l,
              callback: c
            }, r, i), VZ(g[g.length - 1]) != VZ(g[0])))
              continue e;
          }
          _[2] = g[0];
        }
      }
  }
  s(ist, "reduceComplexNonAdjacentCases");
  function HZ(e, t, r, i, n) {
    for (var a = [], o = [], u = [], l = t.length - 1; l >= 0; l--)
      if (!r.filterOut(l, a)) {
        var c = t[l].where, p = e[c], h = Jnt(p[2]);
        a = a.concat(h), o.push(h), u.push(c);
      }
    Ynt(a, !0, !1, n);
    for (var y = u.length, _ = a.length - 1, g = y - 1; g >= 0; ) {
      if ((g === 0 || a[_] && o[g].indexOf(a[_]) > -1) && _ > -1) {
        _--;
        continue;
      }
      var m = a.splice(_ + 1);
      r.callback(e[u[g]], m, y, g), g--;
    }
  }
  s(HZ, "reduceSelector");
  zZ.exports = est;
});

// ../node_modules/clean-css/lib/optimizer/level-2/remove-duplicate-font-at-rules.js
var $Z = b((_Mt, WZ) => {
  var nst = ui(), sst = Hi().all, ast = "@font-face";
  function ost(e) {
    var t = [], r, i, n, a;
    for (n = 0, a = e.length; n < a; n++)
      r = e[n], !(r[0] != nst.AT_RULE_BLOCK && r[1][0][1] != ast) && (i = sst([r]), t.indexOf(i) > -1 ? r[2] = [] : t.push(i));
  }
  s(ost, "removeDuplicateFontAtRules");
  WZ.exports = ost;
});

// ../node_modules/clean-css/lib/optimizer/level-2/remove-duplicate-media-queries.js
var YZ = b((vMt, XZ) => {
  var ust = ui(), lst = Hi().all, cst = Hi().rules;
  function fst(e) {
    var t = {}, r, i, n, a, o;
    for (a = 0, o = e.length; a < o; a++)
      i = e[a], i[0] == ust.NESTED_BLOCK && (n = cst(i[1]) + "%" + lst(i[2]), r = t[n], r && (r[2] = []), t[n] = i);
  }
  s(fst, "removeDuplicateMediaQueries");
  XZ.exports = fst;
});

// ../node_modules/clean-css/lib/optimizer/level-2/remove-duplicates.js
var QZ = b((TMt, JZ) => {
  var pst = ui(), hst = Hi().body, dst = Hi().rules;
  function mst(e) {
    for (var t = {}, r = [], i, n, a, o, u = 0, l = e.length; u < l; u++)
      n = e[u], n[0] == pst.RULE && (i = dst(n[1]), t[i] && t[i].length == 1 ? r.push(i) : t[i] = t[i] || [], t[i].push(u));
    for (u = 0, l = r.length; u < l; u++) {
      i = r[u], o = [];
      for (var c = t[i].length - 1; c >= 0; c--)
        n = e[t[i][c]], a = hst(n[2]), o.indexOf(a) > -1 ? n[2] = [] : o.push(a);
    }
  }
  s(mst, "removeDuplicates");
  JZ.exports = mst;
});

// ../node_modules/clean-css/lib/optimizer/level-2/remove-unused-at-rules.js
var tee = b((AMt, eee) => {
  var SO = yS(), TO = Fc().single, EO = Rp(), Vc = ui(), yst = /^(-moz-|-o-|-webkit-)?animation-name$/, gst = /^(-moz-|-o-|-webkit-)?animation$/,
  _st = /^@(-moz-|-o-|-webkit-)?keyframes /, bst = /\s{0,31}!important$/, vst = /^(['"]?)(.*)\1$/;
  function vO(e) {
    return e.replace(vst, "$2").replace(bst, "");
  }
  s(vO, "normalize");
  function Sst(e, t) {
    CS(e, Tst, Est, t), CS(e, Ast, xst, t), CS(e, Cst, Pst, t), CS(e, Dst, wst, t);
  }
  s(Sst, "removeUnusedAtRules");
  function CS(e, t, r, i) {
    var n = {}, a, o, u, l, c, p;
    for (c = 0, p = e.length; c < p; c++)
      t(e[c], n);
    if (Object.keys(n).length !== 0) {
      ZZ(e, r, n, i);
      for (a in n)
        for (o = n[a], c = 0, p = o.length; c < p; c++)
          u = o[c], l = u[0] == Vc.AT_RULE ? 1 : 2, u[l] = [];
    }
  }
  s(CS, "removeUnusedAtRule");
  function ZZ(e, t, r, i) {
    var n = t(r), a, o;
    for (a = 0, o = e.length; a < o; a++)
      switch (e[a][0]) {
        case Vc.RULE:
          n(e[a], i);
          break;
        case Vc.NESTED_BLOCK:
          ZZ(e[a][2], t, r, i);
      }
  }
  s(ZZ, "markUsedAtRules");
  function Tst(e, t) {
    var r;
    e[0] == Vc.AT_RULE_BLOCK && e[1][0][1].indexOf("@counter-style") === 0 && (r = e[1][0][1].split(" ")[1], t[r] = t[r] || [], t[r].push(e));
  }
  s(Tst, "matchCounterStyle");
  function Est(e) {
    return function(t, r) {
      var i, n, a, o;
      for (a = 0, o = t[2].length; a < o; a++)
        i = t[2][a], i[1][1] == "list-style" && (n = TO(i), SO([n], r.validator, r.warnings), n.components[0].value[0][1] in e && delete e[i[2][1]],
        EO([n])), i[1][1] == "list-style-type" && i[2][1] in e && delete e[i[2][1]];
    };
  }
  s(Est, "markCounterStylesAsUsed");
  function Ast(e, t) {
    var r, i, n, a;
    if (e[0] == Vc.AT_RULE_BLOCK && e[1][0][1] == "@font-face") {
      for (n = 0, a = e[2].length; n < a; n++)
        if (r = e[2][n], r[1][1] == "font-family") {
          i = vO(r[2][1].toLowerCase()), t[i] = t[i] || [], t[i].push(e);
          break;
        }
    }
  }
  s(Ast, "matchFontFace");
  function xst(e) {
    return function(t, r) {
      var i, n, a, o, u, l, c, p;
      for (u = 0, l = t[2].length; u < l; u++) {
        if (i = t[2][u], i[1][1] == "font") {
          for (n = TO(i), SO([n], r.validator, r.warnings), a = n.components[6], c = 0, p = a.value.length; c < p; c++)
            o = vO(a.value[c][1].toLowerCase()), o in e && delete e[o];
          EO([n]);
        }
        if (i[1][1] == "font-family")
          for (c = 2, p = i.length; c < p; c++)
            o = vO(i[c][1].toLowerCase()), o in e && delete e[o];
      }
    };
  }
  s(xst, "markFontFacesAsUsed");
  function Cst(e, t) {
    var r;
    e[0] == Vc.NESTED_BLOCK && _st.test(e[1][0][1]) && (r = e[1][0][1].split(" ")[1], t[r] = t[r] || [], t[r].push(e));
  }
  s(Cst, "matchKeyframe");
  function Pst(e) {
    return function(t, r) {
      var i, n, a, o, u, l, c;
      for (o = 0, u = t[2].length; o < u; o++) {
        if (i = t[2][o], gst.test(i[1][1])) {
          for (n = TO(i), SO([n], r.validator, r.warnings), a = n.components[7], l = 0, c = a.value.length; l < c; l++)
            a.value[l][1] in e && delete e[a.value[l][1]];
          EO([n]);
        }
        if (yst.test(i[1][1]))
          for (l = 2, c = i.length; l < c; l++)
            i[l][1] in e && delete e[i[l][1]];
      }
    };
  }
  s(Pst, "markKeyframesAsUsed");
  function Dst(e, t) {
    var r;
    e[0] == Vc.AT_RULE && e[1].indexOf("@namespace") === 0 && (r = e[1].split(" ")[1], t[r] = t[r] || [], t[r].push(e));
  }
  s(Dst, "matchNamespace");
  function wst(e) {
    var t = new RegExp(Object.keys(e).join("\\||") + "\\|", "g");
    return function(r) {
      var i, n, a, o, u, l, c;
      for (o = 0, u = r[1].length; o < u; o++)
        for (n = r[1][o], i = n[1].match(t), l = 0, c = i.length; l < c; l++)
          a = i[l].substring(0, i[l].length - 1), a in e && delete e[a];
    };
  }
  s(wst, "markNamespacesAsUsed");
  eee.exports = Sst;
});

// ../node_modules/clean-css/lib/optimizer/level-2/tidy-rule-duplicates.js
var iee = b((CMt, ree) => {
  function Ost(e, t) {
    return e[1] > t[1] ? 1 : -1;
  }
  s(Ost, "ruleSorter");
  function kst(e) {
    for (var t = [], r = [], i = 0, n = e.length; i < n; i++) {
      var a = e[i];
      r.indexOf(a[1]) == -1 && (r.push(a[1]), t.push(a));
    }
    return t.sort(Ost);
  }
  s(kst, "tidyRuleDuplicates");
  ree.exports = kst;
});

// ../node_modules/clean-css/lib/optimizer/level-2/restructure.js
var oee = b((DMt, aee) => {
  var nee = Nm().canReorderSingle, Ist = xS(), Rst = wm(), see = iee(), Vp = ui(), Nst = bO(), Lst = Hi().body, AO = Hi().rules;
  function Fst(e, t) {
    return e > t ? 1 : -1;
  }
  s(Fst, "naturalSorter");
  function Mst(e, t) {
    var r = Nst(e);
    return r[5] = r[5].concat(t[5]), r;
  }
  s(Mst, "cloneAndMergeSelectors");
  function Bst(e, t) {
    var r = t.options, i = r.compatibility.selectors.mergeablePseudoClasses, n = r.compatibility.selectors.mergeablePseudoElements, a = r.compatibility.
    selectors.mergeLimit, o = r.compatibility.selectors.multiplePseudoMerging, u = t.cache.specificity, l = {}, c = [], p = {}, h = [], y = 2,
    _ = "%";
    function g(oe, Ae, Ie) {
      for (var te = Ie.length - 1; te >= 0; te--) {
        var pe = Ie[te][0], we = m(Ae, pe);
        if (p[we].length > 1 && T(oe, p[we])) {
          f(we);
          break;
        }
      }
    }
    s(g, "sendToMultiPropertyMoveCache");
    function m(oe, Ae) {
      var Ie = d(Ae);
      return p[Ie] = p[Ie] || [], p[Ie].push([oe, Ae]), Ie;
    }
    s(m, "addToCache");
    function f(oe) {
      var Ae = oe.split(_), Ie = [], te;
      for (var pe in p) {
        var we = pe.split(_);
        for (te = we.length - 1; te >= 0; te--)
          if (Ae.indexOf(we[te]) > -1) {
            Ie.push(pe);
            break;
          }
      }
      for (te = Ie.length - 1; te >= 0; te--)
        delete p[Ie[te]];
    }
    s(f, "removeAllMatchingFromCache");
    function d(oe) {
      for (var Ae = [], Ie = 0, te = oe.length; Ie < te; Ie++)
        Ae.push(AO(oe[Ie][1]));
      return Ae.join(_);
    }
    s(d, "cacheId");
    function v(oe) {
      for (var Ae = [], Ie = [], te = oe.length - 1; te >= 0; te--)
        Rst(
          AO(oe[te][1]),
          i,
          n,
          o
        ) && (Ie.unshift(oe[te]), oe[te][2].length > 0 && Ae.indexOf(oe[te]) == -1 && Ae.push(oe[te]));
      return Ae.length > 1 ? Ie : [];
    }
    s(v, "tokensToMerge");
    function E(oe, Ae) {
      var Ie = Ae[0], te = Ae[1], pe = Ae[4], we = Ie.length + te.length + 1, He = [], vt = [], wt = v(l[pe]);
      if (!(wt.length < 2)) {
        var xr = x(wt, we, 1), ae = xr[0];
        if (ae[1] > 0)
          return g(oe, Ae, xr);
        for (var _e = ae[0].length - 1; _e >= 0; _e--)
          He = ae[0][_e][1].concat(He), vt.unshift(ae[0][_e]);
        He = see(He), w(oe, [Ae], He, vt);
      }
    }
    s(E, "shortenIfPossible");
    function S(oe, Ae) {
      return oe[1] > Ae[1] ? 1 : oe[1] == Ae[1] ? 0 : -1;
    }
    s(S, "fitSorter");
    function x(oe, Ae, Ie) {
      var te = C(oe, Ae, Ie, y - 1);
      return te.sort(S);
    }
    s(x, "findAllFits");
    function C(oe, Ae, Ie, te) {
      var pe = [[oe, z(oe, Ae, Ie)]];
      if (oe.length > 2 && te > 0)
        for (var we = oe.length - 1; we >= 0; we--) {
          var He = Array.prototype.slice.call(oe, 0);
          He.splice(we, 1), pe = pe.concat(
            C(He, Ae, Ie, te - 1)
          );
        }
      return pe;
    }
    s(C, "allCombinations");
    function z(oe, Ae, Ie) {
      for (var te = 0, pe = oe.length - 1; pe >= 0; pe--)
        te += oe[pe][2].length > Ie ? AO(oe[pe][1]).length : -1;
      return te - (oe.length - 1) * Ae + 1;
    }
    s(z, "sizeDifference");
    function w(oe, Ae, Ie, te) {
      var pe, we, He, vt, wt = [];
      for (pe = te.length - 1; pe >= 0; pe--) {
        var xr = te[pe];
        for (we = xr[2].length - 1; we >= 0; we--) {
          var ae = xr[2][we];
          for (He = 0, vt = Ae.length; He < vt; He++) {
            var _e = Ae[He], be = ae[1][1], Pe = _e[0], ze = _e[4];
            if (be == Pe && Lst([ae]) == ze) {
              xr[2].splice(we, 1);
              break;
            }
          }
        }
      }
      for (pe = Ae.length - 1; pe >= 0; pe--)
        wt.unshift(Ae[pe][3]);
      var nt = [Vp.RULE, Ie, wt];
      e.splice(oe, 0, nt);
    }
    s(w, "dropAsNewTokenAt");
    function D(oe, Ae) {
      var Ie = Ae[4], te = l[Ie];
      te && te.length > 1 && (N(oe, Ae) || E(oe, Ae));
    }
    s(D, "dropPropertiesAt");
    function N(oe, Ae) {
      var Ie = [], te = [], pe = Ae[4], we, He, vt = v(l[pe]);
      if (!(vt.length < 2)) {
        e:
          for (var wt in l) {
            var xr = l[wt];
            for (we = vt.length - 1; we >= 0; we--)
              if (xr.indexOf(vt[we]) == -1)
                continue e;
            Ie.push(wt);
          }
        if (Ie.length < 2)
          return !1;
        for (we = Ie.length - 1; we >= 0; we--)
          for (He = c.length - 1; He >= 0; He--)
            if (c[He][4] == Ie[we]) {
              te.unshift([c[He], vt]);
              break;
            }
        return T(oe, te);
      }
    }
    s(N, "shortenMultiMovesIfPossible");
    function T(oe, Ae) {
      for (var Ie = 0, te = [], pe, we = Ae.length - 1; we >= 0; we--) {
        pe = Ae[we][0];
        var He = pe[4];
        Ie += He.length + (we > 0 ? 1 : 0), te.push(pe);
      }
      var vt = Ae[0][1], wt = x(vt, Ie, te.length)[0];
      if (wt[1] > 0)
        return !1;
      var xr = [], ae = [];
      for (we = wt[0].length - 1; we >= 0; we--)
        xr = wt[0][we][1].concat(xr), ae.unshift(wt[0][we]);
      for (xr = see(xr), w(oe, te, xr, ae), we = te.length - 1; we >= 0; we--) {
        pe = te[we];
        var _e = c.indexOf(pe);
        delete l[pe[4]], _e > -1 && h.indexOf(_e) == -1 && h.push(_e);
      }
      return !0;
    }
    s(T, "processMultiPropertyMove");
    function R(oe, Ae, Ie) {
      var te = oe[0], pe = Ae[0];
      if (te != pe)
        return !1;
      var we = Ae[4], He = l[we];
      return He && He.indexOf(Ie) > -1;
    }
    s(R, "boundToAnotherPropertyInCurrrentToken");
    for (var j = e.length - 1; j >= 0; j--) {
      var J = e[j], H, F, re, se, de;
      if (J[0] == Vp.RULE)
        H = !0;
      else if (J[0] == Vp.NESTED_BLOCK)
        H = !1;
      else
        continue;
      var he = c.length, xe = Ist(J);
      h = [];
      var G = [];
      for (F = xe.length - 1; F >= 0; F--)
        for (re = F - 1; re >= 0; re--)
          if (!nee(xe[F], xe[re], u)) {
            G.push(F);
            break;
          }
      for (F = xe.length - 1; F >= 0; F--) {
        var ie = xe[F], X = !1;
        for (re = 0; re < he; re++) {
          var ye = c[re];
          h.indexOf(re) == -1 && (!nee(ie, ye, u) && !R(ie, ye, J) || l[ye[4]] && l[ye[4]].length === a) && (D(j + 1, ye), h.indexOf(re) == -1 &&
          (h.push(re), delete l[ye[4]])), X || (X = ie[0] == ye[0] && ie[1] == ye[1], X && (de = re));
        }
        if (!(!H || G.indexOf(F) > -1)) {
          var Oe = ie[4];
          X && c[de][5].length + ie[5].length > a ? (D(j + 1, c[de]), c.splice(de, 1), l[Oe] = [J], X = !1) : (l[Oe] = l[Oe] || [], l[Oe].push(
          J)), X ? c[de] = Mst(c[de], ie) : c.push(ie);
        }
      }
      for (h = h.sort(Fst), F = 0, se = h.length; F < se; F++) {
        var Pt = h[F] - F;
        c.splice(Pt, 1);
      }
    }
    for (var Vt = e[0] && e[0][0] == Vp.AT_RULE && e[0][1].indexOf("@charset") === 0 ? 1 : 0; Vt < e.length - 1; Vt++) {
      var Ee = e[Vt][0] === Vp.AT_RULE && e[Vt][1].indexOf("@import") === 0, st = e[Vt][0] === Vp.COMMENT;
      if (!(Ee || st))
        break;
    }
    for (j = 0; j < c.length; j++)
      D(Vt, c[j]);
  }
  s(Bst, "restructure");
  aee.exports = Bst;
});

// ../node_modules/clean-css/lib/optimizer/level-2/optimize.js
var hee = b((OMt, pee) => {
  var uee = uZ(), qst = wZ(), Ust = LZ(), jst = qZ(), Vst = GZ(), Kst = $Z(), Hst = YZ(), zst = QZ(), Gst = tee(), lee = oee(), Wst = Im(), $st = Ki().
  OptimizationLevel, Kc = ui();
  function cee(e) {
    for (var t = 0, r = e.length; t < r; t++) {
      var i = e[t], n = !1;
      switch (i[0]) {
        case Kc.RULE:
          n = i[1].length === 0 || i[2].length === 0;
          break;
        case Kc.NESTED_BLOCK:
          cee(i[2]), n = i[2].length === 0;
          break;
        case Kc.AT_RULE:
          n = i[1].length === 0;
          break;
        case Kc.AT_RULE_BLOCK:
          n = i[2].length === 0;
      }
      n && (e.splice(t, 1), t--, r--);
    }
  }
  s(cee, "removeEmpty");
  function Xst(e, t) {
    for (var r = 0, i = e.length; r < i; r++) {
      var n = e[r];
      if (n[0] == Kc.NESTED_BLOCK) {
        var a = /@(-moz-|-o-|-webkit-)?keyframes/.test(n[1][0][1]);
        xO(n[2], t, !a);
      }
    }
  }
  s(Xst, "recursivelyOptimizeBlocks");
  function fee(e, t) {
    for (var r = 0, i = e.length; r < i; r++) {
      var n = e[r];
      switch (n[0]) {
        case Kc.RULE:
          Wst(n[2], !0, !0, t);
          break;
        case Kc.NESTED_BLOCK:
          fee(n[2], t);
      }
    }
  }
  s(fee, "recursivelyOptimizeProperties");
  function xO(e, t, r) {
    var i = t.options.level[$st.Two], n = t.options.plugins.level2Block, a, o;
    if (Xst(e, t), fee(e, t), i.removeDuplicateRules && zst(e, t), i.mergeAdjacentRules && uee(e, t), i.reduceNonAdjacentRules && Vst(e, t),
    i.mergeNonAdjacentRules && i.mergeNonAdjacentRules != "body" && jst(e, t), i.mergeNonAdjacentRules && i.mergeNonAdjacentRules != "select\
or" && Ust(e, t), i.restructureRules && i.mergeAdjacentRules && r && (lee(e, t), uee(e, t)), i.restructureRules && !i.mergeAdjacentRules && r &&
    lee(e, t), i.removeDuplicateFontRules && Kst(e, t), i.removeDuplicateMediaBlocks && Hst(e, t), i.removeUnusedAtRules && Gst(e, t), i.mergeMedia)
      for (a = qst(e, t), o = a.length - 1; o >= 0; o--)
        xO(a[o][2], t, !1);
    for (o = 0; o < n.length; o++)
      n[o](e);
    return i.removeEmpty && cee(e), e;
  }
  s(xO, "level2Optimize");
  pee.exports = xO;
});

// ../node_modules/clean-css/lib/optimizer/validator.js
var Aee = b((IMt, Eee) => {
  var Yst = "[A-Z]+(\\-|[A-Z]|[0-9])+\\(.*?\\)", Jst = "\\-(\\-|[A-Z]|[0-9])+\\(.*?\\)", gee = "var\\(\\-\\-[^\\)]+\\)", Qst = "(" + gee + "\
|" + Yst + "|" + Jst + ")", Zst = new RegExp("^(\\-moz\\-|\\-webkit\\-)?calc\\([^\\)]+\\)$", "i"), eat = /[0-9]/, tat = new RegExp("^" + Qst +
  "$", "i"), rat = /^#(?:[0-9a-f]{4}|[0-9a-f]{8})$/i, iat = /^hsl\(\s{0,31}[-.]?\d+\s{0,31},\s{0,31}\d*\.?\d+%\s{0,31},\s{0,31}\d*\.?\d+%\s{0,31}\)|hsla\(\s{0,31}[-.]?\d+\s{0,31},\s{0,31}\d*\.?\d+%\s{0,31},\s{0,31}\d*\.?\d+%\s{0,31},\s{0,31}\.?\d+\s{0,31}\)$/,
  nat = /^hsl\(\s{0,31}[-.]?\d+(deg)?\s{1,31}\d*\.?\d+%\s{1,31}\d*\.?\d+%\s{0,31}\)|hsla\(\s{0,31}[-.]?\d+(deg)?\s{1,31}\d*\.?\d+%\s{1,31}\d*\.?\d+%\s{1,31}\/\s{1,31}\d*\.?\d+%?\s{0,31}\)$/,
  sat = /^(-[a-z0-9_][a-z0-9\-_]*|[a-z_][a-z0-9\-_]*)$/i, aat = /^[a-z]+$/i, oat = /^-([a-z0-9]|-)*$/i, uat = /^("[^"]*"|'[^']*')$/i, lat = /^rgb\(\s{0,31}[\d]{1,3}\s{0,31},\s{0,31}[\d]{1,3}\s{0,31},\s{0,31}[\d]{1,3}\s{0,31}\)|rgba\(\s{0,31}[\d]{1,3}\s{0,31},\s{0,31}[\d]{1,3}\s{0,31},\s{0,31}[\d]{1,3}\s{0,31},\s{0,31}[.\d]+\s{0,31}\)$/i,
  cat = /^rgb\(\s{0,31}[\d]{1,3}\s{1,31}[\d]{1,3}\s{1,31}[\d]{1,3}\s{0,31}\)|rgba\(\s{0,31}[\d]{1,3}\s{1,31}[\d]{1,3}\s{1,31}[\d]{1,3}\s{1,31}\/\s{1,31}[\d]*\.?[.\d]+%?\s{0,31}\)$/i,
  fat = /\d+(s|ms)/, pat = /^(cubic-bezier|steps)\([^)]+\)$/, hat = ["ms", "s"], dat = /^url\([\s\S]+\)$/i, mat = new RegExp("^" + gee + "$",
  "i"), yat = /^#[0-9a-f]{8}$/i, gat = /^#[0-9a-f]{4}$/i, _at = /^#[0-9a-f]{6}$/i, bat = /^#[0-9a-f]{3}$/i, dee = ".", mee = "-", yee = "+",
  vat = {
    "^": [
      "inherit",
      "initial",
      "unset"
    ],
    "*-style": [
      "auto",
      "dashed",
      "dotted",
      "double",
      "groove",
      "hidden",
      "inset",
      "none",
      "outset",
      "ridge",
      "solid"
    ],
    "*-timing-function": [
      "ease",
      "ease-in",
      "ease-in-out",
      "ease-out",
      "linear",
      "step-end",
      "step-start"
    ],
    "animation-direction": [
      "alternate",
      "alternate-reverse",
      "normal",
      "reverse"
    ],
    "animation-fill-mode": [
      "backwards",
      "both",
      "forwards",
      "none"
    ],
    "animation-iteration-count": [
      "infinite"
    ],
    "animation-name": [
      "none"
    ],
    "animation-play-state": [
      "paused",
      "running"
    ],
    "background-attachment": [
      "fixed",
      "inherit",
      "local",
      "scroll"
    ],
    "background-clip": [
      "border-box",
      "content-box",
      "inherit",
      "padding-box",
      "text"
    ],
    "background-origin": [
      "border-box",
      "content-box",
      "inherit",
      "padding-box"
    ],
    "background-position": [
      "bottom",
      "center",
      "left",
      "right",
      "top"
    ],
    "background-repeat": [
      "no-repeat",
      "inherit",
      "repeat",
      "repeat-x",
      "repeat-y",
      "round",
      "space"
    ],
    "background-size": [
      "auto",
      "cover",
      "contain"
    ],
    "border-collapse": [
      "collapse",
      "inherit",
      "separate"
    ],
    bottom: [
      "auto"
    ],
    clear: [
      "both",
      "left",
      "none",
      "right"
    ],
    color: [
      "transparent"
    ],
    cursor: [
      "all-scroll",
      "auto",
      "col-resize",
      "crosshair",
      "default",
      "e-resize",
      "help",
      "move",
      "n-resize",
      "ne-resize",
      "no-drop",
      "not-allowed",
      "nw-resize",
      "pointer",
      "progress",
      "row-resize",
      "s-resize",
      "se-resize",
      "sw-resize",
      "text",
      "vertical-text",
      "w-resize",
      "wait"
    ],
    display: [
      "block",
      "inline",
      "inline-block",
      "inline-table",
      "list-item",
      "none",
      "table",
      "table-caption",
      "table-cell",
      "table-column",
      "table-column-group",
      "table-footer-group",
      "table-header-group",
      "table-row",
      "table-row-group"
    ],
    float: [
      "left",
      "none",
      "right"
    ],
    left: [
      "auto"
    ],
    font: [
      "caption",
      "icon",
      "menu",
      "message-box",
      "small-caption",
      "status-bar",
      "unset"
    ],
    "font-size": [
      "large",
      "larger",
      "medium",
      "small",
      "smaller",
      "x-large",
      "x-small",
      "xx-large",
      "xx-small"
    ],
    "font-stretch": [
      "condensed",
      "expanded",
      "extra-condensed",
      "extra-expanded",
      "normal",
      "semi-condensed",
      "semi-expanded",
      "ultra-condensed",
      "ultra-expanded"
    ],
    "font-style": [
      "italic",
      "normal",
      "oblique"
    ],
    "font-variant": [
      "normal",
      "small-caps"
    ],
    "font-weight": [
      "100",
      "200",
      "300",
      "400",
      "500",
      "600",
      "700",
      "800",
      "900",
      "bold",
      "bolder",
      "lighter",
      "normal"
    ],
    "line-height": [
      "normal"
    ],
    "list-style-position": [
      "inside",
      "outside"
    ],
    "list-style-type": [
      "armenian",
      "circle",
      "decimal",
      "decimal-leading-zero",
      "disc",
      "decimal|disc",
      // this is the default value of list-style-type, see comment in configuration.js
      "georgian",
      "lower-alpha",
      "lower-greek",
      "lower-latin",
      "lower-roman",
      "none",
      "square",
      "upper-alpha",
      "upper-latin",
      "upper-roman"
    ],
    overflow: [
      "auto",
      "hidden",
      "scroll",
      "visible"
    ],
    position: [
      "absolute",
      "fixed",
      "relative",
      "static"
    ],
    right: [
      "auto"
    ],
    "text-align": [
      "center",
      "justify",
      "left",
      "left|right",
      // this is the default value of list-style-type, see comment in configuration.js
      "right"
    ],
    "text-decoration": [
      "line-through",
      "none",
      "overline",
      "underline"
    ],
    "text-overflow": [
      "clip",
      "ellipsis"
    ],
    top: [
      "auto"
    ],
    "vertical-align": [
      "baseline",
      "bottom",
      "middle",
      "sub",
      "super",
      "text-bottom",
      "text-top",
      "top"
    ],
    visibility: [
      "collapse",
      "hidden",
      "visible"
    ],
    "white-space": [
      "normal",
      "nowrap",
      "pre"
    ],
    width: [
      "inherit",
      "initial",
      "medium",
      "thick",
      "thin"
    ]
  }, Sat = [
    "%",
    "ch",
    "cm",
    "em",
    "ex",
    "in",
    "mm",
    "pc",
    "pt",
    "px",
    "rem",
    "vh",
    "vm",
    "vmax",
    "vmin",
    "vw"
  ];
  function Tat(e) {
    return e != "auto" && (Gr("color")(e) || Aat(e) || _ee(e) || wat(e));
  }
  s(Tat, "isColor");
  function _ee(e) {
    return See(e) || vee(e);
  }
  s(_ee, "isColorFunction");
  function Eat(e) {
    return Zst.test(e);
  }
  s(Eat, "isDynamicUnit");
  function bee(e) {
    return tat.test(e);
  }
  s(bee, "isFunction");
  function Aat(e) {
    return bat.test(e) || gat.test(e) || _at.test(e) || yat.test(e);
  }
  s(Aat, "isHexColor");
  function vee(e) {
    return iat.test(e) || nat.test(e);
  }
  s(vee, "isHslColor");
  function xat(e) {
    return rat.test(e);
  }
  s(xat, "isHexAlphaColor");
  function Cat(e) {
    return sat.test(e);
  }
  s(Cat, "isIdentifier");
  function Pat(e) {
    return uat.test(e);
  }
  s(Pat, "isQuotedText");
  function Dat(e) {
    return e == "none" || e == "inherit" || Tee(e);
  }
  s(Dat, "isImage");
  function Gr(e) {
    return function(t) {
      return vat[e].indexOf(t) > -1;
    };
  }
  s(Gr, "isKeyword");
  function wat(e) {
    return aat.test(e);
  }
  s(wat, "isNamedEntity");
  function CO(e) {
    return PO(e) == e.length;
  }
  s(CO, "isNumber");
  function See(e) {
    return lat.test(e) || cat.test(e);
  }
  s(See, "isRgbColor");
  function Oat(e) {
    return oat.test(e);
  }
  s(Oat, "isPrefixed");
  function kat(e) {
    return CO(e) && parseFloat(e) >= 0;
  }
  s(kat, "isPositiveNumber");
  function Iat(e) {
    return mat.test(e);
  }
  s(Iat, "isVariable");
  function Rat(e) {
    var t = PO(e);
    return t == e.length && parseInt(e) === 0 || t > -1 && hat.indexOf(e.slice(t + 1)) > -1 || Nat(e);
  }
  s(Rat, "isTime");
  function Nat(e) {
    return bee(e) && fat.test(e);
  }
  s(Nat, "isCalculatedTime");
  function Lat() {
    var e = Gr("*-timing-function");
    return function(t) {
      return e(t) || pat.test(t);
    };
  }
  s(Lat, "isTimingFunction");
  function Fat(e, t) {
    var r = PO(t);
    return r == t.length && parseInt(t) === 0 || r > -1 && e.indexOf(t.slice(r + 1).toLowerCase()) > -1 || t == "auto" || t == "inherit";
  }
  s(Fat, "isUnit");
  function Tee(e) {
    return dat.test(e);
  }
  s(Tee, "isUrl");
  function Mat(e) {
    return e == "auto" || CO(e) || Gr("^")(e);
  }
  s(Mat, "isZIndex");
  function PO(e) {
    var t = !1, r = !1, i, n, a;
    for (n = 0, a = e.length; n < a; n++)
      if (i = e[n], n === 0 && (i == yee || i == mee))
        r = !0;
      else {
        if (n > 0 && r && (i == yee || i == mee))
          return n - 1;
        if (i == dee && !t)
          t = !0;
        else {
          if (i == dee && t)
            return n - 1;
          if (eat.test(i))
            continue;
          return n - 1;
        }
      }
    return n;
  }
  s(PO, "scanForNumber");
  function Bat(e) {
    var t = Sat.slice(0).filter(function(r) {
      return !(r in e.units) || e.units[r] === !0;
    });
    return e.customUnits.rpx && t.push("rpx"), {
      colorOpacity: e.colors.opacity,
      colorHexAlpha: e.colors.hexAlpha,
      isAnimationDirectionKeyword: Gr("animation-direction"),
      isAnimationFillModeKeyword: Gr("animation-fill-mode"),
      isAnimationIterationCountKeyword: Gr("animation-iteration-count"),
      isAnimationNameKeyword: Gr("animation-name"),
      isAnimationPlayStateKeyword: Gr("animation-play-state"),
      isTimingFunction: Lat(),
      isBackgroundAttachmentKeyword: Gr("background-attachment"),
      isBackgroundClipKeyword: Gr("background-clip"),
      isBackgroundOriginKeyword: Gr("background-origin"),
      isBackgroundPositionKeyword: Gr("background-position"),
      isBackgroundRepeatKeyword: Gr("background-repeat"),
      isBackgroundSizeKeyword: Gr("background-size"),
      isColor: Tat,
      isColorFunction: _ee,
      isDynamicUnit: Eat,
      isFontKeyword: Gr("font"),
      isFontSizeKeyword: Gr("font-size"),
      isFontStretchKeyword: Gr("font-stretch"),
      isFontStyleKeyword: Gr("font-style"),
      isFontVariantKeyword: Gr("font-variant"),
      isFontWeightKeyword: Gr("font-weight"),
      isFunction: bee,
      isGlobal: Gr("^"),
      isHexAlphaColor: xat,
      isHslColor: vee,
      isIdentifier: Cat,
      isImage: Dat,
      isKeyword: Gr,
      isLineHeightKeyword: Gr("line-height"),
      isListStylePositionKeyword: Gr("list-style-position"),
      isListStyleTypeKeyword: Gr("list-style-type"),
      isNumber: CO,
      isPrefixed: Oat,
      isPositiveNumber: kat,
      isQuotedText: Pat,
      isRgbColor: See,
      isStyleKeyword: Gr("*-style"),
      isTime: Rat,
      isUnit: Fat.bind(null, t),
      isUrl: Tee,
      isVariable: Iat,
      isWidth: Gr("width"),
      isZIndex: Mat
    };
  }
  s(Bat, "validator");
  Eee.exports = Bat;
});

// ../node_modules/clean-css/lib/options/compatibility.js
var Cee = b((NMt, xee) => {
  var Qn = {
    "*": {
      colors: {
        hexAlpha: !1,
        // 4- and 8-character hex notation
        opacity: !0
        // rgba / hsla
      },
      customUnits: { rpx: !1 },
      properties: {
        backgroundClipMerging: !0,
        // background-clip to shorthand
        backgroundOriginMerging: !0,
        // background-origin to shorthand
        backgroundSizeMerging: !0,
        // background-size to shorthand
        colors: !0,
        // any kind of color transformations, like `#ff00ff` to `#f0f` or `#fff` into `red`
        ieBangHack: !1,
        // !ie suffix hacks on IE<8
        ieFilters: !1,
        // whether to preserve `filter` and `-ms-filter` properties
        iePrefixHack: !1,
        // underscore / asterisk prefix hacks on IE
        ieSuffixHack: !1,
        // \9 suffix hacks on IE6-9, \0 suffix hack on IE6-11
        merging: !0,
        // merging properties into one
        shorterLengthUnits: !1,
        // optimize pixel units into `pt`, `pc` or `in` units
        spaceAfterClosingBrace: !0,
        // 'url() no-repeat' to 'url()no-repeat'
        urlQuotes: !0,
        // whether to wrap content of `url()` into quotes or not
        zeroUnits: !0
        // 0[unit] -> 0
      },
      selectors: {
        adjacentSpace: !1,
        // div+ nav Android stock browser hack
        ie7Hack: !1,
        // *+html hack
        mergeablePseudoClasses: [
          ":active",
          ":after",
          ":before",
          ":empty",
          ":checked",
          ":disabled",
          ":empty",
          ":enabled",
          ":first-child",
          ":first-letter",
          ":first-line",
          ":first-of-type",
          ":focus",
          ":hover",
          ":lang",
          ":last-child",
          ":last-of-type",
          ":link",
          ":not",
          ":nth-child",
          ":nth-last-child",
          ":nth-last-of-type",
          ":nth-of-type",
          ":only-child",
          ":only-of-type",
          ":root",
          ":target",
          ":visited"
        ],
        // selectors with these pseudo-classes can be merged as these are universally supported
        mergeablePseudoElements: [
          "::after",
          "::before",
          "::first-letter",
          "::first-line"
        ],
        // selectors with these pseudo-elements can be merged as these are universally supported
        mergeLimit: 8191,
        // number of rules that can be safely merged together
        multiplePseudoMerging: !0
      },
      units: {
        ch: !0,
        in: !0,
        pc: !0,
        pt: !0,
        rem: !0,
        vh: !0,
        vm: !0,
        // vm is vmin on IE9+ see https://developer.mozilla.org/en-US/docs/Web/CSS/length
        vmax: !0,
        vmin: !0,
        vw: !0
      }
    }
  };
  Qn.ie11 = Ol(Qn["*"], { properties: { ieSuffixHack: !0 } });
  Qn.ie10 = Ol(Qn["*"], { properties: { ieSuffixHack: !0 } });
  Qn.ie9 = Ol(Qn["*"], {
    properties: {
      ieFilters: !0,
      ieSuffixHack: !0
    }
  });
  Qn.ie8 = Ol(Qn.ie9, {
    colors: { opacity: !1 },
    properties: {
      backgroundClipMerging: !1,
      backgroundOriginMerging: !1,
      backgroundSizeMerging: !1,
      iePrefixHack: !0,
      merging: !1
    },
    selectors: {
      mergeablePseudoClasses: [
        ":after",
        ":before",
        ":first-child",
        ":first-letter",
        ":focus",
        ":hover",
        ":visited"
      ],
      mergeablePseudoElements: []
    },
    units: {
      ch: !1,
      rem: !1,
      vh: !1,
      vm: !1,
      vmax: !1,
      vmin: !1,
      vw: !1
    }
  });
  Qn.ie7 = Ol(Qn.ie8, {
    properties: { ieBangHack: !0 },
    selectors: {
      ie7Hack: !0,
      mergeablePseudoClasses: [
        ":first-child",
        ":first-letter",
        ":hover",
        ":visited"
      ]
    }
  });
  function qat(e) {
    return Ol(Qn["*"], Uat(e));
  }
  s(qat, "compatibilityFrom");
  function Ol(e, t) {
    for (var r in e)
      if (Object.prototype.hasOwnProperty.call(e, r)) {
        var i = e[r];
        Object.prototype.hasOwnProperty.call(t, r) && typeof i == "object" && !Array.isArray(i) ? t[r] = Ol(i, t[r] || {}) : t[r] = r in t ?
        t[r] : i;
      }
    return t;
  }
  s(Ol, "merge");
  function Uat(e) {
    if (typeof e == "object")
      return e;
    if (!/[,+-]/.test(e))
      return Qn[e] || Qn["*"];
    var t = e.split(","), r = t[0] in Qn ? Qn[t.shift()] : Qn["*"];
    return e = {}, t.forEach(function(i) {
      var n = i[0] == "+", a = i.substring(1).split("."), o = a[0], u = a[1];
      e[o] = e[o] || {}, e[o][u] = n;
    }), Ol(r, e);
  }
  s(Uat, "calculateSource");
  xee.exports = qat;
});

// ../node_modules/clean-css/lib/utils/is-http-resource.js
var Dee = b((FMt, Pee) => {
  var jat = /^http:\/\//;
  function Vat(e) {
    return jat.test(e);
  }
  s(Vat, "isHttpResource");
  Pee.exports = Vat;
});

// ../node_modules/clean-css/lib/utils/is-https-resource.js
var Oee = b((BMt, wee) => {
  var Kat = /^https:\/\//;
  function Hat(e) {
    return Kat.test(e);
  }
  s(Hat, "isHttpsResource");
  wee.exports = Hat;
});

// ../node_modules/clean-css/lib/reader/load-remote-resource.js
var Nee = b((UMt, Ree) => {
  var zat = require("http"), Gat = require("https"), kee = require("url"), Wat = Dee(), $at = Oee(), Xat = Nc(), Yat = "http:";
  function Iee(e, t, r, i) {
    var n = t.protocol || t.hostname, a = !1, o, u;
    o = Xat(
      kee.parse(e),
      t || {}
    ), t.hostname !== void 0 && (o.protocol = t.protocol || Yat, o.path = o.href), u = n && !$at(n) || Wat(e) ? zat.get : Gat.get, u(o, function(l) {
      var c = [], p;
      if (!a) {
        if (l.statusCode < 200 || l.statusCode > 399)
          return i(l.statusCode, null);
        if (l.statusCode > 299)
          return p = kee.resolve(e, l.headers.location), Iee(p, t, r, i);
        l.on("data", function(h) {
          c.push(h.toString());
        }), l.on("end", function() {
          var h = c.join("");
          i(null, h);
        });
      }
    }).on("error", function(l) {
      a || (a = !0, i(l.message, null));
    }).on("timeout", function() {
      a || (a = !0, i("timeout", null));
    }).setTimeout(r);
  }
  s(Iee, "loadRemoteResource");
  Ree.exports = Iee;
});

// ../node_modules/clean-css/lib/options/fetch.js
var Fee = b((VMt, Lee) => {
  var Jat = Nee();
  function Qat(e) {
    return e || Jat;
  }
  s(Qat, "fetchFrom");
  Lee.exports = Qat;
});

// ../node_modules/clean-css/lib/options/inline.js
var Bee = b((HMt, Mee) => {
  function Zat(e) {
    return Array.isArray(e) ? e : e === !1 ? ["none"] : e === void 0 ? ["local"] : e.split(",");
  }
  s(Zat, "inlineOptionsFrom");
  Mee.exports = Zat;
});

// ../node_modules/clean-css/lib/options/inline-request.js
var jee = b((GMt, Uee) => {
  var qee = require("url"), eot = Nc();
  function tot(e) {
    return eot(
      /* jshint camelcase: false */
      rot(process.env.HTTP_PROXY || process.env.http_proxy),
      e || {}
    );
  }
  s(tot, "inlineRequestFrom");
  function rot(e) {
    return e ? {
      hostname: qee.parse(e).hostname,
      port: parseInt(qee.parse(e).port)
    } : {};
  }
  s(rot, "proxyOptionsFrom");
  Uee.exports = tot;
});

// ../node_modules/clean-css/lib/options/inline-timeout.js
var Kee = b(($Mt, Vee) => {
  var iot = 5e3;
  function not(e) {
    return e || iot;
  }
  s(not, "inlineTimeoutFrom");
  Vee.exports = not;
});

// ../node_modules/clean-css/lib/options/plugins.js
var zee = b((YMt, Hee) => {
  function sot(e) {
    var t = {
      level1Value: [],
      level1Property: [],
      level2Block: []
    };
    return e = e || [], t.level1Value = e.map(function(r) {
      return r.level1 && r.level1.value;
    }).filter(function(r) {
      return r != null;
    }), t.level1Property = e.map(function(r) {
      return r.level1 && r.level1.property;
    }).filter(function(r) {
      return r != null;
    }), t.level2Block = e.map(function(r) {
      return r.level2 && r.level2.block;
    }).filter(function(r) {
      return r != null;
    }), t;
  }
  s(sot, "pluginsFrom");
  Hee.exports = sot;
});

// ../node_modules/clean-css/lib/options/rebase.js
var Wee = b((QMt, Gee) => {
  function aot(e, t) {
    return t !== void 0 ? !0 : e === void 0 ? !1 : !!e;
  }
  s(aot, "rebaseFrom");
  Gee.exports = aot;
});

// ../node_modules/clean-css/lib/options/rebase-to.js
var Xee = b((eBt, $ee) => {
  var oot = require("path");
  function uot(e) {
    return e ? oot.resolve(e) : process.cwd();
  }
  s(uot, "rebaseToFrom");
  $ee.exports = uot;
});

// ../node_modules/clean-css/node_modules/source-map/lib/base64.js
var Jee = b((DO) => {
  var Yee = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
  DO.encode = function(e) {
    if (0 <= e && e < Yee.length)
      return Yee[e];
    throw new TypeError("Must be between 0 and 63: " + e);
  };
  DO.decode = function(e) {
    var t = 65, r = 90, i = 97, n = 122, a = 48, o = 57, u = 43, l = 47, c = 26, p = 52;
    return t <= e && e <= r ? e - t : i <= e && e <= n ? e - i + c : a <= e && e <= o ? e - a + p : e == u ? 62 : e == l ? 63 : -1;
  };
});

// ../node_modules/clean-css/node_modules/source-map/lib/base64-vlq.js
var kO = b((OO) => {
  var Qee = Jee(), wO = 5, Zee = 1 << wO, ete = Zee - 1, tte = Zee;
  function lot(e) {
    return e < 0 ? (-e << 1) + 1 : (e << 1) + 0;
  }
  s(lot, "toVLQSigned");
  function cot(e) {
    var t = (e & 1) === 1, r = e >> 1;
    return t ? -r : r;
  }
  s(cot, "fromVLQSigned");
  OO.encode = /* @__PURE__ */ s(function(t) {
    var r = "", i, n = lot(t);
    do
      i = n & ete, n >>>= wO, n > 0 && (i |= tte), r += Qee.encode(i);
    while (n > 0);
    return r;
  }, "base64VLQ_encode");
  OO.decode = /* @__PURE__ */ s(function(t, r, i) {
    var n = t.length, a = 0, o = 0, u, l;
    do {
      if (r >= n)
        throw new Error("Expected more digits in base 64 VLQ value.");
      if (l = Qee.decode(t.charCodeAt(r++)), l === -1)
        throw new Error("Invalid base64 digit: " + t.charAt(r - 1));
      u = !!(l & tte), l &= ete, a = a + (l << o), o += wO;
    } while (u);
    i.value = cot(a), i.rest = r;
  }, "base64VLQ_decode");
});

// ../node_modules/clean-css/node_modules/source-map/lib/util.js
var zp = b((Zn) => {
  function fot(e, t, r) {
    if (t in e)
      return e[t];
    if (arguments.length === 3)
      return r;
    throw new Error('"' + t + '" is a required argument.');
  }
  s(fot, "getArg");
  Zn.getArg = fot;
  var rte = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/, pot = /^data:.+\,.+$/;
  function Lm(e) {
    var t = e.match(rte);
    return t ? {
      scheme: t[1],
      auth: t[2],
      host: t[3],
      port: t[4],
      path: t[5]
    } : null;
  }
  s(Lm, "urlParse");
  Zn.urlParse = Lm;
  function Kp(e) {
    var t = "";
    return e.scheme && (t += e.scheme + ":"), t += "//", e.auth && (t += e.auth + "@"), e.host && (t += e.host), e.port && (t += ":" + e.port),
    e.path && (t += e.path), t;
  }
  s(Kp, "urlGenerate");
  Zn.urlGenerate = Kp;
  function IO(e) {
    var t = e, r = Lm(e);
    if (r) {
      if (!r.path)
        return e;
      t = r.path;
    }
    for (var i = Zn.isAbsolute(t), n = t.split(/\/+/), a, o = 0, u = n.length - 1; u >= 0; u--)
      a = n[u], a === "." ? n.splice(u, 1) : a === ".." ? o++ : o > 0 && (a === "" ? (n.splice(u + 1, o), o = 0) : (n.splice(u, 2), o--));
    return t = n.join("/"), t === "" && (t = i ? "/" : "."), r ? (r.path = t, Kp(r)) : t;
  }
  s(IO, "normalize");
  Zn.normalize = IO;
  function ite(e, t) {
    e === "" && (e = "."), t === "" && (t = ".");
    var r = Lm(t), i = Lm(e);
    if (i && (e = i.path || "/"), r && !r.scheme)
      return i && (r.scheme = i.scheme), Kp(r);
    if (r || t.match(pot))
      return t;
    if (i && !i.host && !i.path)
      return i.host = t, Kp(i);
    var n = t.charAt(0) === "/" ? t : IO(e.replace(/\/+$/, "") + "/" + t);
    return i ? (i.path = n, Kp(i)) : n;
  }
  s(ite, "join");
  Zn.join = ite;
  Zn.isAbsolute = function(e) {
    return e.charAt(0) === "/" || rte.test(e);
  };
  function hot(e, t) {
    e === "" && (e = "."), e = e.replace(/\/$/, "");
    for (var r = 0; t.indexOf(e + "/") !== 0; ) {
      var i = e.lastIndexOf("/");
      if (i < 0 || (e = e.slice(0, i), e.match(/^([^\/]+:\/)?\/*$/)))
        return t;
      ++r;
    }
    return Array(r + 1).join("../") + t.substr(e.length + 1);
  }
  s(hot, "relative");
  Zn.relative = hot;
  var nte = function() {
    var e = /* @__PURE__ */ Object.create(null);
    return !("__proto__" in e);
  }();
  function ste(e) {
    return e;
  }
  s(ste, "identity");
  function dot(e) {
    return ate(e) ? "$" + e : e;
  }
  s(dot, "toSetString");
  Zn.toSetString = nte ? ste : dot;
  function mot(e) {
    return ate(e) ? e.slice(1) : e;
  }
  s(mot, "fromSetString");
  Zn.fromSetString = nte ? ste : mot;
  function ate(e) {
    if (!e)
      return !1;
    var t = e.length;
    if (t < 9 || e.charCodeAt(t - 1) !== 95 || e.charCodeAt(t - 2) !== 95 || e.charCodeAt(t - 3) !== 111 || e.charCodeAt(t - 4) !== 116 || e.
    charCodeAt(t - 5) !== 111 || e.charCodeAt(t - 6) !== 114 || e.charCodeAt(t - 7) !== 112 || e.charCodeAt(t - 8) !== 95 || e.charCodeAt(t -
    9) !== 95)
      return !1;
    for (var r = t - 10; r >= 0; r--)
      if (e.charCodeAt(r) !== 36)
        return !1;
    return !0;
  }
  s(ate, "isProtoString");
  function yot(e, t, r) {
    var i = Hp(e.source, t.source);
    return i !== 0 || (i = e.originalLine - t.originalLine, i !== 0) || (i = e.originalColumn - t.originalColumn, i !== 0 || r) || (i = e.generatedColumn -
    t.generatedColumn, i !== 0) || (i = e.generatedLine - t.generatedLine, i !== 0) ? i : Hp(e.name, t.name);
  }
  s(yot, "compareByOriginalPositions");
  Zn.compareByOriginalPositions = yot;
  function got(e, t, r) {
    var i = e.generatedLine - t.generatedLine;
    return i !== 0 || (i = e.generatedColumn - t.generatedColumn, i !== 0 || r) || (i = Hp(e.source, t.source), i !== 0) || (i = e.originalLine -
    t.originalLine, i !== 0) || (i = e.originalColumn - t.originalColumn, i !== 0) ? i : Hp(e.name, t.name);
  }
  s(got, "compareByGeneratedPositionsDeflated");
  Zn.compareByGeneratedPositionsDeflated = got;
  function Hp(e, t) {
    return e === t ? 0 : e === null ? 1 : t === null ? -1 : e > t ? 1 : -1;
  }
  s(Hp, "strcmp");
  function _ot(e, t) {
    var r = e.generatedLine - t.generatedLine;
    return r !== 0 || (r = e.generatedColumn - t.generatedColumn, r !== 0) || (r = Hp(e.source, t.source), r !== 0) || (r = e.originalLine -
    t.originalLine, r !== 0) || (r = e.originalColumn - t.originalColumn, r !== 0) ? r : Hp(e.name, t.name);
  }
  s(_ot, "compareByGeneratedPositionsInflated");
  Zn.compareByGeneratedPositionsInflated = _ot;
  function bot(e) {
    return JSON.parse(e.replace(/^\)]}'[^\n]*\n/, ""));
  }
  s(bot, "parseSourceMapInput");
  Zn.parseSourceMapInput = bot;
  function vot(e, t, r) {
    if (t = t || "", e && (e[e.length - 1] !== "/" && t[0] !== "/" && (e += "/"), t = e + t), r) {
      var i = Lm(r);
      if (!i)
        throw new Error("sourceMapURL could not be parsed");
      if (i.path) {
        var n = i.path.lastIndexOf("/");
        n >= 0 && (i.path = i.path.substring(0, n + 1));
      }
      t = ite(Kp(i), t);
    }
    return IO(t);
  }
  s(vot, "computeSourceURL");
  Zn.computeSourceURL = vot;
});

// ../node_modules/clean-css/node_modules/source-map/lib/array-set.js
var LO = b((ote) => {
  var RO = zp(), NO = Object.prototype.hasOwnProperty, Hc = typeof Map < "u";
  function Iu() {
    this._array = [], this._set = Hc ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
  }
  s(Iu, "ArraySet");
  Iu.fromArray = /* @__PURE__ */ s(function(t, r) {
    for (var i = new Iu(), n = 0, a = t.length; n < a; n++)
      i.add(t[n], r);
    return i;
  }, "ArraySet_fromArray");
  Iu.prototype.size = /* @__PURE__ */ s(function() {
    return Hc ? this._set.size : Object.getOwnPropertyNames(this._set).length;
  }, "ArraySet_size");
  Iu.prototype.add = /* @__PURE__ */ s(function(t, r) {
    var i = Hc ? t : RO.toSetString(t), n = Hc ? this.has(t) : NO.call(this._set, i), a = this._array.length;
    (!n || r) && this._array.push(t), n || (Hc ? this._set.set(t, a) : this._set[i] = a);
  }, "ArraySet_add");
  Iu.prototype.has = /* @__PURE__ */ s(function(t) {
    if (Hc)
      return this._set.has(t);
    var r = RO.toSetString(t);
    return NO.call(this._set, r);
  }, "ArraySet_has");
  Iu.prototype.indexOf = /* @__PURE__ */ s(function(t) {
    if (Hc) {
      var r = this._set.get(t);
      if (r >= 0)
        return r;
    } else {
      var i = RO.toSetString(t);
      if (NO.call(this._set, i))
        return this._set[i];
    }
    throw new Error('"' + t + '" is not in the set.');
  }, "ArraySet_indexOf");
  Iu.prototype.at = /* @__PURE__ */ s(function(t) {
    if (t >= 0 && t < this._array.length)
      return this._array[t];
    throw new Error("No element indexed by " + t);
  }, "ArraySet_at");
  Iu.prototype.toArray = /* @__PURE__ */ s(function() {
    return this._array.slice();
  }, "ArraySet_toArray");
  ote.ArraySet = Iu;
});

// ../node_modules/clean-css/node_modules/source-map/lib/mapping-list.js
var cte = b((lte) => {
  var ute = zp();
  function Sot(e, t) {
    var r = e.generatedLine, i = t.generatedLine, n = e.generatedColumn, a = t.generatedColumn;
    return i > r || i == r && a >= n || ute.compareByGeneratedPositionsInflated(e, t) <= 0;
  }
  s(Sot, "generatedPositionAfter");
  function PS() {
    this._array = [], this._sorted = !0, this._last = { generatedLine: -1, generatedColumn: 0 };
  }
  s(PS, "MappingList");
  PS.prototype.unsortedForEach = /* @__PURE__ */ s(function(t, r) {
    this._array.forEach(t, r);
  }, "MappingList_forEach");
  PS.prototype.add = /* @__PURE__ */ s(function(t) {
    Sot(this._last, t) ? (this._last = t, this._array.push(t)) : (this._sorted = !1, this._array.push(t));
  }, "MappingList_add");
  PS.prototype.toArray = /* @__PURE__ */ s(function() {
    return this._sorted || (this._array.sort(ute.compareByGeneratedPositionsInflated), this._sorted = !0), this._array;
  }, "MappingList_toArray");
  lte.MappingList = PS;
});

// ../node_modules/clean-css/node_modules/source-map/lib/source-map-generator.js
var FO = b((fte) => {
  var Fm = kO(), tn = zp(), DS = LO().ArraySet, Tot = cte().MappingList;
  function Oa(e) {
    e || (e = {}), this._file = tn.getArg(e, "file", null), this._sourceRoot = tn.getArg(e, "sourceRoot", null), this._skipValidation = tn.getArg(
    e, "skipValidation", !1), this._sources = new DS(), this._names = new DS(), this._mappings = new Tot(), this._sourcesContents = null;
  }
  s(Oa, "SourceMapGenerator");
  Oa.prototype._version = 3;
  Oa.fromSourceMap = /* @__PURE__ */ s(function(t) {
    var r = t.sourceRoot, i = new Oa({
      file: t.file,
      sourceRoot: r
    });
    return t.eachMapping(function(n) {
      var a = {
        generated: {
          line: n.generatedLine,
          column: n.generatedColumn
        }
      };
      n.source != null && (a.source = n.source, r != null && (a.source = tn.relative(r, a.source)), a.original = {
        line: n.originalLine,
        column: n.originalColumn
      }, n.name != null && (a.name = n.name)), i.addMapping(a);
    }), t.sources.forEach(function(n) {
      var a = n;
      r !== null && (a = tn.relative(r, n)), i._sources.has(a) || i._sources.add(a);
      var o = t.sourceContentFor(n);
      o != null && i.setSourceContent(n, o);
    }), i;
  }, "SourceMapGenerator_fromSourceMap");
  Oa.prototype.addMapping = /* @__PURE__ */ s(function(t) {
    var r = tn.getArg(t, "generated"), i = tn.getArg(t, "original", null), n = tn.getArg(t, "source", null), a = tn.getArg(t, "name", null);
    this._skipValidation || this._validateMapping(r, i, n, a), n != null && (n = String(n), this._sources.has(n) || this._sources.add(n)), a !=
    null && (a = String(a), this._names.has(a) || this._names.add(a)), this._mappings.add({
      generatedLine: r.line,
      generatedColumn: r.column,
      originalLine: i != null && i.line,
      originalColumn: i != null && i.column,
      source: n,
      name: a
    });
  }, "SourceMapGenerator_addMapping");
  Oa.prototype.setSourceContent = /* @__PURE__ */ s(function(t, r) {
    var i = t;
    this._sourceRoot != null && (i = tn.relative(this._sourceRoot, i)), r != null ? (this._sourcesContents || (this._sourcesContents = /* @__PURE__ */ Object.
    create(null)), this._sourcesContents[tn.toSetString(i)] = r) : this._sourcesContents && (delete this._sourcesContents[tn.toSetString(i)],
    Object.keys(this._sourcesContents).length === 0 && (this._sourcesContents = null));
  }, "SourceMapGenerator_setSourceContent");
  Oa.prototype.applySourceMap = /* @__PURE__ */ s(function(t, r, i) {
    var n = r;
    if (r == null) {
      if (t.file == null)
        throw new Error(
          `SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both we\
re omitted.`
        );
      n = t.file;
    }
    var a = this._sourceRoot;
    a != null && (n = tn.relative(a, n));
    var o = new DS(), u = new DS();
    this._mappings.unsortedForEach(function(l) {
      if (l.source === n && l.originalLine != null) {
        var c = t.originalPositionFor({
          line: l.originalLine,
          column: l.originalColumn
        });
        c.source != null && (l.source = c.source, i != null && (l.source = tn.join(i, l.source)), a != null && (l.source = tn.relative(a, l.
        source)), l.originalLine = c.line, l.originalColumn = c.column, c.name != null && (l.name = c.name));
      }
      var p = l.source;
      p != null && !o.has(p) && o.add(p);
      var h = l.name;
      h != null && !u.has(h) && u.add(h);
    }, this), this._sources = o, this._names = u, t.sources.forEach(function(l) {
      var c = t.sourceContentFor(l);
      c != null && (i != null && (l = tn.join(i, l)), a != null && (l = tn.relative(a, l)), this.setSourceContent(l, c));
    }, this);
  }, "SourceMapGenerator_applySourceMap");
  Oa.prototype._validateMapping = /* @__PURE__ */ s(function(t, r, i, n) {
    if (r && typeof r.line != "number" && typeof r.column != "number")
      throw new Error(
        "original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the gene\
rated position. If so, pass null for the original mapping instead of an object with empty or null values."
      );
    if (!(t && "line" in t && "column" in t && t.line > 0 && t.column >= 0 && !r && !i && !n)) {
      if (t && "line" in t && "column" in t && r && "line" in r && "column" in r && t.line > 0 && t.column >= 0 && r.line > 0 && r.column >=
      0 && i)
        return;
      throw new Error("Invalid mapping: " + JSON.stringify({
        generated: t,
        source: i,
        original: r,
        name: n
      }));
    }
  }, "SourceMapGenerator_validateMapping");
  Oa.prototype._serializeMappings = /* @__PURE__ */ s(function() {
    for (var t = 0, r = 1, i = 0, n = 0, a = 0, o = 0, u = "", l, c, p, h, y = this._mappings.toArray(), _ = 0, g = y.length; _ < g; _++) {
      if (c = y[_], l = "", c.generatedLine !== r)
        for (t = 0; c.generatedLine !== r; )
          l += ";", r++;
      else if (_ > 0) {
        if (!tn.compareByGeneratedPositionsInflated(c, y[_ - 1]))
          continue;
        l += ",";
      }
      l += Fm.encode(c.generatedColumn - t), t = c.generatedColumn, c.source != null && (h = this._sources.indexOf(c.source), l += Fm.encode(
      h - o), o = h, l += Fm.encode(c.originalLine - 1 - n), n = c.originalLine - 1, l += Fm.encode(c.originalColumn - i), i = c.originalColumn,
      c.name != null && (p = this._names.indexOf(c.name), l += Fm.encode(p - a), a = p)), u += l;
    }
    return u;
  }, "SourceMapGenerator_serializeMappings");
  Oa.prototype._generateSourcesContent = /* @__PURE__ */ s(function(t, r) {
    return t.map(function(i) {
      if (!this._sourcesContents)
        return null;
      r != null && (i = tn.relative(r, i));
      var n = tn.toSetString(i);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, n) ? this._sourcesContents[n] : null;
    }, this);
  }, "SourceMapGenerator_generateSourcesContent");
  Oa.prototype.toJSON = /* @__PURE__ */ s(function() {
    var t = {
      version: this._version,
      sources: this._sources.toArray(),
      names: this._names.toArray(),
      mappings: this._serializeMappings()
    };
    return this._file != null && (t.file = this._file), this._sourceRoot != null && (t.sourceRoot = this._sourceRoot), this._sourcesContents &&
    (t.sourcesContent = this._generateSourcesContent(t.sources, t.sourceRoot)), t;
  }, "SourceMapGenerator_toJSON");
  Oa.prototype.toString = /* @__PURE__ */ s(function() {
    return JSON.stringify(this.toJSON());
  }, "SourceMapGenerator_toString");
  fte.SourceMapGenerator = Oa;
});

// ../node_modules/clean-css/node_modules/source-map/lib/binary-search.js
var pte = b((zc) => {
  zc.GREATEST_LOWER_BOUND = 1;
  zc.LEAST_UPPER_BOUND = 2;
  function MO(e, t, r, i, n, a) {
    var o = Math.floor((t - e) / 2) + e, u = n(r, i[o], !0);
    return u === 0 ? o : u > 0 ? t - o > 1 ? MO(o, t, r, i, n, a) : a == zc.LEAST_UPPER_BOUND ? t < i.length ? t : -1 : o : o - e > 1 ? MO(e,
    o, r, i, n, a) : a == zc.LEAST_UPPER_BOUND ? o : e < 0 ? -1 : e;
  }
  s(MO, "recursiveSearch");
  zc.search = /* @__PURE__ */ s(function(t, r, i, n) {
    if (r.length === 0)
      return -1;
    var a = MO(
      -1,
      r.length,
      t,
      r,
      i,
      n || zc.GREATEST_LOWER_BOUND
    );
    if (a < 0)
      return -1;
    for (; a - 1 >= 0 && i(r[a], r[a - 1], !0) === 0; )
      --a;
    return a;
  }, "search");
});

// ../node_modules/clean-css/node_modules/source-map/lib/quick-sort.js
var dte = b((hte) => {
  function BO(e, t, r) {
    var i = e[t];
    e[t] = e[r], e[r] = i;
  }
  s(BO, "swap");
  function Eot(e, t) {
    return Math.round(e + Math.random() * (t - e));
  }
  s(Eot, "randomIntInRange");
  function qO(e, t, r, i) {
    if (r < i) {
      var n = Eot(r, i), a = r - 1;
      BO(e, n, i);
      for (var o = e[i], u = r; u < i; u++)
        t(e[u], o) <= 0 && (a += 1, BO(e, a, u));
      BO(e, a + 1, u);
      var l = a + 1;
      qO(e, t, r, l - 1), qO(e, t, l + 1, i);
    }
  }
  s(qO, "doQuickSort");
  hte.quickSort = function(e, t) {
    qO(e, t, 0, e.length - 1);
  };
});

// ../node_modules/clean-css/node_modules/source-map/lib/source-map-consumer.js
var yte = b((wS) => {
  var tt = zp(), UO = pte(), Gp = LO().ArraySet, Aot = kO(), Mm = dte().quickSort;
  function li(e, t) {
    var r = e;
    return typeof e == "string" && (r = tt.parseSourceMapInput(e)), r.sections != null ? new no(r, t) : new Fn(r, t);
  }
  s(li, "SourceMapConsumer");
  li.fromSourceMap = function(e, t) {
    return Fn.fromSourceMap(e, t);
  };
  li.prototype._version = 3;
  li.prototype.__generatedMappings = null;
  Object.defineProperty(li.prototype, "_generatedMappings", {
    configurable: !0,
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return this.__generatedMappings || this._parseMappings(this._mappings, this.sourceRoot), this.__generatedMappings;
    }, "get")
  });
  li.prototype.__originalMappings = null;
  Object.defineProperty(li.prototype, "_originalMappings", {
    configurable: !0,
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return this.__originalMappings || this._parseMappings(this._mappings, this.sourceRoot), this.__originalMappings;
    }, "get")
  });
  li.prototype._charIsMappingSeparator = /* @__PURE__ */ s(function(t, r) {
    var i = t.charAt(r);
    return i === ";" || i === ",";
  }, "SourceMapConsumer_charIsMappingSeparator");
  li.prototype._parseMappings = /* @__PURE__ */ s(function(t, r) {
    throw new Error("Subclasses must implement _parseMappings");
  }, "SourceMapConsumer_parseMappings");
  li.GENERATED_ORDER = 1;
  li.ORIGINAL_ORDER = 2;
  li.GREATEST_LOWER_BOUND = 1;
  li.LEAST_UPPER_BOUND = 2;
  li.prototype.eachMapping = /* @__PURE__ */ s(function(t, r, i) {
    var n = r || null, a = i || li.GENERATED_ORDER, o;
    switch (a) {
      case li.GENERATED_ORDER:
        o = this._generatedMappings;
        break;
      case li.ORIGINAL_ORDER:
        o = this._originalMappings;
        break;
      default:
        throw new Error("Unknown order of iteration.");
    }
    var u = this.sourceRoot;
    o.map(function(l) {
      var c = l.source === null ? null : this._sources.at(l.source);
      return c = tt.computeSourceURL(u, c, this._sourceMapURL), {
        source: c,
        generatedLine: l.generatedLine,
        generatedColumn: l.generatedColumn,
        originalLine: l.originalLine,
        originalColumn: l.originalColumn,
        name: l.name === null ? null : this._names.at(l.name)
      };
    }, this).forEach(t, n);
  }, "SourceMapConsumer_eachMapping");
  li.prototype.allGeneratedPositionsFor = /* @__PURE__ */ s(function(t) {
    var r = tt.getArg(t, "line"), i = {
      source: tt.getArg(t, "source"),
      originalLine: r,
      originalColumn: tt.getArg(t, "column", 0)
    };
    if (i.source = this._findSourceIndex(i.source), i.source < 0)
      return [];
    var n = [], a = this._findMapping(
      i,
      this._originalMappings,
      "originalLine",
      "originalColumn",
      tt.compareByOriginalPositions,
      UO.LEAST_UPPER_BOUND
    );
    if (a >= 0) {
      var o = this._originalMappings[a];
      if (t.column === void 0)
        for (var u = o.originalLine; o && o.originalLine === u; )
          n.push({
            line: tt.getArg(o, "generatedLine", null),
            column: tt.getArg(o, "generatedColumn", null),
            lastColumn: tt.getArg(o, "lastGeneratedColumn", null)
          }), o = this._originalMappings[++a];
      else
        for (var l = o.originalColumn; o && o.originalLine === r && o.originalColumn == l; )
          n.push({
            line: tt.getArg(o, "generatedLine", null),
            column: tt.getArg(o, "generatedColumn", null),
            lastColumn: tt.getArg(o, "lastGeneratedColumn", null)
          }), o = this._originalMappings[++a];
    }
    return n;
  }, "SourceMapConsumer_allGeneratedPositionsFor");
  wS.SourceMapConsumer = li;
  function Fn(e, t) {
    var r = e;
    typeof e == "string" && (r = tt.parseSourceMapInput(e));
    var i = tt.getArg(r, "version"), n = tt.getArg(r, "sources"), a = tt.getArg(r, "names", []), o = tt.getArg(r, "sourceRoot", null), u = tt.
    getArg(r, "sourcesContent", null), l = tt.getArg(r, "mappings"), c = tt.getArg(r, "file", null);
    if (i != this._version)
      throw new Error("Unsupported version: " + i);
    o && (o = tt.normalize(o)), n = n.map(String).map(tt.normalize).map(function(p) {
      return o && tt.isAbsolute(o) && tt.isAbsolute(p) ? tt.relative(o, p) : p;
    }), this._names = Gp.fromArray(a.map(String), !0), this._sources = Gp.fromArray(n, !0), this._absoluteSources = this._sources.toArray().
    map(function(p) {
      return tt.computeSourceURL(o, p, t);
    }), this.sourceRoot = o, this.sourcesContent = u, this._mappings = l, this._sourceMapURL = t, this.file = c;
  }
  s(Fn, "BasicSourceMapConsumer");
  Fn.prototype = Object.create(li.prototype);
  Fn.prototype.consumer = li;
  Fn.prototype._findSourceIndex = function(e) {
    var t = e;
    if (this.sourceRoot != null && (t = tt.relative(this.sourceRoot, t)), this._sources.has(t))
      return this._sources.indexOf(t);
    var r;
    for (r = 0; r < this._absoluteSources.length; ++r)
      if (this._absoluteSources[r] == e)
        return r;
    return -1;
  };
  Fn.fromSourceMap = /* @__PURE__ */ s(function(t, r) {
    var i = Object.create(Fn.prototype), n = i._names = Gp.fromArray(t._names.toArray(), !0), a = i._sources = Gp.fromArray(t._sources.toArray(),
    !0);
    i.sourceRoot = t._sourceRoot, i.sourcesContent = t._generateSourcesContent(
      i._sources.toArray(),
      i.sourceRoot
    ), i.file = t._file, i._sourceMapURL = r, i._absoluteSources = i._sources.toArray().map(function(_) {
      return tt.computeSourceURL(i.sourceRoot, _, r);
    });
    for (var o = t._mappings.toArray().slice(), u = i.__generatedMappings = [], l = i.__originalMappings = [], c = 0, p = o.length; c < p; c++) {
      var h = o[c], y = new mte();
      y.generatedLine = h.generatedLine, y.generatedColumn = h.generatedColumn, h.source && (y.source = a.indexOf(h.source), y.originalLine =
      h.originalLine, y.originalColumn = h.originalColumn, h.name && (y.name = n.indexOf(h.name)), l.push(y)), u.push(y);
    }
    return Mm(i.__originalMappings, tt.compareByOriginalPositions), i;
  }, "SourceMapConsumer_fromSourceMap");
  Fn.prototype._version = 3;
  Object.defineProperty(Fn.prototype, "sources", {
    get: /* @__PURE__ */ s(function() {
      return this._absoluteSources.slice();
    }, "get")
  });
  function mte() {
    this.generatedLine = 0, this.generatedColumn = 0, this.source = null, this.originalLine = null, this.originalColumn = null, this.name = null;
  }
  s(mte, "Mapping");
  Fn.prototype._parseMappings = /* @__PURE__ */ s(function(t, r) {
    for (var i = 1, n = 0, a = 0, o = 0, u = 0, l = 0, c = t.length, p = 0, h = {}, y = {}, _ = [], g = [], m, f, d, v, E; p < c; )
      if (t.charAt(p) === ";")
        i++, p++, n = 0;
      else if (t.charAt(p) === ",")
        p++;
      else {
        for (m = new mte(), m.generatedLine = i, v = p; v < c && !this._charIsMappingSeparator(t, v); v++)
          ;
        if (f = t.slice(p, v), d = h[f], d)
          p += f.length;
        else {
          for (d = []; p < v; )
            Aot.decode(t, p, y), E = y.value, p = y.rest, d.push(E);
          if (d.length === 2)
            throw new Error("Found a source, but no line and column");
          if (d.length === 3)
            throw new Error("Found a source and line, but no column");
          h[f] = d;
        }
        m.generatedColumn = n + d[0], n = m.generatedColumn, d.length > 1 && (m.source = u + d[1], u += d[1], m.originalLine = a + d[2], a =
        m.originalLine, m.originalLine += 1, m.originalColumn = o + d[3], o = m.originalColumn, d.length > 4 && (m.name = l + d[4], l += d[4])),
        g.push(m), typeof m.originalLine == "number" && _.push(m);
      }
    Mm(g, tt.compareByGeneratedPositionsDeflated), this.__generatedMappings = g, Mm(_, tt.compareByOriginalPositions), this.__originalMappings =
    _;
  }, "SourceMapConsumer_parseMappings");
  Fn.prototype._findMapping = /* @__PURE__ */ s(function(t, r, i, n, a, o) {
    if (t[i] <= 0)
      throw new TypeError("Line must be greater than or equal to 1, got " + t[i]);
    if (t[n] < 0)
      throw new TypeError("Column must be greater than or equal to 0, got " + t[n]);
    return UO.search(t, r, a, o);
  }, "SourceMapConsumer_findMapping");
  Fn.prototype.computeColumnSpans = /* @__PURE__ */ s(function() {
    for (var t = 0; t < this._generatedMappings.length; ++t) {
      var r = this._generatedMappings[t];
      if (t + 1 < this._generatedMappings.length) {
        var i = this._generatedMappings[t + 1];
        if (r.generatedLine === i.generatedLine) {
          r.lastGeneratedColumn = i.generatedColumn - 1;
          continue;
        }
      }
      r.lastGeneratedColumn = 1 / 0;
    }
  }, "SourceMapConsumer_computeColumnSpans");
  Fn.prototype.originalPositionFor = /* @__PURE__ */ s(function(t) {
    var r = {
      generatedLine: tt.getArg(t, "line"),
      generatedColumn: tt.getArg(t, "column")
    }, i = this._findMapping(
      r,
      this._generatedMappings,
      "generatedLine",
      "generatedColumn",
      tt.compareByGeneratedPositionsDeflated,
      tt.getArg(t, "bias", li.GREATEST_LOWER_BOUND)
    );
    if (i >= 0) {
      var n = this._generatedMappings[i];
      if (n.generatedLine === r.generatedLine) {
        var a = tt.getArg(n, "source", null);
        a !== null && (a = this._sources.at(a), a = tt.computeSourceURL(this.sourceRoot, a, this._sourceMapURL));
        var o = tt.getArg(n, "name", null);
        return o !== null && (o = this._names.at(o)), {
          source: a,
          line: tt.getArg(n, "originalLine", null),
          column: tt.getArg(n, "originalColumn", null),
          name: o
        };
      }
    }
    return {
      source: null,
      line: null,
      column: null,
      name: null
    };
  }, "SourceMapConsumer_originalPositionFor");
  Fn.prototype.hasContentsOfAllSources = /* @__PURE__ */ s(function() {
    return this.sourcesContent ? this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(t) {
      return t == null;
    }) : !1;
  }, "BasicSourceMapConsumer_hasContentsOfAllSources");
  Fn.prototype.sourceContentFor = /* @__PURE__ */ s(function(t, r) {
    if (!this.sourcesContent)
      return null;
    var i = this._findSourceIndex(t);
    if (i >= 0)
      return this.sourcesContent[i];
    var n = t;
    this.sourceRoot != null && (n = tt.relative(this.sourceRoot, n));
    var a;
    if (this.sourceRoot != null && (a = tt.urlParse(this.sourceRoot))) {
      var o = n.replace(/^file:\/\//, "");
      if (a.scheme == "file" && this._sources.has(o))
        return this.sourcesContent[this._sources.indexOf(o)];
      if ((!a.path || a.path == "/") && this._sources.has("/" + n))
        return this.sourcesContent[this._sources.indexOf("/" + n)];
    }
    if (r)
      return null;
    throw new Error('"' + n + '" is not in the SourceMap.');
  }, "SourceMapConsumer_sourceContentFor");
  Fn.prototype.generatedPositionFor = /* @__PURE__ */ s(function(t) {
    var r = tt.getArg(t, "source");
    if (r = this._findSourceIndex(r), r < 0)
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    var i = {
      source: r,
      originalLine: tt.getArg(t, "line"),
      originalColumn: tt.getArg(t, "column")
    }, n = this._findMapping(
      i,
      this._originalMappings,
      "originalLine",
      "originalColumn",
      tt.compareByOriginalPositions,
      tt.getArg(t, "bias", li.GREATEST_LOWER_BOUND)
    );
    if (n >= 0) {
      var a = this._originalMappings[n];
      if (a.source === i.source)
        return {
          line: tt.getArg(a, "generatedLine", null),
          column: tt.getArg(a, "generatedColumn", null),
          lastColumn: tt.getArg(a, "lastGeneratedColumn", null)
        };
    }
    return {
      line: null,
      column: null,
      lastColumn: null
    };
  }, "SourceMapConsumer_generatedPositionFor");
  wS.BasicSourceMapConsumer = Fn;
  function no(e, t) {
    var r = e;
    typeof e == "string" && (r = tt.parseSourceMapInput(e));
    var i = tt.getArg(r, "version"), n = tt.getArg(r, "sections");
    if (i != this._version)
      throw new Error("Unsupported version: " + i);
    this._sources = new Gp(), this._names = new Gp();
    var a = {
      line: -1,
      column: 0
    };
    this._sections = n.map(function(o) {
      if (o.url)
        throw new Error("Support for url field in sections not implemented.");
      var u = tt.getArg(o, "offset"), l = tt.getArg(u, "line"), c = tt.getArg(u, "column");
      if (l < a.line || l === a.line && c < a.column)
        throw new Error("Section offsets must be ordered and non-overlapping.");
      return a = u, {
        generatedOffset: {
          // The offset fields are 0-based, but we use 1-based indices when
          // encoding/decoding from VLQ.
          generatedLine: l + 1,
          generatedColumn: c + 1
        },
        consumer: new li(tt.getArg(o, "map"), t)
      };
    });
  }
  s(no, "IndexedSourceMapConsumer");
  no.prototype = Object.create(li.prototype);
  no.prototype.constructor = li;
  no.prototype._version = 3;
  Object.defineProperty(no.prototype, "sources", {
    get: /* @__PURE__ */ s(function() {
      for (var e = [], t = 0; t < this._sections.length; t++)
        for (var r = 0; r < this._sections[t].consumer.sources.length; r++)
          e.push(this._sections[t].consumer.sources[r]);
      return e;
    }, "get")
  });
  no.prototype.originalPositionFor = /* @__PURE__ */ s(function(t) {
    var r = {
      generatedLine: tt.getArg(t, "line"),
      generatedColumn: tt.getArg(t, "column")
    }, i = UO.search(
      r,
      this._sections,
      function(a, o) {
        var u = a.generatedLine - o.generatedOffset.generatedLine;
        return u || a.generatedColumn - o.generatedOffset.generatedColumn;
      }
    ), n = this._sections[i];
    return n ? n.consumer.originalPositionFor({
      line: r.generatedLine - (n.generatedOffset.generatedLine - 1),
      column: r.generatedColumn - (n.generatedOffset.generatedLine === r.generatedLine ? n.generatedOffset.generatedColumn - 1 : 0),
      bias: t.bias
    }) : {
      source: null,
      line: null,
      column: null,
      name: null
    };
  }, "IndexedSourceMapConsumer_originalPositionFor");
  no.prototype.hasContentsOfAllSources = /* @__PURE__ */ s(function() {
    return this._sections.every(function(t) {
      return t.consumer.hasContentsOfAllSources();
    });
  }, "IndexedSourceMapConsumer_hasContentsOfAllSources");
  no.prototype.sourceContentFor = /* @__PURE__ */ s(function(t, r) {
    for (var i = 0; i < this._sections.length; i++) {
      var n = this._sections[i], a = n.consumer.sourceContentFor(t, !0);
      if (a)
        return a;
    }
    if (r)
      return null;
    throw new Error('"' + t + '" is not in the SourceMap.');
  }, "IndexedSourceMapConsumer_sourceContentFor");
  no.prototype.generatedPositionFor = /* @__PURE__ */ s(function(t) {
    for (var r = 0; r < this._sections.length; r++) {
      var i = this._sections[r];
      if (i.consumer._findSourceIndex(tt.getArg(t, "source")) !== -1) {
        var n = i.consumer.generatedPositionFor(t);
        if (n) {
          var a = {
            line: n.line + (i.generatedOffset.generatedLine - 1),
            column: n.column + (i.generatedOffset.generatedLine === n.line ? i.generatedOffset.generatedColumn - 1 : 0)
          };
          return a;
        }
      }
    }
    return {
      line: null,
      column: null
    };
  }, "IndexedSourceMapConsumer_generatedPositionFor");
  no.prototype._parseMappings = /* @__PURE__ */ s(function(t, r) {
    this.__generatedMappings = [], this.__originalMappings = [];
    for (var i = 0; i < this._sections.length; i++)
      for (var n = this._sections[i], a = n.consumer._generatedMappings, o = 0; o < a.length; o++) {
        var u = a[o], l = n.consumer._sources.at(u.source);
        l = tt.computeSourceURL(n.consumer.sourceRoot, l, this._sourceMapURL), this._sources.add(l), l = this._sources.indexOf(l);
        var c = null;
        u.name && (c = n.consumer._names.at(u.name), this._names.add(c), c = this._names.indexOf(c));
        var p = {
          source: l,
          generatedLine: u.generatedLine + (n.generatedOffset.generatedLine - 1),
          generatedColumn: u.generatedColumn + (n.generatedOffset.generatedLine === u.generatedLine ? n.generatedOffset.generatedColumn - 1 :
          0),
          originalLine: u.originalLine,
          originalColumn: u.originalColumn,
          name: c
        };
        this.__generatedMappings.push(p), typeof p.originalLine == "number" && this.__originalMappings.push(p);
      }
    Mm(this.__generatedMappings, tt.compareByGeneratedPositionsDeflated), Mm(this.__originalMappings, tt.compareByOriginalPositions);
  }, "IndexedSourceMapConsumer_parseMappings");
  wS.IndexedSourceMapConsumer = no;
});

// ../node_modules/clean-css/node_modules/source-map/lib/source-node.js
var _te = b((gte) => {
  var xot = FO().SourceMapGenerator, OS = zp(), Cot = /(\r?\n)/, Pot = 10, Wp = "$$$isSourceNode$$$";
  function sa(e, t, r, i, n) {
    this.children = [], this.sourceContents = {}, this.line = e ?? null, this.column = t ?? null, this.source = r ?? null, this.name = n ?? null,
    this[Wp] = !0, i != null && this.add(i);
  }
  s(sa, "SourceNode");
  sa.fromStringWithSourceMap = /* @__PURE__ */ s(function(t, r, i) {
    var n = new sa(), a = t.split(Cot), o = 0, u = /* @__PURE__ */ s(function() {
      var y = g(), _ = g() || "";
      return y + _;
      function g() {
        return o < a.length ? a[o++] : void 0;
      }
    }, "shiftNextLine"), l = 1, c = 0, p = null;
    return r.eachMapping(function(y) {
      if (p !== null)
        if (l < y.generatedLine)
          h(p, u()), l++, c = 0;
        else {
          var _ = a[o] || "", g = _.substr(0, y.generatedColumn - c);
          a[o] = _.substr(y.generatedColumn - c), c = y.generatedColumn, h(p, g), p = y;
          return;
        }
      for (; l < y.generatedLine; )
        n.add(u()), l++;
      if (c < y.generatedColumn) {
        var _ = a[o] || "";
        n.add(_.substr(0, y.generatedColumn)), a[o] = _.substr(y.generatedColumn), c = y.generatedColumn;
      }
      p = y;
    }, this), o < a.length && (p && h(p, u()), n.add(a.splice(o).join(""))), r.sources.forEach(function(y) {
      var _ = r.sourceContentFor(y);
      _ != null && (i != null && (y = OS.join(i, y)), n.setSourceContent(y, _));
    }), n;
    function h(y, _) {
      if (y === null || y.source === void 0)
        n.add(_);
      else {
        var g = i ? OS.join(i, y.source) : y.source;
        n.add(new sa(
          y.originalLine,
          y.originalColumn,
          g,
          _,
          y.name
        ));
      }
    }
    s(h, "addMappingWithCode");
  }, "SourceNode_fromStringWithSourceMap");
  sa.prototype.add = /* @__PURE__ */ s(function(t) {
    if (Array.isArray(t))
      t.forEach(function(r) {
        this.add(r);
      }, this);
    else if (t[Wp] || typeof t == "string")
      t && this.children.push(t);
    else
      throw new TypeError(
        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + t
      );
    return this;
  }, "SourceNode_add");
  sa.prototype.prepend = /* @__PURE__ */ s(function(t) {
    if (Array.isArray(t))
      for (var r = t.length - 1; r >= 0; r--)
        this.prepend(t[r]);
    else if (t[Wp] || typeof t == "string")
      this.children.unshift(t);
    else
      throw new TypeError(
        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + t
      );
    return this;
  }, "SourceNode_prepend");
  sa.prototype.walk = /* @__PURE__ */ s(function(t) {
    for (var r, i = 0, n = this.children.length; i < n; i++)
      r = this.children[i], r[Wp] ? r.walk(t) : r !== "" && t(r, {
        source: this.source,
        line: this.line,
        column: this.column,
        name: this.name
      });
  }, "SourceNode_walk");
  sa.prototype.join = /* @__PURE__ */ s(function(t) {
    var r, i, n = this.children.length;
    if (n > 0) {
      for (r = [], i = 0; i < n - 1; i++)
        r.push(this.children[i]), r.push(t);
      r.push(this.children[i]), this.children = r;
    }
    return this;
  }, "SourceNode_join");
  sa.prototype.replaceRight = /* @__PURE__ */ s(function(t, r) {
    var i = this.children[this.children.length - 1];
    return i[Wp] ? i.replaceRight(t, r) : typeof i == "string" ? this.children[this.children.length - 1] = i.replace(t, r) : this.children.push(
    "".replace(t, r)), this;
  }, "SourceNode_replaceRight");
  sa.prototype.setSourceContent = /* @__PURE__ */ s(function(t, r) {
    this.sourceContents[OS.toSetString(t)] = r;
  }, "SourceNode_setSourceContent");
  sa.prototype.walkSourceContents = /* @__PURE__ */ s(function(t) {
    for (var r = 0, i = this.children.length; r < i; r++)
      this.children[r][Wp] && this.children[r].walkSourceContents(t);
    for (var n = Object.keys(this.sourceContents), r = 0, i = n.length; r < i; r++)
      t(OS.fromSetString(n[r]), this.sourceContents[n[r]]);
  }, "SourceNode_walkSourceContents");
  sa.prototype.toString = /* @__PURE__ */ s(function() {
    var t = "";
    return this.walk(function(r) {
      t += r;
    }), t;
  }, "SourceNode_toString");
  sa.prototype.toStringWithSourceMap = /* @__PURE__ */ s(function(t) {
    var r = {
      code: "",
      line: 1,
      column: 0
    }, i = new xot(t), n = !1, a = null, o = null, u = null, l = null;
    return this.walk(function(c, p) {
      r.code += c, p.source !== null && p.line !== null && p.column !== null ? ((a !== p.source || o !== p.line || u !== p.column || l !== p.
      name) && i.addMapping({
        source: p.source,
        original: {
          line: p.line,
          column: p.column
        },
        generated: {
          line: r.line,
          column: r.column
        },
        name: p.name
      }), a = p.source, o = p.line, u = p.column, l = p.name, n = !0) : n && (i.addMapping({
        generated: {
          line: r.line,
          column: r.column
        }
      }), a = null, n = !1);
      for (var h = 0, y = c.length; h < y; h++)
        c.charCodeAt(h) === Pot ? (r.line++, r.column = 0, h + 1 === y ? (a = null, n = !1) : n && i.addMapping({
          source: p.source,
          original: {
            line: p.line,
            column: p.column
          },
          generated: {
            line: r.line,
            column: r.column
          },
          name: p.name
        })) : r.column++;
    }), this.walkSourceContents(function(c, p) {
      i.setSourceContent(c, p);
    }), { code: r.code, map: i };
  }, "SourceNode_toStringWithSourceMap");
  gte.SourceNode = sa;
});

// ../node_modules/clean-css/node_modules/source-map/source-map.js
var jO = b((kS) => {
  kS.SourceMapGenerator = FO().SourceMapGenerator;
  kS.SourceMapConsumer = yte().SourceMapConsumer;
  kS.SourceNode = _te().SourceNode;
});

// ../node_modules/clean-css/lib/reader/input-source-map-tracker.js
var Ste = b((TBt, vte) => {
  var Dot = jO().SourceMapConsumer;
  function wot() {
    var e = {};
    return {
      all: Oot.bind(null, e),
      isTracking: kot.bind(null, e),
      originalPositionFor: bte.bind(null, e),
      track: Rot.bind(null, e)
    };
  }
  s(wot, "inputSourceMapTracker");
  function Oot(e) {
    return e;
  }
  s(Oot, "all");
  function kot(e, t) {
    return t in e;
  }
  s(kot, "isTracking");
  function bte(e, t, r, i) {
    for (var n = t[0], a = t[1], o = t[2], u = {
      line: n,
      column: a + r
    }, l; !l && u.column > a; )
      u.column--, l = e[o].originalPositionFor(u);
    return !l || l.column < 0 ? t : l.line === null && n > 1 && i > 0 ? bte(e, [n - 1, a, o], r, i - 1) : l.line !== null ? Iot(l) : t;
  }
  s(bte, "originalPositionFor");
  function Iot(e) {
    return [e.line, e.column, e.source];
  }
  s(Iot, "toMetadata");
  function Rot(e, t, r) {
    e[t] = new Dot(r);
  }
  s(Rot, "track");
  vte.exports = wot;
});

// ../node_modules/clean-css/lib/utils/is-remote-resource.js
var $p = b((ABt, Tte) => {
  var Not = /^(\w+:\/\/|\/\/)/, Lot = /^file:\/\//;
  function Fot(e) {
    return Not.test(e) && !Lot.test(e);
  }
  s(Fot, "isRemoteResource");
  Tte.exports = Fot;
});

// ../node_modules/clean-css/lib/utils/has-protocol.js
var Bm = b((CBt, Ete) => {
  var Mot = /^\/\//;
  function Bot(e) {
    return !Mot.test(e);
  }
  s(Bot, "hasProtocol");
  Ete.exports = Bot;
});

// ../node_modules/clean-css/lib/reader/is-allowed-resource.js
var IS = b((DBt, Pte) => {
  var Ate = require("path"), xte = require("url"), qot = $p(), Uot = Bm(), Cte = "http:";
  function KO(e, t, r) {
    var i, n, a = !t, o, u, l, c;
    if (r.length === 0)
      return !1;
    for (t && !Uot(e) && (e = Cte + e), i = t ? xte.parse(e).host : e, n = t ? e : Ate.resolve(e), c = 0; c < r.length; c++)
      o = r[c], u = o[0] == "!", l = o.substring(1), u && t && VO(l) ? a = a && !KO(e, !0, [l]) : u && !t && !VO(l) ? a = a && !KO(e, !1, [l]) :
      u ? a = a && !0 : o == "all" ? a = !0 : t && o == "local" ? a = a || !1 : t && o == "remote" ? a = !0 : !t && o == "remote" ? a = !1 :
      !t && o == "local" || o === i || o === e || t && n.indexOf(o) === 0 || !t && n.indexOf(Ate.resolve(o)) === 0 ? a = !0 : t != VO(l) ? a =
      a && !0 : a = !1;
    return a;
  }
  s(KO, "isAllowedResource");
  function VO(e) {
    return qot(e) || xte.parse(Cte + "//" + e).host == e;
  }
  s(VO, "isRemoteRule");
  Pte.exports = KO;
});

// ../node_modules/clean-css/lib/reader/match-data-uri.js
var wte = b((OBt, Dte) => {
  var jot = /^data:(\S*?)?(;charset=(?:(?!;charset=)[^;])+)?(;[^,]+?)?,(.+)/;
  function Vot(e) {
    return jot.exec(e);
  }
  s(Vot, "matchDataUri");
  Dte.exports = Vot;
});

// ../node_modules/clean-css/lib/reader/rebase-local-map.js
var HO = b((IBt, Ote) => {
  var qm = require("path");
  function Kot(e, t, r) {
    var i = qm.resolve(""), n = qm.resolve(i, t), a = qm.dirname(n);
    return e.sources = e.sources.map(function(o) {
      return qm.relative(r, qm.resolve(a, o));
    }), e;
  }
  s(Kot, "rebaseLocalMap");
  Ote.exports = Kot;
});

// ../node_modules/clean-css/lib/reader/rebase-remote-map.js
var zO = b((NBt, kte) => {
  var Hot = require("path"), zot = require("url");
  function Got(e, t) {
    var r = Hot.dirname(t);
    return e.sources = e.sources.map(function(i) {
      return zot.resolve(r, i);
    }), e;
  }
  s(Got, "rebaseRemoteMap");
  kte.exports = Got;
});

// ../node_modules/clean-css/lib/utils/is-data-uri-resource.js
var GO = b((FBt, Ite) => {
  var Wot = /^data:(\S{0,31}?)?(;charset=(?:(?!;charset=)[^;])+)?(;[^,]+?)?,(.+)/;
  function $ot(e) {
    return Wot.test(e);
  }
  s($ot, "isDataUriResource");
  Ite.exports = $ot;
});

// ../node_modules/clean-css/lib/reader/apply-source-maps.js
var Bte = b((BBt, Mte) => {
  var RS = require("fs"), Xot = require("path"), Nte = IS(), Yot = wte(), Jot = HO(), Qot = zO(), es = ui(), Zot = Bm(), eut = GO(), tut = $p(),
  Lte = /^\/\*# sourceMappingURL=(\S+) \*\/$/;
  function rut(e, t, r) {
    var i = {
      callback: r,
      fetch: t.options.fetch,
      index: 0,
      inline: t.options.inline,
      inlineRequest: t.options.inlineRequest,
      inlineTimeout: t.options.inlineTimeout,
      inputSourceMapTracker: t.inputSourceMapTracker,
      localOnly: t.localOnly,
      processedTokens: [],
      rebaseTo: t.options.rebaseTo,
      sourceTokens: e,
      warnings: t.warnings
    };
    return t.options.sourceMap && e.length > 0 ? Fte(i) : r(e);
  }
  s(rut, "applySourceMaps");
  function Fte(e) {
    var t = [], r = Rte(e.sourceTokens[0]), i, n, a;
    for (a = e.sourceTokens.length; e.index < a; e.index++)
      if (n = e.sourceTokens[e.index], i = Rte(n), i != r && (t = [], r = i), t.push(n), e.processedTokens.push(n), n[0] == es.COMMENT && Lte.
      test(n[1]))
        return iut(n[1], i, t, e);
    return e.callback(e.processedTokens);
  }
  s(Fte, "doApplySourceMaps");
  function Rte(e) {
    var t, r;
    return e[0] == es.AT_RULE || e[0] == es.COMMENT || e[0] == es.RAW ? r = e[2][0] : (t = e[1][0], r = t[2][0]), r[2];
  }
  s(Rte, "findTokenSource");
  function iut(e, t, r, i) {
    return nut(e, i, function(n) {
      return n && (i.inputSourceMapTracker.track(t, n), Ru(r, i.inputSourceMapTracker)), i.index++, Fte(i);
    });
  }
  s(iut, "fetchAndApplySourceMap");
  function nut(e, t, r) {
    var i = Lte.exec(e)[1], n, a, o;
    return eut(i) ? (a = sut(i), r(a)) : tut(i) ? aut(i, t, function(u) {
      var l;
      u ? (l = JSON.parse(u), o = Qot(l, i), r(o)) : r(null);
    }) : (n = Xot.resolve(t.rebaseTo, i), a = out(n, t), a ? (o = Jot(a, n, t.rebaseTo), r(o)) : r(null));
  }
  s(nut, "extractInputSourceMapFrom");
  function sut(e) {
    var t = Yot(e), r = t[2] ? t[2].split(/[=;]/)[2] : "us-ascii", i = t[3] ? t[3].split(";")[1] : "utf8", n = i == "utf8" ? global.unescape(
    t[4]) : t[4], a = Buffer.from(n, i);
    return a.charset = r, JSON.parse(a.toString());
  }
  s(sut, "extractInputSourceMapFromDataUri");
  function aut(e, t, r) {
    var i = Nte(e, !0, t.inline), n = !Zot(e);
    if (t.localOnly)
      return t.warnings.push('Cannot fetch remote resource from "' + e + '" as no callback given.'), r(null);
    if (n)
      return t.warnings.push('Cannot fetch "' + e + '" as no protocol given.'), r(null);
    if (!i)
      return t.warnings.push('Cannot fetch "' + e + '" as resource is not allowed.'), r(null);
    t.fetch(e, t.inlineRequest, t.inlineTimeout, function(a, o) {
      if (a)
        return t.warnings.push('Missing source map at "' + e + '" - ' + a), r(null);
      r(o);
    });
  }
  s(aut, "loadInputSourceMapFromRemoteUri");
  function out(e, t) {
    var r = Nte(e, !1, t.inline), i;
    return !RS.existsSync(e) || !RS.statSync(e).isFile() ? (t.warnings.push('Ignoring local source map at "' + e + '" as resource is missing\
.'), null) : r ? RS.statSync(e).size ? (i = RS.readFileSync(e, "utf-8"), JSON.parse(i)) : (t.warnings.push('Cannot fetch "' + e + '" as reso\
urce is empty.'), null) : (t.warnings.push('Cannot fetch "' + e + '" as resource is not allowed.'), null);
  }
  s(out, "loadInputSourceMapFromLocalUri");
  function Ru(e, t) {
    var r, i, n;
    for (i = 0, n = e.length; i < n; i++)
      switch (r = e[i], r[0]) {
        case es.AT_RULE:
          Gc(r, t);
          break;
        case es.AT_RULE_BLOCK:
          Ru(r[1], t), Ru(r[2], t);
          break;
        case es.AT_RULE_BLOCK_SCOPE:
          Gc(r, t);
          break;
        case es.NESTED_BLOCK:
          Ru(r[1], t), Ru(r[2], t);
          break;
        case es.NESTED_BLOCK_SCOPE:
          Gc(r, t);
          break;
        case es.COMMENT:
          Gc(r, t);
          break;
        case es.PROPERTY:
          Ru(r, t);
          break;
        case es.PROPERTY_BLOCK:
          Ru(r[1], t);
          break;
        case es.PROPERTY_NAME:
          Gc(r, t);
          break;
        case es.PROPERTY_VALUE:
          Gc(r, t);
          break;
        case es.RULE:
          Ru(r[1], t), Ru(r[2], t);
          break;
        case es.RULE_SCOPE:
          Gc(r, t);
      }
    return e;
  }
  s(Ru, "applySourceMapRecursively");
  function Gc(e, t) {
    var r = e[1], i = e[2], n = [], a, o;
    for (a = 0, o = i.length; a < o; a++)
      n.push(t.originalPositionFor(i[a], r.length));
    e[2] = n;
  }
  s(Gc, "applySourceMapTo");
  Mte.exports = rut;
});

// ../node_modules/clean-css/lib/reader/extract-import-url-and-media.js
var WO = b((UBt, qte) => {
  var uut = Bp(), lut = /^\(/, cut = /\)$/, fut = /^@import/i, put = /['"]\s{0,31}/, hut = /\s{0,31}['"]/, dut = /^url\(\s{0,31}/i, mut = /\s{0,31}\)/i;
  function yut(e) {
    var t, r, i, n;
    return i = e.replace(fut, "").trim().replace(dut, "(").replace(mut, ") ").replace(put, "").replace(hut, ""), n = uut(i, " "), t = n[0].replace(
    lut, "").replace(cut, ""), r = n.slice(1).join(" "), [t, r];
  }
  s(yut, "extractImportUrlAndMedia");
  qte.exports = yut;
});

// ../node_modules/clean-css/lib/reader/load-original-sources.js
var Vte = b((VBt, jte) => {
  var $O = require("fs"), gut = require("path"), Ute = IS(), _ut = Bm(), but = $p();
  function vut(e, t) {
    var r = {
      callback: t,
      fetch: e.options.fetch,
      index: 0,
      inline: e.options.inline,
      inlineRequest: e.options.inlineRequest,
      inlineTimeout: e.options.inlineTimeout,
      localOnly: e.localOnly,
      rebaseTo: e.options.rebaseTo,
      sourcesContent: e.sourcesContent,
      uriToSource: Sut(e.inputSourceMapTracker.all()),
      warnings: e.warnings
    };
    return e.options.sourceMap && e.options.sourceMapInlineSources ? XO(r) : t();
  }
  s(vut, "loadOriginalSources");
  function Sut(e) {
    var t = {}, r, i, n, a, o;
    for (n in e)
      for (r = e[n], a = 0, o = r.sources.length; a < o; a++)
        i = r.sources[a], n = r.sourceContentFor(i, !0), t[i] = n;
    return t;
  }
  s(Sut, "uriToSourceMapping");
  function XO(e) {
    var t = Object.keys(e.uriToSource), r, i, n;
    for (n = t.length; e.index < n; e.index++)
      if (r = t[e.index], i = e.uriToSource[r], i)
        e.sourcesContent[r] = i;
      else
        return Tut(r, e);
    return e.callback();
  }
  s(XO, "doLoadOriginalSources");
  function Tut(e, t) {
    var r;
    return but(e) ? Eut(e, t, function(i) {
      return t.index++, t.sourcesContent[e] = i, XO(t);
    }) : (r = Aut(e, t), t.index++, t.sourcesContent[e] = r, XO(t));
  }
  s(Tut, "loadOriginalSource");
  function Eut(e, t, r) {
    var i = Ute(e, !0, t.inline), n = !_ut(e);
    if (t.localOnly)
      return t.warnings.push('Cannot fetch remote resource from "' + e + '" as no callback given.'), r(null);
    if (n)
      return t.warnings.push('Cannot fetch "' + e + '" as no protocol given.'), r(null);
    if (!i)
      return t.warnings.push('Cannot fetch "' + e + '" as resource is not allowed.'), r(null);
    t.fetch(e, t.inlineRequest, t.inlineTimeout, function(a, o) {
      a && t.warnings.push('Missing original source at "' + e + '" - ' + a), r(o);
    });
  }
  s(Eut, "loadOriginalSourceFromRemoteUri");
  function Aut(e, t) {
    var r = Ute(e, !1, t.inline), i = gut.resolve(t.rebaseTo, e);
    if (!$O.existsSync(i) || !$O.statSync(i).isFile())
      return t.warnings.push('Ignoring local source map at "' + i + '" as resource is missing.'), null;
    if (!r)
      return t.warnings.push('Cannot fetch "' + i + '" as resource is not allowed.'), null;
    var n = $O.readFileSync(i, "utf8");
    return n.charCodeAt(0) === 65279 && (n = n.substring(1)), n;
  }
  s(Aut, "loadOriginalSourceFromLocalUri");
  jte.exports = vut;
});

// ../node_modules/clean-css/lib/reader/normalize-path.js
var Hte = b((HBt, Kte) => {
  var xut = "/", Cut = /\\/g;
  function Put(e) {
    return e.replace(Cut, xut);
  }
  s(Put, "normalizePath");
  Kte.exports = Put;
});

// ../node_modules/clean-css/lib/reader/restore-import.js
var YO = b((GBt, zte) => {
  function Dut(e, t) {
    return ("@import " + e + " " + t).trim();
  }
  s(Dut, "restoreImport");
  zte.exports = Dut;
});

// ../node_modules/clean-css/lib/reader/rewrite-url.js
var Xte = b(($Bt, $te) => {
  var Um = require("path"), wut = require("url"), Out = GO(), QO = '"', NS = "'", kut = "url(", Iut = ")", Rut = /^[^\w\d]*\/\//, Nut = /^["']/,
  Lut = /["']$/, Fut = /[()]/, Mut = /^url\(/i, But = /\)$/, qut = /\s/, Uut = process.platform == "win32";
  function Gte(e, t) {
    return !t || jut(e) && !JO(t.toBase) || JO(e) || Vut(e) || Kut(e) || Out(e) ? e : JO(t.toBase) ? wut.resolve(t.toBase, e) : t.absolute ?
    Wte(Hut(e, t)) : Wte(zut(e, t));
  }
  s(Gte, "rebase");
  function jut(e) {
    return Um.isAbsolute(e);
  }
  s(jut, "isAbsolute");
  function Vut(e) {
    return e[0] == "#";
  }
  s(Vut, "isSVGMarker");
  function Kut(e) {
    return /^\w+:\w+/.test(e);
  }
  s(Kut, "isInternal");
  function JO(e) {
    return /^[^:]+?:\/\//.test(e) || Rut.test(e);
  }
  s(JO, "isRemote");
  function Hut(e, t) {
    return Um.resolve(Um.join(t.fromBase || "", e)).replace(t.toBase, "");
  }
  s(Hut, "absolute");
  function zut(e, t) {
    return Um.relative(t.toBase, Um.join(t.fromBase || "", e));
  }
  s(zut, "relative");
  function Wte(e) {
    return Uut ? e.replace(/\\/g, "/") : e;
  }
  s(Wte, "normalize");
  function Gut(e) {
    return e.indexOf(NS) > -1 ? QO : e.indexOf(QO) > -1 || Wut(e) || $ut(e) ? NS : "";
  }
  s(Gut, "quoteFor");
  function Wut(e) {
    return qut.test(e);
  }
  s(Wut, "hasWhitespace");
  function $ut(e) {
    return Fut.test(e);
  }
  s($ut, "hasRoundBrackets");
  function Xut(e, t, r) {
    var i = e.replace(Mut, "").replace(But, "").trim(), n = i.replace(Nut, "").replace(Lut, "").trim(), a = i[0] == NS || i[0] == QO ? i[0] :
    Gut(n);
    return r ? Gte(n, t) : kut + a + Gte(n, t) + a + Iut;
  }
  s(Xut, "rewriteUrl");
  $te.exports = Xut;
});

// ../node_modules/clean-css/lib/utils/is-import.js
var ZO = b((YBt, Yte) => {
  var Yut = /^@import/i;
  function Jut(e) {
    return Yut.test(e);
  }
  s(Jut, "isImport");
  Yte.exports = Jut;
});

// ../node_modules/clean-css/lib/reader/rebase.js
var tre = b((QBt, ere) => {
  var Qut = WO(), Zut = YO(), ek = Xte(), Xp = ui(), elt = ZO(), tlt = /^\/\*# sourceMappingURL=(\S+) \*\/$/;
  function rlt(e, t, r, i) {
    return t ? Qte(e, r, i) : ilt(e, r, i);
  }
  s(rlt, "rebase");
  function Qte(e, t, r) {
    var i, n, a;
    for (n = 0, a = e.length; n < a; n++)
      switch (i = e[n], i[0]) {
        case Xp.AT_RULE:
          Zte(i, t, r);
          break;
        case Xp.AT_RULE_BLOCK:
          Jte(i[2], t, r);
          break;
        case Xp.COMMENT:
          nlt(i, r);
          break;
        case Xp.NESTED_BLOCK:
          Qte(i[2], t, r);
          break;
        case Xp.RULE:
          Jte(i[2], t, r);
          break;
      }
    return e;
  }
  s(Qte, "rebaseEverything");
  function ilt(e, t, r) {
    var i, n, a;
    for (n = 0, a = e.length; n < a; n++)
      switch (i = e[n], i[0]) {
        case Xp.AT_RULE:
          Zte(i, t, r);
          break;
      }
    return e;
  }
  s(ilt, "rebaseAtRules");
  function Zte(e, t, r) {
    if (elt(e[1])) {
      var i = Qut(e[1]), n = ek(i[0], r), a = i[1];
      e[1] = Zut(n, a);
    }
  }
  s(Zte, "rebaseAtRule");
  function nlt(e, t) {
    var r = tlt.exec(e[1]);
    r && r[1].indexOf("data:") === -1 && (e[1] = e[1].replace(r[1], ek(r[1], t, !0)));
  }
  s(nlt, "rebaseSourceMapComment");
  function Jte(e, t, r) {
    var i, n, a, o, u, l;
    for (a = 0, o = e.length; a < o; a++)
      for (i = e[a], u = 2, l = i.length; u < l; u++)
        n = i[u][1], t.isUrl(n) && (i[u][1] = ek(n, r));
  }
  s(Jte, "rebaseProperties");
  ere.exports = rlt;
});

// ../node_modules/clean-css/lib/tokenizer/tokenize.js
var ire = b((e3t, rre) => {
  var Ve = Ln(), Ot = ui(), LS = dm(), rt = {
    BLOCK: "block",
    COMMENT: "comment",
    DOUBLE_QUOTE: "double-quote",
    RULE: "rule",
    SINGLE_QUOTE: "single-quote"
  }, slt = [
    "@charset",
    "@import"
  ], alt = [
    "@-moz-document",
    "@document",
    "@-moz-keyframes",
    "@-ms-keyframes",
    "@-o-keyframes",
    "@-webkit-keyframes",
    "@keyframes",
    "@media",
    "@supports",
    "@container",
    "@layer"
  ], olt = /\/\* clean-css ignore:end \*\/$/, ult = /^\/\* clean-css ignore:start \*\//, llt = [
    "@bottom-center",
    "@bottom-left",
    "@bottom-left-corner",
    "@bottom-right",
    "@bottom-right-corner",
    "@left-bottom",
    "@left-middle",
    "@left-top",
    "@right-bottom",
    "@right-middle",
    "@right-top",
    "@top-center",
    "@top-left",
    "@top-left-corner",
    "@top-right",
    "@top-right-corner"
  ], clt = [
    "@footnote",
    "@footnotes",
    "@left",
    "@page-float-bottom",
    "@page-float-top",
    "@right"
  ], flt = /^\[\s{0,31}\d+\s{0,31}\]$/, plt = /([^}])\}*$/, hlt = /[\s(]/;
  function dlt(e, t) {
    var r = {
      level: rt.BLOCK,
      position: {
        source: t.source || void 0,
        line: 1,
        column: 0,
        index: 0
      }
    };
    return rk(e, t, r, !1);
  }
  s(dlt, "tokenize");
  function rk(e, t, r, i) {
    for (var n = [], a = n, o, u, l = [], c, p, h = [], y = r.level, _ = [], g = [], m = [], f = !0, d, v, E = 0, S, x, C, z, w, D, N = !1, T,
    R = !1, j, J, H = !1, F, re = !1, se = !1, de = !1, he = !1, xe = !1, G = r.position, ie; G.index < e.length; G.index++) {
      var X = e[G.index];
      if (S = y == rt.SINGLE_QUOTE || y == rt.DOUBLE_QUOTE, x = X == Ve.SPACE || X == Ve.TAB, C = X == Ve.NEW_LINE_NIX, z = X == Ve.NEW_LINE_NIX &&
      e[G.index - 1] == Ve.CARRIAGE_RETURN, w = X == Ve.CARRIAGE_RETURN && e[G.index + 1] && e[G.index + 1] != Ve.NEW_LINE_NIX, D = !R && y !=
      rt.COMMENT && !S && X == Ve.ASTERISK && e[G.index - 1] == Ve.FORWARD_SLASH, j = !N && !S && X == Ve.FORWARD_SLASH && e[G.index - 1] ==
      Ve.ASTERISK, T = y == rt.COMMENT && j, F = !x && !w && (X >= "A" && X <= "Z" || X >= "a" && X <= "z" || X >= "0" && X <= "9" || X == "\
-"), se = se || y != rt.COMMENT && !he && re && X === "-" && g.length === 1, re = X === "-", E = Math.max(E, 0), p = f ? [G.line, G.column, G.
      source] : p, J)
        g.push(X), f = !1;
      else if (F)
        g.push(X), f = !1;
      else if ((x || C && !z) && (S || y == rt.COMMENT))
        g.push(X), f = !1;
      else if (!((x || C && !z) && f)) {
        if (!T && y == rt.COMMENT)
          g.push(X), f = !1;
        else if (!D && !T && de)
          g.push(X), f = !1;
        else if (D && se && (y == rt.BLOCK || y == rt.RULE) && g.length > 1)
          g.push(X), f = !1, _.push(y), y = rt.COMMENT;
        else if (D && (y == rt.BLOCK || y == rt.RULE) && g.length > 1)
          h.push(p), g.push(X), m.push(g.slice(0, -2)), f = !1, g = g.slice(-2), p = [G.line, G.column - 1, G.source], _.push(y), y = rt.COMMENT;
        else if (D)
          _.push(y), y = rt.COMMENT, g.push(X), f = !1;
        else if (T && se)
          g.push(X), y = _.pop();
        else if (T && mlt(g))
          d = g.join("").trim() + X, o = [
            Ot.COMMENT,
            d,
            [Wr(p, d, t)]
          ], a.push(o), de = !0, p = h.pop() || null, g = m.pop() || [], f = g.length === 0;
        else if (T && ylt(g))
          d = g.join("") + X, ie = d.lastIndexOf(Ve.FORWARD_SLASH + Ve.ASTERISK), v = d.substring(0, ie), o = [
            Ot.RAW,
            v,
            [Wr(p, v, t)]
          ], a.push(o), v = d.substring(ie), p = [G.line, G.column - v.length + 1, G.source], o = [
            Ot.COMMENT,
            v,
            [Wr(p, v, t)]
          ], a.push(o), de = !1, y = _.pop(), p = h.pop() || null, g = m.pop() || [], f = g.length === 0;
        else if (T)
          d = g.join("").trim() + X, o = [
            Ot.COMMENT,
            d,
            [Wr(p, d, t)]
          ], a.push(o), y = _.pop(), p = h.pop() || null, g = m.pop() || [], f = g.length === 0;
        else if (j && e[G.index + 1] != Ve.ASTERISK)
          t.warnings.push("Unexpected '*/' at " + LS([G.line, G.column, G.source]) + "."), g = [], f = !0;
        else if (X == Ve.SINGLE_QUOTE && !S)
          _.push(y), y = rt.SINGLE_QUOTE, g.push(X), f = !1;
        else if (X == Ve.SINGLE_QUOTE && y == rt.SINGLE_QUOTE)
          y = _.pop(), g.push(X), f = !1;
        else if (X == Ve.DOUBLE_QUOTE && !S)
          _.push(y), y = rt.DOUBLE_QUOTE, g.push(X), f = !1;
        else if (X == Ve.DOUBLE_QUOTE && y == rt.DOUBLE_QUOTE)
          y = _.pop(), g.push(X), f = !1;
        else if (X != Ve.CLOSE_ROUND_BRACKET && X != Ve.OPEN_ROUND_BRACKET && y != rt.COMMENT && !S && E > 0)
          g.push(X), f = !1;
        else if (X == Ve.OPEN_ROUND_BRACKET && !S && y != rt.COMMENT && !he)
          g.push(X), f = !1, E++;
        else if (X == Ve.CLOSE_ROUND_BRACKET && !S && y != rt.COMMENT && !he)
          g.push(X), f = !1, E--;
        else if (X == Ve.SEMICOLON && y == rt.BLOCK && g[0] == Ve.AT)
          d = g.join("").trim(), n.push([
            Ot.AT_RULE,
            d,
            [Wr(p, d, t)]
          ]), g = [], f = !0;
        else if (X == Ve.COMMA && y == rt.BLOCK && u)
          d = g.join("").trim(), u[1].push([
            tk(u[0]),
            d,
            [Wr(p, d, t, u[1].length)]
          ]), g = [], f = !0;
        else if (X == Ve.COMMA && y == rt.BLOCK && FS(g) == Ot.AT_RULE)
          g.push(X), f = !1;
        else if (X == Ve.COMMA && y == rt.BLOCK)
          u = [FS(g), [], []], d = g.join("").trim(), u[1].push([
            tk(u[0]),
            d,
            [Wr(p, d, t, 0)]
          ]), g = [], f = !0;
        else if (X == Ve.OPEN_CURLY_BRACKET && y == rt.BLOCK && u && u[0] == Ot.NESTED_BLOCK)
          d = g.join("").trim(), u[1].push([
            Ot.NESTED_BLOCK_SCOPE,
            d,
            [Wr(p, d, t)]
          ]), n.push(u), _.push(y), G.column++, G.index++, g = [], f = !0, u[2] = rk(e, t, r, !0), u = null;
        else if (X == Ve.OPEN_CURLY_BRACKET && y == rt.BLOCK && FS(g) == Ot.NESTED_BLOCK)
          d = g.join("").trim(), u = u || [Ot.NESTED_BLOCK, [], []], u[1].push([
            Ot.NESTED_BLOCK_SCOPE,
            d,
            [Wr(p, d, t)]
          ]), n.push(u), _.push(y), G.column++, G.index++, g = [], f = !0, se = !1, u[2] = rk(e, t, r, !0), u = null;
        else if (X == Ve.OPEN_CURLY_BRACKET && y == rt.BLOCK)
          d = g.join("").trim(), u = u || [FS(g), [], []], u[1].push([
            tk(u[0]),
            d,
            [Wr(p, d, t, u[1].length)]
          ]), a = u[2], n.push(u), _.push(y), y = rt.RULE, g = [], f = !0;
        else if (X == Ve.OPEN_CURLY_BRACKET && y == rt.RULE && he)
          l.push(u), u = [Ot.PROPERTY_BLOCK, []], c.push(u), a = u[1], _.push(y), y = rt.RULE, he = !1;
        else if (X == Ve.OPEN_CURLY_BRACKET && y == rt.RULE && glt(g))
          d = g.join("").trim(), l.push(u), u = [Ot.AT_RULE_BLOCK, [], []], u[1].push([
            Ot.AT_RULE_BLOCK_SCOPE,
            d,
            [Wr(p, d, t)]
          ]), a.push(u), a = u[2], _.push(y), y = rt.RULE, g = [], f = !0;
        else if (X == Ve.COLON && y == rt.RULE && !he)
          d = g.join("").trim(), c = [
            Ot.PROPERTY,
            [
              Ot.PROPERTY_NAME,
              d,
              [Wr(p, d, t)]
            ]
          ], a.push(c), he = !0, g = [], f = !0;
        else if (X == Ve.SEMICOLON && y == rt.RULE && c && l.length > 0 && !f && g[0] == Ve.AT)
          d = g.join("").trim(), u[1].push([
            Ot.AT_RULE,
            d,
            [Wr(p, d, t)]
          ]), g = [], f = !0;
        else if (X == Ve.SEMICOLON && y == rt.RULE && c && !f)
          d = g.join("").trim(), c.push([
            Ot.PROPERTY_VALUE,
            d,
            [Wr(p, d, t)]
          ]), c = null, he = !1, g = [], f = !0, se = !1;
        else if (X == Ve.SEMICOLON && y == rt.RULE && c && f && se && !c[2])
          c.push([Ot.PROPERTY_VALUE, " ", [Wr(p, " ", t)]]), se = !1, c = null, he = !1;
        else if (X == Ve.SEMICOLON && y == rt.RULE && c && f)
          c = null, he = !1;
        else if (X == Ve.SEMICOLON && y == rt.RULE && !f && g[0] == Ve.AT)
          d = g.join(""), a.push([
            Ot.AT_RULE,
            d,
            [Wr(p, d, t)]
          ]), he = !1, g = [], f = !0;
        else if (X == Ve.SEMICOLON && y == rt.RULE && xe)
          xe = !1, g = [], f = !0;
        else if (!(X == Ve.SEMICOLON && y == rt.RULE && f))
          if (X == Ve.CLOSE_CURLY_BRACKET && y == rt.RULE && c && he && !f && l.length > 0)
            d = g.join(""), c.push([
              Ot.PROPERTY_VALUE,
              d,
              [Wr(p, d, t)]
            ]), c = null, u = l.pop(), a = u[2], y = _.pop(), he = !1, g = [], f = !0;
          else if (X == Ve.CLOSE_CURLY_BRACKET && y == rt.RULE && c && !f && g[0] == Ve.AT && l.length > 0)
            d = g.join(""), u[1].push([
              Ot.AT_RULE,
              d,
              [Wr(p, d, t)]
            ]), c = null, u = l.pop(), a = u[2], y = _.pop(), he = !1, g = [], f = !0;
          else if (X == Ve.CLOSE_CURLY_BRACKET && y == rt.RULE && c && l.length > 0)
            c = null, u = l.pop(), a = u[2], y = _.pop(), he = !1;
          else if (X == Ve.CLOSE_CURLY_BRACKET && y == rt.RULE && c && !f)
            d = g.join(""), c.push([
              Ot.PROPERTY_VALUE,
              d,
              [Wr(p, d, t)]
            ]), c = null, u = l.pop(), a = n, y = _.pop(), he = !1, g = [], f = !0;
          else if (X == Ve.CLOSE_CURLY_BRACKET && y == rt.RULE && !f && g[0] == Ve.AT)
            c = null, u = null, d = g.join("").trim(), a.push([
              Ot.AT_RULE,
              d,
              [Wr(p, d, t)]
            ]), a = n, y = _.pop(), he = !1, g = [], f = !0;
          else if (X == Ve.CLOSE_CURLY_BRACKET && y == rt.RULE && _[_.length - 1] == rt.RULE)
            c = null, u = l.pop(), a = u[2], y = _.pop(), he = !1, xe = !0, g = [], f = !0;
          else if (X == Ve.CLOSE_CURLY_BRACKET && y == rt.RULE && se && c && !c[2])
            c.push([Ot.PROPERTY_VALUE, " ", [Wr(p, " ", t)]]), se = !1, c = null, u = null, a = n, y = _.pop(), he = !1, se = !1;
          else if (X == Ve.CLOSE_CURLY_BRACKET && y == rt.RULE)
            c = null, u = null, a = n, y = _.pop(), he = !1, se = !1;
          else if (X == Ve.CLOSE_CURLY_BRACKET && y == rt.BLOCK && !i && G.index <= e.length - 1)
            t.warnings.push("Unexpected '}' at " + LS([G.line, G.column, G.source]) + "."), g.push(X), f = !1;
          else {
            if (X == Ve.CLOSE_CURLY_BRACKET && y == rt.BLOCK)
              break;
            X == Ve.OPEN_ROUND_BRACKET && y == rt.RULE && he ? (g.push(X), f = !1, E++) : X == Ve.CLOSE_ROUND_BRACKET && y == rt.RULE && he &&
            E == 1 ? (g.push(X), f = !1, d = g.join("").trim(), c.push([
              Ot.PROPERTY_VALUE,
              d,
              [Wr(p, d, t)]
            ]), E--, g = [], f = !0, se = !1) : X == Ve.CLOSE_ROUND_BRACKET && y == rt.RULE && he ? (g.push(X), f = !1, se = !1, E--) : X ==
            Ve.FORWARD_SLASH && e[G.index + 1] != Ve.ASTERISK && y == rt.RULE && he && !f ? (d = g.join("").trim(), c.push([
              Ot.PROPERTY_VALUE,
              d,
              [Wr(p, d, t)]
            ]), c.push([
              Ot.PROPERTY_VALUE,
              X,
              [[G.line, G.column, G.source]]
            ]), g = [], f = !0) : X == Ve.FORWARD_SLASH && e[G.index + 1] != Ve.ASTERISK && y == rt.RULE && he ? (c.push([
              Ot.PROPERTY_VALUE,
              X,
              [[G.line, G.column, G.source]]
            ]), g = [], f = !0) : X == Ve.COMMA && y == rt.RULE && he && !f ? (d = g.join("").trim(), c.push([
              Ot.PROPERTY_VALUE,
              d,
              [Wr(p, d, t)]
            ]), c.push([
              Ot.PROPERTY_VALUE,
              X,
              [[G.line, G.column, G.source]]
            ]), g = [], f = !0) : X == Ve.COMMA && y == rt.RULE && he ? (c.push([
              Ot.PROPERTY_VALUE,
              X,
              [[G.line, G.column, G.source]]
            ]), g = [], f = !0) : X == Ve.CLOSE_SQUARE_BRACKET && c && c.length > 1 && !f && _lt(g) ? (g.push(X), d = g.join("").trim(), c[c.
            length - 1][1] += d, g = [], f = !0) : (x || C && !z) && y == rt.RULE && he && c && !f ? (d = g.join("").trim(), c.push([
              Ot.PROPERTY_VALUE,
              d,
              [Wr(p, d, t)]
            ]), g = [], f = !0) : z && y == rt.RULE && he && c && g.length > 1 ? (d = g.join("").trim(), c.push([
              Ot.PROPERTY_VALUE,
              d,
              [Wr(p, d, t)]
            ]), g = [], f = !0) : z && y == rt.RULE && he ? (g = [], f = !0) : z && g.length == 1 ? (g.pop(), f = g.length === 0) : (!f || !x &&
            !C && !z && !w) && (g.push(X), f = !1);
          }
      }
      H = J, J = !H && X == Ve.BACK_SLASH, N = D, R = T, G.line = z || C || w ? G.line + 1 : G.line, G.column = z || C || w ? 0 : G.column +
      1;
    }
    return he && t.warnings.push("Missing '}' at " + LS([G.line, G.column, G.source]) + "."), he && g.length > 0 && (d = g.join("").trimRight().
    replace(plt, "$1").trimRight(), c.push([
      Ot.PROPERTY_VALUE,
      d,
      [Wr(p, d, t)]
    ]), g = []), g.length > 0 && t.warnings.push("Invalid character(s) '" + g.join("") + "' at " + LS(p) + ". Ignoring."), n;
  }
  s(rk, "intoTokens");
  function mlt(e) {
    return ult.test(e.join("") + Ve.FORWARD_SLASH);
  }
  s(mlt, "isIgnoreStartComment");
  function ylt(e) {
    return olt.test(e.join("") + Ve.FORWARD_SLASH);
  }
  s(ylt, "isIgnoreEndComment");
  function Wr(e, t, r, i) {
    var n = e[2];
    return r.inputSourceMapTracker.isTracking(n) ? r.inputSourceMapTracker.originalPositionFor(e, t.length, i) : e;
  }
  s(Wr, "originalMetadata");
  function FS(e) {
    var t = e[0] == Ve.AT || e[0] == Ve.UNDERSCORE, r = e.join("").split(hlt)[0];
    return t && alt.indexOf(r) > -1 ? Ot.NESTED_BLOCK : t && slt.indexOf(r) > -1 ? Ot.AT_RULE : t ? Ot.AT_RULE_BLOCK : Ot.RULE;
  }
  s(FS, "tokenTypeFrom");
  function tk(e) {
    if (e == Ot.RULE)
      return Ot.RULE_SCOPE;
    if (e == Ot.NESTED_BLOCK)
      return Ot.NESTED_BLOCK_SCOPE;
    if (e == Ot.AT_RULE_BLOCK)
      return Ot.AT_RULE_BLOCK_SCOPE;
  }
  s(tk, "tokenScopeFrom");
  function glt(e) {
    var t = e.join("").trim();
    return llt.indexOf(t) > -1 || clt.indexOf(t) > -1;
  }
  s(glt, "isPageMarginBox");
  function _lt(e) {
    return flt.test(e.join("") + Ve.CLOSE_SQUARE_BRACKET);
  }
  s(_lt, "isRepeatToken");
  rre.exports = dlt;
});

// ../node_modules/clean-css/lib/reader/read-sources.js
var pre = b((r3t, fre) => {
  var ik = require("fs"), Hs = require("path"), blt = Bte(), vlt = WO(), sre = IS(), Slt = Vte(), are = Hte(), Tlt = tre(), Elt = HO(), Alt = zO(),
  xlt = YO(), Clt = ire(), jm = ui(), Plt = Ln(), Dlt = Bm(), wlt = ZO(), MS = $p(), Olt = "uri:unknown", klt = "file://";
  function Ilt(e, t, r) {
    return Rlt(e, t, function(i) {
      return blt(i, t, function() {
        return Slt(t, function() {
          return r(i);
        });
      });
    });
  }
  s(Ilt, "readSources");
  function Rlt(e, t, r) {
    if (typeof e == "string")
      return nre(e, t, r);
    if (Buffer.isBuffer(e))
      return nre(e.toString(), t, r);
    if (Array.isArray(e))
      return Nlt(e, t, r);
    if (typeof e == "object")
      return Llt(e, t, r);
  }
  s(Rlt, "doReadSources");
  function nre(e, t, r) {
    return t.source = void 0, t.sourcesContent[void 0] = e, t.stats.originalSize += e.length, Vm(e, t, { inline: t.options.inline }, r);
  }
  s(nre, "fromString");
  function Nlt(e, t, r) {
    var i = e.reduce(function(n, a) {
      return typeof a == "string" ? Flt(a, n) : ore(a, t, n);
    }, []);
    return Vm(i.join(""), t, { inline: ["all"] }, r);
  }
  s(Nlt, "fromArray");
  function Llt(e, t, r) {
    var i = ore(e, t, []);
    return Vm(i.join(""), t, { inline: ["all"] }, r);
  }
  s(Llt, "fromHash");
  function Flt(e, t) {
    return t.push(lre(ure(e))), t;
  }
  s(Flt, "addStringSource");
  function ore(e, t, r) {
    var i, n, a;
    for (i in e)
      a = e[i], n = ure(i), r.push(lre(n)), t.sourcesContent[n] = a.styles, a.sourceMap && Mlt(a.sourceMap, n, t);
    return r;
  }
  s(ore, "addHashSource");
  function ure(e) {
    var t = Hs.resolve(""), r, i, n;
    return MS(e) ? e : (r = Hs.isAbsolute(e) ? e : Hs.resolve(e), i = Hs.relative(t, r), n = are(i), n);
  }
  s(ure, "normalizeUri");
  function Mlt(e, t, r) {
    var i = typeof e == "string" ? JSON.parse(e) : e, n = MS(t) ? Alt(i, t) : Elt(i, t || Olt, r.options.rebaseTo);
    r.inputSourceMapTracker.track(t, n);
  }
  s(Mlt, "trackSourceMap");
  function lre(e) {
    return xlt("url(" + e + ")", "") + Plt.SEMICOLON;
  }
  s(lre, "restoreAsImport");
  function Vm(e, t, r, i) {
    var n, a = {};
    return t.source ? MS(t.source) ? (a.fromBase = t.source, a.toBase = t.source) : Hs.isAbsolute(t.source) ? (a.fromBase = Hs.dirname(t.source),
    a.toBase = t.options.rebaseTo) : (a.fromBase = Hs.dirname(Hs.resolve(t.source)), a.toBase = t.options.rebaseTo) : (a.fromBase = Hs.resolve(
    ""), a.toBase = t.options.rebaseTo), n = Clt(e, t), n = Tlt(n, t.options.rebase, t.validator, a), Blt(r.inline) ? qlt(n, t, r, i) : i(n);
  }
  s(Vm, "fromStyles");
  function Blt(e) {
    return !(e.length == 1 && e[0] == "none");
  }
  s(Blt, "allowsAnyImports");
  function qlt(e, t, r, i) {
    var n = {
      afterContent: !1,
      callback: i,
      errors: t.errors,
      externalContext: t,
      fetch: t.options.fetch,
      inlinedStylesheets: r.inlinedStylesheets || t.inlinedStylesheets,
      inline: r.inline,
      inlineRequest: t.options.inlineRequest,
      inlineTimeout: t.options.inlineTimeout,
      isRemote: r.isRemote || !1,
      localOnly: t.localOnly,
      outputTokens: [],
      rebaseTo: t.options.rebaseTo,
      sourceTokens: e,
      warnings: t.warnings
    };
    return so(n);
  }
  s(qlt, "inline");
  function so(e) {
    var t, r, i;
    for (r = 0, i = e.sourceTokens.length; r < i; r++) {
      if (t = e.sourceTokens[r], t[0] == jm.AT_RULE && wlt(t[1]))
        return e.sourceTokens.splice(0, r), Ult(t, e);
      t[0] == jm.AT_RULE || t[0] == jm.COMMENT ? e.outputTokens.push(t) : (e.outputTokens.push(t), e.afterContent = !0);
    }
    return e.sourceTokens = [], e.callback(e.outputTokens);
  }
  s(so, "doInlineImports");
  function Ult(e, t) {
    var r = vlt(e[1]), i = r[0], n = r[1], a = e[2];
    return MS(i) ? jlt(i, n, a, t) : Vlt(i, n, a, t);
  }
  s(Ult, "inlineStylesheet");
  function jlt(e, t, r, i) {
    var n = sre(e, !0, i.inline), a = e, o = e in i.externalContext.sourcesContent, u = !Dlt(e);
    if (i.inlinedStylesheets.indexOf(e) > -1)
      return i.warnings.push('Ignoring remote @import of "' + e + '" as it has already been imported.'), i.sourceTokens = i.sourceTokens.slice(
      1), so(i);
    if (i.localOnly && i.afterContent)
      return i.warnings.push('Ignoring remote @import of "' + e + '" as no callback given and after other content.'), i.sourceTokens = i.sourceTokens.
      slice(1), so(i);
    if (u)
      return i.warnings.push('Skipping remote @import of "' + e + '" as no protocol given.'), i.outputTokens = i.outputTokens.concat(i.sourceTokens.
      slice(0, 1)), i.sourceTokens = i.sourceTokens.slice(1), so(i);
    if (i.localOnly && !o)
      return i.warnings.push('Skipping remote @import of "' + e + '" as no callback given.'), i.outputTokens = i.outputTokens.concat(i.sourceTokens.
      slice(0, 1)), i.sourceTokens = i.sourceTokens.slice(1), so(i);
    if (!n && i.afterContent)
      return i.warnings.push('Ignoring remote @import of "' + e + '" as resource is not allowed and after other content.'), i.sourceTokens =
      i.sourceTokens.slice(1), so(i);
    if (!n)
      return i.warnings.push('Skipping remote @import of "' + e + '" as resource is not allowed.'), i.outputTokens = i.outputTokens.concat(i.
      sourceTokens.slice(0, 1)), i.sourceTokens = i.sourceTokens.slice(1), so(i);
    i.inlinedStylesheets.push(e);
    function l(c, p) {
      return c ? (i.errors.push('Broken @import declaration of "' + e + '" - ' + c), process.nextTick(function() {
        i.outputTokens = i.outputTokens.concat(i.sourceTokens.slice(0, 1)), i.sourceTokens = i.sourceTokens.slice(1), so(i);
      })) : (i.inline = i.externalContext.options.inline, i.isRemote = !0, i.externalContext.source = a, i.externalContext.sourcesContent[e] =
      p, i.externalContext.stats.originalSize += p.length, Vm(p, i.externalContext, i, function(h) {
        return h = cre(h, t, r), i.outputTokens = i.outputTokens.concat(h), i.sourceTokens = i.sourceTokens.slice(1), so(i);
      }));
    }
    return s(l, "whenLoaded"), o ? l(null, i.externalContext.sourcesContent[e]) : i.fetch(e, i.inlineRequest, i.inlineTimeout, l);
  }
  s(jlt, "inlineRemoteStylesheet");
  function Vlt(e, t, r, i) {
    var n = e.replace(klt, ""), a = Hs.resolve(""), o = Hs.isAbsolute(n) ? Hs.resolve(a, n[0] == "/" ? n.substring(1) : n) : Hs.resolve(i.rebaseTo,
    n), u = Hs.relative(a, o), l, c = sre(n, !1, i.inline), p = are(u), h = p in i.externalContext.sourcesContent;
    if (i.inlinedStylesheets.indexOf(o) > -1)
      i.warnings.push('Ignoring local @import of "' + n + '" as it has already been imported.');
    else if (c && !h && (!ik.existsSync(o) || !ik.statSync(o).isFile()))
      i.errors.push('Ignoring local @import of "' + n + '" as resource is missing.');
    else if (!c && i.afterContent)
      i.warnings.push('Ignoring local @import of "' + n + '" as resource is not allowed and after other content.');
    else if (i.afterContent)
      i.warnings.push('Ignoring local @import of "' + n + '" as after other content.');
    else if (!c)
      i.warnings.push('Skipping local @import of "' + n + '" as resource is not allowed.'), i.outputTokens = i.outputTokens.concat(i.sourceTokens.
      slice(0, 1));
    else
      return l = h ? i.externalContext.sourcesContent[p] : ik.readFileSync(o, "utf-8"), l.charCodeAt(0) === 65279 && (l = l.substring(1)), i.
      inlinedStylesheets.push(o), i.inline = i.externalContext.options.inline, i.externalContext.source = p, i.externalContext.sourcesContent[p] =
      l, i.externalContext.stats.originalSize += l.length, Vm(l, i.externalContext, i, function(y) {
        return y = cre(y, t, r), i.outputTokens = i.outputTokens.concat(y), i.sourceTokens = i.sourceTokens.slice(1), so(i);
      });
    return i.sourceTokens = i.sourceTokens.slice(1), so(i);
  }
  s(Vlt, "inlineLocalStylesheet");
  function cre(e, t, r) {
    return t ? [[jm.NESTED_BLOCK, [[jm.NESTED_BLOCK_SCOPE, "@media " + t, r]], e]] : e;
  }
  s(cre, "wrapInMedia");
  fre.exports = Ilt;
});

// ../node_modules/clean-css/lib/writer/simple.js
var mre = b((n3t, dre) => {
  var Klt = cS().all;
  function Hlt(e, t) {
    var r = typeof t == "string" ? t : t[1], i = e.wrap;
    i(e, r), hre(e, r), e.output.push(r);
  }
  s(Hlt, "store");
  function zlt(e, t) {
    e.column + t.length > e.format.wrapAt && (hre(e, e.format.breakWith), e.output.push(e.format.breakWith));
  }
  s(zlt, "wrap");
  function hre(e, t) {
    var r = t.split(`
`);
    e.line += r.length - 1, e.column = r.length > 1 ? 0 : e.column + r.pop().length;
  }
  s(hre, "track");
  function Glt(e, t) {
    var r = {
      column: 0,
      format: t.options.format,
      indentBy: 0,
      indentWith: "",
      line: 1,
      output: [],
      spaceAfterClosingBrace: t.options.compatibility.properties.spaceAfterClosingBrace,
      store: Hlt,
      wrap: t.options.format.wrapAt ? zlt : function() {
      }
    };
    return Klt(r, e), { styles: r.output.join("") };
  }
  s(Glt, "serializeStyles");
  dre.exports = Glt;
});

// ../node_modules/clean-css/lib/writer/source-maps.js
var _re = b((a3t, gre) => {
  var Wlt = jO().SourceMapGenerator, $lt = cS().all, Xlt = $p(), Ylt = process.platform == "win32", Jlt = /\//g, Qlt = "$stdin", Zlt = "\\";
  function ect(e, t) {
    var r = typeof t == "string", i = r ? t : t[1], n = r ? null : t[2], a = e.wrap;
    a(e, i), yre(e, i, n), e.output.push(i);
  }
  s(ect, "store");
  function tct(e, t) {
    e.column + t.length > e.format.wrapAt && (yre(e, e.format.breakWith, !1), e.output.push(e.format.breakWith));
  }
  s(tct, "wrap");
  function yre(e, t, r) {
    var i = t.split(`
`);
    r && rct(e, r), e.line += i.length - 1, e.column = i.length > 1 ? 0 : e.column + i.pop().length;
  }
  s(yre, "track");
  function rct(e, t) {
    for (var r = 0, i = t.length; r < i; r++)
      ict(e, t[r]);
  }
  s(rct, "trackAllMappings");
  function ict(e, t) {
    var r = t[0], i = t[1], n = t[2], a = n, o = a || Qlt;
    Ylt && a && !Xlt(a) && (o = a.replace(Jlt, Zlt)), e.outputMap.addMapping({
      generated: {
        line: e.line,
        column: e.column
      },
      source: o,
      original: {
        line: r,
        column: i
      }
    }), e.inlineSources && n in e.sourcesContent && e.outputMap.setSourceContent(
      o,
      e.sourcesContent[n]
    );
  }
  s(ict, "trackMapping");
  function nct(e, t) {
    var r = {
      column: 0,
      format: t.options.format,
      indentBy: 0,
      indentWith: "",
      inlineSources: t.options.sourceMapInlineSources,
      line: 1,
      output: [],
      outputMap: new Wlt(),
      sourcesContent: t.sourcesContent,
      spaceAfterClosingBrace: t.options.compatibility.properties.spaceAfterClosingBrace,
      store: ect,
      wrap: t.options.format.wrapAt ? tct : function() {
      }
    };
    return $lt(r, e), {
      sourceMap: r.outputMap,
      styles: r.output.join("")
    };
  }
  s(nct, "serializeStylesAndSourceMap");
  gre.exports = nct;
});

// ../node_modules/clean-css/lib/clean.js
var Ere = b((u3t, Tre) => {
  var sct = rY(), act = gQ(), oct = hee(), uct = Aee(), lct = Cee(), cct = Fee(), fct = hm().formatFrom, pct = Bee(), hct = jee(), dct = Kee(),
  bre = Ki().OptimizationLevel, mct = Ki().optimizationLevelFrom, yct = zee(), gct = Wee(), _ct = Xee(), bct = Ste(), vct = pre(), Sct = mre(),
  Tct = _re(), nk = Tre.exports = /* @__PURE__ */ s(function(t) {
    t = t || {}, this.options = {
      batch: !!t.batch,
      compatibility: lct(t.compatibility),
      explicitRebaseTo: "rebaseTo" in t,
      fetch: cct(t.fetch),
      format: fct(t.format),
      inline: pct(t.inline),
      inlineRequest: hct(t.inlineRequest),
      inlineTimeout: dct(t.inlineTimeout),
      level: mct(t.level),
      plugins: yct(t.plugins),
      rebase: gct(t.rebase, t.rebaseTo),
      rebaseTo: _ct(t.rebaseTo),
      returnPromise: !!t.returnPromise,
      sourceMap: !!t.sourceMap,
      sourceMapInlineSources: !!t.sourceMapInlineSources
    };
  }, "CleanCSS");
  nk.process = function(e, t) {
    var r, i = t.to;
    return delete t.to, r = new nk(Object.assign({
      returnPromise: !0,
      rebaseTo: i
    }, t)), r.minify(e).then(function(n) {
      return { css: n.styles };
    });
  };
  nk.prototype.minify = function(e, t, r) {
    var i = this.options;
    return i.returnPromise ? new Promise(function(n, a) {
      vre(e, i, t, function(o, u) {
        return o ? a(o) : n(u);
      });
    }) : vre(e, i, t, r);
  };
  function vre(e, t, r, i) {
    return t.batch && Array.isArray(e) ? Ect(e, t, r, i) : t.batch && typeof e == "object" ? Sre(e, t, r, i) : sk(e, t, r, i);
  }
  s(vre, "minifyAll");
  function Ect(e, t, r, i) {
    var n = typeof i == "function" ? i : typeof r == "function" ? r : null, a = [], o = {}, u, l, c;
    function p(h, y) {
      o = Object.assign(o, y), h !== null && (a = a.concat(h));
    }
    for (s(p, "whenHashBatchDone"), l = 0, c = e.length; l < c; l++)
      typeof e[l] == "object" ? Sre(e[l], t, p) : (u = e[l], o[u] = sk([u], t), a = a.concat(o[u].errors));
    return n ? n(a.length > 0 ? a : null, o) : o;
  }
  s(Ect, "minifyInBatchesFromArray");
  function Sre(e, t, r, i) {
    var n = typeof i == "function" ? i : typeof r == "function" ? r : null, a = [], o = {}, u, l;
    for (u in e)
      l = e[u], o[u] = sk(l.styles, t, l.sourceMap), a = a.concat(o[u].errors);
    return n ? n(a.length > 0 ? a : null, o) : o;
  }
  s(Sre, "minifyInBatchesFromHash");
  function sk(e, t, r, i) {
    var n = typeof r != "function" ? r : null, a = typeof i == "function" ? i : typeof r == "function" ? r : null, o = {
      stats: {
        efficiency: 0,
        minifiedSize: 0,
        originalSize: 0,
        startedAt: Date.now(),
        timeSpent: 0
      },
      cache: { specificity: {} },
      errors: [],
      inlinedStylesheets: [],
      inputSourceMapTracker: bct(),
      localOnly: !a,
      options: t,
      source: null,
      sourcesContent: {},
      validator: uct(t.compatibility),
      warnings: []
    }, u;
    return n && o.inputSourceMapTracker.track(void 0, n), t.rebase && !t.explicitRebaseTo && (u = "You have set `rebase: true` without givin\
g `rebaseTo` option, which, in this case, defaults to the current working directory. You are then warned this can lead to unexpected URL reb\
asing (aka here be dragons)! If you are OK with the clean-css output, then you can get rid of this warning by giving clean-css a `rebaseTo: \
process.cwd()` option.", o.warnings.push(u)), Act(o.localOnly)(function() {
      return vct(e, o, function(l) {
        var c = o.options.sourceMap ? Tct : Sct, p = xct(l, o), h = c(p, o), y = Cct(h, o);
        return a ? a(o.errors.length > 0 ? o.errors : null, y) : y;
      });
    });
  }
  s(sk, "minify");
  function Act(e) {
    return e ? function(t) {
      return t();
    } : process.nextTick;
  }
  s(Act, "runner");
  function xct(e, t) {
    var r = sct(e, t);
    return r = bre.One in t.options.level ? act(e, t) : e, r = bre.Two in t.options.level ? oct(e, t, !0) : r, r;
  }
  s(xct, "optimize");
  function Cct(e, t) {
    return e.stats = Pct(e.styles, t), e.errors = t.errors, e.inlinedStylesheets = t.inlinedStylesheets, e.warnings = t.warnings, e;
  }
  s(Cct, "withMetadata");
  function Pct(e, t) {
    var r = Date.now(), i = r - t.stats.startedAt;
    return delete t.stats.startedAt, t.stats.timeSpent = i, t.stats.efficiency = 1 - e.length / t.stats.originalSize, t.stats.minifiedSize =
    e.length, t.stats;
  }
  s(Pct, "calculateStatsFrom");
});

// ../node_modules/clean-css/index.js
var xre = b((c3t, Are) => {
  Are.exports = Ere();
});

// ../node_modules/he/he.js
var Cre = b((BS, Km) => {
  (function(e) {
    var t = typeof BS == "object" && BS, r = typeof Km == "object" && Km && Km.exports == t && Km, i = typeof global == "object" && global;
    (i.global === i || i.window === i) && (e = i);
    var n = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, a = /[\x01-\x7F]/g, o = /[\x01-\t\x0B\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g, u = /<\u20D2|=\u20E5|>\u20D2|\u205F\u200A|\u219D\u0338|\u2202\u0338|\u2220\u20D2|\u2229\uFE00|\u222A\uFE00|\u223C\u20D2|\u223D\u0331|\u223E\u0333|\u2242\u0338|\u224B\u0338|\u224D\u20D2|\u224E\u0338|\u224F\u0338|\u2250\u0338|\u2261\u20E5|\u2264\u20D2|\u2265\u20D2|\u2266\u0338|\u2267\u0338|\u2268\uFE00|\u2269\uFE00|\u226A\u0338|\u226A\u20D2|\u226B\u0338|\u226B\u20D2|\u227F\u0338|\u2282\u20D2|\u2283\u20D2|\u228A\uFE00|\u228B\uFE00|\u228F\u0338|\u2290\u0338|\u2293\uFE00|\u2294\uFE00|\u22B4\u20D2|\u22B5\u20D2|\u22D8\u0338|\u22D9\u0338|\u22DA\uFE00|\u22DB\uFE00|\u22F5\u0338|\u22F9\u0338|\u2933\u0338|\u29CF\u0338|\u29D0\u0338|\u2A6D\u0338|\u2A70\u0338|\u2A7D\u0338|\u2A7E\u0338|\u2AA1\u0338|\u2AA2\u0338|\u2AAC\uFE00|\u2AAD\uFE00|\u2AAF\u0338|\u2AB0\u0338|\u2AC5\u0338|\u2AC6\u0338|\u2ACB\uFE00|\u2ACC\uFE00|\u2AFD\u20E5|[\xA0-\u0113\u0116-\u0122\u0124-\u012B\u012E-\u014D\u0150-\u017E\u0192\u01B5\u01F5\u0237\u02C6\u02C7\u02D8-\u02DD\u0311\u0391-\u03A1\u03A3-\u03A9\u03B1-\u03C9\u03D1\u03D2\u03D5\u03D6\u03DC\u03DD\u03F0\u03F1\u03F5\u03F6\u0401-\u040C\u040E-\u044F\u0451-\u045C\u045E\u045F\u2002-\u2005\u2007-\u2010\u2013-\u2016\u2018-\u201A\u201C-\u201E\u2020-\u2022\u2025\u2026\u2030-\u2035\u2039\u203A\u203E\u2041\u2043\u2044\u204F\u2057\u205F-\u2063\u20AC\u20DB\u20DC\u2102\u2105\u210A-\u2113\u2115-\u211E\u2122\u2124\u2127-\u2129\u212C\u212D\u212F-\u2131\u2133-\u2138\u2145-\u2148\u2153-\u215E\u2190-\u219B\u219D-\u21A7\u21A9-\u21AE\u21B0-\u21B3\u21B5-\u21B7\u21BA-\u21DB\u21DD\u21E4\u21E5\u21F5\u21FD-\u2205\u2207-\u2209\u220B\u220C\u220F-\u2214\u2216-\u2218\u221A\u221D-\u2238\u223A-\u2257\u2259\u225A\u225C\u225F-\u2262\u2264-\u228B\u228D-\u229B\u229D-\u22A5\u22A7-\u22B0\u22B2-\u22BB\u22BD-\u22DB\u22DE-\u22E3\u22E6-\u22F7\u22F9-\u22FE\u2305\u2306\u2308-\u2310\u2312\u2313\u2315\u2316\u231C-\u231F\u2322\u2323\u232D\u232E\u2336\u233D\u233F\u237C\u23B0\u23B1\u23B4-\u23B6\u23DC-\u23DF\u23E2\u23E7\u2423\u24C8\u2500\u2502\u250C\u2510\u2514\u2518\u251C\u2524\u252C\u2534\u253C\u2550-\u256C\u2580\u2584\u2588\u2591-\u2593\u25A1\u25AA\u25AB\u25AD\u25AE\u25B1\u25B3-\u25B5\u25B8\u25B9\u25BD-\u25BF\u25C2\u25C3\u25CA\u25CB\u25EC\u25EF\u25F8-\u25FC\u2605\u2606\u260E\u2640\u2642\u2660\u2663\u2665\u2666\u266A\u266D-\u266F\u2713\u2717\u2720\u2736\u2758\u2772\u2773\u27C8\u27C9\u27E6-\u27ED\u27F5-\u27FA\u27FC\u27FF\u2902-\u2905\u290C-\u2913\u2916\u2919-\u2920\u2923-\u292A\u2933\u2935-\u2939\u293C\u293D\u2945\u2948-\u294B\u294E-\u2976\u2978\u2979\u297B-\u297F\u2985\u2986\u298B-\u2996\u299A\u299C\u299D\u29A4-\u29B7\u29B9\u29BB\u29BC\u29BE-\u29C5\u29C9\u29CD-\u29D0\u29DC-\u29DE\u29E3-\u29E5\u29EB\u29F4\u29F6\u2A00-\u2A02\u2A04\u2A06\u2A0C\u2A0D\u2A10-\u2A17\u2A22-\u2A27\u2A29\u2A2A\u2A2D-\u2A31\u2A33-\u2A3C\u2A3F\u2A40\u2A42-\u2A4D\u2A50\u2A53-\u2A58\u2A5A-\u2A5D\u2A5F\u2A66\u2A6A\u2A6D-\u2A75\u2A77-\u2A9A\u2A9D-\u2AA2\u2AA4-\u2AB0\u2AB3-\u2AC8\u2ACB\u2ACC\u2ACF-\u2ADB\u2AE4\u2AE6-\u2AE9\u2AEB-\u2AF3\u2AFD\uFB00-\uFB04]|\uD835[\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDD6B]/g,
    l = { "\xAD": "shy", "\u200C": "zwnj", "\u200D": "zwj", "\u200E": "lrm", "\u2063": "ic", "\u2062": "it", "\u2061": "af", "\u200F": "rlm",
    "\u200B": "ZeroWidthSpace", "\u2060": "NoBreak", "\u0311": "DownBreve", "\u20DB": "tdot", "\u20DC": "DotDot", "	": "Tab", "\n": "NewLine",
    "\u2008": "puncsp", "\u205F": "MediumSpace", "\u2009": "thinsp", "\u200A": "hairsp", "\u2004": "emsp13", "\u2002": "ensp", "\u2005": "em\
sp14", "\u2003": "emsp", "\u2007": "numsp", "\xA0": "nbsp", "\u205F\u200A": "ThickSpace", "\u203E": "oline", _: "lowbar", "\u2010": "dash", "\
\u2013": "ndash", "\u2014": "mdash", "\u2015": "horbar", ",": "comma", ";": "semi", "\u204F": "bsemi", ":": "colon", "\u2A74": "Colone", "!": "\
excl", "\xA1": "iexcl", "?": "quest", "\xBF": "iquest", ".": "period", "\u2025": "nldr", "\u2026": "mldr", "\xB7": "middot", "'": "apos", "\u2018": "\
lsquo", "\u2019": "rsquo", "\u201A": "sbquo", "\u2039": "lsaquo", "\u203A": "rsaquo", '"': "quot", "\u201C": "ldquo", "\u201D": "rdquo", "\u201E": "\
bdquo", "\xAB": "laquo", "\xBB": "raquo", "(": "lpar", ")": "rpar", "[": "lsqb", "]": "rsqb", "{": "lcub", "}": "rcub", "\u2308": "lceil", "\
\u2309": "rceil", "\u230A": "lfloor", "\u230B": "rfloor", "\u2985": "lopar", "\u2986": "ropar", "\u298B": "lbrke", "\u298C": "rbrke", "\u298D": "\
lbrkslu", "\u298E": "rbrksld", "\u298F": "lbrksld", "\u2990": "rbrkslu", "\u2991": "langd", "\u2992": "rangd", "\u2993": "lparlt", "\u2994": "\
rpargt", "\u2995": "gtlPar", "\u2996": "ltrPar", "\u27E6": "lobrk", "\u27E7": "robrk", "\u27E8": "lang", "\u27E9": "rang", "\u27EA": "Lang",
    "\u27EB": "Rang", "\u27EC": "loang", "\u27ED": "roang", "\u2772": "lbbrk", "\u2773": "rbbrk", "\u2016": "Vert", "\xA7": "sect", "\xB6": "\
para", "@": "commat", "*": "ast", "/": "sol", undefined: null, "&": "amp", "#": "num", "%": "percnt", "\u2030": "permil", "\u2031": "pertenk",
    "\u2020": "dagger", "\u2021": "Dagger", "\u2022": "bull", "\u2043": "hybull", "\u2032": "prime", "\u2033": "Prime", "\u2034": "tprime", "\
\u2057": "qprime", "\u2035": "bprime", "\u2041": "caret", "`": "grave", "\xB4": "acute", "\u02DC": "tilde", "^": "Hat", "\xAF": "macr", "\u02D8": "\
breve", "\u02D9": "dot", "\xA8": "die", "\u02DA": "ring", "\u02DD": "dblac", "\xB8": "cedil", "\u02DB": "ogon", "\u02C6": "circ", "\u02C7": "\
caron", "\xB0": "deg", "\xA9": "copy", "\xAE": "reg", "\u2117": "copysr", "\u2118": "wp", "\u211E": "rx", "\u2127": "mho", "\u2129": "iiota",
    "\u2190": "larr", "\u219A": "nlarr", "\u2192": "rarr", "\u219B": "nrarr", "\u2191": "uarr", "\u2193": "darr", "\u2194": "harr", "\u21AE": "\
nharr", "\u2195": "varr", "\u2196": "nwarr", "\u2197": "nearr", "\u2198": "searr", "\u2199": "swarr", "\u219D": "rarrw", "\u219D\u0338": "nr\
arrw", "\u219E": "Larr", "\u219F": "Uarr", "\u21A0": "Rarr", "\u21A1": "Darr", "\u21A2": "larrtl", "\u21A3": "rarrtl", "\u21A4": "mapstoleft",
    "\u21A5": "mapstoup", "\u21A6": "map", "\u21A7": "mapstodown", "\u21A9": "larrhk", "\u21AA": "rarrhk", "\u21AB": "larrlp", "\u21AC": "ra\
rrlp", "\u21AD": "harrw", "\u21B0": "lsh", "\u21B1": "rsh", "\u21B2": "ldsh", "\u21B3": "rdsh", "\u21B5": "crarr", "\u21B6": "cularr", "\u21B7": "\
curarr", "\u21BA": "olarr", "\u21BB": "orarr", "\u21BC": "lharu", "\u21BD": "lhard", "\u21BE": "uharr", "\u21BF": "uharl", "\u21C0": "rharu",
    "\u21C1": "rhard", "\u21C2": "dharr", "\u21C3": "dharl", "\u21C4": "rlarr", "\u21C5": "udarr", "\u21C6": "lrarr", "\u21C7": "llarr", "\u21C8": "\
uuarr", "\u21C9": "rrarr", "\u21CA": "ddarr", "\u21CB": "lrhar", "\u21CC": "rlhar", "\u21D0": "lArr", "\u21CD": "nlArr", "\u21D1": "uArr", "\
\u21D2": "rArr", "\u21CF": "nrArr", "\u21D3": "dArr", "\u21D4": "iff", "\u21CE": "nhArr", "\u21D5": "vArr", "\u21D6": "nwArr", "\u21D7": "ne\
Arr", "\u21D8": "seArr", "\u21D9": "swArr", "\u21DA": "lAarr", "\u21DB": "rAarr", "\u21DD": "zigrarr", "\u21E4": "larrb", "\u21E5": "rarrb",
    "\u21F5": "duarr", "\u21FD": "loarr", "\u21FE": "roarr", "\u21FF": "hoarr", "\u2200": "forall", "\u2201": "comp", "\u2202": "part", "\u2202\u0338": "\
npart", "\u2203": "exist", "\u2204": "nexist", "\u2205": "empty", "\u2207": "Del", "\u2208": "in", "\u2209": "notin", "\u220B": "ni", "\u220C": "\
notni", "\u03F6": "bepsi", "\u220F": "prod", "\u2210": "coprod", "\u2211": "sum", "+": "plus", "\xB1": "pm", "\xF7": "div", "\xD7": "times",
    "<": "lt", "\u226E": "nlt", "<\u20D2": "nvlt", "=": "equals", "\u2260": "ne", "=\u20E5": "bne", "\u2A75": "Equal", ">": "gt", "\u226F": "\
ngt", ">\u20D2": "nvgt", "\xAC": "not", "|": "vert", "\xA6": "brvbar", "\u2212": "minus", "\u2213": "mp", "\u2214": "plusdo", "\u2044": "fra\
sl", "\u2216": "setmn", "\u2217": "lowast", "\u2218": "compfn", "\u221A": "Sqrt", "\u221D": "prop", "\u221E": "infin", "\u221F": "angrt", "\u2220": "\
ang", "\u2220\u20D2": "nang", "\u2221": "angmsd", "\u2222": "angsph", "\u2223": "mid", "\u2224": "nmid", "\u2225": "par", "\u2226": "npar", "\
\u2227": "and", "\u2228": "or", "\u2229": "cap", "\u2229\uFE00": "caps", "\u222A": "cup", "\u222A\uFE00": "cups", "\u222B": "int", "\u222C": "\
Int", "\u222D": "tint", "\u2A0C": "qint", "\u222E": "oint", "\u222F": "Conint", "\u2230": "Cconint", "\u2231": "cwint", "\u2232": "cwconint",
    "\u2233": "awconint", "\u2234": "there4", "\u2235": "becaus", "\u2236": "ratio", "\u2237": "Colon", "\u2238": "minusd", "\u223A": "mDDot",
    "\u223B": "homtht", "\u223C": "sim", "\u2241": "nsim", "\u223C\u20D2": "nvsim", "\u223D": "bsim", "\u223D\u0331": "race", "\u223E": "ac",
    "\u223E\u0333": "acE", "\u223F": "acd", "\u2240": "wr", "\u2242": "esim", "\u2242\u0338": "nesim", "\u2243": "sime", "\u2244": "nsime", "\
\u2245": "cong", "\u2247": "ncong", "\u2246": "simne", "\u2248": "ap", "\u2249": "nap", "\u224A": "ape", "\u224B": "apid", "\u224B\u0338": "\
napid", "\u224C": "bcong", "\u224D": "CupCap", "\u226D": "NotCupCap", "\u224D\u20D2": "nvap", "\u224E": "bump", "\u224E\u0338": "nbump", "\u224F": "\
bumpe", "\u224F\u0338": "nbumpe", "\u2250": "doteq", "\u2250\u0338": "nedot", "\u2251": "eDot", "\u2252": "efDot", "\u2253": "erDot", "\u2254": "\
colone", "\u2255": "ecolon", "\u2256": "ecir", "\u2257": "cire", "\u2259": "wedgeq", "\u225A": "veeeq", "\u225C": "trie", "\u225F": "equest",
    "\u2261": "equiv", "\u2262": "nequiv", "\u2261\u20E5": "bnequiv", "\u2264": "le", "\u2270": "nle", "\u2264\u20D2": "nvle", "\u2265": "ge",
    "\u2271": "nge", "\u2265\u20D2": "nvge", "\u2266": "lE", "\u2266\u0338": "nlE", "\u2267": "gE", "\u2267\u0338": "ngE", "\u2268\uFE00": "\
lvnE", "\u2268": "lnE", "\u2269": "gnE", "\u2269\uFE00": "gvnE", "\u226A": "ll", "\u226A\u0338": "nLtv", "\u226A\u20D2": "nLt", "\u226B": "g\
g", "\u226B\u0338": "nGtv", "\u226B\u20D2": "nGt", "\u226C": "twixt", "\u2272": "lsim", "\u2274": "nlsim", "\u2273": "gsim", "\u2275": "ngsi\
m", "\u2276": "lg", "\u2278": "ntlg", "\u2277": "gl", "\u2279": "ntgl", "\u227A": "pr", "\u2280": "npr", "\u227B": "sc", "\u2281": "nsc", "\u227C": "\
prcue", "\u22E0": "nprcue", "\u227D": "sccue", "\u22E1": "nsccue", "\u227E": "prsim", "\u227F": "scsim", "\u227F\u0338": "NotSucceedsTilde",
    "\u2282": "sub", "\u2284": "nsub", "\u2282\u20D2": "vnsub", "\u2283": "sup", "\u2285": "nsup", "\u2283\u20D2": "vnsup", "\u2286": "sube",
    "\u2288": "nsube", "\u2287": "supe", "\u2289": "nsupe", "\u228A\uFE00": "vsubne", "\u228A": "subne", "\u228B\uFE00": "vsupne", "\u228B": "\
supne", "\u228D": "cupdot", "\u228E": "uplus", "\u228F": "sqsub", "\u228F\u0338": "NotSquareSubset", "\u2290": "sqsup", "\u2290\u0338": "Not\
SquareSuperset", "\u2291": "sqsube", "\u22E2": "nsqsube", "\u2292": "sqsupe", "\u22E3": "nsqsupe", "\u2293": "sqcap", "\u2293\uFE00": "sqcap\
s", "\u2294": "sqcup", "\u2294\uFE00": "sqcups", "\u2295": "oplus", "\u2296": "ominus", "\u2297": "otimes", "\u2298": "osol", "\u2299": "odo\
t", "\u229A": "ocir", "\u229B": "oast", "\u229D": "odash", "\u229E": "plusb", "\u229F": "minusb", "\u22A0": "timesb", "\u22A1": "sdotb", "\u22A2": "\
vdash", "\u22AC": "nvdash", "\u22A3": "dashv", "\u22A4": "top", "\u22A5": "bot", "\u22A7": "models", "\u22A8": "vDash", "\u22AD": "nvDash", "\
\u22A9": "Vdash", "\u22AE": "nVdash", "\u22AA": "Vvdash", "\u22AB": "VDash", "\u22AF": "nVDash", "\u22B0": "prurel", "\u22B2": "vltri", "\u22EA": "\
nltri", "\u22B3": "vrtri", "\u22EB": "nrtri", "\u22B4": "ltrie", "\u22EC": "nltrie", "\u22B4\u20D2": "nvltrie", "\u22B5": "rtrie", "\u22ED": "\
nrtrie", "\u22B5\u20D2": "nvrtrie", "\u22B6": "origof", "\u22B7": "imof", "\u22B8": "mumap", "\u22B9": "hercon", "\u22BA": "intcal", "\u22BB": "\
veebar", "\u22BD": "barvee", "\u22BE": "angrtvb", "\u22BF": "lrtri", "\u22C0": "Wedge", "\u22C1": "Vee", "\u22C2": "xcap", "\u22C3": "xcup",
    "\u22C4": "diam", "\u22C5": "sdot", "\u22C6": "Star", "\u22C7": "divonx", "\u22C8": "bowtie", "\u22C9": "ltimes", "\u22CA": "rtimes", "\u22CB": "\
lthree", "\u22CC": "rthree", "\u22CD": "bsime", "\u22CE": "cuvee", "\u22CF": "cuwed", "\u22D0": "Sub", "\u22D1": "Sup", "\u22D2": "Cap", "\u22D3": "\
Cup", "\u22D4": "fork", "\u22D5": "epar", "\u22D6": "ltdot", "\u22D7": "gtdot", "\u22D8": "Ll", "\u22D8\u0338": "nLl", "\u22D9": "Gg", "\u22D9\u0338": "\
nGg", "\u22DA\uFE00": "lesg", "\u22DA": "leg", "\u22DB": "gel", "\u22DB\uFE00": "gesl", "\u22DE": "cuepr", "\u22DF": "cuesc", "\u22E6": "lns\
im", "\u22E7": "gnsim", "\u22E8": "prnsim", "\u22E9": "scnsim", "\u22EE": "vellip", "\u22EF": "ctdot", "\u22F0": "utdot", "\u22F1": "dtdot",
    "\u22F2": "disin", "\u22F3": "isinsv", "\u22F4": "isins", "\u22F5": "isindot", "\u22F5\u0338": "notindot", "\u22F6": "notinvc", "\u22F7": "\
notinvb", "\u22F9": "isinE", "\u22F9\u0338": "notinE", "\u22FA": "nisd", "\u22FB": "xnis", "\u22FC": "nis", "\u22FD": "notnivc", "\u22FE": "\
notnivb", "\u2305": "barwed", "\u2306": "Barwed", "\u230C": "drcrop", "\u230D": "dlcrop", "\u230E": "urcrop", "\u230F": "ulcrop", "\u2310": "\
bnot", "\u2312": "profline", "\u2313": "profsurf", "\u2315": "telrec", "\u2316": "target", "\u231C": "ulcorn", "\u231D": "urcorn", "\u231E": "\
dlcorn", "\u231F": "drcorn", "\u2322": "frown", "\u2323": "smile", "\u232D": "cylcty", "\u232E": "profalar", "\u2336": "topbot", "\u233D": "\
ovbar", "\u233F": "solbar", "\u237C": "angzarr", "\u23B0": "lmoust", "\u23B1": "rmoust", "\u23B4": "tbrk", "\u23B5": "bbrk", "\u23B6": "bbrk\
tbrk", "\u23DC": "OverParenthesis", "\u23DD": "UnderParenthesis", "\u23DE": "OverBrace", "\u23DF": "UnderBrace", "\u23E2": "trpezium", "\u23E7": "\
elinters", "\u2423": "blank", "\u2500": "boxh", "\u2502": "boxv", "\u250C": "boxdr", "\u2510": "boxdl", "\u2514": "boxur", "\u2518": "boxul",
    "\u251C": "boxvr", "\u2524": "boxvl", "\u252C": "boxhd", "\u2534": "boxhu", "\u253C": "boxvh", "\u2550": "boxH", "\u2551": "boxV", "\u2552": "\
boxdR", "\u2553": "boxDr", "\u2554": "boxDR", "\u2555": "boxdL", "\u2556": "boxDl", "\u2557": "boxDL", "\u2558": "boxuR", "\u2559": "boxUr",
    "\u255A": "boxUR", "\u255B": "boxuL", "\u255C": "boxUl", "\u255D": "boxUL", "\u255E": "boxvR", "\u255F": "boxVr", "\u2560": "boxVR", "\u2561": "\
boxvL", "\u2562": "boxVl", "\u2563": "boxVL", "\u2564": "boxHd", "\u2565": "boxhD", "\u2566": "boxHD", "\u2567": "boxHu", "\u2568": "boxhU",
    "\u2569": "boxHU", "\u256A": "boxvH", "\u256B": "boxVh", "\u256C": "boxVH", "\u2580": "uhblk", "\u2584": "lhblk", "\u2588": "block", "\u2591": "\
blk14", "\u2592": "blk12", "\u2593": "blk34", "\u25A1": "squ", "\u25AA": "squf", "\u25AB": "EmptyVerySmallSquare", "\u25AD": "rect", "\u25AE": "\
marker", "\u25B1": "fltns", "\u25B3": "xutri", "\u25B4": "utrif", "\u25B5": "utri", "\u25B8": "rtrif", "\u25B9": "rtri", "\u25BD": "xdtri", "\
\u25BE": "dtrif", "\u25BF": "dtri", "\u25C2": "ltrif", "\u25C3": "ltri", "\u25CA": "loz", "\u25CB": "cir", "\u25EC": "tridot", "\u25EF": "xc\
irc", "\u25F8": "ultri", "\u25F9": "urtri", "\u25FA": "lltri", "\u25FB": "EmptySmallSquare", "\u25FC": "FilledSmallSquare", "\u2605": "starf",
    "\u2606": "star", "\u260E": "phone", "\u2640": "female", "\u2642": "male", "\u2660": "spades", "\u2663": "clubs", "\u2665": "hearts", "\u2666": "\
diams", "\u266A": "sung", "\u2713": "check", "\u2717": "cross", "\u2720": "malt", "\u2736": "sext", "\u2758": "VerticalSeparator", "\u27C8": "\
bsolhsub", "\u27C9": "suphsol", "\u27F5": "xlarr", "\u27F6": "xrarr", "\u27F7": "xharr", "\u27F8": "xlArr", "\u27F9": "xrArr", "\u27FA": "xh\
Arr", "\u27FC": "xmap", "\u27FF": "dzigrarr", "\u2902": "nvlArr", "\u2903": "nvrArr", "\u2904": "nvHarr", "\u2905": "Map", "\u290C": "lbarr",
    "\u290D": "rbarr", "\u290E": "lBarr", "\u290F": "rBarr", "\u2910": "RBarr", "\u2911": "DDotrahd", "\u2912": "UpArrowBar", "\u2913": "Dow\
nArrowBar", "\u2916": "Rarrtl", "\u2919": "latail", "\u291A": "ratail", "\u291B": "lAtail", "\u291C": "rAtail", "\u291D": "larrfs", "\u291E": "\
rarrfs", "\u291F": "larrbfs", "\u2920": "rarrbfs", "\u2923": "nwarhk", "\u2924": "nearhk", "\u2925": "searhk", "\u2926": "swarhk", "\u2927": "\
nwnear", "\u2928": "toea", "\u2929": "tosa", "\u292A": "swnwar", "\u2933": "rarrc", "\u2933\u0338": "nrarrc", "\u2935": "cudarrr", "\u2936": "\
ldca", "\u2937": "rdca", "\u2938": "cudarrl", "\u2939": "larrpl", "\u293C": "curarrm", "\u293D": "cularrp", "\u2945": "rarrpl", "\u2948": "h\
arrcir", "\u2949": "Uarrocir", "\u294A": "lurdshar", "\u294B": "ldrushar", "\u294E": "LeftRightVector", "\u294F": "RightUpDownVector", "\u2950": "\
DownLeftRightVector", "\u2951": "LeftUpDownVector", "\u2952": "LeftVectorBar", "\u2953": "RightVectorBar", "\u2954": "RightUpVectorBar", "\u2955": "\
RightDownVectorBar", "\u2956": "DownLeftVectorBar", "\u2957": "DownRightVectorBar", "\u2958": "LeftUpVectorBar", "\u2959": "LeftDownVectorBa\
r", "\u295A": "LeftTeeVector", "\u295B": "RightTeeVector", "\u295C": "RightUpTeeVector", "\u295D": "RightDownTeeVector", "\u295E": "DownLeft\
TeeVector", "\u295F": "DownRightTeeVector", "\u2960": "LeftUpTeeVector", "\u2961": "LeftDownTeeVector", "\u2962": "lHar", "\u2963": "uHar", "\
\u2964": "rHar", "\u2965": "dHar", "\u2966": "luruhar", "\u2967": "ldrdhar", "\u2968": "ruluhar", "\u2969": "rdldhar", "\u296A": "lharul", "\
\u296B": "llhard", "\u296C": "rharul", "\u296D": "lrhard", "\u296E": "udhar", "\u296F": "duhar", "\u2970": "RoundImplies", "\u2971": "erarr",
    "\u2972": "simrarr", "\u2973": "larrsim", "\u2974": "rarrsim", "\u2975": "rarrap", "\u2976": "ltlarr", "\u2978": "gtrarr", "\u2979": "su\
brarr", "\u297B": "suplarr", "\u297C": "lfisht", "\u297D": "rfisht", "\u297E": "ufisht", "\u297F": "dfisht", "\u299A": "vzigzag", "\u299C": "\
vangrt", "\u299D": "angrtvbd", "\u29A4": "ange", "\u29A5": "range", "\u29A6": "dwangle", "\u29A7": "uwangle", "\u29A8": "angmsdaa", "\u29A9": "\
angmsdab", "\u29AA": "angmsdac", "\u29AB": "angmsdad", "\u29AC": "angmsdae", "\u29AD": "angmsdaf", "\u29AE": "angmsdag", "\u29AF": "angmsdah",
    "\u29B0": "bemptyv", "\u29B1": "demptyv", "\u29B2": "cemptyv", "\u29B3": "raemptyv", "\u29B4": "laemptyv", "\u29B5": "ohbar", "\u29B6": "\
omid", "\u29B7": "opar", "\u29B9": "operp", "\u29BB": "olcross", "\u29BC": "odsold", "\u29BE": "olcir", "\u29BF": "ofcir", "\u29C0": "olt", "\
\u29C1": "ogt", "\u29C2": "cirscir", "\u29C3": "cirE", "\u29C4": "solb", "\u29C5": "bsolb", "\u29C9": "boxbox", "\u29CD": "trisb", "\u29CE": "\
rtriltri", "\u29CF": "LeftTriangleBar", "\u29CF\u0338": "NotLeftTriangleBar", "\u29D0": "RightTriangleBar", "\u29D0\u0338": "NotRightTriangl\
eBar", "\u29DC": "iinfin", "\u29DD": "infintie", "\u29DE": "nvinfin", "\u29E3": "eparsl", "\u29E4": "smeparsl", "\u29E5": "eqvparsl", "\u29EB": "\
lozf", "\u29F4": "RuleDelayed", "\u29F6": "dsol", "\u2A00": "xodot", "\u2A01": "xoplus", "\u2A02": "xotime", "\u2A04": "xuplus", "\u2A06": "\
xsqcup", "\u2A0D": "fpartint", "\u2A10": "cirfnint", "\u2A11": "awint", "\u2A12": "rppolint", "\u2A13": "scpolint", "\u2A14": "npolint", "\u2A15": "\
pointint", "\u2A16": "quatint", "\u2A17": "intlarhk", "\u2A22": "pluscir", "\u2A23": "plusacir", "\u2A24": "simplus", "\u2A25": "plusdu", "\u2A26": "\
plussim", "\u2A27": "plustwo", "\u2A29": "mcomma", "\u2A2A": "minusdu", "\u2A2D": "loplus", "\u2A2E": "roplus", "\u2A2F": "Cross", "\u2A30": "\
timesd", "\u2A31": "timesbar", "\u2A33": "smashp", "\u2A34": "lotimes", "\u2A35": "rotimes", "\u2A36": "otimesas", "\u2A37": "Otimes", "\u2A38": "\
odiv", "\u2A39": "triplus", "\u2A3A": "triminus", "\u2A3B": "tritime", "\u2A3C": "iprod", "\u2A3F": "amalg", "\u2A40": "capdot", "\u2A42": "\
ncup", "\u2A43": "ncap", "\u2A44": "capand", "\u2A45": "cupor", "\u2A46": "cupcap", "\u2A47": "capcup", "\u2A48": "cupbrcap", "\u2A49": "cap\
brcup", "\u2A4A": "cupcup", "\u2A4B": "capcap", "\u2A4C": "ccups", "\u2A4D": "ccaps", "\u2A50": "ccupssm", "\u2A53": "And", "\u2A54": "Or", "\
\u2A55": "andand", "\u2A56": "oror", "\u2A57": "orslope", "\u2A58": "andslope", "\u2A5A": "andv", "\u2A5B": "orv", "\u2A5C": "andd", "\u2A5D": "\
ord", "\u2A5F": "wedbar", "\u2A66": "sdote", "\u2A6A": "simdot", "\u2A6D": "congdot", "\u2A6D\u0338": "ncongdot", "\u2A6E": "easter", "\u2A6F": "\
apacir", "\u2A70": "apE", "\u2A70\u0338": "napE", "\u2A71": "eplus", "\u2A72": "pluse", "\u2A73": "Esim", "\u2A77": "eDDot", "\u2A78": "equi\
vDD", "\u2A79": "ltcir", "\u2A7A": "gtcir", "\u2A7B": "ltquest", "\u2A7C": "gtquest", "\u2A7D": "les", "\u2A7D\u0338": "nles", "\u2A7E": "ge\
s", "\u2A7E\u0338": "nges", "\u2A7F": "lesdot", "\u2A80": "gesdot", "\u2A81": "lesdoto", "\u2A82": "gesdoto", "\u2A83": "lesdotor", "\u2A84": "\
gesdotol", "\u2A85": "lap", "\u2A86": "gap", "\u2A87": "lne", "\u2A88": "gne", "\u2A89": "lnap", "\u2A8A": "gnap", "\u2A8B": "lEg", "\u2A8C": "\
gEl", "\u2A8D": "lsime", "\u2A8E": "gsime", "\u2A8F": "lsimg", "\u2A90": "gsiml", "\u2A91": "lgE", "\u2A92": "glE", "\u2A93": "lesges", "\u2A94": "\
gesles", "\u2A95": "els", "\u2A96": "egs", "\u2A97": "elsdot", "\u2A98": "egsdot", "\u2A99": "el", "\u2A9A": "eg", "\u2A9D": "siml", "\u2A9E": "\
simg", "\u2A9F": "simlE", "\u2AA0": "simgE", "\u2AA1": "LessLess", "\u2AA1\u0338": "NotNestedLessLess", "\u2AA2": "GreaterGreater", "\u2AA2\u0338": "\
NotNestedGreaterGreater", "\u2AA4": "glj", "\u2AA5": "gla", "\u2AA6": "ltcc", "\u2AA7": "gtcc", "\u2AA8": "lescc", "\u2AA9": "gescc", "\u2AAA": "\
smt", "\u2AAB": "lat", "\u2AAC": "smte", "\u2AAC\uFE00": "smtes", "\u2AAD": "late", "\u2AAD\uFE00": "lates", "\u2AAE": "bumpE", "\u2AAF": "p\
re", "\u2AAF\u0338": "npre", "\u2AB0": "sce", "\u2AB0\u0338": "nsce", "\u2AB3": "prE", "\u2AB4": "scE", "\u2AB5": "prnE", "\u2AB6": "scnE", "\
\u2AB7": "prap", "\u2AB8": "scap", "\u2AB9": "prnap", "\u2ABA": "scnap", "\u2ABB": "Pr", "\u2ABC": "Sc", "\u2ABD": "subdot", "\u2ABE": "supd\
ot", "\u2ABF": "subplus", "\u2AC0": "supplus", "\u2AC1": "submult", "\u2AC2": "supmult", "\u2AC3": "subedot", "\u2AC4": "supedot", "\u2AC5": "\
subE", "\u2AC5\u0338": "nsubE", "\u2AC6": "supE", "\u2AC6\u0338": "nsupE", "\u2AC7": "subsim", "\u2AC8": "supsim", "\u2ACB\uFE00": "vsubnE",
    "\u2ACB": "subnE", "\u2ACC\uFE00": "vsupnE", "\u2ACC": "supnE", "\u2ACF": "csub", "\u2AD0": "csup", "\u2AD1": "csube", "\u2AD2": "csupe",
    "\u2AD3": "subsup", "\u2AD4": "supsub", "\u2AD5": "subsub", "\u2AD6": "supsup", "\u2AD7": "suphsub", "\u2AD8": "supdsub", "\u2AD9": "for\
kv", "\u2ADA": "topfork", "\u2ADB": "mlcp", "\u2AE4": "Dashv", "\u2AE6": "Vdashl", "\u2AE7": "Barv", "\u2AE8": "vBar", "\u2AE9": "vBarv", "\u2AEB": "\
Vbar", "\u2AEC": "Not", "\u2AED": "bNot", "\u2AEE": "rnmid", "\u2AEF": "cirmid", "\u2AF0": "midcir", "\u2AF1": "topcir", "\u2AF2": "nhpar", "\
\u2AF3": "parsim", "\u2AFD": "parsl", "\u2AFD\u20E5": "nparsl", "\u266D": "flat", "\u266E": "natur", "\u266F": "sharp", "\xA4": "curren", "\xA2": "\
cent", $: "dollar", "\xA3": "pound", "\xA5": "yen", "\u20AC": "euro", "\xB9": "sup1", "\xBD": "half", "\u2153": "frac13", "\xBC": "frac14", "\
\u2155": "frac15", "\u2159": "frac16", "\u215B": "frac18", "\xB2": "sup2", "\u2154": "frac23", "\u2156": "frac25", "\xB3": "sup3", "\xBE": "\
frac34", "\u2157": "frac35", "\u215C": "frac38", "\u2158": "frac45", "\u215A": "frac56", "\u215D": "frac58", "\u215E": "frac78", "\u{1D4B6}": "\
ascr", "\u{1D552}": "aopf", "\u{1D51E}": "afr", "\u{1D538}": "Aopf", "\u{1D504}": "Afr", "\u{1D49C}": "Ascr", \u00AA: "ordf", \u00E1: "aacut\
e", \u00C1: "Aacute", \u00E0: "agrave", \u00C0: "Agrave", \u0103: "abreve", \u0102: "Abreve", \u00E2: "acirc", \u00C2: "Acirc", \u00E5: "ari\
ng", \u00C5: "angst", \u00E4: "auml", \u00C4: "Auml", \u00E3: "atilde", \u00C3: "Atilde", \u0105: "aogon", \u0104: "Aogon", \u0101: "amacr",
    \u0100: "Amacr", \u00E6: "aelig", \u00C6: "AElig", "\u{1D4B7}": "bscr", "\u{1D553}": "bopf", "\u{1D51F}": "bfr", "\u{1D539}": "Bopf", \u212C: "\
Bscr", "\u{1D505}": "Bfr", "\u{1D520}": "cfr", "\u{1D4B8}": "cscr", "\u{1D554}": "copf", \u212D: "Cfr", "\u{1D49E}": "Cscr", \u2102: "Copf",
    \u0107: "cacute", \u0106: "Cacute", \u0109: "ccirc", \u0108: "Ccirc", \u010D: "ccaron", \u010C: "Ccaron", \u010B: "cdot", \u010A: "Cdot",
    \u00E7: "ccedil", \u00C7: "Ccedil", "\u2105": "incare", "\u{1D521}": "dfr", "\u2146": "dd", "\u{1D555}": "dopf", "\u{1D4B9}": "dscr", "\u{1D49F}": "\
Dscr", "\u{1D507}": "Dfr", "\u2145": "DD", "\u{1D53B}": "Dopf", \u010F: "dcaron", \u010E: "Dcaron", \u0111: "dstrok", \u0110: "Dstrok", \u00F0: "\
eth", \u00D0: "ETH", "\u2147": "ee", \u212F: "escr", "\u{1D522}": "efr", "\u{1D556}": "eopf", \u2130: "Escr", "\u{1D508}": "Efr", "\u{1D53C}": "\
Eopf", \u00E9: "eacute", \u00C9: "Eacute", \u00E8: "egrave", \u00C8: "Egrave", \u00EA: "ecirc", \u00CA: "Ecirc", \u011B: "ecaron", \u011A: "\
Ecaron", \u00EB: "euml", \u00CB: "Euml", \u0117: "edot", \u0116: "Edot", \u0119: "eogon", \u0118: "Eogon", \u0113: "emacr", \u0112: "Emacr",
    "\u{1D523}": "ffr", "\u{1D557}": "fopf", "\u{1D4BB}": "fscr", "\u{1D509}": "Ffr", "\u{1D53D}": "Fopf", \u2131: "Fscr", \uFB00: "fflig", \uFB03: "\
ffilig", \uFB04: "ffllig", \uFB01: "filig", fj: "fjlig", \uFB02: "fllig", \u0192: "fnof", \u210A: "gscr", "\u{1D558}": "gopf", "\u{1D524}": "\
gfr", "\u{1D4A2}": "Gscr", "\u{1D53E}": "Gopf", "\u{1D50A}": "Gfr", \u01F5: "gacute", \u011F: "gbreve", \u011E: "Gbreve", \u011D: "gcirc", \u011C: "\
Gcirc", \u0121: "gdot", \u0120: "Gdot", \u0122: "Gcedil", "\u{1D525}": "hfr", \u210E: "planckh", "\u{1D4BD}": "hscr", "\u{1D559}": "hopf", \u210B: "\
Hscr", \u210C: "Hfr", \u210D: "Hopf", \u0125: "hcirc", \u0124: "Hcirc", \u210F: "hbar", \u0127: "hstrok", \u0126: "Hstrok", "\u{1D55A}": "io\
pf", "\u{1D526}": "ifr", "\u{1D4BE}": "iscr", "\u2148": "ii", "\u{1D540}": "Iopf", \u2110: "Iscr", \u2111: "Im", \u00ED: "iacute", \u00CD: "\
Iacute", \u00EC: "igrave", \u00CC: "Igrave", \u00EE: "icirc", \u00CE: "Icirc", \u00EF: "iuml", \u00CF: "Iuml", \u0129: "itilde", \u0128: "It\
ilde", \u0130: "Idot", \u012F: "iogon", \u012E: "Iogon", \u012B: "imacr", \u012A: "Imacr", \u0133: "ijlig", \u0132: "IJlig", \u0131: "imath",
    "\u{1D4BF}": "jscr", "\u{1D55B}": "jopf", "\u{1D527}": "jfr", "\u{1D4A5}": "Jscr", "\u{1D50D}": "Jfr", "\u{1D541}": "Jopf", \u0135: "jci\
rc", \u0134: "Jcirc", "\u0237": "jmath", "\u{1D55C}": "kopf", "\u{1D4C0}": "kscr", "\u{1D528}": "kfr", "\u{1D4A6}": "Kscr", "\u{1D542}": "Ko\
pf", "\u{1D50E}": "Kfr", \u0137: "kcedil", \u0136: "Kcedil", "\u{1D529}": "lfr", "\u{1D4C1}": "lscr", \u2113: "ell", "\u{1D55D}": "lopf", \u2112: "\
Lscr", "\u{1D50F}": "Lfr", "\u{1D543}": "Lopf", \u013A: "lacute", \u0139: "Lacute", \u013E: "lcaron", \u013D: "Lcaron", \u013C: "lcedil", \u013B: "\
Lcedil", \u0142: "lstrok", \u0141: "Lstrok", \u0140: "lmidot", \u013F: "Lmidot", "\u{1D52A}": "mfr", "\u{1D55E}": "mopf", "\u{1D4C2}": "mscr",
    "\u{1D510}": "Mfr", "\u{1D544}": "Mopf", \u2133: "Mscr", "\u{1D52B}": "nfr", "\u{1D55F}": "nopf", "\u{1D4C3}": "nscr", \u2115: "Nopf", "\
\u{1D4A9}": "Nscr", "\u{1D511}": "Nfr", \u0144: "nacute", \u0143: "Nacute", \u0148: "ncaron", \u0147: "Ncaron", \u00F1: "ntilde", \u00D1: "N\
tilde", \u0146: "ncedil", \u0145: "Ncedil", "\u2116": "numero", \u014B: "eng", \u014A: "ENG", "\u{1D560}": "oopf", "\u{1D52C}": "ofr", \u2134: "\
oscr", "\u{1D4AA}": "Oscr", "\u{1D512}": "Ofr", "\u{1D546}": "Oopf", \u00BA: "ordm", \u00F3: "oacute", \u00D3: "Oacute", \u00F2: "ograve", \u00D2: "\
Ograve", \u00F4: "ocirc", \u00D4: "Ocirc", \u00F6: "ouml", \u00D6: "Ouml", \u0151: "odblac", \u0150: "Odblac", \u00F5: "otilde", \u00D5: "Ot\
ilde", \u00F8: "oslash", \u00D8: "Oslash", \u014D: "omacr", \u014C: "Omacr", \u0153: "oelig", \u0152: "OElig", "\u{1D52D}": "pfr", "\u{1D4C5}": "\
pscr", "\u{1D561}": "popf", \u2119: "Popf", "\u{1D513}": "Pfr", "\u{1D4AB}": "Pscr", "\u{1D562}": "qopf", "\u{1D52E}": "qfr", "\u{1D4C6}": "\
qscr", "\u{1D4AC}": "Qscr", "\u{1D514}": "Qfr", \u211A: "Qopf", \u0138: "kgreen", "\u{1D52F}": "rfr", "\u{1D563}": "ropf", "\u{1D4C7}": "rsc\
r", \u211B: "Rscr", \u211C: "Re", \u211D: "Ropf", \u0155: "racute", \u0154: "Racute", \u0159: "rcaron", \u0158: "Rcaron", \u0157: "rcedil", \u0156: "\
Rcedil", "\u{1D564}": "sopf", "\u{1D4C8}": "sscr", "\u{1D530}": "sfr", "\u{1D54A}": "Sopf", "\u{1D516}": "Sfr", "\u{1D4AE}": "Sscr", "\u24C8": "\
oS", \u015B: "sacute", \u015A: "Sacute", \u015D: "scirc", \u015C: "Scirc", \u0161: "scaron", \u0160: "Scaron", \u015F: "scedil", \u015E: "Sc\
edil", \u00DF: "szlig", "\u{1D531}": "tfr", "\u{1D4C9}": "tscr", "\u{1D565}": "topf", "\u{1D4AF}": "Tscr", "\u{1D517}": "Tfr", "\u{1D54B}": "\
Topf", \u0165: "tcaron", \u0164: "Tcaron", \u0163: "tcedil", \u0162: "Tcedil", "\u2122": "trade", \u0167: "tstrok", \u0166: "Tstrok", "\u{1D4CA}": "\
uscr", "\u{1D566}": "uopf", "\u{1D532}": "ufr", "\u{1D54C}": "Uopf", "\u{1D518}": "Ufr", "\u{1D4B0}": "Uscr", \u00FA: "uacute", \u00DA: "Uac\
ute", \u00F9: "ugrave", \u00D9: "Ugrave", \u016D: "ubreve", \u016C: "Ubreve", \u00FB: "ucirc", \u00DB: "Ucirc", \u016F: "uring", \u016E: "Ur\
ing", \u00FC: "uuml", \u00DC: "Uuml", \u0171: "udblac", \u0170: "Udblac", \u0169: "utilde", \u0168: "Utilde", \u0173: "uogon", \u0172: "Uogo\
n", \u016B: "umacr", \u016A: "Umacr", "\u{1D533}": "vfr", "\u{1D567}": "vopf", "\u{1D4CB}": "vscr", "\u{1D519}": "Vfr", "\u{1D54D}": "Vopf",
    "\u{1D4B1}": "Vscr", "\u{1D568}": "wopf", "\u{1D4CC}": "wscr", "\u{1D534}": "wfr", "\u{1D4B2}": "Wscr", "\u{1D54E}": "Wopf", "\u{1D51A}": "\
Wfr", \u0175: "wcirc", \u0174: "Wcirc", "\u{1D535}": "xfr", "\u{1D4CD}": "xscr", "\u{1D569}": "xopf", "\u{1D54F}": "Xopf", "\u{1D51B}": "Xfr",
    "\u{1D4B3}": "Xscr", "\u{1D536}": "yfr", "\u{1D4CE}": "yscr", "\u{1D56A}": "yopf", "\u{1D4B4}": "Yscr", "\u{1D51C}": "Yfr", "\u{1D550}": "\
Yopf", \u00FD: "yacute", \u00DD: "Yacute", \u0177: "ycirc", \u0176: "Ycirc", \u00FF: "yuml", \u0178: "Yuml", "\u{1D4CF}": "zscr", "\u{1D537}": "\
zfr", "\u{1D56B}": "zopf", \u2128: "Zfr", \u2124: "Zopf", "\u{1D4B5}": "Zscr", \u017A: "zacute", \u0179: "Zacute", \u017E: "zcaron", \u017D: "\
Zcaron", \u017C: "zdot", \u017B: "Zdot", \u01B5: "imped", \u00FE: "thorn", \u00DE: "THORN", \u0149: "napos", \u03B1: "alpha", \u0391: "Alpha",
    \u03B2: "beta", \u0392: "Beta", \u03B3: "gamma", \u0393: "Gamma", \u03B4: "delta", \u0394: "Delta", \u03B5: "epsi", "\u03F5": "epsiv", \u0395: "\
Epsilon", \u03DD: "gammad", \u03DC: "Gammad", \u03B6: "zeta", \u0396: "Zeta", \u03B7: "eta", \u0397: "Eta", \u03B8: "theta", \u03D1: "thetav",
    \u0398: "Theta", \u03B9: "iota", \u0399: "Iota", \u03BA: "kappa", \u03F0: "kappav", \u039A: "Kappa", \u03BB: "lambda", \u039B: "Lambda",
    \u03BC: "mu", \u00B5: "micro", \u039C: "Mu", \u03BD: "nu", \u039D: "Nu", \u03BE: "xi", \u039E: "Xi", \u03BF: "omicron", \u039F: "Omicron",
    \u03C0: "pi", \u03D6: "piv", \u03A0: "Pi", \u03C1: "rho", \u03F1: "rhov", \u03A1: "Rho", \u03C3: "sigma", \u03A3: "Sigma", \u03C2: "sigm\
af", \u03C4: "tau", \u03A4: "Tau", \u03C5: "upsi", \u03A5: "Upsilon", \u03D2: "Upsi", \u03C6: "phi", \u03D5: "phiv", \u03A6: "Phi", \u03C7: "\
chi", \u03A7: "Chi", \u03C8: "psi", \u03A8: "Psi", \u03C9: "omega", \u03A9: "ohm", \u0430: "acy", \u0410: "Acy", \u0431: "bcy", \u0411: "Bcy",
    \u0432: "vcy", \u0412: "Vcy", \u0433: "gcy", \u0413: "Gcy", \u0453: "gjcy", \u0403: "GJcy", \u0434: "dcy", \u0414: "Dcy", \u0452: "djcy",
    \u0402: "DJcy", \u0435: "iecy", \u0415: "IEcy", \u0451: "iocy", \u0401: "IOcy", \u0454: "jukcy", \u0404: "Jukcy", \u0436: "zhcy", \u0416: "\
ZHcy", \u0437: "zcy", \u0417: "Zcy", \u0455: "dscy", \u0405: "DScy", \u0438: "icy", \u0418: "Icy", \u0456: "iukcy", \u0406: "Iukcy", \u0457: "\
yicy", \u0407: "YIcy", \u0439: "jcy", \u0419: "Jcy", \u0458: "jsercy", \u0408: "Jsercy", \u043A: "kcy", \u041A: "Kcy", \u045C: "kjcy", \u040C: "\
KJcy", \u043B: "lcy", \u041B: "Lcy", \u0459: "ljcy", \u0409: "LJcy", \u043C: "mcy", \u041C: "Mcy", \u043D: "ncy", \u041D: "Ncy", \u045A: "nj\
cy", \u040A: "NJcy", \u043E: "ocy", \u041E: "Ocy", \u043F: "pcy", \u041F: "Pcy", \u0440: "rcy", \u0420: "Rcy", \u0441: "scy", \u0421: "Scy",
    \u0442: "tcy", \u0422: "Tcy", \u045B: "tshcy", \u040B: "TSHcy", \u0443: "ucy", \u0423: "Ucy", \u045E: "ubrcy", \u040E: "Ubrcy", \u0444: "\
fcy", \u0424: "Fcy", \u0445: "khcy", \u0425: "KHcy", \u0446: "tscy", \u0426: "TScy", \u0447: "chcy", \u0427: "CHcy", \u045F: "dzcy", \u040F: "\
DZcy", \u0448: "shcy", \u0428: "SHcy", \u0449: "shchcy", \u0429: "SHCHcy", \u044A: "hardcy", \u042A: "HARDcy", \u044B: "ycy", \u042B: "Ycy",
    \u044C: "softcy", \u042C: "SOFTcy", \u044D: "ecy", \u042D: "Ecy", \u044E: "yucy", \u042E: "YUcy", \u044F: "yacy", \u042F: "YAcy", \u2135: "\
aleph", \u2136: "beth", \u2137: "gimel", \u2138: "daleth" }, c = /["&'<>`]/g, p = {
      '"': "&quot;",
      "&": "&amp;",
      "'": "&#x27;",
      "<": "&lt;",
      // See https://mathiasbynens.be/notes/ambiguous-ampersands: in HTML, the
      // following is not strictly necessary unless it’s part of a tag or an
      // unquoted attribute value. We’re only escaping it to support those
      // situations, and for XML support.
      ">": "&gt;",
      // In Internet Explorer ≤ 8, the backtick character can be used
      // to break out of (un)quoted attribute values or HTML comments.
      // See http://html5sec.org/#102, http://html5sec.org/#108, and
      // http://html5sec.org/#133.
      "`": "&#x60;"
    }, h = /&#(?:[xX][^a-fA-F0-9]|[^0-9xX])/, y = /[\0-\x08\x0B\x0E-\x1F\x7F-\x9F\uFDD0-\uFDEF\uFFFE\uFFFF]|[\uD83F\uD87F\uD8BF\uD8FF\uD93F\uD97F\uD9BF\uD9FF\uDA3F\uDA7F\uDABF\uDAFF\uDB3F\uDB7F\uDBBF\uDBFF][\uDFFE\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/,
    _ = /&(CounterClockwiseContourIntegral|DoubleLongLeftRightArrow|ClockwiseContourIntegral|NotNestedGreaterGreater|NotSquareSupersetEqual|DiacriticalDoubleAcute|NotRightTriangleEqual|NotSucceedsSlantEqual|NotPrecedesSlantEqual|CloseCurlyDoubleQuote|NegativeVeryThinSpace|DoubleContourIntegral|FilledVerySmallSquare|CapitalDifferentialD|OpenCurlyDoubleQuote|EmptyVerySmallSquare|NestedGreaterGreater|DoubleLongRightArrow|NotLeftTriangleEqual|NotGreaterSlantEqual|ReverseUpEquilibrium|DoubleLeftRightArrow|NotSquareSubsetEqual|NotDoubleVerticalBar|RightArrowLeftArrow|NotGreaterFullEqual|NotRightTriangleBar|SquareSupersetEqual|DownLeftRightVector|DoubleLongLeftArrow|leftrightsquigarrow|LeftArrowRightArrow|NegativeMediumSpace|blacktriangleright|RightDownVectorBar|PrecedesSlantEqual|RightDoubleBracket|SucceedsSlantEqual|NotLeftTriangleBar|RightTriangleEqual|SquareIntersection|RightDownTeeVector|ReverseEquilibrium|NegativeThickSpace|longleftrightarrow|Longleftrightarrow|LongLeftRightArrow|DownRightTeeVector|DownRightVectorBar|GreaterSlantEqual|SquareSubsetEqual|LeftDownVectorBar|LeftDoubleBracket|VerticalSeparator|rightleftharpoons|NotGreaterGreater|NotSquareSuperset|blacktriangleleft|blacktriangledown|NegativeThinSpace|LeftDownTeeVector|NotLessSlantEqual|leftrightharpoons|DoubleUpDownArrow|DoubleVerticalBar|LeftTriangleEqual|FilledSmallSquare|twoheadrightarrow|NotNestedLessLess|DownLeftTeeVector|DownLeftVectorBar|RightAngleBracket|NotTildeFullEqual|NotReverseElement|RightUpDownVector|DiacriticalTilde|NotSucceedsTilde|circlearrowright|NotPrecedesEqual|rightharpoondown|DoubleRightArrow|NotSucceedsEqual|NonBreakingSpace|NotRightTriangle|LessEqualGreater|RightUpTeeVector|LeftAngleBracket|GreaterFullEqual|DownArrowUpArrow|RightUpVectorBar|twoheadleftarrow|GreaterEqualLess|downharpoonright|RightTriangleBar|ntrianglerighteq|NotSupersetEqual|LeftUpDownVector|DiacriticalAcute|rightrightarrows|vartriangleright|UpArrowDownArrow|DiacriticalGrave|UnderParenthesis|EmptySmallSquare|LeftUpVectorBar|leftrightarrows|DownRightVector|downharpoonleft|trianglerighteq|ShortRightArrow|OverParenthesis|DoubleLeftArrow|DoubleDownArrow|NotSquareSubset|bigtriangledown|ntrianglelefteq|UpperRightArrow|curvearrowright|vartriangleleft|NotLeftTriangle|nleftrightarrow|LowerRightArrow|NotHumpDownHump|NotGreaterTilde|rightthreetimes|LeftUpTeeVector|NotGreaterEqual|straightepsilon|LeftTriangleBar|rightsquigarrow|ContourIntegral|rightleftarrows|CloseCurlyQuote|RightDownVector|LeftRightVector|nLeftrightarrow|leftharpoondown|circlearrowleft|SquareSuperset|OpenCurlyQuote|hookrightarrow|HorizontalLine|DiacriticalDot|NotLessGreater|ntriangleright|DoubleRightTee|InvisibleComma|InvisibleTimes|LowerLeftArrow|DownLeftVector|NotSubsetEqual|curvearrowleft|trianglelefteq|NotVerticalBar|TildeFullEqual|downdownarrows|NotGreaterLess|RightTeeVector|ZeroWidthSpace|looparrowright|LongRightArrow|doublebarwedge|ShortLeftArrow|ShortDownArrow|RightVectorBar|GreaterGreater|ReverseElement|rightharpoonup|LessSlantEqual|leftthreetimes|upharpoonright|rightarrowtail|LeftDownVector|Longrightarrow|NestedLessLess|UpperLeftArrow|nshortparallel|leftleftarrows|leftrightarrow|Leftrightarrow|LeftRightArrow|longrightarrow|upharpoonleft|RightArrowBar|ApplyFunction|LeftTeeVector|leftarrowtail|NotEqualTilde|varsubsetneqq|varsupsetneqq|RightTeeArrow|SucceedsEqual|SucceedsTilde|LeftVectorBar|SupersetEqual|hookleftarrow|DifferentialD|VerticalTilde|VeryThinSpace|blacktriangle|bigtriangleup|LessFullEqual|divideontimes|leftharpoonup|UpEquilibrium|ntriangleleft|RightTriangle|measuredangle|shortparallel|longleftarrow|Longleftarrow|LongLeftArrow|DoubleLeftTee|Poincareplane|PrecedesEqual|triangleright|DoubleUpArrow|RightUpVector|fallingdotseq|looparrowleft|PrecedesTilde|NotTildeEqual|NotTildeTilde|smallsetminus|Proportional|triangleleft|triangledown|UnderBracket|NotHumpEqual|exponentiale|ExponentialE|NotLessTilde|HilbertSpace|RightCeiling|blacklozenge|varsupsetneq|HumpDownHump|GreaterEqual|VerticalLine|LeftTeeArrow|NotLessEqual|DownTeeArrow|LeftTriangle|varsubsetneq|Intersection|NotCongruent|DownArrowBar|LeftUpVector|LeftArrowBar|risingdotseq|GreaterTilde|RoundImplies|SquareSubset|ShortUpArrow|NotSuperset|quaternions|precnapprox|backepsilon|preccurlyeq|OverBracket|blacksquare|MediumSpace|VerticalBar|circledcirc|circleddash|CircleMinus|CircleTimes|LessGreater|curlyeqprec|curlyeqsucc|diamondsuit|UpDownArrow|Updownarrow|RuleDelayed|Rrightarrow|updownarrow|RightVector|nRightarrow|nrightarrow|eqslantless|LeftCeiling|Equilibrium|SmallCircle|expectation|NotSucceeds|thickapprox|GreaterLess|SquareUnion|NotPrecedes|NotLessLess|straightphi|succnapprox|succcurlyeq|SubsetEqual|sqsupseteq|Proportion|Laplacetrf|ImaginaryI|supsetneqq|NotGreater|gtreqqless|NotElement|ThickSpace|TildeEqual|TildeTilde|Fouriertrf|rmoustache|EqualTilde|eqslantgtr|UnderBrace|LeftVector|UpArrowBar|nLeftarrow|nsubseteqq|subsetneqq|nsupseteqq|nleftarrow|succapprox|lessapprox|UpTeeArrow|upuparrows|curlywedge|lesseqqgtr|varepsilon|varnothing|RightFloor|complement|CirclePlus|sqsubseteq|Lleftarrow|circledast|RightArrow|Rightarrow|rightarrow|lmoustache|Bernoullis|precapprox|mapstoleft|mapstodown|longmapsto|dotsquare|downarrow|DoubleDot|nsubseteq|supsetneq|leftarrow|nsupseteq|subsetneq|ThinSpace|ngeqslant|subseteqq|HumpEqual|NotSubset|triangleq|NotCupCap|lesseqgtr|heartsuit|TripleDot|Leftarrow|Coproduct|Congruent|varpropto|complexes|gvertneqq|LeftArrow|LessTilde|supseteqq|MinusPlus|CircleDot|nleqslant|NotExists|gtreqless|nparallel|UnionPlus|LeftFloor|checkmark|CenterDot|centerdot|Mellintrf|gtrapprox|bigotimes|OverBrace|spadesuit|therefore|pitchfork|rationals|PlusMinus|Backslash|Therefore|DownBreve|backsimeq|backprime|DownArrow|nshortmid|Downarrow|lvertneqq|eqvparsl|imagline|imagpart|infintie|integers|Integral|intercal|LessLess|Uarrocir|intlarhk|sqsupset|angmsdaf|sqsubset|llcorner|vartheta|cupbrcap|lnapprox|Superset|SuchThat|succnsim|succneqq|angmsdag|biguplus|curlyvee|trpezium|Succeeds|NotTilde|bigwedge|angmsdah|angrtvbd|triminus|cwconint|fpartint|lrcorner|smeparsl|subseteq|urcorner|lurdshar|laemptyv|DDotrahd|approxeq|ldrushar|awconint|mapstoup|backcong|shortmid|triangle|geqslant|gesdotol|timesbar|circledR|circledS|setminus|multimap|naturals|scpolint|ncongdot|RightTee|boxminus|gnapprox|boxtimes|andslope|thicksim|angmsdaa|varsigma|cirfnint|rtriltri|angmsdab|rppolint|angmsdac|barwedge|drbkarow|clubsuit|thetasym|bsolhsub|capbrcup|dzigrarr|doteqdot|DotEqual|dotminus|UnderBar|NotEqual|realpart|otimesas|ulcorner|hksearow|hkswarow|parallel|PartialD|elinters|emptyset|plusacir|bbrktbrk|angmsdad|pointint|bigoplus|angmsdae|Precedes|bigsqcup|varkappa|notindot|supseteq|precneqq|precnsim|profalar|profline|profsurf|leqslant|lesdotor|raemptyv|subplus|notnivb|notnivc|subrarr|zigrarr|vzigzag|submult|subedot|Element|between|cirscir|larrbfs|larrsim|lotimes|lbrksld|lbrkslu|lozenge|ldrdhar|dbkarow|bigcirc|epsilon|simrarr|simplus|ltquest|Epsilon|luruhar|gtquest|maltese|npolint|eqcolon|npreceq|bigodot|ddagger|gtrless|bnequiv|harrcir|ddotseq|equivDD|backsim|demptyv|nsqsube|nsqsupe|Upsilon|nsubset|upsilon|minusdu|nsucceq|swarrow|nsupset|coloneq|searrow|boxplus|napprox|natural|asympeq|alefsym|congdot|nearrow|bigstar|diamond|supplus|tritime|LeftTee|nvinfin|triplus|NewLine|nvltrie|nvrtrie|nwarrow|nexists|Diamond|ruluhar|Implies|supmult|angzarr|suplarr|suphsub|questeq|because|digamma|Because|olcross|bemptyv|omicron|Omicron|rotimes|NoBreak|intprod|angrtvb|orderof|uwangle|suphsol|lesdoto|orslope|DownTee|realine|cudarrl|rdldhar|OverBar|supedot|lessdot|supdsub|topfork|succsim|rbrkslu|rbrksld|pertenk|cudarrr|isindot|planckh|lessgtr|pluscir|gesdoto|plussim|plustwo|lesssim|cularrp|rarrsim|Cayleys|notinva|notinvb|notinvc|UpArrow|Uparrow|uparrow|NotLess|dwangle|precsim|Product|curarrm|Cconint|dotplus|rarrbfs|ccupssm|Cedilla|cemptyv|notniva|quatint|frac35|frac38|frac45|frac56|frac58|frac78|tridot|xoplus|gacute|gammad|Gammad|lfisht|lfloor|bigcup|sqsupe|gbreve|Gbreve|lharul|sqsube|sqcups|Gcedil|apacir|llhard|lmidot|Lmidot|lmoust|andand|sqcaps|approx|Abreve|spades|circeq|tprime|divide|topcir|Assign|topbot|gesdot|divonx|xuplus|timesd|gesles|atilde|solbar|SOFTcy|loplus|timesb|lowast|lowbar|dlcorn|dlcrop|softcy|dollar|lparlt|thksim|lrhard|Atilde|lsaquo|smashp|bigvee|thinsp|wreath|bkarow|lsquor|lstrok|Lstrok|lthree|ltimes|ltlarr|DotDot|simdot|ltrPar|weierp|xsqcup|angmsd|sigmav|sigmaf|zeetrf|Zcaron|zcaron|mapsto|vsupne|thetav|cirmid|marker|mcomma|Zacute|vsubnE|there4|gtlPar|vsubne|bottom|gtrarr|SHCHcy|shchcy|midast|midcir|middot|minusb|minusd|gtrdot|bowtie|sfrown|mnplus|models|colone|seswar|Colone|mstpos|searhk|gtrsim|nacute|Nacute|boxbox|telrec|hairsp|Tcedil|nbumpe|scnsim|ncaron|Ncaron|ncedil|Ncedil|hamilt|Scedil|nearhk|hardcy|HARDcy|tcedil|Tcaron|commat|nequiv|nesear|tcaron|target|hearts|nexist|varrho|scedil|Scaron|scaron|hellip|Sacute|sacute|hercon|swnwar|compfn|rtimes|rthree|rsquor|rsaquo|zacute|wedgeq|homtht|barvee|barwed|Barwed|rpargt|horbar|conint|swarhk|roplus|nltrie|hslash|hstrok|Hstrok|rmoust|Conint|bprime|hybull|hyphen|iacute|Iacute|supsup|supsub|supsim|varphi|coprod|brvbar|agrave|Supset|supset|igrave|Igrave|notinE|Agrave|iiiint|iinfin|copysr|wedbar|Verbar|vangrt|becaus|incare|verbar|inodot|bullet|drcorn|intcal|drcrop|cularr|vellip|Utilde|bumpeq|cupcap|dstrok|Dstrok|CupCap|cupcup|cupdot|eacute|Eacute|supdot|iquest|easter|ecaron|Ecaron|ecolon|isinsv|utilde|itilde|Itilde|curarr|succeq|Bumpeq|cacute|ulcrop|nparsl|Cacute|nprcue|egrave|Egrave|nrarrc|nrarrw|subsup|subsub|nrtrie|jsercy|nsccue|Jsercy|kappav|kcedil|Kcedil|subsim|ulcorn|nsimeq|egsdot|veebar|kgreen|capand|elsdot|Subset|subset|curren|aacute|lacute|Lacute|emptyv|ntilde|Ntilde|lagran|lambda|Lambda|capcap|Ugrave|langle|subdot|emsp13|numero|emsp14|nvdash|nvDash|nVdash|nVDash|ugrave|ufisht|nvHarr|larrfs|nvlArr|larrhk|larrlp|larrpl|nvrArr|Udblac|nwarhk|larrtl|nwnear|oacute|Oacute|latail|lAtail|sstarf|lbrace|odblac|Odblac|lbrack|udblac|odsold|eparsl|lcaron|Lcaron|ograve|Ograve|lcedil|Lcedil|Aacute|ssmile|ssetmn|squarf|ldquor|capcup|ominus|cylcty|rharul|eqcirc|dagger|rfloor|rfisht|Dagger|daleth|equals|origof|capdot|equest|dcaron|Dcaron|rdquor|oslash|Oslash|otilde|Otilde|otimes|Otimes|urcrop|Ubreve|ubreve|Yacute|Uacute|uacute|Rcedil|rcedil|urcorn|parsim|Rcaron|Vdashl|rcaron|Tstrok|percnt|period|permil|Exists|yacute|rbrack|rbrace|phmmat|ccaron|Ccaron|planck|ccedil|plankv|tstrok|female|plusdo|plusdu|ffilig|plusmn|ffllig|Ccedil|rAtail|dfisht|bernou|ratail|Rarrtl|rarrtl|angsph|rarrpl|rarrlp|rarrhk|xwedge|xotime|forall|ForAll|Vvdash|vsupnE|preceq|bigcap|frac12|frac13|frac14|primes|rarrfs|prnsim|frac15|Square|frac16|square|lesdot|frac18|frac23|propto|prurel|rarrap|rangle|puncsp|frac25|Racute|qprime|racute|lesges|frac34|abreve|AElig|eqsim|utdot|setmn|urtri|Equal|Uring|seArr|uring|searr|dashv|Dashv|mumap|nabla|iogon|Iogon|sdote|sdotb|scsim|napid|napos|equiv|natur|Acirc|dblac|erarr|nbump|iprod|erDot|ucirc|awint|esdot|angrt|ncong|isinE|scnap|Scirc|scirc|ndash|isins|Ubrcy|nearr|neArr|isinv|nedot|ubrcy|acute|Ycirc|iukcy|Iukcy|xutri|nesim|caret|jcirc|Jcirc|caron|twixt|ddarr|sccue|exist|jmath|sbquo|ngeqq|angst|ccaps|lceil|ngsim|UpTee|delta|Delta|rtrif|nharr|nhArr|nhpar|rtrie|jukcy|Jukcy|kappa|rsquo|Kappa|nlarr|nlArr|TSHcy|rrarr|aogon|Aogon|fflig|xrarr|tshcy|ccirc|nleqq|filig|upsih|nless|dharl|nlsim|fjlig|ropar|nltri|dharr|robrk|roarr|fllig|fltns|roang|rnmid|subnE|subne|lAarr|trisb|Ccirc|acirc|ccups|blank|VDash|forkv|Vdash|langd|cedil|blk12|blk14|laquo|strns|diams|notin|vDash|larrb|blk34|block|disin|uplus|vdash|vBarv|aelig|starf|Wedge|check|xrArr|lates|lbarr|lBarr|notni|lbbrk|bcong|frasl|lbrke|frown|vrtri|vprop|vnsup|gamma|Gamma|wedge|xodot|bdquo|srarr|doteq|ldquo|boxdl|boxdL|gcirc|Gcirc|boxDl|boxDL|boxdr|boxdR|boxDr|TRADE|trade|rlhar|boxDR|vnsub|npart|vltri|rlarr|boxhd|boxhD|nprec|gescc|nrarr|nrArr|boxHd|boxHD|boxhu|boxhU|nrtri|boxHu|clubs|boxHU|times|colon|Colon|gimel|xlArr|Tilde|nsime|tilde|nsmid|nspar|THORN|thorn|xlarr|nsube|nsubE|thkap|xhArr|comma|nsucc|boxul|boxuL|nsupe|nsupE|gneqq|gnsim|boxUl|boxUL|grave|boxur|boxuR|boxUr|boxUR|lescc|angle|bepsi|boxvh|varpi|boxvH|numsp|Theta|gsime|gsiml|theta|boxVh|boxVH|boxvl|gtcir|gtdot|boxvL|boxVl|boxVL|crarr|cross|Cross|nvsim|boxvr|nwarr|nwArr|sqsup|dtdot|Uogon|lhard|lharu|dtrif|ocirc|Ocirc|lhblk|duarr|odash|sqsub|Hacek|sqcup|llarr|duhar|oelig|OElig|ofcir|boxvR|uogon|lltri|boxVr|csube|uuarr|ohbar|csupe|ctdot|olarr|olcir|harrw|oline|sqcap|omacr|Omacr|omega|Omega|boxVR|aleph|lneqq|lnsim|loang|loarr|rharu|lobrk|hcirc|operp|oplus|rhard|Hcirc|orarr|Union|order|ecirc|Ecirc|cuepr|szlig|cuesc|breve|reals|eDDot|Breve|hoarr|lopar|utrif|rdquo|Umacr|umacr|efDot|swArr|ultri|alpha|rceil|ovbar|swarr|Wcirc|wcirc|smtes|smile|bsemi|lrarr|aring|parsl|lrhar|bsime|uhblk|lrtri|cupor|Aring|uharr|uharl|slarr|rbrke|bsolb|lsime|rbbrk|RBarr|lsimg|phone|rBarr|rbarr|icirc|lsquo|Icirc|emacr|Emacr|ratio|simne|plusb|simlE|simgE|simeq|pluse|ltcir|ltdot|empty|xharr|xdtri|iexcl|Alpha|ltrie|rarrw|pound|ltrif|xcirc|bumpe|prcue|bumpE|asymp|amacr|cuvee|Sigma|sigma|iiint|udhar|iiota|ijlig|IJlig|supnE|imacr|Imacr|prime|Prime|image|prnap|eogon|Eogon|rarrc|mdash|mDDot|cuwed|imath|supne|imped|Amacr|udarr|prsim|micro|rarrb|cwint|raquo|infin|eplus|range|rangd|Ucirc|radic|minus|amalg|veeeq|rAarr|epsiv|ycirc|quest|sharp|quot|zwnj|Qscr|race|qscr|Qopf|qopf|qint|rang|Rang|Zscr|zscr|Zopf|zopf|rarr|rArr|Rarr|Pscr|pscr|prop|prod|prnE|prec|ZHcy|zhcy|prap|Zeta|zeta|Popf|popf|Zdot|plus|zdot|Yuml|yuml|phiv|YUcy|yucy|Yscr|yscr|perp|Yopf|yopf|part|para|YIcy|Ouml|rcub|yicy|YAcy|rdca|ouml|osol|Oscr|rdsh|yacy|real|oscr|xvee|andd|rect|andv|Xscr|oror|ordm|ordf|xscr|ange|aopf|Aopf|rHar|Xopf|opar|Oopf|xopf|xnis|rhov|oopf|omid|xmap|oint|apid|apos|ogon|ascr|Ascr|odot|odiv|xcup|xcap|ocir|oast|nvlt|nvle|nvgt|nvge|nvap|Wscr|wscr|auml|ntlg|ntgl|nsup|nsub|nsim|Nscr|nscr|nsce|Wopf|ring|npre|wopf|npar|Auml|Barv|bbrk|Nopf|nopf|nmid|nLtv|beta|ropf|Ropf|Beta|beth|nles|rpar|nleq|bnot|bNot|nldr|NJcy|rscr|Rscr|Vscr|vscr|rsqb|njcy|bopf|nisd|Bopf|rtri|Vopf|nGtv|ngtr|vopf|boxh|boxH|boxv|nges|ngeq|boxV|bscr|scap|Bscr|bsim|Vert|vert|bsol|bull|bump|caps|cdot|ncup|scnE|ncap|nbsp|napE|Cdot|cent|sdot|Vbar|nang|vBar|chcy|Mscr|mscr|sect|semi|CHcy|Mopf|mopf|sext|circ|cire|mldr|mlcp|cirE|comp|shcy|SHcy|vArr|varr|cong|copf|Copf|copy|COPY|malt|male|macr|lvnE|cscr|ltri|sime|ltcc|simg|Cscr|siml|csub|Uuml|lsqb|lsim|uuml|csup|Lscr|lscr|utri|smid|lpar|cups|smte|lozf|darr|Lopf|Uscr|solb|lopf|sopf|Sopf|lneq|uscr|spar|dArr|lnap|Darr|dash|Sqrt|LJcy|ljcy|lHar|dHar|Upsi|upsi|diam|lesg|djcy|DJcy|leqq|dopf|Dopf|dscr|Dscr|dscy|ldsh|ldca|squf|DScy|sscr|Sscr|dsol|lcub|late|star|Star|Uopf|Larr|lArr|larr|uopf|dtri|dzcy|sube|subE|Lang|lang|Kscr|kscr|Kopf|kopf|KJcy|kjcy|KHcy|khcy|DZcy|ecir|edot|eDot|Jscr|jscr|succ|Jopf|jopf|Edot|uHar|emsp|ensp|Iuml|iuml|eopf|isin|Iscr|iscr|Eopf|epar|sung|epsi|escr|sup1|sup2|sup3|Iota|iota|supe|supE|Iopf|iopf|IOcy|iocy|Escr|esim|Esim|imof|Uarr|QUOT|uArr|uarr|euml|IEcy|iecy|Idot|Euml|euro|excl|Hscr|hscr|Hopf|hopf|TScy|tscy|Tscr|hbar|tscr|flat|tbrk|fnof|hArr|harr|half|fopf|Fopf|tdot|gvnE|fork|trie|gtcc|fscr|Fscr|gdot|gsim|Gscr|gscr|Gopf|gopf|gneq|Gdot|tosa|gnap|Topf|topf|geqq|toea|GJcy|gjcy|tint|gesl|mid|Sfr|ggg|top|ges|gla|glE|glj|geq|gne|gEl|gel|gnE|Gcy|gcy|gap|Tfr|tfr|Tcy|tcy|Hat|Tau|Ffr|tau|Tab|hfr|Hfr|ffr|Fcy|fcy|icy|Icy|iff|ETH|eth|ifr|Ifr|Eta|eta|int|Int|Sup|sup|ucy|Ucy|Sum|sum|jcy|ENG|ufr|Ufr|eng|Jcy|jfr|els|ell|egs|Efr|efr|Jfr|uml|kcy|Kcy|Ecy|ecy|kfr|Kfr|lap|Sub|sub|lat|lcy|Lcy|leg|Dot|dot|lEg|leq|les|squ|div|die|lfr|Lfr|lgE|Dfr|dfr|Del|deg|Dcy|dcy|lne|lnE|sol|loz|smt|Cup|lrm|cup|lsh|Lsh|sim|shy|map|Map|mcy|Mcy|mfr|Mfr|mho|gfr|Gfr|sfr|cir|Chi|chi|nap|Cfr|vcy|Vcy|cfr|Scy|scy|ncy|Ncy|vee|Vee|Cap|cap|nfr|scE|sce|Nfr|nge|ngE|nGg|vfr|Vfr|ngt|bot|nGt|nis|niv|Rsh|rsh|nle|nlE|bne|Bfr|bfr|nLl|nlt|nLt|Bcy|bcy|not|Not|rlm|wfr|Wfr|npr|nsc|num|ocy|ast|Ocy|ofr|xfr|Xfr|Ofr|ogt|ohm|apE|olt|Rho|ape|rho|Rfr|rfr|ord|REG|ang|reg|orv|And|and|AMP|Rcy|amp|Afr|ycy|Ycy|yen|yfr|Yfr|rcy|par|pcy|Pcy|pfr|Pfr|phi|Phi|afr|Acy|acy|zcy|Zcy|piv|acE|acd|zfr|Zfr|pre|prE|psi|Psi|qfr|Qfr|zwj|Or|ge|Gg|gt|gg|el|oS|lt|Lt|LT|Re|lg|gl|eg|ne|Im|it|le|DD|wp|wr|nu|Nu|dd|lE|Sc|sc|pi|Pi|ee|af|ll|Ll|rx|gE|xi|pm|Xi|ic|pr|Pr|in|ni|mp|mu|ac|Mu|or|ap|Gt|GT|ii);|&(Aacute|Agrave|Atilde|Ccedil|Eacute|Egrave|Iacute|Igrave|Ntilde|Oacute|Ograve|Oslash|Otilde|Uacute|Ugrave|Yacute|aacute|agrave|atilde|brvbar|ccedil|curren|divide|eacute|egrave|frac12|frac14|frac34|iacute|igrave|iquest|middot|ntilde|oacute|ograve|oslash|otilde|plusmn|uacute|ugrave|yacute|AElig|Acirc|Aring|Ecirc|Icirc|Ocirc|THORN|Ucirc|acirc|acute|aelig|aring|cedil|ecirc|icirc|iexcl|laquo|micro|ocirc|pound|raquo|szlig|thorn|times|ucirc|Auml|COPY|Euml|Iuml|Ouml|QUOT|Uuml|auml|cent|copy|euml|iuml|macr|nbsp|ordf|ordm|ouml|para|quot|sect|sup1|sup2|sup3|uuml|yuml|AMP|ETH|REG|amp|deg|eth|not|reg|shy|uml|yen|GT|LT|gt|lt)(?!;)([=a-zA-Z0-9]?)|&#([0-9]+)(;?)|&#[xX]([a-fA-F0-9]+)(;?)|&([0-9a-zA-Z]+)/g,
    g = { aacute: "\xE1", Aacute: "\xC1", abreve: "\u0103", Abreve: "\u0102", ac: "\u223E", acd: "\u223F", acE: "\u223E\u0333", acirc: "\xE2",
    Acirc: "\xC2", acute: "\xB4", acy: "\u0430", Acy: "\u0410", aelig: "\xE6", AElig: "\xC6", af: "\u2061", afr: "\u{1D51E}", Afr: "\u{1D504}",
    agrave: "\xE0", Agrave: "\xC0", alefsym: "\u2135", aleph: "\u2135", alpha: "\u03B1", Alpha: "\u0391", amacr: "\u0101", Amacr: "\u0100", amalg: "\
\u2A3F", amp: "&", AMP: "&", and: "\u2227", And: "\u2A53", andand: "\u2A55", andd: "\u2A5C", andslope: "\u2A58", andv: "\u2A5A", ang: "\u2220",
    ange: "\u29A4", angle: "\u2220", angmsd: "\u2221", angmsdaa: "\u29A8", angmsdab: "\u29A9", angmsdac: "\u29AA", angmsdad: "\u29AB", angmsdae: "\
\u29AC", angmsdaf: "\u29AD", angmsdag: "\u29AE", angmsdah: "\u29AF", angrt: "\u221F", angrtvb: "\u22BE", angrtvbd: "\u299D", angsph: "\u2222",
    angst: "\xC5", angzarr: "\u237C", aogon: "\u0105", Aogon: "\u0104", aopf: "\u{1D552}", Aopf: "\u{1D538}", ap: "\u2248", apacir: "\u2A6F",
    ape: "\u224A", apE: "\u2A70", apid: "\u224B", apos: "'", ApplyFunction: "\u2061", approx: "\u2248", approxeq: "\u224A", aring: "\xE5", Aring: "\
\xC5", ascr: "\u{1D4B6}", Ascr: "\u{1D49C}", Assign: "\u2254", ast: "*", asymp: "\u2248", asympeq: "\u224D", atilde: "\xE3", Atilde: "\xC3",
    auml: "\xE4", Auml: "\xC4", awconint: "\u2233", awint: "\u2A11", backcong: "\u224C", backepsilon: "\u03F6", backprime: "\u2035", backsim: "\
\u223D", backsimeq: "\u22CD", Backslash: "\u2216", Barv: "\u2AE7", barvee: "\u22BD", barwed: "\u2305", Barwed: "\u2306", barwedge: "\u2305",
    bbrk: "\u23B5", bbrktbrk: "\u23B6", bcong: "\u224C", bcy: "\u0431", Bcy: "\u0411", bdquo: "\u201E", becaus: "\u2235", because: "\u2235",
    Because: "\u2235", bemptyv: "\u29B0", bepsi: "\u03F6", bernou: "\u212C", Bernoullis: "\u212C", beta: "\u03B2", Beta: "\u0392", beth: "\u2136",
    between: "\u226C", bfr: "\u{1D51F}", Bfr: "\u{1D505}", bigcap: "\u22C2", bigcirc: "\u25EF", bigcup: "\u22C3", bigodot: "\u2A00", bigoplus: "\
\u2A01", bigotimes: "\u2A02", bigsqcup: "\u2A06", bigstar: "\u2605", bigtriangledown: "\u25BD", bigtriangleup: "\u25B3", biguplus: "\u2A04",
    bigvee: "\u22C1", bigwedge: "\u22C0", bkarow: "\u290D", blacklozenge: "\u29EB", blacksquare: "\u25AA", blacktriangle: "\u25B4", blacktriangledown: "\
\u25BE", blacktriangleleft: "\u25C2", blacktriangleright: "\u25B8", blank: "\u2423", blk12: "\u2592", blk14: "\u2591", blk34: "\u2593", block: "\
\u2588", bne: "=\u20E5", bnequiv: "\u2261\u20E5", bnot: "\u2310", bNot: "\u2AED", bopf: "\u{1D553}", Bopf: "\u{1D539}", bot: "\u22A5", bottom: "\
\u22A5", bowtie: "\u22C8", boxbox: "\u29C9", boxdl: "\u2510", boxdL: "\u2555", boxDl: "\u2556", boxDL: "\u2557", boxdr: "\u250C", boxdR: "\u2552",
    boxDr: "\u2553", boxDR: "\u2554", boxh: "\u2500", boxH: "\u2550", boxhd: "\u252C", boxhD: "\u2565", boxHd: "\u2564", boxHD: "\u2566", boxhu: "\
\u2534", boxhU: "\u2568", boxHu: "\u2567", boxHU: "\u2569", boxminus: "\u229F", boxplus: "\u229E", boxtimes: "\u22A0", boxul: "\u2518", boxuL: "\
\u255B", boxUl: "\u255C", boxUL: "\u255D", boxur: "\u2514", boxuR: "\u2558", boxUr: "\u2559", boxUR: "\u255A", boxv: "\u2502", boxV: "\u2551",
    boxvh: "\u253C", boxvH: "\u256A", boxVh: "\u256B", boxVH: "\u256C", boxvl: "\u2524", boxvL: "\u2561", boxVl: "\u2562", boxVL: "\u2563", boxvr: "\
\u251C", boxvR: "\u255E", boxVr: "\u255F", boxVR: "\u2560", bprime: "\u2035", breve: "\u02D8", Breve: "\u02D8", brvbar: "\xA6", bscr: "\u{1D4B7}",
    Bscr: "\u212C", bsemi: "\u204F", bsim: "\u223D", bsime: "\u22CD", bsol: "\\", bsolb: "\u29C5", bsolhsub: "\u27C8", bull: "\u2022", bullet: "\
\u2022", bump: "\u224E", bumpe: "\u224F", bumpE: "\u2AAE", bumpeq: "\u224F", Bumpeq: "\u224E", cacute: "\u0107", Cacute: "\u0106", cap: "\u2229",
    Cap: "\u22D2", capand: "\u2A44", capbrcup: "\u2A49", capcap: "\u2A4B", capcup: "\u2A47", capdot: "\u2A40", CapitalDifferentialD: "\u2145",
    caps: "\u2229\uFE00", caret: "\u2041", caron: "\u02C7", Cayleys: "\u212D", ccaps: "\u2A4D", ccaron: "\u010D", Ccaron: "\u010C", ccedil: "\
\xE7", Ccedil: "\xC7", ccirc: "\u0109", Ccirc: "\u0108", Cconint: "\u2230", ccups: "\u2A4C", ccupssm: "\u2A50", cdot: "\u010B", Cdot: "\u010A",
    cedil: "\xB8", Cedilla: "\xB8", cemptyv: "\u29B2", cent: "\xA2", centerdot: "\xB7", CenterDot: "\xB7", cfr: "\u{1D520}", Cfr: "\u212D", chcy: "\
\u0447", CHcy: "\u0427", check: "\u2713", checkmark: "\u2713", chi: "\u03C7", Chi: "\u03A7", cir: "\u25CB", circ: "\u02C6", circeq: "\u2257",
    circlearrowleft: "\u21BA", circlearrowright: "\u21BB", circledast: "\u229B", circledcirc: "\u229A", circleddash: "\u229D", CircleDot: "\u2299",
    circledR: "\xAE", circledS: "\u24C8", CircleMinus: "\u2296", CirclePlus: "\u2295", CircleTimes: "\u2297", cire: "\u2257", cirE: "\u29C3",
    cirfnint: "\u2A10", cirmid: "\u2AEF", cirscir: "\u29C2", ClockwiseContourIntegral: "\u2232", CloseCurlyDoubleQuote: "\u201D", CloseCurlyQuote: "\
\u2019", clubs: "\u2663", clubsuit: "\u2663", colon: ":", Colon: "\u2237", colone: "\u2254", Colone: "\u2A74", coloneq: "\u2254", comma: ",",
    commat: "@", comp: "\u2201", compfn: "\u2218", complement: "\u2201", complexes: "\u2102", cong: "\u2245", congdot: "\u2A6D", Congruent: "\
\u2261", conint: "\u222E", Conint: "\u222F", ContourIntegral: "\u222E", copf: "\u{1D554}", Copf: "\u2102", coprod: "\u2210", Coproduct: "\u2210",
    copy: "\xA9", COPY: "\xA9", copysr: "\u2117", CounterClockwiseContourIntegral: "\u2233", crarr: "\u21B5", cross: "\u2717", Cross: "\u2A2F",
    cscr: "\u{1D4B8}", Cscr: "\u{1D49E}", csub: "\u2ACF", csube: "\u2AD1", csup: "\u2AD0", csupe: "\u2AD2", ctdot: "\u22EF", cudarrl: "\u2938",
    cudarrr: "\u2935", cuepr: "\u22DE", cuesc: "\u22DF", cularr: "\u21B6", cularrp: "\u293D", cup: "\u222A", Cup: "\u22D3", cupbrcap: "\u2A48",
    cupcap: "\u2A46", CupCap: "\u224D", cupcup: "\u2A4A", cupdot: "\u228D", cupor: "\u2A45", cups: "\u222A\uFE00", curarr: "\u21B7", curarrm: "\
\u293C", curlyeqprec: "\u22DE", curlyeqsucc: "\u22DF", curlyvee: "\u22CE", curlywedge: "\u22CF", curren: "\xA4", curvearrowleft: "\u21B6", curvearrowright: "\
\u21B7", cuvee: "\u22CE", cuwed: "\u22CF", cwconint: "\u2232", cwint: "\u2231", cylcty: "\u232D", dagger: "\u2020", Dagger: "\u2021", daleth: "\
\u2138", darr: "\u2193", dArr: "\u21D3", Darr: "\u21A1", dash: "\u2010", dashv: "\u22A3", Dashv: "\u2AE4", dbkarow: "\u290F", dblac: "\u02DD",
    dcaron: "\u010F", Dcaron: "\u010E", dcy: "\u0434", Dcy: "\u0414", dd: "\u2146", DD: "\u2145", ddagger: "\u2021", ddarr: "\u21CA", DDotrahd: "\
\u2911", ddotseq: "\u2A77", deg: "\xB0", Del: "\u2207", delta: "\u03B4", Delta: "\u0394", demptyv: "\u29B1", dfisht: "\u297F", dfr: "\u{1D521}",
    Dfr: "\u{1D507}", dHar: "\u2965", dharl: "\u21C3", dharr: "\u21C2", DiacriticalAcute: "\xB4", DiacriticalDot: "\u02D9", DiacriticalDoubleAcute: "\
\u02DD", DiacriticalGrave: "`", DiacriticalTilde: "\u02DC", diam: "\u22C4", diamond: "\u22C4", Diamond: "\u22C4", diamondsuit: "\u2666", diams: "\
\u2666", die: "\xA8", DifferentialD: "\u2146", digamma: "\u03DD", disin: "\u22F2", div: "\xF7", divide: "\xF7", divideontimes: "\u22C7", divonx: "\
\u22C7", djcy: "\u0452", DJcy: "\u0402", dlcorn: "\u231E", dlcrop: "\u230D", dollar: "$", dopf: "\u{1D555}", Dopf: "\u{1D53B}", dot: "\u02D9",
    Dot: "\xA8", DotDot: "\u20DC", doteq: "\u2250", doteqdot: "\u2251", DotEqual: "\u2250", dotminus: "\u2238", dotplus: "\u2214", dotsquare: "\
\u22A1", doublebarwedge: "\u2306", DoubleContourIntegral: "\u222F", DoubleDot: "\xA8", DoubleDownArrow: "\u21D3", DoubleLeftArrow: "\u21D0",
    DoubleLeftRightArrow: "\u21D4", DoubleLeftTee: "\u2AE4", DoubleLongLeftArrow: "\u27F8", DoubleLongLeftRightArrow: "\u27FA", DoubleLongRightArrow: "\
\u27F9", DoubleRightArrow: "\u21D2", DoubleRightTee: "\u22A8", DoubleUpArrow: "\u21D1", DoubleUpDownArrow: "\u21D5", DoubleVerticalBar: "\u2225",
    downarrow: "\u2193", Downarrow: "\u21D3", DownArrow: "\u2193", DownArrowBar: "\u2913", DownArrowUpArrow: "\u21F5", DownBreve: "\u0311", downdownarrows: "\
\u21CA", downharpoonleft: "\u21C3", downharpoonright: "\u21C2", DownLeftRightVector: "\u2950", DownLeftTeeVector: "\u295E", DownLeftVector: "\
\u21BD", DownLeftVectorBar: "\u2956", DownRightTeeVector: "\u295F", DownRightVector: "\u21C1", DownRightVectorBar: "\u2957", DownTee: "\u22A4",
    DownTeeArrow: "\u21A7", drbkarow: "\u2910", drcorn: "\u231F", drcrop: "\u230C", dscr: "\u{1D4B9}", Dscr: "\u{1D49F}", dscy: "\u0455", DScy: "\
\u0405", dsol: "\u29F6", dstrok: "\u0111", Dstrok: "\u0110", dtdot: "\u22F1", dtri: "\u25BF", dtrif: "\u25BE", duarr: "\u21F5", duhar: "\u296F",
    dwangle: "\u29A6", dzcy: "\u045F", DZcy: "\u040F", dzigrarr: "\u27FF", eacute: "\xE9", Eacute: "\xC9", easter: "\u2A6E", ecaron: "\u011B",
    Ecaron: "\u011A", ecir: "\u2256", ecirc: "\xEA", Ecirc: "\xCA", ecolon: "\u2255", ecy: "\u044D", Ecy: "\u042D", eDDot: "\u2A77", edot: "\
\u0117", eDot: "\u2251", Edot: "\u0116", ee: "\u2147", efDot: "\u2252", efr: "\u{1D522}", Efr: "\u{1D508}", eg: "\u2A9A", egrave: "\xE8", Egrave: "\
\xC8", egs: "\u2A96", egsdot: "\u2A98", el: "\u2A99", Element: "\u2208", elinters: "\u23E7", ell: "\u2113", els: "\u2A95", elsdot: "\u2A97",
    emacr: "\u0113", Emacr: "\u0112", empty: "\u2205", emptyset: "\u2205", EmptySmallSquare: "\u25FB", emptyv: "\u2205", EmptyVerySmallSquare: "\
\u25AB", emsp: "\u2003", emsp13: "\u2004", emsp14: "\u2005", eng: "\u014B", ENG: "\u014A", ensp: "\u2002", eogon: "\u0119", Eogon: "\u0118",
    eopf: "\u{1D556}", Eopf: "\u{1D53C}", epar: "\u22D5", eparsl: "\u29E3", eplus: "\u2A71", epsi: "\u03B5", epsilon: "\u03B5", Epsilon: "\u0395",
    epsiv: "\u03F5", eqcirc: "\u2256", eqcolon: "\u2255", eqsim: "\u2242", eqslantgtr: "\u2A96", eqslantless: "\u2A95", Equal: "\u2A75", equals: "\
=", EqualTilde: "\u2242", equest: "\u225F", Equilibrium: "\u21CC", equiv: "\u2261", equivDD: "\u2A78", eqvparsl: "\u29E5", erarr: "\u2971", erDot: "\
\u2253", escr: "\u212F", Escr: "\u2130", esdot: "\u2250", esim: "\u2242", Esim: "\u2A73", eta: "\u03B7", Eta: "\u0397", eth: "\xF0", ETH: "\xD0",
    euml: "\xEB", Euml: "\xCB", euro: "\u20AC", excl: "!", exist: "\u2203", Exists: "\u2203", expectation: "\u2130", exponentiale: "\u2147",
    ExponentialE: "\u2147", fallingdotseq: "\u2252", fcy: "\u0444", Fcy: "\u0424", female: "\u2640", ffilig: "\uFB03", fflig: "\uFB00", ffllig: "\
\uFB04", ffr: "\u{1D523}", Ffr: "\u{1D509}", filig: "\uFB01", FilledSmallSquare: "\u25FC", FilledVerySmallSquare: "\u25AA", fjlig: "fj", flat: "\
\u266D", fllig: "\uFB02", fltns: "\u25B1", fnof: "\u0192", fopf: "\u{1D557}", Fopf: "\u{1D53D}", forall: "\u2200", ForAll: "\u2200", fork: "\
\u22D4", forkv: "\u2AD9", Fouriertrf: "\u2131", fpartint: "\u2A0D", frac12: "\xBD", frac13: "\u2153", frac14: "\xBC", frac15: "\u2155", frac16: "\
\u2159", frac18: "\u215B", frac23: "\u2154", frac25: "\u2156", frac34: "\xBE", frac35: "\u2157", frac38: "\u215C", frac45: "\u2158", frac56: "\
\u215A", frac58: "\u215D", frac78: "\u215E", frasl: "\u2044", frown: "\u2322", fscr: "\u{1D4BB}", Fscr: "\u2131", gacute: "\u01F5", gamma: "\
\u03B3", Gamma: "\u0393", gammad: "\u03DD", Gammad: "\u03DC", gap: "\u2A86", gbreve: "\u011F", Gbreve: "\u011E", Gcedil: "\u0122", gcirc: "\u011D",
    Gcirc: "\u011C", gcy: "\u0433", Gcy: "\u0413", gdot: "\u0121", Gdot: "\u0120", ge: "\u2265", gE: "\u2267", gel: "\u22DB", gEl: "\u2A8C",
    geq: "\u2265", geqq: "\u2267", geqslant: "\u2A7E", ges: "\u2A7E", gescc: "\u2AA9", gesdot: "\u2A80", gesdoto: "\u2A82", gesdotol: "\u2A84",
    gesl: "\u22DB\uFE00", gesles: "\u2A94", gfr: "\u{1D524}", Gfr: "\u{1D50A}", gg: "\u226B", Gg: "\u22D9", ggg: "\u22D9", gimel: "\u2137", gjcy: "\
\u0453", GJcy: "\u0403", gl: "\u2277", gla: "\u2AA5", glE: "\u2A92", glj: "\u2AA4", gnap: "\u2A8A", gnapprox: "\u2A8A", gne: "\u2A88", gnE: "\
\u2269", gneq: "\u2A88", gneqq: "\u2269", gnsim: "\u22E7", gopf: "\u{1D558}", Gopf: "\u{1D53E}", grave: "`", GreaterEqual: "\u2265", GreaterEqualLess: "\
\u22DB", GreaterFullEqual: "\u2267", GreaterGreater: "\u2AA2", GreaterLess: "\u2277", GreaterSlantEqual: "\u2A7E", GreaterTilde: "\u2273", gscr: "\
\u210A", Gscr: "\u{1D4A2}", gsim: "\u2273", gsime: "\u2A8E", gsiml: "\u2A90", gt: ">", Gt: "\u226B", GT: ">", gtcc: "\u2AA7", gtcir: "\u2A7A",
    gtdot: "\u22D7", gtlPar: "\u2995", gtquest: "\u2A7C", gtrapprox: "\u2A86", gtrarr: "\u2978", gtrdot: "\u22D7", gtreqless: "\u22DB", gtreqqless: "\
\u2A8C", gtrless: "\u2277", gtrsim: "\u2273", gvertneqq: "\u2269\uFE00", gvnE: "\u2269\uFE00", Hacek: "\u02C7", hairsp: "\u200A", half: "\xBD",
    hamilt: "\u210B", hardcy: "\u044A", HARDcy: "\u042A", harr: "\u2194", hArr: "\u21D4", harrcir: "\u2948", harrw: "\u21AD", Hat: "^", hbar: "\
\u210F", hcirc: "\u0125", Hcirc: "\u0124", hearts: "\u2665", heartsuit: "\u2665", hellip: "\u2026", hercon: "\u22B9", hfr: "\u{1D525}", Hfr: "\
\u210C", HilbertSpace: "\u210B", hksearow: "\u2925", hkswarow: "\u2926", hoarr: "\u21FF", homtht: "\u223B", hookleftarrow: "\u21A9", hookrightarrow: "\
\u21AA", hopf: "\u{1D559}", Hopf: "\u210D", horbar: "\u2015", HorizontalLine: "\u2500", hscr: "\u{1D4BD}", Hscr: "\u210B", hslash: "\u210F",
    hstrok: "\u0127", Hstrok: "\u0126", HumpDownHump: "\u224E", HumpEqual: "\u224F", hybull: "\u2043", hyphen: "\u2010", iacute: "\xED", Iacute: "\
\xCD", ic: "\u2063", icirc: "\xEE", Icirc: "\xCE", icy: "\u0438", Icy: "\u0418", Idot: "\u0130", iecy: "\u0435", IEcy: "\u0415", iexcl: "\xA1",
    iff: "\u21D4", ifr: "\u{1D526}", Ifr: "\u2111", igrave: "\xEC", Igrave: "\xCC", ii: "\u2148", iiiint: "\u2A0C", iiint: "\u222D", iinfin: "\
\u29DC", iiota: "\u2129", ijlig: "\u0133", IJlig: "\u0132", Im: "\u2111", imacr: "\u012B", Imacr: "\u012A", image: "\u2111", ImaginaryI: "\u2148",
    imagline: "\u2110", imagpart: "\u2111", imath: "\u0131", imof: "\u22B7", imped: "\u01B5", Implies: "\u21D2", in: "\u2208", incare: "\u2105",
    infin: "\u221E", infintie: "\u29DD", inodot: "\u0131", int: "\u222B", Int: "\u222C", intcal: "\u22BA", integers: "\u2124", Integral: "\u222B",
    intercal: "\u22BA", Intersection: "\u22C2", intlarhk: "\u2A17", intprod: "\u2A3C", InvisibleComma: "\u2063", InvisibleTimes: "\u2062", iocy: "\
\u0451", IOcy: "\u0401", iogon: "\u012F", Iogon: "\u012E", iopf: "\u{1D55A}", Iopf: "\u{1D540}", iota: "\u03B9", Iota: "\u0399", iprod: "\u2A3C",
    iquest: "\xBF", iscr: "\u{1D4BE}", Iscr: "\u2110", isin: "\u2208", isindot: "\u22F5", isinE: "\u22F9", isins: "\u22F4", isinsv: "\u22F3",
    isinv: "\u2208", it: "\u2062", itilde: "\u0129", Itilde: "\u0128", iukcy: "\u0456", Iukcy: "\u0406", iuml: "\xEF", Iuml: "\xCF", jcirc: "\
\u0135", Jcirc: "\u0134", jcy: "\u0439", Jcy: "\u0419", jfr: "\u{1D527}", Jfr: "\u{1D50D}", jmath: "\u0237", jopf: "\u{1D55B}", Jopf: "\u{1D541}",
    jscr: "\u{1D4BF}", Jscr: "\u{1D4A5}", jsercy: "\u0458", Jsercy: "\u0408", jukcy: "\u0454", Jukcy: "\u0404", kappa: "\u03BA", Kappa: "\u039A",
    kappav: "\u03F0", kcedil: "\u0137", Kcedil: "\u0136", kcy: "\u043A", Kcy: "\u041A", kfr: "\u{1D528}", Kfr: "\u{1D50E}", kgreen: "\u0138",
    khcy: "\u0445", KHcy: "\u0425", kjcy: "\u045C", KJcy: "\u040C", kopf: "\u{1D55C}", Kopf: "\u{1D542}", kscr: "\u{1D4C0}", Kscr: "\u{1D4A6}",
    lAarr: "\u21DA", lacute: "\u013A", Lacute: "\u0139", laemptyv: "\u29B4", lagran: "\u2112", lambda: "\u03BB", Lambda: "\u039B", lang: "\u27E8",
    Lang: "\u27EA", langd: "\u2991", langle: "\u27E8", lap: "\u2A85", Laplacetrf: "\u2112", laquo: "\xAB", larr: "\u2190", lArr: "\u21D0", Larr: "\
\u219E", larrb: "\u21E4", larrbfs: "\u291F", larrfs: "\u291D", larrhk: "\u21A9", larrlp: "\u21AB", larrpl: "\u2939", larrsim: "\u2973", larrtl: "\
\u21A2", lat: "\u2AAB", latail: "\u2919", lAtail: "\u291B", late: "\u2AAD", lates: "\u2AAD\uFE00", lbarr: "\u290C", lBarr: "\u290E", lbbrk: "\
\u2772", lbrace: "{", lbrack: "[", lbrke: "\u298B", lbrksld: "\u298F", lbrkslu: "\u298D", lcaron: "\u013E", Lcaron: "\u013D", lcedil: "\u013C",
    Lcedil: "\u013B", lceil: "\u2308", lcub: "{", lcy: "\u043B", Lcy: "\u041B", ldca: "\u2936", ldquo: "\u201C", ldquor: "\u201E", ldrdhar: "\
\u2967", ldrushar: "\u294B", ldsh: "\u21B2", le: "\u2264", lE: "\u2266", LeftAngleBracket: "\u27E8", leftarrow: "\u2190", Leftarrow: "\u21D0",
    LeftArrow: "\u2190", LeftArrowBar: "\u21E4", LeftArrowRightArrow: "\u21C6", leftarrowtail: "\u21A2", LeftCeiling: "\u2308", LeftDoubleBracket: "\
\u27E6", LeftDownTeeVector: "\u2961", LeftDownVector: "\u21C3", LeftDownVectorBar: "\u2959", LeftFloor: "\u230A", leftharpoondown: "\u21BD",
    leftharpoonup: "\u21BC", leftleftarrows: "\u21C7", leftrightarrow: "\u2194", Leftrightarrow: "\u21D4", LeftRightArrow: "\u2194", leftrightarrows: "\
\u21C6", leftrightharpoons: "\u21CB", leftrightsquigarrow: "\u21AD", LeftRightVector: "\u294E", LeftTee: "\u22A3", LeftTeeArrow: "\u21A4", LeftTeeVector: "\
\u295A", leftthreetimes: "\u22CB", LeftTriangle: "\u22B2", LeftTriangleBar: "\u29CF", LeftTriangleEqual: "\u22B4", LeftUpDownVector: "\u2951",
    LeftUpTeeVector: "\u2960", LeftUpVector: "\u21BF", LeftUpVectorBar: "\u2958", LeftVector: "\u21BC", LeftVectorBar: "\u2952", leg: "\u22DA",
    lEg: "\u2A8B", leq: "\u2264", leqq: "\u2266", leqslant: "\u2A7D", les: "\u2A7D", lescc: "\u2AA8", lesdot: "\u2A7F", lesdoto: "\u2A81", lesdotor: "\
\u2A83", lesg: "\u22DA\uFE00", lesges: "\u2A93", lessapprox: "\u2A85", lessdot: "\u22D6", lesseqgtr: "\u22DA", lesseqqgtr: "\u2A8B", LessEqualGreater: "\
\u22DA", LessFullEqual: "\u2266", LessGreater: "\u2276", lessgtr: "\u2276", LessLess: "\u2AA1", lesssim: "\u2272", LessSlantEqual: "\u2A7D",
    LessTilde: "\u2272", lfisht: "\u297C", lfloor: "\u230A", lfr: "\u{1D529}", Lfr: "\u{1D50F}", lg: "\u2276", lgE: "\u2A91", lHar: "\u2962",
    lhard: "\u21BD", lharu: "\u21BC", lharul: "\u296A", lhblk: "\u2584", ljcy: "\u0459", LJcy: "\u0409", ll: "\u226A", Ll: "\u22D8", llarr: "\
\u21C7", llcorner: "\u231E", Lleftarrow: "\u21DA", llhard: "\u296B", lltri: "\u25FA", lmidot: "\u0140", Lmidot: "\u013F", lmoust: "\u23B0", lmoustache: "\
\u23B0", lnap: "\u2A89", lnapprox: "\u2A89", lne: "\u2A87", lnE: "\u2268", lneq: "\u2A87", lneqq: "\u2268", lnsim: "\u22E6", loang: "\u27EC",
    loarr: "\u21FD", lobrk: "\u27E6", longleftarrow: "\u27F5", Longleftarrow: "\u27F8", LongLeftArrow: "\u27F5", longleftrightarrow: "\u27F7",
    Longleftrightarrow: "\u27FA", LongLeftRightArrow: "\u27F7", longmapsto: "\u27FC", longrightarrow: "\u27F6", Longrightarrow: "\u27F9", LongRightArrow: "\
\u27F6", looparrowleft: "\u21AB", looparrowright: "\u21AC", lopar: "\u2985", lopf: "\u{1D55D}", Lopf: "\u{1D543}", loplus: "\u2A2D", lotimes: "\
\u2A34", lowast: "\u2217", lowbar: "_", LowerLeftArrow: "\u2199", LowerRightArrow: "\u2198", loz: "\u25CA", lozenge: "\u25CA", lozf: "\u29EB",
    lpar: "(", lparlt: "\u2993", lrarr: "\u21C6", lrcorner: "\u231F", lrhar: "\u21CB", lrhard: "\u296D", lrm: "\u200E", lrtri: "\u22BF", lsaquo: "\
\u2039", lscr: "\u{1D4C1}", Lscr: "\u2112", lsh: "\u21B0", Lsh: "\u21B0", lsim: "\u2272", lsime: "\u2A8D", lsimg: "\u2A8F", lsqb: "[", lsquo: "\
\u2018", lsquor: "\u201A", lstrok: "\u0142", Lstrok: "\u0141", lt: "<", Lt: "\u226A", LT: "<", ltcc: "\u2AA6", ltcir: "\u2A79", ltdot: "\u22D6",
    lthree: "\u22CB", ltimes: "\u22C9", ltlarr: "\u2976", ltquest: "\u2A7B", ltri: "\u25C3", ltrie: "\u22B4", ltrif: "\u25C2", ltrPar: "\u2996",
    lurdshar: "\u294A", luruhar: "\u2966", lvertneqq: "\u2268\uFE00", lvnE: "\u2268\uFE00", macr: "\xAF", male: "\u2642", malt: "\u2720", maltese: "\
\u2720", map: "\u21A6", Map: "\u2905", mapsto: "\u21A6", mapstodown: "\u21A7", mapstoleft: "\u21A4", mapstoup: "\u21A5", marker: "\u25AE", mcomma: "\
\u2A29", mcy: "\u043C", Mcy: "\u041C", mdash: "\u2014", mDDot: "\u223A", measuredangle: "\u2221", MediumSpace: "\u205F", Mellintrf: "\u2133",
    mfr: "\u{1D52A}", Mfr: "\u{1D510}", mho: "\u2127", micro: "\xB5", mid: "\u2223", midast: "*", midcir: "\u2AF0", middot: "\xB7", minus: "\
\u2212", minusb: "\u229F", minusd: "\u2238", minusdu: "\u2A2A", MinusPlus: "\u2213", mlcp: "\u2ADB", mldr: "\u2026", mnplus: "\u2213", models: "\
\u22A7", mopf: "\u{1D55E}", Mopf: "\u{1D544}", mp: "\u2213", mscr: "\u{1D4C2}", Mscr: "\u2133", mstpos: "\u223E", mu: "\u03BC", Mu: "\u039C",
    multimap: "\u22B8", mumap: "\u22B8", nabla: "\u2207", nacute: "\u0144", Nacute: "\u0143", nang: "\u2220\u20D2", nap: "\u2249", napE: "\u2A70\u0338",
    napid: "\u224B\u0338", napos: "\u0149", napprox: "\u2249", natur: "\u266E", natural: "\u266E", naturals: "\u2115", nbsp: "\xA0", nbump: "\
\u224E\u0338", nbumpe: "\u224F\u0338", ncap: "\u2A43", ncaron: "\u0148", Ncaron: "\u0147", ncedil: "\u0146", Ncedil: "\u0145", ncong: "\u2247",
    ncongdot: "\u2A6D\u0338", ncup: "\u2A42", ncy: "\u043D", Ncy: "\u041D", ndash: "\u2013", ne: "\u2260", nearhk: "\u2924", nearr: "\u2197",
    neArr: "\u21D7", nearrow: "\u2197", nedot: "\u2250\u0338", NegativeMediumSpace: "\u200B", NegativeThickSpace: "\u200B", NegativeThinSpace: "\
\u200B", NegativeVeryThinSpace: "\u200B", nequiv: "\u2262", nesear: "\u2928", nesim: "\u2242\u0338", NestedGreaterGreater: "\u226B", NestedLessLess: "\
\u226A", NewLine: `
`, nexist: "\u2204", nexists: "\u2204", nfr: "\u{1D52B}", Nfr: "\u{1D511}", nge: "\u2271", ngE: "\u2267\u0338", ngeq: "\u2271", ngeqq: "\u2267\u0338",
    ngeqslant: "\u2A7E\u0338", nges: "\u2A7E\u0338", nGg: "\u22D9\u0338", ngsim: "\u2275", ngt: "\u226F", nGt: "\u226B\u20D2", ngtr: "\u226F",
    nGtv: "\u226B\u0338", nharr: "\u21AE", nhArr: "\u21CE", nhpar: "\u2AF2", ni: "\u220B", nis: "\u22FC", nisd: "\u22FA", niv: "\u220B", njcy: "\
\u045A", NJcy: "\u040A", nlarr: "\u219A", nlArr: "\u21CD", nldr: "\u2025", nle: "\u2270", nlE: "\u2266\u0338", nleftarrow: "\u219A", nLeftarrow: "\
\u21CD", nleftrightarrow: "\u21AE", nLeftrightarrow: "\u21CE", nleq: "\u2270", nleqq: "\u2266\u0338", nleqslant: "\u2A7D\u0338", nles: "\u2A7D\u0338",
    nless: "\u226E", nLl: "\u22D8\u0338", nlsim: "\u2274", nlt: "\u226E", nLt: "\u226A\u20D2", nltri: "\u22EA", nltrie: "\u22EC", nLtv: "\u226A\u0338",
    nmid: "\u2224", NoBreak: "\u2060", NonBreakingSpace: "\xA0", nopf: "\u{1D55F}", Nopf: "\u2115", not: "\xAC", Not: "\u2AEC", NotCongruent: "\
\u2262", NotCupCap: "\u226D", NotDoubleVerticalBar: "\u2226", NotElement: "\u2209", NotEqual: "\u2260", NotEqualTilde: "\u2242\u0338", NotExists: "\
\u2204", NotGreater: "\u226F", NotGreaterEqual: "\u2271", NotGreaterFullEqual: "\u2267\u0338", NotGreaterGreater: "\u226B\u0338", NotGreaterLess: "\
\u2279", NotGreaterSlantEqual: "\u2A7E\u0338", NotGreaterTilde: "\u2275", NotHumpDownHump: "\u224E\u0338", NotHumpEqual: "\u224F\u0338", notin: "\
\u2209", notindot: "\u22F5\u0338", notinE: "\u22F9\u0338", notinva: "\u2209", notinvb: "\u22F7", notinvc: "\u22F6", NotLeftTriangle: "\u22EA",
    NotLeftTriangleBar: "\u29CF\u0338", NotLeftTriangleEqual: "\u22EC", NotLess: "\u226E", NotLessEqual: "\u2270", NotLessGreater: "\u2278",
    NotLessLess: "\u226A\u0338", NotLessSlantEqual: "\u2A7D\u0338", NotLessTilde: "\u2274", NotNestedGreaterGreater: "\u2AA2\u0338", NotNestedLessLess: "\
\u2AA1\u0338", notni: "\u220C", notniva: "\u220C", notnivb: "\u22FE", notnivc: "\u22FD", NotPrecedes: "\u2280", NotPrecedesEqual: "\u2AAF\u0338",
    NotPrecedesSlantEqual: "\u22E0", NotReverseElement: "\u220C", NotRightTriangle: "\u22EB", NotRightTriangleBar: "\u29D0\u0338", NotRightTriangleEqual: "\
\u22ED", NotSquareSubset: "\u228F\u0338", NotSquareSubsetEqual: "\u22E2", NotSquareSuperset: "\u2290\u0338", NotSquareSupersetEqual: "\u22E3",
    NotSubset: "\u2282\u20D2", NotSubsetEqual: "\u2288", NotSucceeds: "\u2281", NotSucceedsEqual: "\u2AB0\u0338", NotSucceedsSlantEqual: "\u22E1",
    NotSucceedsTilde: "\u227F\u0338", NotSuperset: "\u2283\u20D2", NotSupersetEqual: "\u2289", NotTilde: "\u2241", NotTildeEqual: "\u2244", NotTildeFullEqual: "\
\u2247", NotTildeTilde: "\u2249", NotVerticalBar: "\u2224", npar: "\u2226", nparallel: "\u2226", nparsl: "\u2AFD\u20E5", npart: "\u2202\u0338",
    npolint: "\u2A14", npr: "\u2280", nprcue: "\u22E0", npre: "\u2AAF\u0338", nprec: "\u2280", npreceq: "\u2AAF\u0338", nrarr: "\u219B", nrArr: "\
\u21CF", nrarrc: "\u2933\u0338", nrarrw: "\u219D\u0338", nrightarrow: "\u219B", nRightarrow: "\u21CF", nrtri: "\u22EB", nrtrie: "\u22ED", nsc: "\
\u2281", nsccue: "\u22E1", nsce: "\u2AB0\u0338", nscr: "\u{1D4C3}", Nscr: "\u{1D4A9}", nshortmid: "\u2224", nshortparallel: "\u2226", nsim: "\
\u2241", nsime: "\u2244", nsimeq: "\u2244", nsmid: "\u2224", nspar: "\u2226", nsqsube: "\u22E2", nsqsupe: "\u22E3", nsub: "\u2284", nsube: "\
\u2288", nsubE: "\u2AC5\u0338", nsubset: "\u2282\u20D2", nsubseteq: "\u2288", nsubseteqq: "\u2AC5\u0338", nsucc: "\u2281", nsucceq: "\u2AB0\u0338",
    nsup: "\u2285", nsupe: "\u2289", nsupE: "\u2AC6\u0338", nsupset: "\u2283\u20D2", nsupseteq: "\u2289", nsupseteqq: "\u2AC6\u0338", ntgl: "\
\u2279", ntilde: "\xF1", Ntilde: "\xD1", ntlg: "\u2278", ntriangleleft: "\u22EA", ntrianglelefteq: "\u22EC", ntriangleright: "\u22EB", ntrianglerighteq: "\
\u22ED", nu: "\u03BD", Nu: "\u039D", num: "#", numero: "\u2116", numsp: "\u2007", nvap: "\u224D\u20D2", nvdash: "\u22AC", nvDash: "\u22AD", nVdash: "\
\u22AE", nVDash: "\u22AF", nvge: "\u2265\u20D2", nvgt: ">\u20D2", nvHarr: "\u2904", nvinfin: "\u29DE", nvlArr: "\u2902", nvle: "\u2264\u20D2",
    nvlt: "<\u20D2", nvltrie: "\u22B4\u20D2", nvrArr: "\u2903", nvrtrie: "\u22B5\u20D2", nvsim: "\u223C\u20D2", nwarhk: "\u2923", nwarr: "\u2196",
    nwArr: "\u21D6", nwarrow: "\u2196", nwnear: "\u2927", oacute: "\xF3", Oacute: "\xD3", oast: "\u229B", ocir: "\u229A", ocirc: "\xF4", Ocirc: "\
\xD4", ocy: "\u043E", Ocy: "\u041E", odash: "\u229D", odblac: "\u0151", Odblac: "\u0150", odiv: "\u2A38", odot: "\u2299", odsold: "\u29BC", oelig: "\
\u0153", OElig: "\u0152", ofcir: "\u29BF", ofr: "\u{1D52C}", Ofr: "\u{1D512}", ogon: "\u02DB", ograve: "\xF2", Ograve: "\xD2", ogt: "\u29C1",
    ohbar: "\u29B5", ohm: "\u03A9", oint: "\u222E", olarr: "\u21BA", olcir: "\u29BE", olcross: "\u29BB", oline: "\u203E", olt: "\u29C0", omacr: "\
\u014D", Omacr: "\u014C", omega: "\u03C9", Omega: "\u03A9", omicron: "\u03BF", Omicron: "\u039F", omid: "\u29B6", ominus: "\u2296", oopf: "\u{1D560}",
    Oopf: "\u{1D546}", opar: "\u29B7", OpenCurlyDoubleQuote: "\u201C", OpenCurlyQuote: "\u2018", operp: "\u29B9", oplus: "\u2295", or: "\u2228",
    Or: "\u2A54", orarr: "\u21BB", ord: "\u2A5D", order: "\u2134", orderof: "\u2134", ordf: "\xAA", ordm: "\xBA", origof: "\u22B6", oror: "\u2A56",
    orslope: "\u2A57", orv: "\u2A5B", oS: "\u24C8", oscr: "\u2134", Oscr: "\u{1D4AA}", oslash: "\xF8", Oslash: "\xD8", osol: "\u2298", otilde: "\
\xF5", Otilde: "\xD5", otimes: "\u2297", Otimes: "\u2A37", otimesas: "\u2A36", ouml: "\xF6", Ouml: "\xD6", ovbar: "\u233D", OverBar: "\u203E",
    OverBrace: "\u23DE", OverBracket: "\u23B4", OverParenthesis: "\u23DC", par: "\u2225", para: "\xB6", parallel: "\u2225", parsim: "\u2AF3",
    parsl: "\u2AFD", part: "\u2202", PartialD: "\u2202", pcy: "\u043F", Pcy: "\u041F", percnt: "%", period: ".", permil: "\u2030", perp: "\u22A5",
    pertenk: "\u2031", pfr: "\u{1D52D}", Pfr: "\u{1D513}", phi: "\u03C6", Phi: "\u03A6", phiv: "\u03D5", phmmat: "\u2133", phone: "\u260E", pi: "\
\u03C0", Pi: "\u03A0", pitchfork: "\u22D4", piv: "\u03D6", planck: "\u210F", planckh: "\u210E", plankv: "\u210F", plus: "+", plusacir: "\u2A23",
    plusb: "\u229E", pluscir: "\u2A22", plusdo: "\u2214", plusdu: "\u2A25", pluse: "\u2A72", PlusMinus: "\xB1", plusmn: "\xB1", plussim: "\u2A26",
    plustwo: "\u2A27", pm: "\xB1", Poincareplane: "\u210C", pointint: "\u2A15", popf: "\u{1D561}", Popf: "\u2119", pound: "\xA3", pr: "\u227A",
    Pr: "\u2ABB", prap: "\u2AB7", prcue: "\u227C", pre: "\u2AAF", prE: "\u2AB3", prec: "\u227A", precapprox: "\u2AB7", preccurlyeq: "\u227C",
    Precedes: "\u227A", PrecedesEqual: "\u2AAF", PrecedesSlantEqual: "\u227C", PrecedesTilde: "\u227E", preceq: "\u2AAF", precnapprox: "\u2AB9",
    precneqq: "\u2AB5", precnsim: "\u22E8", precsim: "\u227E", prime: "\u2032", Prime: "\u2033", primes: "\u2119", prnap: "\u2AB9", prnE: "\u2AB5",
    prnsim: "\u22E8", prod: "\u220F", Product: "\u220F", profalar: "\u232E", profline: "\u2312", profsurf: "\u2313", prop: "\u221D", Proportion: "\
\u2237", Proportional: "\u221D", propto: "\u221D", prsim: "\u227E", prurel: "\u22B0", pscr: "\u{1D4C5}", Pscr: "\u{1D4AB}", psi: "\u03C8", Psi: "\
\u03A8", puncsp: "\u2008", qfr: "\u{1D52E}", Qfr: "\u{1D514}", qint: "\u2A0C", qopf: "\u{1D562}", Qopf: "\u211A", qprime: "\u2057", qscr: "\u{1D4C6}",
    Qscr: "\u{1D4AC}", quaternions: "\u210D", quatint: "\u2A16", quest: "?", questeq: "\u225F", quot: '"', QUOT: '"', rAarr: "\u21DB", race: "\
\u223D\u0331", racute: "\u0155", Racute: "\u0154", radic: "\u221A", raemptyv: "\u29B3", rang: "\u27E9", Rang: "\u27EB", rangd: "\u2992", range: "\
\u29A5", rangle: "\u27E9", raquo: "\xBB", rarr: "\u2192", rArr: "\u21D2", Rarr: "\u21A0", rarrap: "\u2975", rarrb: "\u21E5", rarrbfs: "\u2920",
    rarrc: "\u2933", rarrfs: "\u291E", rarrhk: "\u21AA", rarrlp: "\u21AC", rarrpl: "\u2945", rarrsim: "\u2974", rarrtl: "\u21A3", Rarrtl: "\u2916",
    rarrw: "\u219D", ratail: "\u291A", rAtail: "\u291C", ratio: "\u2236", rationals: "\u211A", rbarr: "\u290D", rBarr: "\u290F", RBarr: "\u2910",
    rbbrk: "\u2773", rbrace: "}", rbrack: "]", rbrke: "\u298C", rbrksld: "\u298E", rbrkslu: "\u2990", rcaron: "\u0159", Rcaron: "\u0158", rcedil: "\
\u0157", Rcedil: "\u0156", rceil: "\u2309", rcub: "}", rcy: "\u0440", Rcy: "\u0420", rdca: "\u2937", rdldhar: "\u2969", rdquo: "\u201D", rdquor: "\
\u201D", rdsh: "\u21B3", Re: "\u211C", real: "\u211C", realine: "\u211B", realpart: "\u211C", reals: "\u211D", rect: "\u25AD", reg: "\xAE", REG: "\
\xAE", ReverseElement: "\u220B", ReverseEquilibrium: "\u21CB", ReverseUpEquilibrium: "\u296F", rfisht: "\u297D", rfloor: "\u230B", rfr: "\u{1D52F}",
    Rfr: "\u211C", rHar: "\u2964", rhard: "\u21C1", rharu: "\u21C0", rharul: "\u296C", rho: "\u03C1", Rho: "\u03A1", rhov: "\u03F1", RightAngleBracket: "\
\u27E9", rightarrow: "\u2192", Rightarrow: "\u21D2", RightArrow: "\u2192", RightArrowBar: "\u21E5", RightArrowLeftArrow: "\u21C4", rightarrowtail: "\
\u21A3", RightCeiling: "\u2309", RightDoubleBracket: "\u27E7", RightDownTeeVector: "\u295D", RightDownVector: "\u21C2", RightDownVectorBar: "\
\u2955", RightFloor: "\u230B", rightharpoondown: "\u21C1", rightharpoonup: "\u21C0", rightleftarrows: "\u21C4", rightleftharpoons: "\u21CC",
    rightrightarrows: "\u21C9", rightsquigarrow: "\u219D", RightTee: "\u22A2", RightTeeArrow: "\u21A6", RightTeeVector: "\u295B", rightthreetimes: "\
\u22CC", RightTriangle: "\u22B3", RightTriangleBar: "\u29D0", RightTriangleEqual: "\u22B5", RightUpDownVector: "\u294F", RightUpTeeVector: "\
\u295C", RightUpVector: "\u21BE", RightUpVectorBar: "\u2954", RightVector: "\u21C0", RightVectorBar: "\u2953", ring: "\u02DA", risingdotseq: "\
\u2253", rlarr: "\u21C4", rlhar: "\u21CC", rlm: "\u200F", rmoust: "\u23B1", rmoustache: "\u23B1", rnmid: "\u2AEE", roang: "\u27ED", roarr: "\
\u21FE", robrk: "\u27E7", ropar: "\u2986", ropf: "\u{1D563}", Ropf: "\u211D", roplus: "\u2A2E", rotimes: "\u2A35", RoundImplies: "\u2970", rpar: "\
)", rpargt: "\u2994", rppolint: "\u2A12", rrarr: "\u21C9", Rrightarrow: "\u21DB", rsaquo: "\u203A", rscr: "\u{1D4C7}", Rscr: "\u211B", rsh: "\
\u21B1", Rsh: "\u21B1", rsqb: "]", rsquo: "\u2019", rsquor: "\u2019", rthree: "\u22CC", rtimes: "\u22CA", rtri: "\u25B9", rtrie: "\u22B5", rtrif: "\
\u25B8", rtriltri: "\u29CE", RuleDelayed: "\u29F4", ruluhar: "\u2968", rx: "\u211E", sacute: "\u015B", Sacute: "\u015A", sbquo: "\u201A", sc: "\
\u227B", Sc: "\u2ABC", scap: "\u2AB8", scaron: "\u0161", Scaron: "\u0160", sccue: "\u227D", sce: "\u2AB0", scE: "\u2AB4", scedil: "\u015F", Scedil: "\
\u015E", scirc: "\u015D", Scirc: "\u015C", scnap: "\u2ABA", scnE: "\u2AB6", scnsim: "\u22E9", scpolint: "\u2A13", scsim: "\u227F", scy: "\u0441",
    Scy: "\u0421", sdot: "\u22C5", sdotb: "\u22A1", sdote: "\u2A66", searhk: "\u2925", searr: "\u2198", seArr: "\u21D8", searrow: "\u2198", sect: "\
\xA7", semi: ";", seswar: "\u2929", setminus: "\u2216", setmn: "\u2216", sext: "\u2736", sfr: "\u{1D530}", Sfr: "\u{1D516}", sfrown: "\u2322",
    sharp: "\u266F", shchcy: "\u0449", SHCHcy: "\u0429", shcy: "\u0448", SHcy: "\u0428", ShortDownArrow: "\u2193", ShortLeftArrow: "\u2190",
    shortmid: "\u2223", shortparallel: "\u2225", ShortRightArrow: "\u2192", ShortUpArrow: "\u2191", shy: "\xAD", sigma: "\u03C3", Sigma: "\u03A3",
    sigmaf: "\u03C2", sigmav: "\u03C2", sim: "\u223C", simdot: "\u2A6A", sime: "\u2243", simeq: "\u2243", simg: "\u2A9E", simgE: "\u2AA0", siml: "\
\u2A9D", simlE: "\u2A9F", simne: "\u2246", simplus: "\u2A24", simrarr: "\u2972", slarr: "\u2190", SmallCircle: "\u2218", smallsetminus: "\u2216",
    smashp: "\u2A33", smeparsl: "\u29E4", smid: "\u2223", smile: "\u2323", smt: "\u2AAA", smte: "\u2AAC", smtes: "\u2AAC\uFE00", softcy: "\u044C",
    SOFTcy: "\u042C", sol: "/", solb: "\u29C4", solbar: "\u233F", sopf: "\u{1D564}", Sopf: "\u{1D54A}", spades: "\u2660", spadesuit: "\u2660",
    spar: "\u2225", sqcap: "\u2293", sqcaps: "\u2293\uFE00", sqcup: "\u2294", sqcups: "\u2294\uFE00", Sqrt: "\u221A", sqsub: "\u228F", sqsube: "\
\u2291", sqsubset: "\u228F", sqsubseteq: "\u2291", sqsup: "\u2290", sqsupe: "\u2292", sqsupset: "\u2290", sqsupseteq: "\u2292", squ: "\u25A1",
    square: "\u25A1", Square: "\u25A1", SquareIntersection: "\u2293", SquareSubset: "\u228F", SquareSubsetEqual: "\u2291", SquareSuperset: "\
\u2290", SquareSupersetEqual: "\u2292", SquareUnion: "\u2294", squarf: "\u25AA", squf: "\u25AA", srarr: "\u2192", sscr: "\u{1D4C8}", Sscr: "\
\u{1D4AE}", ssetmn: "\u2216", ssmile: "\u2323", sstarf: "\u22C6", star: "\u2606", Star: "\u22C6", starf: "\u2605", straightepsilon: "\u03F5",
    straightphi: "\u03D5", strns: "\xAF", sub: "\u2282", Sub: "\u22D0", subdot: "\u2ABD", sube: "\u2286", subE: "\u2AC5", subedot: "\u2AC3",
    submult: "\u2AC1", subne: "\u228A", subnE: "\u2ACB", subplus: "\u2ABF", subrarr: "\u2979", subset: "\u2282", Subset: "\u22D0", subseteq: "\
\u2286", subseteqq: "\u2AC5", SubsetEqual: "\u2286", subsetneq: "\u228A", subsetneqq: "\u2ACB", subsim: "\u2AC7", subsub: "\u2AD5", subsup: "\
\u2AD3", succ: "\u227B", succapprox: "\u2AB8", succcurlyeq: "\u227D", Succeeds: "\u227B", SucceedsEqual: "\u2AB0", SucceedsSlantEqual: "\u227D",
    SucceedsTilde: "\u227F", succeq: "\u2AB0", succnapprox: "\u2ABA", succneqq: "\u2AB6", succnsim: "\u22E9", succsim: "\u227F", SuchThat: "\
\u220B", sum: "\u2211", Sum: "\u2211", sung: "\u266A", sup: "\u2283", Sup: "\u22D1", sup1: "\xB9", sup2: "\xB2", sup3: "\xB3", supdot: "\u2ABE",
    supdsub: "\u2AD8", supe: "\u2287", supE: "\u2AC6", supedot: "\u2AC4", Superset: "\u2283", SupersetEqual: "\u2287", suphsol: "\u27C9", suphsub: "\
\u2AD7", suplarr: "\u297B", supmult: "\u2AC2", supne: "\u228B", supnE: "\u2ACC", supplus: "\u2AC0", supset: "\u2283", Supset: "\u22D1", supseteq: "\
\u2287", supseteqq: "\u2AC6", supsetneq: "\u228B", supsetneqq: "\u2ACC", supsim: "\u2AC8", supsub: "\u2AD4", supsup: "\u2AD6", swarhk: "\u2926",
    swarr: "\u2199", swArr: "\u21D9", swarrow: "\u2199", swnwar: "\u292A", szlig: "\xDF", Tab: "	", target: "\u2316", tau: "\u03C4", Tau: "\u03A4",
    tbrk: "\u23B4", tcaron: "\u0165", Tcaron: "\u0164", tcedil: "\u0163", Tcedil: "\u0162", tcy: "\u0442", Tcy: "\u0422", tdot: "\u20DB", telrec: "\
\u2315", tfr: "\u{1D531}", Tfr: "\u{1D517}", there4: "\u2234", therefore: "\u2234", Therefore: "\u2234", theta: "\u03B8", Theta: "\u0398", thetasym: "\
\u03D1", thetav: "\u03D1", thickapprox: "\u2248", thicksim: "\u223C", ThickSpace: "\u205F\u200A", thinsp: "\u2009", ThinSpace: "\u2009", thkap: "\
\u2248", thksim: "\u223C", thorn: "\xFE", THORN: "\xDE", tilde: "\u02DC", Tilde: "\u223C", TildeEqual: "\u2243", TildeFullEqual: "\u2245", TildeTilde: "\
\u2248", times: "\xD7", timesb: "\u22A0", timesbar: "\u2A31", timesd: "\u2A30", tint: "\u222D", toea: "\u2928", top: "\u22A4", topbot: "\u2336",
    topcir: "\u2AF1", topf: "\u{1D565}", Topf: "\u{1D54B}", topfork: "\u2ADA", tosa: "\u2929", tprime: "\u2034", trade: "\u2122", TRADE: "\u2122",
    triangle: "\u25B5", triangledown: "\u25BF", triangleleft: "\u25C3", trianglelefteq: "\u22B4", triangleq: "\u225C", triangleright: "\u25B9",
    trianglerighteq: "\u22B5", tridot: "\u25EC", trie: "\u225C", triminus: "\u2A3A", TripleDot: "\u20DB", triplus: "\u2A39", trisb: "\u29CD",
    tritime: "\u2A3B", trpezium: "\u23E2", tscr: "\u{1D4C9}", Tscr: "\u{1D4AF}", tscy: "\u0446", TScy: "\u0426", tshcy: "\u045B", TSHcy: "\u040B",
    tstrok: "\u0167", Tstrok: "\u0166", twixt: "\u226C", twoheadleftarrow: "\u219E", twoheadrightarrow: "\u21A0", uacute: "\xFA", Uacute: "\xDA",
    uarr: "\u2191", uArr: "\u21D1", Uarr: "\u219F", Uarrocir: "\u2949", ubrcy: "\u045E", Ubrcy: "\u040E", ubreve: "\u016D", Ubreve: "\u016C",
    ucirc: "\xFB", Ucirc: "\xDB", ucy: "\u0443", Ucy: "\u0423", udarr: "\u21C5", udblac: "\u0171", Udblac: "\u0170", udhar: "\u296E", ufisht: "\
\u297E", ufr: "\u{1D532}", Ufr: "\u{1D518}", ugrave: "\xF9", Ugrave: "\xD9", uHar: "\u2963", uharl: "\u21BF", uharr: "\u21BE", uhblk: "\u2580",
    ulcorn: "\u231C", ulcorner: "\u231C", ulcrop: "\u230F", ultri: "\u25F8", umacr: "\u016B", Umacr: "\u016A", uml: "\xA8", UnderBar: "_", UnderBrace: "\
\u23DF", UnderBracket: "\u23B5", UnderParenthesis: "\u23DD", Union: "\u22C3", UnionPlus: "\u228E", uogon: "\u0173", Uogon: "\u0172", uopf: "\
\u{1D566}", Uopf: "\u{1D54C}", uparrow: "\u2191", Uparrow: "\u21D1", UpArrow: "\u2191", UpArrowBar: "\u2912", UpArrowDownArrow: "\u21C5", updownarrow: "\
\u2195", Updownarrow: "\u21D5", UpDownArrow: "\u2195", UpEquilibrium: "\u296E", upharpoonleft: "\u21BF", upharpoonright: "\u21BE", uplus: "\u228E",
    UpperLeftArrow: "\u2196", UpperRightArrow: "\u2197", upsi: "\u03C5", Upsi: "\u03D2", upsih: "\u03D2", upsilon: "\u03C5", Upsilon: "\u03A5",
    UpTee: "\u22A5", UpTeeArrow: "\u21A5", upuparrows: "\u21C8", urcorn: "\u231D", urcorner: "\u231D", urcrop: "\u230E", uring: "\u016F", Uring: "\
\u016E", urtri: "\u25F9", uscr: "\u{1D4CA}", Uscr: "\u{1D4B0}", utdot: "\u22F0", utilde: "\u0169", Utilde: "\u0168", utri: "\u25B5", utrif: "\
\u25B4", uuarr: "\u21C8", uuml: "\xFC", Uuml: "\xDC", uwangle: "\u29A7", vangrt: "\u299C", varepsilon: "\u03F5", varkappa: "\u03F0", varnothing: "\
\u2205", varphi: "\u03D5", varpi: "\u03D6", varpropto: "\u221D", varr: "\u2195", vArr: "\u21D5", varrho: "\u03F1", varsigma: "\u03C2", varsubsetneq: "\
\u228A\uFE00", varsubsetneqq: "\u2ACB\uFE00", varsupsetneq: "\u228B\uFE00", varsupsetneqq: "\u2ACC\uFE00", vartheta: "\u03D1", vartriangleleft: "\
\u22B2", vartriangleright: "\u22B3", vBar: "\u2AE8", Vbar: "\u2AEB", vBarv: "\u2AE9", vcy: "\u0432", Vcy: "\u0412", vdash: "\u22A2", vDash: "\
\u22A8", Vdash: "\u22A9", VDash: "\u22AB", Vdashl: "\u2AE6", vee: "\u2228", Vee: "\u22C1", veebar: "\u22BB", veeeq: "\u225A", vellip: "\u22EE",
    verbar: "|", Verbar: "\u2016", vert: "|", Vert: "\u2016", VerticalBar: "\u2223", VerticalLine: "|", VerticalSeparator: "\u2758", VerticalTilde: "\
\u2240", VeryThinSpace: "\u200A", vfr: "\u{1D533}", Vfr: "\u{1D519}", vltri: "\u22B2", vnsub: "\u2282\u20D2", vnsup: "\u2283\u20D2", vopf: "\
\u{1D567}", Vopf: "\u{1D54D}", vprop: "\u221D", vrtri: "\u22B3", vscr: "\u{1D4CB}", Vscr: "\u{1D4B1}", vsubne: "\u228A\uFE00", vsubnE: "\u2ACB\uFE00",
    vsupne: "\u228B\uFE00", vsupnE: "\u2ACC\uFE00", Vvdash: "\u22AA", vzigzag: "\u299A", wcirc: "\u0175", Wcirc: "\u0174", wedbar: "\u2A5F",
    wedge: "\u2227", Wedge: "\u22C0", wedgeq: "\u2259", weierp: "\u2118", wfr: "\u{1D534}", Wfr: "\u{1D51A}", wopf: "\u{1D568}", Wopf: "\u{1D54E}",
    wp: "\u2118", wr: "\u2240", wreath: "\u2240", wscr: "\u{1D4CC}", Wscr: "\u{1D4B2}", xcap: "\u22C2", xcirc: "\u25EF", xcup: "\u22C3", xdtri: "\
\u25BD", xfr: "\u{1D535}", Xfr: "\u{1D51B}", xharr: "\u27F7", xhArr: "\u27FA", xi: "\u03BE", Xi: "\u039E", xlarr: "\u27F5", xlArr: "\u27F8",
    xmap: "\u27FC", xnis: "\u22FB", xodot: "\u2A00", xopf: "\u{1D569}", Xopf: "\u{1D54F}", xoplus: "\u2A01", xotime: "\u2A02", xrarr: "\u27F6",
    xrArr: "\u27F9", xscr: "\u{1D4CD}", Xscr: "\u{1D4B3}", xsqcup: "\u2A06", xuplus: "\u2A04", xutri: "\u25B3", xvee: "\u22C1", xwedge: "\u22C0",
    yacute: "\xFD", Yacute: "\xDD", yacy: "\u044F", YAcy: "\u042F", ycirc: "\u0177", Ycirc: "\u0176", ycy: "\u044B", Ycy: "\u042B", yen: "\xA5",
    yfr: "\u{1D536}", Yfr: "\u{1D51C}", yicy: "\u0457", YIcy: "\u0407", yopf: "\u{1D56A}", Yopf: "\u{1D550}", yscr: "\u{1D4CE}", Yscr: "\u{1D4B4}",
    yucy: "\u044E", YUcy: "\u042E", yuml: "\xFF", Yuml: "\u0178", zacute: "\u017A", Zacute: "\u0179", zcaron: "\u017E", Zcaron: "\u017D", zcy: "\
\u0437", Zcy: "\u0417", zdot: "\u017C", Zdot: "\u017B", zeetrf: "\u2128", ZeroWidthSpace: "\u200B", zeta: "\u03B6", Zeta: "\u0396", zfr: "\u{1D537}",
    Zfr: "\u2128", zhcy: "\u0436", ZHcy: "\u0416", zigrarr: "\u21DD", zopf: "\u{1D56B}", Zopf: "\u2124", zscr: "\u{1D4CF}", Zscr: "\u{1D4B5}",
    zwj: "\u200D", zwnj: "\u200C" }, m = { aacute: "\xE1", Aacute: "\xC1", acirc: "\xE2", Acirc: "\xC2", acute: "\xB4", aelig: "\xE6", AElig: "\
\xC6", agrave: "\xE0", Agrave: "\xC0", amp: "&", AMP: "&", aring: "\xE5", Aring: "\xC5", atilde: "\xE3", Atilde: "\xC3", auml: "\xE4", Auml: "\
\xC4", brvbar: "\xA6", ccedil: "\xE7", Ccedil: "\xC7", cedil: "\xB8", cent: "\xA2", copy: "\xA9", COPY: "\xA9", curren: "\xA4", deg: "\xB0",
    divide: "\xF7", eacute: "\xE9", Eacute: "\xC9", ecirc: "\xEA", Ecirc: "\xCA", egrave: "\xE8", Egrave: "\xC8", eth: "\xF0", ETH: "\xD0", euml: "\
\xEB", Euml: "\xCB", frac12: "\xBD", frac14: "\xBC", frac34: "\xBE", gt: ">", GT: ">", iacute: "\xED", Iacute: "\xCD", icirc: "\xEE", Icirc: "\
\xCE", iexcl: "\xA1", igrave: "\xEC", Igrave: "\xCC", iquest: "\xBF", iuml: "\xEF", Iuml: "\xCF", laquo: "\xAB", lt: "<", LT: "<", macr: "\xAF",
    micro: "\xB5", middot: "\xB7", nbsp: "\xA0", not: "\xAC", ntilde: "\xF1", Ntilde: "\xD1", oacute: "\xF3", Oacute: "\xD3", ocirc: "\xF4",
    Ocirc: "\xD4", ograve: "\xF2", Ograve: "\xD2", ordf: "\xAA", ordm: "\xBA", oslash: "\xF8", Oslash: "\xD8", otilde: "\xF5", Otilde: "\xD5",
    ouml: "\xF6", Ouml: "\xD6", para: "\xB6", plusmn: "\xB1", pound: "\xA3", quot: '"', QUOT: '"', raquo: "\xBB", reg: "\xAE", REG: "\xAE", sect: "\
\xA7", shy: "\xAD", sup1: "\xB9", sup2: "\xB2", sup3: "\xB3", szlig: "\xDF", thorn: "\xFE", THORN: "\xDE", times: "\xD7", uacute: "\xFA", Uacute: "\
\xDA", ucirc: "\xFB", Ucirc: "\xDB", ugrave: "\xF9", Ugrave: "\xD9", uml: "\xA8", uuml: "\xFC", Uuml: "\xDC", yacute: "\xFD", Yacute: "\xDD",
    yen: "\xA5", yuml: "\xFF" }, f = { 0: "\uFFFD", 128: "\u20AC", 130: "\u201A", 131: "\u0192", 132: "\u201E", 133: "\u2026", 134: "\u2020",
    135: "\u2021", 136: "\u02C6", 137: "\u2030", 138: "\u0160", 139: "\u2039", 140: "\u0152", 142: "\u017D", 145: "\u2018", 146: "\u2019", 147: "\
\u201C", 148: "\u201D", 149: "\u2022", 150: "\u2013", 151: "\u2014", 152: "\u02DC", 153: "\u2122", 154: "\u0161", 155: "\u203A", 156: "\u0153",
    158: "\u017E", 159: "\u0178" }, d = [1, 2, 3, 4, 5, 6, 7, 8, 11, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30,
    31, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153,
    154, 155, 156, 157, 158, 159, 64976, 64977, 64978, 64979, 64980, 64981, 64982, 64983, 64984, 64985, 64986, 64987, 64988, 64989, 64990, 64991,
    64992, 64993, 64994, 64995, 64996, 64997, 64998, 64999, 65e3, 65001, 65002, 65003, 65004, 65005, 65006, 65007, 65534, 65535, 131070, 131071,
    196606, 196607, 262142, 262143, 327678, 327679, 393214, 393215, 458750, 458751, 524286, 524287, 589822, 589823, 655358, 655359, 720894, 720895,
    786430, 786431, 851966, 851967, 917502, 917503, 983038, 983039, 1048574, 1048575, 1114110, 1114111], v = String.fromCharCode, E = {}, S = E.
    hasOwnProperty, x = /* @__PURE__ */ s(function(re, se) {
      return S.call(re, se);
    }, "has"), C = /* @__PURE__ */ s(function(re, se) {
      for (var de = -1, he = re.length; ++de < he; )
        if (re[de] == se)
          return !0;
      return !1;
    }, "contains"), z = /* @__PURE__ */ s(function(re, se) {
      if (!re)
        return se;
      var de = {}, he;
      for (he in se)
        de[he] = x(re, he) ? re[he] : se[he];
      return de;
    }, "merge"), w = /* @__PURE__ */ s(function(re, se) {
      var de = "";
      return re >= 55296 && re <= 57343 || re > 1114111 ? (se && T("character reference outside the permissible Unicode range"), "\uFFFD") :
      x(f, re) ? (se && T("disallowed character reference"), f[re]) : (se && C(d, re) && T("disallowed character reference"), re > 65535 && (re -=
      65536, de += v(re >>> 10 & 1023 | 55296), re = 56320 | re & 1023), de += v(re), de);
    }, "codePointToSymbol"), D = /* @__PURE__ */ s(function(re) {
      return "&#x" + re.toString(16).toUpperCase() + ";";
    }, "hexEscape"), N = /* @__PURE__ */ s(function(re) {
      return "&#" + re + ";";
    }, "decEscape"), T = /* @__PURE__ */ s(function(re) {
      throw Error("Parse error: " + re);
    }, "parseError"), R = /* @__PURE__ */ s(function(re, se) {
      se = z(se, R.options);
      var de = se.strict;
      de && y.test(re) && T("forbidden code point");
      var he = se.encodeEverything, xe = se.useNamedReferences, G = se.allowUnsafeSymbols, ie = se.decimal ? N : D, X = /* @__PURE__ */ s(function(ye) {
        return ie(ye.charCodeAt(0));
      }, "escapeBmpSymbol");
      return he ? (re = re.replace(a, function(ye) {
        return xe && x(l, ye) ? "&" + l[ye] + ";" : X(ye);
      }), xe && (re = re.replace(/&gt;\u20D2/g, "&nvgt;").replace(/&lt;\u20D2/g, "&nvlt;").replace(/&#x66;&#x6A;/g, "&fjlig;")), xe && (re =
      re.replace(u, function(ye) {
        return "&" + l[ye] + ";";
      }))) : xe ? (G || (re = re.replace(c, function(ye) {
        return "&" + l[ye] + ";";
      })), re = re.replace(/&gt;\u20D2/g, "&nvgt;").replace(/&lt;\u20D2/g, "&nvlt;"), re = re.replace(u, function(ye) {
        return "&" + l[ye] + ";";
      })) : G || (re = re.replace(c, X)), re.replace(n, function(ye) {
        var Oe = ye.charCodeAt(0), Pt = ye.charCodeAt(1), Vt = (Oe - 55296) * 1024 + Pt - 56320 + 65536;
        return ie(Vt);
      }).replace(o, X);
    }, "encode");
    R.options = {
      allowUnsafeSymbols: !1,
      encodeEverything: !1,
      strict: !1,
      useNamedReferences: !1,
      decimal: !1
    };
    var j = /* @__PURE__ */ s(function(re, se) {
      se = z(se, j.options);
      var de = se.strict;
      return de && h.test(re) && T("malformed character reference"), re.replace(_, function(he, xe, G, ie, X, ye, Oe, Pt, Vt) {
        var Ee, st, oe, Ae, Ie, te;
        return xe ? (Ie = xe, g[Ie]) : G ? (Ie = G, te = ie, te && se.isAttributeValue ? (de && te == "=" && T("`&` did not start a characte\
r reference"), he) : (de && T(
          "named character reference was not terminated by a semicolon"
        ), m[Ie] + (te || ""))) : X ? (oe = X, st = ye, de && !st && T("character reference was not terminated by a semicolon"), Ee = parseInt(
        oe, 10), w(Ee, de)) : Oe ? (Ae = Oe, st = Pt, de && !st && T("character reference was not terminated by a semicolon"), Ee = parseInt(
        Ae, 16), w(Ee, de)) : (de && T(
          "named character reference was not terminated by a semicolon"
        ), he);
      });
    }, "decode");
    j.options = {
      isAttributeValue: !1,
      strict: !1
    };
    var J = /* @__PURE__ */ s(function(re) {
      return re.replace(c, function(se) {
        return p[se];
      });
    }, "escape"), H = {
      version: "1.2.0",
      encode: R,
      decode: j,
      escape: J,
      unescape: j
    };
    if (typeof define == "function" && typeof define.amd == "object" && define.amd)
      define(function() {
        return H;
      });
    else if (t && !t.nodeType)
      if (r)
        r.exports = H;
      else
        for (var F in H)
          x(H, F) && (t[F] = H[F]);
    else
      e.he = H;
  })(BS);
});

// ../node_modules/html-minifier-terser/src/utils.js
var US = b((qS) => {
  "use strict";
  function Pre(e, t) {
    var r = {};
    return e.forEach(function(i) {
      r[i] = 1;
    }), t ? function(i) {
      return r[i.toLowerCase()] === 1;
    } : function(i) {
      return r[i] === 1;
    };
  }
  s(Pre, "createMap");
  async function Dct(e, t, r) {
    let i = [];
    e.replace(t, (a, ...o) => {
      let u = r(a, ...o);
      i.push(u);
    });
    let n = await Promise.all(i);
    return e.replace(t, () => n.shift());
  }
  s(Dct, "replaceAsync");
  qS.createMap = Pre;
  qS.createMapFromString = function(e, t) {
    return Pre(e.split(/,/), t);
  };
  qS.replaceAsync = Dct;
});

// ../node_modules/html-minifier-terser/src/htmlparser.js
var ak = b((zm) => {
  "use strict";
  var wct = US().createMapFromString, Dre = US().replaceAsync;
  function Yp(e) {
    return wct(e, !0);
  }
  s(Yp, "makeMap");
  var Oct = /([^\s"'<>/=]+)/, kct = [/=/], Ict = [
    // attr value double quotes
    /"([^"]*)"+/.source,
    // attr value, single quotes
    /'([^']*)'+/.source,
    // attr value, no quotes
    /([^ \t\n\f\r"'`=<>]+)/.source
  ], kre = function() {
    var e = "\\u0300-\\u0345\\u0360\\u0361\\u0483-\\u0486\\u0591-\\u05A1\\u05A3-\\u05B9\\u05BB-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u064B-\\u0652\\u0670\\u06D6-\
\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0901-\\u0903\\u093C\\u093E-\\u094D\\u0951-\\u0954\\u0962\\u0963\\u0981-\\u0983\\u09BC\\u09BE-\\u09C4\\u09C7\\u09C8\\u09CB-\\\
u09CD\\u09D7\\u09E2\\u09E3\\u0A02\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A70\\u0A71\\u0A81-\\u0A83\\u0ABC\\u0ABE-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0\
ACD\\u0B01-\\u0B03\\u0B3C\\u0B3E-\\u0B43\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B82\\u0B83\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD7\\u0C01-\\u0C\
03\\u0C3E-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C82\\u0C83\\u0CBE-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0D02\\u0D03\\u0D3E-\\u0D4\
3\\u0D46-\\u0D48\\u0D4A-\\u0D4D\\u0D57\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EB9\\u0EBB\\u0EBC\\u0EC8-\\u0ECD\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\\
u0F3E\\u0F3F\\u0F71-\\u0F84\\u0F86-\\u0F8B\\u0F90-\\u0F95\\u0F97\\u0F99-\\u0FAD\\u0FB1-\\u0FB7\\u0FB9\\u20D0-\\u20DC\\u20E1\\u302A-\\u302F\\u3099\\u309A",
    t = "0-9\\u0660-\\u0669\\u06F0-\\u06F9\\u0966-\\u096F\\u09E6-\\u09EF\\u0A66-\\u0A6F\\u0AE6-\\u0AEF\\u0B66-\\u0B6F\\u0BE7-\\u0BEF\\u0C66-\\u0C6F\\u0CE6-\\u0C\
EF\\u0D66-\\u0D6F\\u0E50-\\u0E59\\u0ED0-\\u0ED9\\u0F20-\\u0F29", r = "\\xB7\\u02D0\\u02D1\\u0387\\u0640\\u0E46\\u0EC6\\u3005\\u3031-\\u3035\\u309D\\u309\
E\\u30FC-\\u30FE", i = "A-Za-z\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u0131\\u0134-\\u013E\\u0141-\\u0148\\u014A-\\u017E\\u0180-\\u01C3\\u01CD-\\u01F0\\u01F4\\u01F5\\u01\
FA-\\u0217\\u0250-\\u02A8\\u02BB-\\u02C1\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03CE\\u03D0-\\u03D6\\u03DA\\u03DC\\u03DE\\u03E0\\u03E2-\\u03F3\\u04\
01-\\u040C\\u040E-\\u044F\\u0451-\\u045C\\u045E-\\u0481\\u0490-\\u04C4\\u04C7\\u04C8\\u04CB\\u04CC\\u04D0-\\u04EB\\u04EE-\\u04F5\\u04F8\\u04F9\\u0531-\\u0556\\u05\
59\\u0561-\\u0586\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0621-\\u063A\\u0641-\\u064A\\u0671-\\u06B7\\u06BA-\\u06BE\\u06C0-\\u06CE\\u06D0-\\u06D3\\u06D5\\u06E5\\u06E6\\u0\
905-\\u0939\\u093D\\u0958-\\u0961\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A\
05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8B\\u0A8D\\u0A8F\
-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AE0\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B36-\
\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u\
0BB5\\u0BB7-\\u0BB9\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C33\\u0C35-\\u0C39\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\
\\u0CB3\\u0CB5-\\u0CB9\\u0CDE\\u0CE0\\u0CE1\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D28\\u0D2A-\\u0D39\\u0D60\\u0D61\\u0E01-\\u0E2E\\u0E30\\u0E32\\u0E33\\u0E40-\\\
u0E45\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD\\u0EAE\\u0EB0\\u0EB2\\u0EB3\
\\u0EBD\\u0EC0-\\u0EC4\\u0F40-\\u0F47\\u0F49-\\u0F69\\u10A0-\\u10C5\\u10D0-\\u10F6\\u1100\\u1102\\u1103\\u1105-\\u1107\\u1109\\u110B\\u110C\\u110E-\\u1112\\u113C\\\
u113E\\u1140\\u114C\\u114E\\u1150\\u1154\\u1155\\u1159\\u115F-\\u1161\\u1163\\u1165\\u1167\\u1169\\u116D\\u116E\\u1172\\u1173\\u1175\\u119E\\u11A8\\u11AB\\u11AE\\u\
11AF\\u11B7\\u11B8\\u11BA\\u11BC-\\u11C2\\u11EB\\u11F0\\u11F9\\u1E00-\\u1E9B\\u1EA0-\\u1EF9\\u1F00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u\
1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\\
u1FF4\\u1FF6-\\u1FFC\\u2126\\u212A\\u212B\\u212E\\u2180-\\u2182\\u3007\\u3021-\\u3029\\u3041-\\u3094\\u30A1-\\u30FA\\u3105-\\u312C\\u4E00-\\u9FA5\\uAC00-\\uD7A3",
    n = "[" + i + "_][" + i + t + "\\.\\-_" + e + r + "]*";
    return "((?:" + n + "\\:)?" + n + ")";
  }(), Rct = new RegExp("^<" + kre), Nct = /^\s*(\/?)>/, jS = new RegExp("^<\\/" + kre + "[^>]*>"), Lct = /^<!DOCTYPE\s?[^>]+>/i, Ire = !1;
  "x".replace(/x(.)?/g, function(e, t) {
    Ire = t === "";
  });
  var Fct = Yp("area,base,basefont,br,col,embed,frame,hr,img,input,isindex,keygen,link,meta,param,source,track,wbr"), wre = Yp("a,abbr,acron\
ym,applet,b,basefont,bdo,big,br,button,cite,code,del,dfn,em,font,i,iframe,img,input,ins,kbd,label,map,noscript,object,q,s,samp,script,select\
,small,span,strike,strong,sub,sup,svg,textarea,tt,u,var"), Mct = Yp("colgroup,dd,dt,li,option,p,td,tfoot,th,thead,tr,source"), Bct = Yp("che\
cked,compact,declare,defer,disabled,ismap,multiple,nohref,noresize,noshade,nowrap,readonly,selected"), qct = Yp("script,style"), Uct = Yp("a\
ddress,article,aside,base,blockquote,body,caption,col,colgroup,dd,details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,h1,h2,h3,h\
4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,ol,optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,title\
,tr,track,ul"), Ore = {};
  function jct(e) {
    var t = Oct.source + "(?:\\s*(" + Vct(e) + ")[ \\t\\n\\f\\r]*(?:" + Ict.join("|") + "))?";
    if (e.customAttrSurround) {
      for (var r = [], i = e.customAttrSurround.length - 1; i >= 0; i--)
        r[i] = "(?:(" + e.customAttrSurround[i][0].source + ")\\s*" + t + "\\s*(" + e.customAttrSurround[i][1].source + "))";
      r.push("(?:" + t + ")"), t = "(?:" + r.join("|") + ")";
    }
    return new RegExp("^\\s*" + t);
  }
  s(jct, "attrForHandler");
  function Vct(e) {
    return kct.concat(
      e.customAttrAssign || []
    ).map(function(t) {
      return "(?:" + t.source + ")";
    }).join("|");
  }
  s(Vct, "joinSingleAttrAssigns");
  var Hm = class {
    static {
      s(this, "HTMLParser");
    }
    constructor(t, r) {
      this.html = t, this.handler = r;
    }
    async parse() {
      let t = this.html, r = this.handler;
      for (var i = [], n, a = jct(r), o, u, l; t; ) {
        if (o = t, !n || !qct(n)) {
          var c = t.indexOf("<");
          if (c === 0) {
            if (/^<!--/.test(t)) {
              var p = t.indexOf("-->");
              if (p >= 0) {
                r.comment && await r.comment(t.substring(4, p)), t = t.substring(p + 3), u = "";
                continue;
              }
            }
            if (/^<!\[/.test(t)) {
              var h = t.indexOf("]>");
              if (h >= 0) {
                r.comment && await r.comment(
                  t.substring(2, h + 1),
                  !0
                  /* non-standard */
                ), t = t.substring(h + 2), u = "";
                continue;
              }
            }
            var y = t.match(Lct);
            if (y) {
              r.doctype && r.doctype(y[0]), t = t.substring(y[0].length), u = "";
              continue;
            }
            var _ = t.match(jS);
            if (_) {
              t = t.substring(_[0].length), await Dre(_[0], jS, z), u = "/" + _[1].toLowerCase();
              continue;
            }
            var g = E(t);
            if (g) {
              t = g.rest, await x(g), u = g.tagName.toLowerCase();
              continue;
            }
            r.continueOnParseError && (c = t.indexOf("<", 1));
          }
          var m;
          c >= 0 ? (m = t.substring(0, c), t = t.substring(c)) : (m = t, t = "");
          var f = E(t);
          f ? l = f.tagName : (f = t.match(jS), f ? l = "/" + f[1] : l = ""), r.chars && await r.chars(m, u, l), u = "";
        } else {
          var d = n.toLowerCase(), v = Ore[d] || (Ore[d] = new RegExp("([\\s\\S]*?)</" + d + "[^>]*>", "i"));
          t = await Dre(t, v, async (w, D) => (d !== "script" && d !== "style" && d !== "noscript" && (D = D.replace(/<!--([\s\S]*?)-->/g, "\
$1").replace(/<!\[CDATA\[([\s\S]*?)]]>/g, "$1")), r.chars && await r.chars(D), "")), await z("</" + d + ">", d);
        }
        if (t === o)
          throw new Error("Parse Error: " + t);
      }
      r.partialMarkup || await z();
      function E(w) {
        var D = w.match(Rct);
        if (D) {
          var N = {
            tagName: D[1],
            attrs: []
          };
          w = w.slice(D[0].length);
          for (var T, R; !(T = w.match(Nct)) && (R = w.match(a)); )
            w = w.slice(R[0].length), N.attrs.push(R);
          if (T)
            return N.unarySlash = T[1], N.rest = w.slice(T[0].length), N;
        }
      }
      s(E, "parseStartTag");
      async function S(w) {
        if (C(w) >= 0)
          return await z("", w), !0;
      }
      s(S, "closeIfFound");
      async function x(w) {
        var D = w.tagName, N = w.unarySlash;
        if (r.html5 && (n === "p" && Uct(D) ? await z("", n) : D === "tbody" ? await S("thead") : D === "tfoot" && (await S("tbody") || await S(
        "thead")), D === "col" && C("colgroup") < 0 && (n = "colgroup", i.push({ tag: n, attrs: [] }), r.start && await r.start(n, [], !1, ""))),
        !r.html5 && !wre(D))
          for (; n && wre(n); )
            await z("", n);
        Mct(D) && n === D && await z("", D);
        var T = Fct(D) || D === "html" && n === "head" || !!N, R = w.attrs.map(function(j) {
          var J, H, F, re, se, de, he = 7;
          Ire && j[0].indexOf('""') === -1 && (j[3] === "" && delete j[3], j[4] === "" && delete j[4], j[5] === "" && delete j[5]);
          function xe(ye) {
            return se = j[ye], H = j[ye + 1], typeof H < "u" ? '"' : (H = j[ye + 2], typeof H < "u" ? "'" : (H = j[ye + 3], typeof H > "u" &&
            Bct(J) && (H = J), ""));
          }
          s(xe, "populate");
          var G = 1;
          if (r.customAttrSurround) {
            for (var ie = 0, X = r.customAttrSurround.length; ie < X; ie++, G += he)
              if (J = j[G + 1], J) {
                de = xe(G + 2), F = j[G], re = j[G + 6];
                break;
              }
          }
          return !J && (J = j[G]) && (de = xe(G + 1)), {
            name: J,
            value: H,
            customAssign: se || "=",
            customOpen: F || "",
            customClose: re || "",
            quote: de || ""
          };
        });
        T || (i.push({ tag: D, attrs: R }), n = D, N = ""), r.start && await r.start(D, R, T, N);
      }
      s(x, "handleStartTag");
      function C(w) {
        var D, N = w.toLowerCase();
        for (D = i.length - 1; D >= 0 && i[D].tag.toLowerCase() !== N; D--)
          ;
        return D;
      }
      s(C, "findTag");
      async function z(w, D) {
        var N;
        if (D ? N = C(D) : N = 0, N >= 0) {
          for (var T = i.length - 1; T >= N; T--)
            r.end && r.end(i[T].tag, i[T].attrs, T > N || !w);
          i.length = N, n = N && i[N - 1].tag;
        } else D.toLowerCase() === "br" ? r.start && await r.start(D, [], !0, "") : D.toLowerCase() === "p" && (r.start && await r.start(D, [],
        !1, "", !0), r.end && r.end(D, []));
      }
      s(z, "parseEndTag");
    }
  };
  zm.HTMLParser = Hm;
  zm.HTMLtoXML = function(e) {
    var t = "";
    return new Hm(e, {
      start: /* @__PURE__ */ s(function(r, i, n) {
        t += "<" + r;
        for (var a = 0, o = i.length; a < o; a++)
          t += " " + i[a].name + '="' + (i[a].value || "").replace(/"/g, "&#34;") + '"';
        t += (n ? "/" : "") + ">";
      }, "start"),
      end: /* @__PURE__ */ s(function(r) {
        t += "</" + r + ">";
      }, "end"),
      chars: /* @__PURE__ */ s(function(r) {
        t += r;
      }, "chars"),
      comment: /* @__PURE__ */ s(function(r) {
        t += "<!--" + r + "-->";
      }, "comment"),
      ignore: /* @__PURE__ */ s(function(r) {
        t += r;
      }, "ignore")
    }), t;
  };
  zm.HTMLtoDOM = function(e, t) {
    var r = {
      html: !0,
      head: !0,
      body: !0,
      title: !0
    }, i = {
      link: "head",
      base: "head"
    };
    t ? t = t.ownerDocument || t.getOwnerDocument && t.getOwnerDocument() || t : typeof DOMDocument < "u" ? t = new DOMDocument() : typeof document <
    "u" && document.implementation && document.implementation.createDocument ? t = document.implementation.createDocument("", "", null) : typeof ActiveX <
    "u" && (t = new ActiveXObject("Msxml.DOMDocument"));
    var n = [], a = t.documentElement || t.getDocumentElement && t.getDocumentElement();
    if (!a && t.createElement && function() {
      var l = t.createElement("html"), c = t.createElement("head");
      c.appendChild(t.createElement("title")), l.appendChild(c), l.appendChild(t.createElement("body")), t.appendChild(l);
    }(), t.getElementsByTagName)
      for (var o in r)
        r[o] = t.getElementsByTagName(o)[0];
    var u = r.body;
    return new Hm(e, {
      start: /* @__PURE__ */ s(function(l, c, p) {
        if (r[l]) {
          u = r[l];
          return;
        }
        var h = t.createElement(l);
        for (var y in c)
          h.setAttribute(c[y].name, c[y].value);
        i[l] && typeof r[i[l]] != "boolean" ? r[i[l]].appendChild(h) : u && u.appendChild && u.appendChild(h), p || (n.push(h), u = h);
      }, "start"),
      end: /* @__PURE__ */ s(function() {
        n.length -= 1, u = n[n.length - 1];
      }, "end"),
      chars: /* @__PURE__ */ s(function(l) {
        u.appendChild(t.createTextNode(l));
      }, "chars"),
      comment: /* @__PURE__ */ s(function() {
      }, "comment"),
      ignore: /* @__PURE__ */ s(function() {
      }, "ignore")
    }), t;
  };
  zm.endTag = jS;
});

// ../node_modules/relateurl/lib/constants.js
var ok = b((y3t, Rre) => {
  "use strict";
  Rre.exports = {
    // Output
    ABSOLUTE: "absolute",
    PATH_RELATIVE: "pathRelative",
    ROOT_RELATIVE: "rootRelative",
    SHORTEST: "shortest"
  };
});

// ../node_modules/relateurl/lib/format.js
var Bre = b((g3t, Mre) => {
  "use strict";
  var aa = ok();
  function Kct(e, t) {
    return e.auth && !t.removeAuth && (e.extra.relation.maximumHost || t.output === aa.ABSOLUTE) ? e.auth + "@" : "";
  }
  s(Kct, "formatAuth");
  function Hct(e, t) {
    return e.hash ? e.hash : "";
  }
  s(Hct, "formatHash");
  function zct(e, t) {
    return e.host.full && (e.extra.relation.maximumAuth || t.output === aa.ABSOLUTE) ? e.host.full : "";
  }
  s(zct, "formatHost");
  function Gct(e, t) {
    var r = "", i = e.path.absolute.string, n = e.path.relative.string, a = Fre(e, t);
    if (e.extra.relation.maximumHost || t.output === aa.ABSOLUTE || t.output === aa.ROOT_RELATIVE)
      r = i;
    else if (n.length <= i.length && t.output === aa.SHORTEST || t.output === aa.PATH_RELATIVE) {
      if (r = n, r === "") {
        var o = Lre(e, t) && !!Nre(e, t);
        (e.extra.relation.maximumPath && !a || e.extra.relation.overridesQuery && !a && !o) && (r = "./");
      }
    } else
      r = i;
    return r === "/" && !a && t.removeRootTrailingSlash && (!e.extra.relation.minimumPort || t.output === aa.ABSOLUTE) && (r = ""), r;
  }
  s(Gct, "formatPath");
  function Wct(e, t) {
    return e.port && !e.extra.portIsDefault && e.extra.relation.maximumHost ? ":" + e.port : "";
  }
  s(Wct, "formatPort");
  function $ct(e, t) {
    return Lre(e, t) ? Nre(e, t) : "";
  }
  s($ct, "formatQuery");
  function Xct(e, t) {
    return Fre(e, t) ? e.resource : "";
  }
  s(Xct, "formatResource");
  function Yct(e, t) {
    var r = "";
    return (e.extra.relation.maximumHost || t.output === aa.ABSOLUTE) && (!e.extra.relation.minimumScheme || !t.schemeRelative || t.output ===
    aa.ABSOLUTE ? r += e.scheme + "://" : r += "//"), r;
  }
  s(Yct, "formatScheme");
  function Jct(e, t) {
    var r = "";
    return r += Yct(e, t), r += Kct(e, t), r += zct(e, t), r += Wct(e, t), r += Gct(e, t), r += Xct(e, t), r += $ct(e, t), r += Hct(e, t), r;
  }
  s(Jct, "formatUrl");
  function Nre(e, t) {
    var r = t.removeEmptyQueries && e.extra.relation.minimumPort;
    return e.query.string[r ? "stripped" : "full"];
  }
  s(Nre, "getQuery");
  function Lre(e, t) {
    return !e.extra.relation.minimumQuery || t.output === aa.ABSOLUTE || t.output === aa.ROOT_RELATIVE;
  }
  s(Lre, "showQuery");
  function Fre(e, t) {
    var r = t.removeDirectoryIndexes && e.extra.resourceIsIndex, i = e.extra.relation.minimumResource && t.output !== aa.ABSOLUTE && t.output !==
    aa.ROOT_RELATIVE;
    return !!e.resource && !i && !r;
  }
  s(Fre, "showResource");
  Mre.exports = Jct;
});

// ../node_modules/relateurl/lib/util/object.js
var VS = b((b3t, Ure) => {
  "use strict";
  function qre(e) {
    if (e instanceof Object) {
      var t = e instanceof Array ? [] : {};
      for (var r in e)
        e.hasOwnProperty(r) && (t[r] = qre(e[r]));
      return t;
    }
    return e;
  }
  s(qre, "clone");
  function Qct(e) {
    return !!e && typeof e == "object" && e.constructor === Object;
  }
  s(Qct, "isPlainObject");
  function Zct(e, t) {
    if (e instanceof Object && t instanceof Object)
      for (var r in t)
        t.hasOwnProperty(r) && (e[r] = t[r]);
    return e;
  }
  s(Zct, "shallowMerge");
  Ure.exports = {
    clone: qre,
    isPlainObject: Qct,
    shallowMerge: Zct
  };
});

// ../node_modules/relateurl/lib/options.js
var Kre = b((S3t, Vre) => {
  "use strict";
  var jre = VS();
  function eft(e, t) {
    if (jre.isPlainObject(e)) {
      var r = {};
      for (var i in t)
        t.hasOwnProperty(i) && (e[i] !== void 0 ? r[i] = tft(e[i], t[i]) : r[i] = t[i]);
      return r;
    } else
      return t;
  }
  s(eft, "getOptions");
  function tft(e, t) {
    return t instanceof Object && e instanceof Object ? t instanceof Array && e instanceof Array ? t.concat(e) : jre.shallowMerge(e, t) : e;
  }
  s(tft, "mergeOption");
  Vre.exports = eft;
});

// ../node_modules/relateurl/lib/parse/hrefInfo.js
var zre = b((E3t, Hre) => {
  "use strict";
  function rft(e) {
    var t = !e.scheme && !e.auth && !e.host.full && !e.port, r = t && !e.path.absolute.string, i = r && !e.resource, n = i && !e.query.string.
    full.length, a = n && !e.hash;
    e.extra.hrefInfo.minimumPathOnly = t, e.extra.hrefInfo.minimumResourceOnly = r, e.extra.hrefInfo.minimumQueryOnly = i, e.extra.hrefInfo.
    minimumHashOnly = n, e.extra.hrefInfo.empty = a;
  }
  s(rft, "hrefInfo");
  Hre.exports = rft;
});

// ../node_modules/relateurl/lib/parse/host.js
var Wre = b((x3t, Gre) => {
  "use strict";
  function ift(e, t) {
    if (t.ignore_www) {
      var r = e.host.full;
      if (r) {
        var i = r;
        r.indexOf("www.") === 0 && (i = r.substr(4)), e.host.stripped = i;
      }
    }
  }
  s(ift, "parseHost");
  Gre.exports = ift;
});

// ../node_modules/relateurl/lib/parse/path.js
var Yre = b((P3t, Xre) => {
  "use strict";
  function nft(e, t) {
    var r = !1;
    return t.directoryIndexes.every(function(i) {
      return i === e ? (r = !0, !1) : !0;
    }), r;
  }
  s(nft, "isDirectoryIndex");
  function sft(e, t) {
    var r = e.path.absolute.string;
    if (r) {
      var i = r.lastIndexOf("/");
      if (i > -1) {
        if (++i < r.length) {
          var n = r.substr(i);
          n !== "." && n !== ".." ? (e.resource = n, r = r.substr(0, i)) : r += "/";
        }
        e.path.absolute.string = r, e.path.absolute.array = $re(r);
      } else r === "." || r === ".." ? (r += "/", e.path.absolute.string = r, e.path.absolute.array = $re(r)) : (e.resource = r, e.path.absolute.
      string = null);
      e.extra.resourceIsIndex = nft(e.resource, t);
    }
  }
  s(sft, "parsePath");
  function $re(e) {
    if (e !== "/") {
      var t = [];
      return e.split("/").forEach(function(r) {
        r !== "" && t.push(r);
      }), t;
    } else
      return [];
  }
  s($re, "splitPath");
  Xre.exports = sft;
});

// ../node_modules/relateurl/lib/parse/port.js
var Qre = b((w3t, Jre) => {
  "use strict";
  function aft(e, t) {
    var r = -1;
    for (var i in t.defaultPorts)
      if (i === e.scheme && t.defaultPorts.hasOwnProperty(i)) {
        r = t.defaultPorts[i];
        break;
      }
    r > -1 && (r = r.toString(), e.port === null && (e.port = r), e.extra.portIsDefault = e.port === r);
  }
  s(aft, "parsePort");
  Jre.exports = aft;
});

// ../node_modules/relateurl/lib/parse/query.js
var tie = b((k3t, eie) => {
  "use strict";
  var oft = Object.prototype.hasOwnProperty;
  function uft(e, t) {
    e.query.string.full = Zre(e.query.object, !1), t.removeEmptyQueries && (e.query.string.stripped = Zre(e.query.object, !0));
  }
  s(uft, "parseQuery");
  function Zre(e, t) {
    var r = 0, i = "";
    for (var n in e)
      if (n !== "" && oft.call(e, n) === !0) {
        var a = e[n];
        (a !== "" || !t) && (i += ++r === 1 ? "?" : "&", n = encodeURIComponent(n), a !== "" ? i += n + "=" + encodeURIComponent(a).replace(
        /%20/g, "+") : i += n);
      }
    return i;
  }
  s(Zre, "stringify");
  eie.exports = uft;
});

// ../node_modules/relateurl/lib/parse/urlstring.js
var iie = b((R3t, rie) => {
  "use strict";
  var lft = require("url").parse;
  function cft(e) {
    var t = e.protocol;
    return t && t.indexOf(":") === t.length - 1 && (t = t.substr(0, t.length - 1)), e.host = {
      // TODO :: unescape(encodeURIComponent(s)) ? ... http://ecmanaut.blogspot.ca/2006/07/encoding-decoding-utf8-in-javascript.html
      full: e.hostname,
      stripped: null
    }, e.path = {
      absolute: {
        array: null,
        string: e.pathname
      },
      relative: {
        array: null,
        string: null
      }
    }, e.query = {
      object: e.query,
      string: {
        full: null,
        stripped: null
      }
    }, e.extra = {
      hrefInfo: {
        minimumPathOnly: null,
        minimumResourceOnly: null,
        minimumQueryOnly: null,
        minimumHashOnly: null,
        empty: null,
        separatorOnlyQuery: e.search === "?"
      },
      portIsDefault: null,
      relation: {
        maximumScheme: null,
        maximumAuth: null,
        maximumHost: null,
        maximumPort: null,
        maximumPath: null,
        maximumResource: null,
        maximumQuery: null,
        maximumHash: null,
        minimumScheme: null,
        minimumAuth: null,
        minimumHost: null,
        minimumPort: null,
        minimumPath: null,
        minimumResource: null,
        minimumQuery: null,
        minimumHash: null,
        overridesQuery: null
      },
      resourceIsIndex: null,
      slashes: e.slashes
    }, e.resource = null, e.scheme = t, delete e.hostname, delete e.pathname, delete e.protocol, delete e.search, delete e.slashes, e;
  }
  s(cft, "clean");
  function fft(e, t) {
    var r = !0;
    return t.rejectedSchemes.every(function(i) {
      return r = e.indexOf(i + ":") !== 0, r;
    }), r;
  }
  s(fft, "validScheme");
  function pft(e, t) {
    return fft(e, t) ? cft(lft(e, !0, t.slashesDenoteHost)) : { href: e, valid: !1 };
  }
  s(pft, "parseUrlString");
  rie.exports = pft;
});

// ../node_modules/relateurl/lib/util/path.js
var KS = b((L3t, nie) => {
  "use strict";
  function hft(e) {
    return e.length > 0 ? e.join("/") + "/" : "";
  }
  s(hft, "joinPath");
  function dft(e) {
    var t = [];
    return e.forEach(function(r) {
      r !== ".." ? r !== "." && t.push(r) : t.length > 0 && t.splice(t.length - 1, 1);
    }), t;
  }
  s(dft, "resolveDotSegments");
  nie.exports = {
    join: hft,
    resolveDotSegments: dft
  };
});

// ../node_modules/relateurl/lib/parse/index.js
var uie = b((M3t, oie) => {
  "use strict";
  var mft = zre(), yft = Wre(), gft = Yre(), _ft = Qre(), bft = tie(), vft = iie(), sie = KS();
  function Sft(e, t, r) {
    if (e) {
      var i = aie(e, t), n = sie.resolveDotSegments(i.path.absolute.array);
      return i.path.absolute.array = n, i.path.absolute.string = "/" + sie.join(n), i;
    } else
      return r;
  }
  s(Sft, "parseFromUrl");
  function aie(e, t) {
    var r = vft(e, t);
    return r.valid === !1 || (yft(r, t), _ft(r, t), gft(r, t), bft(r, t), mft(r)), r;
  }
  s(aie, "parseUrl");
  oie.exports = {
    from: Sft,
    to: aie
  };
});

// ../node_modules/relateurl/lib/relate/findRelation.js
var cie = b((q3t, lie) => {
  "use strict";
  function Tft(e, t, r) {
    var i = e.extra.hrefInfo.minimumPathOnly, n = e.scheme === t.scheme || !e.scheme, a = n && (e.auth === t.auth || r.removeAuth || i), o = r.
    ignore_www ? "stripped" : "full", u = a && (e.host[o] === t.host[o] || i), l = u && (e.port === t.port || i);
    e.extra.relation.minimumScheme = n, e.extra.relation.minimumAuth = a, e.extra.relation.minimumHost = u, e.extra.relation.minimumPort = l,
    e.extra.relation.maximumScheme = !n || n && !a, e.extra.relation.maximumAuth = !n || n && !u, e.extra.relation.maximumHost = !n || n && !l;
  }
  s(Tft, "findRelation_upToPath");
  function Eft(e, t, r) {
    var i = e.extra.hrefInfo.minimumQueryOnly, n = e.extra.hrefInfo.minimumHashOnly, a = e.extra.hrefInfo.empty, o = e.extra.relation.minimumPort,
    u = e.extra.relation.minimumScheme, l = o && e.path.absolute.string === t.path.absolute.string, c = e.resource === t.resource || !e.resource &&
    t.extra.resourceIsIndex || r.removeDirectoryIndexes && e.extra.resourceIsIndex && !t.resource, p = l && (c || i || n || a), h = r.removeEmptyQueries ?
    "stripped" : "full", y = e.query.string[h], _ = t.query.string[h], g = p && !!y && y === _ || (n || a) && !e.extra.hrefInfo.separatorOnlyQuery,
    m = g && e.hash === t.hash;
    e.extra.relation.minimumPath = l, e.extra.relation.minimumResource = p, e.extra.relation.minimumQuery = g, e.extra.relation.minimumHash =
    m, e.extra.relation.maximumPort = !u || u && !l, e.extra.relation.maximumPath = !u || u && !p, e.extra.relation.maximumResource = !u || u &&
    !g, e.extra.relation.maximumQuery = !u || u && !m, e.extra.relation.maximumHash = !u || u && !m, e.extra.relation.overridesQuery = l && e.
    extra.relation.maximumResource && !g && !!_;
  }
  s(Eft, "findRelation_pathOn");
  lie.exports = {
    pathOn: Eft,
    upToPath: Tft
  };
});

// ../node_modules/relateurl/lib/relate/absolutize.js
var die = b((j3t, hie) => {
  "use strict";
  var fie = cie(), uk = VS(), pie = KS();
  function Aft(e, t, r) {
    fie.upToPath(e, t, r), e.extra.relation.minimumScheme && (e.scheme = t.scheme), e.extra.relation.minimumAuth && (e.auth = t.auth), e.extra.
    relation.minimumHost && (e.host = uk.clone(t.host)), e.extra.relation.minimumPort && Cft(e, t), e.extra.relation.minimumScheme && xft(e,
    t), fie.pathOn(e, t, r), e.extra.relation.minimumResource && Pft(e, t), e.extra.relation.minimumQuery && (e.query = uk.clone(t.query)), e.
    extra.relation.minimumHash && (e.hash = t.hash);
  }
  s(Aft, "absolutize");
  function xft(e, t) {
    if (e.extra.relation.maximumHost || !e.extra.hrefInfo.minimumResourceOnly) {
      var r = e.path.absolute.array, i = "/";
      r ? (e.extra.hrefInfo.minimumPathOnly && e.path.absolute.string.indexOf("/") !== 0 && (r = t.path.absolute.array.concat(r)), r = pie.resolveDotSegments(
      r), i += pie.join(r)) : r = [], e.path.absolute.array = r, e.path.absolute.string = i;
    } else
      e.path = uk.clone(t.path);
  }
  s(xft, "copyPath");
  function Cft(e, t) {
    e.port = t.port, e.extra.portIsDefault = t.extra.portIsDefault;
  }
  s(Cft, "copyPort");
  function Pft(e, t) {
    e.resource = t.resource, e.extra.resourceIsIndex = t.extra.resourceIsIndex;
  }
  s(Pft, "copyResource");
  hie.exports = Aft;
});

// ../node_modules/relateurl/lib/relate/relativize.js
var yie = b((K3t, mie) => {
  "use strict";
  var Dft = KS();
  function wft(e, t) {
    var r = [], i = !0, n = -1;
    return t.forEach(function(a, o) {
      i && (e[o] !== a ? i = !1 : n = o), i || r.push("..");
    }), e.forEach(function(a, o) {
      o > n && r.push(a);
    }), r;
  }
  s(wft, "relatePath");
  function Oft(e, t, r) {
    if (e.extra.relation.minimumScheme) {
      var i = wft(e.path.absolute.array, t.path.absolute.array);
      e.path.relative.array = i, e.path.relative.string = Dft.join(i);
    }
  }
  s(Oft, "relativize");
  mie.exports = Oft;
});

// ../node_modules/relateurl/lib/relate/index.js
var _ie = b((z3t, gie) => {
  "use strict";
  var kft = die(), Ift = yie();
  function Rft(e, t, r) {
    return kft(t, e, r), Ift(t, e, r), t;
  }
  s(Rft, "relateUrl");
  gie.exports = Rft;
});

// ../node_modules/relateurl/lib/index.js
var Tie = b((W3t, Sie) => {
  "use strict";
  var Nft = ok(), Lft = Bre(), bie = Kre(), vie = VS(), lk = uie(), Fft = _ie();
  function Jp(e, t) {
    this.options = bie(
      t,
      {
        defaultPorts: { ftp: 21, http: 80, https: 443 },
        directoryIndexes: ["index.html"],
        ignore_www: !1,
        output: Jp.SHORTEST,
        rejectedSchemes: ["data", "javascript", "mailto"],
        removeAuth: !1,
        removeDirectoryIndexes: !0,
        removeEmptyQueries: !1,
        removeRootTrailingSlash: !0,
        schemeRelative: !0,
        site: void 0,
        slashesDenoteHost: !0
      }
    ), this.from = lk.from(e, this.options, null);
  }
  s(Jp, "RelateUrl");
  Jp.prototype.relate = function(e, t, r) {
    if (vie.isPlainObject(t) ? (r = t, t = e, e = null) : t || (t = e, e = null), r = bie(r, this.options), e = e || r.site, e = lk.from(e, r,
    this.from), !e || !e.href)
      throw new Error("from value not defined.");
    if (e.extra.hrefInfo.minimumPathOnly)
      throw new Error("from value supplied is not absolute: " + e.href);
    return t = lk.to(t, r), t.valid === !1 ? t.href : (t = Fft(e, t, r), t = Lft(t, r), t);
  };
  Jp.relate = function(e, t, r) {
    return new Jp().relate(e, t, r);
  };
  vie.shallowMerge(Jp, Nft);
  Sie.exports = Jp;
});

// ../node_modules/html-minifier-terser/src/tokenchain.js
var xie = b((X3t, Aie) => {
  "use strict";
  function Eie() {
  }
  s(Eie, "Sorter");
  Eie.prototype.sort = function(e, t) {
    t = t || 0;
    for (var r = 0, i = this.keys.length; r < i; r++) {
      var n = this.keys[r], a = n.slice(1), o = e.indexOf(a, t);
      if (o !== -1) {
        do
          o !== t && (e.splice(o, 1), e.splice(t, 0, a)), t++;
        while ((o = e.indexOf(a, t)) !== -1);
        return this[n].sort(e, t);
      }
    }
    return e;
  };
  function ck() {
  }
  s(ck, "TokenChain");
  ck.prototype = {
    add: /* @__PURE__ */ s(function(e) {
      var t = this;
      e.forEach(function(r) {
        var i = "$" + r;
        t[i] || (t[i] = [], t[i].processed = 0), t[i].push(e);
      });
    }, "add"),
    createSorter: /* @__PURE__ */ s(function() {
      var e = this, t = new Eie();
      return t.keys = Object.keys(e).sort(function(r, i) {
        var n = e[r].length, a = e[i].length;
        return n < a ? 1 : n > a || r < i ? -1 : r > i ? 1 : 0;
      }).filter(function(r) {
        if (e[r].processed < e[r].length) {
          var i = r.slice(1), n = new ck();
          return e[r].forEach(function(a) {
            for (var o; (o = a.indexOf(i)) !== -1; )
              a.splice(o, 1);
            a.forEach(function(u) {
              e["$" + u].processed++;
            }), n.add(a.slice(0));
          }), t[r] = n.createSorter(), !0;
        }
        return !1;
      }), t;
    }, "createSorter")
  };
  Aie.exports = ck;
});

// ../node_modules/terser/lib/utils/index.js
function Wc(e) {
  return e.split("");
}
function Gm(e, t) {
  return t.includes(e);
}
function Mn(e, t, r) {
  e === !0 ? e = {} : e != null && typeof e == "object" && (e = { ...e });
  let i = e || {};
  if (r) {
    for (let n in i) if (Pi(i, n) && !Pi(t, n))
      throw new fk("`" + n + "` is not a supported option", t);
  }
  for (let n in t) if (Pi(t, n))
    if (!e || !Pi(e, n))
      i[n] = t[n];
    else if (n === "ecma") {
      let a = e[n] | 0;
      a > 5 && a < 2015 && (a += 2009), i[n] = a;
    } else
      i[n] = e && Pi(e, n) ? e[n] : t[n];
  return i;
}
function fn() {
}
function kt() {
  return !1;
}
function rn() {
  return !0;
}
function ao() {
  return this;
}
function zo() {
  return null;
}
function k(e, t, r) {
  return r || (r = {}), t && (r.start || (r.start = t.start), r.end || (r.end = t.end)), new e(r);
}
function Nu(e, t) {
  e.includes(t) || e.push(t);
}
function $c(e, t) {
  return e.replace(/{(.+?)}/g, function(r, i) {
    return t && t[i];
  });
}
function Lu(e, t) {
  for (var r = e.length; --r >= 0; )
    e[r] === t && e.splice(r, 1);
}
function pk(e, t) {
  if (e.length < 2) return e.slice();
  function r(n, a) {
    for (var o = [], u = 0, l = 0, c = 0; u < n.length && l < a.length; )
      t(n[u], a[l]) <= 0 ? o[c++] = n[u++] : o[c++] = a[l++];
    return u < n.length && o.push.apply(o, n.slice(u)), l < a.length && o.push.apply(o, a.slice(l)), o;
  }
  s(r, "merge");
  function i(n) {
    if (n.length <= 1)
      return n;
    var a = Math.floor(n.length / 2), o = n.slice(0, a), u = n.slice(a);
    return o = i(o), u = i(u), r(o, u);
  }
  return s(i, "_ms"), i(e);
}
function qt(e) {
  return Array.isArray(e) || (e = e.split(" ")), new Set(e.sort());
}
function Wm(e, t, r) {
  e.has(t) ? e.get(t).push(r) : e.set(t, [r]);
}
function Cie(e) {
  var t = /* @__PURE__ */ new Map();
  for (var r in e)
    Pi(e, r) && r.charAt(0) === "$" && t.set(r.substr(1), e[r]);
  return t;
}
function Pie(e) {
  var t = /* @__PURE__ */ Object.create(null);
  return e.forEach(function(r, i) {
    t["$" + i] = r;
  }), t;
}
function Pi(e, t) {
  return Object.prototype.hasOwnProperty.call(e, t);
}
function kl(e, t) {
  return e === !0 || e instanceof RegExp && e.test(t);
}
function Il(e) {
  return e.replace(/[\0\n\r\u2028\u2029]/g, function(t, r) {
    var i = e[r - 1] == "\\" && (e[r - 2] != "\\" || /(?:^|[^\\])(?:\\{2})*$/.test(e.slice(0, r - 1)));
    return (i ? "" : "\\") + Mft[t];
  });
}
function Die(e) {
  let t = new Set(e.split("")), r = "";
  for (let i of qft)
    t.has(i) && (r += i, t.delete(i));
  return t.size && t.forEach((i) => {
    r += i;
  }), r;
}
function nn(e, t) {
  return e._annotations & t;
}
function Qp(e, t) {
  e._annotations |= t;
}
function hk(e, t) {
  e._annotations &= ~t;
}
var fk, sr, Mft, Bft, HS, qft, Gi = at(() => {
  "use strict";
  Di();
  s(Wc, "characters");
  s(Gm, "member");
  fk = class extends Error {
    static {
      s(this, "DefaultsError");
    }
    constructor(t, r) {
      super(), this.name = "DefaultsError", this.message = t, this.defs = r;
    }
  };
  s(Mn, "defaults");
  s(fn, "noop");
  s(kt, "return_false");
  s(rn, "return_true");
  s(ao, "return_this");
  s(zo, "return_null");
  sr = function() {
    function e(r, i, n = !0) {
      let a = [];
      for (let o = 0; o < r.length; ++o) {
        let l = r[o].transform(i, n);
        l instanceof Se ? a.push(l) : l instanceof t && a.push(...l.v);
      }
      return a;
    }
    s(e, "MAP"), e.splice = function(r) {
      return new t(r);
    }, e.skip = {};
    function t(r) {
      this.v = r;
    }
    return s(t, "Splice"), e;
  }();
  s(k, "make_node");
  s(Nu, "push_uniq");
  s($c, "string_template");
  s(Lu, "remove");
  s(pk, "mergeSort");
  s(qt, "makePredicate");
  s(Wm, "map_add");
  s(Cie, "map_from_object");
  s(Pie, "map_to_object");
  s(Pi, "HOP");
  s(kl, "keep_name");
  Mft = {
    "\0": "0",
    "\n": "n",
    "\r": "r",
    "\u2028": "u2028",
    "\u2029": "u2029"
  };
  s(Il, "regexp_source_fix");
  Bft = /^[\\/|\0\s\w^$.[\]()]*$/, HS = /* @__PURE__ */ s((e) => Bft.test(e), "regexp_is_safe"), qft = "dgimsuyv";
  s(Die, "sort_regexp_flags");
  s(nn, "has_annotation");
  s(Qp, "set_annotation");
  s(hk, "clear_annotation");
});

// ../node_modules/terser/lib/parse.js
function Ym(e, t) {
  if (XS(e.charCodeAt(t))) {
    if (_k(e.charCodeAt(t + 1)))
      return e.charAt(t) + e.charAt(t + 1);
  } else if (_k(e.charCodeAt(t)) && XS(e.charCodeAt(t - 1)))
    return e.charAt(t - 1) + e.charAt(t);
  return e.charAt(t);
}
function Nie(e, t) {
  return XS(e.charCodeAt(t)) ? 65536 + (e.charCodeAt(t) - 55296 << 10) + e.charCodeAt(t + 1) - 56320 : e.charCodeAt(t);
}
function Yft(e) {
  for (var t = 0, r = 0; r < e.length; r++)
    XS(e.charCodeAt(r)) && _k(e.charCodeAt(r + 1)) && (t++, r++);
  return e.length - t;
}
function Jft(e) {
  return e > 65535 ? (e -= 65536, String.fromCharCode((e >> 10) + 55296) + String.fromCharCode(e % 1024 + 56320)) : String.fromCharCode(e);
}
function XS(e) {
  return e >= 55296 && e <= 56319;
}
function _k(e) {
  return e >= 56320 && e <= 57343;
}
function Oie(e) {
  return e >= 48 && e <= 57;
}
function mk(e) {
  return $S.ID_Start.test(e);
}
function Jm(e) {
  return $S.ID_Continue.test(e);
}
function Xc(e) {
  return Lie.test(e);
}
function bk(e, t) {
  if (Lie.test(e))
    return !0;
  if (!t && /[\ud800-\udfff]/.test(e))
    return !1;
  var r = $S.ID_Start.exec(e);
  return !r || r.index !== 0 ? !1 : (e = e.slice(r[0].length), e ? (r = $S.ID_Continue.exec(e), !!r && r[0].length === e.length) : !0);
}
function kie(e, t = !0) {
  if (!t && e.includes("e"))
    return NaN;
  if (Iie.test(e))
    return parseInt(e.substr(2), 16);
  if (Rie.test(e))
    return parseInt(e.substr(1), 8);
  if (Vft.test(e))
    return parseInt(e.substr(2), 8);
  if (Kft.test(e))
    return parseInt(e.substr(2), 2);
  if (Hft.test(e))
    return parseFloat(e);
  var r = parseFloat(e);
  if (r == e) return r;
}
function Zm(e, t, r, i, n) {
  throw new Qm(e, t, r, i, n);
}
function gs(e, t, r) {
  return e.type == t && (r == null || e.value == r);
}
function Qft(e, t, r, i) {
  var n = {
    text: e,
    filename: t,
    pos: 0,
    tokpos: 0,
    line: 1,
    tokline: 0,
    col: 0,
    tokcol: 0,
    newline_before: !1,
    regex_allowed: !1,
    brace_counter: 0,
    template_braces: [],
    comments_before: [],
    directives: {},
    directive_stack: []
  };
  function a() {
    return Ym(n.text, n.pos);
  }
  s(a, "peek");
  function o() {
    if (!(n.text.charCodeAt(n.pos + 1) === 46)) return !1;
    let ie = n.text.charCodeAt(n.pos + 2);
    return ie < 48 || ie > 57;
  }
  s(o, "is_option_chain_op");
  function u(G, ie) {
    var X = Ym(n.text, n.pos++);
    if (G && !X)
      throw yk;
    return dk.has(X) ? (n.newline_before = n.newline_before || !ie, ++n.line, n.col = 0, X == "\r" && a() == `
` && (++n.pos, X = `
`)) : (X.length > 1 && (++n.pos, ++n.col), ++n.col), X;
  }
  s(u, "next");
  function l(G) {
    for (; G--; ) u();
  }
  s(l, "forward");
  function c(G) {
    return n.text.substr(n.pos, G.length) == G;
  }
  s(c, "looking_at");
  function p() {
    for (var G = n.text, ie = n.pos, X = n.text.length; ie < X; ++ie) {
      var ye = G[ie];
      if (dk.has(ye))
        return ie;
    }
    return -1;
  }
  s(p, "find_eol");
  function h(G, ie) {
    var X = n.text.indexOf(G, n.pos);
    if (ie && X == -1) throw yk;
    return X;
  }
  s(h, "find");
  function y() {
    n.tokline = n.line, n.tokcol = n.col, n.tokpos = n.pos;
  }
  s(y, "start_token");
  var _ = !1, g = null;
  function m(G, ie, X) {
    n.regex_allowed = G == "operator" && !Fie.has(ie) || G == "keyword" && gk.has(ie) || G == "punc" && $ft.has(ie) || G == "arrow", G == "p\
unc" && (ie == "." || ie == "?.") ? _ = !0 : X || (_ = !1);
    let ye = n.tokline, Oe = n.tokcol, Pt = n.tokpos, Vt = n.newline_before, Ee = t, st = [], oe = [];
    X || (st = n.comments_before, oe = n.comments_before = []), n.newline_before = !1;
    let Ae = new Mu(G, ie, ye, Oe, Pt, Vt, st, oe, Ee);
    return X || (g = Ae), Ae;
  }
  s(m, "token");
  function f() {
    for (; Gft.has(a()); )
      u();
  }
  s(f, "skip_whitespace");
  function d(G) {
    for (var ie = "", X, ye = 0; (X = a()) && G(X, ye++); )
      ie += u();
    return ie;
  }
  s(d, "read_while");
  function v(G) {
    Zm(G, t, n.tokline, n.tokcol, n.tokpos);
  }
  s(v, "parse_error");
  function E(G) {
    var ie = !1, X = !1, ye = !1, Oe = G == ".", Pt = !1, Vt = !1, Ee = d(function(oe, Ae) {
      if (Pt) return !1;
      var Ie = oe.charCodeAt(0);
      switch (Ie) {
        case 95:
          return Vt = !0;
        case 98:
        case 66:
          return ye = !0;
        // Can occur in hex sequence, don't return false yet
        case 111:
        case 79:
        // oO
        case 120:
        case 88:
          return ye ? !1 : ye = !0;
        case 101:
        case 69:
          return ye ? !0 : ie ? !1 : ie = X = !0;
        case 45:
          return X || Ae == 0 && !G;
        case 43:
          return X;
        case (X = !1, 46):
          return !Oe && !ye && !ie ? Oe = !0 : !1;
      }
      return oe === "n" ? (Pt = !0, !0) : jft.test(oe);
    });
    if (G && (Ee = G + Ee), zS = Ee, Rie.test(Ee) && xe.has_directive("use strict") && v("Legacy octal literals are not allowed in strict mo\
de"), Vt && (Ee.endsWith("_") ? v("Numeric separators are not allowed at the end of numeric literals") : Ee.includes("__") && v("Only one un\
derscore is allowed as numeric separator"), Ee = Ee.replace(/_/g, "")), Ee.endsWith("n")) {
      let oe = Ee.slice(0, -1), Ae = Iie.test(oe), Ie = kie(oe, Ae);
      if (!Oe && zft.test(Ee) && !isNaN(Ie))
        return m("big_int", oe);
      v("Invalid or unexpected token");
    }
    var st = kie(Ee);
    if (isNaN(st))
      v("Invalid syntax: " + Ee);
    else
      return m("num", st);
  }
  s(E, "read_num");
  function S(G) {
    return G >= "0" && G <= "7";
  }
  s(S, "is_octal");
  function x(G, ie, X) {
    var ye = u(!0, G);
    switch (ye.charCodeAt(0)) {
      case 110:
        return `
`;
      case 114:
        return "\r";
      case 116:
        return "	";
      case 98:
        return "\b";
      case 118:
        return "\v";
      // \v
      case 102:
        return "\f";
      case 120:
        return String.fromCharCode(z(2, ie));
      // \x
      case 117:
        if (a() == "{") {
          for (u(!0), a() === "}" && v("Expecting hex-character between {}"); a() == "0"; ) u(!0);
          var Oe, Pt = h("}", !0) - n.pos;
          return (Pt > 6 || (Oe = z(Pt, ie)) > 1114111) && v("Unicode reference out of bounds"), u(!0), Jft(Oe);
        }
        return String.fromCharCode(z(4, ie));
      case 10:
        return "";
      // newline
      case 13:
        if (a() == `
`)
          return u(!0, G), "";
    }
    return S(ye) ? (X && ie && (ye === "0" && !S(a()) || v("Octal escape sequences are not allowed in template strings")), C(ye, ie)) : ye;
  }
  s(x, "read_escaped_char");
  function C(G, ie) {
    var X = a();
    return X >= "0" && X <= "7" && (G += u(!0), G[0] <= "3" && (X = a()) >= "0" && X <= "7" && (G += u(!0))), G === "0" ? "\0" : (G.length >
    0 && xe.has_directive("use strict") && ie && v("Legacy octal escape sequences are not allowed in strict mode"), String.fromCharCode(parseInt(
    G, 8)));
  }
  s(C, "read_octal_escape_sequence");
  function z(G, ie) {
    for (var X = 0; G > 0; --G) {
      if (!ie && isNaN(parseInt(a(), 16)))
        return parseInt(X, 16) || "";
      var ye = u(!0);
      isNaN(parseInt(ye, 16)) && v("Invalid hex-character pattern in string"), X += ye;
    }
    return parseInt(X, 16);
  }
  s(z, "hex_bytes");
  var w = he("Unterminated string constant", function() {
    let G = n.pos;
    for (var ie = u(), X = []; ; ) {
      var ye = u(!0, !0);
      if (ye == "\\") ye = x(!0, !0);
      else if (ye == "\r" || ye == `
`) v("Unterminated string constant");
      else if (ye == ie) break;
      X.push(ye);
    }
    var Oe = m("string", X.join(""));
    return zS = n.text.slice(G, n.pos), Oe.quote = ie, Oe;
  }), D = he("Unterminated template", function(G) {
    G && n.template_braces.push(n.brace_counter);
    var ie = "", X = "", ye, Oe;
    for (u(!0, !0); (ye = u(!0, !0)) != "`"; ) {
      if (ye == "\r")
        a() == `
` && ++n.pos, ye = `
`;
      else if (ye == "$" && a() == "{")
        return u(!0, !0), n.brace_counter++, Oe = m(G ? "template_head" : "template_substitution", ie), $m.set(Oe, X), Oe.template_end = !1,
        Oe;
      if (X += ye, ye == "\\") {
        var Pt = n.pos, Vt = g && (g.type === "name" || g.type === "punc" && (g.value === ")" || g.value === "]"));
        ye = x(!0, !Vt, !0), X += n.text.substr(Pt, n.pos - Pt);
      }
      ie += ye;
    }
    return n.template_braces.pop(), Oe = m(G ? "template_head" : "template_substitution", ie), $m.set(Oe, X), Oe.template_end = !0, Oe;
  });
  function N(G) {
    var ie = n.regex_allowed, X = p(), ye;
    return X == -1 ? (ye = n.text.substr(n.pos), n.pos = n.text.length) : (ye = n.text.substring(n.pos, X), n.pos = X), n.col = n.tokcol + (n.
    pos - n.tokpos), n.comments_before.push(m(G, ye, !0)), n.regex_allowed = ie, xe;
  }
  s(N, "skip_line_comment");
  var T = he("Unterminated multiline comment", function() {
    var G = n.regex_allowed, ie = h("*/", !0), X = n.text.substring(n.pos, ie).replace(/\r\n|\r|\u2028|\u2029/g, `
`);
    return l(Yft(X) + 2), n.comments_before.push(m("comment2", X, !0)), n.newline_before = n.newline_before || X.includes(`
`), n.regex_allowed = G, xe;
  }), R = he("Unterminated identifier name", function() {
    var G = [], ie, X = !1, ye = /* @__PURE__ */ s(function() {
      return X = !0, u(), a() !== "u" && v("Expecting UnicodeEscapeSequence -- uXXXX or u{XXXX}"), x(!1, !0);
    }, "read_escaped_identifier_char");
    if ((ie = a()) === "\\")
      ie = ye(), mk(ie) || v("First identifier char is an invalid identifier char");
    else if (mk(ie))
      u();
    else
      return "";
    for (G.push(ie); (ie = a()) != null; ) {
      if ((ie = a()) === "\\")
        ie = ye(), Jm(ie) || v("Invalid escaped identifier char");
      else {
        if (!Jm(ie))
          break;
        u();
      }
      G.push(ie);
    }
    let Oe = G.join("");
    return Xm.has(Oe) && X && v("Escaped characters are not allowed in keywords"), Oe;
  }), j = he("Unterminated regular expression", function(G) {
    for (var ie = !1, X, ye = !1; X = u(!0); ) if (dk.has(X))
      v("Unexpected line terminator");
    else if (ie)
      /^[\u0000-\u007F]$/.test(X) ? G += "\\" + X : G += X, ie = !1;
    else if (X == "[")
      ye = !0, G += X;
    else if (X == "]" && ye)
      ye = !1, G += X;
    else {
      if (X == "/" && !ye)
        break;
      X == "\\" ? ie = !0 : G += X;
    }
    let Oe = R();
    return m("regexp", "/" + G + "/" + Oe);
  });
  function J(G) {
    function ie(X) {
      if (!a()) return X;
      var ye = X + a();
      return wie.has(ye) ? (u(), ie(ye)) : X;
    }
    return s(ie, "grow"), m("operator", ie(G || u()));
  }
  s(J, "read_operator");
  function H() {
    switch (u(), a()) {
      case "/":
        return u(), N("comment1");
      case "*":
        return u(), T();
    }
    return n.regex_allowed ? j("") : J("/");
  }
  s(H, "handle_slash");
  function F() {
    return u(), a() === ">" ? (u(), m("arrow", "=>")) : J("=");
  }
  s(F, "handle_eq_sign");
  function re() {
    return u(), Oie(a().charCodeAt(0)) ? E(".") : a() === "." ? (u(), u(), m("expand", "...")) : m("punc", ".");
  }
  s(re, "handle_dot");
  function se() {
    var G = R();
    return _ ? m("name", G) : WS.has(G) ? m("atom", G) : GS.has(G) ? wie.has(G) ? m("operator", G) : m("keyword", G) : m("name", G);
  }
  s(se, "read_word");
  function de() {
    return u(), m("privatename", R());
  }
  s(de, "read_private_word");
  function he(G, ie) {
    return function(X) {
      try {
        return ie(X);
      } catch (ye) {
        if (ye === yk) v(G);
        else throw ye;
      }
    };
  }
  s(he, "with_eof_error");
  function xe(G) {
    if (G != null)
      return j(G);
    for (i && n.pos == 0 && c("#!") && (y(), l(2), N("comment5")); ; ) {
      if (f(), y(), r) {
        if (c("<!--")) {
          l(4), N("comment3");
          continue;
        }
        if (c("-->") && n.newline_before) {
          l(3), N("comment4");
          continue;
        }
      }
      var ie = a();
      if (!ie) return m("eof");
      var X = ie.charCodeAt(0);
      switch (X) {
        case 34:
        case 39:
          return w();
        case 46:
          return re();
        case 47: {
          var ye = H();
          if (ye === xe) continue;
          return ye;
        }
        case 61:
          return F();
        case 63: {
          if (!o()) break;
          return u(), u(), m("punc", "?.");
        }
        case 96:
          return D(!0);
        case 123:
          n.brace_counter++;
          break;
        case 125:
          if (n.brace_counter--, n.template_braces.length > 0 && n.template_braces[n.template_braces.length - 1] === n.brace_counter)
            return D(!1);
          break;
      }
      if (Oie(X)) return E();
      if (Xft.has(ie)) return m("punc", u());
      if (Uft.has(ie)) return J();
      if (X == 92 || mk(ie)) return se();
      if (X == 35) return de();
      break;
    }
    v("Unexpected character '" + ie + "'");
  }
  return s(xe, "next_token"), xe.next = u, xe.peek = a, xe.context = function(G) {
    return G && (n = G), n;
  }, xe.add_directive = function(G) {
    n.directive_stack[n.directive_stack.length - 1].push(G), n.directives[G] === void 0 ? n.directives[G] = 1 : n.directives[G]++;
  }, xe.push_directives_stack = function() {
    n.directive_stack.push([]);
  }, xe.pop_directives_stack = function() {
    for (var G = n.directive_stack[n.directive_stack.length - 1], ie = 0; ie < G.length; ie++)
      n.directives[G[ie]]--;
    n.directive_stack.pop();
  }, xe.has_directive = function(G) {
    return n.directives[G] > 0;
  }, xe;
}
function $o(e, t) {
  let r = /* @__PURE__ */ new WeakMap();
  t = Mn(t, {
    bare_returns: !1,
    ecma: null,
    // Legacy
    expression: !1,
    filename: null,
    html5_comments: !0,
    module: !1,
    shebang: !0,
    strict: !1,
    toplevel: null
  }, !0);
  var i = {
    input: typeof e == "string" ? Qft(
      e,
      t.filename,
      t.html5_comments,
      t.shebang
    ) : e,
    token: null,
    prev: null,
    peeked: null,
    in_function: 0,
    in_async: -1,
    in_generator: -1,
    in_directives: !0,
    in_loop: 0,
    labels: []
  };
  i.token = o();
  function n(P, Y) {
    return gs(i.token, P, Y);
  }
  s(n, "is");
  function a() {
    return i.peeked || (i.peeked = i.input());
  }
  s(a, "peek");
  function o() {
    return i.prev = i.token, i.peeked || a(), i.token = i.peeked, i.peeked = null, i.in_directives = i.in_directives && (i.token.type == "st\
ring" || n("punc", ";")), i.token;
  }
  s(o, "next");
  function u() {
    return i.prev;
  }
  s(u, "prev");
  function l(P, Y, Q, le) {
    var me = i.input.context();
    Zm(
      P,
      me.filename,
      Y ?? me.tokline,
      Q ?? me.tokcol,
      le ?? me.tokpos
    );
  }
  s(l, "croak");
  function c(P, Y) {
    l(Y, P.line, P.col);
  }
  s(c, "token_error");
  function p(P) {
    P == null && (P = i.token), c(P, "Unexpected token: " + P.type + " (" + P.value + ")");
  }
  s(p, "unexpected");
  function h(P, Y) {
    if (n(P, Y))
      return o();
    c(i.token, "Unexpected token " + i.token.type + " \xAB" + i.token.value + "\xBB, expected " + P + " \xAB" + Y + "\xBB");
  }
  s(h, "expect_token");
  function y(P) {
    return h("punc", P);
  }
  s(y, "expect");
  function _(P) {
    return P.nlb || !P.comments_before.every((Y) => !Y.nlb);
  }
  s(_, "has_newline_before");
  function g() {
    return !t.strict && (n("eof") || n("punc", "}") || _(i.token));
  }
  s(g, "can_insert_semicolon");
  function m() {
    return i.in_generator === i.in_function;
  }
  s(m, "is_in_generator");
  function f() {
    return i.in_async === i.in_function;
  }
  s(f, "is_in_async");
  function d() {
    return i.in_async === i.in_function || i.in_function === 0 && i.input.has_directive("use strict");
  }
  s(d, "can_await");
  function v(P) {
    n("punc", ";") ? o() : !P && !g() && p();
  }
  s(v, "semicolon");
  function E() {
    y("(");
    var P = $t(!0);
    return y(")"), P;
  }
  s(E, "parenthesised");
  function S(P) {
    return /* @__PURE__ */ s(function(...Q) {
      let le = i.token, me = P(...Q);
      return me.start = le, me.end = u(), me;
    }, "_embed_tokens_wrapper");
  }
  s(S, "embed_tokens");
  function x() {
    (n("operator", "/") || n("operator", "/=")) && (i.peeked = null, i.token = i.input(i.token.value.substr(1)));
  }
  s(x, "handle_regexp");
  var C = S(/* @__PURE__ */ s(function P(Y, Q, le) {
    switch (x(), i.token.type) {
      case "string":
        if (i.in_directives) {
          var me = a();
          !zS.includes("\\") && (gs(me, "punc", ";") || gs(me, "punc", "}") || _(me) || gs(me, "eof")) ? i.input.add_directive(i.token.value) :
          i.in_directives = !1;
        }
        var Xe = i.in_directives, Ge = w();
        return Xe && Ge.body instanceof bt ? new wi(Ge.body) : Ge;
      case "template_head":
      case "num":
      case "big_int":
      case "regexp":
      case "operator":
      case "atom":
        return w();
      case "name":
      case "privatename":
        if (n("privatename") && !i.in_class && l("Private field must be used in an enclosing class"), i.token.value == "async" && gs(a(), "k\
eyword", "function"))
          return o(), o(), Q && l("functions are not allowed as the body of a loop"), H(tr, !1, !0, Y);
        if (i.token.value == "import" && !gs(a(), "punc", "(") && !gs(a(), "punc", ".")) {
          o();
          var Bt = ze();
          return v(), Bt;
        }
        return gs(a(), "punc", ":") ? z() : w();
      case "punc":
        switch (i.token.value) {
          case "{":
            return new ot({
              start: i.token,
              body: ye(),
              end: u()
            });
          case "[":
          case "(":
            return w();
          case ";":
            return i.in_directives = !1, o(), new Rt();
          default:
            p();
        }
      case "keyword":
        switch (i.token.value) {
          case "break":
            return o(), D(hn);
          case "continue":
            return o(), D(ua);
          case "debugger":
            return o(), v(), new is();
          case "do":
            o();
            var fi = iu(P);
            h("keyword", "while");
            var Ps = E();
            return v(!0), new Pn({
              body: fi,
              condition: Ps
            });
          case "while":
            return o(), new qn({
              condition: E(),
              body: iu(function() {
                return P(!1, !0);
              })
            });
          case "for":
            return o(), N();
          case "class":
            return o(), Q && l("classes are not allowed as the body of a loop"), le && l("classes are not allowed as the body of an if"), ae(
            an, Y);
          case "function":
            return o(), Q && l("functions are not allowed as the body of a loop"), H(tr, !1, !1, Y);
          case "if":
            return o(), X();
          case "return":
            i.in_function == 0 && !t.bare_returns && l("'return' outside of function"), o();
            var In = null;
            return n("punc", ";") ? o() : g() || (In = $t(!0), v()), new mr({
              value: In
            });
          case "switch":
            return o(), new Vr({
              expression: E(),
              body: iu(Oe)
            });
          case "throw":
            o(), _(i.token) && l("Illegal newline after 'throw'");
            var In = $t(!0);
            return v(), new Bu({
              value: In
            });
          case "try":
            return o(), Pt();
          case "var":
            o();
            var Bt = Ee();
            return v(), Bt;
          case "let":
            o();
            var Bt = st();
            return v(), Bt;
          case "const":
            o();
            var Bt = oe();
            return v(), Bt;
          case "with":
            return i.input.has_directive("use strict") && l("Strict mode may not include a with statement"), o(), new di({
              expression: E(),
              body: P()
            });
          case "export":
            if (!gs(a(), "punc", "(")) {
              o();
              var Bt = Re();
              return n("punc", ";") && v(), Bt;
            }
        }
    }
    p();
  }, "statement"));
  function z() {
    var P = qr(Ll);
    P.name === "await" && f() && c(i.prev, "await cannot be used as label inside async function"), i.labels.some((Q) => Q.name === P.name) &&
    l("Label " + P.name + " defined twice"), y(":"), i.labels.push(P);
    var Y = C();
    return i.labels.pop(), Y instanceof ns || P.references.forEach(function(Q) {
      Q instanceof ua && (Q = Q.label.start, l(
        "Continue label `" + P.name + "` refers to non-IterationStatement.",
        Q.line,
        Q.col,
        Q.pos
      ));
    }), new wr({ body: Y, label: P });
  }
  s(z, "labeled_statement");
  function w(P) {
    return new qe({ body: (P = $t(!0), v(), P) });
  }
  s(w, "simple_statement");
  function D(P) {
    var Y = null, Q;
    g() || (Y = qr(Zp, !0)), Y != null ? (Q = i.labels.find((me) => me.name === Y.name), Q || l("Undefined label " + Y.name), Y.thedef = Q) :
    i.in_loop == 0 && l(P.TYPE + " not inside a loop or switch"), v();
    var le = new P({ label: Y });
    return Q && Q.references.push(le), le;
  }
  s(D, "break_cont");
  function N() {
    var P = "`for await` invalid in this context", Y = i.token;
    Y.type == "name" && Y.value == "await" ? (d() || c(Y, P), o()) : Y = !1, y("(");
    var Q = null;
    if (n("punc", ";"))
      Y && c(Y, P);
    else {
      Q = n("keyword", "var") ? (o(), Ee(!0)) : n("keyword", "let") ? (o(), st(!0)) : n("keyword", "const") ? (o(), oe(!0)) : $t(!0, !0);
      var le = n("operator", "in"), me = n("name", "of");
      if (Y && !me && c(Y, P), le || me)
        return Q instanceof cr ? Q.definitions.length > 1 && c(Q.start, "Only one variable declaration allowed in for..in loop") : Jl(Q) || (Q =
        Cs(Q)) instanceof Ut || c(Q.start, "Invalid left-hand side in for..in loop"), o(), le ? j(Q) : R(Q, !!Y);
    }
    return T(Q);
  }
  s(N, "for_");
  function T(P) {
    y(";");
    var Y = n("punc", ";") ? null : $t(!0);
    y(";");
    var Q = n("punc", ")") ? null : $t(!0);
    return y(")"), new yr({
      init: P,
      condition: Y,
      step: Q,
      body: iu(function() {
        return C(!1, !0);
      })
    });
  }
  s(T, "regular_for");
  function R(P, Y) {
    var Q = P instanceof cr ? P.definitions[0].name : null, le = $t(!0);
    return y(")"), new ka({
      await: Y,
      init: P,
      name: Q,
      object: le,
      body: iu(function() {
        return C(!1, !0);
      })
    });
  }
  s(R, "for_of");
  function j(P) {
    var Y = $t(!0);
    return y(")"), new Or({
      init: P,
      object: Y,
      body: iu(function() {
        return C(!1, !0);
      })
    });
  }
  s(j, "for_in");
  var J = /* @__PURE__ */ s(function(P, Y, Q) {
    _(i.token) && l("Unexpected newline before arrow (=>)"), h("arrow", "=>");
    var le = xe(n("punc", "{"), !1, Q), me = le instanceof Array && le.length ? le[le.length - 1].end : le instanceof Array ? P : le.end;
    return new Zt({
      start: P,
      end: me,
      async: Q,
      argnames: Y,
      body: le
    });
  }, "arrow_function"), H = /* @__PURE__ */ s(function(P, Y, Q, le) {
    var me = P === tr, Xe = n("operator", "*");
    Xe && o();
    var Ge = n("name") ? qr(me ? jn : kn) : null;
    me && !Ge && (le ? P = jt : p()), Ge && P !== rs && !(Ge instanceof Lr) && p(u());
    var Bt = [], fi = xe(!0, Xe || Y, Q, Ge, Bt);
    return new P({
      start: Bt.start,
      end: fi.end,
      is_generator: Xe,
      async: Q,
      name: Ge,
      argnames: Bt,
      body: fi
    });
  }, "function_");
  class F {
    static {
      s(this, "UsedParametersTracker");
    }
    constructor(Y, Q, le = !1) {
      this.is_parameter = Y, this.duplicates_ok = le, this.parameters = /* @__PURE__ */ new Set(), this.duplicate = null, this.default_assignment =
      !1, this.spread = !1, this.strict_mode = !!Q;
    }
    add_parameter(Y) {
      if (this.parameters.has(Y.value))
        this.duplicate === null && (this.duplicate = Y), this.check_strict();
      else if (this.parameters.add(Y.value), this.is_parameter)
        switch (Y.value) {
          case "arguments":
          case "eval":
          case "yield":
            this.strict_mode && c(Y, "Unexpected " + Y.value + " identifier as parameter inside strict mode");
            break;
          default:
            Xm.has(Y.value) && p();
        }
    }
    mark_default_assignment(Y) {
      this.default_assignment === !1 && (this.default_assignment = Y);
    }
    mark_spread(Y) {
      this.spread === !1 && (this.spread = Y);
    }
    mark_strict_mode() {
      this.strict_mode = !0;
    }
    is_strict() {
      return this.default_assignment !== !1 || this.spread !== !1 || this.strict_mode;
    }
    check_strict() {
      this.is_strict() && this.duplicate !== null && !this.duplicates_ok && c(this.duplicate, "Parameter " + this.duplicate.value + " was us\
ed already");
    }
  }
  function re(P) {
    var Y = new F(!0, i.input.has_directive("use strict"));
    for (y("("); !n("punc", ")"); ) {
      var Q = se(Y);
      if (P.push(Q), n("punc", ")") || y(","), Q instanceof ft)
        break;
    }
    o();
  }
  s(re, "parameters");
  function se(P, Y) {
    var Q, le = !1;
    return P === void 0 && (P = new F(!0, i.input.has_directive("use strict"))), n("expand", "...") && (le = i.token, P.mark_spread(i.token),
    o()), Q = de(P, Y), n("operator", "=") && le === !1 && (P.mark_default_assignment(i.token), o(), Q = new sn({
      start: Q.start,
      left: Q,
      operator: "=",
      right: $t(!1),
      end: i.token
    })), le !== !1 && (n("punc", ")") || p(), Q = new ft({
      start: le,
      expression: Q,
      end: le
    })), P.check_strict(), Q;
  }
  s(se, "parameter");
  function de(P, Y) {
    var Q = [], le = !0, me = !1, Xe, Ge = i.token;
    if (P === void 0) {
      let Zl = i.input.has_directive("use strict"), ei = Y === bs;
      P = new F(!1, Zl, ei);
    }
    if (Y = Y === void 0 ? Nr : Y, n("punc", "[")) {
      for (o(); !n("punc", "]"); ) {
        if (le ? le = !1 : y(","), n("expand", "...") && (me = !0, Xe = i.token, P.mark_spread(i.token), o()), n("punc"))
          switch (i.token.value) {
            case ",":
              Q.push(new xn({
                start: i.token,
                end: i.token
              }));
              continue;
            case "]":
              break;
            case "[":
            case "{":
              Q.push(de(P, Y));
              break;
            default:
              p();
          }
        else n("name") ? (P.add_parameter(i.token), Q.push(qr(Y))) : l("Invalid function parameter");
        n("operator", "=") && me === !1 && (P.mark_default_assignment(i.token), o(), Q[Q.length - 1] = new sn({
          start: Q[Q.length - 1].start,
          left: Q[Q.length - 1],
          operator: "=",
          right: $t(!1),
          end: i.token
        })), me && (n("punc", "]") || l("Rest element must be last element"), Q[Q.length - 1] = new ft({
          start: Xe,
          expression: Q[Q.length - 1],
          end: Xe
        }));
      }
      return y("]"), P.check_strict(), new Ut({
        start: Ge,
        names: Q,
        is_array: !0,
        end: u()
      });
    } else if (n("punc", "{")) {
      for (o(); !n("punc", "}"); ) {
        if (le ? le = !1 : y(","), n("expand", "...") && (me = !0, Xe = i.token, P.mark_spread(i.token), o()), n("name") && (gs(a(), "punc") ||
        gs(a(), "operator")) && [",", "}", "="].includes(a().value)) {
          P.add_parameter(i.token);
          var Bt = u(), fi = qr(Y);
          me ? Q.push(new ft({
            start: Xe,
            expression: fi,
            end: fi.end
          })) : Q.push(new Nt({
            start: Bt,
            key: fi.name,
            value: fi,
            end: fi.end
          }));
        } else {
          if (n("punc", "}"))
            continue;
          var Ps = i.token, In = St();
          In === null ? p(u()) : u().type === "name" && !n("punc", ":") ? Q.push(new Nt({
            start: u(),
            key: In,
            value: new Y({
              start: u(),
              name: In,
              end: u()
            }),
            end: u()
          })) : (y(":"), Q.push(new Nt({
            start: Ps,
            quote: Ps.quote,
            key: In,
            value: de(P, Y),
            end: u()
          })));
        }
        me ? n("punc", "}") || l("Rest element must be last element") : n("operator", "=") && (P.mark_default_assignment(i.token), o(), Q[Q.
        length - 1].value = new sn({
          start: Q[Q.length - 1].value.start,
          left: Q[Q.length - 1].value,
          operator: "=",
          right: $t(!1),
          end: i.token
        }));
      }
      return y("}"), P.check_strict(), new Ut({
        start: Ge,
        names: Q,
        is_array: !1,
        end: u()
      });
    } else {
      if (n("name"))
        return P.add_parameter(i.token), qr(Y);
      l("Invalid function parameter");
    }
  }
  s(de, "binding_element");
  function he(P, Y) {
    var Q, le, me, Xe = [];
    for (y("("); !n("punc", ")"); )
      Q && p(Q), n("expand", "...") ? (Q = i.token, Y && (le = i.token), o(), Xe.push(new ft({
        start: u(),
        expression: $t(),
        end: i.token
      }))) : Xe.push($t()), n("punc", ")") || (y(","), n("punc", ")") && (me = u(), Y && (le = me)));
    return y(")"), P && n("arrow", "=>") ? Q && me && p(me) : le && p(le), Xe;
  }
  s(he, "params_or_seq_");
  function xe(P, Y, Q, le, me) {
    var Xe = i.in_loop, Ge = i.labels, Bt = i.in_generator, fi = i.in_async;
    if (++i.in_function, Y && (i.in_generator = i.in_function), Q && (i.in_async = i.in_function), me && re(me), P && (i.in_directives = !0),
    i.in_loop = 0, i.labels = [], P) {
      i.input.push_directives_stack();
      var Ps = ye();
      le && rr(le), me && me.forEach(rr), i.input.pop_directives_stack();
    } else
      var Ps = [new mr({
        start: i.token,
        value: $t(!1),
        end: i.token
      })];
    return --i.in_function, i.in_loop = Xe, i.labels = Ge, i.in_generator = Bt, i.in_async = fi, Ps;
  }
  s(xe, "_function_body");
  function G() {
    return d() || l(
      "Unexpected await expression outside async function",
      i.prev.line,
      i.prev.col,
      i.prev.pos
    ), new Mi({
      start: u(),
      end: i.token,
      expression: Hn(!0)
    });
  }
  s(G, "_await_expression");
  function ie() {
    m() || l(
      "Unexpected yield expression outside generator function",
      i.prev.line,
      i.prev.col,
      i.prev.pos
    );
    var P = i.token, Y = !1, Q = !0;
    return g() || n("punc") && Wft.has(i.token.value) ? Q = !1 : n("operator", "*") && (Y = !0, o()), new Oi({
      start: P,
      is_star: Y,
      expression: Q ? $t() : null,
      end: u()
    });
  }
  s(ie, "_yield_expression");
  function X() {
    var P = E(), Y = C(!1, !1, !0), Q = null;
    return n("keyword", "else") && (o(), Q = C(!1, !1, !0)), new Ft({
      condition: P,
      body: Y,
      alternative: Q
    });
  }
  s(X, "if_");
  function ye() {
    y("{");
    for (var P = []; !n("punc", "}"); )
      n("eof") && p(), P.push(C());
    return o(), P;
  }
  s(ye, "block_");
  function Oe() {
    y("{");
    for (var P = [], Y = null, Q = null, le; !n("punc", "}"); )
      n("eof") && p(), n("keyword", "case") ? (Q && (Q.end = u()), Y = [], Q = new dn({
        start: (le = i.token, o(), le),
        expression: $t(!0),
        body: Y
      }), P.push(Q), y(":")) : n("keyword", "default") ? (Q && (Q.end = u()), Y = [], Q = new zs({
        start: (le = i.token, o(), y(":"), le),
        body: Y
      }), P.push(Q)) : (Y || p(), Y.push(C()));
    return Q && (Q.end = u()), o(), P;
  }
  s(Oe, "switch_body_");
  function Pt() {
    var P, Y = null, Q = null;
    if (P = new Nl({
      start: i.token,
      body: ye(),
      end: u()
    }), n("keyword", "catch")) {
      var le = i.token;
      if (o(), n("punc", "{"))
        var me = null;
      else {
        y("(");
        var me = se(void 0, Vn);
        y(")");
      }
      Y = new mn({
        start: le,
        argname: me,
        body: ye(),
        end: u()
      });
    }
    if (n("keyword", "finally")) {
      var le = i.token;
      o(), Q = new uo({
        start: le,
        body: ye(),
        end: u()
      });
    }
    return !Y && !Q && l("Missing catch/finally blocks"), new mi({
      body: P,
      bcatch: Y,
      bfinally: Q
    });
  }
  s(Pt, "try_");
  function Vt(P, Y) {
    for (var Q = [], le; ; ) {
      var me = Y === "var" ? bs : Y === "const" ? la : Y === "let" ? co : null;
      if (n("punc", "{") || n("punc", "[") ? le = new Lt({
        start: i.token,
        name: de(void 0, me),
        value: n("operator", "=") ? (h("operator", "="), $t(!1, P)) : null,
        end: u()
      }) : (le = new Lt({
        start: i.token,
        name: qr(me),
        value: n("operator", "=") ? (o(), $t(!1, P)) : !P && Y === "const" ? l("Missing initializer in const declaration") : null,
        end: u()
      }), le.name.name == "import" && l("Unexpected token: import")), Q.push(le), !n("punc", ","))
        break;
      o();
    }
    return Q;
  }
  s(Vt, "vardefs");
  var Ee = /* @__PURE__ */ s(function(P) {
    return new Fr({
      start: u(),
      definitions: Vt(P, "var"),
      end: u()
    });
  }, "var_"), st = /* @__PURE__ */ s(function(P) {
    return new Dn({
      start: u(),
      definitions: Vt(P, "let"),
      end: u()
    });
  }, "let_"), oe = /* @__PURE__ */ s(function(P) {
    return new wn({
      start: u(),
      definitions: Vt(P, "const"),
      end: u()
    });
  }, "const_"), Ae = /* @__PURE__ */ s(function(P) {
    var Y = i.token;
    if (h("operator", "new"), n("punc", "."))
      return o(), h("name", "target"), zr(new lo({
        start: Y,
        end: u()
      }), P);
    var Q = pe(!1), le;
    n("punc", "(") ? (o(), le = He(")", !0)) : le = [];
    var me = new gi({
      start: Y,
      expression: Q,
      args: le,
      end: u()
    });
    return Si(me), zr(me, P);
  }, "new_");
  function Ie() {
    var P = i.token, Y;
    switch (P.type) {
      case "name":
        Y = yt(Te);
        break;
      case "num":
        Y = new We({
          start: P,
          end: P,
          value: P.value,
          raw: zS
        });
        break;
      case "big_int":
        Y = new un({ start: P, end: P, value: P.value });
        break;
      case "string":
        Y = new bt({
          start: P,
          end: P,
          value: P.value,
          quote: P.quote
        }), Si(Y);
        break;
      case "regexp":
        let [Q, le, me] = P.value.match(/^\/(.*)\/(\w*)$/);
        Y = new $r({ start: P, end: P, value: { source: le, flags: me } });
        break;
      case "atom":
        switch (P.value) {
          case "false":
            Y = new Ss({ start: P, end: P });
            break;
          case "true":
            Y = new ln({ start: P, end: P });
            break;
          case "null":
            Y = new Xi({ start: P, end: P });
            break;
        }
        break;
    }
    return o(), Y;
  }
  s(Ie, "as_atom_node");
  function te(P, Y) {
    var Q = /* @__PURE__ */ s(function(le, me) {
      return me ? new sn({
        start: le.start,
        left: le,
        operator: "=",
        right: me,
        end: me.end
      }) : le;
    }, "insert_default");
    if (P instanceof Tt)
      return Q(new Ut({
        start: P.start,
        end: P.end,
        is_array: !1,
        names: P.properties.map((le) => te(le))
      }), Y);
    if (P instanceof Nt)
      return P.value = te(P.value), Q(P, Y);
    if (P instanceof xn)
      return P;
    if (P instanceof Ut)
      return P.names = P.names.map((le) => te(le)), Q(P, Y);
    if (P instanceof Te)
      return Q(new Nr({
        name: P.name,
        start: P.start,
        end: P.end
      }), Y);
    if (P instanceof ft)
      return P.expression = te(P.expression), Q(P, Y);
    if (P instanceof pt)
      return Q(new Ut({
        start: P.start,
        end: P.end,
        is_array: !0,
        names: P.elements.map((le) => te(le))
      }), Y);
    if (P instanceof ct)
      return Q(te(P.left, P.right), Y);
    if (P instanceof sn)
      return P.left = te(P.left), P;
    l("Invalid function parameter", P.start.line, P.start.col);
  }
  s(te, "to_fun_args");
  var pe = /* @__PURE__ */ s(function(P, Y) {
    if (n("operator", "new"))
      return Ae(P);
    if (n("name", "import") && gs(a(), "punc", "."))
      return nt(P);
    var Q = i.token, le, me = n("name", "async") && (le = a()).value != "[" && le.type != "arrow" && Ie();
    if (n("punc")) {
      switch (i.token.value) {
        case "(":
          if (me && !P) break;
          var Xe = he(Y, !me);
          if (Y && n("arrow", "=>"))
            return J(Q, Xe.map((ei) => te(ei)), !!me);
          var Ge = me ? new Fe({
            expression: me,
            args: Xe
          }) : bh(Q, Xe);
          if (Ge.start) {
            let ei = Q.comments_before.length;
            if (r.set(Q, ei), Ge.start.comments_before.unshift(...Q.comments_before), Q.comments_before = Ge.start.comments_before, ei == 0 &&
            Q.comments_before.length > 0) {
              var Bt = Q.comments_before[0];
              Bt.nlb || (Bt.nlb = Q.nlb, Q.nlb = !1);
            }
            Q.comments_after = Ge.start.comments_after;
          }
          Ge.start = Q;
          var fi = u();
          return Ge.end && (fi.comments_before = Ge.end.comments_before, Ge.end.comments_after.push(...fi.comments_after), fi.comments_after =
          Ge.end.comments_after), Ge.end = fi, Ge instanceof Fe && Si(Ge), zr(Ge, P);
        case "[":
          return zr(vt(), P);
        case "{":
          return zr(xr(), P);
      }
      me || p();
    }
    if (Y && n("name") && gs(a(), "arrow")) {
      var Ps = new Nr({
        name: i.token.value,
        start: Q,
        end: Q
      });
      return o(), J(Q, [Ps], !!me);
    }
    if (n("keyword", "function")) {
      o();
      var In = H(jt, !1, !!me);
      return In.start = Q, In.end = u(), zr(In, P);
    }
    if (me) return zr(me, P);
    if (n("keyword", "class")) {
      o();
      var Zl = ae(ts);
      return Zl.start = Q, Zl.end = u(), zr(Zl, P);
    }
    if (n("template_head"))
      return zr(we(), P);
    if (rpt.has(i.token.type))
      return zr(Ie(), P);
    p();
  }, "expr_atom");
  function we() {
    var P = [], Y = i.token;
    for (P.push(new Bn({
      start: i.token,
      raw: $m.get(i.token),
      value: i.token.value,
      end: i.token
    })); !i.token.template_end; )
      o(), x(), P.push($t(!0)), P.push(new Bn({
        start: i.token,
        raw: $m.get(i.token),
        value: i.token.value,
        end: i.token
      }));
    return o(), new jr({
      start: Y,
      segments: P,
      end: i.token
    });
  }
  s(we, "template_string");
  function He(P, Y, Q) {
    for (var le = !0, me = []; !n("punc", P) && (le ? le = !1 : y(","), !(Y && n("punc", P))); )
      n("punc", ",") && Q ? me.push(new xn({ start: i.token, end: i.token })) : n("expand", "...") ? (o(), me.push(new ft({ start: u(), expression: $t(),
      end: i.token }))) : me.push($t(!1));
    return o(), me;
  }
  s(He, "expr_list");
  var vt = S(function() {
    return y("["), new pt({
      elements: He("]", !t.strict, !0)
    });
  }), wt = S((P, Y) => H(rs, P, Y)), xr = S(/* @__PURE__ */ s(function() {
    var Y = i.token, Q = !0, le = [];
    for (y("{"); !n("punc", "}") && (Q ? Q = !1 : y(","), !(!t.strict && n("punc", "}"))); ) {
      if (Y = i.token, Y.type == "expand") {
        o(), le.push(new ft({
          start: Y,
          expression: $t(!1),
          end: u()
        }));
        continue;
      }
      n("privatename") && l("private fields are not allowed in an object");
      var me = St(), Xe;
      if (n("punc", ":"))
        me === null ? p(u()) : (o(), Xe = $t(!1));
      else {
        var Ge = _e(me, Y);
        if (Ge) {
          le.push(Ge);
          continue;
        }
        Xe = new Te({
          start: u(),
          name: me,
          end: u()
        });
      }
      n("operator", "=") && (o(), Xe = new ct({
        start: Y,
        left: Xe,
        operator: "=",
        right: $t(!1),
        logical: !1,
        end: u()
      }));
      let Bt = new Nt({
        start: Y,
        quote: Y.quote,
        key: me instanceof Se ? me : "" + me,
        value: Xe,
        end: u()
      });
      le.push(Si(Bt));
    }
    return o(), new Tt({ properties: le });
  }, "object_or_destructuring_"));
  function ae(P, Y) {
    var Q, le, me, Xe, Ge = [];
    i.input.push_directives_stack(), i.input.add_directive("use strict"), i.token.type == "name" && i.token.value != "extends" && (me = qr(P ===
    an ? Yc : Jc)), P === an && !me && (Y ? P = ts : p()), i.token.value == "extends" && (o(), Xe = $t(!0)), y("{");
    let Bt = i.in_class;
    for (i.in_class = !0; n("punc", ";"); )
      o();
    for (; !n("punc", "}"); )
      for (Q = i.token, le = _e(St(), Q, !0), le || p(), Ge.push(le); n("punc", ";"); )
        o();
    return i.in_class = Bt, i.input.pop_directives_stack(), o(), new P({
      start: Q,
      name: me,
      extends: Xe,
      properties: Ge,
      end: u()
    });
  }
  s(ae, "class_");
  function _e(P, Y, Q) {
    let le = /* @__PURE__ */ s((ei, Sy = hi) => typeof ei == "string" || typeof ei == "number" ? new Sy({
      start: Y,
      name: "" + ei,
      end: u()
    }) : (ei === null && p(), ei), "get_symbol_ast"), me = /* @__PURE__ */ s(() => !n("punc", "(") && !n("punc", ",") && !n("punc", "}") && !n(
    "punc", ";") && !n("operator", "="), "is_not_method_start");
    var Xe = !1, Ge = !1, Bt = !1, fi = !1, Ps = null;
    if (Q && P === "static" && me()) {
      let ei = be();
      if (ei != null)
        return ei;
      Ge = !0, P = St();
    }
    P === "async" && me() && (Xe = !0, P = St()), u().type === "operator" && u().value === "*" && (Bt = !0, P = St()), (P === "get" || P ===
    "set") && me() && (Ps = P, P = St()), u().type === "privatename" && (fi = !0);
    let In = u();
    if (Ps != null)
      if (fi) {
        let ei = Ps === "get" ? $i : on;
        return Si(new ei({
          start: Y,
          static: Ge,
          key: le(P),
          value: wt(),
          end: u()
        }));
      } else {
        let ei = Ps === "get" ? yn : On;
        return P = le(P), Si(new ei({
          start: Y,
          static: Ge,
          key: P,
          quote: P instanceof hi ? In.quote : void 0,
          value: wt(),
          end: u()
        }));
      }
    if (n("punc", "(")) {
      P = le(P);
      let ei = fi ? ki : Kr;
      var Zl = new ei({
        start: Y,
        static: Ge,
        is_generator: Bt,
        async: Xe,
        key: P,
        quote: P instanceof hi ? In.quote : void 0,
        value: wt(Bt, Xe),
        end: u()
      });
      return Si(Zl);
    }
    if (Q) {
      let ei = le(P, vs), Sy = ei instanceof vs ? In.quote : void 0, gI = fi ? Ii : Bi;
      if (n("operator", "="))
        return o(), Si(
          new gI({
            start: Y,
            static: Ge,
            quote: Sy,
            key: ei,
            value: $t(!1),
            end: u()
          })
        );
      if (n("name") || n("privatename") || n("punc", "[") || n("operator", "*") || n("punc", ";") || n("punc", "}"))
        return Si(
          new gI({
            start: Y,
            static: Ge,
            quote: Sy,
            key: ei,
            end: u()
          })
        );
    }
  }
  s(_e, "concise_method_or_getset");
  function be() {
    if (!n("punc", "{"))
      return null;
    let P = i.token, Y = [];
    for (o(); !n("punc", "}"); )
      Y.push(C());
    return o(), new Hr({ start: P, body: Y, end: u() });
  }
  s(be, "class_static_block");
  function Pe() {
    return (n("keyword", "with") || n("name", "assert")) && !_(i.token) ? (o(), xr()) : null;
  }
  s(Pe, "maybe_import_attributes");
  function ze() {
    var P = u(), Y, Q;
    n("name") && (Y = qr(Fu)), n("punc", ",") && o(), Q = ke(!0), (Q || Y) && h("name", "from");
    var le = i.token;
    le.type !== "string" && p(), o();
    let me = Pe();
    return new yi({
      start: P,
      imported_name: Y,
      imported_names: Q,
      module_name: new bt({
        start: le,
        value: le.value,
        quote: le.quote,
        end: le
      }),
      attributes: me,
      end: i.token
    });
  }
  s(ze, "import_statement");
  function nt(P) {
    var Y = i.token;
    return h("name", "import"), h("punc", "."), h("name", "meta"), zr(new ss({
      start: Y,
      end: u()
    }), P);
  }
  s(nt, "import_meta");
  function V(P) {
    function Y(Bt, fi) {
      return new Bt({
        name: St(),
        quote: fi || void 0,
        start: u(),
        end: u()
      });
    }
    s(Y, "make_symbol");
    var Q = P ? Wo : oa, le = P ? Fu : oo, me = i.token, Xe, Ge;
    return P ? Xe = Y(Q, me.quote) : Ge = Y(le, me.quote), n("name", "as") ? (o(), P ? Ge = Y(le) : Xe = Y(Q, i.token.quote)) : P ? Ge = new le(
    Xe) : Xe = new Q(Ge), new Cn({
      start: me,
      foreign_name: Xe,
      name: Ge,
      end: u()
    });
  }
  s(V, "map_name");
  function Ce(P, Y) {
    var Q = P ? Wo : oa, le = P ? Fu : oo, me = i.token, Xe, Ge, Bt = u();
    return P ? Xe = Y : Ge = Y, Xe = Xe || new le({
      start: me,
      name: "*",
      end: Bt
    }), Ge = Ge || new Q({
      start: me,
      name: "*",
      end: Bt
    }), new Cn({
      start: me,
      foreign_name: Ge,
      name: Xe,
      end: Bt
    });
  }
  s(Ce, "map_nameAsterisk");
  function ke(P) {
    var Y;
    if (n("punc", "{")) {
      for (o(), Y = []; !n("punc", "}"); )
        Y.push(V(P)), n("punc", ",") && o();
      o();
    } else if (n("operator", "*")) {
      var Q;
      o(), n("name", "as") && (o(), Q = P ? qr(Fu) : ha(oa)), Y = [Ce(P, Q)];
    }
    return Y;
  }
  s(ke, "map_names");
  function Re() {
    var P = i.token, Y, Q;
    if (n("keyword", "default"))
      Y = !0, o();
    else if (Q = ke(!1))
      if (n("name", "from")) {
        o();
        var le = i.token;
        le.type !== "string" && p(), o();
        let Bt = Pe();
        return new dr({
          start: P,
          is_default: Y,
          exported_names: Q,
          module_name: new bt({
            start: le,
            value: le.value,
            quote: le.quote,
            end: le
          }),
          end: u(),
          attributes: Bt
        });
      } else
        return new dr({
          start: P,
          is_default: Y,
          exported_names: Q,
          end: u()
        });
    var me, Xe, Ge;
    return n("punc", "{") || Y && (n("keyword", "class") || n("keyword", "function")) && gs(a(), "punc") ? (Xe = $t(!1), v()) : (me = C(Y)) instanceof
    cr && Y ? p(me.start) : me instanceof cr || me instanceof tr || me instanceof an ? Ge = me : me instanceof ts || me instanceof jt ? Xe =
    me : me instanceof qe ? Xe = me.body : p(me.start), new dr({
      start: P,
      is_default: Y,
      exported_value: Xe,
      exported_definition: Ge,
      end: u(),
      attributes: null
    });
  }
  s(Re, "export_statement");
  function St() {
    var P = i.token;
    switch (P.type) {
      case "punc":
        if (P.value === "[") {
          o();
          var Y = $t(!1);
          return y("]"), Y;
        } else p(P);
      case "operator":
        if (P.value === "*")
          return o(), null;
        ["delete", "in", "instanceof", "new", "typeof", "void"].includes(P.value) || p(P);
      /* falls through */
      case "name":
      case "privatename":
      case "string":
      case "num":
      case "big_int":
      case "keyword":
      case "atom":
        return o(), P.value;
      default:
        p(P);
    }
  }
  s(St, "as_property_name");
  function Mt() {
    var P = i.token;
    return P.type != "name" && P.type != "privatename" && p(), o(), P.value;
  }
  s(Mt, "as_name");
  function yt(P) {
    var Y = i.token.value;
    return new (Y == "this" ? kr : Y == "super" ? fo : P)({
      name: String(Y),
      start: i.token,
      end: i.token
    });
  }
  s(yt, "_make_symbol");
  function rr(P) {
    var Y = P.name;
    m() && Y == "yield" && c(P.start, "Yield cannot be used as identifier inside generators"), i.input.has_directive("use strict") && (Y == "\
yield" && c(P.start, "Unexpected yield identifier inside strict mode"), P instanceof Lr && (Y == "arguments" || Y == "eval") && c(P.start, "\
Unexpected " + Y + " in strict mode"));
  }
  s(rr, "_verify_symbol");
  function qr(P, Y) {
    if (!n("name"))
      return Y || l("Name expected"), null;
    var Q = yt(P);
    return rr(Q), o(), Q;
  }
  s(qr, "as_symbol");
  function ha(P) {
    if (!n("name")) {
      n("string") || l("Name or string expected");
      var Y = i.token, Q = new P({
        start: Y,
        end: Y,
        name: Y.value,
        quote: Y.quote
      });
      return o(), Q;
    }
    var le = yt(P);
    return rr(le), o(), le;
  }
  s(ha, "as_symbol_or_string");
  function Si(P, Y = P.start) {
    var Q = Y.comments_before;
    let le = r.get(Y);
    for (var me = le ?? Q.length; --me >= 0; ) {
      var Xe = Q[me];
      if (/[@#]__/.test(Xe.value)) {
        if (/[@#]__PURE__/.test(Xe.value)) {
          Qp(P, eh);
          break;
        }
        if (/[@#]__INLINE__/.test(Xe.value)) {
          Qp(P, ey);
          break;
        }
        if (/[@#]__NOINLINE__/.test(Xe.value)) {
          Qp(P, po);
          break;
        }
        if (/[@#]__KEY__/.test(Xe.value)) {
          Qp(P, Qc);
          break;
        }
        if (/[@#]__MANGLE_PROP__/.test(Xe.value)) {
          Qp(P, Zc);
          break;
        }
      }
    }
    return P;
  }
  s(Si, "annotate");
  var zr = /* @__PURE__ */ s(function(P, Y, Q) {
    var le = P.start;
    if (n("punc", ".")) {
      o(), n("privatename") && !i.in_class && l("Private field must be used in an enclosing class");
      let Ge = n("privatename") ? Wi : It;
      return Si(zr(new Ge({
        start: le,
        expression: P,
        optional: !1,
        property: Mt(),
        end: u()
      }), Y, Q));
    }
    if (n("punc", "[")) {
      o();
      var me = $t(!0);
      return y("]"), Si(zr(new fr({
        start: le,
        expression: P,
        optional: !1,
        property: me,
        end: u()
      }), Y, Q));
    }
    if (Y && n("punc", "(")) {
      o();
      var Xe = new Fe({
        start: le,
        expression: P,
        optional: !1,
        args: gf(),
        end: u()
      });
      return Si(Xe), zr(Xe, !0, Q);
    }
    if (n("punc", "?.")) {
      o();
      let Ge;
      if (Y && n("punc", "(")) {
        o();
        let Bt = new Fe({
          start: le,
          optional: !0,
          expression: P,
          args: gf(),
          end: u()
        });
        Si(Bt), Ge = zr(Bt, !0, !0);
      } else if (n("name") || n("privatename")) {
        n("privatename") && !i.in_class && l("Private field must be used in an enclosing class");
        let Bt = n("privatename") ? Wi : It;
        Ge = Si(zr(new Bt({
          start: le,
          expression: P,
          optional: !0,
          property: Mt(),
          end: u()
        }), Y, !0));
      } else if (n("punc", "[")) {
        o();
        let Bt = $t(!0);
        y("]"), Ge = Si(zr(new fr({
          start: le,
          expression: P,
          optional: !0,
          property: Bt,
          end: u()
        }), Y, !0));
      }
      return Ge || p(), Ge instanceof er ? Ge : new er({
        start: le,
        expression: Ge,
        end: u()
      });
    }
    return n("template_head") ? (Q && p(), zr(new pn({
      start: le,
      prefix: P,
      template_string: we(),
      end: u()
    }), Y)) : P;
  }, "subscripts");
  function gf() {
    for (var P = []; !n("punc", ")"); )
      n("expand", "...") ? (o(), P.push(new ft({
        start: u(),
        expression: $t(!1),
        end: u()
      }))) : P.push($t(!1)), n("punc", ")") || y(",");
    return o(), P;
  }
  s(gf, "call_args");
  var Hn = /* @__PURE__ */ s(function(P, Y) {
    var Q = i.token;
    if (Q.type == "name" && Q.value == "await" && d())
      return o(), G();
    if (n("operator") && Zft.has(Q.value)) {
      o(), x();
      var le = _f($e, Q, Hn(P));
      return le.start = Q, le.end = u(), le;
    }
    for (var me = pe(P, Y); n("operator") && Fie.has(i.token.value) && !_(i.token); )
      me instanceof Zt && p(), me = _f(as, i.token, me), me.start = Q, me.end = i.token, o();
    return me;
  }, "maybe_unary");
  function _f(P, Y, Q) {
    var le = Y.value;
    switch (le) {
      case "++":
      case "--":
        Jl(Q) || l("Invalid use of " + le + " operator", Y.line, Y.col, Y.pos);
        break;
      case "delete":
        Q instanceof Te && i.input.has_directive("use strict") && l("Calling delete on expression not allowed in strict mode", Q.start.line,
        Q.start.col, Q.start.pos);
        break;
    }
    return new P({ operator: le, expression: Q });
  }
  s(_f, "make_unary");
  var bf = /* @__PURE__ */ s(function(P, Y, Q) {
    var le = n("operator") ? i.token.value : null;
    le == "in" && Q && (le = null), le == "**" && P instanceof $e && !gs(P.start, "punc", "(") && P.operator !== "--" && P.operator !== "++" &&
    p(P.start);
    var me = le != null ? _s[le] : null;
    if (me != null && (me > Y || le === "**" && Y === me)) {
      o();
      var Xe = _h(Q, me, !0);
      return bf(new ce({
        start: P.start,
        left: P,
        operator: le,
        right: Xe,
        end: Xe.end
      }), Y, Q);
    }
    return P;
  }, "expr_op");
  function _h(P, Y, Q, le) {
    if (!P && Y < _s.in && n("privatename")) {
      i.in_class || l("Private field must be used in an enclosing class");
      let me = i.token, Xe = new Fl({
        start: me,
        name: me.value,
        end: me
      });
      o(), h("operator", "in");
      let Ge = new Un({
        start: me,
        key: Xe,
        value: _h(P, _s.in, !0),
        end: u()
      });
      return bf(Ge, 0, P);
    } else
      return bf(Hn(Q, le), Y, P);
  }
  s(_h, "expr_ops");
  var vy = /* @__PURE__ */ s(function(P) {
    var Y = i.token, Q = _h(P, 0, !0, !0);
    if (n("operator", "?")) {
      o();
      var le = $t(!1);
      return y(":"), new it({
        start: Y,
        condition: Q,
        consequent: le,
        alternative: $t(!1, P),
        end: u()
      });
    }
    return Q;
  }, "maybe_conditional");
  function Jl(P) {
    return P instanceof je || P instanceof Te;
  }
  s(Jl, "is_assignable");
  function Cs(P) {
    if (P instanceof Tt)
      P = new Ut({
        start: P.start,
        names: P.properties.map(Cs),
        is_array: !1,
        end: P.end
      });
    else if (P instanceof pt) {
      for (var Y = [], Q = 0; Q < P.elements.length; Q++)
        P.elements[Q] instanceof ft && (Q + 1 !== P.elements.length && c(P.elements[Q].start, "Spread must the be last element in destructur\
ing array"), P.elements[Q].expression = Cs(P.elements[Q].expression)), Y.push(Cs(P.elements[Q]));
      P = new Ut({
        start: P.start,
        names: Y,
        is_array: !0,
        end: P.end
      });
    } else P instanceof gr ? P.value = Cs(P.value) : P instanceof ct && (P = new sn({
      start: P.start,
      left: P.left,
      operator: "=",
      right: P.right,
      end: P.end
    }));
    return P;
  }
  s(Cs, "to_destructuring");
  var Ql = /* @__PURE__ */ s(function(P) {
    x();
    var Y = i.token;
    if (Y.type == "name" && Y.value == "yield") {
      if (m())
        return o(), ie();
      i.input.has_directive("use strict") && c(i.token, "Unexpected yield identifier inside strict mode");
    }
    var Q = vy(P), le = i.token.value;
    if (n("operator") && ept.has(le)) {
      if (Jl(Q) || (Q = Cs(Q)) instanceof Ut)
        return o(), new ct({
          start: Y,
          left: Q,
          operator: le,
          right: Ql(P),
          logical: tpt.has(le),
          end: u()
        });
      l("Invalid assignment");
    }
    return Q;
  }, "maybe_assign"), bh = /* @__PURE__ */ s(function(P, Y) {
    if (Y.length === 1)
      return Y[0];
    if (Y.length > 1)
      return new Qe({ start: P, expressions: Y, end: a() });
    l("Invalid parenthesized expression");
  }, "to_expr_or_sequence"), $t = /* @__PURE__ */ s(function(P, Y) {
    for (var Q = i.token, le = []; le.push(Ql(Y)), !(!P || !n("punc", ",")); )
      o(), P = !0;
    return bh(Q, le);
  }, "expression");
  function iu(P) {
    ++i.in_loop;
    var Y = P();
    return --i.in_loop, Y;
  }
  return s(iu, "in_loop"), t.expression ? $t(!0) : (/* @__PURE__ */ s(function() {
    var Y = i.token, Q = [];
    for (i.input.push_directives_stack(), t.module && i.input.add_directive("use strict"); !n("eof"); )
      Q.push(C());
    i.input.pop_directives_stack();
    var le = u(), me = t.toplevel;
    return me ? (me.body = me.body.concat(Q), me.end = le) : me = new Kt({ start: Y, body: Q, end: le }), $m = /* @__PURE__ */ new Map(), me;
  }, "parse_toplevel"))();
}
var zS, $m, GS, WS, Xm, Go, gk, Uft, jft, Iie, Rie, Vft, Kft, Hft, zft, wie, Gft, dk, Wft, $ft, Xft, $S, Lie, Qm, yk, Zft, Fie, ept, tpt, _s,
rpt, Rl = at(() => {
  "use strict";
  Gi();
  Di();
  zS = "", $m = /* @__PURE__ */ new Map(), GS = "break case catch class const continue debugger default delete do else export extends finall\
y for function if in instanceof let new return switch throw try typeof var void while with", WS = "false null true", Xm = "enum import super\
 this " + WS + " " + GS, Go = "implements interface package private protected public static " + Xm, gk = "return new delete throw else case \
yield await";
  GS = qt(GS);
  Xm = qt(Xm);
  gk = qt(gk);
  WS = qt(WS);
  Go = qt(Go);
  Uft = qt(Wc("+-*&%=<>!?|~^")), jft = /[0-9a-f]/i, Iie = /^0x[0-9a-f]+$/i, Rie = /^0[0-7]+$/, Vft = /^0o[0-7]+$/i, Kft = /^0b[01]+$/i, Hft =
  /^\d*\.?\d*(?:e[+-]?\d*(?:\d\.?|\.?\d)\d*)?$/i, zft = /^(0[xob])?[0-9a-f]+n$/i, wie = qt([
    "in",
    "instanceof",
    "typeof",
    "new",
    "void",
    "delete",
    "++",
    "--",
    "+",
    "-",
    "!",
    "~",
    "&",
    "|",
    "^",
    "*",
    "**",
    "/",
    "%",
    ">>",
    "<<",
    ">>>",
    "<",
    ">",
    "<=",
    ">=",
    "==",
    "===",
    "!=",
    "!==",
    "?",
    "=",
    "+=",
    "-=",
    "||=",
    "&&=",
    "??=",
    "/=",
    "*=",
    "**=",
    "%=",
    ">>=",
    "<<=",
    ">>>=",
    "|=",
    "^=",
    "&=",
    "&&",
    "??",
    "||"
  ]), Gft = qt(Wc(` \xA0
\r	\f\v\u200B\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF`)), dk = qt(Wc(`
\r\u2028\u2029`)), Wft = qt(Wc(";]),:")), $ft = qt(Wc("[{(,;:")), Xft = qt(Wc("[]{}(),;:")), $S = {
    ID_Start: /[$A-Z_a-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
    ID_Continue: /(?:[$0-9A-Z_a-z\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF])+/
  };
  s(Ym, "get_full_char");
  s(Nie, "get_full_char_code");
  s(Yft, "get_full_char_length");
  s(Jft, "from_char_code");
  s(XS, "is_surrogate_pair_head");
  s(_k, "is_surrogate_pair_tail");
  s(Oie, "is_digit");
  s(mk, "is_identifier_start");
  s(Jm, "is_identifier_char");
  Lie = /^[a-z_$][a-z0-9_$]*$/i;
  s(Xc, "is_basic_identifier_string");
  s(bk, "is_identifier_string");
  s(kie, "parse_js_number");
  Qm = class extends Error {
    static {
      s(this, "JS_Parse_Error");
    }
    constructor(t, r, i, n, a) {
      super(), this.name = "SyntaxError", this.message = t, this.filename = r, this.line = i, this.col = n, this.pos = a;
    }
  };
  s(Zm, "js_error");
  s(gs, "is_token");
  yk = {};
  s(Qft, "tokenizer");
  Zft = qt([
    "typeof",
    "void",
    "delete",
    "--",
    "++",
    "!",
    "~",
    "-",
    "+"
  ]), Fie = qt(["--", "++"]), ept = qt(["=", "+=", "-=", "??=", "&&=", "||=", "/=", "*=", "**=", "%=", ">>=", "<<=", ">>>=", "|=", "^=", "&="]),
  tpt = qt(["??=", "&&=", "||="]), _s = function(e, t) {
    for (var r = 0; r < e.length; ++r)
      for (let i of e[r])
        t[i] = r + 1;
    return t;
  }(
    [
      ["||"],
      ["??"],
      ["&&"],
      ["|"],
      ["^"],
      ["&"],
      ["==", "===", "!=", "!=="],
      ["<", ">", "<=", ">=", "in", "instanceof"],
      [">>", "<<", ">>>"],
      ["+", "-"],
      ["*", "/", "%"],
      ["**"]
    ],
    {}
  ), rpt = qt(["atom", "num", "big_int", "string", "regexp", "name"]);
  s($o, "parse");
});

// ../node_modules/terser/lib/ast.js
function ge(e, t, r, i, n = Se) {
  t ? t = t.split(/\s+/) : t = [];
  var a = t;
  n && n.PROPS && (t = t.concat(n.PROPS));
  let o = n && Object.create(n.prototype);
  if (o && (r.prototype = o, r.BASE = n), n && n.SUBCLASSES.push(r), r.prototype.CTOR = r, r.prototype.constructor = r, r.PROPS = t || null,
  r.SELF_PROPS = a, r.SUBCLASSES = [], e && (r.prototype.TYPE = r.TYPE = e), i) for (let u in i) Pi(i, u) && (u[0] === "$" ? r[u.substr(1)] =
  i[u] : r.prototype[u] = i[u]);
  return r.DEFMETHOD = function(u, l) {
    this.prototype[u] = l;
  }, r;
}
function Ml(e, t) {
  let r = e.body;
  for (var i = 0, n = r.length; i < n; i++)
    r[i]._walk(t);
}
function vk(e) {
  var t = this._clone(e);
  return this.block_scope && (t.block_scope = this.block_scope.clone()), t;
}
function _r(e, t, r = [e]) {
  let i = r.push.bind(r);
  for (; r.length; ) {
    let n = r.pop(), a = t(n, r);
    if (a) {
      if (a === Yi) return !0;
      continue;
    }
    n._children_backwards(i);
  }
  return !1;
}
function ih(e, t, r) {
  let i = [e], n = i.push.bind(i), a = r ? r.slice() : [], o = [], u, l = {
    parent: /* @__PURE__ */ s((c = 0) => c === -1 ? u : r && c >= a.length ? (c -= a.length, r[r.length - (c + 1)]) : a[a.length - (1 + c)],
    "parent")
  };
  for (; i.length; ) {
    for (u = i.pop(); o.length && i.length == o[o.length - 1]; )
      a.pop(), o.pop();
    let c = t(u, l);
    if (c) {
      if (c === Yi) return !0;
      continue;
    }
    let p = i.length;
    u._children_backwards(n), i.length > p && (a.push(u), o.push(p - 1));
  }
  return !1;
}
var YS, JS, Mie, Bie, qie, Uie, Mu, Se, Br, is, wi, qe, Tr, ot, Rt, Bl, wr, ns, th, Pn, qn, yr, Or, ka, di, Ye, Kt, ft, Ue, rs, jt, Zt, tr, Ut,
pn, jr, Bn, ql, cn, mr, Bu, Kn, hn, ua, Mi, Oi, Ft, Vr, Ts, zs, dn, mi, Nl, mn, uo, cr, Fr, Dn, wn, Lt, Cn, yi, ss, dr, Fe, gi, Qe, je, It, Wi,
fr, er, Ht, $e, as, ce, it, ct, sn, pt, Tt, gr, Nt, on, $i, On, yn, Kr, ki, ht, Bi, Ii, Un, an, Hr, ts, gt, lo, Lr, bs, ho, la, co, Nr, jn, hi,
vs, kn, Yc, Jc, Vn, Fu, Wo, Ll, Te, oo, oa, Zp, Fl, kr, fo, Ct, bt, We, un, $r, Xo, Xi, Ul, pr, xn, mo, rh, Ss, ln, Yi, Mr, qi, eh, ey, po, Qc,
Zc, Di = at(() => {
  Gi();
  Rl();
  s(ge, "DEFNODE");
  YS = /* @__PURE__ */ s((e, t) => !!(e.flags & t), "has_tok_flag"), JS = /* @__PURE__ */ s((e, t, r) => {
    r ? e.flags |= t : e.flags &= ~t;
  }, "set_tok_flag"), Mie = 1, Bie = 2, qie = 4, Uie = 8, Mu = class {
    static {
      s(this, "AST_Token");
    }
    constructor(t, r, i, n, a, o, u, l, c) {
      this.flags = o ? 1 : 0, this.type = t, this.value = r, this.line = i, this.col = n, this.pos = a, this.comments_before = u, this.comments_after =
      l, this.file = c, Object.seal(this);
    }
    // Return a string summary of the token for node.js console.log
    [Symbol.for("nodejs.util.inspect.custom")](t, r) {
      let i = /* @__PURE__ */ s((o) => r.stylize(o, "special"), "special"), n = typeof this.value == "string" && this.value.includes("`") ? "\
'" : "`", a = `${n}${this.value}${n}`;
      return `${i("[AST_Token")} ${a} at ${this.line}:${this.col}${i("]")}`;
    }
    get nlb() {
      return YS(this, Mie);
    }
    set nlb(t) {
      JS(this, Mie, t);
    }
    get quote() {
      return YS(this, qie) ? YS(this, Bie) ? "'" : '"' : "";
    }
    set quote(t) {
      JS(this, Bie, t === "'"), JS(this, qie, !!t);
    }
    get template_end() {
      return YS(this, Uie);
    }
    set template_end(t) {
      JS(this, Uie, t);
    }
  }, Se = ge("Node", "start end", /* @__PURE__ */ s(function(t) {
    t && (this.start = t.start, this.end = t.end), this.flags = 0;
  }, "AST_Node"), {
    _clone: /* @__PURE__ */ s(function(e) {
      if (e) {
        var t = this.clone();
        return t.transform(new qi(function(r) {
          if (r !== t)
            return r.clone(!0);
        }));
      }
      return new this.CTOR(this);
    }, "_clone"),
    clone: /* @__PURE__ */ s(function(e) {
      return this._clone(e);
    }, "clone"),
    $documentation: "Base class of all AST nodes",
    $propdoc: {
      start: "[AST_Token] The first token of this node",
      end: "[AST_Token] The last token of this node"
    },
    _walk: /* @__PURE__ */ s(function(e) {
      return e._visit(this);
    }, "_walk"),
    walk: /* @__PURE__ */ s(function(e) {
      return this._walk(e);
    }, "walk"),
    _children_backwards: /* @__PURE__ */ s(() => {
    }, "_children_backwards")
  }, null), Br = ge("Statement", null, /* @__PURE__ */ s(function(t) {
    t && (this.start = t.start, this.end = t.end), this.flags = 0;
  }, "AST_Statement"), {
    $documentation: "Base class of all statements"
  }), is = ge("Debugger", null, /* @__PURE__ */ s(function(t) {
    t && (this.start = t.start, this.end = t.end), this.flags = 0;
  }, "AST_Debugger"), {
    $documentation: "Represents a debugger statement"
  }, Br), wi = ge("Directive", "value quote", /* @__PURE__ */ s(function(t) {
    t && (this.value = t.value, this.quote = t.quote, this.start = t.start, this.end = t.end), this.flags = 0;
  }, "AST_Directive"), {
    $documentation: 'Represents a directive, like "use strict";',
    $propdoc: {
      value: "[string] The value of this directive as a plain string (it's not an AST_String!)",
      quote: "[string] the original quote character"
    }
  }, Br), qe = ge("SimpleStatement", "body", /* @__PURE__ */ s(function(t) {
    t && (this.body = t.body, this.start = t.start, this.end = t.end), this.flags = 0;
  }, "AST_SimpleStatement"), {
    $documentation: "A statement consisting of an expression, i.e. a = 1 + 2",
    $propdoc: {
      body: "[AST_Node] an expression node (should not be instanceof AST_Statement)"
    },
    _walk: /* @__PURE__ */ s(function(e) {
      return e._visit(this, function() {
        this.body._walk(e);
      });
    }, "_walk"),
    _children_backwards(e) {
      e(this.body);
    }
  }, Br);
  s(Ml, "walk_body");
  s(vk, "clone_block_scope");
  Tr = ge("Block", "body block_scope", /* @__PURE__ */ s(function(t) {
    t && (this.body = t.body, this.block_scope = t.block_scope, this.start = t.start, this.end = t.end), this.flags = 0;
  }, "AST_Block"), {
    $documentation: "A body of statements (usually braced)",
    $propdoc: {
      body: "[AST_Statement*] an array of statements",
      block_scope: "[AST_Scope] the block scope"
    },
    _walk: /* @__PURE__ */ s(function(e) {
      return e._visit(this, function() {
        Ml(this, e);
      });
    }, "_walk"),
    _children_backwards(e) {
      let t = this.body.length;
      for (; t--; ) e(this.body[t]);
    },
    clone: vk
  }, Br), ot = ge("BlockStatement", null, /* @__PURE__ */ s(function(t) {
    t && (this.body = t.body, this.block_scope = t.block_scope, this.start = t.start, this.end = t.end), this.flags = 0;
  }, "AST_BlockStatement"), {
    $documentation: "A block statement"
  }, Tr), Rt = ge("EmptyStatement", null, /* @__PURE__ */ s(function(t) {
    t && (this.start = t.start, this.end = t.end), this.flags = 0;
  }, "AST_EmptyStatement"), {
    $documentation: "The empty statement (empty block or simply a semicolon)"
  }, Br), Bl = ge("StatementWithBody", "body", /* @__PURE__ */ s(function(t) {
    t && (this.body = t.body, this.start = t.start, this.end = t.end), this.flags = 0;
  }, "AST_StatementWithBody"), {
    $documentation: "Base class for all statements that contain one nested body: `For`, `ForIn`, `Do`, `While`, `With`",
    $propdoc: {
      body: "[AST_Statement] the body; this should always be present, even if it's an AST_EmptyStatement"
    }
  }, Br), wr = ge("LabeledStatement", "label", /* @__PURE__ */ s(function(t) {
    t && (this.label = t.label, this.body = t.body, this.start = t.start, this.end = t.end), this.flags = 0;
  }, "AST_LabeledStatement"), {
    $documentation: "Statement with a label",
    $propdoc: {
      label: "[AST_Label] a label definition"
    },
    _walk: /* @__PURE__ */ s(function(e) {
      return e._visit(this, function() {
        this.label._walk(e), this.body._walk(e);
      });
    }, "_walk"),
    _children_backwards(e) {
      e(this.body), e(this.label);
    },
    clone: /* @__PURE__ */ s(function(e) {
      var t = this._clone(e);
      if (e) {
        var r = t.label, i = this.label;
        t.walk(new Mr(function(n) {
          n instanceof Kn && n.label && n.label.thedef === i && (n.label.thedef = r, r.references.push(n));
        }));
      }
      return t;
    }, "clone")
  }, Bl), ns = ge(
    "IterationStatement",
    "block_scope",
    /* @__PURE__ */ s(function(t) {
      t && (this.block_scope = t.block_scope, this.body = t.body, this.start = t.start, this.end = t.end), this.flags = 0;
    }, "AST_IterationStatement"),
    {
      $documentation: "Internal class.  All loops inherit from it.",
      $propdoc: {
        block_scope: "[AST_Scope] the block scope for this iteration statement."
      },
      clone: vk
    },
    Bl
  ), th = ge("DWLoop", "condition", /* @__PURE__ */ s(function(t) {
    t && (this.condition = t.condition, this.block_scope = t.block_scope, this.body = t.body, this.start = t.start, this.end = t.end), this.
    flags = 0;
  }, "AST_DWLoop"), {
    $documentation: "Base class for do/while statements",
    $propdoc: {
      condition: "[AST_Node] the loop condition.  Should not be instanceof AST_Statement"
    }
  }, ns), Pn = ge("Do", null, /* @__PURE__ */ s(function(t) {
    t && (this.condition = t.condition, this.block_scope = t.block_scope, this.body = t.body, this.start = t.start, this.end = t.end), this.
    flags = 0;
  }, "AST_Do"), {
    $documentation: "A `do` statement",
    _walk: /* @__PURE__ */ s(function(e) {
      return e._visit(this, function() {
        this.body._walk(e), this.condition._walk(e);
      });
    }, "_walk"),
    _children_backwards(e) {
      e(this.condition), e(this.body);
    }
  }, th), qn = ge("While", null, /* @__PURE__ */ s(function(t) {
    t && (this.condition = t.condition, this.block_scope = t.block_scope, this.body = t.body, this.start = t.start, this.end = t.end), this.
    flags = 0;
  }, "AST_While"), {
    $documentation: "A `while` statement",
    _walk: /* @__PURE__ */ s(function(e) {
      return e._visit(this, function() {
        this.condition._walk(e), this.body._walk(e);
      });
    }, "_walk"),
    _children_backwards(e) {
      e(this.body), e(this.condition);
    }
  }, th), yr = ge("For", "init condition step", /* @__PURE__ */ s(function(t) {
    t && (this.init = t.init, this.condition = t.condition, this.step = t.step, this.block_scope = t.block_scope, this.body = t.body, this.start =
    t.start, this.end = t.end), this.flags = 0;
  }, "AST_For"), {
    $documentation: "A `for` statement",
    $propdoc: {
      init: "[AST_Node?] the `for` initialization code, or null if empty",
      condition: "[AST_Node?] the `for` termination clause, or null if empty",
      step: "[AST_Node?] the `for` update clause, or null if empty"
    },
    _walk: /* @__PURE__ */ s(function(e) {
      return e._visit(this, function() {
        this.init && this.init._walk(e), this.condition && this.condition._walk(e), this.step && this.step._walk(e), this.body._walk(e);
      });
    }, "_walk"),
    _children_backwards(e) {
      e(this.body), this.step && e(this.step), this.condition && e(this.condition), this.init && e(this.init);
    }
  }, ns), Or = ge("ForIn", "init object", /* @__PURE__ */ s(function(t) {
    t && (this.init = t.init, this.object = t.object, this.block_scope = t.block_scope, this.body = t.body, this.start = t.start, this.end =
    t.end), this.flags = 0;
  }, "AST_ForIn"), {
    $documentation: "A `for ... in` statement",
    $propdoc: {
      init: "[AST_Node] the `for/in` initialization code",
      object: "[AST_Node] the object that we're looping through"
    },
    _walk: /* @__PURE__ */ s(function(e) {
      return e._visit(this, function() {
        this.init._walk(e), this.object._walk(e), this.body._walk(e);
      });
    }, "_walk"),
    _children_backwards(e) {
      e(this.body), this.object && e(this.object), this.init && e(this.init);
    }
  }, ns), ka = ge("ForOf", "await", /* @__PURE__ */ s(function(t) {
    t && (this.await = t.await, this.init = t.init, this.object = t.object, this.block_scope = t.block_scope, this.body = t.body, this.start =
    t.start, this.end = t.end), this.flags = 0;
  }, "AST_ForOf"), {
    $documentation: "A `for ... of` statement"
  }, Or), di = ge("With", "expression", /* @__PURE__ */ s(function(t) {
    t && (this.expression = t.expression, this.body = t.body, this.start = t.start, this.end = t.end), this.flags = 0;
  }, "AST_With"), {
    $documentation: "A `with` statement",
    $propdoc: {
      expression: "[AST_Node] the `with` expression"
    },
    _walk: /* @__PURE__ */ s(function(e) {
      return e._visit(this, function() {
        this.expression._walk(e), this.body._walk(e);
      });
    }, "_walk"),
    _children_backwards(e) {
      e(this.body), e(this.expression);
    }
  }, Bl), Ye = ge(
    "Scope",
    "variables uses_with uses_eval parent_scope enclosed cname",
    /* @__PURE__ */ s(function(t) {
      t && (this.variables = t.variables, this.uses_with = t.uses_with, this.uses_eval = t.uses_eval, this.parent_scope = t.parent_scope, this.
      enclosed = t.enclosed, this.cname = t.cname, this.body = t.body, this.block_scope = t.block_scope, this.start = t.start, this.end = t.
      end), this.flags = 0;
    }, "AST_Scope"),
    {
      $documentation: "Base class for all statements introducing a lexical scope",
      $propdoc: {
        variables: "[Map/S] a map of name -> SymbolDef for all variables/functions defined in this scope",
        uses_with: "[boolean/S] tells whether this scope uses the `with` statement",
        uses_eval: "[boolean/S] tells whether this scope contains a direct call to the global `eval`",
        parent_scope: "[AST_Scope?/S] link to the parent scope",
        enclosed: "[SymbolDef*/S] a list of all symbol definitions that are accessed from this scope or any subscopes",
        cname: "[integer/S] current index for mangling variables (used internally by the mangler)"
      },
      get_defun_scope: /* @__PURE__ */ s(function() {
        for (var e = this; e.is_block_scope(); )
          e = e.parent_scope;
        return e;
      }, "get_defun_scope"),
      clone: /* @__PURE__ */ s(function(e, t) {
        var r = this._clone(e);
        return e && this.variables && t && !this._block_scope ? r.figure_out_scope({}, {
          toplevel: t,
          parent_scope: this.parent_scope
        }) : (this.variables && (r.variables = new Map(this.variables)), this.enclosed && (r.enclosed = this.enclosed.slice()), this._block_scope &&
        (r._block_scope = this._block_scope)), r;
      }, "clone"),
      pinned: /* @__PURE__ */ s(function() {
        return this.uses_eval || this.uses_with;
      }, "pinned")
    },
    Tr
  ), Kt = ge("Toplevel", "globals", /* @__PURE__ */ s(function(t) {
    t && (this.globals = t.globals, this.variables = t.variables, this.uses_with = t.uses_with, this.uses_eval = t.uses_eval, this.parent_scope =
    t.parent_scope, this.enclosed = t.enclosed, this.cname = t.cname, this.body = t.body, this.block_scope = t.block_scope, this.start = t.start,
    this.end = t.end), this.flags = 0;
  }, "AST_Toplevel"), {
    $documentation: "The toplevel scope",
    $propdoc: {
      globals: "[Map/S] a map of name -> SymbolDef for all undeclared names"
    },
    wrap_commonjs: /* @__PURE__ */ s(function(e) {
      var t = this.body, r = "(function(exports){'$ORIG';})(typeof " + e + "=='undefined'?(" + e + "={}):" + e + ");";
      return r = $o(r), r = r.transform(new qi(function(i) {
        if (i instanceof wi && i.value == "$ORIG")
          return sr.splice(t);
      })), r;
    }, "wrap_commonjs"),
    wrap_enclose: /* @__PURE__ */ s(function(e) {
      typeof e != "string" && (e = "");
      var t = e.indexOf(":");
      t < 0 && (t = e.length);
      var r = this.body;
      return $o([
        "(function(",
        e.slice(0, t),
        '){"$ORIG"})(',
        e.slice(t + 1),
        ")"
      ].join("")).transform(new qi(function(i) {
        if (i instanceof wi && i.value == "$ORIG")
          return sr.splice(r);
      }));
    }, "wrap_enclose")
  }, Ye), ft = ge("Expansion", "expression", /* @__PURE__ */ s(function(t) {
    t && (this.expression = t.expression, this.start = t.start, this.end = t.end), this.flags = 0;
  }, "AST_Expansion"), {
    $documentation: "An expandible argument, such as ...rest, a splat, such as [1,2,...all], or an expansion in a variable declaration, such\
 as var [first, ...rest] = list",
    $propdoc: {
      expression: "[AST_Node] the thing to be expanded"
    },
    _walk: /* @__PURE__ */ s(function(e) {
      return e._visit(this, function() {
        this.expression.walk(e);
      });
    }, "_walk"),
    _children_backwards(e) {
      e(this.expression);
    }
  }), Ue = ge(
    "Lambda",
    "name argnames uses_arguments is_generator async",
    /* @__PURE__ */ s(function(t) {
      t && (this.name = t.name, this.argnames = t.argnames, this.uses_arguments = t.uses_arguments, this.is_generator = t.is_generator, this.
      async = t.async, this.variables = t.variables, this.uses_with = t.uses_with, this.uses_eval = t.uses_eval, this.parent_scope = t.parent_scope,
      this.enclosed = t.enclosed, this.cname = t.cname, this.body = t.body, this.block_scope = t.block_scope, this.start = t.start, this.end =
      t.end), this.flags = 0;
    }, "AST_Lambda"),
    {
      $documentation: "Base class for functions",
      $propdoc: {
        name: "[AST_SymbolDeclaration?] the name of this function",
        argnames: "[AST_SymbolFunarg|AST_Destructuring|AST_Expansion|AST_DefaultAssign*] array of function arguments, destructurings, or exp\
anding arguments",
        uses_arguments: "[boolean/S] tells whether this function accesses the arguments array",
        is_generator: "[boolean] is this a generator method",
        async: "[boolean] is this method async"
      },
      args_as_names: /* @__PURE__ */ s(function() {
        for (var e = [], t = 0; t < this.argnames.length; t++)
          this.argnames[t] instanceof Ut ? e.push(...this.argnames[t].all_symbols()) : e.push(this.argnames[t]);
        return e;
      }, "args_as_names"),
      _walk: /* @__PURE__ */ s(function(e) {
        return e._visit(this, function() {
          this.name && this.name._walk(e);
          for (var t = this.argnames, r = 0, i = t.length; r < i; r++)
            t[r]._walk(e);
          Ml(this, e);
        });
      }, "_walk"),
      _children_backwards(e) {
        let t = this.body.length;
        for (; t--; ) e(this.body[t]);
        for (t = this.argnames.length; t--; ) e(this.argnames[t]);
        this.name && e(this.name);
      },
      is_braceless() {
        return this.body[0] instanceof mr && this.body[0].value;
      },
      // Default args and expansion don't count, so .argnames.length doesn't cut it
      length_property() {
        let e = 0;
        for (let t of this.argnames)
          (t instanceof Nr || t instanceof Ut) && e++;
        return e;
      }
    },
    Ye
  ), rs = ge("Accessor", null, /* @__PURE__ */ s(function(t) {
    t && (this.name = t.name, this.argnames = t.argnames, this.uses_arguments = t.uses_arguments, this.is_generator = t.is_generator, this.async =
    t.async, this.variables = t.variables, this.uses_with = t.uses_with, this.uses_eval = t.uses_eval, this.parent_scope = t.parent_scope, this.
    enclosed = t.enclosed, this.cname = t.cname, this.body = t.body, this.block_scope = t.block_scope, this.start = t.start, this.end = t.end),
    this.flags = 0;
  }, "AST_Accessor"), {
    $documentation: "A setter/getter function.  The `name` property is always null."
  }, Ue), jt = ge("Function", null, /* @__PURE__ */ s(function(t) {
    t && (this.name = t.name, this.argnames = t.argnames, this.uses_arguments = t.uses_arguments, this.is_generator = t.is_generator, this.async =
    t.async, this.variables = t.variables, this.uses_with = t.uses_with, this.uses_eval = t.uses_eval, this.parent_scope = t.parent_scope, this.
    enclosed = t.enclosed, this.cname = t.cname, this.body = t.body, this.block_scope = t.block_scope, this.start = t.start, this.end = t.end),
    this.flags = 0;
  }, "AST_Function"), {
    $documentation: "A function expression"
  }, Ue), Zt = ge("Arrow", null, /* @__PURE__ */ s(function(t) {
    t && (this.name = t.name, this.argnames = t.argnames, this.uses_arguments = t.uses_arguments, this.is_generator = t.is_generator, this.async =
    t.async, this.variables = t.variables, this.uses_with = t.uses_with, this.uses_eval = t.uses_eval, this.parent_scope = t.parent_scope, this.
    enclosed = t.enclosed, this.cname = t.cname, this.body = t.body, this.block_scope = t.block_scope, this.start = t.start, this.end = t.end),
    this.flags = 0;
  }, "AST_Arrow"), {
    $documentation: "An ES6 Arrow function ((a) => b)"
  }, Ue), tr = ge("Defun", null, /* @__PURE__ */ s(function(t) {
    t && (this.name = t.name, this.argnames = t.argnames, this.uses_arguments = t.uses_arguments, this.is_generator = t.is_generator, this.async =
    t.async, this.variables = t.variables, this.uses_with = t.uses_with, this.uses_eval = t.uses_eval, this.parent_scope = t.parent_scope, this.
    enclosed = t.enclosed, this.cname = t.cname, this.body = t.body, this.block_scope = t.block_scope, this.start = t.start, this.end = t.end),
    this.flags = 0;
  }, "AST_Defun"), {
    $documentation: "A function definition"
  }, Ue), Ut = ge("Destructuring", "names is_array", /* @__PURE__ */ s(function(t) {
    t && (this.names = t.names, this.is_array = t.is_array, this.start = t.start, this.end = t.end), this.flags = 0;
  }, "AST_Destructuring"), {
    $documentation: "A destructuring of several names. Used in destructuring assignment and with destructuring function argument names",
    $propdoc: {
      names: "[AST_Node*] Array of properties or elements",
      is_array: "[Boolean] Whether the destructuring represents an object or array"
    },
    _walk: /* @__PURE__ */ s(function(e) {
      return e._visit(this, function() {
        this.names.forEach(function(t) {
          t._walk(e);
        });
      });
    }, "_walk"),
    _children_backwards(e) {
      let t = this.names.length;
      for (; t--; ) e(this.names[t]);
    },
    all_symbols: /* @__PURE__ */ s(function() {
      var e = [];
      return _r(this, (t) => {
        if (t instanceof Lr && e.push(t), t instanceof Ue)
          return !0;
      }), e;
    }, "all_symbols")
  }), pn = ge(
    "PrefixedTemplateString",
    "template_string prefix",
    /* @__PURE__ */ s(function(t) {
      t && (this.template_string = t.template_string, this.prefix = t.prefix, this.start = t.start, this.end = t.end), this.flags = 0;
    }, "AST_PrefixedTemplateString"),
    {
      $documentation: "A templatestring with a prefix, such as String.raw`foobarbaz`",
      $propdoc: {
        template_string: "[AST_TemplateString] The template string",
        prefix: "[AST_Node] The prefix, which will get called."
      },
      _walk: /* @__PURE__ */ s(function(e) {
        return e._visit(this, function() {
          this.prefix._walk(e), this.template_string._walk(e);
        });
      }, "_walk"),
      _children_backwards(e) {
        e(this.template_string), e(this.prefix);
      }
    }
  ), jr = ge("TemplateString", "segments", /* @__PURE__ */ s(function(t) {
    t && (this.segments = t.segments, this.start = t.start, this.end = t.end), this.flags = 0;
  }, "AST_TemplateString"), {
    $documentation: "A template string literal",
    $propdoc: {
      segments: "[AST_Node*] One or more segments, starting with AST_TemplateSegment. AST_Node may follow AST_TemplateSegment, but each AST_\
Node must be followed by AST_TemplateSegment."
    },
    _walk: /* @__PURE__ */ s(function(e) {
      return e._visit(this, function() {
        this.segments.forEach(function(t) {
          t._walk(e);
        });
      });
    }, "_walk"),
    _children_backwards(e) {
      let t = this.segments.length;
      for (; t--; ) e(this.segments[t]);
    }
  }), Bn = ge("TemplateSegment", "value raw", /* @__PURE__ */ s(function(t) {
    t && (this.value = t.value, this.raw = t.raw, this.start = t.start, this.end = t.end), this.flags = 0;
  }, "AST_TemplateSegment"), {
    $documentation: "A segment of a template string literal",
    $propdoc: {
      value: "Content of the segment",
      raw: "Raw source of the segment"
    }
  }), ql = ge("Jump", null, /* @__PURE__ */ s(function(t) {
    t && (this.start = t.start, this.end = t.end), this.flags = 0;
  }, "AST_Jump"), {
    $documentation: "Base class for \u201Cjumps\u201D (for now that's `return`, `throw`, `break` and `continue`)"
  }, Br), cn = ge("Exit", "value", /* @__PURE__ */ s(function(t) {
    t && (this.value = t.value, this.start = t.start, this.end = t.end), this.flags = 0;
  }, "AST_Exit"), {
    $documentation: "Base class for \u201Cexits\u201D (`return` and `throw`)",
    $propdoc: {
      value: "[AST_Node?] the value returned or thrown by this statement; could be null for AST_Return"
    },
    _walk: /* @__PURE__ */ s(function(e) {
      return e._visit(this, this.value && function() {
        this.value._walk(e);
      });
    }, "_walk"),
    _children_backwards(e) {
      this.value && e(this.value);
    }
  }, ql), mr = ge("Return", null, /* @__PURE__ */ s(function(t) {
    t && (this.value = t.value, this.start = t.start, this.end = t.end), this.flags = 0;
  }, "AST_Return"), {
    $documentation: "A `return` statement"
  }, cn), Bu = ge("Throw", null, /* @__PURE__ */ s(function(t) {
    t && (this.value = t.value, this.start = t.start, this.end = t.end), this.flags = 0;
  }, "AST_Throw"), {
    $documentation: "A `throw` statement"
  }, cn), Kn = ge("LoopControl", "label", /* @__PURE__ */ s(function(t) {
    t && (this.label = t.label, this.start = t.start, this.end = t.end), this.flags = 0;
  }, "AST_LoopControl"), {
    $documentation: "Base class for loop control statements (`break` and `continue`)",
    $propdoc: {
      label: "[AST_LabelRef?] the label, or null if none"
    },
    _walk: /* @__PURE__ */ s(function(e) {
      return e._visit(this, this.label && function() {
        this.label._walk(e);
      });
    }, "_walk"),
    _children_backwards(e) {
      this.label && e(this.label);
    }
  }, ql), hn = ge("Break", null, /* @__PURE__ */ s(function(t) {
    t && (this.label = t.label, this.start = t.start, this.end = t.end), this.flags = 0;
  }, "AST_Break"), {
    $documentation: "A `break` statement"
  }, Kn), ua = ge("Continue", null, /* @__PURE__ */ s(function(t) {
    t && (this.label = t.label, this.start = t.start, this.end = t.end), this.flags = 0;
  }, "AST_Continue"), {
    $documentation: "A `continue` statement"
  }, Kn), Mi = ge("Await", "expression", /* @__PURE__ */ s(function(t) {
    t && (this.expression = t.expression, this.start = t.start, this.end = t.end), this.flags = 0;
  }, "AST_Await"), {
    $documentation: "An `await` statement",
    $propdoc: {
      expression: "[AST_Node] the mandatory expression being awaited"
    },
    _walk: /* @__PURE__ */ s(function(e) {
      return e._visit(this, function() {
        this.expression._walk(e);
      });
    }, "_walk"),
    _children_backwards(e) {
      e(this.expression);
    }
  }), Oi = ge("Yield", "expression is_star", /* @__PURE__ */ s(function(t) {
    t && (this.expression = t.expression, this.is_star = t.is_star, this.start = t.start, this.end = t.end), this.flags = 0;
  }, "AST_Yield"), {
    $documentation: "A `yield` statement",
    $propdoc: {
      expression: "[AST_Node?] the value returned or thrown by this statement; could be null (representing undefined) but only when is_star \
is set to false",
      is_star: "[Boolean] Whether this is a yield or yield* statement"
    },
    _walk: /* @__PURE__ */ s(function(e) {
      return e._visit(this, this.expression && function() {
        this.expression._walk(e);
      });
    }, "_walk"),
    _children_backwards(e) {
      this.expression && e(this.expression);
    }
  }), Ft = ge("If", "condition alternative", /* @__PURE__ */ s(function(t) {
    t && (this.condition = t.condition, this.alternative = t.alternative, this.body = t.body, this.start = t.start, this.end = t.end), this.
    flags = 0;
  }, "AST_If"), {
    $documentation: "A `if` statement",
    $propdoc: {
      condition: "[AST_Node] the `if` condition",
      alternative: "[AST_Statement?] the `else` part, or null if not present"
    },
    _walk: /* @__PURE__ */ s(function(e) {
      return e._visit(this, function() {
        this.condition._walk(e), this.body._walk(e), this.alternative && this.alternative._walk(e);
      });
    }, "_walk"),
    _children_backwards(e) {
      this.alternative && e(this.alternative), e(this.body), e(this.condition);
    }
  }, Bl), Vr = ge("Switch", "expression", /* @__PURE__ */ s(function(t) {
    t && (this.expression = t.expression, this.body = t.body, this.block_scope = t.block_scope, this.start = t.start, this.end = t.end), this.
    flags = 0;
  }, "AST_Switch"), {
    $documentation: "A `switch` statement",
    $propdoc: {
      expression: "[AST_Node] the `switch` \u201Cdiscriminant\u201D"
    },
    _walk: /* @__PURE__ */ s(function(e) {
      return e._visit(this, function() {
        this.expression._walk(e), Ml(this, e);
      });
    }, "_walk"),
    _children_backwards(e) {
      let t = this.body.length;
      for (; t--; ) e(this.body[t]);
      e(this.expression);
    }
  }, Tr), Ts = ge("SwitchBranch", null, /* @__PURE__ */ s(function(t) {
    t && (this.body = t.body, this.block_scope = t.block_scope, this.start = t.start, this.end = t.end), this.flags = 0;
  }, "AST_SwitchBranch"), {
    $documentation: "Base class for `switch` branches"
  }, Tr), zs = ge("Default", null, /* @__PURE__ */ s(function(t) {
    t && (this.body = t.body, this.block_scope = t.block_scope, this.start = t.start, this.end = t.end), this.flags = 0;
  }, "AST_Default"), {
    $documentation: "A `default` switch branch"
  }, Ts), dn = ge("Case", "expression", /* @__PURE__ */ s(function(t) {
    t && (this.expression = t.expression, this.body = t.body, this.block_scope = t.block_scope, this.start = t.start, this.end = t.end), this.
    flags = 0;
  }, "AST_Case"), {
    $documentation: "A `case` switch branch",
    $propdoc: {
      expression: "[AST_Node] the `case` expression"
    },
    _walk: /* @__PURE__ */ s(function(e) {
      return e._visit(this, function() {
        this.expression._walk(e), Ml(this, e);
      });
    }, "_walk"),
    _children_backwards(e) {
      let t = this.body.length;
      for (; t--; ) e(this.body[t]);
      e(this.expression);
    }
  }, Ts), mi = ge("Try", "body bcatch bfinally", /* @__PURE__ */ s(function(t) {
    t && (this.body = t.body, this.bcatch = t.bcatch, this.bfinally = t.bfinally, this.start = t.start, this.end = t.end), this.flags = 0;
  }, "AST_Try"), {
    $documentation: "A `try` statement",
    $propdoc: {
      body: "[AST_TryBlock] the try block",
      bcatch: "[AST_Catch?] the catch block, or null if not present",
      bfinally: "[AST_Finally?] the finally block, or null if not present"
    },
    _walk: /* @__PURE__ */ s(function(e) {
      return e._visit(this, function() {
        this.body._walk(e), this.bcatch && this.bcatch._walk(e), this.bfinally && this.bfinally._walk(e);
      });
    }, "_walk"),
    _children_backwards(e) {
      this.bfinally && e(this.bfinally), this.bcatch && e(this.bcatch), e(this.body);
    }
  }, Br), Nl = ge("TryBlock", null, /* @__PURE__ */ s(function(t) {
    t && (this.body = t.body, this.block_scope = t.block_scope, this.start = t.start, this.end = t.end), this.flags = 0;
  }, "AST_TryBlock"), {
    $documentation: "The `try` block of a try statement"
  }, Tr), mn = ge("Catch", "argname", /* @__PURE__ */ s(function(t) {
    t && (this.argname = t.argname, this.body = t.body, this.block_scope = t.block_scope, this.start = t.start, this.end = t.end), this.flags =
    0;
  }, "AST_Catch"), {
    $documentation: "A `catch` node; only makes sense as part of a `try` statement",
    $propdoc: {
      argname: "[AST_SymbolCatch|AST_Destructuring|AST_Expansion|AST_DefaultAssign] symbol for the exception"
    },
    _walk: /* @__PURE__ */ s(function(e) {
      return e._visit(this, function() {
        this.argname && this.argname._walk(e), Ml(this, e);
      });
    }, "_walk"),
    _children_backwards(e) {
      let t = this.body.length;
      for (; t--; ) e(this.body[t]);
      this.argname && e(this.argname);
    }
  }, Tr), uo = ge("Finally", null, /* @__PURE__ */ s(function(t) {
    t && (this.body = t.body, this.block_scope = t.block_scope, this.start = t.start, this.end = t.end), this.flags = 0;
  }, "AST_Finally"), {
    $documentation: "A `finally` node; only makes sense as part of a `try` statement"
  }, Tr), cr = ge("Definitions", "definitions", /* @__PURE__ */ s(function(t) {
    t && (this.definitions = t.definitions, this.start = t.start, this.end = t.end), this.flags = 0;
  }, "AST_Definitions"), {
    $documentation: "Base class for `var` or `const` nodes (variable declarations/initializations)",
    $propdoc: {
      definitions: "[AST_VarDef*] array of variable definitions"
    },
    _walk: /* @__PURE__ */ s(function(e) {
      return e._visit(this, function() {
        for (var t = this.definitions, r = 0, i = t.length; r < i; r++)
          t[r]._walk(e);
      });
    }, "_walk"),
    _children_backwards(e) {
      let t = this.definitions.length;
      for (; t--; ) e(this.definitions[t]);
    }
  }, Br), Fr = ge("Var", null, /* @__PURE__ */ s(function(t) {
    t && (this.definitions = t.definitions, this.start = t.start, this.end = t.end), this.flags = 0;
  }, "AST_Var"), {
    $documentation: "A `var` statement"
  }, cr), Dn = ge("Let", null, /* @__PURE__ */ s(function(t) {
    t && (this.definitions = t.definitions, this.start = t.start, this.end = t.end), this.flags = 0;
  }, "AST_Let"), {
    $documentation: "A `let` statement"
  }, cr), wn = ge("Const", null, /* @__PURE__ */ s(function(t) {
    t && (this.definitions = t.definitions, this.start = t.start, this.end = t.end), this.flags = 0;
  }, "AST_Const"), {
    $documentation: "A `const` statement"
  }, cr), Lt = ge("VarDef", "name value", /* @__PURE__ */ s(function(t) {
    t && (this.name = t.name, this.value = t.value, this.start = t.start, this.end = t.end), this.flags = 0;
  }, "AST_VarDef"), {
    $documentation: "A variable declaration; only appears in a AST_Definitions node",
    $propdoc: {
      name: "[AST_Destructuring|AST_SymbolConst|AST_SymbolLet|AST_SymbolVar] name of the variable",
      value: "[AST_Node?] initializer, or null of there's no initializer"
    },
    _walk: /* @__PURE__ */ s(function(e) {
      return e._visit(this, function() {
        this.name._walk(e), this.value && this.value._walk(e);
      });
    }, "_walk"),
    _children_backwards(e) {
      this.value && e(this.value), e(this.name);
    },
    declarations_as_names() {
      return this.name instanceof Lr ? [this] : this.name.all_symbols();
    }
  }), Cn = ge("NameMapping", "foreign_name name", /* @__PURE__ */ s(function(t) {
    t && (this.foreign_name = t.foreign_name, this.name = t.name, this.start = t.start, this.end = t.end), this.flags = 0;
  }, "AST_NameMapping"), {
    $documentation: "The part of the export/import statement that declare names from a module.",
    $propdoc: {
      foreign_name: "[AST_SymbolExportForeign|AST_SymbolImportForeign] The name being exported/imported (as specified in the module)",
      name: "[AST_SymbolExport|AST_SymbolImport] The name as it is visible to this module."
    },
    _walk: /* @__PURE__ */ s(function(e) {
      return e._visit(this, function() {
        this.foreign_name._walk(e), this.name._walk(e);
      });
    }, "_walk"),
    _children_backwards(e) {
      e(this.name), e(this.foreign_name);
    }
  }), yi = ge(
    "Import",
    "imported_name imported_names module_name attributes",
    /* @__PURE__ */ s(function(t) {
      t && (this.imported_name = t.imported_name, this.imported_names = t.imported_names, this.module_name = t.module_name, this.attributes =
      t.attributes, this.start = t.start, this.end = t.end), this.flags = 0;
    }, "AST_Import"),
    {
      $documentation: "An `import` statement",
      $propdoc: {
        imported_name: "[AST_SymbolImport] The name of the variable holding the module's default export.",
        imported_names: "[AST_NameMapping*] The names of non-default imported variables",
        module_name: "[AST_String] String literal describing where this module came from",
        attributes: "[AST_Object?] The import attributes (with {...})"
      },
      _walk: /* @__PURE__ */ s(function(e) {
        return e._visit(this, function() {
          this.imported_name && this.imported_name._walk(e), this.imported_names && this.imported_names.forEach(function(t) {
            t._walk(e);
          }), this.module_name._walk(e);
        });
      }, "_walk"),
      _children_backwards(e) {
        if (e(this.module_name), this.imported_names) {
          let t = this.imported_names.length;
          for (; t--; ) e(this.imported_names[t]);
        }
        this.imported_name && e(this.imported_name);
      }
    }
  ), ss = ge("ImportMeta", null, /* @__PURE__ */ s(function(t) {
    t && (this.start = t.start, this.end = t.end), this.flags = 0;
  }, "AST_ImportMeta"), {
    $documentation: "A reference to import.meta"
  }), dr = ge(
    "Export",
    "exported_definition exported_value is_default exported_names module_name attributes",
    /* @__PURE__ */ s(function(t) {
      t && (this.exported_definition = t.exported_definition, this.exported_value = t.exported_value, this.is_default = t.is_default, this.exported_names =
      t.exported_names, this.module_name = t.module_name, this.attributes = t.attributes, this.start = t.start, this.end = t.end), this.flags =
      0;
    }, "AST_Export"),
    {
      $documentation: "An `export` statement",
      $propdoc: {
        exported_definition: "[AST_Defun|AST_Definitions|AST_DefClass?] An exported definition",
        exported_value: "[AST_Node?] An exported value",
        exported_names: "[AST_NameMapping*?] List of exported names",
        module_name: "[AST_String?] Name of the file to load exports from",
        is_default: "[Boolean] Whether this is the default exported value of this module",
        attributes: "[AST_Object?] The import attributes"
      },
      _walk: /* @__PURE__ */ s(function(e) {
        return e._visit(this, function() {
          this.exported_definition && this.exported_definition._walk(e), this.exported_value && this.exported_value._walk(e), this.exported_names &&
          this.exported_names.forEach(function(t) {
            t._walk(e);
          }), this.module_name && this.module_name._walk(e);
        });
      }, "_walk"),
      _children_backwards(e) {
        if (this.module_name && e(this.module_name), this.exported_names) {
          let t = this.exported_names.length;
          for (; t--; ) e(this.exported_names[t]);
        }
        this.exported_value && e(this.exported_value), this.exported_definition && e(this.exported_definition);
      }
    },
    Br
  ), Fe = ge(
    "Call",
    "expression args optional _annotations",
    /* @__PURE__ */ s(function(t) {
      t && (this.expression = t.expression, this.args = t.args, this.optional = t.optional, this._annotations = t._annotations, this.start =
      t.start, this.end = t.end, this.initialize()), this.flags = 0;
    }, "AST_Call"),
    {
      $documentation: "A function call expression",
      $propdoc: {
        expression: "[AST_Node] expression to invoke as function",
        args: "[AST_Node*] array of arguments",
        optional: "[boolean] whether this is an optional call (IE ?.() )",
        _annotations: "[number] bitfield containing information about the call"
      },
      initialize() {
        this._annotations == null && (this._annotations = 0);
      },
      _walk(e) {
        return e._visit(this, function() {
          for (var t = this.args, r = 0, i = t.length; r < i; r++)
            t[r]._walk(e);
          this.expression._walk(e);
        });
      },
      _children_backwards(e) {
        let t = this.args.length;
        for (; t--; ) e(this.args[t]);
        e(this.expression);
      }
    }
  ), gi = ge("New", null, /* @__PURE__ */ s(function(t) {
    t && (this.expression = t.expression, this.args = t.args, this.optional = t.optional, this._annotations = t._annotations, this.start = t.
    start, this.end = t.end, this.initialize()), this.flags = 0;
  }, "AST_New"), {
    $documentation: "An object instantiation.  Derives from a function call since it has exactly the same properties"
  }, Fe), Qe = ge("Sequence", "expressions", /* @__PURE__ */ s(function(t) {
    t && (this.expressions = t.expressions, this.start = t.start, this.end = t.end), this.flags = 0;
  }, "AST_Sequence"), {
    $documentation: "A sequence expression (comma-separated expressions)",
    $propdoc: {
      expressions: "[AST_Node*] array of expressions (at least two)"
    },
    _walk: /* @__PURE__ */ s(function(e) {
      return e._visit(this, function() {
        this.expressions.forEach(function(t) {
          t._walk(e);
        });
      });
    }, "_walk"),
    _children_backwards(e) {
      let t = this.expressions.length;
      for (; t--; ) e(this.expressions[t]);
    }
  }), je = ge(
    "PropAccess",
    "expression property optional",
    /* @__PURE__ */ s(function(t) {
      t && (this.expression = t.expression, this.property = t.property, this.optional = t.optional, this.start = t.start, this.end = t.end),
      this.flags = 0;
    }, "AST_PropAccess"),
    {
      $documentation: 'Base class for property access expressions, i.e. `a.foo` or `a["foo"]`',
      $propdoc: {
        expression: "[AST_Node] the \u201Ccontainer\u201D expression",
        property: "[AST_Node|string] the property to access.  For AST_Dot & AST_DotHash this is always a plain string, while for AST_Sub it'\
s an arbitrary AST_Node",
        optional: "[boolean] whether this is an optional property access (IE ?.)"
      }
    }
  ), It = ge("Dot", "quote", /* @__PURE__ */ s(function(t) {
    t && (this.quote = t.quote, this.expression = t.expression, this.property = t.property, this.optional = t.optional, this._annotations = t.
    _annotations, this.start = t.start, this.end = t.end), this.flags = 0;
  }, "AST_Dot"), {
    $documentation: "A dotted property access expression",
    $propdoc: {
      quote: "[string] the original quote character when transformed from AST_Sub"
    },
    _walk: /* @__PURE__ */ s(function(e) {
      return e._visit(this, function() {
        this.expression._walk(e);
      });
    }, "_walk"),
    _children_backwards(e) {
      e(this.expression);
    }
  }, je), Wi = ge("DotHash", "", /* @__PURE__ */ s(function(t) {
    t && (this.expression = t.expression, this.property = t.property, this.optional = t.optional, this.start = t.start, this.end = t.end), this.
    flags = 0;
  }, "AST_DotHash"), {
    $documentation: "A dotted property access to a private property",
    _walk: /* @__PURE__ */ s(function(e) {
      return e._visit(this, function() {
        this.expression._walk(e);
      });
    }, "_walk"),
    _children_backwards(e) {
      e(this.expression);
    }
  }, je), fr = ge("Sub", null, /* @__PURE__ */ s(function(t) {
    t && (this.expression = t.expression, this.property = t.property, this.optional = t.optional, this._annotations = t._annotations, this.start =
    t.start, this.end = t.end), this.flags = 0;
  }, "AST_Sub"), {
    $documentation: 'Index-style property access, i.e. `a["foo"]`',
    _walk: /* @__PURE__ */ s(function(e) {
      return e._visit(this, function() {
        this.expression._walk(e), this.property._walk(e);
      });
    }, "_walk"),
    _children_backwards(e) {
      e(this.property), e(this.expression);
    }
  }, je), er = ge("Chain", "expression", /* @__PURE__ */ s(function(t) {
    t && (this.expression = t.expression, this.start = t.start, this.end = t.end), this.flags = 0;
  }, "AST_Chain"), {
    $documentation: "A chain expression like a?.b?.(c)?.[d]",
    $propdoc: {
      expression: "[AST_Call|AST_Dot|AST_DotHash|AST_Sub] chain element."
    },
    _walk: /* @__PURE__ */ s(function(e) {
      return e._visit(this, function() {
        this.expression._walk(e);
      });
    }, "_walk"),
    _children_backwards(e) {
      e(this.expression);
    }
  }), Ht = ge("Unary", "operator expression", /* @__PURE__ */ s(function(t) {
    t && (this.operator = t.operator, this.expression = t.expression, this.start = t.start, this.end = t.end), this.flags = 0;
  }, "AST_Unary"), {
    $documentation: "Base class for unary expressions",
    $propdoc: {
      operator: "[string] the operator",
      expression: "[AST_Node] expression that this unary operator applies to"
    },
    _walk: /* @__PURE__ */ s(function(e) {
      return e._visit(this, function() {
        this.expression._walk(e);
      });
    }, "_walk"),
    _children_backwards(e) {
      e(this.expression);
    }
  }), $e = ge("UnaryPrefix", null, /* @__PURE__ */ s(function(t) {
    t && (this.operator = t.operator, this.expression = t.expression, this.start = t.start, this.end = t.end), this.flags = 0;
  }, "AST_UnaryPrefix"), {
    $documentation: "Unary prefix expression, i.e. `typeof i` or `++i`"
  }, Ht), as = ge("UnaryPostfix", null, /* @__PURE__ */ s(function(t) {
    t && (this.operator = t.operator, this.expression = t.expression, this.start = t.start, this.end = t.end), this.flags = 0;
  }, "AST_UnaryPostfix"), {
    $documentation: "Unary postfix expression, i.e. `i++`"
  }, Ht), ce = ge("Binary", "operator left right", /* @__PURE__ */ s(function(t) {
    t && (this.operator = t.operator, this.left = t.left, this.right = t.right, this.start = t.start, this.end = t.end), this.flags = 0;
  }, "AST_Binary"), {
    $documentation: "Binary expression, i.e. `a + b`",
    $propdoc: {
      left: "[AST_Node] left-hand side expression",
      operator: "[string] the operator",
      right: "[AST_Node] right-hand side expression"
    },
    _walk: /* @__PURE__ */ s(function(e) {
      return e._visit(this, function() {
        this.left._walk(e), this.right._walk(e);
      });
    }, "_walk"),
    _children_backwards(e) {
      e(this.right), e(this.left);
    }
  }), it = ge(
    "Conditional",
    "condition consequent alternative",
    /* @__PURE__ */ s(function(t) {
      t && (this.condition = t.condition, this.consequent = t.consequent, this.alternative = t.alternative, this.start = t.start, this.end =
      t.end), this.flags = 0;
    }, "AST_Conditional"),
    {
      $documentation: "Conditional expression using the ternary operator, i.e. `a ? b : c`",
      $propdoc: {
        condition: "[AST_Node]",
        consequent: "[AST_Node]",
        alternative: "[AST_Node]"
      },
      _walk: /* @__PURE__ */ s(function(e) {
        return e._visit(this, function() {
          this.condition._walk(e), this.consequent._walk(e), this.alternative._walk(e);
        });
      }, "_walk"),
      _children_backwards(e) {
        e(this.alternative), e(this.consequent), e(this.condition);
      }
    }
  ), ct = ge("Assign", "logical", /* @__PURE__ */ s(function(t) {
    t && (this.logical = t.logical, this.operator = t.operator, this.left = t.left, this.right = t.right, this.start = t.start, this.end = t.
    end), this.flags = 0;
  }, "AST_Assign"), {
    $documentation: "An assignment expression \u2014 `a = b + 5`",
    $propdoc: {
      logical: "Whether it's a logical assignment"
    }
  }, ce), sn = ge("DefaultAssign", null, /* @__PURE__ */ s(function(t) {
    t && (this.operator = t.operator, this.left = t.left, this.right = t.right, this.start = t.start, this.end = t.end), this.flags = 0;
  }, "AST_DefaultAssign"), {
    $documentation: "A default assignment expression like in `(a = 3) => a`"
  }, ce), pt = ge("Array", "elements", /* @__PURE__ */ s(function(t) {
    t && (this.elements = t.elements, this.start = t.start, this.end = t.end), this.flags = 0;
  }, "AST_Array"), {
    $documentation: "An array literal",
    $propdoc: {
      elements: "[AST_Node*] array of elements"
    },
    _walk: /* @__PURE__ */ s(function(e) {
      return e._visit(this, function() {
        for (var t = this.elements, r = 0, i = t.length; r < i; r++)
          t[r]._walk(e);
      });
    }, "_walk"),
    _children_backwards(e) {
      let t = this.elements.length;
      for (; t--; ) e(this.elements[t]);
    }
  }), Tt = ge("Object", "properties", /* @__PURE__ */ s(function(t) {
    t && (this.properties = t.properties, this.start = t.start, this.end = t.end), this.flags = 0;
  }, "AST_Object"), {
    $documentation: "An object literal",
    $propdoc: {
      properties: "[AST_ObjectProperty*] array of properties"
    },
    _walk: /* @__PURE__ */ s(function(e) {
      return e._visit(this, function() {
        for (var t = this.properties, r = 0, i = t.length; r < i; r++)
          t[r]._walk(e);
      });
    }, "_walk"),
    _children_backwards(e) {
      let t = this.properties.length;
      for (; t--; ) e(this.properties[t]);
    }
  }), gr = ge("ObjectProperty", "key value", /* @__PURE__ */ s(function(t) {
    t && (this.key = t.key, this.value = t.value, this.start = t.start, this.end = t.end, this._annotations = t._annotations), this.flags = 0;
  }, "AST_ObjectProperty"), {
    $documentation: "Base class for literal object properties",
    $propdoc: {
      key: "[string|AST_Node] property name. For ObjectKeyVal this is a string. For getters, setters and computed property this is an AST_No\
de.",
      value: "[AST_Node] property value.  For getters, setters and methods this is an AST_Accessor."
    },
    _walk: /* @__PURE__ */ s(function(e) {
      return e._visit(this, function() {
        this.key instanceof Se && this.key._walk(e), this.value._walk(e);
      });
    }, "_walk"),
    _children_backwards(e) {
      e(this.value), this.key instanceof Se && e(this.key);
    }
  }), Nt = ge("ObjectKeyVal", "quote", /* @__PURE__ */ s(function(t) {
    t && (this.quote = t.quote, this.key = t.key, this.value = t.value, this.start = t.start, this.end = t.end, this._annotations = t._annotations),
    this.flags = 0;
  }, "AST_ObjectKeyVal"), {
    $documentation: "A key: value object property",
    $propdoc: {
      quote: "[string] the original quote character"
    },
    computed_key() {
      return this.key instanceof Se;
    }
  }, gr), on = ge("PrivateSetter", "static", /* @__PURE__ */ s(function(t) {
    t && (this.static = t.static, this.key = t.key, this.value = t.value, this.start = t.start, this.end = t.end), this.flags = 0;
  }, "AST_PrivateSetter"), {
    $propdoc: {
      static: "[boolean] whether this is a static private setter"
    },
    $documentation: "A private setter property",
    computed_key() {
      return !1;
    }
  }, gr), $i = ge("PrivateGetter", "static", /* @__PURE__ */ s(function(t) {
    t && (this.static = t.static, this.key = t.key, this.value = t.value, this.start = t.start, this.end = t.end), this.flags = 0;
  }, "AST_PrivateGetter"), {
    $propdoc: {
      static: "[boolean] whether this is a static private getter"
    },
    $documentation: "A private getter property",
    computed_key() {
      return !1;
    }
  }, gr), On = ge("ObjectSetter", "quote static", /* @__PURE__ */ s(function(t) {
    t && (this.quote = t.quote, this.static = t.static, this.key = t.key, this.value = t.value, this.start = t.start, this.end = t.end, this.
    _annotations = t._annotations), this.flags = 0;
  }, "AST_ObjectSetter"), {
    $propdoc: {
      quote: "[string|undefined] the original quote character, if any",
      static: "[boolean] whether this is a static setter (classes only)"
    },
    $documentation: "An object setter property",
    computed_key() {
      return !(this.key instanceof hi);
    }
  }, gr), yn = ge("ObjectGetter", "quote static", /* @__PURE__ */ s(function(t) {
    t && (this.quote = t.quote, this.static = t.static, this.key = t.key, this.value = t.value, this.start = t.start, this.end = t.end, this.
    _annotations = t._annotations), this.flags = 0;
  }, "AST_ObjectGetter"), {
    $propdoc: {
      quote: "[string|undefined] the original quote character, if any",
      static: "[boolean] whether this is a static getter (classes only)"
    },
    $documentation: "An object getter property",
    computed_key() {
      return !(this.key instanceof hi);
    }
  }, gr), Kr = ge("ConciseMethod", "quote static is_generator async", /* @__PURE__ */ s(function(t) {
    t && (this.quote = t.quote, this.static = t.static, this.is_generator = t.is_generator, this.async = t.async, this.key = t.key, this.value =
    t.value, this.start = t.start, this.end = t.end, this._annotations = t._annotations), this.flags = 0;
  }, "AST_ConciseMethod"), {
    $propdoc: {
      quote: "[string|undefined] the original quote character, if any",
      static: "[boolean] is this method static (classes only)",
      is_generator: "[boolean] is this a generator method",
      async: "[boolean] is this method async"
    },
    $documentation: "An ES6 concise method inside an object or class",
    computed_key() {
      return !(this.key instanceof hi);
    }
  }, gr), ki = ge("PrivateMethod", "", /* @__PURE__ */ s(function(t) {
    t && (this.quote = t.quote, this.static = t.static, this.is_generator = t.is_generator, this.async = t.async, this.key = t.key, this.value =
    t.value, this.start = t.start, this.end = t.end), this.flags = 0;
  }, "AST_PrivateMethod"), {
    $documentation: "A private class method inside a class",
    computed_key() {
      return !1;
    }
  }, gr), ht = ge(
    "Class",
    "name extends properties",
    /* @__PURE__ */ s(function(t) {
      t && (this.name = t.name, this.extends = t.extends, this.properties = t.properties, this.variables = t.variables, this.uses_with = t.uses_with,
      this.uses_eval = t.uses_eval, this.parent_scope = t.parent_scope, this.enclosed = t.enclosed, this.cname = t.cname, this.body = t.body,
      this.block_scope = t.block_scope, this.start = t.start, this.end = t.end), this.flags = 0;
    }, "AST_Class"),
    {
      $propdoc: {
        name: "[AST_SymbolClass|AST_SymbolDefClass?] optional class name.",
        extends: "[AST_Node]? optional parent class",
        properties: "[AST_ObjectProperty|AST_ClassStaticBlock]* array of properties or static blocks"
      },
      $documentation: "An ES6 class",
      _walk: /* @__PURE__ */ s(function(e) {
        return e._visit(this, function() {
          this.name && this.name._walk(e), this.extends && this.extends._walk(e), this.properties.forEach((t) => t._walk(e));
        });
      }, "_walk"),
      _children_backwards(e) {
        let t = this.properties.length;
        for (; t--; ) e(this.properties[t]);
        this.extends && e(this.extends), this.name && e(this.name);
      },
      /** go through the bits that are executed instantly, not when the class is `new`'d. Doesn't walk the name. */
      visit_nondeferred_class_parts(e) {
        this.extends && this.extends._walk(e), this.properties.forEach((t) => {
          if (t instanceof Hr) {
            t._walk(e);
            return;
          }
          t.computed_key() && (e.push(t), t.key._walk(e), e.pop()), (t instanceof Ii && t.static && t.value || t instanceof Bi && t.static &&
          t.value) && (e.push(t), t.value._walk(e), e.pop());
        });
      },
      /** go through the bits that are executed later, when the class is `new`'d or a static method is called */
      visit_deferred_class_parts(e) {
        this.properties.forEach((t) => {
          t instanceof Kr || t instanceof ki ? t.walk(e) : (t instanceof Bi && !t.static && t.value || t instanceof Ii && !t.static && t.value) &&
          (e.push(t), t.value._walk(e), e.pop());
        });
      },
      is_self_referential: /* @__PURE__ */ s(function() {
        let e = this.name && this.name.definition().id, t = !1, r = !0;
        return this.visit_nondeferred_class_parts(new Mr((i, n) => {
          if (t) return !0;
          if (i instanceof kr) return t = r;
          if (i instanceof Te) return t = i.definition().id === e;
          if (i instanceof Ue && !(i instanceof Zt)) {
            let a = r;
            return r = !1, n(), r = a, !0;
          }
        })), t;
      }, "is_self_referential")
    },
    Ye
    /* TODO a class might have a scope but it's not a scope */
  ), Bi = ge("ClassProperty", "static quote", /* @__PURE__ */ s(function(t) {
    t && (this.static = t.static, this.quote = t.quote, this.key = t.key, this.value = t.value, this.start = t.start, this.end = t.end, this.
    _annotations = t._annotations), this.flags = 0;
  }, "AST_ClassProperty"), {
    $documentation: "A class property",
    $propdoc: {
      static: "[boolean] whether this is a static key",
      quote: "[string] which quote is being used"
    },
    _walk: /* @__PURE__ */ s(function(e) {
      return e._visit(this, function() {
        this.key instanceof Se && this.key._walk(e), this.value instanceof Se && this.value._walk(e);
      });
    }, "_walk"),
    _children_backwards(e) {
      this.value instanceof Se && e(this.value), this.key instanceof Se && e(this.key);
    },
    computed_key() {
      return !(this.key instanceof vs);
    }
  }, gr), Ii = ge("ClassPrivateProperty", "", /* @__PURE__ */ s(function(t) {
    t && (this.static = t.static, this.quote = t.quote, this.key = t.key, this.value = t.value, this.start = t.start, this.end = t.end), this.
    flags = 0;
  }, "AST_ClassPrivateProperty"), {
    $documentation: "A class property for a private property",
    _walk: /* @__PURE__ */ s(function(e) {
      return e._visit(this, function() {
        this.value instanceof Se && this.value._walk(e);
      });
    }, "_walk"),
    _children_backwards(e) {
      this.value instanceof Se && e(this.value);
    },
    computed_key() {
      return !1;
    }
  }, gr), Un = ge("PrivateIn", "key value", /* @__PURE__ */ s(function(t) {
    t && (this.key = t.key, this.value = t.value, this.start = t.start, this.end = t.end), this.flags = 0;
  }, "AST_PrivateIn"), {
    $documentation: "An `in` binop when the key is private, eg #x in this",
    _walk: /* @__PURE__ */ s(function(e) {
      return e._visit(this, function() {
        this.key._walk(e), this.value._walk(e);
      });
    }, "_walk"),
    _children_backwards(e) {
      e(this.value), e(this.key);
    }
  }), an = ge("DefClass", null, /* @__PURE__ */ s(function(t) {
    t && (this.name = t.name, this.extends = t.extends, this.properties = t.properties, this.variables = t.variables, this.uses_with = t.uses_with,
    this.uses_eval = t.uses_eval, this.parent_scope = t.parent_scope, this.enclosed = t.enclosed, this.cname = t.cname, this.body = t.body, this.
    block_scope = t.block_scope, this.start = t.start, this.end = t.end), this.flags = 0;
  }, "AST_DefClass"), {
    $documentation: "A class definition"
  }, ht), Hr = ge("ClassStaticBlock", "body block_scope", /* @__PURE__ */ s(function(t) {
    this.body = t.body, this.block_scope = t.block_scope, this.start = t.start, this.end = t.end;
  }, "AST_ClassStaticBlock"), {
    $documentation: "A block containing statements to be executed in the context of the class",
    $propdoc: {
      body: "[AST_Statement*] an array of statements"
    },
    _walk: /* @__PURE__ */ s(function(e) {
      return e._visit(this, function() {
        Ml(this, e);
      });
    }, "_walk"),
    _children_backwards(e) {
      let t = this.body.length;
      for (; t--; ) e(this.body[t]);
    },
    clone: vk,
    computed_key() {
      return !1;
    }
  }, Ye), ts = ge("ClassExpression", null, /* @__PURE__ */ s(function(t) {
    t && (this.name = t.name, this.extends = t.extends, this.properties = t.properties, this.variables = t.variables, this.uses_with = t.uses_with,
    this.uses_eval = t.uses_eval, this.parent_scope = t.parent_scope, this.enclosed = t.enclosed, this.cname = t.cname, this.body = t.body, this.
    block_scope = t.block_scope, this.start = t.start, this.end = t.end), this.flags = 0;
  }, "AST_ClassExpression"), {
    $documentation: "A class expression."
  }, ht), gt = ge("Symbol", "scope name thedef", /* @__PURE__ */ s(function(t) {
    t && (this.scope = t.scope, this.name = t.name, this.thedef = t.thedef, this.start = t.start, this.end = t.end), this.flags = 0;
  }, "AST_Symbol"), {
    $propdoc: {
      name: "[string] name of this symbol",
      scope: "[AST_Scope/S] the current scope (not necessarily the definition scope)",
      thedef: "[SymbolDef/S] the definition of this symbol"
    },
    $documentation: "Base class for all symbols"
  }), lo = ge("NewTarget", null, /* @__PURE__ */ s(function(t) {
    t && (this.start = t.start, this.end = t.end), this.flags = 0;
  }, "AST_NewTarget"), {
    $documentation: "A reference to new.target"
  }), Lr = ge("SymbolDeclaration", "init", /* @__PURE__ */ s(function(t) {
    t && (this.init = t.init, this.scope = t.scope, this.name = t.name, this.thedef = t.thedef, this.start = t.start, this.end = t.end), this.
    flags = 0;
  }, "AST_SymbolDeclaration"), {
    $documentation: "A declaration symbol (symbol in var/const, function name or argument, symbol in catch)"
  }, gt), bs = ge("SymbolVar", null, /* @__PURE__ */ s(function(t) {
    t && (this.init = t.init, this.scope = t.scope, this.name = t.name, this.thedef = t.thedef, this.start = t.start, this.end = t.end), this.
    flags = 0;
  }, "AST_SymbolVar"), {
    $documentation: "Symbol defining a variable"
  }, Lr), ho = ge(
    "SymbolBlockDeclaration",
    null,
    /* @__PURE__ */ s(function(t) {
      t && (this.init = t.init, this.scope = t.scope, this.name = t.name, this.thedef = t.thedef, this.start = t.start, this.end = t.end), this.
      flags = 0;
    }, "AST_SymbolBlockDeclaration"),
    {
      $documentation: "Base class for block-scoped declaration symbols"
    },
    Lr
  ), la = ge("SymbolConst", null, /* @__PURE__ */ s(function(t) {
    t && (this.init = t.init, this.scope = t.scope, this.name = t.name, this.thedef = t.thedef, this.start = t.start, this.end = t.end), this.
    flags = 0;
  }, "AST_SymbolConst"), {
    $documentation: "A constant declaration"
  }, ho), co = ge("SymbolLet", null, /* @__PURE__ */ s(function(t) {
    t && (this.init = t.init, this.scope = t.scope, this.name = t.name, this.thedef = t.thedef, this.start = t.start, this.end = t.end), this.
    flags = 0;
  }, "AST_SymbolLet"), {
    $documentation: "A block-scoped `let` declaration"
  }, ho), Nr = ge("SymbolFunarg", null, /* @__PURE__ */ s(function(t) {
    t && (this.init = t.init, this.scope = t.scope, this.name = t.name, this.thedef = t.thedef, this.start = t.start, this.end = t.end), this.
    flags = 0;
  }, "AST_SymbolFunarg"), {
    $documentation: "Symbol naming a function argument"
  }, bs), jn = ge("SymbolDefun", null, /* @__PURE__ */ s(function(t) {
    t && (this.init = t.init, this.scope = t.scope, this.name = t.name, this.thedef = t.thedef, this.start = t.start, this.end = t.end), this.
    flags = 0;
  }, "AST_SymbolDefun"), {
    $documentation: "Symbol defining a function"
  }, Lr), hi = ge("SymbolMethod", null, /* @__PURE__ */ s(function(t) {
    t && (this.scope = t.scope, this.name = t.name, this.thedef = t.thedef, this.start = t.start, this.end = t.end), this.flags = 0;
  }, "AST_SymbolMethod"), {
    $documentation: "Symbol in an object defining a method"
  }, gt), vs = ge("SymbolClassProperty", null, /* @__PURE__ */ s(function(t) {
    t && (this.scope = t.scope, this.name = t.name, this.thedef = t.thedef, this.start = t.start, this.end = t.end), this.flags = 0;
  }, "AST_SymbolClassProperty"), {
    $documentation: "Symbol for a class property"
  }, gt), kn = ge("SymbolLambda", null, /* @__PURE__ */ s(function(t) {
    t && (this.init = t.init, this.scope = t.scope, this.name = t.name, this.thedef = t.thedef, this.start = t.start, this.end = t.end), this.
    flags = 0;
  }, "AST_SymbolLambda"), {
    $documentation: "Symbol naming a function expression"
  }, Lr), Yc = ge("SymbolDefClass", null, /* @__PURE__ */ s(function(t) {
    t && (this.init = t.init, this.scope = t.scope, this.name = t.name, this.thedef = t.thedef, this.start = t.start, this.end = t.end), this.
    flags = 0;
  }, "AST_SymbolDefClass"), {
    $documentation: "Symbol naming a class's name in a class declaration. Lexically scoped to its containing scope, and accessible within th\
e class."
  }, ho), Jc = ge("SymbolClass", null, /* @__PURE__ */ s(function(t) {
    t && (this.init = t.init, this.scope = t.scope, this.name = t.name, this.thedef = t.thedef, this.start = t.start, this.end = t.end), this.
    flags = 0;
  }, "AST_SymbolClass"), {
    $documentation: "Symbol naming a class's name. Lexically scoped to the class."
  }, Lr), Vn = ge("SymbolCatch", null, /* @__PURE__ */ s(function(t) {
    t && (this.init = t.init, this.scope = t.scope, this.name = t.name, this.thedef = t.thedef, this.start = t.start, this.end = t.end), this.
    flags = 0;
  }, "AST_SymbolCatch"), {
    $documentation: "Symbol naming the exception in catch"
  }, ho), Fu = ge("SymbolImport", null, /* @__PURE__ */ s(function(t) {
    t && (this.init = t.init, this.scope = t.scope, this.name = t.name, this.thedef = t.thedef, this.start = t.start, this.end = t.end), this.
    flags = 0;
  }, "AST_SymbolImport"), {
    $documentation: "Symbol referring to an imported name"
  }, ho), Wo = ge("SymbolImportForeign", null, /* @__PURE__ */ s(function(t) {
    t && (this.scope = t.scope, this.name = t.name, this.thedef = t.thedef, this.quote = t.quote, this.start = t.start, this.end = t.end), this.
    flags = 0;
  }, "AST_SymbolImportForeign"), {
    $documentation: "A symbol imported from a module, but it is defined in the other module, and its real name is irrelevant for this module\
's purposes"
  }, gt), Ll = ge("Label", "references", /* @__PURE__ */ s(function(t) {
    t && (this.references = t.references, this.scope = t.scope, this.name = t.name, this.thedef = t.thedef, this.start = t.start, this.end =
    t.end, this.initialize()), this.flags = 0;
  }, "AST_Label"), {
    $documentation: "Symbol naming a label (declaration)",
    $propdoc: {
      references: "[AST_LoopControl*] a list of nodes referring to this label"
    },
    initialize: /* @__PURE__ */ s(function() {
      this.references = [], this.thedef = this;
    }, "initialize")
  }, gt), Te = ge("SymbolRef", null, /* @__PURE__ */ s(function(t) {
    t && (this.scope = t.scope, this.name = t.name, this.thedef = t.thedef, this.start = t.start, this.end = t.end), this.flags = 0;
  }, "AST_SymbolRef"), {
    $documentation: "Reference to some symbol (not definition/declaration)"
  }, gt), oo = ge("SymbolExport", null, /* @__PURE__ */ s(function(t) {
    t && (this.scope = t.scope, this.name = t.name, this.thedef = t.thedef, this.quote = t.quote, this.start = t.start, this.end = t.end), this.
    flags = 0;
  }, "AST_SymbolExport"), {
    $documentation: "Symbol referring to a name to export"
  }, Te), oa = ge("SymbolExportForeign", null, /* @__PURE__ */ s(function(t) {
    t && (this.scope = t.scope, this.name = t.name, this.thedef = t.thedef, this.quote = t.quote, this.start = t.start, this.end = t.end), this.
    flags = 0;
  }, "AST_SymbolExportForeign"), {
    $documentation: "A symbol exported from this module, but it is used in the other module, and its real name is irrelevant for this module\
's purposes"
  }, gt), Zp = ge("LabelRef", null, /* @__PURE__ */ s(function(t) {
    t && (this.scope = t.scope, this.name = t.name, this.thedef = t.thedef, this.start = t.start, this.end = t.end), this.flags = 0;
  }, "AST_LabelRef"), {
    $documentation: "Reference to a label symbol"
  }, gt), Fl = ge("SymbolPrivateProperty", null, /* @__PURE__ */ s(function(t) {
    t && (this.scope = t.scope, this.name = t.name, this.thedef = t.thedef, this.start = t.start, this.end = t.end), this.flags = 0;
  }, "AST_SymbolPrivateProperty"), {
    $documentation: "A symbol that refers to a private property"
  }, gt), kr = ge("This", null, /* @__PURE__ */ s(function(t) {
    t && (this.scope = t.scope, this.name = t.name, this.thedef = t.thedef, this.start = t.start, this.end = t.end), this.flags = 0;
  }, "AST_This"), {
    $documentation: "The `this` symbol"
  }, gt), fo = ge("Super", null, /* @__PURE__ */ s(function(t) {
    t && (this.scope = t.scope, this.name = t.name, this.thedef = t.thedef, this.start = t.start, this.end = t.end), this.flags = 0;
  }, "AST_Super"), {
    $documentation: "The `super` symbol"
  }, kr), Ct = ge("Constant", null, /* @__PURE__ */ s(function(t) {
    t && (this.start = t.start, this.end = t.end), this.flags = 0;
  }, "AST_Constant"), {
    $documentation: "Base class for all constants",
    getValue: /* @__PURE__ */ s(function() {
      return this.value;
    }, "getValue")
  }), bt = ge("String", "value quote", /* @__PURE__ */ s(function(t) {
    t && (this.value = t.value, this.quote = t.quote, this.start = t.start, this.end = t.end, this._annotations = t._annotations), this.flags =
    0;
  }, "AST_String"), {
    $documentation: "A string literal",
    $propdoc: {
      value: "[string] the contents of this string",
      quote: "[string] the original quote character"
    }
  }, Ct), We = ge("Number", "value raw", /* @__PURE__ */ s(function(t) {
    t && (this.value = t.value, this.raw = t.raw, this.start = t.start, this.end = t.end), this.flags = 0;
  }, "AST_Number"), {
    $documentation: "A number literal",
    $propdoc: {
      value: "[number] the numeric value",
      raw: "[string] numeric value as string"
    }
  }, Ct), un = ge("BigInt", "value", /* @__PURE__ */ s(function(t) {
    t && (this.value = t.value, this.start = t.start, this.end = t.end), this.flags = 0;
  }, "AST_BigInt"), {
    $documentation: "A big int literal",
    $propdoc: {
      value: "[string] big int value"
    }
  }, Ct), $r = ge("RegExp", "value", /* @__PURE__ */ s(function(t) {
    t && (this.value = t.value, this.start = t.start, this.end = t.end), this.flags = 0;
  }, "AST_RegExp"), {
    $documentation: "A regexp literal",
    $propdoc: {
      value: "[RegExp] the actual regexp"
    }
  }, Ct), Xo = ge("Atom", null, /* @__PURE__ */ s(function(t) {
    t && (this.start = t.start, this.end = t.end), this.flags = 0;
  }, "AST_Atom"), {
    $documentation: "Base class for atoms"
  }, Ct), Xi = ge("Null", null, /* @__PURE__ */ s(function(t) {
    t && (this.start = t.start, this.end = t.end), this.flags = 0;
  }, "AST_Null"), {
    $documentation: "The `null` atom",
    value: null
  }, Xo), Ul = ge("NaN", null, /* @__PURE__ */ s(function(t) {
    t && (this.start = t.start, this.end = t.end), this.flags = 0;
  }, "AST_NaN"), {
    $documentation: "The impossible value",
    value: NaN
  }, Xo), pr = ge("Undefined", null, /* @__PURE__ */ s(function(t) {
    t && (this.start = t.start, this.end = t.end), this.flags = 0;
  }, "AST_Undefined"), {
    $documentation: "The `undefined` value",
    value: /* @__PURE__ */ function() {
    }()
  }, Xo), xn = ge("Hole", null, /* @__PURE__ */ s(function(t) {
    t && (this.start = t.start, this.end = t.end), this.flags = 0;
  }, "AST_Hole"), {
    $documentation: "A hole in an array",
    value: /* @__PURE__ */ function() {
    }()
  }, Xo), mo = ge("Infinity", null, /* @__PURE__ */ s(function(t) {
    t && (this.start = t.start, this.end = t.end), this.flags = 0;
  }, "AST_Infinity"), {
    $documentation: "The `Infinity` value",
    value: 1 / 0
  }, Xo), rh = ge("Boolean", null, /* @__PURE__ */ s(function(t) {
    t && (this.start = t.start, this.end = t.end), this.flags = 0;
  }, "AST_Boolean"), {
    $documentation: "Base class for booleans"
  }, Xo), Ss = ge("False", null, /* @__PURE__ */ s(function(t) {
    t && (this.start = t.start, this.end = t.end), this.flags = 0;
  }, "AST_False"), {
    $documentation: "The `false` atom",
    value: !1
  }, rh), ln = ge("True", null, /* @__PURE__ */ s(function(t) {
    t && (this.start = t.start, this.end = t.end), this.flags = 0;
  }, "AST_True"), {
    $documentation: "The `true` atom",
    value: !0
  }, rh);
  s(_r, "walk");
  s(ih, "walk_parent");
  Yi = Symbol("abort walk"), Mr = class {
    static {
      s(this, "TreeWalker");
    }
    constructor(t) {
      this.visit = t, this.stack = [], this.directives = /* @__PURE__ */ Object.create(null);
    }
    _visit(t, r) {
      this.push(t);
      var i = this.visit(t, r ? function() {
        r.call(t);
      } : fn);
      return !i && r && r.call(t), this.pop(), i;
    }
    parent(t) {
      return this.stack[this.stack.length - 2 - (t || 0)];
    }
    push(t) {
      t instanceof Ue ? this.directives = Object.create(this.directives) : t instanceof wi && !this.directives[t.value] ? this.directives[t.
      value] = t : t instanceof ht && (this.directives = Object.create(this.directives), this.directives["use strict"] || (this.directives["\
use strict"] = t)), this.stack.push(t);
    }
    pop() {
      var t = this.stack.pop();
      (t instanceof Ue || t instanceof ht) && (this.directives = Object.getPrototypeOf(this.directives));
    }
    self() {
      return this.stack[this.stack.length - 1];
    }
    find_parent(t) {
      for (var r = this.stack, i = r.length; --i >= 0; ) {
        var n = r[i];
        if (n instanceof t) return n;
      }
    }
    find_scope() {
      for (var t = this.stack, r = t.length; --r >= 0; ) {
        let i = t[r];
        if (i instanceof Kt || i instanceof Ue) return i;
        if (i.block_scope) return i.block_scope;
      }
    }
    has_directive(t) {
      var r = this.directives[t];
      if (r) return r;
      var i = this.stack[this.stack.length - 1];
      if (i instanceof Ye && i.body)
        for (var n = 0; n < i.body.length; ++n) {
          var a = i.body[n];
          if (!(a instanceof wi)) break;
          if (a.value == t) return a;
        }
    }
    loopcontrol_target(t) {
      var r = this.stack;
      if (t.label) for (var i = r.length; --i >= 0; ) {
        var n = r[i];
        if (n instanceof wr && n.label.name == t.label.name)
          return n.body;
      }
      else for (var i = r.length; --i >= 0; ) {
        var n = r[i];
        if (n instanceof ns || t instanceof hn && n instanceof Vr)
          return n;
      }
    }
  }, qi = class extends Mr {
    static {
      s(this, "TreeTransformer");
    }
    constructor(t, r) {
      super(), this.before = t, this.after = r;
    }
  }, eh = 1, ey = 2, po = 4, Qc = 8, Zc = 16;
});

// ../node_modules/terser/lib/transform.js
function zt(e, t) {
  e.DEFMETHOD("transform", function(r, i) {
    let n;
    if (r.push(this), r.before && (n = r.before(this, t, i)), n === void 0 && (n = this, t(n, r), r.after)) {
      let a = r.after(n, i);
      a !== void 0 && (n = a);
    }
    return r.pop(), n;
  });
}
var jie = at(() => {
  "use strict";
  Di();
  Gi();
  s(zt, "def_transform");
  zt(Se, fn);
  zt(wr, function(e, t) {
    e.label = e.label.transform(t), e.body = e.body.transform(t);
  });
  zt(qe, function(e, t) {
    e.body = e.body.transform(t);
  });
  zt(Tr, function(e, t) {
    e.body = sr(e.body, t);
  });
  zt(Pn, function(e, t) {
    e.body = e.body.transform(t), e.condition = e.condition.transform(t);
  });
  zt(qn, function(e, t) {
    e.condition = e.condition.transform(t), e.body = e.body.transform(t);
  });
  zt(yr, function(e, t) {
    e.init && (e.init = e.init.transform(t)), e.condition && (e.condition = e.condition.transform(t)), e.step && (e.step = e.step.transform(
    t)), e.body = e.body.transform(t);
  });
  zt(Or, function(e, t) {
    e.init = e.init.transform(t), e.object = e.object.transform(t), e.body = e.body.transform(t);
  });
  zt(di, function(e, t) {
    e.expression = e.expression.transform(t), e.body = e.body.transform(t);
  });
  zt(cn, function(e, t) {
    e.value && (e.value = e.value.transform(t));
  });
  zt(Kn, function(e, t) {
    e.label && (e.label = e.label.transform(t));
  });
  zt(Ft, function(e, t) {
    e.condition = e.condition.transform(t), e.body = e.body.transform(t), e.alternative && (e.alternative = e.alternative.transform(t));
  });
  zt(Vr, function(e, t) {
    e.expression = e.expression.transform(t), e.body = sr(e.body, t);
  });
  zt(dn, function(e, t) {
    e.expression = e.expression.transform(t), e.body = sr(e.body, t);
  });
  zt(mi, function(e, t) {
    e.body = e.body.transform(t), e.bcatch && (e.bcatch = e.bcatch.transform(t)), e.bfinally && (e.bfinally = e.bfinally.transform(t));
  });
  zt(mn, function(e, t) {
    e.argname && (e.argname = e.argname.transform(t)), e.body = sr(e.body, t);
  });
  zt(cr, function(e, t) {
    e.definitions = sr(e.definitions, t);
  });
  zt(Lt, function(e, t) {
    e.name = e.name.transform(t), e.value && (e.value = e.value.transform(t));
  });
  zt(Ut, function(e, t) {
    e.names = sr(e.names, t);
  });
  zt(Ue, function(e, t) {
    e.name && (e.name = e.name.transform(t)), e.argnames = sr(
      e.argnames,
      t,
      /* allow_splicing */
      !1
    ), e.body instanceof Se ? e.body = e.body.transform(t) : e.body = sr(e.body, t);
  });
  zt(Fe, function(e, t) {
    e.expression = e.expression.transform(t), e.args = sr(
      e.args,
      t,
      /* allow_splicing */
      !1
    );
  });
  zt(Qe, function(e, t) {
    let r = sr(e.expressions, t);
    e.expressions = r.length ? r : [new We({ value: 0 })];
  });
  zt(je, function(e, t) {
    e.expression = e.expression.transform(t);
  });
  zt(fr, function(e, t) {
    e.expression = e.expression.transform(t), e.property = e.property.transform(t);
  });
  zt(er, function(e, t) {
    e.expression = e.expression.transform(t);
  });
  zt(Oi, function(e, t) {
    e.expression && (e.expression = e.expression.transform(t));
  });
  zt(Mi, function(e, t) {
    e.expression = e.expression.transform(t);
  });
  zt(Ht, function(e, t) {
    e.expression = e.expression.transform(t);
  });
  zt(ce, function(e, t) {
    e.left = e.left.transform(t), e.right = e.right.transform(t);
  });
  zt(Un, function(e, t) {
    e.key = e.key.transform(t), e.value = e.value.transform(t);
  });
  zt(it, function(e, t) {
    e.condition = e.condition.transform(t), e.consequent = e.consequent.transform(t), e.alternative = e.alternative.transform(t);
  });
  zt(pt, function(e, t) {
    e.elements = sr(e.elements, t);
  });
  zt(Tt, function(e, t) {
    e.properties = sr(e.properties, t);
  });
  zt(gr, function(e, t) {
    e.key instanceof Se && (e.key = e.key.transform(t)), e.value && (e.value = e.value.transform(t));
  });
  zt(ht, function(e, t) {
    e.name && (e.name = e.name.transform(t)), e.extends && (e.extends = e.extends.transform(t)), e.properties = sr(e.properties, t);
  });
  zt(Hr, function(e, t) {
    e.body = sr(e.body, t);
  });
  zt(ft, function(e, t) {
    e.expression = e.expression.transform(t);
  });
  zt(Cn, function(e, t) {
    e.foreign_name = e.foreign_name.transform(t), e.name = e.name.transform(t);
  });
  zt(yi, function(e, t) {
    e.imported_name && (e.imported_name = e.imported_name.transform(t)), e.imported_names && sr(e.imported_names, t), e.module_name = e.module_name.
    transform(t);
  });
  zt(dr, function(e, t) {
    e.exported_definition && (e.exported_definition = e.exported_definition.transform(t)), e.exported_value && (e.exported_value = e.exported_value.
    transform(t)), e.exported_names && sr(e.exported_names, t), e.module_name && (e.module_name = e.module_name.transform(t));
  });
  zt(jr, function(e, t) {
    e.segments = sr(e.segments, t);
  });
  zt(pn, function(e, t) {
    e.prefix = e.prefix.transform(t), e.template_string = e.template_string.transform(t);
  });
});

// ../node_modules/terser/lib/mozilla-ast.js
var Vie = at(() => {
  Gi();
  Di();
  Rl();
  (function() {
    var e = /* @__PURE__ */ s(function(m) {
      for (var f = 0; f < m.length; f++)
        if (m[f] instanceof Br && m[f].body instanceof bt)
          m[f] = new wi({
            start: m[f].start,
            end: m[f].end,
            value: m[f].body.value
          });
        else
          return m;
      return m;
    }, "normalize_directives");
    function t(m) {
      return m && m.length > 0 ? new Tt({
        start: n(m),
        end: a(m),
        properties: m.map(
          (f) => new Nt({
            start: n(f),
            end: a(f),
            key: f.key.name || f.key.value,
            value: u(f.value)
          })
        )
      }) : null;
    }
    s(t, "import_attributes_from_moz");
    var r = {
      Program: /* @__PURE__ */ s(function(m) {
        return new Kt({
          start: n(m),
          end: a(m),
          body: e(m.body.map(u))
        });
      }, "Program"),
      ArrayPattern: /* @__PURE__ */ s(function(m) {
        return new Ut({
          start: n(m),
          end: a(m),
          names: m.elements.map(function(f) {
            return f === null ? new xn() : u(f);
          }),
          is_array: !0
        });
      }, "ArrayPattern"),
      ObjectPattern: /* @__PURE__ */ s(function(m) {
        return new Ut({
          start: n(m),
          end: a(m),
          names: m.properties.map(u),
          is_array: !1
        });
      }, "ObjectPattern"),
      AssignmentPattern: /* @__PURE__ */ s(function(m) {
        return new sn({
          start: n(m),
          end: a(m),
          left: u(m.left),
          operator: "=",
          right: u(m.right)
        });
      }, "AssignmentPattern"),
      SpreadElement: /* @__PURE__ */ s(function(m) {
        return new ft({
          start: n(m),
          end: a(m),
          expression: u(m.argument)
        });
      }, "SpreadElement"),
      RestElement: /* @__PURE__ */ s(function(m) {
        return new ft({
          start: n(m),
          end: a(m),
          expression: u(m.argument)
        });
      }, "RestElement"),
      TemplateElement: /* @__PURE__ */ s(function(m) {
        return new Bn({
          start: n(m),
          end: a(m),
          value: m.value.cooked,
          raw: m.value.raw
        });
      }, "TemplateElement"),
      TemplateLiteral: /* @__PURE__ */ s(function(m) {
        for (var f = [], d = 0; d < m.quasis.length; d++)
          f.push(u(m.quasis[d])), m.expressions[d] && f.push(u(m.expressions[d]));
        return new jr({
          start: n(m),
          end: a(m),
          segments: f
        });
      }, "TemplateLiteral"),
      TaggedTemplateExpression: /* @__PURE__ */ s(function(m) {
        return new pn({
          start: n(m),
          end: a(m),
          template_string: u(m.quasi),
          prefix: u(m.tag)
        });
      }, "TaggedTemplateExpression"),
      FunctionDeclaration: /* @__PURE__ */ s(function(m) {
        return new tr({
          start: n(m),
          end: a(m),
          name: u(m.id),
          argnames: m.params.map(u),
          is_generator: m.generator,
          async: m.async,
          body: e(u(m.body).body)
        });
      }, "FunctionDeclaration"),
      FunctionExpression: /* @__PURE__ */ s(function(m) {
        return new jt({
          start: n(m),
          end: a(m),
          name: u(m.id),
          argnames: m.params.map(u),
          is_generator: m.generator,
          async: m.async,
          body: e(u(m.body).body)
        });
      }, "FunctionExpression"),
      ArrowFunctionExpression: /* @__PURE__ */ s(function(m) {
        let f = m.body.type === "BlockStatement" ? u(m.body).body : [k(mr, {}, { value: u(m.body) })];
        return new Zt({
          start: n(m),
          end: a(m),
          argnames: m.params.map(u),
          body: f,
          async: m.async
        });
      }, "ArrowFunctionExpression"),
      ExpressionStatement: /* @__PURE__ */ s(function(m) {
        return new qe({
          start: n(m),
          end: a(m),
          body: u(m.expression)
        });
      }, "ExpressionStatement"),
      TryStatement: /* @__PURE__ */ s(function(m) {
        var f = m.handlers || [m.handler];
        if (f.length > 1 || m.guardedHandlers && m.guardedHandlers.length)
          throw new Error("Multiple catch clauses are not supported.");
        return new mi({
          start: n(m),
          end: a(m),
          body: new Nl(u(m.block)),
          bcatch: u(f[0]),
          bfinally: m.finalizer ? new uo(u(m.finalizer)) : null
        });
      }, "TryStatement"),
      Property: /* @__PURE__ */ s(function(m) {
        var f = m.key, d = {
          start: n(f || m.value),
          end: a(m.value),
          key: f.type == "Identifier" ? f.name : f.value,
          value: u(m.value)
        };
        if (m.computed && (d.key = u(m.key)), m.method)
          return d.is_generator = m.value.generator, d.async = m.value.async, m.computed ? d.key = u(m.key) : d.key = new hi({ name: d.key }),
          new Kr(d);
        if (m.kind == "init")
          return f.type != "Identifier" && f.type != "Literal" && (d.key = u(f)), new Nt(d);
        if ((typeof d.key == "string" || typeof d.key == "number") && (d.key = new hi({
          name: d.key
        })), d.value = new rs(d.value), m.kind == "get") return new yn(d);
        if (m.kind == "set") return new On(d);
        if (m.kind == "method")
          return d.async = m.value.async, d.is_generator = m.value.generator, d.quote = m.computed ? '"' : null, new Kr(d);
      }, "Property"),
      MethodDefinition: /* @__PURE__ */ s(function(m) {
        let f = m.key.type === "PrivateIdentifier", d = m.computed ? u(m.key) : new hi({ name: m.key.name || m.key.value });
        var v = {
          start: n(m),
          end: a(m),
          key: d,
          value: u(m.value),
          static: m.static
        };
        return m.kind == "get" ? new (f ? $i : yn)(v) : m.kind == "set" ? new (f ? on : On)(v) : (v.is_generator = m.value.generator, v.async =
        m.value.async, new (f ? ki : Kr)(v));
      }, "MethodDefinition"),
      FieldDefinition: /* @__PURE__ */ s(function(m) {
        let f;
        if (m.computed)
          f = u(m.key);
        else {
          if (m.key.type !== "Identifier") throw new Error("Non-Identifier key in FieldDefinition");
          f = u(m.key);
        }
        return new Bi({
          start: n(m),
          end: a(m),
          key: f,
          value: u(m.value),
          static: m.static
        });
      }, "FieldDefinition"),
      PropertyDefinition: /* @__PURE__ */ s(function(m) {
        let f;
        if (m.computed)
          f = u(m.key);
        else {
          if (m.key.type === "PrivateIdentifier")
            return new Ii({
              start: n(m),
              end: a(m),
              key: u(m.key),
              value: u(m.value),
              static: m.static
            });
          if (m.key.type !== "Identifier")
            throw new Error("Non-Identifier key in PropertyDefinition");
          f = u(m.key);
        }
        return new Bi({
          start: n(m),
          end: a(m),
          key: f,
          value: u(m.value),
          static: m.static
        });
      }, "PropertyDefinition"),
      PrivateIdentifier: /* @__PURE__ */ s(function(m) {
        return new Fl({
          start: n(m),
          end: a(m),
          name: m.name
        });
      }, "PrivateIdentifier"),
      StaticBlock: /* @__PURE__ */ s(function(m) {
        return new Hr({
          start: n(m),
          end: a(m),
          body: m.body.map(u)
        });
      }, "StaticBlock"),
      ArrayExpression: /* @__PURE__ */ s(function(m) {
        return new pt({
          start: n(m),
          end: a(m),
          elements: m.elements.map(function(f) {
            return f === null ? new xn() : u(f);
          })
        });
      }, "ArrayExpression"),
      ObjectExpression: /* @__PURE__ */ s(function(m) {
        return new Tt({
          start: n(m),
          end: a(m),
          properties: m.properties.map(function(f) {
            return f.type === "SpreadElement" || (f.type = "Property"), u(f);
          })
        });
      }, "ObjectExpression"),
      SequenceExpression: /* @__PURE__ */ s(function(m) {
        return new Qe({
          start: n(m),
          end: a(m),
          expressions: m.expressions.map(u)
        });
      }, "SequenceExpression"),
      MemberExpression: /* @__PURE__ */ s(function(m) {
        return m.property.type === "PrivateIdentifier" ? new Wi({
          start: n(m),
          end: a(m),
          property: m.property.name,
          expression: u(m.object),
          optional: m.optional || !1
        }) : new (m.computed ? fr : It)({
          start: n(m),
          end: a(m),
          property: m.computed ? u(m.property) : m.property.name,
          expression: u(m.object),
          optional: m.optional || !1
        });
      }, "MemberExpression"),
      ChainExpression: /* @__PURE__ */ s(function(m) {
        return new er({
          start: n(m),
          end: a(m),
          expression: u(m.expression)
        });
      }, "ChainExpression"),
      SwitchCase: /* @__PURE__ */ s(function(m) {
        return new (m.test ? dn : zs)({
          start: n(m),
          end: a(m),
          expression: u(m.test),
          body: m.consequent.map(u)
        });
      }, "SwitchCase"),
      VariableDeclaration: /* @__PURE__ */ s(function(m) {
        return new (m.kind === "const" ? wn : m.kind === "let" ? Dn : Fr)({
          start: n(m),
          end: a(m),
          definitions: m.declarations.map(u)
        });
      }, "VariableDeclaration"),
      ImportDeclaration: /* @__PURE__ */ s(function(m) {
        var f = null, d = null;
        return m.specifiers.forEach(function(v) {
          v.type === "ImportSpecifier" || v.type === "ImportNamespaceSpecifier" ? (d || (d = []), d.push(u(v))) : v.type === "ImportDefaultS\
pecifier" && (f = u(v));
        }), new yi({
          start: n(m),
          end: a(m),
          imported_name: f,
          imported_names: d,
          module_name: u(m.source),
          attributes: t(m.attributes || m.assertions)
        });
      }, "ImportDeclaration"),
      ImportSpecifier: /* @__PURE__ */ s(function(m) {
        return new Cn({
          start: n(m),
          end: a(m),
          foreign_name: u(m.imported),
          name: u(m.local)
        });
      }, "ImportSpecifier"),
      ImportDefaultSpecifier: /* @__PURE__ */ s(function(m) {
        return u(m.local);
      }, "ImportDefaultSpecifier"),
      ImportNamespaceSpecifier: /* @__PURE__ */ s(function(m) {
        return new Cn({
          start: n(m),
          end: a(m),
          foreign_name: new Wo({ name: "*" }),
          name: u(m.local)
        });
      }, "ImportNamespaceSpecifier"),
      ImportExpression: /* @__PURE__ */ s(function(m) {
        let f = [u(m.source)];
        return m.options && f.push(u(m.options)), new Fe({
          start: n(m),
          end: a(m),
          expression: u({
            type: "Identifier",
            name: "import"
          }),
          optional: !1,
          args: f
        });
      }, "ImportExpression"),
      ExportAllDeclaration: /* @__PURE__ */ s(function(m) {
        var f = m.exported == null ? new oa({ name: "*" }) : u(m.exported);
        return new dr({
          start: n(m),
          end: a(m),
          exported_names: [
            new Cn({
              name: new oa({ name: "*" }),
              foreign_name: f
            })
          ],
          module_name: u(m.source),
          attributes: t(m.attributes || m.assertions)
        });
      }, "ExportAllDeclaration"),
      ExportNamedDeclaration: /* @__PURE__ */ s(function(m) {
        return new dr({
          start: n(m),
          end: a(m),
          exported_definition: u(m.declaration),
          exported_names: m.specifiers && m.specifiers.length ? m.specifiers.map(u) : null,
          module_name: u(m.source),
          attributes: t(m.attributes || m.assertions)
        });
      }, "ExportNamedDeclaration"),
      ExportDefaultDeclaration: /* @__PURE__ */ s(function(m) {
        return new dr({
          start: n(m),
          end: a(m),
          exported_value: u(m.declaration),
          is_default: !0
        });
      }, "ExportDefaultDeclaration"),
      ExportSpecifier: /* @__PURE__ */ s(function(m) {
        return new Cn({
          foreign_name: u(m.exported),
          name: u(m.local)
        });
      }, "ExportSpecifier"),
      Literal: /* @__PURE__ */ s(function(m) {
        var f = m.value, d = {
          start: n(m),
          end: a(m)
        }, v = m.regex;
        if (v && v.pattern)
          return d.value = {
            source: v.pattern,
            flags: v.flags
          }, new $r(d);
        if (v) {
          let x = m.raw || f, C = x.match(/^\/(.*)\/(\w*)$/);
          if (!C) throw new Error("Invalid regex source " + x);
          let [z, w, D] = C;
          return d.value = { source: w, flags: D }, new $r(d);
        }
        let E = typeof m.value == "bigint" ? m.value.toString() : m.bigint;
        if (typeof E == "string")
          return d.value = E, new un(d);
        if (f === null) return new Xi(d);
        switch (typeof f) {
          case "string":
            d.quote = '"';
            var S = o[o.length - 2];
            return S.type == "ImportSpecifier" ? (d.name = f, new Wo(d)) : S.type == "ExportSpecifier" ? (d.name = f, m == S.exported ? new oa(
            d) : new oo(d)) : S.type == "ExportAllDeclaration" && m == S.exported ? (d.name = f, new oa(d)) : (d.value = f, new bt(d));
          case "number":
            return d.value = f, d.raw = m.raw || f.toString(), new We(d);
          case "boolean":
            return new (f ? ln : Ss)(d);
        }
      }, "Literal"),
      MetaProperty: /* @__PURE__ */ s(function(m) {
        if (m.meta.name === "new" && m.property.name === "target")
          return new lo({
            start: n(m),
            end: a(m)
          });
        if (m.meta.name === "import" && m.property.name === "meta")
          return new ss({
            start: n(m),
            end: a(m)
          });
      }, "MetaProperty"),
      Identifier: /* @__PURE__ */ s(function(m) {
        var f = o[o.length - 2];
        return new (f.type == "LabeledStatement" ? Ll : f.type == "VariableDeclarator" && f.id === m ? f.kind == "const" ? la : f.kind == "l\
et" ? co : bs : /Import.*Specifier/.test(f.type) ? f.local === m ? Fu : Wo : f.type == "ExportSpecifier" ? f.local === m ? oo : oa : f.type ==
        "FunctionExpression" ? f.id === m ? kn : Nr : f.type == "FunctionDeclaration" ? f.id === m ? jn : Nr : f.type == "ArrowFunctionExpre\
ssion" ? f.params.includes(m) ? Nr : Te : f.type == "ClassExpression" ? f.id === m ? Jc : Te : f.type == "Property" ? f.key === m && f.computed ||
        f.value === m ? Te : hi : f.type == "PropertyDefinition" || f.type === "FieldDefinition" ? f.key === m && f.computed || f.value === m ?
        Te : vs : f.type == "ClassDeclaration" ? f.id === m ? Yc : Te : f.type == "MethodDefinition" ? f.computed ? Te : hi : f.type == "Cat\
chClause" ? Vn : f.type == "BreakStatement" || f.type == "ContinueStatement" ? Zp : Te)({
          start: n(m),
          end: a(m),
          name: m.name
        });
      }, "Identifier"),
      EmptyStatement: /* @__PURE__ */ s(function(m) {
        return new Rt({
          start: n(m),
          end: a(m)
        });
      }, "EmptyStatement"),
      BlockStatement: /* @__PURE__ */ s(function(m) {
        return new ot({
          start: n(m),
          end: a(m),
          body: m.body.map(u)
        });
      }, "BlockStatement"),
      IfStatement: /* @__PURE__ */ s(function(m) {
        return new Ft({
          start: n(m),
          end: a(m),
          condition: u(m.test),
          body: u(m.consequent),
          alternative: u(m.alternate)
        });
      }, "IfStatement"),
      LabeledStatement: /* @__PURE__ */ s(function(m) {
        return new wr({
          start: n(m),
          end: a(m),
          label: u(m.label),
          body: u(m.body)
        });
      }, "LabeledStatement"),
      BreakStatement: /* @__PURE__ */ s(function(m) {
        return new hn({
          start: n(m),
          end: a(m),
          label: u(m.label)
        });
      }, "BreakStatement"),
      ContinueStatement: /* @__PURE__ */ s(function(m) {
        return new ua({
          start: n(m),
          end: a(m),
          label: u(m.label)
        });
      }, "ContinueStatement"),
      WithStatement: /* @__PURE__ */ s(function(m) {
        return new di({
          start: n(m),
          end: a(m),
          expression: u(m.object),
          body: u(m.body)
        });
      }, "WithStatement"),
      SwitchStatement: /* @__PURE__ */ s(function(m) {
        return new Vr({
          start: n(m),
          end: a(m),
          expression: u(m.discriminant),
          body: m.cases.map(u)
        });
      }, "SwitchStatement"),
      ReturnStatement: /* @__PURE__ */ s(function(m) {
        return new mr({
          start: n(m),
          end: a(m),
          value: u(m.argument)
        });
      }, "ReturnStatement"),
      ThrowStatement: /* @__PURE__ */ s(function(m) {
        return new Bu({
          start: n(m),
          end: a(m),
          value: u(m.argument)
        });
      }, "ThrowStatement"),
      WhileStatement: /* @__PURE__ */ s(function(m) {
        return new qn({
          start: n(m),
          end: a(m),
          condition: u(m.test),
          body: u(m.body)
        });
      }, "WhileStatement"),
      DoWhileStatement: /* @__PURE__ */ s(function(m) {
        return new Pn({
          start: n(m),
          end: a(m),
          condition: u(m.test),
          body: u(m.body)
        });
      }, "DoWhileStatement"),
      ForStatement: /* @__PURE__ */ s(function(m) {
        return new yr({
          start: n(m),
          end: a(m),
          init: u(m.init),
          condition: u(m.test),
          step: u(m.update),
          body: u(m.body)
        });
      }, "ForStatement"),
      ForInStatement: /* @__PURE__ */ s(function(m) {
        return new Or({
          start: n(m),
          end: a(m),
          init: u(m.left),
          object: u(m.right),
          body: u(m.body)
        });
      }, "ForInStatement"),
      ForOfStatement: /* @__PURE__ */ s(function(m) {
        return new ka({
          start: n(m),
          end: a(m),
          init: u(m.left),
          object: u(m.right),
          body: u(m.body),
          await: m.await
        });
      }, "ForOfStatement"),
      AwaitExpression: /* @__PURE__ */ s(function(m) {
        return new Mi({
          start: n(m),
          end: a(m),
          expression: u(m.argument)
        });
      }, "AwaitExpression"),
      YieldExpression: /* @__PURE__ */ s(function(m) {
        return new Oi({
          start: n(m),
          end: a(m),
          expression: u(m.argument),
          is_star: m.delegate
        });
      }, "YieldExpression"),
      DebuggerStatement: /* @__PURE__ */ s(function(m) {
        return new is({
          start: n(m),
          end: a(m)
        });
      }, "DebuggerStatement"),
      VariableDeclarator: /* @__PURE__ */ s(function(m) {
        return new Lt({
          start: n(m),
          end: a(m),
          name: u(m.id),
          value: u(m.init)
        });
      }, "VariableDeclarator"),
      CatchClause: /* @__PURE__ */ s(function(m) {
        return new mn({
          start: n(m),
          end: a(m),
          argname: u(m.param),
          body: u(m.body).body
        });
      }, "CatchClause"),
      ThisExpression: /* @__PURE__ */ s(function(m) {
        return new kr({
          start: n(m),
          end: a(m)
        });
      }, "ThisExpression"),
      Super: /* @__PURE__ */ s(function(m) {
        return new fo({
          start: n(m),
          end: a(m)
        });
      }, "Super"),
      BinaryExpression: /* @__PURE__ */ s(function(m) {
        return m.left.type === "PrivateIdentifier" ? new Un({
          start: n(m),
          end: a(m),
          key: new Fl({
            start: n(m.left),
            end: a(m.left),
            name: m.left.name
          }),
          value: u(m.right)
        }) : new ce({
          start: n(m),
          end: a(m),
          operator: m.operator,
          left: u(m.left),
          right: u(m.right)
        });
      }, "BinaryExpression"),
      LogicalExpression: /* @__PURE__ */ s(function(m) {
        return new ce({
          start: n(m),
          end: a(m),
          operator: m.operator,
          left: u(m.left),
          right: u(m.right)
        });
      }, "LogicalExpression"),
      AssignmentExpression: /* @__PURE__ */ s(function(m) {
        return new ct({
          start: n(m),
          end: a(m),
          operator: m.operator,
          left: u(m.left),
          right: u(m.right)
        });
      }, "AssignmentExpression"),
      ConditionalExpression: /* @__PURE__ */ s(function(m) {
        return new it({
          start: n(m),
          end: a(m),
          condition: u(m.test),
          consequent: u(m.consequent),
          alternative: u(m.alternate)
        });
      }, "ConditionalExpression"),
      NewExpression: /* @__PURE__ */ s(function(m) {
        return new gi({
          start: n(m),
          end: a(m),
          expression: u(m.callee),
          args: m.arguments.map(u)
        });
      }, "NewExpression"),
      CallExpression: /* @__PURE__ */ s(function(m) {
        return new Fe({
          start: n(m),
          end: a(m),
          expression: u(m.callee),
          optional: m.optional,
          args: m.arguments.map(u)
        });
      }, "CallExpression")
    };
    r.UpdateExpression = r.UnaryExpression = /* @__PURE__ */ s(function(f) {
      var d = "prefix" in f ? f.prefix : f.type == "UnaryExpression";
      return new (d ? $e : as)({
        start: n(f),
        end: a(f),
        operator: f.operator,
        expression: u(f.argument)
      });
    }, "To_Moz_Unary"), r.ClassDeclaration = r.ClassExpression = /* @__PURE__ */ s(function(f) {
      return new (f.type === "ClassDeclaration" ? an : ts)({
        start: n(f),
        end: a(f),
        name: u(f.id),
        extends: u(f.superClass),
        properties: f.body.body.map(u)
      });
    }, "From_Moz_Class"), c(Rt, /* @__PURE__ */ s(function() {
      return {
        type: "EmptyStatement"
      };
    }, "To_Moz_EmptyStatement")), c(ot, /* @__PURE__ */ s(function(f) {
      return {
        type: "BlockStatement",
        body: f.body.map(h)
      };
    }, "To_Moz_BlockStatement")), c(Ft, /* @__PURE__ */ s(function(f) {
      return {
        type: "IfStatement",
        test: h(f.condition),
        consequent: h(f.body),
        alternate: h(f.alternative)
      };
    }, "To_Moz_IfStatement")), c(wr, /* @__PURE__ */ s(function(f) {
      return {
        type: "LabeledStatement",
        label: h(f.label),
        body: h(f.body)
      };
    }, "To_Moz_LabeledStatement")), c(hn, /* @__PURE__ */ s(function(f) {
      return {
        type: "BreakStatement",
        label: h(f.label)
      };
    }, "To_Moz_BreakStatement")), c(ua, /* @__PURE__ */ s(function(f) {
      return {
        type: "ContinueStatement",
        label: h(f.label)
      };
    }, "To_Moz_ContinueStatement")), c(di, /* @__PURE__ */ s(function(f) {
      return {
        type: "WithStatement",
        object: h(f.expression),
        body: h(f.body)
      };
    }, "To_Moz_WithStatement")), c(Vr, /* @__PURE__ */ s(function(f) {
      return {
        type: "SwitchStatement",
        discriminant: h(f.expression),
        cases: f.body.map(h)
      };
    }, "To_Moz_SwitchStatement")), c(mr, /* @__PURE__ */ s(function(f) {
      return {
        type: "ReturnStatement",
        argument: h(f.value)
      };
    }, "To_Moz_ReturnStatement")), c(Bu, /* @__PURE__ */ s(function(f) {
      return {
        type: "ThrowStatement",
        argument: h(f.value)
      };
    }, "To_Moz_ThrowStatement")), c(qn, /* @__PURE__ */ s(function(f) {
      return {
        type: "WhileStatement",
        test: h(f.condition),
        body: h(f.body)
      };
    }, "To_Moz_WhileStatement")), c(Pn, /* @__PURE__ */ s(function(f) {
      return {
        type: "DoWhileStatement",
        test: h(f.condition),
        body: h(f.body)
      };
    }, "To_Moz_DoWhileStatement")), c(yr, /* @__PURE__ */ s(function(f) {
      return {
        type: "ForStatement",
        init: h(f.init),
        test: h(f.condition),
        update: h(f.step),
        body: h(f.body)
      };
    }, "To_Moz_ForStatement")), c(Or, /* @__PURE__ */ s(function(f) {
      return {
        type: "ForInStatement",
        left: h(f.init),
        right: h(f.object),
        body: h(f.body)
      };
    }, "To_Moz_ForInStatement")), c(ka, /* @__PURE__ */ s(function(f) {
      return {
        type: "ForOfStatement",
        left: h(f.init),
        right: h(f.object),
        body: h(f.body),
        await: f.await
      };
    }, "To_Moz_ForOfStatement")), c(Mi, /* @__PURE__ */ s(function(f) {
      return {
        type: "AwaitExpression",
        argument: h(f.expression)
      };
    }, "To_Moz_AwaitExpression")), c(Oi, /* @__PURE__ */ s(function(f) {
      return {
        type: "YieldExpression",
        argument: h(f.expression),
        delegate: f.is_star
      };
    }, "To_Moz_YieldExpression")), c(is, /* @__PURE__ */ s(function() {
      return {
        type: "DebuggerStatement"
      };
    }, "To_Moz_DebuggerStatement")), c(Lt, /* @__PURE__ */ s(function(f) {
      return {
        type: "VariableDeclarator",
        id: h(f.name),
        init: h(f.value)
      };
    }, "To_Moz_VariableDeclarator")), c(mn, /* @__PURE__ */ s(function(f) {
      return {
        type: "CatchClause",
        param: h(f.argname),
        body: _(f)
      };
    }, "To_Moz_CatchClause")), c(kr, /* @__PURE__ */ s(function() {
      return {
        type: "ThisExpression"
      };
    }, "To_Moz_ThisExpression")), c(fo, /* @__PURE__ */ s(function() {
      return {
        type: "Super"
      };
    }, "To_Moz_Super")), c(ce, /* @__PURE__ */ s(function(f) {
      return {
        type: "BinaryExpression",
        operator: f.operator,
        left: h(f.left),
        right: h(f.right)
      };
    }, "To_Moz_BinaryExpression")), c(ce, /* @__PURE__ */ s(function(f) {
      return {
        type: "LogicalExpression",
        operator: f.operator,
        left: h(f.left),
        right: h(f.right)
      };
    }, "To_Moz_LogicalExpression")), c(ct, /* @__PURE__ */ s(function(f) {
      return {
        type: "AssignmentExpression",
        operator: f.operator,
        left: h(f.left),
        right: h(f.right)
      };
    }, "To_Moz_AssignmentExpression")), c(it, /* @__PURE__ */ s(function(f) {
      return {
        type: "ConditionalExpression",
        test: h(f.condition),
        consequent: h(f.consequent),
        alternate: h(f.alternative)
      };
    }, "To_Moz_ConditionalExpression")), c(gi, /* @__PURE__ */ s(function(f) {
      return {
        type: "NewExpression",
        callee: h(f.expression),
        arguments: f.args.map(h)
      };
    }, "To_Moz_NewExpression")), c(Fe, /* @__PURE__ */ s(function(f) {
      if (f.expression instanceof Te && f.expression.name === "import") {
        let [d, v] = f.args.map(h);
        return {
          type: "ImportExpression",
          source: d,
          options: v
        };
      }
      return {
        type: "CallExpression",
        callee: h(f.expression),
        optional: f.optional,
        arguments: f.args.map(h)
      };
    }, "To_Moz_CallExpression")), c(Kt, /* @__PURE__ */ s(function(f) {
      return g("Program", f);
    }, "To_Moz_Program")), c(ft, /* @__PURE__ */ s(function(f) {
      return {
        type: y() ? "RestElement" : "SpreadElement",
        argument: h(f.expression)
      };
    }, "To_Moz_Spread")), c(pn, /* @__PURE__ */ s(function(f) {
      return {
        type: "TaggedTemplateExpression",
        tag: h(f.prefix),
        quasi: h(f.template_string)
      };
    }, "To_Moz_TaggedTemplateExpression")), c(jr, /* @__PURE__ */ s(function(f) {
      for (var d = [], v = [], E = 0; E < f.segments.length; E++)
        E % 2 !== 0 ? v.push(h(f.segments[E])) : d.push({
          type: "TemplateElement",
          value: {
            raw: f.segments[E].raw,
            cooked: f.segments[E].value
          },
          tail: E === f.segments.length - 1
        });
      return {
        type: "TemplateLiteral",
        quasis: d,
        expressions: v
      };
    }, "To_Moz_TemplateLiteral")), c(tr, /* @__PURE__ */ s(function(f) {
      return {
        type: "FunctionDeclaration",
        id: h(f.name),
        params: f.argnames.map(h),
        generator: f.is_generator,
        async: f.async,
        body: g("BlockStatement", f)
      };
    }, "To_Moz_FunctionDeclaration")), c(jt, /* @__PURE__ */ s(function(f, d) {
      var v = d.is_generator !== void 0 ? d.is_generator : f.is_generator;
      return {
        type: "FunctionExpression",
        id: h(f.name),
        params: f.argnames.map(h),
        generator: v,
        async: f.async,
        body: g("BlockStatement", f)
      };
    }, "To_Moz_FunctionExpression")), c(Zt, /* @__PURE__ */ s(function(f) {
      var d = {
        type: "BlockStatement",
        body: f.body.map(h)
      };
      return {
        type: "ArrowFunctionExpression",
        params: f.argnames.map(h),
        async: f.async,
        body: d
      };
    }, "To_Moz_ArrowFunctionExpression")), c(Ut, /* @__PURE__ */ s(function(f) {
      return f.is_array ? {
        type: "ArrayPattern",
        elements: f.names.map(h)
      } : {
        type: "ObjectPattern",
        properties: f.names.map(h)
      };
    }, "To_Moz_ObjectPattern")), c(wi, /* @__PURE__ */ s(function(f) {
      return {
        type: "ExpressionStatement",
        expression: {
          type: "Literal",
          value: f.value,
          raw: f.print_to_string()
        },
        directive: f.value
      };
    }, "To_Moz_Directive")), c(qe, /* @__PURE__ */ s(function(f) {
      return {
        type: "ExpressionStatement",
        expression: h(f.body)
      };
    }, "To_Moz_ExpressionStatement")), c(Ts, /* @__PURE__ */ s(function(f) {
      return {
        type: "SwitchCase",
        test: h(f.expression),
        consequent: f.body.map(h)
      };
    }, "To_Moz_SwitchCase")), c(mi, /* @__PURE__ */ s(function(f) {
      return {
        type: "TryStatement",
        block: _(f.body),
        handler: h(f.bcatch),
        guardedHandlers: [],
        finalizer: h(f.bfinally)
      };
    }, "To_Moz_TryStatement")), c(mn, /* @__PURE__ */ s(function(f) {
      return {
        type: "CatchClause",
        param: h(f.argname),
        guard: null,
        body: _(f)
      };
    }, "To_Moz_CatchClause")), c(cr, /* @__PURE__ */ s(function(f) {
      return {
        type: "VariableDeclaration",
        kind: f instanceof wn ? "const" : f instanceof Dn ? "let" : "var",
        declarations: f.definitions.map(h)
      };
    }, "To_Moz_VariableDeclaration"));
    function i(m) {
      let f = [];
      if (m)
        for (let { key: d, value: v } of m.properties) {
          let E = Xc(d) ? { type: "Identifier", name: d } : { type: "Literal", value: d, raw: JSON.stringify(d) };
          f.push({
            type: "ImportAttribute",
            key: E,
            value: h(v)
          });
        }
      return f;
    }
    s(i, "import_attributes_to_moz"), c(dr, /* @__PURE__ */ s(function(f) {
      if (f.exported_names) {
        var d = f.exported_names[0], v = d.name;
        if (v.name === "*" && !v.quote) {
          var E = d.foreign_name, S = E.name === "*" && !E.quote ? null : h(E);
          return {
            type: "ExportAllDeclaration",
            source: h(f.module_name),
            exported: S,
            attributes: i(f.attributes)
          };
        }
        return {
          type: "ExportNamedDeclaration",
          specifiers: f.exported_names.map(function(x) {
            return {
              type: "ExportSpecifier",
              exported: h(x.foreign_name),
              local: h(x.name)
            };
          }),
          declaration: h(f.exported_definition),
          source: h(f.module_name),
          attributes: i(f.attributes)
        };
      }
      return {
        type: f.is_default ? "ExportDefaultDeclaration" : "ExportNamedDeclaration",
        declaration: h(f.exported_value || f.exported_definition)
      };
    }, "To_Moz_ExportDeclaration")), c(yi, /* @__PURE__ */ s(function(f) {
      var d = [];
      if (f.imported_name && d.push({
        type: "ImportDefaultSpecifier",
        local: h(f.imported_name)
      }), f.imported_names) {
        var v = f.imported_names[0].foreign_name;
        v.name === "*" && !v.quote ? d.push({
          type: "ImportNamespaceSpecifier",
          local: h(f.imported_names[0].name)
        }) : f.imported_names.forEach(function(E) {
          d.push({
            type: "ImportSpecifier",
            local: h(E.name),
            imported: h(E.foreign_name)
          });
        });
      }
      return {
        type: "ImportDeclaration",
        specifiers: d,
        source: h(f.module_name),
        attributes: i(f.attributes)
      };
    }, "To_Moz_ImportDeclaration")), c(ss, /* @__PURE__ */ s(function() {
      return {
        type: "MetaProperty",
        meta: {
          type: "Identifier",
          name: "import"
        },
        property: {
          type: "Identifier",
          name: "meta"
        }
      };
    }, "To_Moz_MetaProperty")), c(Qe, /* @__PURE__ */ s(function(f) {
      return {
        type: "SequenceExpression",
        expressions: f.expressions.map(h)
      };
    }, "To_Moz_SequenceExpression")), c(Wi, /* @__PURE__ */ s(function(f) {
      return {
        type: "MemberExpression",
        object: h(f.expression),
        computed: !1,
        property: {
          type: "PrivateIdentifier",
          name: f.property
        },
        optional: f.optional
      };
    }, "To_Moz_PrivateMemberExpression")), c(je, /* @__PURE__ */ s(function(f) {
      var d = f instanceof fr;
      return {
        type: "MemberExpression",
        object: h(f.expression),
        computed: d,
        property: d ? h(f.property) : { type: "Identifier", name: f.property },
        optional: f.optional
      };
    }, "To_Moz_MemberExpression")), c(er, /* @__PURE__ */ s(function(f) {
      return {
        type: "ChainExpression",
        expression: h(f.expression)
      };
    }, "To_Moz_ChainExpression")), c(Ht, /* @__PURE__ */ s(function(f) {
      return {
        type: f.operator == "++" || f.operator == "--" ? "UpdateExpression" : "UnaryExpression",
        operator: f.operator,
        prefix: f instanceof $e,
        argument: h(f.expression)
      };
    }, "To_Moz_Unary")), c(ce, /* @__PURE__ */ s(function(f) {
      return f.operator == "=" && y() ? {
        type: "AssignmentPattern",
        left: h(f.left),
        right: h(f.right)
      } : {
        type: f.operator == "&&" || f.operator == "||" || f.operator === "??" ? "LogicalExpression" : "BinaryExpression",
        left: h(f.left),
        operator: f.operator,
        right: h(f.right)
      };
    }, "To_Moz_BinaryExpression")), c(Un, /* @__PURE__ */ s(function(f) {
      return {
        type: "BinaryExpression",
        left: { type: "PrivateIdentifier", name: f.key.name },
        operator: "in",
        right: h(f.value)
      };
    }, "To_Moz_BinaryExpression_PrivateIn")), c(pt, /* @__PURE__ */ s(function(f) {
      return {
        type: "ArrayExpression",
        elements: f.elements.map(h)
      };
    }, "To_Moz_ArrayExpression")), c(Tt, /* @__PURE__ */ s(function(f) {
      return {
        type: "ObjectExpression",
        properties: f.properties.map(h)
      };
    }, "To_Moz_ObjectExpression")), c(gr, /* @__PURE__ */ s(function(f, d) {
      var v = f.key instanceof Se ? h(f.key) : {
        type: "Identifier",
        value: f.key
      };
      typeof f.key == "number" && (v = {
        type: "Literal",
        value: Number(f.key)
      }), typeof f.key == "string" && (v = {
        type: "Identifier",
        name: f.key
      });
      var E, S = typeof f.key == "string" || typeof f.key == "number", x = S ? !1 : !(f.key instanceof gt) || f.key instanceof Te;
      return f instanceof Nt ? (E = "init", x = !S) : f instanceof yn ? E = "get" : f instanceof On && (E = "set"), f instanceof $i || f instanceof
      on ? {
        type: "MethodDefinition",
        computed: !1,
        kind: f instanceof $i ? "get" : "set",
        static: f.static,
        key: {
          type: "PrivateIdentifier",
          name: f.key.name
        },
        value: h(f.value)
      } : f instanceof Ii ? {
        type: "PropertyDefinition",
        key: {
          type: "PrivateIdentifier",
          name: f.key.name
        },
        value: h(f.value),
        computed: !1,
        static: f.static
      } : f instanceof Bi ? {
        type: "PropertyDefinition",
        key: v,
        value: h(f.value),
        computed: x,
        static: f.static
      } : d instanceof ht ? {
        type: "MethodDefinition",
        computed: x,
        kind: E,
        static: f.static,
        key: h(f.key),
        value: h(f.value)
      } : {
        type: "Property",
        computed: x,
        kind: E,
        key: v,
        value: h(f.value)
      };
    }, "To_Moz_Property")), c(Kr, /* @__PURE__ */ s(function(f, d) {
      return d instanceof Tt ? {
        type: "Property",
        computed: !(f.key instanceof gt) || f.key instanceof Te,
        kind: "init",
        method: !0,
        shorthand: !1,
        key: h(f.key),
        value: h(f.value)
      } : {
        type: "MethodDefinition",
        kind: f.key === "constructor" ? "constructor" : "method",
        key: h(f.key),
        value: h(f.value),
        computed: !(f.key instanceof gt) || f.key instanceof Te,
        static: f.static
      };
    }, "To_Moz_MethodDefinition")), c(ki, /* @__PURE__ */ s(function(f) {
      return {
        type: "MethodDefinition",
        kind: "method",
        key: { type: "PrivateIdentifier", name: f.key.name },
        value: h(f.value),
        computed: !1,
        static: f.static
      };
    }, "To_Moz_MethodDefinition")), c(ht, /* @__PURE__ */ s(function(f) {
      var d = f instanceof ts ? "ClassExpression" : "ClassDeclaration";
      return {
        type: d,
        superClass: h(f.extends),
        id: f.name ? h(f.name) : null,
        body: {
          type: "ClassBody",
          body: f.properties.map(h)
        }
      };
    }, "To_Moz_Class")), c(Hr, /* @__PURE__ */ s(function(f) {
      return {
        type: "StaticBlock",
        body: f.body.map(h)
      };
    }, "To_Moz_StaticBlock")), c(lo, /* @__PURE__ */ s(function() {
      return {
        type: "MetaProperty",
        meta: {
          type: "Identifier",
          name: "new"
        },
        property: {
          type: "Identifier",
          name: "target"
        }
      };
    }, "To_Moz_MetaProperty")), c(gt, /* @__PURE__ */ s(function(f, d) {
      if (f instanceof hi && d.quote || (f instanceof Wo || f instanceof oa || f instanceof oo) && f.quote)
        return {
          type: "Literal",
          value: f.name
        };
      var v = f.definition();
      return {
        type: "Identifier",
        name: v ? v.mangled_name || v.name : f.name
      };
    }, "To_Moz_Identifier")), c($r, /* @__PURE__ */ s(function(f) {
      let d = f.value.source, v = f.value.flags;
      return {
        type: "Literal",
        value: null,
        raw: f.print_to_string(),
        regex: { pattern: d, flags: v }
      };
    }, "To_Moz_RegExpLiteral")), c(Ct, /* @__PURE__ */ s(function(f) {
      var d = f.value;
      return {
        type: "Literal",
        value: d,
        raw: f.raw || f.print_to_string()
      };
    }, "To_Moz_Literal")), c(Xo, /* @__PURE__ */ s(function(f) {
      return {
        type: "Identifier",
        name: String(f.value)
      };
    }, "To_Moz_Atom")), c(un, (m) => ({
      type: "Literal",
      // value cannot be represented natively
      // see: https://github.com/estree/estree/blob/master/es2020.md#bigintliteral
      value: null,
      // `M.value` is a string that may be a hex number representation.
      // but "bigint" property should have only decimal digits
      bigint: typeof BigInt == "function" ? BigInt(m.value).toString() : m.value
    })), rh.DEFMETHOD("to_mozilla_ast", Ct.prototype.to_mozilla_ast), Xi.DEFMETHOD("to_mozilla_ast", Ct.prototype.to_mozilla_ast), xn.DEFMETHOD(
    "to_mozilla_ast", /* @__PURE__ */ s(function() {
      return null;
    }, "To_Moz_ArrayHole")), Tr.DEFMETHOD("to_mozilla_ast", ot.prototype.to_mozilla_ast), Ue.DEFMETHOD("to_mozilla_ast", jt.prototype.to_mozilla_ast);
    function n(m) {
      var f = m.loc, d = f && f.start, v = m.range;
      return new Mu(
        "",
        "",
        d && d.line || 0,
        d && d.column || 0,
        v ? v[0] : m.start,
        !1,
        [],
        [],
        f && f.source
      );
    }
    s(n, "my_start_token");
    function a(m) {
      var f = m.loc, d = f && f.end, v = m.range;
      return new Mu(
        "",
        "",
        d && d.line || 0,
        d && d.column || 0,
        v ? v[0] : m.end,
        !1,
        [],
        [],
        f && f.source
      );
    }
    s(a, "my_end_token");
    var o = null;
    function u(m) {
      o.push(m);
      var f = m != null ? r[m.type](m) : null;
      return o.pop(), f;
    }
    s(u, "from_moz"), Se.from_mozilla_ast = function(m) {
      var f = o;
      o = [];
      var d = u(m);
      return o = f, d;
    };
    function l(m, f) {
      var d = m.start, v = m.end;
      return d && v && (d.pos != null && v.endpos != null && (f.range = [d.pos, v.endpos]), d.line && (f.loc = {
        start: { line: d.line, column: d.col },
        end: v.endline ? { line: v.endline, column: v.endcol } : null
      }, d.file && (f.loc.source = d.file))), f;
    }
    s(l, "set_moz_loc");
    function c(m, f) {
      m.DEFMETHOD("to_mozilla_ast", function(d) {
        return l(this, f(this, d));
      });
    }
    s(c, "def_to_moz");
    var p = null;
    function h(m) {
      p === null && (p = []), p.push(m);
      var f = m != null ? m.to_mozilla_ast(p[p.length - 2]) : null;
      return p.pop(), p.length === 0 && (p = null), f;
    }
    s(h, "to_moz");
    function y() {
      for (var m = p.length; m--; )
        if (p[m] instanceof Ut)
          return !0;
      return !1;
    }
    s(y, "to_moz_in_destructuring");
    function _(m) {
      return {
        type: "BlockStatement",
        body: m.body.map(h)
      };
    }
    s(_, "to_moz_block");
    function g(m, f) {
      var d = f.body.map(h);
      return f.body[0] instanceof qe && f.body[0].body instanceof bt && d.unshift(h(new Rt(f.body[0]))), {
        type: m,
        body: d
      };
    }
    s(g, "to_moz_scope");
  })();
});

// ../node_modules/terser/lib/utils/first_in_statement.js
function os(e) {
  let t = e.parent(-1);
  for (let r = 0, i; i = e.parent(r); r++) {
    if (i instanceof Br && i.body === t)
      return !0;
    if (i instanceof Qe && i.expressions[0] === t || i.TYPE === "Call" && i.expression === t || i instanceof pn && i.prefix === t || i instanceof
    It && i.expression === t || i instanceof fr && i.expression === t || i instanceof er && i.expression === t || i instanceof it && i.condition ===
    t || i instanceof ce && i.left === t || i instanceof as && i.expression === t)
      t = i;
    else
      return !1;
  }
}
function Yo(e) {
  return e instanceof Tt ? !0 : e instanceof Qe ? Yo(e.expressions[0]) : e.TYPE === "Call" ? Yo(e.expression) : e instanceof pn ? Yo(e.prefix) :
  e instanceof It || e instanceof fr || e instanceof er ? Yo(e.expression) : e instanceof it ? Yo(e.condition) : e instanceof ce ? Yo(e.left) :
  e instanceof as ? Yo(e.expression) : !1;
}
var nh = at(() => {
  Di();
  s(os, "first_in_statement");
  s(Yo, "left_is_object");
});

// ../node_modules/terser/lib/output.js
function ipt(e) {
  return (e.type === "comment2" || e.type === "comment1") && /@preserve|@copyright|@lic|@cc_on|^\**!/i.test(e.value);
}
function ef(e) {
  var t = !e;
  e = Mn(e, {
    ascii_only: !1,
    beautify: !1,
    braces: !1,
    comments: "some",
    ecma: 5,
    ie8: !1,
    indent_level: 4,
    indent_start: 0,
    inline_script: !0,
    keep_numbers: !1,
    keep_quoted_props: !1,
    max_line_len: !1,
    preamble: null,
    preserve_annotations: !1,
    quote_keys: !1,
    quote_style: 0,
    safari10: !1,
    semicolons: !0,
    shebang: !0,
    shorthand: void 0,
    source_map: null,
    webkit: !1,
    width: 80,
    wrap_iife: !1,
    wrap_func_args: !0,
    _destroy_ast: !1
  }, !0), e.shorthand === void 0 && (e.shorthand = e.ecma > 5);
  var r = kt;
  if (e.comments) {
    let te = e.comments;
    if (typeof e.comments == "string" && /^\/.*\/[a-zA-Z]*$/.test(e.comments)) {
      var i = e.comments.lastIndexOf("/");
      te = new RegExp(
        e.comments.substr(1, i - 1),
        e.comments.substr(i + 1)
      );
    }
    te instanceof RegExp ? r = /* @__PURE__ */ s(function(pe) {
      return pe.type != "comment5" && te.test(pe.value);
    }, "comment_filter") : typeof te == "function" ? r = /* @__PURE__ */ s(function(pe) {
      return pe.type != "comment5" && te(this, pe);
    }, "comment_filter") : te === "some" ? r = ipt : r = rn;
  }
  if (e.preserve_annotations) {
    let te = r;
    r = /* @__PURE__ */ s(function(pe) {
      return zie.test(pe.value) || te.apply(this, arguments);
    }, "comment_filter");
  }
  var n = 0, a = 0, o = 1, u = 0, l = new Sk();
  let c = /* @__PURE__ */ new Set();
  var p = e.ascii_only ? function(te, pe = !1, we = !1) {
    return e.ecma >= 2015 && !e.safari10 && !we && (te = te.replace(/[\ud800-\udbff][\udc00-\udfff]/g, function(He) {
      var vt = Nie(He, 0).toString(16);
      return "\\u{" + vt + "}";
    })), te.replace(/[\u0000-\u001f\u007f-\uffff]/g, function(He) {
      var vt = He.charCodeAt(0).toString(16);
      if (vt.length <= 2 && !pe) {
        for (; vt.length < 2; ) vt = "0" + vt;
        return "\\x" + vt;
      } else {
        for (; vt.length < 4; ) vt = "0" + vt;
        return "\\u" + vt;
      }
    });
  } : function(te) {
    return te.replace(/[\ud800-\udbff][\udc00-\udfff]|([\ud800-\udbff]|[\udc00-\udfff])/g, function(pe, we) {
      return we ? "\\u" + we.charCodeAt(0).toString(16) : pe;
    });
  };
  function h(te, pe) {
    var we = 0, He = 0;
    te = te.replace(
      /[\\\b\f\n\r\v\t\x22\x27\u2028\u2029\0\ufeff]/g,
      function(ae, _e) {
        switch (ae) {
          case '"':
            return ++we, '"';
          case "'":
            return ++He, "'";
          case "\\":
            return "\\\\";
          case `
`:
            return "\\n";
          case "\r":
            return "\\r";
          case "	":
            return "\\t";
          case "\b":
            return "\\b";
          case "\f":
            return "\\f";
          case "\v":
            return e.ie8 ? "\\x0B" : "\\v";
          case "\u2028":
            return "\\u2028";
          case "\u2029":
            return "\\u2029";
          case "\uFEFF":
            return "\\ufeff";
          case "\0":
            return /[0-9]/.test(Ym(te, _e + 1)) ? "\\x00" : "\\0";
        }
        return ae;
      }
    );
    function vt() {
      return "'" + te.replace(/\x27/g, "\\'") + "'";
    }
    s(vt, "quote_single");
    function wt() {
      return '"' + te.replace(/\x22/g, '\\"') + '"';
    }
    s(wt, "quote_double");
    function xr() {
      return "`" + te.replace(/`/g, "\\`") + "`";
    }
    if (s(xr, "quote_template"), te = p(te), pe === "`") return xr();
    switch (e.quote_style) {
      case 1:
        return vt();
      case 2:
        return wt();
      case 3:
        return pe == "'" ? vt() : wt();
      default:
        return we > He ? vt() : wt();
    }
  }
  s(h, "make_string");
  function y(te, pe) {
    var we = h(te, pe);
    return e.inline_script && (we = we.replace(/<\x2f(script)([>\/\t\n\f\r ])/gi, "<\\/$1$2"), we = we.replace(/\x3c!--/g, "\\x3c!--"), we =
    we.replace(/--\x3e/g, "--\\x3e")), we;
  }
  s(y, "encode_string");
  function _(te) {
    return te = te.toString(), te = p(te, !0), te;
  }
  s(_, "make_name");
  function g(te) {
    return " ".repeat(e.indent_start + n - te * e.indent_level);
  }
  s(g, "make_indent");
  var m = !1, f = !1, d = !1, v = 0, E = !1, S = !1, x = -1, C = "", z, w, D = e.source_map && [], N = D ? function() {
    D.forEach(function(te) {
      try {
        let { name: pe, token: we } = te;
        pe !== !1 && (we.type == "name" || we.type === "privatename" ? pe = we.value : pe instanceof gt && (pe = we.type === "string" ? we.value :
        pe.name)), e.source_map.add(
          te.token.file,
          te.line,
          te.col,
          te.token.line,
          te.token.col,
          Xc(pe) ? pe : void 0
        );
      } catch {
      }
    }), D = [];
  } : fn, T = e.max_line_len ? function() {
    if (a > e.max_line_len && v) {
      l.insertAt(`
`, v);
      let pe = l.length() - v - 1;
      if (D) {
        var te = pe - a;
        D.forEach(function(we) {
          we.line++, we.col += te;
        });
      }
      o++, u++, a = pe;
    }
    v && (v = 0, N());
  } : fn, R = qt("( [ + * / - , . `");
  function j(te) {
    te = String(te);
    var pe = Ym(te, 0);
    E && pe && (E = !1, pe !== `
` && (j(`
`), F())), S && pe && (S = !1, /[\s;})]/.test(pe) || H()), x = -1;
    var we = C.charAt(C.length - 1);
    d && (d = !1, (we === ":" && pe === "}" || (!pe || !";}".includes(pe)) && we !== ";") && (e.semicolons || R.has(pe) ? (l.append(";"), a++,
    u++) : (T(), a > 0 && (l.append(`
`), u++, o++, a = 0), /^\s+$/.test(te) && (d = !0)), e.beautify || (f = !1))), f && ((Jm(we) && (Jm(pe) || pe == "\\") || pe == "/" && pe ==
    we || (pe == "+" || pe == "-") && pe == C) && (l.append(" "), a++, u++), f = !1), z && (D.push({
      token: z,
      name: w,
      line: o,
      col: a
    }), z = !1, v || N()), l.append(te), m = te[te.length - 1] == "(", u += te.length;
    var He = te.split(/\r?\n/), vt = He.length - 1;
    o += vt, a += He[0].length, vt > 0 && (T(), a = He[vt].length), C = te;
  }
  s(j, "print");
  var J = /* @__PURE__ */ s(function() {
    j("*");
  }, "star"), H = e.beautify ? function() {
    j(" ");
  } : function() {
    f = !0;
  }, F = e.beautify ? function(te) {
    e.beautify && j(g(te ? 0.5 : 0));
  } : fn, re = e.beautify ? function(te, pe) {
    te === !0 && (te = xe());
    var we = n;
    n = te;
    var He = pe();
    return n = we, He;
  } : function(te, pe) {
    return pe();
  }, se = e.beautify ? function() {
    if (x < 0) return j(`
`);
    l.charAt(x) != `
` && (l.insertAt(`
`, x), u++, o++), x++;
  } : e.max_line_len ? function() {
    T(), v = l.length();
  } : fn, de = e.beautify ? function() {
    j(";");
  } : function() {
    d = !0;
  };
  function he() {
    d = !1, j(";");
  }
  s(he, "force_semicolon");
  function xe() {
    return n + e.indent_level;
  }
  s(xe, "next_indent");
  function G(te) {
    var pe;
    return j("{"), se(), re(xe(), function() {
      pe = te();
    }), F(), j("}"), pe;
  }
  s(G, "with_block");
  function ie(te) {
    j("(");
    var pe = te();
    return j(")"), pe;
  }
  s(ie, "with_parens");
  function X(te) {
    j("[");
    var pe = te();
    return j("]"), pe;
  }
  s(X, "with_square");
  function ye() {
    j(","), H();
  }
  s(ye, "comma");
  function Oe() {
    j(":"), H();
  }
  s(Oe, "colon");
  var Pt = D ? function(te, pe) {
    z = te, w = pe;
  } : fn;
  function Vt() {
    return v && T(), l.toString();
  }
  s(Vt, "get");
  function Ee(te) {
    return e.preserve_annotations || (te = te.replace(zie, " ")), /^\s*$/.test(te) ? "" : te.replace(/(<\s*\/\s*)(script)/i, "<\\/$2");
  }
  s(Ee, "filter_comment");
  function st(te) {
    var pe = this, we = te.start;
    if (!we) return;
    var He = pe.printed_comments;
    let vt = te instanceof cn && te.value || (te instanceof Mi || te instanceof Oi) && te.expression;
    if (we.comments_before && He.has(we.comments_before))
      if (vt)
        we.comments_before = [];
      else
        return;
    var wt = we.comments_before;
    if (wt || (wt = we.comments_before = []), He.add(wt), vt) {
      var xr = new Mr(function(be) {
        var Pe = xr.parent();
        if (Pe instanceof cn || Pe instanceof Mi || Pe instanceof Oi || Pe instanceof ce && Pe.left === be || Pe.TYPE == "Call" && Pe.expression ===
        be || Pe instanceof it && Pe.condition === be || Pe instanceof It && Pe.expression === be || Pe instanceof Qe && Pe.expressions[0] ===
        be || Pe instanceof fr && Pe.expression === be || Pe instanceof as) {
          if (!be.start) return;
          var ze = be.start.comments_before;
          ze && !He.has(ze) && (He.add(ze), wt = wt.concat(ze));
        } else
          return !0;
      });
      xr.push(te), vt.walk(xr);
    }
    if (u == 0) {
      wt.length > 0 && e.shebang && wt[0].type === "comment5" && !He.has(wt[0]) && (j("#!" + wt.shift().value + `
`), F());
      var ae = e.preamble;
      ae && j(ae.replace(/\r\n?|[\n\u2028\u2029]|\s*$/g, `
`));
    }
    if (wt = wt.filter(r, te).filter((be) => !He.has(be)), wt.length != 0) {
      var _e = l.hasNLB();
      wt.forEach(function(be, Pe) {
        if (He.add(be), _e || (be.nlb ? (j(`
`), F(), _e = !0) : Pe > 0 && H()), /comment[134]/.test(be.type)) {
          var ze = Ee(be.value);
          ze && (j("//" + ze + `
`), F()), _e = !0;
        } else if (be.type == "comment2") {
          var ze = Ee(be.value);
          ze && j("/*" + ze + "*/"), _e = !1;
        }
      }), _e || (we.nlb ? (j(`
`), F()) : H());
    }
  }
  s(st, "prepend_comments");
  function oe(te, pe) {
    var we = this, He = te.end;
    if (He) {
      var vt = we.printed_comments, wt = He[pe ? "comments_before" : "comments_after"];
      if (!(!wt || vt.has(wt)) && (te instanceof Br || wt.every(
        (ae) => !/comment[134]/.test(ae.type)
      ))) {
        vt.add(wt);
        var xr = l.length();
        wt.filter(r, te).forEach(function(ae, _e) {
          if (!vt.has(ae)) {
            if (vt.add(ae), S = !1, E ? (j(`
`), F(), E = !1) : ae.nlb && (_e > 0 || !l.hasNLB()) ? (j(`
`), F()) : (_e > 0 || !pe) && H(), /comment[134]/.test(ae.type)) {
              let be = Ee(ae.value);
              be && j("//" + be), E = !0;
            } else if (ae.type == "comment2") {
              let be = Ee(ae.value);
              be && j("/*" + be + "*/"), S = !0;
            }
          }
        }), l.length() > xr && (x = xr);
      }
    }
  }
  s(oe, "append_comments");
  let Ae = e._destroy_ast ? /* @__PURE__ */ s(function(pe) {
    pe.body.length = 0, pe.argnames.length = 0;
  }, "gc_scope") : fn;
  var Ie = [];
  return {
    get: Vt,
    toString: Vt,
    indent: F,
    in_directive: !1,
    use_asm: null,
    active_scope: null,
    indentation: /* @__PURE__ */ s(function() {
      return n;
    }, "indentation"),
    current_width: /* @__PURE__ */ s(function() {
      return a - n;
    }, "current_width"),
    should_break: /* @__PURE__ */ s(function() {
      return e.width && this.current_width() >= e.width;
    }, "should_break"),
    has_parens: /* @__PURE__ */ s(function() {
      return m;
    }, "has_parens"),
    newline: se,
    print: j,
    star: J,
    space: H,
    comma: ye,
    colon: Oe,
    last: /* @__PURE__ */ s(function() {
      return C;
    }, "last"),
    semicolon: de,
    force_semicolon: he,
    to_utf8: p,
    print_name: /* @__PURE__ */ s(function(te) {
      j(_(te));
    }, "print_name"),
    print_string: /* @__PURE__ */ s(function(te, pe, we) {
      var He = y(te, pe);
      we === !0 && !He.includes("\\") && (l.expectDirective() || he(), he()), j(He);
    }, "print_string"),
    print_template_string_chars: /* @__PURE__ */ s(function(te) {
      var pe = y(te, "`").replace(/\${/g, "\\${");
      return j(pe.substr(1, pe.length - 2));
    }, "print_template_string_chars"),
    encode_string: y,
    next_indent: xe,
    with_indent: re,
    with_block: G,
    with_parens: ie,
    with_square: X,
    add_mapping: Pt,
    option: /* @__PURE__ */ s(function(te) {
      return e[te];
    }, "option"),
    gc_scope: Ae,
    printed_comments: c,
    prepend_comments: t ? fn : st,
    append_comments: t || r === kt ? fn : oe,
    line: /* @__PURE__ */ s(function() {
      return o;
    }, "line"),
    col: /* @__PURE__ */ s(function() {
      return a;
    }, "col"),
    pos: /* @__PURE__ */ s(function() {
      return u;
    }, "pos"),
    push_node: /* @__PURE__ */ s(function(te) {
      Ie.push(te);
    }, "push_node"),
    pop_node: /* @__PURE__ */ s(function() {
      return Ie.pop();
    }, "pop_node"),
    parent: /* @__PURE__ */ s(function(te) {
      return Ie[Ie.length - 2 - (te || 0)];
    }, "parent")
  };
}
var Kie, Hie, zie, npt, Sk, QS = at(() => {
  "use strict";
  Gi();
  nh();
  Di();
  Rl();
  Kie = 10, Hie = 32, zie = /[@#]__(PURE|INLINE|NOINLINE)__/;
  s(ipt, "is_some_comments");
  npt = 8 * 1e3, Sk = class {
    static {
      s(this, "Rope");
    }
    constructor() {
      this.committed = "", this.current = "";
    }
    append(t) {
      this.current.length > npt ? (this.committed += this.current + t, this.current = "") : this.current += t;
    }
    insertAt(t, r) {
      let { committed: i, current: n } = this;
      r < i.length ? this.committed = i.slice(0, r) + t + i.slice(r) : r === i.length ? this.committed += t : (r -= i.length, this.committed +=
      n.slice(0, r) + t, this.current = n.slice(r));
    }
    charAt(t) {
      let { committed: r } = this;
      return t < r.length ? r[t] : this.current[t - r.length];
    }
    charCodeAt(t) {
      let { committed: r } = this;
      return t < r.length ? r.charCodeAt(t) : this.current.charCodeAt(t - r.length);
    }
    length() {
      return this.committed.length + this.current.length;
    }
    expectDirective() {
      let t, r = this.length();
      if (r <= 0) return !0;
      for (; (t = this.charCodeAt(--r)) && (t == Hie || t == Kie); ) ;
      return !t || t === 59 || t === 123;
    }
    hasNLB() {
      let t = this.length() - 1;
      for (; t >= 0; ) {
        let r = this.charCodeAt(t--);
        if (r === Kie) return !0;
        if (r !== Hie) return !1;
      }
      return !0;
    }
    toString() {
      return this.committed + this.current;
    }
  };
  s(ef, "OutputStream");
  (function() {
    function e(f, d) {
      f.DEFMETHOD("_codegen", d);
    }
    s(e, "DEFPRINT"), Se.DEFMETHOD("print", function(f, d) {
      var v = this, E = v._codegen;
      v instanceof Ye ? f.active_scope = v : !f.use_asm && v instanceof wi && v.value == "use asm" && (f.use_asm = f.active_scope);
      function S() {
        f.prepend_comments(v), v.add_source_map(f), E(v, f), f.append_comments(v);
      }
      s(S, "doit"), f.push_node(v), d || v.needs_parens(f) ? f.with_parens(S) : S(), f.pop_node(), v === f.use_asm && (f.use_asm = null);
    }), Se.DEFMETHOD("_print", Se.prototype.print), Se.DEFMETHOD("print_to_string", function(f) {
      var d = ef(f);
      return this.print(d), d.get();
    });
    function t(f, d) {
      Array.isArray(f) ? f.forEach(function(v) {
        t(v, d);
      }) : f.DEFMETHOD("needs_parens", d);
    }
    s(t, "PARENS"), t(Se, kt), t(jt, function(f) {
      if (!f.has_parens() && os(f))
        return !0;
      if (f.option("webkit")) {
        var d = f.parent();
        if (d instanceof je && d.expression === this)
          return !0;
      }
      if (f.option("wrap_iife")) {
        var d = f.parent();
        if (d instanceof Fe && d.expression === this)
          return !0;
      }
      if (f.option("wrap_func_args")) {
        var d = f.parent();
        if (d instanceof Fe && d.args.includes(this))
          return !0;
      }
      return !1;
    }), t(Zt, function(f) {
      var d = f.parent();
      return f.option("wrap_func_args") && d instanceof Fe && d.args.includes(this) ? !0 : d instanceof je && d.expression === this || d instanceof
      it && d.condition === this;
    }), t(Tt, function(f) {
      return !f.has_parens() && os(f);
    }), t(ts, os), t(Ht, function(f) {
      var d = f.parent();
      return d instanceof je && d.expression === this || d instanceof Fe && d.expression === this || d instanceof ce && d.operator === "**" &&
      this instanceof $e && d.left === this && this.operator !== "++" && this.operator !== "--";
    }), t(Mi, function(f) {
      var d = f.parent();
      return d instanceof je && d.expression === this || d instanceof Fe && d.expression === this || d instanceof ce && d.operator === "**" &&
      d.left === this || f.option("safari10") && d instanceof $e;
    }), t(Qe, function(f) {
      var d = f.parent();
      return d instanceof Fe || d instanceof Ht || d instanceof ce || d instanceof Lt || d instanceof je || d instanceof pt || d instanceof gr ||
      d instanceof it || d instanceof Zt || d instanceof sn || d instanceof ft || d instanceof ka && this === d.object || d instanceof Oi ||
      d instanceof dr;
    }), t(ce, function(f) {
      var d = f.parent();
      if (d instanceof Fe && d.expression === this || d instanceof Ht || d instanceof je && d.expression === this)
        return !0;
      if (d instanceof ce) {
        let v = d.operator, E = this.operator;
        if (E === "??" && (v === "||" || v === "&&") || v === "??" && (E === "||" || E === "&&"))
          return !0;
        let S = _s[v], x = _s[E];
        if (S > x || S == x && (this === d.right || v == "**"))
          return !0;
      }
      if (d instanceof Un) {
        let v = this.operator, E = _s.in, S = _s[v];
        if (E > S || E == S && this === d.value)
          return !0;
      }
    }), t(Un, function(f) {
      var d = f.parent();
      if (d instanceof Fe && d.expression === this || d instanceof Ht || d instanceof je && d.expression === this)
        return !0;
      if (d instanceof ce) {
        let v = d.operator, E = _s[v], S = _s.in;
        if (E > S || E == S && (this === d.right || v == "**"))
          return !0;
      }
      if (d instanceof Un && this === d.value)
        return !0;
    }), t(Oi, function(f) {
      var d = f.parent();
      if (d instanceof ce && d.operator !== "=" || d instanceof Fe && d.expression === this || d instanceof it && d.condition === this || d instanceof
      Ht || d instanceof je && d.expression === this)
        return !0;
    }), t(er, function(f) {
      var d = f.parent();
      return d instanceof Fe || d instanceof je ? d.expression === this : !1;
    }), t(je, function(f) {
      var d = f.parent();
      if (d instanceof gi && d.expression === this)
        return _r(this, (v) => {
          if (v instanceof Ye) return !0;
          if (v instanceof Fe)
            return Yi;
        });
    }), t(Fe, function(f) {
      var d = f.parent(), v;
      return d instanceof gi && d.expression === this || d instanceof dr && d.is_default && this.expression instanceof jt ? !0 : this.expression instanceof
      jt && d instanceof je && d.expression === this && (v = f.parent(1)) instanceof ct && v.left === d;
    }), t(gi, function(f) {
      var d = f.parent();
      if (this.args.length === 0 && (d instanceof je || d instanceof Fe && d.expression === this || d instanceof pn && d.prefix === this))
        return !0;
    }), t(We, function(f) {
      var d = f.parent();
      if (d instanceof je && d.expression === this) {
        var v = this.getValue();
        if (v < 0 || /^0/.test(_(v)))
          return !0;
      }
    }), t(un, function(f) {
      var d = f.parent();
      if (d instanceof je && d.expression === this) {
        var v = this.getValue();
        if (v.startsWith("-"))
          return !0;
      }
    }), t([ct, it], function(f) {
      var d = f.parent();
      if (d instanceof Ht || d instanceof ce && !(d instanceof ct) || d instanceof Fe && d.expression === this || d instanceof it && d.condition ===
      this || d instanceof je && d.expression === this || this instanceof ct && this.left instanceof Ut && this.left.is_array === !1)
        return !0;
    }), e(wi, function(f, d) {
      d.print_string(f.value, f.quote), d.semicolon();
    }), e(ft, function(f, d) {
      d.print("..."), f.expression.print(d);
    }), e(Ut, function(f, d) {
      d.print(f.is_array ? "[" : "{");
      var v = f.names.length;
      f.names.forEach(function(E, S) {
        S > 0 && d.comma(), E.print(d), S == v - 1 && E instanceof xn && d.comma();
      }), d.print(f.is_array ? "]" : "}");
    }), e(is, function(f, d) {
      d.print("debugger"), d.semicolon();
    });
    function r(f, d, v, E) {
      var S = f.length - 1;
      v.in_directive = E, f.forEach(function(x, C) {
        v.in_directive === !0 && !(x instanceof wi || x instanceof Rt || x instanceof qe && x.body instanceof bt) && (v.in_directive = !1), x instanceof
        Rt || (v.indent(), x.print(v), C == S && d || (v.newline(), d && v.newline())), v.in_directive === !0 && x instanceof qe && x.body instanceof
        bt && (v.in_directive = !1);
      }), v.in_directive = !1;
    }
    s(r, "display_body"), Bl.DEFMETHOD("_do_print_body", function(f) {
      h(this.body, f);
    }), e(Br, function(f, d) {
      f.body.print(d), d.semicolon();
    }), e(Kt, function(f, d) {
      r(f.body, !0, d, !0), d.print("");
    }), e(wr, function(f, d) {
      f.label.print(d), d.colon(), f.body.print(d);
    }), e(qe, function(f, d) {
      f.body.print(d), d.semicolon();
    });
    function i(f, d) {
      d.print("{"), d.with_indent(d.next_indent(), function() {
        d.append_comments(f, !0);
      }), d.add_mapping(f.end), d.print("}");
    }
    s(i, "print_braced_empty");
    function n(f, d, v) {
      f.body.length > 0 ? d.with_block(function() {
        r(f.body, !1, d, v), d.add_mapping(f.end);
      }) : i(f, d);
    }
    s(n, "print_braced"), e(ot, function(f, d) {
      n(f, d);
    }), e(Rt, function(f, d) {
      d.semicolon();
    }), e(Pn, function(f, d) {
      d.print("do"), d.space(), g(f.body, d), d.space(), d.print("while"), d.space(), d.with_parens(function() {
        f.condition.print(d);
      }), d.semicolon();
    }), e(qn, function(f, d) {
      d.print("while"), d.space(), d.with_parens(function() {
        f.condition.print(d);
      }), d.space(), f._do_print_body(d);
    }), e(yr, function(f, d) {
      d.print("for"), d.space(), d.with_parens(function() {
        f.init ? (f.init instanceof cr ? f.init.print(d) : o(f.init, d, !0), d.print(";"), d.space()) : d.print(";"), f.condition ? (f.condition.
        print(d), d.print(";"), d.space()) : d.print(";"), f.step && f.step.print(d);
      }), d.space(), f._do_print_body(d);
    }), e(Or, function(f, d) {
      d.print("for"), f.await && (d.space(), d.print("await")), d.space(), d.with_parens(function() {
        f.init.print(d), d.space(), d.print(f instanceof ka ? "of" : "in"), d.space(), f.object.print(d);
      }), d.space(), f._do_print_body(d);
    }), e(di, function(f, d) {
      d.print("with"), d.space(), d.with_parens(function() {
        f.expression.print(d);
      }), d.space(), f._do_print_body(d);
    }), Ue.DEFMETHOD("_do_print", function(f, d) {
      var v = this;
      d || (v.async && (f.print("async"), f.space()), f.print("function"), v.is_generator && f.star(), v.name && f.space()), v.name instanceof
      gt ? v.name.print(f) : d && v.name instanceof Se && f.with_square(function() {
        v.name.print(f);
      }), f.with_parens(function() {
        v.argnames.forEach(function(E, S) {
          S && f.comma(), E.print(f);
        });
      }), f.space(), n(v, f, !0);
    }), e(Ue, function(f, d) {
      f._do_print(d), d.gc_scope(f);
    }), e(pn, function(f, d) {
      var v = f.prefix, E = v instanceof Ue || v instanceof ce || v instanceof it || v instanceof Qe || v instanceof Ht || v instanceof It &&
      v.expression instanceof Tt;
      E && d.print("("), f.prefix.print(d), E && d.print(")"), f.template_string.print(d);
    }), e(jr, function(f, d) {
      var v = d.parent() instanceof pn;
      d.print("`");
      for (var E = 0; E < f.segments.length; E++)
        f.segments[E] instanceof Bn ? v ? d.print(f.segments[E].raw) : d.print_template_string_chars(f.segments[E].value) : (d.print("${"), f.
        segments[E].print(d), d.print("}"));
      d.print("`");
    }), e(Bn, function(f, d) {
      d.print_template_string_chars(f.value);
    }), Zt.DEFMETHOD("_do_print", function(f) {
      var d = this, v = f.parent(), E = v instanceof ce && !(v instanceof ct) && !(v instanceof sn) || v instanceof Ht || v instanceof Fe &&
      d === v.expression;
      E && f.print("("), d.async && (f.print("async"), f.space()), d.argnames.length === 1 && d.argnames[0] instanceof gt ? d.argnames[0].print(
      f) : f.with_parens(function() {
        d.argnames.forEach(function(x, C) {
          C && f.comma(), x.print(f);
        });
      }), f.space(), f.print("=>"), f.space();
      let S = d.body[0];
      if (d.body.length === 1 && S instanceof mr) {
        let x = S.value;
        x ? Yo(x) ? (f.print("("), x.print(f), f.print(")")) : x.print(f) : f.print("{}");
      } else
        n(d, f);
      E && f.print(")"), f.gc_scope(d);
    }), cn.DEFMETHOD("_do_print", function(f, d) {
      if (f.print(d), this.value) {
        f.space();
        let v = this.value.start.comments_before;
        v && v.length && !f.printed_comments.has(v) ? (f.print("("), this.value.print(f), f.print(")")) : this.value.print(f);
      }
      f.semicolon();
    }), e(mr, function(f, d) {
      f._do_print(d, "return");
    }), e(Bu, function(f, d) {
      f._do_print(d, "throw");
    }), e(Oi, function(f, d) {
      var v = f.is_star ? "*" : "";
      d.print("yield" + v), f.expression && (d.space(), f.expression.print(d));
    }), e(Mi, function(f, d) {
      d.print("await"), d.space();
      var v = f.expression, E = !(v instanceof Fe || v instanceof Te || v instanceof je || v instanceof Ht || v instanceof Ct || v instanceof
      Mi || v instanceof Tt);
      E && d.print("("), f.expression.print(d), E && d.print(")");
    }), Kn.DEFMETHOD("_do_print", function(f, d) {
      f.print(d), this.label && (f.space(), this.label.print(f)), f.semicolon();
    }), e(hn, function(f, d) {
      f._do_print(d, "break");
    }), e(ua, function(f, d) {
      f._do_print(d, "continue");
    });
    function a(f, d) {
      var v = f.body;
      if (d.option("braces") || d.option("ie8") && v instanceof Pn)
        return g(v, d);
      if (!v) return d.force_semicolon();
      for (; ; )
        if (v instanceof Ft) {
          if (!v.alternative) {
            g(f.body, d);
            return;
          }
          v = v.alternative;
        } else if (v instanceof Bl)
          v = v.body;
        else break;
      h(f.body, d);
    }
    s(a, "make_then"), e(Ft, function(f, d) {
      d.print("if"), d.space(), d.with_parens(function() {
        f.condition.print(d);
      }), d.space(), f.alternative ? (a(f, d), d.space(), d.print("else"), d.space(), f.alternative instanceof Ft ? f.alternative.print(d) :
      h(f.alternative, d)) : f._do_print_body(d);
    }), e(Vr, function(f, d) {
      d.print("switch"), d.space(), d.with_parens(function() {
        f.expression.print(d);
      }), d.space();
      var v = f.body.length - 1;
      v < 0 ? i(f, d) : d.with_block(function() {
        f.body.forEach(function(E, S) {
          d.indent(!0), E.print(d), S < v && E.body.length > 0 && d.newline();
        });
      });
    }), Ts.DEFMETHOD("_do_print_body", function(f) {
      f.newline(), this.body.forEach(function(d) {
        f.indent(), d.print(f), f.newline();
      });
    }), e(zs, function(f, d) {
      d.print("default:"), f._do_print_body(d);
    }), e(dn, function(f, d) {
      d.print("case"), d.space(), f.expression.print(d), d.print(":"), f._do_print_body(d);
    }), e(mi, function(f, d) {
      d.print("try"), d.space(), f.body.print(d), f.bcatch && (d.space(), f.bcatch.print(d)), f.bfinally && (d.space(), f.bfinally.print(d));
    }), e(Nl, function(f, d) {
      n(f, d);
    }), e(mn, function(f, d) {
      d.print("catch"), f.argname && (d.space(), d.with_parens(function() {
        f.argname.print(d);
      })), d.space(), n(f, d);
    }), e(uo, function(f, d) {
      d.print("finally"), d.space(), n(f, d);
    }), cr.DEFMETHOD("_do_print", function(f, d) {
      f.print(d), f.space(), this.definitions.forEach(function(x, C) {
        C && f.comma(), x.print(f);
      });
      var v = f.parent(), E = v instanceof yr || v instanceof Or, S = !E || v && v.init !== this;
      S && f.semicolon();
    }), e(Dn, function(f, d) {
      f._do_print(d, "let");
    }), e(Fr, function(f, d) {
      f._do_print(d, "var");
    }), e(wn, function(f, d) {
      f._do_print(d, "const");
    }), e(yi, function(f, d) {
      d.print("import"), d.space(), f.imported_name && f.imported_name.print(d), f.imported_name && f.imported_names && (d.print(","), d.space()),
      f.imported_names && (f.imported_names.length === 1 && f.imported_names[0].foreign_name.name === "*" && !f.imported_names[0].foreign_name.
      quote ? f.imported_names[0].print(d) : (d.print("{"), f.imported_names.forEach(function(v, E) {
        d.space(), v.print(d), E < f.imported_names.length - 1 && d.print(",");
      }), d.space(), d.print("}"))), (f.imported_name || f.imported_names) && (d.space(), d.print("from"), d.space()), f.module_name.print(d),
      f.attributes && (d.print("with"), f.attributes.print(d)), d.semicolon();
    }), e(ss, function(f, d) {
      d.print("import.meta");
    }), e(Cn, function(f, d) {
      var v = d.parent() instanceof yi, E = f.name.definition(), S = f.foreign_name, x = (E && E.mangled_name || f.name.name) !== S.name;
      !x && S.name === "*" && S.quote != f.name.quote && (x = !0);
      var C = S.quote == null;
      x ? (v ? C ? d.print(S.name) : d.print_string(S.name, S.quote) : f.name.quote == null ? f.name.print(d) : d.print_string(f.name.name, f.
      name.quote), d.space(), d.print("as"), d.space(), v ? f.name.print(d) : C ? d.print(S.name) : d.print_string(S.name, S.quote)) : f.name.
      quote == null ? f.name.print(d) : d.print_string(f.name.name, f.name.quote);
    }), e(dr, function(f, d) {
      if (d.print("export"), d.space(), f.is_default && (d.print("default"), d.space()), f.exported_names)
        f.exported_names.length === 1 && f.exported_names[0].name.name === "*" && !f.exported_names[0].name.quote ? f.exported_names[0].print(
        d) : (d.print("{"), f.exported_names.forEach(function(v, E) {
          d.space(), v.print(d), E < f.exported_names.length - 1 && d.print(",");
        }), d.space(), d.print("}"));
      else if (f.exported_value)
        f.exported_value.print(d);
      else if (f.exported_definition && (f.exported_definition.print(d), f.exported_definition instanceof cr))
        return;
      f.module_name && (d.space(), d.print("from"), d.space(), f.module_name.print(d)), f.attributes && (d.print("with"), f.attributes.print(
      d)), (f.exported_value && !(f.exported_value instanceof tr || f.exported_value instanceof jt || f.exported_value instanceof ht) || f.module_name ||
      f.exported_names) && d.semicolon();
    });
    function o(f, d, v) {
      var E = !1;
      v && (E = _r(f, (S) => {
        if (S instanceof Ye && !(S instanceof Zt))
          return !0;
        if (S instanceof ce && S.operator == "in" || S instanceof Un)
          return Yi;
      })), f.print(d, E);
    }
    s(o, "parenthesize_for_noin"), e(Lt, function(f, d) {
      if (f.name.print(d), f.value) {
        d.space(), d.print("="), d.space();
        var v = d.parent(1), E = v instanceof yr || v instanceof Or;
        o(f.value, d, E);
      }
    }), e(Fe, function(f, d) {
      f.expression.print(d), !(f instanceof gi && f.args.length === 0) && ((f.expression instanceof Fe || f.expression instanceof Ue) && d.add_mapping(
      f.start), f.optional && d.print("?."), d.with_parens(function() {
        f.args.forEach(function(v, E) {
          E && d.comma(), v.print(d);
        });
      }));
    }), e(gi, function(f, d) {
      d.print("new"), d.space(), Fe.prototype._codegen(f, d);
    }), Qe.DEFMETHOD("_do_print", function(f) {
      this.expressions.forEach(function(d, v) {
        v > 0 && (f.comma(), f.should_break() && (f.newline(), f.indent())), d.print(f);
      });
    }), e(Qe, function(f, d) {
      f._do_print(d);
    }), e(It, function(f, d) {
      var v = f.expression;
      v.print(d);
      var E = f.property, S = Go.has(E) ? d.option("ie8") : !bk(
        E,
        d.option("ecma") >= 2015 && !d.option("safari10")
      );
      f.optional && d.print("?."), S ? (d.print("["), d.add_mapping(f.end), d.print_string(E), d.print("]")) : (v instanceof We && v.getValue() >=
      0 && (/[xa-f.)]/i.test(d.last()) || d.print(".")), f.optional || d.print("."), d.add_mapping(f.end), d.print_name(E));
    }), e(Wi, function(f, d) {
      var v = f.expression;
      v.print(d);
      var E = f.property;
      f.optional && d.print("?"), d.print(".#"), d.add_mapping(f.end), d.print_name(E);
    }), e(fr, function(f, d) {
      f.expression.print(d), f.optional && d.print("?."), d.print("["), f.property.print(d), d.print("]");
    }), e(er, function(f, d) {
      f.expression.print(d);
    }), e($e, function(f, d) {
      var v = f.operator;
      v === "--" && d.last().endsWith("!") && d.print(" "), d.print(v), (/^[a-z]/i.test(v) || /[+-]$/.test(v) && f.expression instanceof $e &&
      /^[+-]/.test(f.expression.operator)) && d.space(), f.expression.print(d);
    }), e(as, function(f, d) {
      f.expression.print(d), d.print(f.operator);
    }), e(ce, function(f, d) {
      var v = f.operator;
      f.left.print(d), v[0] == ">" && d.last().endsWith("--") ? d.print(" ") : d.space(), d.print(v), d.space(), f.right.print(d);
    }), e(it, function(f, d) {
      f.condition.print(d), d.space(), d.print("?"), d.space(), f.consequent.print(d), d.space(), d.colon(), f.alternative.print(d);
    }), e(pt, function(f, d) {
      d.with_square(function() {
        var v = f.elements, E = v.length;
        E > 0 && d.space(), v.forEach(function(S, x) {
          x && d.comma(), S.print(d), x === E - 1 && S instanceof xn && d.comma();
        }), E > 0 && d.space();
      });
    }), e(Tt, function(f, d) {
      f.properties.length > 0 ? d.with_block(function() {
        f.properties.forEach(function(v, E) {
          E && (d.print(","), d.newline()), d.indent(), v.print(d);
        }), d.newline();
      }) : i(f, d);
    }), e(ht, function(f, d) {
      if (d.print("class"), d.space(), f.name && (f.name.print(d), d.space()), f.extends) {
        var v = !(f.extends instanceof Te) && !(f.extends instanceof je) && !(f.extends instanceof ts) && !(f.extends instanceof jt);
        d.print("extends"), v ? d.print("(") : d.space(), f.extends.print(d), v ? d.print(")") : d.space();
      }
      f.properties.length > 0 ? d.with_block(function() {
        f.properties.forEach(function(E, S) {
          S && d.newline(), d.indent(), E.print(d);
        }), d.newline();
      }) : d.print("{}");
    }), e(lo, function(f, d) {
      d.print("new.target");
    });
    function u(f, d, v) {
      if (v.option("quote_keys"))
        return v.print_string(f), !1;
      if ("" + +f == f && f >= 0)
        return v.option("keep_numbers") ? (v.print(f), !1) : (v.print(_(f)), !1);
      var E = Go.has(f) ? v.option("ie8") : v.option("ecma") < 2015 || v.option("safari10") ? !Xc(f) : !bk(f, !0);
      return E || d && v.option("keep_quoted_props") ? (v.print_string(f, d), !1) : (v.print_name(f), !0);
    }
    s(u, "print_property_name"), e(Nt, function(f, d) {
      function v(S) {
        var x = S.definition();
        return x ? x.mangled_name || x.name : S.name;
      }
      s(v, "get_name");
      let E = d.option("shorthand") && !(f.key instanceof Se);
      E && f.value instanceof gt && v(f.value) === f.key && !Go.has(f.key) ? u(f.key, f.quote, d) || (d.colon(), f.value.print(d)) : E && f.
      value instanceof sn && f.value.left instanceof gt && v(f.value.left) === f.key ? (u(f.key, f.quote, d) || (d.colon(), f.value.left.print(
      d)), d.space(), d.print("="), d.space(), f.value.right.print(d)) : (f.key instanceof Se ? d.with_square(function() {
        f.key.print(d);
      }) : u(f.key, f.quote, d), d.colon(), f.value.print(d));
    }), e(Ii, (f, d) => {
      f.static && (d.print("static"), d.space()), d.print("#"), u(f.key.name, f.quote, d), f.value && (d.print("="), f.value.print(d)), d.semicolon();
    }), e(Bi, (f, d) => {
      f.static && (d.print("static"), d.space()), f.key instanceof vs ? u(f.key.name, f.quote, d) : (d.print("["), f.key.print(d), d.print("\
]")), f.value && (d.print("="), f.value.print(d)), d.semicolon();
    }), gr.DEFMETHOD("_print_getter_setter", function(f, d, v) {
      var E = this;
      E.static && (v.print("static"), v.space()), f && (v.print(f), v.space()), E.key instanceof hi ? (d && v.print("#"), u(E.key.name, E.quote,
      v), E.key.add_source_map(v)) : v.with_square(function() {
        E.key.print(v);
      }), E.value._do_print(v, !0);
    }), e(On, function(f, d) {
      f._print_getter_setter("set", !1, d);
    }), e(yn, function(f, d) {
      f._print_getter_setter("get", !1, d);
    }), e(on, function(f, d) {
      f._print_getter_setter("set", !0, d);
    }), e($i, function(f, d) {
      f._print_getter_setter("get", !0, d);
    }), e(Kr, function(f, d) {
      var v;
      f.is_generator && f.async ? v = "async*" : f.is_generator ? v = "*" : f.async && (v = "async"), f._print_getter_setter(v, !1, d);
    }), e(ki, function(f, d) {
      var v;
      f.is_generator && f.async ? v = "async*" : f.is_generator ? v = "*" : f.async && (v = "async"), f._print_getter_setter(v, !0, d);
    }), e(Un, function(f, d) {
      f.key.print(d), d.space(), d.print("in"), d.space(), f.value.print(d);
    }), e(Fl, function(f, d) {
      d.print("#" + f.name);
    }), e(Hr, function(f, d) {
      d.print("static"), d.space(), n(f, d);
    }), gt.DEFMETHOD("_do_print", function(f) {
      var d = this.definition();
      f.print_name(d ? d.mangled_name || d.name : this.name);
    }), e(gt, function(f, d) {
      f._do_print(d);
    }), e(xn, fn), e(kr, function(f, d) {
      d.print("this");
    }), e(fo, function(f, d) {
      d.print("super");
    }), e(Ct, function(f, d) {
      d.print(f.getValue());
    }), e(bt, function(f, d) {
      d.print_string(f.getValue(), f.quote, d.in_directive);
    }), e(We, function(f, d) {
      (d.option("keep_numbers") || d.use_asm) && f.raw ? d.print(f.raw) : d.print(_(f.getValue()));
    }), e(un, function(f, d) {
      d.print(f.getValue() + "n");
    });
    let l = /(<\s*\/\s*script)/i, c = /^\s*script/i, p = /* @__PURE__ */ s((f, d) => d.replace("/", "\\/"), "slash_script_replace");
    e($r, function(f, d) {
      let { source: v, flags: E } = f.getValue();
      v = Il(v), E = E ? Die(E) : "", v = v.replace(l, p), c.test(v) && d.last().endsWith("<") && d.print(" "), d.print(d.to_utf8(`/${v}/${E}`,
      !1, !0));
      let S = d.parent();
      S instanceof ce && /^\w/.test(S.operator) && S.left === f && d.print(" ");
    });
    function h(f, d) {
      d.option("braces") ? g(f, d) : !f || f instanceof Rt ? d.force_semicolon() : f instanceof Dn || f instanceof wn || f instanceof ht ? g(
      f, d) : f.print(d);
    }
    s(h, "print_maybe_braced_body");
    function y(f) {
      for (var d = f[0], v = d.length, E = 1; E < f.length; ++E)
        f[E].length < v && (d = f[E], v = d.length);
      return d;
    }
    s(y, "best_of");
    function _(f) {
      var d = f.toString(10).replace(/^0\./, ".").replace("e+", "e"), v = [d];
      Math.floor(f) === f && (f < 0 ? v.push("-0x" + (-f).toString(16).toLowerCase()) : v.push("0x" + f.toString(16).toLowerCase()));
      var E, S, x;
      return (E = /^\.0+/.exec(d)) ? (S = E[0].length, x = d.slice(S), v.push(x + "e-" + (x.length + S - 1))) : (E = /0+$/.exec(d)) ? (S = E[0].
      length, v.push(d.slice(0, -S) + "e" + S)) : (E = /^(\d)\.(\d+)e(-?\d+)$/.exec(d)) && v.push(E[1] + E[2] + "e" + (E[3] - E[2].length)),
      y(v);
    }
    s(_, "make_num");
    function g(f, d) {
      !f || f instanceof Rt ? d.print("{}") : f instanceof ot ? f.print(d) : d.with_block(function() {
        d.indent(), f.print(d), d.newline();
      });
    }
    s(g, "make_block");
    function m(f, d) {
      f.forEach(function(v) {
        v.DEFMETHOD("add_source_map", d);
      });
    }
    s(m, "DEFMAP"), m([
      // We could easily add info for ALL nodes, but it seems to me that
      // would be quite wasteful, hence this noop in the base class.
      Se,
      // since the label symbol will mark it
      wr,
      Kt
    ], fn), m([
      pt,
      ot,
      mn,
      ht,
      Ct,
      is,
      cr,
      wi,
      uo,
      ql,
      Ue,
      gi,
      Tt,
      Bl,
      gt,
      Vr,
      Ts,
      jr,
      Bn,
      mi
    ], function(f) {
      f.add_mapping(this.start);
    }), m([
      yn,
      On,
      $i,
      on,
      Kr,
      ki
    ], function(f) {
      f.add_mapping(
        this.start,
        !1
        /*name handled below*/
      );
    }), m([
      hi,
      Fl
    ], function(f) {
      let d = this.end && this.end.type;
      d === "name" || d === "privatename" ? f.add_mapping(this.end, this.name) : f.add_mapping(this.end);
    }), m([gr], function(f) {
      f.add_mapping(this.start, this.key);
    });
  })();
});

// ../node_modules/terser/lib/equivalent-to.js
var Gie, Wie, br, $ie = at(() => {
  Di();
  Gie = /* @__PURE__ */ s((e, t) => e === null && t === null || e.TYPE === t.TYPE && e.shallow_cmp(t), "shallow_cmp"), Wie = /* @__PURE__ */ s(
  (e, t) => {
    if (!Gie(e, t)) return !1;
    let r = [e], i = [t], n = r.push.bind(r), a = i.push.bind(i);
    for (; r.length && i.length; ) {
      let o = r.pop(), u = i.pop();
      if (!Gie(o, u) || (o._children_backwards(n), u._children_backwards(a), r.length !== i.length))
        return !1;
    }
    return r.length == 0 && i.length == 0;
  }, "equivalent_to"), br = /* @__PURE__ */ s(() => !0, "pass_through");
  Se.prototype.shallow_cmp = function() {
    throw new Error("did not find a shallow_cmp function for " + this.constructor.name);
  };
  is.prototype.shallow_cmp = br;
  wi.prototype.shallow_cmp = function(e) {
    return this.value === e.value;
  };
  qe.prototype.shallow_cmp = br;
  Tr.prototype.shallow_cmp = br;
  Rt.prototype.shallow_cmp = br;
  wr.prototype.shallow_cmp = function(e) {
    return this.label.name === e.label.name;
  };
  Pn.prototype.shallow_cmp = br;
  qn.prototype.shallow_cmp = br;
  yr.prototype.shallow_cmp = function(e) {
    return (this.init == null ? e.init == null : this.init === e.init) && (this.condition == null ? e.condition == null : this.condition ===
    e.condition) && (this.step == null ? e.step == null : this.step === e.step);
  };
  Or.prototype.shallow_cmp = br;
  ka.prototype.shallow_cmp = br;
  di.prototype.shallow_cmp = br;
  Kt.prototype.shallow_cmp = br;
  ft.prototype.shallow_cmp = br;
  Ue.prototype.shallow_cmp = function(e) {
    return this.is_generator === e.is_generator && this.async === e.async;
  };
  Ut.prototype.shallow_cmp = function(e) {
    return this.is_array === e.is_array;
  };
  pn.prototype.shallow_cmp = br;
  jr.prototype.shallow_cmp = br;
  Bn.prototype.shallow_cmp = function(e) {
    return this.value === e.value;
  };
  ql.prototype.shallow_cmp = br;
  Kn.prototype.shallow_cmp = br;
  Mi.prototype.shallow_cmp = br;
  Oi.prototype.shallow_cmp = function(e) {
    return this.is_star === e.is_star;
  };
  Ft.prototype.shallow_cmp = function(e) {
    return this.alternative == null ? e.alternative == null : this.alternative === e.alternative;
  };
  Vr.prototype.shallow_cmp = br;
  Ts.prototype.shallow_cmp = br;
  mi.prototype.shallow_cmp = function(e) {
    return this.body === e.body && (this.bcatch == null ? e.bcatch == null : this.bcatch === e.bcatch) && (this.bfinally == null ? e.bfinally ==
    null : this.bfinally === e.bfinally);
  };
  mn.prototype.shallow_cmp = function(e) {
    return this.argname == null ? e.argname == null : this.argname === e.argname;
  };
  uo.prototype.shallow_cmp = br;
  cr.prototype.shallow_cmp = br;
  Lt.prototype.shallow_cmp = function(e) {
    return this.value == null ? e.value == null : this.value === e.value;
  };
  Cn.prototype.shallow_cmp = br;
  yi.prototype.shallow_cmp = function(e) {
    return (this.imported_name == null ? e.imported_name == null : this.imported_name === e.imported_name) && (this.imported_names == null ?
    e.imported_names == null : this.imported_names === e.imported_names);
  };
  ss.prototype.shallow_cmp = br;
  dr.prototype.shallow_cmp = function(e) {
    return (this.exported_definition == null ? e.exported_definition == null : this.exported_definition === e.exported_definition) && (this.
    exported_value == null ? e.exported_value == null : this.exported_value === e.exported_value) && (this.exported_names == null ? e.exported_names ==
    null : this.exported_names === e.exported_names) && this.module_name === e.module_name && this.is_default === e.is_default;
  };
  Fe.prototype.shallow_cmp = br;
  Qe.prototype.shallow_cmp = br;
  je.prototype.shallow_cmp = br;
  er.prototype.shallow_cmp = br;
  It.prototype.shallow_cmp = function(e) {
    return this.property === e.property;
  };
  Wi.prototype.shallow_cmp = function(e) {
    return this.property === e.property;
  };
  Ht.prototype.shallow_cmp = function(e) {
    return this.operator === e.operator;
  };
  ce.prototype.shallow_cmp = function(e) {
    return this.operator === e.operator;
  };
  it.prototype.shallow_cmp = br;
  pt.prototype.shallow_cmp = br;
  Tt.prototype.shallow_cmp = br;
  gr.prototype.shallow_cmp = br;
  Nt.prototype.shallow_cmp = function(e) {
    return this.key === e.key;
  };
  On.prototype.shallow_cmp = function(e) {
    return this.static === e.static;
  };
  yn.prototype.shallow_cmp = function(e) {
    return this.static === e.static;
  };
  Kr.prototype.shallow_cmp = function(e) {
    return this.static === e.static && this.is_generator === e.is_generator && this.async === e.async;
  };
  ki.prototype.shallow_cmp = function(e) {
    return this.static === e.static && this.is_generator === e.is_generator && this.async === e.async;
  };
  ht.prototype.shallow_cmp = function(e) {
    return (this.name == null ? e.name == null : this.name === e.name) && (this.extends == null ? e.extends == null : this.extends === e.extends);
  };
  Bi.prototype.shallow_cmp = function(e) {
    return this.static === e.static && (typeof this.key == "string" ? this.key === e.key : !0);
  };
  Ii.prototype.shallow_cmp = function(e) {
    return this.static === e.static;
  };
  gt.prototype.shallow_cmp = function(e) {
    return this.name === e.name;
  };
  lo.prototype.shallow_cmp = br;
  kr.prototype.shallow_cmp = br;
  fo.prototype.shallow_cmp = br;
  bt.prototype.shallow_cmp = function(e) {
    return this.value === e.value;
  };
  We.prototype.shallow_cmp = function(e) {
    return this.value === e.value;
  };
  un.prototype.shallow_cmp = function(e) {
    return this.value === e.value;
  };
  $r.prototype.shallow_cmp = function(e) {
    return this.value.flags === e.value.flags && this.value.source === e.value.source;
  };
  Xo.prototype.shallow_cmp = br;
});

// ../node_modules/terser/lib/scope.js
function Tk(e) {
  if (e.orig[0] instanceof Vn && e.scope.is_block_scope())
    return e.scope.get_defun_scope().variables.get(e.name);
}
function apt(e) {
  let t = /* @__PURE__ */ new Set();
  for (let r of new Set(e))
    (/* @__PURE__ */ s(function i(n) {
      n == null || t.has(n) || (t.add(n), i(n.parent_scope));
    }, "bubble_up"))(r);
  return [...t];
}
function Ek(e, t) {
  let r;
  oh && (r = e.get_defun_scope()) && oh.has(r) && (e = r);
  var i = e.enclosed, n = t.nth_identifier;
  e: for (; ; ) {
    var a = n.get(++e.cname);
    if (!Go.has(a) && !t.reserved.has(a)) {
      if (ah && ah.has(a)) continue e;
      for (let o = i.length; --o >= 0; ) {
        let u = i[o], l = u.mangled_name || u.unmangleable(t) && u.name;
        if (a == l) continue e;
      }
      return a;
    }
  }
}
function ty(e) {
  return e = Mn(e, {
    eval: !1,
    nth_identifier: jl,
    ie8: !1,
    keep_classnames: !1,
    keep_fnames: !1,
    module: !1,
    reserved: [],
    toplevel: !1
  }), e.module && (e.toplevel = !0), !Array.isArray(e.reserved) && !(e.reserved instanceof Set) && (e.reserved = []), e.reserved = new Set(e.
  reserved), e.reserved.add("arguments"), e;
}
var ZS, spt, sh, ah, oh, tf, jl, ry = at(() => {
  "use strict";
  Gi();
  Di();
  Rl();
  ZS = 1, spt = 2, sh = null, ah = null, oh = null, tf = class e {
    static {
      s(this, "SymbolDef");
    }
    constructor(t, r, i) {
      this.name = r.name, this.orig = [r], this.init = i, this.eliminated = 0, this.assignments = 0, this.scope = t, this.replaced = 0, this.
      global = !1, this.export = 0, this.mangled_name = null, this.undeclared = !1, this.id = e.next_id++, this.chained = !1, this.direct_access =
      !1, this.escaped = 0, this.recursive_refs = 0, this.references = [], this.should_replace = void 0, this.single_use = !1, this.fixed = !1,
      Object.seal(this);
    }
    fixed_value() {
      return !this.fixed || this.fixed instanceof Se ? this.fixed : this.fixed();
    }
    unmangleable(t) {
      return t || (t = {}), sh && sh.has(this.id) && kl(t.keep_fnames, this.orig[0].name) ? !0 : this.global && !t.toplevel || this.export &
      ZS || this.undeclared || !t.eval && this.scope.pinned() || (this.orig[0] instanceof kn || this.orig[0] instanceof jn) && kl(t.keep_fnames,
      this.orig[0].name) || this.orig[0] instanceof hi || (this.orig[0] instanceof Jc || this.orig[0] instanceof Yc) && kl(t.keep_classnames,
      this.orig[0].name);
    }
    mangle(t) {
      let r = t.cache && t.cache.props;
      if (this.global && r && r.has(this.name))
        this.mangled_name = r.get(this.name);
      else if (!this.mangled_name && !this.unmangleable(t)) {
        var i = this.scope, n = this.orig[0];
        t.ie8 && n instanceof kn && (i = i.parent_scope);
        let a = Tk(this);
        this.mangled_name = a ? a.mangled_name || a.name : i.next_mangled(t, this), this.global && r && r.set(this.name, this.mangled_name);
      }
    }
  };
  tf.next_id = 1;
  s(Tk, "redefined_catch_def");
  Ye.DEFMETHOD("figure_out_scope", function(e, { parent_scope: t = void 0, toplevel: r = this } = {}) {
    if (e = Mn(e, {
      cache: null,
      ie8: !1,
      safari10: !1,
      module: !1
    }), !(r instanceof Kt))
      throw new Error("Invalid toplevel scope");
    var i = this.parent_scope = t, n = /* @__PURE__ */ new Map(), a = null, o = null, u = [], p = new Mr((h, y) => {
      if (h.is_block_scope()) {
        let S = i;
        if (h.block_scope = i = new Ye(h), i._block_scope = !0, i.init_scope_vars(S), i.uses_with = S.uses_with, i.uses_eval = S.uses_eval, e.
        safari10 && (h instanceof yr || h instanceof Or || h instanceof ka) && u.push(i), h instanceof Vr) {
          let x = i;
          i = S, h.expression.walk(p), i = x;
          for (let C = 0; C < h.body.length; C++)
            h.body[C].walk(p);
        } else
          y();
        return i = S, !0;
      }
      if (h instanceof Ut) {
        let S = o;
        return o = h, y(), o = S, !0;
      }
      if (h instanceof Ye) {
        h.init_scope_vars(i);
        var _ = i, g = a, m = n;
        return a = i = h, n = /* @__PURE__ */ new Map(), y(), i = _, a = g, n = m, !0;
      }
      if (h instanceof wr) {
        var f = h.label;
        if (n.has(f.name))
          throw new Error($c("Label {name} defined twice", f));
        return n.set(f.name, f), y(), n.delete(f.name), !0;
      }
      if (h instanceof di) {
        for (var d = i; d; d = d.parent_scope)
          d.uses_with = !0;
        return;
      }
      if (h instanceof gt && (h.scope = i), h instanceof Ll && (h.thedef = h, h.references = []), h instanceof kn)
        a.def_function(h, h.name == "arguments" ? void 0 : a);
      else if (h instanceof jn) {
        let S = a.parent_scope;
        h.scope = p.directives["use strict"] ? S : S.get_defun_scope(), l(h.scope.def_function(h, a), 1);
      } else if (h instanceof Jc)
        l(a.def_variable(h, a), 1);
      else if (h instanceof Fu)
        i.def_variable(h);
      else if (h instanceof Yc)
        l((h.scope = a.parent_scope).def_function(h, a), 1);
      else if (h instanceof bs || h instanceof co || h instanceof la || h instanceof Vn) {
        var v;
        if (h instanceof ho ? v = i.def_variable(h, null) : v = a.def_variable(h, h.TYPE == "SymbolVar" ? null : void 0), v.orig.every((S) => S ===
        h ? !0 : h instanceof ho ? S instanceof kn : !(S instanceof co || S instanceof la)) || Zm(
          `"${h.name}" is redeclared`,
          h.start.file,
          h.start.line,
          h.start.col,
          h.start.pos
        ), h instanceof Nr || l(v, 2), a !== i) {
          h.mark_enclosed();
          var v = i.find_variable(h);
          h.thedef !== v && (h.thedef = v, h.reference());
        }
      } else if (h instanceof Zp) {
        var E = n.get(h.name);
        if (!E) throw new Error($c("Undefined label {name} [{line},{col}]", {
          name: h.name,
          line: h.start.line,
          col: h.start.col
        }));
        h.thedef = E;
      }
      !(i instanceof Kt) && (h instanceof dr || h instanceof yi) && Zm(
        `"${h.TYPE}" statement may only appear at the top level`,
        h.start.file,
        h.start.line,
        h.start.col,
        h.start.pos
      );
    });
    e.module && (p.directives["use strict"] = !0), this.walk(p);
    function l(h, y) {
      if (o) {
        var _ = 0;
        do
          y++;
        while (p.parent(_++) !== o);
      }
      var g = p.parent(y);
      if (h.export = g instanceof dr ? ZS : 0) {
        var m = g.exported_definition;
        (m instanceof tr || m instanceof an) && g.is_default && (h.export = spt);
      }
    }
    s(l, "mark_export"), this instanceof Kt && (this.globals = /* @__PURE__ */ new Map());
    var p = new Mr((h) => {
      if (h instanceof Kn && h.label)
        return h.label.thedef.references.push(h), !0;
      if (h instanceof Te) {
        var y = h.name;
        if (y == "eval" && p.parent() instanceof Fe)
          for (var _ = h.scope; _ && !_.uses_eval; _ = _.parent_scope)
            _.uses_eval = !0;
        var g;
        return p.parent() instanceof Cn && p.parent(1).module_name || !(g = h.scope.find_variable(y)) ? (g = r.def_global(h), h instanceof oo &&
        (g.export = ZS)) : g.scope instanceof Ue && y == "arguments" && (g.scope.get_defun_scope().uses_arguments = !0), h.thedef = g, h.reference(),
        h.scope.is_block_scope() && !(g.orig[0] instanceof ho) && (h.scope = h.scope.get_defun_scope()), !0;
      }
      var m;
      if (h instanceof Vn && (m = Tk(h.definition())))
        for (var _ = h.scope; _ && (Nu(_.enclosed, m), _ !== m.scope); )
          _ = _.parent_scope;
    });
    if (this.walk(p), (e.ie8 || e.safari10) && _r(this, (h) => {
      if (h instanceof Vn) {
        var y = h.name, _ = h.thedef.references, g = h.scope.get_defun_scope(), m = g.find_variable(y) || r.globals.get(y) || g.def_variable(
        h);
        return _.forEach(function(f) {
          f.thedef = m, f.reference();
        }), h.thedef = m, h.reference(), !0;
      }
    }), e.safari10)
      for (let h of u)
        h.parent_scope.variables.forEach(function(y) {
          Nu(h.enclosed, y);
        });
  });
  Kt.DEFMETHOD("def_global", function(e) {
    var t = this.globals, r = e.name;
    if (t.has(r))
      return t.get(r);
    var i = new tf(this, e);
    return i.undeclared = !0, i.global = !0, t.set(r, i), i;
  });
  Ye.DEFMETHOD("init_scope_vars", function(e) {
    this.variables = /* @__PURE__ */ new Map(), this.uses_with = !1, this.uses_eval = !1, this.parent_scope = e, this.enclosed = [], this.cname =
    -1;
  });
  Ye.DEFMETHOD("conflicting_def", function(e) {
    return this.enclosed.find((t) => t.name === e) || this.variables.has(e) || this.parent_scope && this.parent_scope.conflicting_def(e);
  });
  Ye.DEFMETHOD("conflicting_def_shallow", function(e) {
    return this.enclosed.find((t) => t.name === e) || this.variables.has(e);
  });
  Ye.DEFMETHOD("add_child_scope", function(e) {
    if (e.parent_scope === this) return;
    e.parent_scope = this, e instanceof Zt && this instanceof Ue && !this.uses_arguments && (this.uses_arguments = _r(e, (n) => {
      if (n instanceof Te && n.scope instanceof Ue && n.name === "arguments")
        return Yi;
      if (n instanceof Ue && !(n instanceof Zt))
        return !0;
    })), this.uses_with = this.uses_with || e.uses_with, this.uses_eval = this.uses_eval || e.uses_eval;
    let t = (() => {
      let n = [], a = this;
      do
        n.push(a);
      while (a = a.parent_scope);
      return n.reverse(), n;
    })(), r = new Set(e.enclosed), i = [];
    for (let n of t) {
      i.forEach((a) => Nu(n.enclosed, a));
      for (let a of n.variables.values())
        r.has(a) && (Nu(i, a), Nu(n.enclosed, a));
    }
  });
  s(apt, "find_scopes_visible_from");
  Ye.DEFMETHOD("create_symbol", function(e, {
    source: t,
    tentative_name: r,
    scope: i,
    conflict_scopes: n = [i],
    init: a = null
  } = {}) {
    let o;
    if (n = apt(n), r) {
      r = o = r.replace(/(?:^[^a-z_$]|[^a-z0-9_$])/ig, "_");
      let l = 0;
      for (; n.find((c) => c.conflicting_def_shallow(o)); )
        o = r + "$" + l++;
    }
    if (!o)
      throw new Error("No symbol name could be generated in create_symbol()");
    let u = k(e, t, {
      name: o,
      scope: i
    });
    return this.def_variable(u, a || null), u.mark_enclosed(), u;
  });
  Se.DEFMETHOD("is_block_scope", kt);
  ht.DEFMETHOD("is_block_scope", kt);
  Ue.DEFMETHOD("is_block_scope", kt);
  Kt.DEFMETHOD("is_block_scope", kt);
  Ts.DEFMETHOD("is_block_scope", kt);
  Tr.DEFMETHOD("is_block_scope", rn);
  Ye.DEFMETHOD("is_block_scope", function() {
    return this._block_scope || !1;
  });
  ns.DEFMETHOD("is_block_scope", rn);
  Ue.DEFMETHOD("init_scope_vars", function() {
    Ye.prototype.init_scope_vars.apply(this, arguments), this.uses_arguments = !1, this.def_variable(new Nr({
      name: "arguments",
      start: this.start,
      end: this.end
    }));
  });
  Zt.DEFMETHOD("init_scope_vars", function() {
    Ye.prototype.init_scope_vars.apply(this, arguments), this.uses_arguments = !1;
  });
  gt.DEFMETHOD("mark_enclosed", function() {
    for (var e = this.definition(), t = this.scope; t && (Nu(t.enclosed, e), t !== e.scope); )
      t = t.parent_scope;
  });
  gt.DEFMETHOD("reference", function() {
    this.definition().references.push(this), this.mark_enclosed();
  });
  Ye.DEFMETHOD("find_variable", function(e) {
    return e instanceof gt && (e = e.name), this.variables.get(e) || this.parent_scope && this.parent_scope.find_variable(e);
  });
  Ye.DEFMETHOD("def_function", function(e, t) {
    var r = this.def_variable(e, t);
    return (!r.init || r.init instanceof tr) && (r.init = t), r;
  });
  Ye.DEFMETHOD("def_variable", function(e, t) {
    var r = this.variables.get(e.name);
    return r ? (r.orig.push(e), r.init && (r.scope !== e.scope || r.init instanceof jt) && (r.init = t)) : (r = new tf(this, e, t), this.variables.
    set(e.name, r), r.global = !this.parent_scope), e.thedef = r;
  });
  s(Ek, "next_mangled");
  Ye.DEFMETHOD("next_mangled", function(e) {
    return Ek(this, e);
  });
  Kt.DEFMETHOD("next_mangled", function(e) {
    let t, r = this.mangled_names;
    do
      t = Ek(this, e);
    while (r.has(t));
    return t;
  });
  jt.DEFMETHOD("next_mangled", function(e, t) {
    for (var r = t.orig[0] instanceof Nr && this.name && this.name.definition(), i = r ? r.mangled_name || r.name : null; ; ) {
      var n = Ek(this, e);
      if (!i || i != n)
        return n;
    }
  });
  gt.DEFMETHOD("unmangleable", function(e) {
    var t = this.definition();
    return !t || t.unmangleable(e);
  });
  Ll.DEFMETHOD("unmangleable", kt);
  gt.DEFMETHOD("unreferenced", function() {
    return !this.definition().references.length && !this.scope.pinned();
  });
  gt.DEFMETHOD("definition", function() {
    return this.thedef;
  });
  gt.DEFMETHOD("global", function() {
    return this.thedef.global;
  });
  s(ty, "format_mangler_options");
  Kt.DEFMETHOD("mangle_names", function(e) {
    e = ty(e);
    var t = e.nth_identifier, r = -1, i = [];
    e.keep_fnames && (sh = /* @__PURE__ */ new Set());
    let n = this.mangled_names = /* @__PURE__ */ new Set();
    ah = /* @__PURE__ */ new Set(), e.cache && (this.globals.forEach(o), e.cache.props && e.cache.props.forEach(function(u) {
      n.add(u);
    }));
    var a = new Mr(function(u, l) {
      if (u instanceof wr) {
        var c = r;
        return l(), r = c, !0;
      }
      if (u instanceof tr && !(a.parent() instanceof Ye) && (oh = oh || /* @__PURE__ */ new Set(), oh.add(u.parent_scope.get_defun_scope())),
      u instanceof Ye) {
        u.variables.forEach(o);
        return;
      }
      if (u.is_block_scope()) {
        u.block_scope.variables.forEach(o);
        return;
      }
      if (sh && u instanceof Lt && u.value instanceof Ue && !u.value.name && kl(e.keep_fnames, u.name.name)) {
        sh.add(u.name.definition().id);
        return;
      }
      if (u instanceof Ll) {
        let p;
        do
          p = t.get(++r);
        while (Go.has(p));
        return u.mangled_name = p, !0;
      }
      if (!(e.ie8 || e.safari10) && u instanceof Vn) {
        i.push(u.definition());
        return;
      }
    });
    this.walk(a), (e.keep_fnames || e.keep_classnames) && i.forEach((u) => {
      u.name.length < 6 && u.unmangleable(e) && ah.add(u.name);
    }), i.forEach((u) => {
      u.mangle(e);
    }), sh = null, ah = null, oh = null;
    function o(u) {
      u.export & ZS ? ah.add(u.name) : e.reserved.has(u.name) || i.push(u);
    }
    s(o, "collect");
  });
  Kt.DEFMETHOD("find_colliding_names", function(e) {
    let t = e.cache && e.cache.props, r = /* @__PURE__ */ new Set();
    return e.reserved.forEach(i), this.globals.forEach(n), this.walk(new Mr(function(a) {
      a instanceof Ye && a.variables.forEach(n), a instanceof Vn && n(a.definition());
    })), r;
    function i(a) {
      r.add(a);
    }
    s(i, "to_avoid");
    function n(a) {
      var o = a.name;
      if (a.global && t && t.has(o)) o = t.get(o);
      else if (!a.unmangleable(e)) return;
      i(o);
    }
    s(n, "add_def");
  });
  Kt.DEFMETHOD("expand_names", function(e) {
    e = ty(e);
    var t = e.nth_identifier;
    t.reset && t.sort && (t.reset(), t.sort());
    var r = this.find_colliding_names(e), i = 0;
    this.globals.forEach(a), this.walk(new Mr(function(o) {
      o instanceof Ye && o.variables.forEach(a), o instanceof Vn && a(o.definition());
    }));
    function n() {
      var o;
      do
        o = t.get(i++);
      while (r.has(o) || Go.has(o));
      return o;
    }
    s(n, "next_name");
    function a(o) {
      if (o.global && e.cache || o.unmangleable(e) || e.reserved.has(o.name)) return;
      let u = Tk(o), l = o.name = u ? u.name : n();
      o.orig.forEach(function(c) {
        c.name = l;
      }), o.references.forEach(function(c) {
        c.name = l;
      });
    }
    s(a, "rename");
  });
  Se.DEFMETHOD("tail_node", ao);
  Qe.DEFMETHOD("tail_node", function() {
    return this.expressions[this.expressions.length - 1];
  });
  Kt.DEFMETHOD("compute_char_frequency", function(e) {
    e = ty(e);
    var t = e.nth_identifier;
    if (!t.reset || !t.consider || !t.sort)
      return;
    t.reset();
    try {
      Se.prototype.print = function(i, n) {
        this._print(i, n), this instanceof gt && !this.unmangleable(e) ? t.consider(this.name, -1) : e.properties && (this instanceof Wi ? t.
        consider("#" + this.property, -1) : this instanceof It ? t.consider(this.property, -1) : this instanceof fr && r(this.property));
      }, t.consider(this.print_to_string(), 1);
    } finally {
      Se.prototype.print = Se.prototype._print;
    }
    t.sort();
    function r(i) {
      i instanceof bt ? t.consider(i.value, -1) : i instanceof it ? (r(i.consequent), r(i.alternative)) : i instanceof Qe && r(i.tail_node());
    }
    s(r, "skip_string");
  });
  jl = (() => {
    let e = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_".split(""), t = "0123456789".split(""), r, i;
    function n() {
      i = /* @__PURE__ */ new Map(), e.forEach(function(c) {
        i.set(c, 0);
      }), t.forEach(function(c) {
        i.set(c, 0);
      });
    }
    s(n, "reset");
    function a(c, p) {
      for (var h = c.length; --h >= 0; )
        i.set(c[h], i.get(c[h]) + p);
    }
    s(a, "consider");
    function o(c, p) {
      return i.get(p) - i.get(c);
    }
    s(o, "compare");
    function u() {
      r = pk(e, o).concat(pk(t, o));
    }
    s(u, "sort"), n(), u();
    function l(c) {
      var p = "", h = 54;
      c++;
      do
        c--, p += r[c % h], c = Math.floor(c / h), h = 64;
      while (c > 0);
      return p;
    }
    return s(l, "base54"), {
      get: l,
      consider: a,
      reset: n,
      sort: u
    };
  })();
});

// ../node_modules/terser/lib/size.js
var e0, Xr, iy, t0, r0, Ak = at(() => {
  Di();
  nh();
  Se.prototype.size = function(e, t) {
    e0 = e && e._mangle_options;
    let r = 0;
    return ih(this, (i, n) => {
      if (r += i._size(n), i instanceof Zt && i.is_braceless())
        return r += i.body[0].value._size(n), !0;
    }, t || e && e.stack), e0 = void 0, r;
  };
  Se.prototype._size = () => 0;
  is.prototype._size = () => 8;
  wi.prototype._size = function() {
    return 2 + this.value.length;
  };
  Xr = /* @__PURE__ */ s((e) => e.length && e.length - 1, "list_overhead");
  Tr.prototype._size = function() {
    return 2 + Xr(this.body);
  };
  Kt.prototype._size = function() {
    return Xr(this.body);
  };
  Rt.prototype._size = () => 1;
  wr.prototype._size = () => 2;
  Pn.prototype._size = () => 9;
  qn.prototype._size = () => 7;
  yr.prototype._size = () => 8;
  Or.prototype._size = () => 8;
  di.prototype._size = () => 6;
  ft.prototype._size = () => 3;
  iy = /* @__PURE__ */ s((e) => (e.is_generator ? 1 : 0) + (e.async ? 6 : 0), "lambda_modifiers");
  rs.prototype._size = function() {
    return iy(this) + 4 + Xr(this.argnames) + Xr(this.body);
  };
  jt.prototype._size = function(e) {
    return !!os(e) * 2 + iy(this) + 12 + Xr(this.argnames) + Xr(this.body);
  };
  tr.prototype._size = function() {
    return iy(this) + 13 + Xr(this.argnames) + Xr(this.body);
  };
  Zt.prototype._size = function() {
    let e = 2 + Xr(this.argnames);
    this.argnames.length === 1 && this.argnames[0] instanceof gt || (e += 2);
    let t = this.is_braceless() ? 0 : Xr(this.body) + 2;
    return iy(this) + e + t;
  };
  Ut.prototype._size = () => 2;
  jr.prototype._size = function() {
    return 2 + Math.floor(this.segments.length / 2) * 3;
  };
  Bn.prototype._size = function() {
    return this.value.length;
  };
  mr.prototype._size = function() {
    return this.value ? 7 : 6;
  };
  Bu.prototype._size = () => 6;
  hn.prototype._size = function() {
    return this.label ? 6 : 5;
  };
  ua.prototype._size = function() {
    return this.label ? 9 : 8;
  };
  Ft.prototype._size = () => 4;
  Vr.prototype._size = function() {
    return 8 + Xr(this.body);
  };
  dn.prototype._size = function() {
    return 5 + Xr(this.body);
  };
  zs.prototype._size = function() {
    return 8 + Xr(this.body);
  };
  mi.prototype._size = () => 3;
  mn.prototype._size = function() {
    let e = 7 + Xr(this.body);
    return this.argname && (e += 2), e;
  };
  uo.prototype._size = function() {
    return 7 + Xr(this.body);
  };
  Fr.prototype._size = function() {
    return 4 + Xr(this.definitions);
  };
  Dn.prototype._size = function() {
    return 4 + Xr(this.definitions);
  };
  wn.prototype._size = function() {
    return 6 + Xr(this.definitions);
  };
  Lt.prototype._size = function() {
    return this.value ? 1 : 0;
  };
  Cn.prototype._size = function() {
    return this.name ? 4 : 0;
  };
  yi.prototype._size = function() {
    let e = 6;
    return this.imported_name && (e += 1), (this.imported_name || this.imported_names) && (e += 5), this.imported_names && (e += 2 + Xr(this.
    imported_names)), e;
  };
  ss.prototype._size = () => 11;
  dr.prototype._size = function() {
    let e = 7 + (this.is_default ? 8 : 0);
    return this.exported_value && (e += this.exported_value._size()), this.exported_names && (e += 2 + Xr(this.exported_names)), this.module_name &&
    (e += 5), e;
  };
  Fe.prototype._size = function() {
    return this.optional ? 4 + Xr(this.args) : 2 + Xr(this.args);
  };
  gi.prototype._size = function() {
    return 6 + Xr(this.args);
  };
  Qe.prototype._size = function() {
    return Xr(this.expressions);
  };
  It.prototype._size = function() {
    return this.optional ? this.property.length + 2 : this.property.length + 1;
  };
  Wi.prototype._size = function() {
    return this.optional ? this.property.length + 3 : this.property.length + 2;
  };
  fr.prototype._size = function() {
    return this.optional ? 4 : 2;
  };
  Ht.prototype._size = function() {
    return this.operator === "typeof" ? 7 : this.operator === "void" ? 5 : this.operator.length;
  };
  ce.prototype._size = function(e) {
    if (this.operator === "in") return 4;
    let t = this.operator.length;
    return (this.operator === "+" || this.operator === "-") && this.right instanceof Ht && this.right.operator === this.operator && (t += 1),
    this.needs_parens(e) && (t += 2), t;
  };
  it.prototype._size = () => 3;
  pt.prototype._size = function() {
    return 2 + Xr(this.elements);
  };
  Tt.prototype._size = function(e) {
    let t = 2;
    return os(e) && (t += 2), t + Xr(this.properties);
  };
  t0 = /* @__PURE__ */ s((e) => typeof e == "string" ? e.length : 0, "key_size");
  Nt.prototype._size = function() {
    return t0(this.key) + 1;
  };
  r0 = /* @__PURE__ */ s((e) => e ? 7 : 0, "static_size");
  yn.prototype._size = function() {
    return 5 + r0(this.static) + t0(this.key);
  };
  On.prototype._size = function() {
    return 5 + r0(this.static) + t0(this.key);
  };
  Kr.prototype._size = function() {
    return r0(this.static) + t0(this.key) + iy(this);
  };
  ki.prototype._size = function() {
    return Kr.prototype._size.call(this) + 1;
  };
  $i.prototype._size = function() {
    return Kr.prototype._size.call(this) + 4;
  };
  on.prototype._size = function() {
    return Kr.prototype._size.call(this) + 4;
  };
  Un.prototype._size = function() {
    return 5;
  };
  ht.prototype._size = function() {
    return (this.name ? 8 : 7) + (this.extends ? 8 : 0);
  };
  Hr.prototype._size = function() {
    return 8 + Xr(this.body);
  };
  Bi.prototype._size = function() {
    return r0(this.static) + (typeof this.key == "string" ? this.key.length + 2 : 0) + (this.value ? 1 : 0);
  };
  Ii.prototype._size = function() {
    return Bi.prototype._size.call(this) + 1;
  };
  gt.prototype._size = function() {
    return e0 && this.thedef && !this.thedef.unmangleable(e0) ? 1 : this.name.length;
  };
  vs.prototype._size = function() {
    return this.name.length;
  };
  Te.prototype._size = Lr.prototype._size = function() {
    return this.name === "arguments" ? 9 : gt.prototype._size.call(this);
  };
  lo.prototype._size = () => 10;
  Wo.prototype._size = function() {
    return this.name.length;
  };
  oa.prototype._size = function() {
    return this.name.length;
  };
  kr.prototype._size = () => 4;
  fo.prototype._size = () => 5;
  bt.prototype._size = function() {
    return this.value.length + 2;
  };
  We.prototype._size = function() {
    let { value: e } = this;
    return e === 0 ? 1 : e > 0 && Math.floor(e) === e ? Math.floor(Math.log10(e) + 1) : e.toString().length;
  };
  un.prototype._size = function() {
    return this.value.length;
  };
  $r.prototype._size = function() {
    return this.value.toString().length;
  };
  Xi.prototype._size = () => 4;
  Ul.prototype._size = () => 3;
  pr.prototype._size = () => 6;
  xn.prototype._size = () => 0;
  mo.prototype._size = () => 8;
  ln.prototype._size = () => 4;
  Ss.prototype._size = () => 5;
  Mi.prototype._size = () => 6;
  Oi.prototype._size = () => 6;
});

// ../node_modules/terser/lib/compress/compressor-flags.js
var _i, gn, Jo, qu = at(() => {
  _i = /* @__PURE__ */ s((e, t) => e.flags & t, "has_flag"), gn = /* @__PURE__ */ s((e, t) => {
    e.flags |= t;
  }, "set_flag"), Jo = /* @__PURE__ */ s((e, t) => {
    e.flags &= ~t;
  }, "clear_flag");
});

// ../node_modules/terser/lib/compress/common.js
function ny(e, t) {
  return t instanceof Qe ? e.push(...t.expressions) : e.push(t), e;
}
function _t(e, t) {
  if (t.length == 1) return t[0];
  if (t.length == 0) throw new Error("trying to create a sequence with length zero!");
  return k(Qe, e, {
    expressions: t.reduce(ny, [])
  });
}
function i0(e) {
  return k(jt, e, {
    uses_arguments: !1,
    argnames: [],
    body: [],
    is_generator: !1,
    async: !1,
    variables: /* @__PURE__ */ new Map(),
    uses_with: !1,
    uses_eval: !1,
    parent_scope: null,
    enclosed: [],
    cname: 0,
    block_scope: void 0
  });
}
function _n(e, t) {
  switch (typeof e) {
    case "string":
      return k(bt, t, {
        value: e
      });
    case "number":
      return isNaN(e) ? k(Ul, t) : isFinite(e) ? 1 / e < 0 ? k($e, t, {
        operator: "-",
        expression: k(We, t, { value: -e })
      }) : k(We, t, { value: e }) : e < 0 ? k($e, t, {
        operator: "-",
        expression: k(mo, t)
      }) : k(mo, t);
    case "bigint":
      return k(un, t, { value: e.toString() });
    case "boolean":
      return k(e ? ln : Ss, t);
    case "undefined":
      return k(pr, t);
    default:
      if (e === null)
        return k(Xi, t, { value: null });
      if (e instanceof RegExp)
        return k($r, t, {
          value: {
            source: Il(e.source),
            flags: e.flags
          }
        });
      throw new Error($c("Can't handle constant of type: {type}", {
        type: typeof e
      }));
  }
}
function yo(e, t) {
  return e.size() > t.size() ? t : e;
}
function opt(e, t) {
  return yo(
    k(qe, e, {
      body: e
    }),
    k(qe, t, {
      body: t
    })
  ).body;
}
function us(e, t, r) {
  return os(e) ? opt(t, r) : yo(t, r);
}
function Ck(e) {
  if (e instanceof Ct)
    return e.getValue();
  if (!(e instanceof $e && e.operator == "void" && e.expression instanceof Ct))
    return e;
}
function n0(e, t) {
  if (t = Ck(t), !(t instanceof Se)) {
    var r;
    if (e instanceof pt) {
      var i = e.elements;
      if (t == "length") return _n(i.length, e);
      typeof t == "number" && t in i && (r = i[t]);
    } else if (e instanceof Tt) {
      t = "" + t;
      for (var n = e.properties, a = n.length; --a >= 0; ) {
        var o = n[a];
        if (!(o instanceof Nt)) return;
        !r && n[a].key === t && (r = n[a].value);
      }
    }
    return r instanceof Te && r.fixed_value() || r;
  }
}
function sy(e, t) {
  var r = !1, i = new Mr(function(n) {
    if (r || n instanceof Ye) return !0;
    if (n instanceof Kn && i.loopcontrol_target(n) === e)
      return r = !0;
  });
  return t instanceof wr && i.push(t), i.push(e), e.body.walk(i), r;
}
function Qo(e, t, r) {
  if (Pk(e, t, r)) {
    let i = k(We, t, { value: 0 });
    return _t(t, [i, r]);
  } else
    return r;
}
function Pk(e, t, r) {
  return e instanceof $e && e.operator == "delete" || e instanceof Fe && e.expression === t && (r instanceof er || r instanceof je || r instanceof
  Te && r.name == "eval");
}
function Vl(e) {
  return e instanceof Zt || e instanceof jt;
}
function ay(e) {
  return e.TYPE != "Call" ? !1 : e.expression instanceof jt || ay(e.expression);
}
function go(e) {
  return e === null || e instanceof Rt ? !0 : e instanceof ot ? e.body.length == 0 : !1;
}
function s0(e) {
  return e instanceof mo || e instanceof Ul || e instanceof pr;
}
function oy(e, t) {
  if (!(e instanceof Te)) return !1;
  for (var r = e.definition().orig, i = r.length; --i >= 0; )
    if (r[i] instanceof t) return !0;
}
function uh(e) {
  return !(e instanceof an || e instanceof tr || e instanceof Dn || e instanceof wn || e instanceof dr || e instanceof yi);
}
function lh(e) {
  if (e === null) return [];
  if (e instanceof ot) return e.body;
  if (e instanceof Rt) return [];
  if (e instanceof Br) return [e];
  throw new Error("Can't convert thing to statement array");
}
function a0(e, t) {
  let r = /* @__PURE__ */ s((i) => {
    if (i instanceof Te && t.includes(i.definition()))
      return Yi;
  }, "find_ref");
  return ih(e, (i, n) => {
    if (i instanceof Ye && i !== e) {
      var a = n.parent();
      return a instanceof Fe && a.expression === i && !(i.async || i.is_generator) ? void 0 : _r(i, r) ? Yi : !0;
    }
  });
}
function ch(e, t) {
  for (var r, i = 0; r = e.parent(i); i++)
    if (r instanceof Ue || r instanceof ht) {
      var n = r.name;
      if (n && n.definition() === t)
        return !0;
    }
  return !1;
}
function wk(e, t) {
  return t.top_retain && e instanceof tr && _i(e, 1024) && e.name && t.top_retain(e.name.definition());
}
var Dk, Uu = at(() => {
  Di();
  Gi();
  nh();
  qu();
  s(ny, "merge_sequence");
  s(_t, "make_sequence");
  s(i0, "make_empty_function");
  s(_n, "make_node_from_constant");
  s(yo, "best_of_expression");
  s(opt, "best_of_statement");
  s(us, "best_of");
  s(Ck, "get_simple_key");
  s(n0, "read_property");
  s(sy, "has_break_or_continue");
  s(Qo, "maintain_this_binding");
  s(Pk, "requires_sequence_to_maintain_binding");
  s(Vl, "is_func_expr");
  s(ay, "is_iife_call");
  s(go, "is_empty");
  Dk = qt("Infinity NaN undefined");
  s(s0, "is_identifier_atom");
  s(oy, "is_ref_of");
  s(uh, "can_be_evicted_from_block");
  s(lh, "as_statement_array");
  s(a0, "is_reachable");
  s(ch, "is_recursive_ref");
  s(wk, "retain_top_func");
});

// ../node_modules/terser/lib/compress/native-objects.js
function Ok(e) {
  let t = /* @__PURE__ */ new Map();
  for (var r of Object.keys(e))
    t.set(r, qt(e[r]));
  return /* @__PURE__ */ s((n, a) => {
    let o = t.get(n);
    return o != null && o.has(a);
  }, "does_have");
}
var nf, rf, o0, u0, Xie, uy = at(() => {
  Gi();
  s(Ok, "make_nested_lookup");
  nf = /* @__PURE__ */ new Set([
    "Number",
    "String",
    "Array",
    "Object",
    "Function",
    "Promise"
  ]), rf = [
    "constructor",
    "toString",
    "valueOf"
  ], o0 = Ok({
    Array: [
      "at",
      "flat",
      "includes",
      "indexOf",
      "join",
      "lastIndexOf",
      "slice",
      ...rf
    ],
    Boolean: rf,
    Function: rf,
    Number: [
      "toExponential",
      "toFixed",
      "toPrecision",
      ...rf
    ],
    Object: rf,
    RegExp: [
      "test",
      ...rf
    ],
    String: [
      "at",
      "charAt",
      "charCodeAt",
      "charPointAt",
      "concat",
      "endsWith",
      "fromCharCode",
      "fromCodePoint",
      "includes",
      "indexOf",
      "italics",
      "lastIndexOf",
      "localeCompare",
      "match",
      "matchAll",
      "normalize",
      "padStart",
      "padEnd",
      "repeat",
      "replace",
      "replaceAll",
      "search",
      "slice",
      "split",
      "startsWith",
      "substr",
      "substring",
      "repeat",
      "toLocaleLowerCase",
      "toLocaleUpperCase",
      "toLowerCase",
      "toUpperCase",
      "trim",
      "trimEnd",
      "trimStart",
      ...rf
    ]
  }), u0 = Ok({
    Array: [
      "isArray"
    ],
    Math: [
      "abs",
      "acos",
      "asin",
      "atan",
      "ceil",
      "cos",
      "exp",
      "floor",
      "log",
      "round",
      "sin",
      "sqrt",
      "tan",
      "atan2",
      "pow",
      "max",
      "min"
    ],
    Number: [
      "isFinite",
      "isNaN"
    ],
    Object: [
      "create",
      "getOwnPropertyDescriptor",
      "getOwnPropertyNames",
      "getPrototypeOf",
      "isExtensible",
      "isFrozen",
      "isSealed",
      "hasOwn",
      "keys"
    ],
    String: [
      "fromCharCode"
    ]
  }), Xie = Ok({
    Math: [
      "E",
      "LN10",
      "LN2",
      "LOG2E",
      "LOG10E",
      "PI",
      "SQRT1_2",
      "SQRT2"
    ],
    Number: [
      "MAX_VALUE",
      "MIN_VALUE",
      "NaN",
      "NEGATIVE_INFINITY",
      "POSITIVE_INFINITY"
    ]
  });
});

// ../node_modules/terser/lib/compress/inference.js
function Ra(e, t) {
  return _i(e, 8) || e instanceof pr || e instanceof $e && e.operator == "void" && !e.expression.has_side_effects(t);
}
function Yie(e, t) {
  let r;
  return e instanceof Xi || Ra(e, t) || e instanceof Te && (r = e.definition().fixed) instanceof Se && Ia(r, t);
}
function sf(e, t) {
  return e instanceof je || e instanceof Fe ? e.optional && Yie(e.expression, t) || sf(e.expression, t) : e instanceof er ? sf(e.expression,
  t) : !1;
}
function Ia(e, t) {
  return Yie(e, t) ? !0 : sf(e, t);
}
function bo(e, t) {
  if (t instanceof Ht && fh.has(t.operator)) return t.expression;
  if (t instanceof ct && t.left === e || t instanceof Or && t.init === e) return e;
}
function Kl(e, t, r, i, n, a) {
  var o = t.parent(n), u = bo(r, o);
  if (u) return u;
  if (!a && o instanceof Fe && o.expression === r && !(i instanceof Zt) && !(i instanceof ht) && !o.is_callee_pure(e) && (!(i instanceof jt) ||
  !(o instanceof gi) && i.contains_this()))
    return !0;
  if (o instanceof pt)
    return Kl(e, t, o, o, n + 1);
  if (o instanceof Nt && r === o.value) {
    var l = t.parent(n + 1);
    return Kl(e, t, l, l, n + 2);
  }
  if (o instanceof je && o.expression === r) {
    var c = n0(i, o.property);
    return !a && Kl(e, t, o, c, n + 1);
  }
}
function f0(e) {
  for (let t = -1, r, i; r = e.parent(t), i = e.parent(t + 1); t++) {
    if (i instanceof Qe)
      if (i.expressions.indexOf(r) !== i.expressions.length - 1) {
        let a = e.parent(t + 2);
        return !(i.expressions.length > 2 || i.expressions.length === 1 || !Pk(a, i, i.expressions[1]));
      } else
        continue;
    if (i instanceof Ht) {
      let n = i.operator;
      if (n === "void")
        return !1;
      if (n === "typeof" || n === "+" || n === "-" || n === "!" || n === "~")
        continue;
    }
    return !(i instanceof qe || i instanceof wr || i instanceof Ye);
  }
  return !0;
}
var ca, c0, _o, fh, upt, Es, Hl = at(() => {
  Di();
  Gi();
  Uu();
  qu();
  uy();
  ca = /* @__PURE__ */ s((e) => e instanceof Te && e.definition().undeclared, "is_undeclared_ref"), c0 = qt("<<< >> << & | ^ ~"), _o = qt("&\
& || ??"), fh = qt("delete ++ --");
  (function(e) {
    let t = qt("! delete"), r = qt("in instanceof == != === !== < <= >= >");
    e(Se, kt), e($e, function() {
      return t.has(this.operator);
    }), e(ce, function() {
      return r.has(this.operator) || _o.has(this.operator) && this.left.is_boolean() && this.right.is_boolean();
    }), e(it, function() {
      return this.consequent.is_boolean() && this.alternative.is_boolean();
    }), e(ct, function() {
      return this.operator == "=" && this.right.is_boolean();
    }), e(Qe, function() {
      return this.tail_node().is_boolean();
    }), e(ln, rn), e(Ss, rn);
  })(function(e, t) {
    e.DEFMETHOD("is_boolean", t);
  });
  (function(e) {
    e(Se, kt), e(We, rn);
    let t = qt("+ - ~ ++ --");
    e(Ht, function() {
      return t.has(this.operator) && !(this.expression instanceof un);
    });
    let r = qt("- * / % & | ^ << >> >>>");
    e(ce, function(i) {
      return r.has(this.operator) || this.operator == "+" && this.left.is_number(i) && this.right.is_number(i);
    }), e(ct, function(i) {
      return r.has(this.operator.slice(0, -1)) || this.operator == "=" && this.right.is_number(i);
    }), e(Qe, function(i) {
      return this.tail_node().is_number(i);
    }), e(it, function(i) {
      return this.consequent.is_number(i) && this.alternative.is_number(i);
    });
  })(function(e, t) {
    e.DEFMETHOD("is_number", t);
  });
  (function(e) {
    e(Se, kt), e(We, function() {
      return this.value === (this.value | 0);
    }), e($e, function() {
      return this.operator == "~" ? this.expression.is_number() : this.operator === "+" ? this.expression.is_32_bit_integer() : !1;
    }), e(ce, function() {
      return c0.has(this.operator);
    });
  })(function(e, t) {
    e.DEFMETHOD("is_32_bit_integer", t);
  });
  (function(e) {
    e(Se, kt), e(bt, rn), e(jr, rn), e($e, function() {
      return this.operator == "typeof";
    }), e(ce, function(t) {
      return this.operator == "+" && (this.left.is_string(t) || this.right.is_string(t));
    }), e(ct, function(t) {
      return (this.operator == "=" || this.operator == "+=") && this.right.is_string(t);
    }), e(Qe, function(t) {
      return this.tail_node().is_string(t);
    }), e(it, function(t) {
      return this.consequent.is_string(t) && this.alternative.is_string(t);
    });
  })(function(e, t) {
    e.DEFMETHOD("is_string", t);
  });
  s(Ra, "is_undefined");
  s(Yie, "is_null_or_undefined");
  s(sf, "is_nullish_shortcircuited");
  s(Ia, "is_nullish");
  (function(e) {
    e(Se, rn), e(Rt, kt), e(Ct, kt), e(kr, kt);
    function t(r, i) {
      for (var n = r.length; --n >= 0; )
        if (r[n].has_side_effects(i))
          return !0;
      return !1;
    }
    s(t, "any"), e(Tr, function(r) {
      return t(this.body, r);
    }), e(Fe, function(r) {
      return !this.is_callee_pure(r) && (!this.expression.is_call_pure(r) || this.expression.has_side_effects(r)) ? !0 : t(this.args, r);
    }), e(Vr, function(r) {
      return this.expression.has_side_effects(r) || t(this.body, r);
    }), e(dn, function(r) {
      return this.expression.has_side_effects(r) || t(this.body, r);
    }), e(mi, function(r) {
      return this.body.has_side_effects(r) || this.bcatch && this.bcatch.has_side_effects(r) || this.bfinally && this.bfinally.has_side_effects(
      r);
    }), e(Ft, function(r) {
      return this.condition.has_side_effects(r) || this.body && this.body.has_side_effects(r) || this.alternative && this.alternative.has_side_effects(
      r);
    }), e(ss, kt), e(wr, function(r) {
      return this.body.has_side_effects(r);
    }), e(qe, function(r) {
      return this.body.has_side_effects(r);
    }), e(Ue, kt), e(ht, function(r) {
      return this.extends && this.extends.has_side_effects(r) ? !0 : t(this.properties, r);
    }), e(Hr, function(r) {
      return t(this.body, r);
    }), e(ce, function(r) {
      return this.left.has_side_effects(r) || this.right.has_side_effects(r);
    }), e(ct, rn), e(it, function(r) {
      return this.condition.has_side_effects(r) || this.consequent.has_side_effects(r) || this.alternative.has_side_effects(r);
    }), e(Ht, function(r) {
      return fh.has(this.operator) || this.expression.has_side_effects(r);
    }), e(Te, function(r) {
      return !this.is_declared(r) && !nf.has(this.name);
    }), e(vs, kt), e(Lr, kt), e(Tt, function(r) {
      return t(this.properties, r);
    }), e(Nt, function(r) {
      return this.computed_key() && this.key.has_side_effects(r) || this.value && this.value.has_side_effects(r);
    }), e([
      Bi,
      Ii
    ], function(r) {
      return this.computed_key() && this.key.has_side_effects(r) || this.static && this.value && this.value.has_side_effects(r);
    }), e([
      ki,
      $i,
      on,
      Kr,
      yn,
      On
    ], function(r) {
      return this.computed_key() && this.key.has_side_effects(r);
    }), e(pt, function(r) {
      return t(this.elements, r);
    }), e(It, function(r) {
      return Ia(this, r) ? this.expression.has_side_effects(r) : !this.optional && this.expression.may_throw_on_access(r) ? !0 : this.expression.
      has_side_effects(r);
    }), e(fr, function(r) {
      if (Ia(this, r))
        return this.expression.has_side_effects(r);
      if (!this.optional && this.expression.may_throw_on_access(r))
        return !0;
      var i = this.property.has_side_effects(r);
      return i && this.optional ? !0 : i || this.expression.has_side_effects(r);
    }), e(er, function(r) {
      return this.expression.has_side_effects(r);
    }), e(Qe, function(r) {
      return t(this.expressions, r);
    }), e(cr, function(r) {
      return t(this.definitions, r);
    }), e(Lt, function() {
      return this.value != null;
    }), e(Bn, kt), e(jr, function(r) {
      return t(this.segments, r);
    });
  })(function(e, t) {
    for (let r of [].concat(e))
      r.DEFMETHOD("has_side_effects", t);
  });
  (function(e) {
    e(Se, rn), e(Ct, kt), e(Rt, kt), e(Ue, kt), e(Lr, kt), e(kr, kt), e(ss, kt);
    function t(r, i) {
      for (var n = r.length; --n >= 0; )
        if (r[n].may_throw(i))
          return !0;
      return !1;
    }
    s(t, "any"), e(ht, function(r) {
      return this.extends && this.extends.may_throw(r) ? !0 : t(this.properties, r);
    }), e(Hr, function(r) {
      return t(this.body, r);
    }), e(pt, function(r) {
      return t(this.elements, r);
    }), e(ct, function(r) {
      return this.right.may_throw(r) ? !0 : !r.has_directive("use strict") && this.operator == "=" && this.left instanceof Te ? !1 : this.left.
      may_throw(r);
    }), e(ce, function(r) {
      return this.left.may_throw(r) || this.right.may_throw(r);
    }), e(Tr, function(r) {
      return t(this.body, r);
    }), e(Fe, function(r) {
      return Ia(this, r) ? !1 : t(this.args, r) ? !0 : this.is_callee_pure(r) ? !1 : this.expression.may_throw(r) ? !0 : !(this.expression instanceof
      Ue) || t(this.expression.body, r);
    }), e(dn, function(r) {
      return this.expression.may_throw(r) || t(this.body, r);
    }), e(it, function(r) {
      return this.condition.may_throw(r) || this.consequent.may_throw(r) || this.alternative.may_throw(r);
    }), e(cr, function(r) {
      return t(this.definitions, r);
    }), e(Ft, function(r) {
      return this.condition.may_throw(r) || this.body && this.body.may_throw(r) || this.alternative && this.alternative.may_throw(r);
    }), e(wr, function(r) {
      return this.body.may_throw(r);
    }), e(Tt, function(r) {
      return t(this.properties, r);
    }), e(Nt, function(r) {
      return this.computed_key() && this.key.may_throw(r) || this.value ? this.value.may_throw(r) : !1;
    }), e([
      Bi,
      Ii
    ], function(r) {
      return this.computed_key() && this.key.may_throw(r) || this.static && this.value && this.value.may_throw(r);
    }), e([
      Kr,
      yn,
      On
    ], function(r) {
      return this.computed_key() && this.key.may_throw(r);
    }), e([
      ki,
      $i,
      on
    ], kt), e(mr, function(r) {
      return this.value && this.value.may_throw(r);
    }), e(Qe, function(r) {
      return t(this.expressions, r);
    }), e(qe, function(r) {
      return this.body.may_throw(r);
    }), e(It, function(r) {
      return Ia(this, r) ? !1 : !this.optional && this.expression.may_throw_on_access(r) || this.expression.may_throw(r);
    }), e(fr, function(r) {
      return Ia(this, r) ? !1 : !this.optional && this.expression.may_throw_on_access(r) || this.expression.may_throw(r) || this.property.may_throw(
      r);
    }), e(er, function(r) {
      return this.expression.may_throw(r);
    }), e(Vr, function(r) {
      return this.expression.may_throw(r) || t(this.body, r);
    }), e(Te, function(r) {
      return !this.is_declared(r) && !nf.has(this.name);
    }), e(vs, kt), e(mi, function(r) {
      return this.bcatch ? this.bcatch.may_throw(r) : this.body.may_throw(r) || this.bfinally && this.bfinally.may_throw(r);
    }), e(Ht, function(r) {
      return this.operator == "typeof" && this.expression instanceof Te ? !1 : this.expression.may_throw(r);
    }), e(Lt, function(r) {
      return this.value ? this.value.may_throw(r) : !1;
    });
  })(function(e, t) {
    for (let r of [].concat(e))
      r.DEFMETHOD("may_throw", t);
  });
  (function(e) {
    function t(r) {
      let i = !0;
      return _r(this, (n) => {
        if (n instanceof Te) {
          if (_i(this, 16))
            return i = !1, Yi;
          var a = n.definition();
          if (Gm(a, this.enclosed) && !this.variables.has(a.name)) {
            if (r) {
              var o = r.find_variable(n);
              if (a.undeclared ? !o : o === a)
                return i = "f", !0;
            }
            return i = !1, Yi;
          }
          return !0;
        }
        if (n instanceof kr && this instanceof Zt)
          return i = !1, Yi;
      }), i;
    }
    s(t, "all_refs_local"), e(Se, kt), e(Ct, rn), e(ht, function(r) {
      if (this.extends && !this.extends.is_constant_expression(r))
        return !1;
      for (let i of this.properties)
        if (i.computed_key() && !i.key.is_constant_expression(r) || i.static && i.value && !i.value.is_constant_expression(r) || i instanceof
        Hr)
          return !1;
      return t.call(this, r);
    }), e(Ue, t), e(Ht, function() {
      return this.expression.is_constant_expression();
    }), e(ce, function() {
      return this.left.is_constant_expression() && this.right.is_constant_expression();
    }), e(pt, function() {
      return this.elements.every((r) => r.is_constant_expression());
    }), e(Tt, function() {
      return this.properties.every((r) => r.is_constant_expression());
    }), e(gr, function() {
      return !!(!(this.key instanceof Se) && this.value && this.value.is_constant_expression());
    });
  })(function(e, t) {
    e.DEFMETHOD("is_constant_expression", t);
  });
  (function(e) {
    Se.DEFMETHOD("may_throw_on_access", function(r) {
      return !r.option("pure_getters") || this._dot_throw(r);
    });
    function t(r) {
      return /strict/.test(r.option("pure_getters"));
    }
    s(t, "is_strict"), e(Se, t), e(Xi, rn), e(pr, rn), e(Ct, kt), e(pt, kt), e(Tt, function(r) {
      if (!t(r)) return !1;
      for (var i = this.properties.length; --i >= 0; )
        if (this.properties[i]._dot_throw(r)) return !0;
      return !1;
    }), e(ht, kt), e(gr, kt), e(yn, rn), e(ft, function(r) {
      return this.expression._dot_throw(r);
    }), e(jt, kt), e(Zt, kt), e(as, kt), e($e, function() {
      return this.operator == "void";
    }), e(ce, function(r) {
      return (this.operator == "&&" || this.operator == "||" || this.operator == "??") && (this.left._dot_throw(r) || this.right._dot_throw(
      r));
    }), e(ct, function(r) {
      return this.logical ? !0 : this.operator == "=" && this.right._dot_throw(r);
    }), e(it, function(r) {
      return this.consequent._dot_throw(r) || this.alternative._dot_throw(r);
    }), e(It, function(r) {
      return t(r) ? this.property == "prototype" ? !(this.expression instanceof jt || this.expression instanceof ht) : !0 : !1;
    }), e(er, function(r) {
      return this.expression._dot_throw(r);
    }), e(Qe, function(r) {
      return this.tail_node()._dot_throw(r);
    }), e(Te, function(r) {
      if (this.name === "arguments" && this.scope instanceof Ue) return !1;
      if (_i(this, 8)) return !0;
      if (!t(r) || ca(this) && this.is_declared(r) || this.is_immutable()) return !1;
      var i = this.fixed_value();
      return !i || i._dot_throw(r);
    });
  })(function(e, t) {
    e.DEFMETHOD("_dot_throw", t);
  });
  s(bo, "is_lhs");
  (function(e) {
    function t(i) {
      return k($e, i, {
        operator: "!",
        expression: i
      });
    }
    s(t, "basic_negation");
    function r(i, n, a) {
      var o = t(i);
      if (a) {
        var u = k(qe, n, {
          body: n
        });
        return yo(o, u) === u ? n : o;
      }
      return yo(o, n);
    }
    s(r, "best"), e(Se, function() {
      return t(this);
    }), e(Br, function() {
      throw new Error("Cannot negate a statement");
    }), e(jt, function() {
      return t(this);
    }), e(ht, function() {
      return t(this);
    }), e(Zt, function() {
      return t(this);
    }), e($e, function() {
      return this.operator == "!" ? this.expression : t(this);
    }), e(Qe, function(i) {
      var n = this.expressions.slice();
      return n.push(n.pop().negate(i)), _t(this, n);
    }), e(it, function(i, n) {
      var a = this.clone();
      return a.consequent = a.consequent.negate(i), a.alternative = a.alternative.negate(i), r(this, a, n);
    }), e(ce, function(i, n) {
      var a = this.clone(), o = this.operator;
      if (i.option("unsafe_comps"))
        switch (o) {
          case "<=":
            return a.operator = ">", a;
          case "<":
            return a.operator = ">=", a;
          case ">=":
            return a.operator = "<", a;
          case ">":
            return a.operator = "<=", a;
        }
      switch (o) {
        case "==":
          return a.operator = "!=", a;
        case "!=":
          return a.operator = "==", a;
        case "===":
          return a.operator = "!==", a;
        case "!==":
          return a.operator = "===", a;
        case "&&":
          return a.operator = "||", a.left = a.left.negate(i, n), a.right = a.right.negate(i), r(this, a, n);
        case "||":
          return a.operator = "&&", a.left = a.left.negate(i, n), a.right = a.right.negate(i), r(this, a, n);
      }
      return t(this);
    });
  })(function(e, t) {
    e.DEFMETHOD("negate", function(r, i) {
      return t.call(this, r, i);
    });
  });
  (function(e) {
    function t(r) {
      return k($e, r, {
        operator: "~",
        expression: r
      });
    }
    s(t, "basic_negation"), e(Se, function() {
      return t(this);
    }), e(We, function() {
      let r = ~this.value;
      return r.toString().length > this.value.toString().length ? t(this) : k(We, this, { value: r });
    }), e($e, function(r) {
      return this.operator == "~" && (r || this.expression.is_32_bit_integer()) ? this.expression : t(this);
    });
  })(function(e, t) {
    e.DEFMETHOD("bitwise_negate", t);
  });
  upt = qt("Boolean decodeURI decodeURIComponent Date encodeURI encodeURIComponent Error escape EvalError isFinite isNaN Number Object parse\
Float parseInt RangeError ReferenceError String SyntaxError TypeError unescape URIError");
  Fe.DEFMETHOD("is_callee_pure", function(e) {
    if (e.option("unsafe")) {
      var t = this.expression, r = this.args && this.args[0] && this.args[0].evaluate(e);
      if (t.expression && t.expression.name === "hasOwnProperty" && (r == null || r.thedef && r.thedef.undeclared))
        return !1;
      if (ca(t) && upt.has(t.name) || t instanceof It && ca(t.expression) && u0(t.expression.name, t.property))
        return !0;
    }
    return this instanceof gi && e.option("pure_new") || e.option("side_effects") && nn(this, eh) ? !0 : !e.pure_funcs(this);
  });
  Se.DEFMETHOD("is_call_pure", kt);
  It.DEFMETHOD("is_call_pure", function(e) {
    if (!e.option("unsafe")) return;
    let t = this.expression, r;
    return t instanceof pt ? r = "Array" : t.is_boolean() ? r = "Boolean" : t.is_number(e) ? r = "Number" : t instanceof $r ? r = "RegExp" :
    t.is_string(e) ? r = "String" : this.may_throw_on_access(e) || (r = "Object"), r != null && o0(r, this.property);
  });
  Es = /* @__PURE__ */ s((e) => e && e.aborts(), "aborts");
  (function(e) {
    e(Br, zo), e(ql, ao);
    function t() {
      for (var r = 0; r < this.body.length; r++)
        if (Es(this.body[r]))
          return this.body[r];
      return null;
    }
    s(t, "block_aborts"), e(yi, zo), e(ot, t), e(Ts, t), e(an, function() {
      for (let r of this.properties)
        if (r instanceof Hr && r.aborts())
          return r;
      return null;
    }), e(Hr, t), e(Ft, function() {
      return this.alternative && Es(this.body) && Es(this.alternative) && this;
    });
  })(function(e, t) {
    e.DEFMETHOD("aborts", t);
  });
  Se.DEFMETHOD("contains_this", function() {
    return _r(this, (e) => {
      if (e instanceof kr) return Yi;
      if (e !== this && e instanceof Ye && !(e instanceof Zt))
        return !0;
    });
  });
  s(Kl, "is_modified");
  s(f0, "is_used_in_expression");
});

// ../node_modules/terser/lib/compress/evaluate.js
function bn(e, t) {
  e.DEFMETHOD("_eval", t);
}
var ph, lpt, cpt, fpt, ppt, hpt, Jie, kk, Qie, dpt, Ik = at(() => {
  Gi();
  Di();
  Hl();
  uy();
  s(bn, "def_eval");
  ph = Symbol("This AST_Chain is nullish");
  Se.DEFMETHOD("evaluate", function(e) {
    if (!e.option("evaluate"))
      return this;
    var t = this._eval(e, 1);
    if (!t || t instanceof RegExp)
      return t;
    if (typeof t == "function" || typeof t == "object" || t == ph)
      return this;
    if (typeof t == "string") {
      let r = this.size(e);
      if (t.length + 2 > r) return this;
    }
    return t;
  });
  lpt = qt("! ~ - + void");
  Se.DEFMETHOD("is_constant", function() {
    return this instanceof Ct ? !(this instanceof $r) : this instanceof $e && lpt.has(this.operator) && // `this.expression` may be an `AST_RegExp`,
    // so not only `.is_constant()`.
    (this.expression instanceof Ct || this.expression.is_constant());
  });
  bn(Br, function() {
    throw new Error($c("Cannot evaluate a statement [{file}:{line},{col}]", this.start));
  });
  bn(Ue, ao);
  bn(ht, ao);
  bn(Se, ao);
  bn(Ct, function() {
    return this.getValue();
  });
  cpt = typeof BigInt == "function";
  bn(un, function() {
    return cpt ? BigInt(this.value) : this;
  });
  bn($r, function(e) {
    let t = e.evaluated_regexps.get(this.value);
    if (t === void 0 && HS(this.value.source)) {
      try {
        let { source: r, flags: i } = this.value;
        t = new RegExp(r, i);
      } catch {
        t = null;
      }
      e.evaluated_regexps.set(this.value, t);
    }
    return t || this;
  });
  bn(jr, function() {
    return this.segments.length !== 1 ? this : this.segments[0].value;
  });
  bn(jt, function(e) {
    if (e.option("unsafe")) {
      var t = /* @__PURE__ */ s(function() {
      }, "fn");
      return t.node = this, t.toString = () => this.print_to_string(), t;
    }
    return this;
  });
  bn(pt, function(e, t) {
    if (e.option("unsafe")) {
      for (var r = [], i = 0, n = this.elements.length; i < n; i++) {
        var a = this.elements[i], o = a._eval(e, t);
        if (a === o)
          return this;
        r.push(o);
      }
      return r;
    }
    return this;
  });
  bn(Tt, function(e, t) {
    if (e.option("unsafe")) {
      for (var r = {}, i = 0, n = this.properties.length; i < n; i++) {
        var a = this.properties[i];
        if (a instanceof ft)
          return this;
        var o = a.key;
        if (o instanceof gt)
          o = o.name;
        else if (o instanceof Se && (o = o._eval(e, t), o === a.key))
          return this;
        if (typeof Object.prototype[o] == "function")
          return this;
        if (!(a.value instanceof jt) && (r[o] = a.value._eval(e, t), r[o] === a.value))
          return this;
      }
      return r;
    }
    return this;
  });
  fpt = qt("! typeof void");
  bn($e, function(e, t) {
    var r = this.expression;
    if (e.option("typeofs") && this.operator == "typeof") {
      if (r instanceof Ue || r instanceof Te && r.fixed_value() instanceof Ue)
        return "function";
      if ((r instanceof Tt || r instanceof pt || r instanceof Te && (r.fixed_value() instanceof Tt || r.fixed_value() instanceof pt)) && !r.
      has_side_effects(e))
        return typeof {};
    }
    if (fpt.has(this.operator) || t++, r = r._eval(e, t), r === this.expression)
      return this;
    switch (this.operator) {
      case "!":
        return !r;
      case "typeof":
        return r instanceof RegExp ? this : typeof r;
      case "void":
        return;
      case "~":
        return ~r;
      case "-":
        return -r;
      case "+":
        return +r;
    }
    return this;
  });
  ppt = qt("&& || ?? === !=="), hpt = qt("== != === !=="), Jie = /* @__PURE__ */ s((e) => typeof e == "object" || typeof e == "function" || typeof e ==
  "symbol", "has_identity");
  bn(ce, function(e, t) {
    ppt.has(this.operator) || t++;
    var r = this.left._eval(e, t);
    if (r === this.left)
      return this;
    var i = this.right._eval(e, t);
    if (i === this.right)
      return this;
    if (r != null && i != null && hpt.has(this.operator) && Jie(r) && Jie(i) && typeof r == typeof i)
      return this;
    if (typeof r == "bigint" != (typeof i == "bigint") || typeof r == "bigint" && (this.operator === ">>>" || this.operator === "/" && Number(
    i) === 0))
      return this;
    var n;
    switch (this.operator) {
      case "&&":
        n = r && i;
        break;
      case "||":
        n = r || i;
        break;
      case "??":
        n = r ?? i;
        break;
      case "|":
        n = r | i;
        break;
      case "&":
        n = r & i;
        break;
      case "^":
        n = r ^ i;
        break;
      case "+":
        n = r + i;
        break;
      case "*":
        n = r * i;
        break;
      case "**":
        n = r ** i;
        break;
      case "/":
        n = r / i;
        break;
      case "%":
        n = r % i;
        break;
      case "-":
        n = r - i;
        break;
      case "<<":
        n = r << i;
        break;
      case ">>":
        n = r >> i;
        break;
      case ">>>":
        n = r >>> i;
        break;
      case "==":
        n = r == i;
        break;
      case "===":
        n = r === i;
        break;
      case "!=":
        n = r != i;
        break;
      case "!==":
        n = r !== i;
        break;
      case "<":
        n = r < i;
        break;
      case "<=":
        n = r <= i;
        break;
      case ">":
        n = r > i;
        break;
      case ">=":
        n = r >= i;
        break;
      default:
        return this;
    }
    return typeof n == "number" && isNaN(n) && e.find_parent(di) ? this : n;
  });
  bn(it, function(e, t) {
    var r = this.condition._eval(e, t);
    if (r === this.condition)
      return this;
    var i = r ? this.consequent : this.alternative, n = i._eval(e, t);
    return n === i ? this : n;
  });
  kk = /* @__PURE__ */ new Set();
  bn(Te, function(e, t) {
    if (kk.has(this))
      return this;
    var r = this.fixed_value();
    if (!r)
      return this;
    kk.add(this);
    let i = r._eval(e, t);
    if (kk.delete(this), i === r)
      return this;
    if (i && typeof i == "object") {
      var n = this.definition().escaped;
      if (n && t > n)
        return this;
    }
    return i;
  });
  Qie = { Array, Math, Number, Object, String }, dpt = /* @__PURE__ */ new Set([
    "dotAll",
    "global",
    "ignoreCase",
    "multiline",
    "sticky",
    "unicode"
  ]);
  bn(je, function(e, t) {
    let r = this.expression._eval(e, t + 1);
    if (r === ph || this.optional && r == null) return ph;
    if (this.property === "length") {
      if (typeof r == "string")
        return r.length;
      if (r instanceof pt && r.elements.every((l) => !(l instanceof ft)) && r.elements.every((l) => !l.has_side_effects(e)))
        return r.elements.length;
    }
    if (e.option("unsafe")) {
      var i = this.property;
      if (i instanceof Se && (i = i._eval(e, t), i === this.property))
        return this;
      var n = this.expression;
      if (ca(n)) {
        var a, o = n.name === "hasOwnProperty" && i === "call" && (a = e.parent() && e.parent().args) && a && a[0] && a[0].evaluate(e);
        if (o = o instanceof It ? o.expression : o, o == null || o.thedef && o.thedef.undeclared)
          return this.clone();
        if (!Xie(n.name, i))
          return this;
        r = Qie[n.name];
      } else {
        if (r instanceof RegExp) {
          if (i == "source")
            return Il(r.source);
          if (i == "flags" || dpt.has(i))
            return r[i];
        }
        if (!r || r === n || !Pi(r, i))
          return this;
        if (typeof r == "function")
          switch (i) {
            case "name":
              return r.node.name ? r.node.name.name : "";
            case "length":
              return r.node.length_property();
            default:
              return this;
          }
      }
      return r[i];
    }
    return this;
  });
  bn(er, function(e, t) {
    let r = this.expression._eval(e, t);
    return r === ph ? void 0 : r === this.expression ? this : r;
  });
  bn(Fe, function(e, t) {
    var r = this.expression;
    let i = r._eval(e, t);
    if (i === ph || this.optional && i == null) return ph;
    if (e.option("unsafe") && r instanceof je) {
      var n = r.property;
      if (n instanceof Se && (n = n._eval(e, t), n === r.property))
        return this;
      var a, o = r.expression;
      if (ca(o)) {
        var u = o.name === "hasOwnProperty" && n === "call" && this.args[0] && this.args[0].evaluate(e);
        if (u = u instanceof It ? u.expression : u, u == null || u.thedef && u.thedef.undeclared)
          return this.clone();
        if (!u0(o.name, n)) return this;
        a = Qie[o.name];
      } else {
        if (a = o._eval(e, t + 1), a === o || !a)
          return this;
        if (!o0(a.constructor.name, n))
          return this;
      }
      for (var l = [], c = 0, p = this.args.length; c < p; c++) {
        var h = this.args[c], y = h._eval(e, t);
        if (h === y)
          return this;
        if (h instanceof Ue)
          return this;
        l.push(y);
      }
      try {
        return a[n].apply(a, l);
      } catch {
      }
    }
    return this;
  });
  bn(gi, ao);
});

// ../node_modules/terser/lib/compress/drop-side-effect-free.js
function Qr(e, t) {
  for (let r of [].concat(e))
    r.DEFMETHOD("drop_side_effect_free", t);
}
function ly(e, t, r) {
  var i = e.length;
  if (!i) return null;
  for (var n = [], a = !1, o = 0; o < i; o++) {
    var u = e[o].drop_side_effect_free(t, r);
    a |= u !== e[o], u && (n.push(u), r = !1);
  }
  return a ? n.length ? n : null : e;
}
var Rk = at(() => {
  Di();
  Gi();
  nh();
  uy();
  Hl();
  qu();
  Uu();
  s(Qr, "def_drop_side_effect_free");
  s(ly, "trim");
  Qr(Se, ao);
  Qr(Ct, zo);
  Qr(kr, zo);
  Qr(Fe, function(e, t) {
    if (sf(this, e))
      return this.expression.drop_side_effect_free(e, t);
    if (!this.is_callee_pure(e)) {
      if (this.expression.is_call_pure(e)) {
        var r = this.args.slice();
        return r.unshift(this.expression.expression), r = ly(r, e, t), r && _t(this, r);
      }
      if (Vl(this.expression) && (!this.expression.name || !this.expression.name.definition().references.length)) {
        var i = this.clone();
        return i.expression.process_expression(!1, e), i;
      }
      return this;
    }
    var n = ly(this.args, e, t);
    return n && _t(this, n);
  });
  Qr(rs, zo);
  Qr(jt, zo);
  Qr(Zt, zo);
  Qr(ht, function(e) {
    let t = [];
    if (this.is_self_referential() && this.has_side_effects(e))
      return this;
    let r = this.extends && this.extends.drop_side_effect_free(e);
    r && t.push(r);
    for (let n of this.properties)
      if (n instanceof Hr) {
        if (n.has_side_effects(e))
          return this;
      } else {
        let a = n.drop_side_effect_free(e);
        a && t.push(a);
      }
    if (!t.length)
      return null;
    let i = _t(this, t);
    return this instanceof an ? k(qe, this, { body: i }) : i;
  });
  Qr([
    Bi,
    Ii
  ], function(e) {
    let t = this.computed_key() && this.key.drop_side_effect_free(e), r = this.static && this.value && this.value.drop_side_effect_free(e);
    return t && r ? _t(this, [t, r]) : t || r || null;
  });
  Qr(ce, function(e, t) {
    var r = this.right.drop_side_effect_free(e);
    if (!r)
      return this.left.drop_side_effect_free(e, t);
    if (_o.has(this.operator)) {
      if (r === this.right)
        return this;
      var i = this.clone();
      return i.right = r, i;
    } else {
      var n = this.left.drop_side_effect_free(e, t);
      return n ? _t(this, [n, r]) : this.right.drop_side_effect_free(e, t);
    }
  });
  Qr(ct, function(e) {
    if (this.logical)
      return this;
    var t = this.left;
    if (t.has_side_effects(e) || e.has_directive("use strict") && t instanceof je && t.expression.is_constant())
      return this;
    for (gn(this, 32); t instanceof je; )
      t = t.expression;
    return t.is_constant_expression(e.find_parent(Ye)) ? this.right.drop_side_effect_free(e) : this;
  });
  Qr(it, function(e) {
    var t = this.consequent.drop_side_effect_free(e), r = this.alternative.drop_side_effect_free(e);
    if (t === this.consequent && r === this.alternative)
      return this;
    if (!t)
      return r ? k(ce, this, {
        operator: "||",
        left: this.condition,
        right: r
      }) : this.condition.drop_side_effect_free(e);
    if (!r)
      return k(ce, this, {
        operator: "&&",
        left: this.condition,
        right: t
      });
    var i = this.clone();
    return i.consequent = t, i.alternative = r, i;
  });
  Qr(Ht, function(e, t) {
    if (fh.has(this.operator))
      return this.expression.has_side_effects(e) ? Jo(this, 32) : gn(this, 32), this;
    if (this.operator == "typeof" && this.expression instanceof Te)
      return null;
    var r = this.expression.drop_side_effect_free(e, t);
    return t && r && ay(r) ? r === this.expression && this.operator == "!" ? this : r.negate(e, t) : r;
  });
  Qr(Te, function(e) {
    return this.is_declared(e) || nf.has(this.name) ? null : this;
  });
  Qr(Tt, function(e, t) {
    var r = ly(this.properties, e, t);
    return r && _t(this, r);
  });
  Qr(Nt, function(e, t) {
    let i = this.key instanceof Se && this.key.drop_side_effect_free(e, t), n = this.value.drop_side_effect_free(e, t);
    return i && n ? _t(this, [i, n]) : i || n;
  });
  Qr([
    Kr,
    yn,
    On
  ], function() {
    return this.computed_key() ? this.key : null;
  });
  Qr([
    ki,
    $i,
    on
  ], function() {
    return null;
  });
  Qr(pt, function(e, t) {
    var r = ly(this.elements, e, t);
    return r && _t(this, r);
  });
  Qr(It, function(e, t) {
    return sf(this, e) ? this.expression.drop_side_effect_free(e, t) : !this.optional && this.expression.may_throw_on_access(e) ? this : this.
    expression.drop_side_effect_free(e, t);
  });
  Qr(fr, function(e, t) {
    if (sf(this, e))
      return this.expression.drop_side_effect_free(e, t);
    if (!this.optional && this.expression.may_throw_on_access(e))
      return this;
    var r = this.property.drop_side_effect_free(e);
    if (r && this.optional) return this;
    var i = this.expression.drop_side_effect_free(e, t);
    return i && r ? _t(this, [i, r]) : i || r;
  });
  Qr(er, function(e, t) {
    return this.expression.drop_side_effect_free(e, t);
  });
  Qr(Qe, function(e) {
    var t = this.tail_node(), r = t.drop_side_effect_free(e);
    if (r === t)
      return this;
    var i = this.expressions.slice(0, -1);
    return r && i.push(r), i.length ? _t(this, i) : k(We, this, { value: 0 });
  });
  Qr(ft, function(e, t) {
    return this.expression.drop_side_effect_free(e, t);
  });
  Qr(Bn, zo);
  Qr(jr, function(e) {
    var t = ly(this.segments, e, os);
    return t && _t(this, t);
  });
});

// ../node_modules/terser/lib/compress/drop-unused.js
var mpt, Zie = at(() => {
  Di();
  Gi();
  ry();
  qu();
  Uu();
  Hl();
  mpt = /keep_assign/;
  Ye.DEFMETHOD("drop_unused", function(e) {
    if (!e.option("unused") || e.has_directive("use asm") || !this.variables) return;
    var t = this;
    if (t.pinned()) return;
    var r = !(t instanceof Kt) || e.toplevel.funcs, i = !(t instanceof Kt) || e.toplevel.vars;
    let n = mpt.test(e.option("unused")) ? kt : function(_) {
      if (_ instanceof ct && !_.logical && (_i(_, 32) || _.operator == "="))
        return _.left;
      if (_ instanceof Ht && _i(_, 32))
        return _.expression;
    };
    var a = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Map();
    t instanceof Kt && e.top_retain && t.variables.forEach(function(_) {
      e.top_retain(_) && a.set(_.id, _);
    });
    var u = /* @__PURE__ */ new Map(), l = /* @__PURE__ */ new Map(), c = this, p = new Mr(function(_, g) {
      if (_ instanceof Ue && _.uses_arguments && !p.has_directive("use strict") && _.argnames.forEach(function(d) {
        if (d instanceof Lr) {
          var v = d.definition();
          a.set(v.id, v);
        }
      }), _ === t) return;
      if (_ instanceof ht && _.has_side_effects(e) && (_.is_self_referential() ? g() : _.visit_nondeferred_class_parts(p)), _ instanceof tr ||
      _ instanceof an) {
        var m = _.name.definition();
        return (p.parent() instanceof dr || !r && c === t) && m.global && a.set(m.id, m), Wm(l, m.id, _), !0;
      }
      let f = c === t;
      if (_ instanceof Nr && f && Wm(u, _.definition().id, _), _ instanceof cr && f) {
        let d = p.parent() instanceof dr;
        return _.definitions.forEach(function(v) {
          if (v.name instanceof bs && Wm(u, v.name.definition().id, v), (d || !i) && _r(v.name, (S) => {
            if (S instanceof Lr) {
              let x = S.definition();
              x.global && a.set(x.id, x);
            }
          }), v.name instanceof Ut && v.walk(p), v.name instanceof Lr && v.value) {
            var E = v.name.definition();
            Wm(l, E.id, v.value), !E.chained && v.name.fixed_value() === v.value && o.set(E.id, v), v.value.has_side_effects(e) && v.value.walk(
            p);
          }
        }), !0;
      }
      return y(_, g);
    });
    t.walk(p), p = new Mr(y), a.forEach(function(_) {
      var g = l.get(_.id);
      g && g.forEach(function(m) {
        m.walk(p);
      });
    });
    var h = new qi(
      /* @__PURE__ */ s(function(g, m, f) {
        var d = h.parent();
        if (i) {
          let J = n(g);
          if (J instanceof Te) {
            var E = J.definition(), v = a.has(E.id);
            if (g instanceof ct) {
              if (!v || o.has(E.id) && o.get(E.id) !== g) {
                let F = g.right.transform(h);
                return !v && !F.has_side_effects(e) && !f0(h) ? f ? sr.skip : k(We, g, { value: 0 }) : Qo(d, g, F);
              }
            } else if (!v)
              return f ? sr.skip : k(We, g, { value: 0 });
          }
        }
        if (c === t) {
          var E;
          if (g.name && (g instanceof ts && !kl(e.option("keep_classnames"), (E = g.name.definition()).name) || g instanceof jt && !kl(e.option(
          "keep_fnames"), (E = g.name.definition()).name)) && (!a.has(E.id) || E.orig.length > 1) && (g.name = null), g instanceof Ue && !(g instanceof
          rs))
            for (var S = !e.option("keep_fargs") || d instanceof Fe && d.expression === g && !g.pinned() && (!g.name || g.name.unreferenced()),
            x = g.argnames, C = x.length; --C >= 0; ) {
              var z = x[C];
              z instanceof ft && (z = z.expression), z instanceof sn && (z = z.left), !(z instanceof Ut) && !a.has(z.definition().id) ? (gn(
              z, 1), S && x.pop()) : S = !1;
            }
          if (g instanceof an && g !== t) {
            let J = g.name.definition();
            if (m(g, this), !(J.global && !r || a.has(J.id))) {
              let F = g.drop_side_effect_free(e);
              return F ?? (J.eliminated++, f ? sr.skip : k(Rt, g));
            }
            return g;
          }
          if (g instanceof tr && g !== t) {
            let J = g.name.definition();
            if (!(J.global && !r || a.has(J.id)))
              return J.eliminated++, f ? sr.skip : k(Rt, g);
          }
          if (g instanceof cr && !(d instanceof Or && d.init === g)) {
            var w = !(d instanceof Kt) && !(g instanceof Fr), D = [], N = [], T = [], R = [];
            switch (g.definitions.forEach(function(J) {
              J.value && (J.value = J.value.transform(h));
              var H = J.name instanceof Ut, F = H ? new tf(null, { name: "<destructure>" }) : J.name.definition();
              if (w && F.global) return T.push(J);
              if (!(i || w) || H && (J.name.names.length || J.name.is_array || e.option("pure_getters") != !0) || a.has(F.id)) {
                if (J.value && o.has(F.id) && o.get(F.id) !== J && (J.value = J.value.drop_side_effect_free(e)), J.name instanceof bs) {
                  var re = u.get(F.id);
                  if (re.length > 1 && (!J.value || F.orig.indexOf(J.name) > F.eliminated)) {
                    if (J.value) {
                      var se = k(Te, J.name, J.name);
                      F.references.push(se);
                      var de = k(ct, J, {
                        operator: "=",
                        logical: !1,
                        left: se,
                        right: J.value
                      });
                      o.get(F.id) === J && o.set(F.id, de), R.push(de.transform(h));
                    }
                    Lu(re, J), F.eliminated++;
                    return;
                  }
                }
                J.value ? (R.length > 0 && (T.length > 0 ? (R.push(J.value), J.value = _t(J.value, R)) : D.push(k(qe, g, {
                  body: _t(g, R)
                })), R = []), T.push(J)) : N.push(J);
              } else if (F.orig[0] instanceof Vn) {
                var he = J.value && J.value.drop_side_effect_free(e);
                he && R.push(he), J.value = null, N.push(J);
              } else {
                var he = J.value && J.value.drop_side_effect_free(e);
                he && R.push(he), F.eliminated++;
              }
            }), (N.length > 0 || T.length > 0) && (g.definitions = N.concat(T), D.push(g)), R.length > 0 && D.push(k(qe, g, {
              body: _t(g, R)
            })), D.length) {
              case 0:
                return f ? sr.skip : k(Rt, g);
              case 1:
                return D[0];
              default:
                return f ? sr.splice(D) : k(ot, g, { body: D });
            }
          }
          if (g instanceof yr) {
            m(g, this);
            var j;
            return g.init instanceof ot && (j = g.init, g.init = j.body.pop(), j.body.push(g)), g.init instanceof qe ? g.init = g.init.body :
            go(g.init) && (g.init = null), j ? f ? sr.splice(j.body) : j : g;
          }
          if (g instanceof wr && g.body instanceof yr) {
            if (m(g, this), g.body instanceof ot) {
              var j = g.body;
              return g.body = j.body.pop(), j.body.push(g), f ? sr.splice(j.body) : j;
            }
            return g;
          }
          if (g instanceof ot)
            return m(g, this), f && g.body.every(uh) ? sr.splice(g.body) : g;
          if (g instanceof Ye && !(g instanceof Hr)) {
            let J = c;
            return c = g, m(g, this), c = J, g;
          }
        }
      }, "before"),
      /* @__PURE__ */ s(function(g, m) {
        if (g instanceof Qe)
          switch (g.expressions.length) {
            case 0:
              return m ? sr.skip : k(We, g, { value: 0 });
            case 1:
              return g.expressions[0];
          }
      }, "after")
    );
    t.transform(h);
    function y(_, g) {
      var m;
      let f = n(_);
      if (f instanceof Te && !oy(_.left, ho) && t.variables.get(f.name) === (m = f.definition()))
        return _ instanceof ct && (_.right.walk(p), !m.chained && _.left.fixed_value() === _.right && o.set(m.id, _)), !0;
      if (_ instanceof Te) {
        if (m = _.definition(), !a.has(m.id) && (a.set(m.id, m), m.orig[0] instanceof Vn)) {
          let v = m.scope.is_block_scope() && m.scope.get_defun_scope().variables.get(m.name);
          v && a.set(v.id, v);
        }
        return !0;
      }
      if (_ instanceof ht)
        return g(), !0;
      if (_ instanceof Ye && !(_ instanceof Hr)) {
        var d = c;
        return c = _, g(), c = d, !0;
      }
    }
    s(y, "scan_ref_scoped");
  });
});

// ../node_modules/terser/lib/compress/reduce-vars.js
function Zr(e, t) {
  e.DEFMETHOD("reduce_vars", t);
}
function Nk(e, t) {
  t.assignments = 0, t.chained = !1, t.direct_access = !1, t.escaped = 0, t.recursive_refs = 0, t.references = [], t.single_use = void 0, t.
  scope.pinned() || t.orig[0] instanceof Nr && t.scope.uses_arguments ? t.fixed = !1 : t.orig[0] instanceof la || !e.exposed(t) ? t.fixed = t.
  init : t.fixed = !1;
}
function Lk(e, t, r) {
  r.variables.forEach(function(i) {
    Nk(t, i), i.fixed === null ? (e.defs_to_safe_ids.set(i.id, e.safe_ids), ju(e, i, !0)) : i.fixed && (e.loop_ids.set(i.id, e.in_loop), ju(
    e, i, !0));
  });
}
function of(e, t) {
  t.block_scope && t.block_scope.variables.forEach((r) => {
    Nk(e, r);
  });
}
function bi(e) {
  e.safe_ids = Object.create(e.safe_ids);
}
function Ui(e) {
  e.safe_ids = Object.getPrototypeOf(e.safe_ids);
}
function ju(e, t, r) {
  e.safe_ids[t.id] = r;
}
function ene(e, t) {
  if (t.single_use == "m") return !1;
  if (e.safe_ids[t.id]) {
    if (t.fixed == null) {
      var r = t.orig[0];
      if (r instanceof Nr || r.name == "arguments") return !1;
      t.fixed = k(pr, r);
    }
    return !0;
  }
  return t.fixed instanceof tr;
}
function Fk(e, t, r, i) {
  if (t.fixed === void 0) return !0;
  let n;
  return t.fixed === null && (n = e.defs_to_safe_ids.get(t.id)) ? (n[t.id] = !1, e.defs_to_safe_ids.delete(t.id), !0) : !Pi(e.safe_ids, t.id) ||
  !ene(e, t) || t.fixed === !1 || t.fixed != null && (!i || t.references.length > t.assignments) ? !1 : t.fixed instanceof tr ? i instanceof
  Se && t.fixed.parent_scope === r : t.orig.every((a) => !(a instanceof la || a instanceof jn || a instanceof kn));
}
function ypt(e, t, r) {
  return t.option("unused") && !r.scope.pinned() && r.references.length - r.recursive_refs == 1 && e.loop_ids.get(r.id) === e.in_loop;
}
function gpt(e) {
  return e ? e.is_constant() || e instanceof Ue || e instanceof kr : !1;
}
function cy(e, t, r, i, n, a = 0, o = 1) {
  var u = e.parent(a);
  if (!(n && (n.is_constant() || n instanceof ts))) {
    if (u instanceof ct && (u.operator === "=" || u.logical) && i === u.right || u instanceof Fe && (i !== u.expression || u instanceof gi) ||
    u instanceof cn && i === u.value && i.scope !== t.scope || u instanceof Lt && i === u.value || u instanceof Oi && i === u.value && i.scope !==
    t.scope) {
      o > 1 && !(n && n.is_constant_expression(r)) && (o = 1), (!t.escaped || t.escaped > o) && (t.escaped = o);
      return;
    } else if (u instanceof pt || u instanceof Mi || u instanceof ce && _o.has(u.operator) || u instanceof it && i !== u.condition || u instanceof
    ft || u instanceof Qe && i === u.tail_node())
      cy(e, t, r, u, u, a + 1, o);
    else if (u instanceof Nt && i === u.value) {
      var l = e.parent(a + 1);
      cy(e, t, r, l, l, a + 2, o);
    } else if (u instanceof je && i === u.expression && (n = n0(n, u.property), cy(e, t, r, u, n, a + 1, o + 1), n))
      return;
    a > 0 || u instanceof Qe && i !== u.tail_node() || u instanceof qe || (t.direct_access = !0);
  }
}
function _pt(e, t, r) {
  Jo(this, 16), bi(e), Lk(e, r, this);
  var i;
  return !this.name && !this.uses_arguments && !this.pinned() && (i = e.parent()) instanceof Fe && i.expression === this && !i.args.some((n) => n instanceof
  ft) && this.argnames.every((n) => n instanceof gt) && this.argnames.forEach((n, a) => {
    if (n.definition) {
      var o = n.definition();
      o.orig.length > 1 || (o.fixed === void 0 && (!this.uses_arguments || e.has_directive("use strict")) ? (o.fixed = function() {
        return i.args[a] || k(pr, i);
      }, e.loop_ids.set(o.id, e.in_loop), ju(e, o, !0)) : o.fixed = !1);
    }
  }), t(), Ui(e), tne(this), !0;
}
function tne(e) {
  let t = [];
  _r(e, (c) => {
    if (c !== e) {
      if (c instanceof tr)
        return t.push(c), !0;
      if (c instanceof Ye || c instanceof qe) return !0;
    }
  });
  let r = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Set(), a = /* @__PURE__ */ new Set();
  for (let c of t) {
    let p = c.name.definition(), h = [];
    for (let y of c.enclosed)
      if (!(y.fixed === !1 || y === p || y.scope.get_defun_scope() !== e)) {
        if (n.add(y.id), y.assignments === 0 && y.orig.length === 1 && y.orig[0] instanceof jn) {
          a.add(y.id), n.add(y.id), a.add(p.id), n.add(p.id), r.has(p.id) || r.set(p.id, []), r.get(p.id).push(y.id);
          continue;
        }
        h.push(y);
      }
    h.length && (i.set(p.id, h), a.add(p.id), n.add(p.id));
  }
  if (!i.size)
    return;
  let o = 1, u = /* @__PURE__ */ new Map(), l = /* @__PURE__ */ new Map();
  ih(e, (c, p) => {
    if (c instanceof gt && c.thedef) {
      let h = c.definition().id;
      o++, n.has(h) && (c instanceof Lr || bo(c, p.parent())) && l.set(h, o), a.has(h) && !u.has(h) && !ch(p, h) && u.set(h, o);
    }
  });
  for (let [c, p] of u) {
    let h = new Set(r.get(c));
    for (let y of h) {
      let _ = u.get(y);
      if (!(_ != null && _ < p)) {
        u.set(y, p);
        for (let g of r.get(y) || [])
          h.add(g);
      }
    }
  }
  for (let [c, p] of i) {
    let h = u.get(c);
    if (h !== void 0)
      for (let y of p) {
        if (y.fixed === !1)
          continue;
        let _ = l.get(y.id) || 0;
        h < _ && (y.fixed = !1);
      }
  }
}
var Mk, Bk = at(() => {
  Di();
  Gi();
  Hl();
  qu();
  Uu();
  s(Zr, "def_reduce_vars");
  Zr(Se, fn);
  s(Nk, "reset_def");
  s(Lk, "reset_variables");
  s(of, "reset_block_variables");
  s(bi, "push");
  s(Ui, "pop");
  s(ju, "mark");
  s(ene, "safe_to_read");
  s(Fk, "safe_to_assign");
  s(ypt, "ref_once");
  s(gpt, "is_immutable");
  s(cy, "mark_escaped");
  Mk = /* @__PURE__ */ s((e) => _r(e, (t) => {
    if (t instanceof gt) {
      var r = t.definition();
      r && (t instanceof Te && r.references.push(t), r.fixed = !1);
    }
  }), "suppress");
  Zr(rs, function(e, t, r) {
    return bi(e), Lk(e, r, this), t(), Ui(e), !0;
  });
  Zr(ct, function(e, t, r) {
    var i = this;
    if (i.left instanceof Ut) {
      Mk(i.left);
      return;
    }
    let n = /* @__PURE__ */ s(() => {
      if (i.logical)
        return i.left.walk(e), bi(e), i.right.walk(e), Ui(e), !0;
    }, "finish_walk");
    var a = i.left;
    if (!(a instanceof Te)) return n();
    var o = a.definition(), u = Fk(e, o, a.scope, i.right);
    if (o.assignments++, !u) return n();
    var l = o.fixed;
    if (!l && i.operator != "=" && !i.logical) return n();
    var c = i.operator == "=", p = c ? i.right : i;
    return Kl(r, e, i, p, 0) ? n() : (o.references.push(a), i.logical || (c || (o.chained = !0), o.fixed = c ? function() {
      return i.right;
    } : function() {
      return k(ce, i, {
        operator: i.operator.slice(0, -1),
        left: l instanceof Se ? l : l(),
        right: i.right
      });
    }), i.logical ? (ju(e, o, !1), bi(e), i.right.walk(e), Ui(e), !0) : (ju(e, o, !1), i.right.walk(e), ju(e, o, !0), cy(e, o, a.scope, i, p,
    0, 1), !0));
  });
  Zr(ce, function(e) {
    if (_o.has(this.operator))
      return this.left.walk(e), bi(e), this.right.walk(e), Ui(e), !0;
  });
  Zr(Tr, function(e, t, r) {
    of(r, this);
  });
  Zr(dn, function(e) {
    return bi(e), this.expression.walk(e), Ui(e), bi(e), Ml(this, e), Ui(e), !0;
  });
  Zr(ht, function(e, t) {
    return Jo(this, 16), bi(e), t(), Ui(e), !0;
  });
  Zr(Hr, function(e, t, r) {
    of(r, this);
  });
  Zr(it, function(e) {
    return this.condition.walk(e), bi(e), this.consequent.walk(e), Ui(e), bi(e), this.alternative.walk(e), Ui(e), !0;
  });
  Zr(er, function(e, t) {
    let r = e.safe_ids;
    return t(), e.safe_ids = r, !0;
  });
  Zr(Fe, function(e) {
    this.expression.walk(e), this.optional && bi(e);
    for (let t of this.args) t.walk(e);
    return !0;
  });
  Zr(je, function(e) {
    if (this.optional)
      return this.expression.walk(e), bi(e), this.property instanceof Se && this.property.walk(e), !0;
  });
  Zr(zs, function(e, t) {
    return bi(e), t(), Ui(e), !0;
  });
  s(_pt, "mark_lambda");
  s(tne, "handle_defined_after_hoist");
  Zr(Ue, _pt);
  Zr(Pn, function(e, t, r) {
    of(r, this);
    let i = e.in_loop;
    return e.in_loop = this, bi(e), this.body.walk(e), sy(this) && (Ui(e), bi(e)), this.condition.walk(e), Ui(e), e.in_loop = i, !0;
  });
  Zr(yr, function(e, t, r) {
    of(r, this), this.init && this.init.walk(e);
    let i = e.in_loop;
    return e.in_loop = this, bi(e), this.condition && this.condition.walk(e), this.body.walk(e), this.step && (sy(this) && (Ui(e), bi(e)), this.
    step.walk(e)), Ui(e), e.in_loop = i, !0;
  });
  Zr(Or, function(e, t, r) {
    of(r, this), Mk(this.init), this.object.walk(e);
    let i = e.in_loop;
    return e.in_loop = this, bi(e), this.body.walk(e), Ui(e), e.in_loop = i, !0;
  });
  Zr(Ft, function(e) {
    return this.condition.walk(e), bi(e), this.body.walk(e), Ui(e), this.alternative && (bi(e), this.alternative.walk(e), Ui(e)), !0;
  });
  Zr(wr, function(e) {
    return bi(e), this.body.walk(e), Ui(e), !0;
  });
  Zr(Vn, function() {
    this.definition().fixed = !1;
  });
  Zr(Te, function(e, t, r) {
    var i = this.definition();
    i.references.push(this), i.references.length == 1 && !i.fixed && i.orig[0] instanceof jn && e.loop_ids.set(i.id, e.in_loop);
    var n;
    i.fixed === void 0 || !ene(e, i) ? i.fixed = !1 : i.fixed && (n = this.fixed_value(), n instanceof Ue && ch(e, i) ? i.recursive_refs++ :
    n && !r.exposed(i) && ypt(e, r, i) ? i.single_use = n instanceof Ue && !n.pinned() || n instanceof ht || i.scope === this.scope && n.is_constant_expression() :
    i.single_use = !1, Kl(r, e, this, n, 0, gpt(n)) && (i.single_use ? i.single_use = "m" : i.fixed = !1)), cy(e, i, this.scope, this, n, 0,
    1);
  });
  Zr(Kt, function(e, t, r) {
    return this.globals.forEach(function(i) {
      Nk(r, i);
    }), Lk(e, r, this), t(), tne(this), !0;
  });
  Zr(mi, function(e, t, r) {
    return of(r, this), bi(e), this.body.walk(e), Ui(e), this.bcatch && (bi(e), this.bcatch.walk(e), Ui(e)), this.bfinally && this.bfinally.
    walk(e), !0;
  });
  Zr(Ht, function(e) {
    var t = this;
    if (!(t.operator !== "++" && t.operator !== "--")) {
      var r = t.expression;
      if (r instanceof Te) {
        var i = r.definition(), n = Fk(e, i, r.scope, !0);
        if (i.assignments++, !!n) {
          var a = i.fixed;
          if (a)
            return i.references.push(r), i.chained = !0, i.fixed = function() {
              return k(ce, t, {
                operator: t.operator.slice(0, -1),
                left: k($e, t, {
                  operator: "+",
                  expression: a instanceof Se ? a : a()
                }),
                right: k(We, t, {
                  value: 1
                })
              });
            }, ju(e, i, !0), !0;
        }
      }
    }
  });
  Zr(Lt, function(e, t) {
    var r = this;
    if (r.name instanceof Ut) {
      Mk(r.name);
      return;
    }
    var i = r.name.definition();
    if (r.value) {
      if (Fk(e, i, r.name.scope, r.value))
        return i.fixed = function() {
          return r.value;
        }, e.loop_ids.set(i.id, e.in_loop), ju(e, i, !1), t(), ju(e, i, !0), !0;
      i.fixed = !1;
    }
  });
  Zr(qn, function(e, t, r) {
    of(r, this);
    let i = e.in_loop;
    return e.in_loop = this, bi(e), t(), Ui(e), e.in_loop = i, !0;
  });
});

// ../node_modules/terser/lib/compress/tighten-body.js
function qk(e) {
  return e instanceof ns && e.body instanceof ot ? e.body : e;
}
function rne(e) {
  if (e instanceof kr) return !0;
  if (e instanceof Te) return e.definition().orig[0] instanceof kn;
  if (e instanceof je) {
    if (e = e.expression, e instanceof Te) {
      if (e.is_immutable()) return !1;
      e = e.fixed_value();
    }
    return e ? e instanceof $r ? !1 : e instanceof Ct ? !0 : rne(e) : !0;
  }
  return !1;
}
function bpt(e) {
  var t = [];
  return e.definitions.forEach(function(r) {
    r.name instanceof Lr ? (r.value = null, t.push(r)) : r.declarations_as_names().forEach((i) => {
      t.push(k(Lt, r, {
        name: i,
        value: null
      }));
    });
  }), t.length ? k(Fr, e, { definitions: t }) : null;
}
function Gl(e, t, r) {
  _r(t, (i) => {
    if (i instanceof Fr) {
      let n = bpt(i);
      return n && r.push(n), !0;
    }
    if (i instanceof tr && (i === t || !e.has_directive("use strict")))
      return r.push(i === t ? i : k(Fr, i, {
        definitions: [
          k(Lt, i, {
            name: k(bs, i.name, i.name),
            value: null
          })
        ]
      })), !0;
    if (i instanceof dr || i instanceof yi)
      return r.push(i), !0;
    if (i instanceof Ye)
      return !0;
  });
}
function fy(e, t) {
  let r = t.find_scope(), i = r.get_defun_scope(), { in_loop: n, in_try: a } = l();
  var o, u = 10;
  do
    o = !1, p(e), t.option("dead_code") && y(e, t), t.option("if_return") && h(e, t), t.sequences_limit > 0 && (g(e, t), f(e, t)), t.option(
    "join_vars") && v(e), t.option("collapse_vars") && c(e, t);
  while (o && u-- > 0);
  function l() {
    var E = t.self(), S = 0, x = !1, C = !1;
    do
      if (E instanceof ns)
        x = !0;
      else {
        if (E instanceof Ye)
          break;
        E instanceof Nl && (C = !0);
      }
    while (E = t.parent(S++));
    return { in_loop: x, in_try: C };
  }
  s(l, "find_loop_scope_try");
  function c(E, S) {
    if (r.pinned() || i.pinned())
      return E;
    for (var x, C = [], z = E.length, w = new qi(function(V) {
      if (X)
        return V;
      if (!ie)
        return V !== N[T] ? V : (T++, T < N.length ? Ee(V) : (ie = !0, J = pe(V, 0), J === V && (X = !0), V));
      var Ce = w.parent();
      if (V instanceof ct && (V.logical || V.operator != "=" && F.equivalent_to(V.left)) || V instanceof Mi || V instanceof Fe && F instanceof
      je && F.equivalent_to(V.expression) || (V instanceof Fe || V instanceof je) && V.optional || V instanceof is || V instanceof Ut || V instanceof
      ft && V.expression instanceof gt && (V.expression instanceof kr || V.expression.definition().references.length > 1) || V instanceof ns &&
      !(V instanceof yr) || V instanceof Kn || V instanceof mi || V instanceof di || V instanceof Oi || V instanceof dr || V instanceof ht ||
      Ce instanceof yr && V !== Ce.init || !he && V instanceof Te && !V.is_declared(S) && !nf.has(V) || V instanceof Te && Ce instanceof Fe &&
      nn(Ce, po) || V instanceof gr && V.key instanceof Se)
        return X = !0, V;
      if (!H && (!se || !he) && (Ce instanceof ce && _o.has(Ce.operator) && Ce.left !== V || Ce instanceof it && Ce.condition !== V || Ce instanceof
      Ft && Ce.condition !== V) && (H = Ce), Oe && !(V instanceof Lr) && F.equivalent_to(V) && !nt(w.find_scope() || r, re)) {
        if (H)
          return X = !0, V;
        if (bo(V, Ce))
          return j && ye++, V;
        if (ye++, j && R instanceof Lt)
          return V;
        if (o = X = !0, R instanceof as)
          return k($e, R, R);
        if (R instanceof Lt) {
          var ke = R.name.definition(), Re = R.value;
          return ke.references.length - ke.replaced == 1 && !S.exposed(ke) ? (ke.replaced++, G && s0(Re) ? Re.transform(S) : Qo(Ce, V, Re)) :
          k(ct, R, {
            operator: "=",
            logical: !1,
            left: k(Te, R.name, R.name),
            right: Re
          });
        }
        return Jo(R, 32), R;
      }
      var St;
      return (V instanceof Fe || V instanceof cn && (de || F instanceof je || Pe(F)) || V instanceof je && (de || V.expression.may_throw_on_access(
      S)) || V instanceof Te && (re.has(V.name) && re.get(V.name).modified || de && Pe(V)) || V instanceof Lt && V.value && (re.has(V.name.name) ||
      de && Pe(V.name)) || (St = bo(V.left, V)) && (St instanceof je || re.has(St.name)) || xe && (a ? V.has_side_effects(S) : ze(V))) && (J =
      V, V instanceof Ye && (X = !0)), Ee(V);
    }, function(V) {
      X || (J === V && (X = !0), H === V && (H = null));
    }), D = new qi(function(V) {
      if (X)
        return V;
      if (!ie)
        return V !== N[T] ? V : (T++, T < N.length ? void 0 : (ie = !0, V));
      if (V instanceof Te && V.name == Vt.name)
        return --ye || (X = !0), bo(V, D.parent()) ? V : (Vt.replaced++, j.replaced--, R.value);
      if (V instanceof zs || V instanceof Ye)
        return V;
    }); --z >= 0; ) {
      z == 0 && S.option("unused") && Ie();
      var N = [];
      for (te(E[z]); C.length > 0; ) {
        N = C.pop();
        var T = 0, R = N[N.length - 1], j = null, J = null, H = null, F = He(R);
        if (!(!F || rne(F) || F.has_side_effects(S))) {
          var re = wt(R), se = ae(F);
          F instanceof Te && re.set(F.name, { def: F.definition(), modified: !1 });
          var de = _e(R), he = be(), xe = R.may_throw(S), G = R.name instanceof Nr, ie = G, X = !1, ye = 0, Oe = !x || !ie;
          if (!Oe) {
            for (let V = S.self().argnames.lastIndexOf(R.name) + 1; !X && V < x.length; V++)
              x[V].transform(w);
            Oe = !0;
          }
          for (var Pt = z; !X && Pt < E.length; Pt++)
            E[Pt].transform(w);
          if (j) {
            var Vt = R.name.definition();
            if (X && Vt.references.length - Vt.replaced > ye)
              ye = !1;
            else {
              X = !1, T = 0, ie = G;
              for (var Pt = z; !X && Pt < E.length; Pt++)
                E[Pt].transform(D);
              j.single_use = !1;
            }
          }
          ye && !xr(R) && E.splice(z, 1);
        }
      }
    }
    function Ee(V) {
      if (V instanceof Ye)
        return V;
      if (V instanceof Vr) {
        V.expression = V.expression.transform(w);
        for (var Ce = 0, ke = V.body.length; !X && Ce < ke; Ce++) {
          var Re = V.body[Ce];
          if (Re instanceof dn) {
            if (!ie) {
              if (Re !== N[T])
                continue;
              T++;
            }
            if (Re.expression = Re.expression.transform(w), !he)
              break;
          }
        }
        return X = !0, V;
      }
    }
    s(Ee, "handle_custom_scan_order");
    function st(V, Ce) {
      if (V.global)
        return !1;
      let ke = V.scope;
      for (; ke && ke !== Ce; ) {
        if (ke.variables.has(V.name))
          return !0;
        ke = ke.parent_scope;
      }
      return !1;
    }
    s(st, "redefined_within_scope");
    function oe(V, Ce, ke) {
      var Re = !1, St = !(V instanceof Zt);
      return Ce.walk(new Mr(function(Mt, yt) {
        if (Re)
          return !0;
        if (Mt instanceof Te && (V.variables.has(Mt.name) || st(Mt.definition(), V))) {
          var rr = Mt.definition().scope;
          if (rr !== i) {
            for (; rr = rr.parent_scope; )
              if (rr === i)
                return !0;
          }
          return Re = !0;
        }
        if ((ke || St) && Mt instanceof kr)
          return Re = !0;
        if (Mt instanceof Ye && !(Mt instanceof Zt)) {
          var qr = St;
          return St = !1, yt(), St = qr, !0;
        }
      })), Re;
    }
    s(oe, "has_overlapping_symbol");
    function Ae(V) {
      return !(V instanceof ft || _r(V, (ke) => {
        if (ke instanceof Mi) return Yi;
      }));
    }
    s(Ae, "arg_is_injectable");
    function Ie() {
      var V, Ce = S.self();
      if (Vl(Ce) && !Ce.name && !Ce.uses_arguments && !Ce.pinned() && (V = S.parent()) instanceof Fe && V.expression === Ce && V.args.every(
      Ae)) {
        var ke = S.has_directive("use strict");
        ke && !Gm(ke, Ce.body) && (ke = !1);
        var Re = Ce.argnames.length;
        x = V.args.slice(Re);
        for (var St = /* @__PURE__ */ new Set(), Mt = Re; --Mt >= 0; ) {
          var yt = Ce.argnames[Mt], rr = V.args[Mt];
          let ha = yt.definition && yt.definition();
          if (!(ha && ha.orig.length > 1) && (x.unshift(k(Lt, yt, {
            name: yt,
            value: rr
          })), !St.has(yt.name)))
            if (St.add(yt.name), yt instanceof ft) {
              var qr = V.args.slice(Mt);
              qr.every(
                (zr) => !oe(Ce, zr, ke)
              ) && C.unshift([k(Lt, yt, {
                name: yt.expression,
                value: k(pt, V, {
                  elements: qr
                })
              })]);
            } else
              rr ? (rr instanceof Ue && rr.pinned() || oe(Ce, rr, ke)) && (rr = null) : rr = k(pr, yt).transform(S), rr && C.unshift([k(Lt, yt,
              {
                name: yt,
                value: rr
              })]);
        }
      }
    }
    s(Ie, "extract_args");
    function te(V) {
      if (N.push(V), V instanceof ct)
        !V.left.has_side_effects(S) && !(V.right instanceof er) && C.push(N.slice()), te(V.right);
      else if (V instanceof ce)
        te(V.left), te(V.right);
      else if (V instanceof Fe && !nn(V, po))
        te(V.expression), V.args.forEach(te);
      else if (V instanceof dn)
        te(V.expression);
      else if (V instanceof it)
        te(V.condition), te(V.consequent), te(V.alternative);
      else if (V instanceof cr) {
        var Ce = V.definitions.length, ke = Ce - 200;
        for (ke < 0 && (ke = 0); ke < Ce; ke++)
          te(V.definitions[ke]);
      } else V instanceof th ? (te(V.condition), V.body instanceof Tr || te(V.body)) : V instanceof cn ? V.value && te(V.value) : V instanceof
      yr ? (V.init && te(V.init), V.condition && te(V.condition), V.step && te(V.step), V.body instanceof Tr || te(V.body)) : V instanceof Or ?
      (te(V.object), V.body instanceof Tr || te(V.body)) : V instanceof Ft ? (te(V.condition), V.body instanceof Tr || te(V.body), V.alternative &&
      !(V.alternative instanceof Tr) && te(V.alternative)) : V instanceof Qe ? V.expressions.forEach(te) : V instanceof qe ? te(V.body) : V instanceof
      Vr ? (te(V.expression), V.body.forEach(te)) : V instanceof Ht ? (V.operator == "++" || V.operator == "--") && C.push(N.slice()) : V instanceof
      Lt && V.value && !(V.value instanceof er) && (C.push(N.slice()), te(V.value));
      N.pop();
    }
    s(te, "extract_candidates");
    function pe(V, Ce, ke) {
      var Re = w.parent(Ce);
      return Re instanceof ct ? ke && !Re.logical && !(Re.left instanceof je || re.has(Re.left.name)) ? pe(Re, Ce + 1, ke) : V : Re instanceof
      ce ? ke && (!_o.has(Re.operator) || Re.left === V) ? pe(Re, Ce + 1, ke) : V : Re instanceof Fe || Re instanceof dn ? V : Re instanceof
      it ? ke && Re.condition === V ? pe(Re, Ce + 1, ke) : V : Re instanceof cr ? pe(Re, Ce + 1, !0) : Re instanceof cn ? ke ? pe(Re, Ce + 1,
      ke) : V : Re instanceof Ft ? ke && Re.condition === V ? pe(Re, Ce + 1, ke) : V : Re instanceof ns ? V : Re instanceof Qe ? pe(Re, Ce +
      1, Re.tail_node() !== V) : Re instanceof qe ? pe(Re, Ce + 1, !0) : Re instanceof Vr || Re instanceof Lt ? V : null;
    }
    s(pe, "find_stop");
    function we(V) {
      var Ce = V.value;
      if (Ce instanceof Te && Ce.name != "arguments") {
        var ke = Ce.definition();
        if (!ke.undeclared)
          return j = ke;
      }
    }
    s(we, "mangleable_var");
    function He(V) {
      if (V instanceof ct && V.logical)
        return !1;
      if (V instanceof Lt && V.name instanceof Lr) {
        var Ce = V.name.definition();
        if (!Gm(V.name, Ce.orig))
          return;
        var ke = Ce.references.length - Ce.replaced;
        if (!ke)
          return;
        var Re = Ce.orig.length - Ce.eliminated;
        if (Re > 1 && !(V.name instanceof Nr) || (ke > 1 ? we(V) : !S.exposed(Ce)))
          return k(Te, V.name, V.name);
      } else {
        let St = V instanceof ct ? V.left : V.expression;
        return !oy(St, la) && !oy(St, co) && St;
      }
    }
    s(He, "get_lhs");
    function vt(V) {
      return V instanceof ct ? V.right : V.value;
    }
    s(vt, "get_rvalue");
    function wt(V) {
      var Ce = /* @__PURE__ */ new Map();
      if (V instanceof Ht)
        return Ce;
      var ke = new Mr(function(Re) {
        for (var St = Re; St instanceof je; )
          St = St.expression;
        if (St instanceof Te) {
          let Mt = Ce.get(St.name);
          (!Mt || !Mt.modified) && Ce.set(St.name, {
            def: St.definition(),
            modified: Kl(S, ke, Re, Re, 0)
          });
        }
      });
      return vt(V).walk(ke), Ce;
    }
    s(wt, "get_lvalues");
    function xr(V) {
      if (V.name instanceof Nr) {
        var Ce = S.parent(), ke = S.self().argnames, Re = ke.indexOf(V.name);
        if (Re < 0)
          Ce.args.length = Math.min(Ce.args.length, ke.length - 1);
        else {
          var St = Ce.args;
          St[Re] && (St[Re] = k(We, St[Re], {
            value: 0
          }));
        }
        return !0;
      }
      var Mt = !1;
      return E[z].transform(new qi(function(yt, rr, qr) {
        if (Mt)
          return yt;
        if (yt === V || yt.body === V)
          return Mt = !0, yt instanceof Lt ? (yt.value = yt.name instanceof la ? k(pr, yt.value) : null, yt) : qr ? sr.skip : null;
      }, function(yt) {
        if (yt instanceof Qe)
          switch (yt.expressions.length) {
            case 0:
              return null;
            case 1:
              return yt.expressions[0];
          }
      }));
    }
    s(xr, "remove_candidate");
    function ae(V) {
      for (; V instanceof je; )
        V = V.expression;
      return V instanceof Te && V.definition().scope.get_defun_scope() === i && !(n && (re.has(V.name) || R instanceof Ht || R instanceof ct &&
      !R.logical && R.operator != "="));
    }
    s(ae, "is_lhs_local");
    function _e(V) {
      return V instanceof Ht ? fh.has(V.operator) : vt(V).has_side_effects(S);
    }
    s(_e, "value_has_side_effects");
    function be() {
      if (de)
        return !1;
      if (j)
        return !0;
      if (F instanceof Te) {
        var V = F.definition();
        if (V.references.length - V.replaced == (R instanceof Lt ? 1 : 2))
          return !0;
      }
      return !1;
    }
    s(be, "replace_all_symbols");
    function Pe(V) {
      if (!V.definition)
        return !0;
      var Ce = V.definition();
      return Ce.orig.length == 1 && Ce.orig[0] instanceof jn ? !1 : Ce.scope.get_defun_scope() !== i ? !0 : Ce.references.some(
        (ke) => ke.scope.get_defun_scope() !== i
      );
    }
    s(Pe, "may_modify");
    function ze(V, Ce) {
      if (V instanceof ct)
        return ze(V.left, !0);
      if (V instanceof Ht)
        return ze(V.expression, !0);
      if (V instanceof Lt)
        return V.value && ze(V.value);
      if (Ce) {
        if (V instanceof It || V instanceof fr)
          return ze(V.expression, !0);
        if (V instanceof Te)
          return V.definition().scope.get_defun_scope() !== i;
      }
      return !1;
    }
    s(ze, "side_effects_external");
    function nt(V, Ce) {
      for (let { def: ke } of Ce.values()) {
        let Re = V.find_variable(ke.name);
        if (Re) {
          if (Re === ke) continue;
          return !0;
        }
      }
      return !1;
    }
    s(nt, "shadows");
  }
  s(c, "collapse");
  function p(E) {
    for (var S = [], x = 0; x < E.length; ) {
      var C = E[x];
      C instanceof ot && C.body.every(uh) ? (o = !0, p(C.body), E.splice(x, 1, ...C.body), x += C.body.length) : C instanceof Rt ? (o = !0, E.
      splice(x, 1)) : C instanceof wi ? S.indexOf(C.value) < 0 ? (x++, S.push(C.value)) : (o = !0, E.splice(x, 1)) : x++;
    }
  }
  s(p, "eliminate_spurious_blocks");
  function h(E, S) {
    var x = S.self(), C = H(E), z = x instanceof Ue;
    let w = Math.min(E.length, 500);
    for (var D = w; --D >= 0; ) {
      var N = E[D], T = he(D), R = E[T];
      if (z && !R && N instanceof mr) {
        if (!N.value) {
          o = !0, E.splice(D, 1);
          continue;
        }
        if (N.value instanceof $e && N.value.operator == "void") {
          o = !0, E[D] = k(qe, N, {
            body: N.value.expression
          });
          continue;
        }
      }
      if (N instanceof Ft) {
        let G, ie;
        if (G = Es(N.body), re(G) && (ie = de(N.body, G))) {
          G.label && Lu(G.label.thedef.references, G), o = !0, N = N.clone(), N.condition = N.condition.negate(S), N.body = k(ot, N, {
            body: lh(N.alternative).concat(se())
          }), N.alternative = k(ot, N, {
            body: ie
          }), E[D] = N.transform(S);
          continue;
        }
        if (G = Es(N.alternative), re(G) && (ie = de(N.alternative, G))) {
          G.label && Lu(G.label.thedef.references, G), o = !0, N = N.clone(), N.body = k(ot, N.body, {
            body: lh(N.body).concat(se())
          }), N.alternative = k(ot, N.alternative, {
            body: ie
          }), E[D] = N.transform(S);
          continue;
        }
      }
      if (N instanceof Ft && N.body instanceof mr) {
        var j = N.body.value;
        if (!j && !N.alternative && (z && !R || R instanceof mr && !R.value)) {
          o = !0, E[D] = k(qe, N.condition, {
            body: N.condition
          });
          continue;
        }
        if (j && !N.alternative && R instanceof mr && R.value) {
          o = !0, N = N.clone(), N.alternative = R, E[D] = N.transform(S), E.splice(T, 1);
          continue;
        }
        if (j && !N.alternative && (!R && z && C || R instanceof mr)) {
          o = !0, N = N.clone(), N.alternative = R || k(mr, N, {
            value: null
          }), E[D] = N.transform(S), R && E.splice(T, 1);
          continue;
        }
        var J = E[xe(D)];
        if (S.option("sequences") && z && !N.alternative && J instanceof Ft && J.body instanceof mr && he(T) == E.length && R instanceof qe) {
          o = !0, N = N.clone(), N.alternative = k(ot, R, {
            body: [
              R,
              k(mr, R, {
                value: null
              })
            ]
          }), E[D] = N.transform(S), E.splice(T, 1);
          continue;
        }
      }
    }
    function H(G) {
      for (var ie = 0, X = G.length; --X >= 0; ) {
        var ye = G[X];
        if (ye instanceof Ft && ye.body instanceof mr && ++ie > 1)
          return !0;
      }
      return !1;
    }
    s(H, "has_multiple_if_returns");
    function F(G) {
      return !G || G instanceof $e && G.operator == "void";
    }
    s(F, "is_return_void");
    function re(G) {
      if (!G)
        return !1;
      for (var ie = D + 1, X = E.length; ie < X; ie++) {
        var ye = E[ie];
        if (ye instanceof wn || ye instanceof Dn)
          return !1;
      }
      var Oe = G instanceof Kn ? S.loopcontrol_target(G) : null;
      return G instanceof mr && z && F(G.value) || G instanceof ua && x === qk(Oe) || G instanceof hn && Oe instanceof ot && x === Oe;
    }
    s(re, "can_merge_flow");
    function se() {
      var G = E.slice(D + 1);
      return E.length = D + 1, G.filter(function(ie) {
        return ie instanceof tr ? (E.push(ie), !1) : !0;
      });
    }
    s(se, "extract_functions");
    function de(G, ie) {
      var X = lh(G);
      if (ie === X[X.length - 1])
        return X = X.slice(0, -1), ie.value && X.push(k(qe, ie.value, {
          body: ie.value.expression
        })), X;
    }
    s(de, "as_statement_array_with_return");
    function he(G) {
      for (var ie = G + 1, X = E.length; ie < X; ie++) {
        var ye = E[ie];
        if (!(ye instanceof Fr && _(ye)))
          break;
      }
      return ie;
    }
    s(he, "next_index");
    function xe(G) {
      for (var ie = G; --ie >= 0; ) {
        var X = E[ie];
        if (!(X instanceof Fr && _(X)))
          break;
      }
      return ie;
    }
    s(xe, "prev_index");
  }
  s(h, "handle_if_return");
  function y(E, S) {
    for (var x, C = S.self(), z = 0, w = 0, D = E.length; z < D; z++) {
      var N = E[z];
      if (N instanceof Kn) {
        var T = S.loopcontrol_target(N);
        N instanceof hn && !(T instanceof ns) && qk(T) === C || N instanceof ua && qk(T) === C ? N.label && Lu(N.label.thedef.references, N) :
        E[w++] = N;
      } else
        E[w++] = N;
      if (Es(N)) {
        x = E.slice(z + 1);
        break;
      }
    }
    E.length = w, o = w != D, x && x.forEach(function(R) {
      Gl(S, R, E);
    });
  }
  s(y, "eliminate_dead_code");
  function _(E) {
    return E.definitions.every((S) => !S.value);
  }
  s(_, "declarations_only");
  function g(E, S) {
    if (E.length < 2)
      return;
    var x = [], C = 0;
    function z() {
      if (x.length) {
        var R = _t(x[0], x);
        E[C++] = k(qe, R, { body: R }), x = [];
      }
    }
    s(z, "push_seq");
    for (var w = 0, D = E.length; w < D; w++) {
      var N = E[w];
      if (N instanceof qe) {
        x.length >= S.sequences_limit && z();
        var T = N.body;
        x.length > 0 && (T = T.drop_side_effect_free(S)), T && ny(x, T);
      } else N instanceof cr && _(N) || N instanceof tr || z(), E[C++] = N;
    }
    z(), E.length = C, C != D && (o = !0);
  }
  s(g, "sequencesize");
  function m(E, S) {
    if (!(E instanceof ot))
      return E;
    for (var x = null, C = 0, z = E.body.length; C < z; C++) {
      var w = E.body[C];
      if (w instanceof Fr && _(w))
        S.push(w);
      else {
        if (x || w instanceof wn || w instanceof Dn)
          return !1;
        x = w;
      }
    }
    return x;
  }
  s(m, "to_simple_statement");
  function f(E, S) {
    function x(J) {
      C--, o = !0;
      var H = z.body;
      return _t(H, [H, J]).transform(S);
    }
    s(x, "cons_seq");
    for (var C = 0, z, w = 0; w < E.length; w++) {
      var D = E[w];
      if (z && (D instanceof cn ? D.value = x(D.value || k(pr, D).transform(S)) : D instanceof yr ? D.init instanceof cr || _r(z.body, (H) => {
        if (H instanceof Ye)
          return !0;
        if (H instanceof ce && H.operator === "in")
          return Yi;
      }) || (D.init ? D.init = x(D.init) : (D.init = z.body, C--, o = !0)) : D instanceof Or ? !(D.init instanceof wn) && !(D.init instanceof
      Dn) && (D.object = x(D.object)) : D instanceof Ft ? D.condition = x(D.condition) : (D instanceof Vr || D instanceof di) && (D.expression =
      x(D.expression))), S.option("conditionals") && D instanceof Ft) {
        var N = [], T = m(D.body, N), R = m(D.alternative, N);
        if (T !== !1 && R !== !1 && N.length > 0) {
          var j = N.length;
          N.push(k(Ft, D, {
            condition: D.condition,
            body: T || k(Rt, D.body),
            alternative: R
          })), N.unshift(C, 1), [].splice.apply(E, N), w += j, C += j + 1, z = null, o = !0;
          continue;
        }
      }
      E[C++] = D, z = D instanceof qe ? D : null;
    }
    E.length = C;
  }
  s(f, "sequencesize_2");
  function d(E, S) {
    if (E instanceof cr) {
      var x = E.definitions[E.definitions.length - 1];
      if (x.value instanceof Tt) {
        var C;
        if (S instanceof ct && !S.logical ? C = [S] : S instanceof Qe && (C = S.expressions.slice()), !!C) {
          var z = !1;
          do {
            var w = C[0];
            if (!(w instanceof ct) || w.operator != "=" || !(w.left instanceof je))
              break;
            var D = w.left.expression;
            if (!(D instanceof Te) || x.name.name != D.name || !w.right.is_constant_expression(r))
              break;
            var N = w.left.property;
            if (N instanceof Se && (N = N.evaluate(t)), N instanceof Se)
              break;
            N = "" + N;
            var T = t.option("ecma") < 2015 && t.has_directive("use strict") ? function(j) {
              return j.key != N && j.key && j.key.name != N;
            } : function(j) {
              return j.key && j.key.name != N;
            };
            if (!x.value.properties.every(T))
              break;
            var R = x.value.properties.filter(function(j) {
              return j.key === N;
            })[0];
            R ? R.value = new Qe({
              start: R.start,
              expressions: [R.value.clone(), w.right.clone()],
              end: R.end
            }) : x.value.properties.push(k(Nt, w, {
              key: N,
              value: w.right
            })), C.shift(), z = !0;
          } while (C.length);
          return z && C;
        }
      }
    }
  }
  s(d, "join_object_assignments");
  function v(E) {
    for (var S, x = 0, C = -1, z = E.length; x < z; x++) {
      var w = E[x], D = E[C];
      if (w instanceof cr)
        D && D.TYPE == w.TYPE ? (D.definitions = D.definitions.concat(w.definitions), o = !0) : S && S.TYPE == w.TYPE && _(w) ? (S.definitions =
        S.definitions.concat(w.definitions), o = !0) : (E[++C] = w, S = w);
      else if (w instanceof cn)
        w.value = T(w.value);
      else if (w instanceof yr) {
        var N = d(D, w.init);
        N ? (o = !0, w.init = N.length ? _t(w.init, N) : null, E[++C] = w) : D instanceof Fr && (!w.init || w.init.TYPE == D.TYPE) ? (w.init &&
        (D.definitions = D.definitions.concat(w.init.definitions)), w.init = D, E[C] = w, o = !0) : S instanceof Fr && w.init instanceof Fr &&
        _(w.init) ? (S.definitions = S.definitions.concat(w.init.definitions), w.init = null, E[++C] = w, o = !0) : E[++C] = w;
      } else if (w instanceof Or)
        w.object = T(w.object);
      else if (w instanceof Ft)
        w.condition = T(w.condition);
      else if (w instanceof qe) {
        var N = d(D, w.body);
        if (N) {
          if (o = !0, !N.length)
            continue;
          w.body = _t(w.body, N);
        }
        E[++C] = w;
      } else w instanceof Vr || w instanceof di ? w.expression = T(w.expression) : E[++C] = w;
    }
    E.length = C + 1;
    function T(R) {
      E[++C] = w;
      var j = d(D, R);
      return j ? (o = !0, j.length ? _t(R, j) : R instanceof Qe ? R.tail_node().left : R.left) : R;
    }
    s(T, "extract_object_assignments");
  }
  s(v, "join_consecutive_vars");
}
var ine = at(() => {
  Di();
  Gi();
  uy();
  Hl();
  qu();
  Uu();
  s(qk, "loop_body");
  s(rne, "is_lhs_read_only");
  s(bpt, "remove_initializers");
  s(Gl, "trim_unreachable_code");
  s(fy, "tighten_body");
});

// ../node_modules/terser/lib/compress/inline.js
function vpt(e) {
  for (var t, r = 0; t = e.parent(r++); ) {
    if (t instanceof Br) return !1;
    if (t instanceof pt || t instanceof Nt || t instanceof Tt)
      return !0;
  }
  return !1;
}
function Uk(e, t) {
  for (let r of t.enclosed) {
    if (t.variables.has(r.name))
      continue;
    let i = e.find_variable(r.name);
    if (i) {
      if (i === r) continue;
      return !0;
    }
  }
  return !1;
}
function Spt(e, t) {
  if (e.orig.length === 1 && t) {
    let r = t.size(), i = e.name.length;
    return r > i;
  }
  return !0;
}
function nne(e, t) {
  if (t.in_computed_key()) return e;
  let r = t.parent(), i = e.definition(), n = t.find_scope(), a = e.fixed_value();
  if (t.top_retain && i.global && t.top_retain(i) && // when identifier is in top_retain option dose not mean we can always inline it.
  // if identifier name is longer then init value, we can replace it.
  Spt(i, a))
    return i.fixed = !1, i.single_use = !1, e;
  let o = i.single_use && !(r instanceof Fe && r.is_callee_pure(t) || nn(r, po)) && !(r instanceof dr && a instanceof Ue && a.name);
  if (o && a instanceof Se && (o = !a.has_side_effects(t) && !a.may_throw(t)), a instanceof ht && i.scope !== e.scope)
    return e;
  if (o && (a instanceof Ue || a instanceof ht)) {
    if (wk(a, t))
      o = !1;
    else if (i.scope !== e.scope && (i.escaped == 1 || _i(a, 16) || vpt(t) || !t.option("reduce_funcs")))
      o = !1;
    else if (ch(t, i))
      o = !1;
    else if ((i.scope !== e.scope || i.orig[0] instanceof Nr) && (o = a.is_constant_expression(e.scope), o == "f")) {
      var u = e.scope;
      do
        (u instanceof tr || Vl(u)) && gn(u, 16);
      while (u = u.parent_scope);
    }
  }
  if (o && (a instanceof Ue || a instanceof ht) && (o = i.scope === e.scope && !Uk(n, a) || r instanceof Fe && r.expression === e && !Uk(n, a) &&
  !(a.name && a.name.definition().recursive_refs > 0)), o && a) {
    if (a instanceof an && (gn(a, 256), a = k(ts, a, a)), a instanceof tr && (gn(a, 256), a = k(jt, a, a)), i.recursive_refs > 0 && a.name instanceof
    jn) {
      let c = a.name.definition(), p = a.variables.get(a.name.name), h = p && p.orig[0];
      h instanceof kn || (h = k(kn, a.name, a.name), h.scope = a, a.name = h, p = a.def_function(h)), _r(a, (y) => {
        y instanceof Te && y.definition() === c && (y.thedef = p, p.references.push(y));
      });
    }
    return (a instanceof Ue || a instanceof ht) && a.parent_scope !== n && (a = a.clone(!0, t.get_toplevel()), n.add_child_scope(a)), a.optimize(
    t);
  }
  if (a) {
    let c;
    if (a instanceof kr)
      !(i.orig[0] instanceof Nr) && i.references.every(
        (p) => i.scope === p.scope
      ) && (c = a);
    else {
      var l = a.evaluate(t);
      l !== a && (t.option("unsafe_regexp") || !(l instanceof RegExp)) && (c = _n(l, a));
    }
    if (c) {
      let p = e.size(t), h = c.size(t), y = 0;
      if (t.option("unused") && !t.exposed(i) && (y = (p + 2 + a.size(t)) / (i.references.length - i.assignments)), h <= p + y)
        return c;
    }
  }
  return e;
}
function sne(e, t) {
  if (t.in_computed_key()) return e;
  var r = e.expression, i = r, n = e.args.every((w) => !(w instanceof ft));
  if (t.option("reduce_vars") && i instanceof Te && !nn(e, po)) {
    let w = i.fixed_value();
    if (wk(w, t) || !t.toplevel.funcs && r.definition().global)
      return e;
    i = w;
  }
  var a = i instanceof Ue, o = a && i.body[0], u = a && !i.is_generator && !i.async, l = u && t.option("inline") && !e.is_callee_pure(t);
  if (l && o instanceof mr) {
    let w = o.value;
    if (!w || w.is_constant_expression()) {
      w ? w = w.clone(!0) : w = k(pr, e);
      let D = e.args.concat(w);
      return _t(e, D).optimize(t);
    }
    if (i.argnames.length === 1 && i.argnames[0] instanceof Nr && e.args.length < 2 && !(e.args[0] instanceof ft) && w instanceof Te && w.name ===
    i.argnames[0].name) {
      let D = (e.args[0] || k(pr)).optimize(t), N;
      return D instanceof je && (N = t.parent()) instanceof Fe && N.expression === e ? _t(e, [
        k(We, e, { value: 0 }),
        D
      ]) : D;
    }
  }
  if (l) {
    var c, p, h = -1;
    let w, D, N;
    if (n && !i.uses_arguments && !(t.parent() instanceof ht) && !(i.name && i instanceof jt) && (D = f(o)) && (r === i || nn(e, ey) || t.option(
    "unused") && (w = r.definition()).references.length == 1 && !ch(t, w) && i.is_constant_expression(r.scope)) && !nn(e, eh | po) && !i.contains_this() &&
    E() && (N = t.find_scope()) && !Uk(N, i) && !(/* @__PURE__ */ s(function() {
      let R = 0, j;
      for (; j = t.parent(R++); ) {
        if (j instanceof sn) return !0;
        if (j instanceof Tr) break;
      }
      return !1;
    }, "in_default_assign"))() && !(c instanceof ht))
      return gn(i, 256), N.add_child_scope(i), _t(e, z(D)).optimize(t);
  }
  if (l && nn(e, ey))
    return gn(i, 256), i = k(i.CTOR === tr ? jt : i.CTOR, i, i), i = i.clone(!0), i.figure_out_scope({}, {
      parent_scope: t.find_scope(),
      toplevel: t.get_toplevel()
    }), k(Fe, e, {
      expression: i,
      args: e.args
    }).optimize(t);
  if (u && t.option("side_effects") && i.body.every(go)) {
    var _ = e.args.concat(k(pr, e));
    return _t(e, _).optimize(t);
  }
  if (t.option("negate_iife") && t.parent() instanceof qe && ay(e))
    return e.negate(t, !0);
  var g = e.evaluate(t);
  if (g !== e)
    return g = _n(g, e).optimize(t), us(t, g, e);
  return e;
  function m(w) {
    if (!w) return k(pr, e);
    if (w instanceof mr)
      return w.value ? w.value.clone(!0) : k(pr, e);
    if (w instanceof qe)
      return k($e, w, {
        operator: "void",
        expression: w.body.clone(!0)
      });
  }
  function f(w) {
    var D = i.body, N = D.length;
    if (t.option("inline") < 3)
      return N == 1 && m(w);
    w = null;
    for (var T = 0; T < N; T++) {
      var R = D[T];
      if (R instanceof Fr) {
        if (w && !R.definitions.every(
          (j) => !j.value
        ))
          return !1;
      } else {
        if (w)
          return !1;
        R instanceof Rt || (w = R);
      }
    }
    return m(w);
  }
  function d(w, D) {
    for (var N = 0, T = i.argnames.length; N < T; N++) {
      var R = i.argnames[N];
      if (R instanceof sn) {
        if (_i(R.left, 1)) continue;
        return !1;
      }
      if (R instanceof Ut) return !1;
      if (R instanceof ft) {
        if (_i(R.expression, 1)) continue;
        return !1;
      }
      if (!_i(R, 1)) {
        if (!D || w.has(R.name) || Dk.has(R.name) || c.conflicting_def(R.name))
          return !1;
        p && p.push(R.definition());
      }
    }
    return !0;
  }
  function v(w, D) {
    for (var N = i.body.length, T = 0; T < N; T++) {
      var R = i.body[T];
      if (R instanceof Fr) {
        if (!D) return !1;
        for (var j = R.definitions.length; --j >= 0; ) {
          var J = R.definitions[j].name;
          if (J instanceof Ut || w.has(J.name) || Dk.has(J.name) || c.conflicting_def(J.name))
            return !1;
          p && p.push(J.definition());
        }
      }
    }
    return !0;
  }
  function E() {
    var w = /* @__PURE__ */ new Set();
    do
      if (c = t.parent(++h), c.is_block_scope() && c.block_scope && c.block_scope.variables.forEach(function(T) {
        w.add(T.name);
      }), c instanceof mn)
        c.argname && w.add(c.argname.name);
      else if (c instanceof ns)
        p = [];
      else if (c instanceof Te && c.fixed_value() instanceof Ye)
        return !1;
    while (!(c instanceof Ye));
    var D = !(c instanceof Kt) || t.toplevel.vars, N = t.option("inline");
    return !v(w, N >= 3 && D) || !d(w, N >= 2 && D) ? !1 : !p || p.length == 0 || !a0(i, p);
  }
  function S(w, D, N, T) {
    var R = N.definition();
    c.variables.has(N.name) || (c.variables.set(N.name, R), c.enclosed.push(R), w.push(k(Lt, N, {
      name: N,
      value: null
    })));
    var J = k(Te, N, N);
    R.references.push(J), T && D.push(k(ct, e, {
      operator: "=",
      logical: !1,
      left: J,
      right: T.clone()
    }));
  }
  function x(w, D) {
    for (var N = i.argnames.length, T = e.args.length; --T >= N; )
      D.push(e.args[T]);
    for (T = N; --T >= 0; ) {
      var R = i.argnames[T], j = e.args[T];
      if (_i(R, 1) || !R.name || c.conflicting_def(R.name))
        j && D.push(j);
      else {
        var J = k(bs, R, R);
        R.definition().orig.push(J), !j && p && (j = k(pr, e)), S(w, D, J, j);
      }
    }
    w.reverse(), D.reverse();
  }
  function C(w, D) {
    for (var N = D.length, T = 0, R = i.body.length; T < R; T++) {
      var j = i.body[T];
      if (j instanceof Fr)
        for (var J = 0, H = j.definitions.length; J < H; J++) {
          var F = j.definitions[J], re = F.name;
          if (S(w, D, re, F.value), p && i.argnames.every(
            (he) => he.name != re.name
          )) {
            var se = i.variables.get(re.name), de = k(Te, re, re);
            se.references.push(de), D.splice(N++, 0, k(ct, F, {
              operator: "=",
              logical: !1,
              left: de,
              right: k(pr, re)
            }));
          }
        }
    }
  }
  function z(w) {
    var D = [], N = [];
    if (x(D, N), C(D, N), N.push(w), D.length) {
      let T = c.body.indexOf(t.parent(h - 1)) + 1;
      c.body.splice(T, 0, k(Fr, i, {
        definitions: D
      }));
    }
    return N.map((T) => T.clone(!0));
  }
}
var ane = at(() => {
  Di();
  Gi();
  Ak();
  Ik();
  Rk();
  Bk();
  qu();
  Uu();
  s(vpt, "within_array_or_object_literal");
  s(Uk, "scope_encloses_variables_in_this_scope");
  s(Spt, "is_const_symbol_short_than_init_value");
  s(nne, "inline_into_symbolref");
  s(sne, "inline_into_call");
});

// ../node_modules/terser/lib/compress/global-defs.js
var one = at(() => {
  Di();
  Gi();
  Uu();
  Hl();
  (function(e) {
    function t(r, i) {
      if (r instanceof Se)
        return r instanceof Ct || (r = r.clone(!0)), k(r.CTOR, i, r);
      if (Array.isArray(r)) return k(pt, i, {
        elements: r.map(function(o) {
          return t(o, i);
        })
      });
      if (r && typeof r == "object") {
        var n = [];
        for (var a in r) Pi(r, a) && n.push(k(Nt, i, {
          key: a,
          value: t(r[a], i)
        }));
        return k(Tt, i, {
          properties: n
        });
      }
      return _n(r, i);
    }
    s(t, "to_node"), Kt.DEFMETHOD("resolve_defines", function(r) {
      return r.option("global_defs") ? (this.figure_out_scope({ ie8: r.option("ie8") }), this.transform(new qi(function(i) {
        var n = i._find_defs(r, "");
        if (n) {
          for (var a = 0, o = i, u; (u = this.parent(a++)) && !(!(u instanceof je) || u.expression !== o); )
            o = u;
          if (!bo(o, u))
            return n;
        }
      }))) : this;
    }), e(Se, fn), e(er, function(r, i) {
      return this.expression._find_defs(r, i);
    }), e(It, function(r, i) {
      return this.expression._find_defs(r, "." + this.property + i);
    }), e(Lr, function() {
      this.global();
    }), e(Te, function(r, i) {
      if (this.global()) {
        var n = r.option("global_defs"), a = this.name + i;
        if (Pi(n, a)) return t(n[a], this);
      }
    }), e(ss, function(r, i) {
      var n = r.option("global_defs"), a = "import.meta" + i;
      if (Pi(n, a)) return t(n[a], this);
    });
  })(function(e, t) {
    e.DEFMETHOD("_find_defs", t);
  });
});

// ../node_modules/terser/lib/compress/index.js
function At(e, t) {
  e.DEFMETHOD("optimize", function(r) {
    var i = this;
    if (_i(i, 512) || r.has_directive("use asm")) return i;
    var n = t(i, r);
    return gn(n, 512), n;
  });
}
function Kk(e, t) {
  for (var r, i = 0; (r = e.parent(i++)) && !(r instanceof Ye); )
    if (r instanceof mn && r.argname) {
      r = r.argname.definition().scope;
      break;
    }
  return r.find_variable(t);
}
function xpt(e) {
  return !(e instanceof wn || e instanceof Dn || e instanceof ht);
}
function Hk(e, t) {
  return fy(e.body, t), t.option("side_effects") && e.body.length == 1 && e.body[0] === t.has_directive("use strict") && (e.body.length = 0),
  e;
}
function lne(e, t) {
  var r = e.body instanceof ot ? e.body.body[0] : e.body;
  if (t.option("dead_code") && n(r)) {
    var i = [];
    return e.init instanceof Br ? i.push(e.init) : e.init && i.push(k(qe, e.init, {
      body: e.init
    })), e.condition && i.push(k(qe, e.condition, {
      body: e.condition
    })), Gl(t, e.body, i), k(ot, e, {
      body: i
    });
  }
  return r instanceof Ft && (n(r.body) ? (e.condition ? e.condition = k(ce, e.condition, {
    left: e.condition,
    operator: "&&",
    right: r.condition.negate(t)
  }) : e.condition = r.condition.negate(t), a(r.alternative)) : n(r.alternative) && (e.condition ? e.condition = k(ce, e.condition, {
    left: e.condition,
    operator: "&&",
    right: r.condition
  }) : e.condition = r.condition, a(r.body))), e;
  function n(o) {
    return o instanceof hn && t.loopcontrol_target(o) === t.self();
  }
  s(n, "is_break");
  function a(o) {
    o = lh(o), e.body instanceof ot ? (e.body = e.body.clone(), e.body.body = o.concat(e.body.body.slice(1)), e.body = e.body.transform(t)) :
    e.body = k(ot, e.body, {
      body: o
    }).transform(t), e = lne(e, t);
  }
  s(a, "drop_it");
}
function Ppt(e) {
  return e instanceof pt || e instanceof Ue || e instanceof Tt || e instanceof ht;
}
function p0(e, t) {
  return e instanceof Te || e.TYPE === t.TYPE;
}
function Opt(e, t, r) {
  if (t.may_throw(r)) return !1;
  let i;
  if (e instanceof ce && e.operator === "==" && ((i = Ia(e.left, r) && e.left) || (i = Ia(e.right, r) && e.right)) && (i === e.left ? e.right :
  e.left).equivalent_to(t))
    return !0;
  if (e instanceof ce && e.operator === "||") {
    let n, a, o = /* @__PURE__ */ s((u) => {
      if (!(u instanceof ce && (u.operator === "===" || u.operator === "==")))
        return !1;
      let l = 0, c;
      return u.left instanceof Xi && (l++, n = u, c = u.right), u.right instanceof Xi && (l++, n = u, c = u.left), Ra(u.left, r) && (l++, a =
      u, c = u.right), Ra(u.right, r) && (l++, a = u, c = u.left), !(l !== 1 || !c.equivalent_to(t));
    }, "find_comparison");
    if (!o(e.left) || !o(e.right)) return !1;
    if (n && a && n !== a)
      return !0;
  }
  return !1;
}
function cne(e, t) {
  return e instanceof Te && (e = e.fixed_value()), e ? !(e instanceof Ue || e instanceof ht) || !(e instanceof Ue && e.contains_this()) ? !0 :
  t.parent() instanceof gi : !1;
}
function zk(e, t) {
  return t.in_boolean_context() ? us(t, e, _t(e, [
    e,
    k(ln, e)
  ]).optimize(t)) : e;
}
function fne(e) {
  for (var t = 0; t < e.length; t++) {
    var r = e[t];
    if (r instanceof ft) {
      var i = r.expression;
      i instanceof pt && !i.elements.some((n) => n instanceof xn) && (e.splice(t, 1, ...i.elements), t--);
    }
  }
}
function kpt(e) {
  for (var t = 0; t < e.length; t++) {
    var r = e[t];
    if (r instanceof ft) {
      let i = r.expression;
      i instanceof Tt && i.properties.every((n) => n instanceof Nt) ? (e.splice(t, 1, ...i.properties), t--) : (
        // `expr.is_constant()` returns `false` for `AST_RegExp`, so need both.
        (i instanceof Ct || i.is_constant()) && !(i instanceof bt) && (e.splice(t, 1), t--)
      );
    }
  }
}
function Gk(e, t) {
  if (!t.option("computed_props") || !(e.key instanceof Ct)) return e;
  if (e.key instanceof bt || e.key instanceof We) {
    let r = e.key.value.toString();
    if (r === "__proto__" || r == "constructor" && t.parent() instanceof ht) return e;
    e instanceof Nt ? (e.quote = e.key.quote, e.key = r) : e instanceof Bi ? (e.quote = e.key.quote, e.key = k(vs, e.key, {
      name: r
    })) : (e.quote = e.key.quote, e.key = k(hi, e.key, {
      name: r
    }));
  }
  return e;
}
var py, Ept, Apt, Cpt, Dpt, wpt, pne = at(() => {
  Di();
  Gi();
  nh();
  $ie();
  Rl();
  QS();
  ry();
  Ak();
  Ik();
  Rk();
  Zie();
  Bk();
  Hl();
  qu();
  Uu();
  ine();
  ane();
  one();
  py = class extends Mr {
    static {
      s(this, "Compressor");
    }
    constructor(t, { false_by_default: r = !1, mangle_options: i = !1 }) {
      super(), t.defaults !== void 0 && !t.defaults && (r = !0), this.options = Mn(t, {
        arguments: !1,
        arrows: !r,
        booleans: !r,
        booleans_as_integers: !1,
        collapse_vars: !r,
        comparisons: !r,
        computed_props: !r,
        conditionals: !r,
        dead_code: !r,
        defaults: !0,
        directives: !r,
        drop_console: !1,
        drop_debugger: !r,
        ecma: 5,
        evaluate: !r,
        expression: !1,
        global_defs: !1,
        hoist_funs: !1,
        hoist_props: !r,
        hoist_vars: !1,
        ie8: !1,
        if_return: !r,
        inline: !r,
        join_vars: !r,
        keep_classnames: !1,
        keep_fargs: !0,
        keep_fnames: !1,
        keep_infinity: !1,
        lhs_constants: !r,
        loops: !r,
        module: !1,
        negate_iife: !r,
        passes: 1,
        properties: !r,
        pure_getters: !r && "strict",
        pure_funcs: null,
        pure_new: !1,
        reduce_funcs: !r,
        reduce_vars: !r,
        sequences: !r,
        side_effects: !r,
        switches: !r,
        top_retain: null,
        toplevel: !!(t && t.top_retain),
        typeofs: !r,
        unsafe: !1,
        unsafe_arrows: !1,
        unsafe_comps: !1,
        unsafe_Function: !1,
        unsafe_math: !1,
        unsafe_symbols: !1,
        unsafe_methods: !1,
        unsafe_proto: !1,
        unsafe_regexp: !1,
        unsafe_undefined: !1,
        unused: !r,
        warnings: !1
        // legacy
      }, !0);
      var n = this.options.global_defs;
      if (typeof n == "object") for (var a in n)
        a[0] === "@" && Pi(n, a) && (n[a.slice(1)] = $o(n[a], {
          expression: !0
        }));
      this.options.inline === !0 && (this.options.inline = 3);
      var o = this.options.pure_funcs;
      typeof o == "function" ? this.pure_funcs = o : this.pure_funcs = o ? function(p) {
        return !o.includes(p.expression.print_to_string());
      } : rn;
      var u = this.options.top_retain;
      u instanceof RegExp ? this.top_retain = function(p) {
        return u.test(p.name);
      } : typeof u == "function" ? this.top_retain = u : u && (typeof u == "string" && (u = u.split(/,/)), this.top_retain = function(p) {
        return u.includes(p.name);
      }), this.options.module && (this.directives["use strict"] = !0, this.options.toplevel = !0);
      var l = this.options.toplevel;
      this.toplevel = typeof l == "string" ? {
        funcs: /funcs/.test(l),
        vars: /vars/.test(l)
      } : {
        funcs: l,
        vars: l
      };
      var c = this.options.sequences;
      this.sequences_limit = c == 1 ? 800 : c | 0, this.evaluated_regexps = /* @__PURE__ */ new Map(), this._toplevel = void 0, this._mangle_options =
      i && ty(i);
    }
    mangle_options() {
      var t = this._mangle_options && this._mangle_options.nth_identifier || jl, r = this._mangle_options && this._mangle_options.module || this.
      option("module");
      return { ie8: this.option("ie8"), nth_identifier: t, module: r };
    }
    option(t) {
      return this.options[t];
    }
    exposed(t) {
      if (t.export) return !0;
      if (t.global) {
        for (var r = 0, i = t.orig.length; r < i; r++)
          if (!this.toplevel[t.orig[r] instanceof jn ? "funcs" : "vars"])
            return !0;
      }
      return !1;
    }
    in_boolean_context() {
      if (!this.option("booleans")) return !1;
      for (var t = this.self(), r = 0, i; i = this.parent(r); r++) {
        if (i instanceof qe || i instanceof it && i.condition === t || i instanceof th && i.condition === t || i instanceof yr && i.condition ===
        t || i instanceof Ft && i.condition === t || i instanceof $e && i.operator == "!" && i.expression === t)
          return !0;
        if (i instanceof ce && (i.operator == "&&" || i.operator == "||" || i.operator == "??") || i instanceof it || i.tail_node() === t)
          t = i;
        else
          return !1;
      }
    }
    in_32_bit_context() {
      if (!this.option("evaluate")) return !1;
      for (var t = this.self(), r = 0, i; i = this.parent(r); r++) {
        if (i instanceof ce && c0.has(i.operator))
          return !0;
        if (i instanceof $e)
          return i.operator === "~";
        if (i instanceof ce && (i.operator == "&&" || i.operator == "||" || i.operator == "??") || i instanceof it && i.condition !== t || i.
        tail_node() === t)
          t = i;
        else
          return !1;
      }
    }
    in_computed_key() {
      if (!this.option("evaluate")) return !1;
      for (var t = this.self(), r = 0, i; i = this.parent(r); r++)
        if (i instanceof gr && i.key === t)
          return !0;
      return !1;
    }
    get_toplevel() {
      return this._toplevel;
    }
    compress(t) {
      t = t.resolve_defines(this), this._toplevel = t, this.option("expression") && this._toplevel.process_expression(!0);
      for (var r = +this.options.passes || 1, i = 1 / 0, n = !1, a = this.mangle_options(), o = 0; o < r; o++)
        if (this._toplevel.figure_out_scope(a), o === 0 && this.option("drop_console") && (this._toplevel = this._toplevel.drop_console(this.
        option("drop_console"))), (o > 0 || this.option("reduce_vars")) && this._toplevel.reset_opt_flags(this), this._toplevel = this._toplevel.
        transform(this), r > 1) {
          let u = 0;
          if (_r(this._toplevel, () => {
            u++;
          }), u < i)
            i = u, n = !1;
          else {
            if (n)
              break;
            n = !0;
          }
        }
      return this.option("expression") && this._toplevel.process_expression(!1), t = this._toplevel, this._toplevel = void 0, t;
    }
    before(t, r) {
      if (_i(t, 256)) return t;
      var i = !1;
      t instanceof Ye && (t = t.hoist_properties(this), t = t.hoist_declarations(this), i = !0), r(t, this), r(t, this);
      var n = t.optimize(this);
      return i && n instanceof Ye && (n.drop_unused(this), r(n, this)), n === t && gn(n, 256), n;
    }
    /** Alternative to plain is_lhs() which doesn't work within .optimize() */
    is_lhs() {
      let t = this.stack[this.stack.length - 1], r = this.stack[this.stack.length - 2];
      return bo(t, r);
    }
  };
  s(At, "def_optimize");
  At(Se, function(e) {
    return e;
  });
  Kt.DEFMETHOD("drop_console", function(e) {
    let t = Array.isArray(e), r = new qi(function(i) {
      if (i.TYPE === "Call") {
        var n = i.expression;
        if (n instanceof je) {
          for (var a = n.expression, o = n.property, u = 2; a.expression; )
            o = a.property, a = a.expression, u++;
          if (!(t && !e.includes(o)) && ca(a) && a.name == "console")
            if (u === 3 && !["call", "apply"].includes(n.property) && f0(r))
              n.expression = i0(i), gn(n.expression, 256), i.args = [];
            else
              return k(pr, i);
        }
      }
    });
    return this.transform(r);
  });
  Se.DEFMETHOD("equivalent_to", function(e) {
    return Wie(this, e);
  });
  Ye.DEFMETHOD("process_expression", function(e, t) {
    var r = this, i = new qi(function(n) {
      if (e && n instanceof qe)
        return k(mr, n, {
          value: n.body
        });
      if (!e && n instanceof mr) {
        if (t) {
          var a = n.value && n.value.drop_side_effect_free(t, !0);
          return a ? k(qe, n, { body: a }) : k(Rt, n);
        }
        return k(qe, n, {
          body: n.value || k($e, n, {
            operator: "void",
            expression: k(We, n, {
              value: 0
            })
          })
        });
      }
      if (n instanceof ht || n instanceof Ue && n !== r)
        return n;
      if (n instanceof Tr) {
        var o = n.body.length - 1;
        o >= 0 && (n.body[o] = n.body[o].transform(i));
      } else n instanceof Ft ? (n.body = n.body.transform(i), n.alternative && (n.alternative = n.alternative.transform(i))) : n instanceof di &&
      (n.body = n.body.transform(i));
      return n;
    });
    r.transform(i);
  });
  Kt.DEFMETHOD("reset_opt_flags", function(e) {
    let t = this, r = e.option("reduce_vars"), i = new Mr(function(n, a) {
      if (Jo(n, 1792), r)
        return e.top_retain && n instanceof tr && i.parent() === t && gn(n, 1024), n.reduce_vars(i, a, e);
    });
    i.safe_ids = /* @__PURE__ */ Object.create(null), i.in_loop = null, i.loop_ids = /* @__PURE__ */ new Map(), i.defs_to_safe_ids = /* @__PURE__ */ new Map(),
    t.walk(i);
  });
  gt.DEFMETHOD("fixed_value", function() {
    var e = this.thedef.fixed;
    return !e || e instanceof Se ? e : e();
  });
  Te.DEFMETHOD("is_immutable", function() {
    var e = this.definition().orig;
    return e.length == 1 && e[0] instanceof kn;
  });
  s(Kk, "find_variable");
  Ept = qt("Array Boolean clearInterval clearTimeout console Date decodeURI decodeURIComponent encodeURI encodeURIComponent Error escape eva\
l EvalError Function isFinite isNaN JSON Math Number parseFloat parseInt RangeError ReferenceError RegExp Object setInterval setTimeout Stri\
ng SyntaxError TypeError unescape URIError");
  Te.DEFMETHOD("is_declared", function(e) {
    return !this.definition().undeclared || e.option("unsafe") && Ept.has(this.name);
  });
  Apt = /* @__PURE__ */ new Set(["use asm", "use strict"]);
  At(wi, function(e, t) {
    return t.option("directives") && (!Apt.has(e.value) || t.has_directive(e.value) !== e) ? k(Rt, e) : e;
  });
  At(is, function(e, t) {
    return t.option("drop_debugger") ? k(Rt, e) : e;
  });
  At(wr, function(e, t) {
    return e.body instanceof hn && t.loopcontrol_target(e.body) === e.body ? k(Rt, e) : e.label.references.length == 0 ? e.body : e;
  });
  At(Tr, function(e, t) {
    return fy(e.body, t), e;
  });
  s(xpt, "can_be_extracted_from_if_block");
  At(ot, function(e, t) {
    switch (fy(e.body, t), e.body.length) {
      case 1:
        if (!t.has_directive("use strict") && t.parent() instanceof Ft && xpt(e.body[0]) || uh(e.body[0]))
          return e.body[0];
        break;
      case 0:
        return k(Rt, e);
    }
    return e;
  });
  s(Hk, "opt_AST_Lambda");
  At(Ue, Hk);
  Ye.DEFMETHOD("hoist_declarations", function(e) {
    var t = this;
    if (e.has_directive("use asm")) return t;
    var r = e.option("hoist_funs"), i = e.option("hoist_vars");
    if (r || i) {
      var n = [], a = [], o = /* @__PURE__ */ new Map(), u = 0, l = 0;
      _r(t, (f) => {
        if (f instanceof Ye && f !== t)
          return !0;
        if (f instanceof Fr)
          return ++l, !0;
      }), i = i && l > 1;
      var c = new qi(
        /* @__PURE__ */ s(function(d) {
          if (d !== t) {
            if (d instanceof wi)
              return n.push(d), k(Rt, d);
            if (r && d instanceof tr && !(c.parent() instanceof dr) && c.parent() === t)
              return a.push(d), k(Rt, d);
            if (i && d instanceof Fr && !d.definitions.some((x) => x.name instanceof Ut)) {
              d.definitions.forEach(function(x) {
                o.set(x.name.name, x), ++u;
              });
              var v = d.to_assignments(e), E = c.parent();
              if (E instanceof Or && E.init === d) {
                if (v == null) {
                  var S = d.definitions[0].name;
                  return k(Te, S, S);
                }
                return v;
              }
              return E instanceof yr && E.init === d ? v : v ? k(qe, d, {
                body: v
              }) : k(Rt, d);
            }
            if (d instanceof Ye)
              return d;
          }
        }, "before")
      );
      if (t = t.transform(c), u > 0) {
        var p = [];
        let f = t instanceof Ue, d = f ? t.args_as_names() : null;
        if (o.forEach((v, E) => {
          f && d.some((S) => S.name === v.name.name) ? o.delete(E) : (v = v.clone(), v.value = null, p.push(v), o.set(E, v));
        }), p.length > 0) {
          for (var h = 0; h < t.body.length; ) {
            if (t.body[h] instanceof qe) {
              var y = t.body[h].body, _, g;
              if (y instanceof ct && y.operator == "=" && (_ = y.left) instanceof gt && o.has(_.name)) {
                var m = o.get(_.name);
                if (m.value) break;
                m.value = y.right, Lu(p, m), p.push(m), t.body.splice(h, 1);
                continue;
              }
              if (y instanceof Qe && (g = y.expressions[0]) instanceof ct && g.operator == "=" && (_ = g.left) instanceof gt && o.has(_.name)) {
                var m = o.get(_.name);
                if (m.value) break;
                m.value = g.right, Lu(p, m), p.push(m), t.body[h].body = _t(y, y.expressions.slice(1));
                continue;
              }
            }
            if (t.body[h] instanceof Rt) {
              t.body.splice(h, 1);
              continue;
            }
            if (t.body[h] instanceof ot) {
              t.body.splice(h, 1, ...t.body[h].body);
              continue;
            }
            break;
          }
          p = k(Fr, t, {
            definitions: p
          }), a.push(p);
        }
      }
      t.body = n.concat(a, t.body);
    }
    return t;
  });
  Ye.DEFMETHOD("hoist_properties", function(e) {
    var t = this;
    if (!e.option("hoist_props") || e.has_directive("use asm")) return t;
    var r = t instanceof Kt && e.top_retain || kt, i = /* @__PURE__ */ new Map(), n = new qi(function(a, o) {
      if (a instanceof Lt) {
        let u = a.name, l, c;
        if (u.scope === t && (l = u.definition()).escaped != 1 && !l.assignments && !l.direct_access && !l.single_use && !e.exposed(l) && !r(
        l) && (c = u.fixed_value()) === a.value && c instanceof Tt && !c.properties.some(
          (p) => p instanceof ft || p.computed_key()
        )) {
          o(a, this);
          let p = /* @__PURE__ */ new Map(), h = [];
          return c.properties.forEach(({ key: y, value: _ }) => {
            let g = n.find_scope(), m = t.create_symbol(u.CTOR, {
              source: u,
              scope: g,
              conflict_scopes: /* @__PURE__ */ new Set([
                g,
                ...u.definition().references.map((f) => f.scope)
              ]),
              tentative_name: u.name + "_" + y
            });
            p.set(String(y), m.definition()), h.push(k(Lt, a, {
              name: m,
              value: _
            }));
          }), i.set(l.id, p), sr.splice(h);
        }
      } else if (a instanceof je && a.expression instanceof Te) {
        let u = i.get(a.expression.definition().id);
        if (u) {
          let l = u.get(String(Ck(a.property))), c = k(Te, a, {
            name: l.name,
            scope: a.expression.scope,
            thedef: l
          });
          return c.reference({}), c;
        }
      }
    });
    return t.transform(n);
  });
  At(qe, function(e, t) {
    if (t.option("side_effects")) {
      var r = e.body, i = r.drop_side_effect_free(t, !0);
      if (!i)
        return k(Rt, e);
      if (i !== r)
        return k(qe, e, { body: i });
    }
    return e;
  });
  At(qn, function(e, t) {
    return t.option("loops") ? k(yr, e, e).optimize(t) : e;
  });
  At(Pn, function(e, t) {
    if (!t.option("loops")) return e;
    var r = e.condition.tail_node().evaluate(t);
    if (!(r instanceof Se)) {
      if (r) return k(yr, e, {
        body: k(ot, e.body, {
          body: [
            e.body,
            k(qe, e.condition, {
              body: e.condition
            })
          ]
        })
      }).optimize(t);
      if (!sy(e, t.parent()))
        return k(ot, e.body, {
          body: [
            e.body,
            k(qe, e.condition, {
              body: e.condition
            })
          ]
        }).optimize(t);
    }
    return e;
  });
  s(lne, "if_break_in_loop");
  At(yr, function(e, t) {
    if (!t.option("loops")) return e;
    if (t.option("side_effects") && e.init && (e.init = e.init.drop_side_effect_free(t)), e.condition) {
      var r = e.condition.evaluate(t);
      if (!(r instanceof Se)) {
        if (r) e.condition = null;
        else if (!t.option("dead_code")) {
          var i = e.condition;
          e.condition = _n(r, e.condition), e.condition = yo(e.condition.transform(t), i);
        }
      }
      if (t.option("dead_code") && (r instanceof Se && (r = e.condition.tail_node().evaluate(t)), !r)) {
        var n = [];
        return Gl(t, e.body, n), e.init instanceof Br ? n.push(e.init) : e.init && n.push(k(qe, e.init, {
          body: e.init
        })), n.push(k(qe, e.condition, {
          body: e.condition
        })), k(ot, e, { body: n }).optimize(t);
      }
    }
    return lne(e, t);
  });
  At(Ft, function(e, t) {
    if (go(e.alternative) && (e.alternative = null), !t.option("conditionals")) return e;
    var r = e.condition.evaluate(t);
    if (!t.option("dead_code") && !(r instanceof Se)) {
      var i = e.condition;
      e.condition = _n(r, i), e.condition = yo(e.condition.transform(t), i);
    }
    if (t.option("dead_code"))
      if (r instanceof Se && (r = e.condition.tail_node().evaluate(t)), r) {
        if (!(r instanceof Se)) {
          var n = [];
          return n.push(k(qe, e.condition, {
            body: e.condition
          })), n.push(e.body), e.alternative && Gl(t, e.alternative, n), k(ot, e, { body: n }).optimize(t);
        }
      } else {
        var n = [];
        return Gl(t, e.body, n), n.push(k(qe, e.condition, {
          body: e.condition
        })), e.alternative && n.push(e.alternative), k(ot, e, { body: n }).optimize(t);
      }
    var a = e.condition.negate(t), o = e.condition.size(), u = a.size(), l = u < o;
    if (e.alternative && l) {
      l = !1, e.condition = a;
      var c = e.body;
      e.body = e.alternative || k(Rt, e), e.alternative = c;
    }
    if (go(e.body) && go(e.alternative))
      return k(qe, e.condition, {
        body: e.condition.clone()
      }).optimize(t);
    if (e.body instanceof qe && e.alternative instanceof qe)
      return k(qe, e, {
        body: k(it, e, {
          condition: e.condition,
          consequent: e.body.body,
          alternative: e.alternative.body
        })
      }).optimize(t);
    if (go(e.alternative) && e.body instanceof qe)
      return o === u && !l && e.condition instanceof ce && e.condition.operator == "||" && (l = !0), l ? k(qe, e, {
        body: k(ce, e, {
          operator: "||",
          left: a,
          right: e.body.body
        })
      }).optimize(t) : k(qe, e, {
        body: k(ce, e, {
          operator: "&&",
          left: e.condition,
          right: e.body.body
        })
      }).optimize(t);
    if (e.body instanceof Rt && e.alternative instanceof qe)
      return k(qe, e, {
        body: k(ce, e, {
          operator: "||",
          left: e.condition,
          right: e.alternative.body
        })
      }).optimize(t);
    if (e.body instanceof cn && e.alternative instanceof cn && e.body.TYPE == e.alternative.TYPE)
      return k(e.body.CTOR, e, {
        value: k(it, e, {
          condition: e.condition,
          consequent: e.body.value || k(pr, e.body),
          alternative: e.alternative.value || k(pr, e.alternative)
        }).transform(t)
      }).optimize(t);
    if (e.body instanceof Ft && !e.body.alternative && !e.alternative && (e = k(Ft, e, {
      condition: k(ce, e.condition, {
        operator: "&&",
        left: e.condition,
        right: e.body.condition
      }),
      body: e.body.body,
      alternative: null
    })), Es(e.body) && e.alternative) {
      var p = e.alternative;
      return e.alternative = null, k(ot, e, {
        body: [e, p]
      }).optimize(t);
    }
    if (Es(e.alternative)) {
      var n = e.body;
      return e.body = e.alternative, e.condition = l ? a : e.condition.negate(t), e.alternative = null, k(ot, e, {
        body: [e, n]
      }).optimize(t);
    }
    return e;
  });
  At(Vr, function(e, t) {
    if (!t.option("switches")) return e;
    var r, i = e.expression.evaluate(t);
    if (!(i instanceof Se)) {
      var n = e.expression;
      e.expression = _n(i, n), e.expression = yo(e.expression.transform(t), n);
    }
    if (!t.option("dead_code")) return e;
    i instanceof Se && (i = e.expression.tail_node().evaluate(t));
    for (var a = [], o = [], u, l, c = 0, p = e.body.length; c < p && !l; c++) {
      if (r = e.body[c], r instanceof zs)
        u ? g(r, o[o.length - 1]) : u = r;
      else if (!(i instanceof Se)) {
        var h = r.expression.evaluate(t);
        if (!(h instanceof Se) && h !== i) {
          g(r, o[o.length - 1]);
          continue;
        }
        if (h instanceof Se && !h.has_side_effects(t) && (h = r.expression.tail_node().evaluate(t)), h === i && (l = r, u)) {
          var y = o.indexOf(u);
          o.splice(y, 1), g(u, o[y - 1]), u = null;
        }
      }
      o.push(r);
    }
    for (; c < p; ) g(e.body[c++], o[o.length - 1]);
    e.body = o;
    let _ = u || l;
    if (u = null, l = null, o.every((S, x) => (S === _ || S.expression instanceof Ct) && (S.body.length === 0 || Es(S) || o.length - 1 === x)))
      for (let S = 0; S < o.length; S++) {
        let x = o[S];
        for (let C = S + 1; C < o.length; C++) {
          let z = o[C];
          if (z.body.length === 0) continue;
          let w = C === o.length - 1, D = m(z, x, !1);
          if (D || w && m(z, x, !0)) {
            !D && w && z.body.push(k(hn));
            let N = C - 1, T = 0;
            for (; N > S && E(o[N--]); )
              T++;
            let R = o.splice(C - T, 1 + T);
            o.splice(S + 1, 0, ...R), S += R.length;
          }
        }
      }
    for (let S = 0; S < o.length; S++) {
      let x = o[S];
      if (x.body.length !== 0 && Es(x))
        for (let C = S + 1; C < o.length; S++, C++) {
          let z = o[C];
          if (z.body.length !== 0) {
            if (m(z, x, !1) || C === o.length - 1 && m(z, x, !0)) {
              x.body = [], x = z;
              continue;
            }
            break;
          }
        }
    }
    {
      let S = o.length - 1;
      for (; S >= 0; S--) {
        let x = o[S].body;
        if (v(x[x.length - 1], t) && x.pop(), !E(o[S])) break;
      }
      if (S++, !_ || o.indexOf(_) >= S)
        for (let x = o.length - 1; x >= S; x--) {
          let C = o[x];
          if (C === _)
            _ = null, o.pop();
          else if (!C.expression.has_side_effects(t))
            o.pop();
          else
            break;
        }
    }
    e: if (_) {
      let S = o.indexOf(_), x = S;
      for (; x < o.length - 1 && E(o[x]); x++)
        ;
      if (x < o.length - 1)
        break e;
      let C = o.length - 1;
      for (; C >= 0; C--) {
        let z = o[C];
        if (z !== _ && z.expression.has_side_effects(t))
          break;
      }
      if (x > C) {
        let z = S - 1;
        for (; z >= 0 && E(o[z]); z--)
          ;
        let w = Math.max(C, z) + 1, D = S;
        C > S ? (D = C, o[C].body = o[x].body) : _.body = o[x].body, o.splice(D + 1, x - D), o.splice(w, S - w);
      }
    }
    e: if (_) {
      let S = o.findIndex((w) => !E(w)), x;
      if (S === o.length - 1) {
        let w = o[S];
        if (d(e)) break e;
        x = k(ot, w, {
          body: w.body
        }), w.body = [];
      } else if (S !== -1)
        break e;
      if (!o.find(
        (w) => w !== _ && w.expression.has_side_effects(t)
      ))
        return k(ot, e, {
          body: a.concat(
            f(e.expression),
            _.expression ? f(_.expression) : [],
            x || []
          )
        }).optimize(t);
      let z = o.indexOf(_);
      if (o.splice(z, 1), _ = null, x)
        return k(ot, e, {
          body: a.concat(e, x)
        }).optimize(t);
    }
    if (o.length > 0 && (o[0].body = a.concat(o[0].body)), o.length == 0)
      return k(ot, e, {
        body: a.concat(f(e.expression))
      }).optimize(t);
    if (o.length == 1 && !d(e)) {
      let S = o[0];
      return k(Ft, e, {
        condition: k(ce, e, {
          operator: "===",
          left: e.expression,
          right: S.expression
        }),
        body: k(ot, S, {
          body: S.body
        }),
        alternative: null
      }).optimize(t);
    }
    if (o.length === 2 && _ && !d(e)) {
      let S = o[0] === _ ? o[1] : o[0], x = _.expression && f(_.expression);
      if (Es(o[0])) {
        let D = o[0];
        return v(D.body[D.body.length - 1], t) && D.body.pop(), k(Ft, e, {
          condition: k(ce, e, {
            operator: "===",
            left: e.expression,
            right: S.expression
          }),
          body: k(ot, S, {
            body: S.body
          }),
          alternative: k(ot, _, {
            body: [].concat(
              x || [],
              _.body
            )
          })
        }).optimize(t);
      }
      let C = "===", z = k(ot, S, {
        body: S.body
      }), w = k(ot, _, {
        body: [].concat(
          x || [],
          _.body
        )
      });
      if (o[0] === _) {
        C = "!==";
        let D = w;
        w = z, z = D;
      }
      return k(ot, e, {
        body: [
          k(Ft, e, {
            condition: k(ce, e, {
              operator: C,
              left: e.expression,
              right: S.expression
            }),
            body: z,
            alternative: null
          }),
          w
        ]
      }).optimize(t);
    }
    return e;
    function g(S, x) {
      x && !Es(x) ? x.body = x.body.concat(S.body) : Gl(t, S, a);
    }
    function m(S, x, C) {
      let z = S.body, w = x.body;
      if (C && (z = z.concat(k(hn))), z.length !== w.length) return !1;
      let D = k(ot, S, { body: z }), N = k(ot, x, { body: w });
      return D.equivalent_to(N);
    }
    function f(S) {
      return k(qe, S, { body: S });
    }
    function d(S) {
      let x = !1, C = new Mr((z) => {
        if (x || z instanceof Ue || z instanceof qe) return !0;
        if (!v(z, C)) return;
        let w = C.parent();
        w instanceof Ts && w.body[w.body.length - 1] === z || (x = !0);
      });
      return S.walk(C), x;
    }
    function v(S, x) {
      return S instanceof hn && x.loopcontrol_target(S) === e;
    }
    function E(S) {
      return !Es(S) && !k(ot, S, {
        body: S.body
      }).has_side_effects(t);
    }
  });
  At(mi, function(e, t) {
    if (e.bcatch && e.bfinally && e.bfinally.body.every(go) && (e.bfinally = null), t.option("dead_code") && e.body.body.every(go)) {
      var r = [];
      return e.bcatch && Gl(t, e.bcatch, r), e.bfinally && r.push(...e.bfinally.body), k(ot, e, {
        body: r
      }).optimize(t);
    }
    return e;
  });
  cr.DEFMETHOD("to_assignments", function(e) {
    var t = e.option("reduce_vars"), r = [];
    for (let n of this.definitions) {
      if (n.value) {
        var i = k(Te, n.name, n.name);
        r.push(k(ct, n, {
          operator: "=",
          logical: !1,
          left: i,
          right: n.value
        })), t && (i.definition().fixed = !1);
      }
      let a = n.name.definition();
      a.eliminated++, a.replaced--;
    }
    return r.length == 0 ? null : _t(this, r);
  });
  At(cr, function(e) {
    return e.definitions.length == 0 ? k(Rt, e) : e;
  });
  At(Lt, function(e, t) {
    return e.name instanceof co && e.value != null && Ra(e.value, t) && (e.value = null), e;
  });
  At(yi, function(e) {
    return e;
  });
  At(Fe, function(e, t) {
    var r = e.expression, i = r;
    fne(e.args);
    var n = e.args.every((R) => !(R instanceof ft));
    t.option("reduce_vars") && i instanceof Te && (i = i.fixed_value());
    var a = i instanceof Ue;
    if (a && i.pinned()) return e;
    if (t.option("unused") && n && a && !i.uses_arguments) {
      for (var o = 0, u = 0, l = 0, c = e.args.length; l < c; l++) {
        if (i.argnames[l] instanceof ft) {
          if (_i(i.argnames[l].expression, 1)) for (; l < c; ) {
            var p = e.args[l++].drop_side_effect_free(t);
            p && (e.args[o++] = p);
          }
          else for (; l < c; )
            e.args[o++] = e.args[l++];
          u = o;
          break;
        }
        var h = l >= i.argnames.length;
        if (h || _i(i.argnames[l], 1)) {
          var p = e.args[l].drop_side_effect_free(t);
          if (p)
            e.args[o++] = p;
          else if (!h) {
            e.args[o++] = k(We, e.args[l], {
              value: 0
            });
            continue;
          }
        } else
          e.args[o++] = e.args[l];
        u = o;
      }
      e.args.length = u;
    }
    if (r instanceof It && r.expression instanceof Te && r.expression.name === "console" && r.expression.definition().undeclared && r.property ===
    "assert") {
      let R = e.args[0];
      if (R) {
        let j = R.evaluate(t);
        if (j === 1 || j === !0)
          return k(pr, e);
      }
    }
    if (t.option("unsafe") && !r.contains_optional()) {
      if (r instanceof It && r.start.value === "Array" && r.property === "from" && e.args.length === 1) {
        let [R] = e.args;
        if (R instanceof pt)
          return k(pt, R, {
            elements: R.elements
          }).optimize(t);
      }
      if (ca(r)) switch (r.name) {
        case "Array":
          if (e.args.length != 1)
            return k(pt, e, {
              elements: e.args
            }).optimize(t);
          if (e.args[0] instanceof We && e.args[0].value <= 11) {
            let R = [];
            for (let j = 0; j < e.args[0].value; j++) R.push(new xn());
            return new pt({ elements: R });
          }
          break;
        case "Object":
          if (e.args.length == 0)
            return k(Tt, e, {
              properties: []
            });
          break;
        case "String":
          if (e.args.length == 0) return k(bt, e, {
            value: ""
          });
          if (e.args.length <= 1) return k(ce, e, {
            left: e.args[0],
            operator: "+",
            right: k(bt, e, { value: "" })
          }).optimize(t);
          break;
        case "Number":
          if (e.args.length == 0) return k(We, e, {
            value: 0
          });
          if (e.args.length == 1 && t.option("unsafe_math"))
            return k($e, e, {
              expression: e.args[0],
              operator: "+"
            }).optimize(t);
          break;
        case "Symbol":
          e.args.length == 1 && e.args[0] instanceof bt && t.option("unsafe_symbols") && (e.args.length = 0);
          break;
        case "Boolean":
          if (e.args.length == 0) return k(Ss, e);
          if (e.args.length == 1) return k($e, e, {
            expression: k($e, e, {
              expression: e.args[0],
              operator: "!"
            }),
            operator: "!"
          }).optimize(t);
          break;
        case "RegExp":
          var y = [];
          if (e.args.length >= 1 && e.args.length <= 2 && e.args.every((R) => {
            var j = R.evaluate(t);
            return y.push(j), R !== j;
          }) && HS(y[0])) {
            let [R, j] = y;
            R = Il(new RegExp(R).source);
            let J = k($r, e, {
              value: { source: R, flags: j }
            });
            if (J._eval(t) !== J)
              return J;
          }
          break;
      }
      else if (r instanceof It) switch (r.property) {
        case "toString":
          if (e.args.length == 0 && !r.expression.may_throw_on_access(t))
            return k(ce, e, {
              left: k(bt, e, { value: "" }),
              operator: "+",
              right: r.expression
            }).optimize(t);
          break;
        case "join":
          if (r.expression instanceof pt) e: {
            var _;
            if (e.args.length > 0 && (_ = e.args[0].evaluate(t), _ === e.args[0]))
              break e;
            for (var g = [], m = [], l = 0, c = r.expression.elements.length; l < c; l++) {
              var f = r.expression.elements[l];
              if (f instanceof ft) break e;
              var d = f.evaluate(t);
              d !== f ? m.push(d) : (m.length > 0 && (g.push(k(bt, e, {
                value: m.join(_)
              })), m.length = 0), g.push(f));
            }
            if (m.length > 0 && g.push(k(bt, e, {
              value: m.join(_)
            })), g.length == 0) return k(bt, e, { value: "" });
            if (g.length == 1)
              return g[0].is_string(t) ? g[0] : k(ce, g[0], {
                operator: "+",
                left: k(bt, e, { value: "" }),
                right: g[0]
              });
            if (_ == "") {
              var v;
              return g[0].is_string(t) || g[1].is_string(t) ? v = g.shift() : v = k(bt, e, { value: "" }), g.reduce(function(j, J) {
                return k(ce, J, {
                  operator: "+",
                  left: j,
                  right: J
                });
              }, v).optimize(t);
            }
            var p = e.clone();
            return p.expression = p.expression.clone(), p.expression.expression = p.expression.expression.clone(), p.expression.expression.elements =
            g, us(t, e, p);
          }
          break;
        case "charAt":
          if (r.expression.is_string(t)) {
            var E = e.args[0], S = E ? E.evaluate(t) : 0;
            if (S !== E)
              return k(fr, r, {
                expression: r.expression,
                property: _n(S | 0, E || r)
              }).optimize(t);
          }
          break;
        case "apply":
          if (e.args.length == 2 && e.args[1] instanceof pt) {
            var x = e.args[1].elements.slice();
            return x.unshift(e.args[0]), k(Fe, e, {
              expression: k(It, r, {
                expression: r.expression,
                optional: !1,
                property: "call"
              }),
              args: x
            }).optimize(t);
          }
          break;
        case "call":
          var C = r.expression;
          if (C instanceof Te && (C = C.fixed_value()), C instanceof Ue && !C.contains_this())
            return (e.args.length ? _t(this, [
              e.args[0],
              k(Fe, e, {
                expression: r.expression,
                args: e.args.slice(1)
              })
            ]) : k(Fe, e, {
              expression: r.expression,
              args: []
            })).optimize(t);
          break;
      }
    }
    if (t.option("unsafe_Function") && ca(r) && r.name == "Function") {
      if (e.args.length == 0) return i0(e).optimize(t);
      if (e.args.every((R) => R instanceof bt))
        try {
          var T = "n(function(" + e.args.slice(0, -1).map(function(R) {
            return R.value;
          }).join(",") + "){" + e.args[e.args.length - 1].value + "})", z = $o(T), w = t.mangle_options();
          z.figure_out_scope(w);
          var D = new py(t.options, {
            mangle_options: t._mangle_options
          });
          z = z.transform(D), z.figure_out_scope(w), z.compute_char_frequency(w), z.mangle_names(w);
          var N;
          _r(z, (R) => {
            if (Vl(R))
              return N = R, Yi;
          });
          var T = ef();
          return ot.prototype._codegen.call(N, N, T), e.args = [
            k(bt, e, {
              value: N.argnames.map(function(R) {
                return R.print_to_string();
              }).join(",")
            }),
            k(bt, e.args[e.args.length - 1], {
              value: T.get().replace(/^{|}$/g, "")
            })
          ], e;
        } catch (R) {
          if (!(R instanceof Qm))
            throw R;
        }
    }
    return sne(e, t);
  });
  Se.DEFMETHOD("contains_optional", function() {
    return this instanceof je || this instanceof Fe || this instanceof er ? this.optional ? !0 : this.expression.contains_optional() : !1;
  });
  At(gi, function(e, t) {
    return t.option("unsafe") && ca(e.expression) && ["Object", "RegExp", "Function", "Error", "Array"].includes(e.expression.name) ? k(Fe, e,
    e).transform(t) : e;
  });
  At(Qe, function(e, t) {
    if (!t.option("side_effects")) return e;
    var r = [];
    n();
    var i = r.length - 1;
    if (a(), i == 0)
      return e = Qo(t.parent(), t.self(), r[0]), e instanceof Qe || (e = e.optimize(t)), e;
    return e.expressions = r, e;
    function n() {
      var o = os(t), u = e.expressions.length - 1;
      e.expressions.forEach(function(l, c) {
        c < u && (l = l.drop_side_effect_free(t, o)), l && (ny(r, l), o = !1);
      });
    }
    s(n, "filter_for_side_effects");
    function a() {
      for (; i > 0 && Ra(r[i], t); ) i--;
      i < r.length - 1 && (r[i] = k($e, e, {
        operator: "void",
        expression: r[i]
      }), r.length = i + 1);
    }
    s(a, "trim_right_for_undefined");
  });
  Ht.DEFMETHOD("lift_sequences", function(e) {
    if (e.option("sequences") && this.expression instanceof Qe) {
      var t = this.expression.expressions.slice(), r = this.clone();
      return r.expression = t.pop(), t.push(r), _t(this, t).optimize(e);
    }
    return this;
  });
  At(as, function(e, t) {
    return e.lift_sequences(t);
  });
  At($e, function(e, t) {
    var r = e.expression;
    if (e.operator == "delete" && !(r instanceof Te || r instanceof je || r instanceof er || s0(r)))
      return _t(e, [r, k(ln, e)]).optimize(t);
    var i = e.lift_sequences(t);
    if (i !== e)
      return i;
    if (t.option("side_effects") && e.operator == "void")
      return r = r.drop_side_effect_free(t), r ? (e.expression = r, e) : k(pr, e).optimize(t);
    if (t.in_boolean_context())
      switch (e.operator) {
        case "!":
          if (r instanceof $e && r.operator == "!")
            return r.expression;
          r instanceof ce && (e = us(t, e, r.negate(t, os(t))));
          break;
        case "typeof":
          return (r instanceof Te ? k(ln, e) : _t(e, [
            r,
            k(ln, e)
          ])).optimize(t);
      }
    if (e.operator == "-" && r instanceof mo && (r = r.transform(t)), r instanceof ce && (e.operator == "+" || e.operator == "-") && (r.operator ==
    "*" || r.operator == "/" || r.operator == "%"))
      return k(ce, e, {
        operator: r.operator,
        left: k($e, r.left, {
          operator: e.operator,
          expression: r.left
        }),
        right: r.right
      });
    if (t.option("evaluate")) {
      if (e.operator === "~" && e.expression instanceof $e && e.expression.operator === "~" && (t.in_32_bit_context() || e.expression.expression.
      is_32_bit_integer()))
        return e.expression.expression;
      if (e.operator === "~" && r instanceof ce && r.operator === "^")
        return r.left instanceof $e && r.left.operator === "~" ? r.left = r.left.bitwise_negate(!0) : r.right = r.right.bitwise_negate(!0), r;
    }
    if (e.operator != "-" || !(r instanceof We || r instanceof mo || r instanceof un)) {
      var n = e.evaluate(t);
      if (n !== e)
        return n = _n(n, e).optimize(t), us(t, n, e);
    }
    return e;
  });
  ce.DEFMETHOD("lift_sequences", function(e) {
    if (e.option("sequences")) {
      if (this.left instanceof Qe) {
        var t = this.left.expressions.slice(), r = this.clone();
        return r.left = t.pop(), t.push(r), _t(this, t).optimize(e);
      }
      if (this.right instanceof Qe && !this.left.has_side_effects(e)) {
        for (var i = this.operator == "=" && this.left instanceof Te, t = this.right.expressions, n = t.length - 1, a = 0; a < n && !(!i && t[a].
        has_side_effects(e)); a++)
          ;
        if (a == n) {
          t = t.slice();
          var r = this.clone();
          return r.right = t.pop(), t.push(r), _t(this, t).optimize(e);
        } else if (a > 0) {
          var r = this.clone();
          return r.right = _t(this.right, t.slice(a)), t = t.slice(0, a), t.push(r), _t(this, t).optimize(e);
        }
      }
    }
    return this;
  });
  Cpt = qt("== === != !== * & | ^");
  s(Ppt, "is_object");
  At(ce, function(e, t) {
    function r() {
      return e.left.is_constant() || e.right.is_constant() || !e.left.has_side_effects(t) && !e.right.has_side_effects(t);
    }
    s(r, "reversible");
    function i(C) {
      if (r()) {
        C && (e.operator = C);
        var z = e.left;
        e.left = e.right, e.right = z;
      }
    }
    if (s(i, "reverse"), t.option("lhs_constants") && Cpt.has(e.operator) && e.right.is_constant() && !e.left.is_constant() && (e.left instanceof
    ce && _s[e.left.operator] >= _s[e.operator] || i()), e = e.lift_sequences(t), t.option("comparisons")) switch (e.operator) {
      case "===":
      case "!==":
        var n = !0;
        (e.left.is_string(t) && e.right.is_string(t) || e.left.is_number(t) && e.right.is_number(t) || e.left.is_boolean() && e.right.is_boolean() ||
        e.left.equivalent_to(e.right)) && (e.operator = e.operator.substr(0, 2));
      // XXX: intentionally falling down to the next case
      case "==":
      case "!=":
        if (!n && Ra(e.left, t))
          e.left = k(Xi, e.left);
        else if (!n && Ra(e.right, t))
          e.right = k(Xi, e.right);
        else if (t.option("typeofs") && e.left instanceof bt && e.left.value == "undefined" && e.right instanceof $e && e.right.operator == "\
typeof") {
          var a = e.right.expression;
          (a instanceof Te ? a.is_declared(t) : !(a instanceof je && t.option("ie8"))) && (e.right = a, e.left = k(pr, e.left).optimize(t), e.
          operator.length == 2 && (e.operator += "="));
        } else if (t.option("typeofs") && e.left instanceof $e && e.left.operator == "typeof" && e.right instanceof bt && e.right.value == "\
undefined") {
          var a = e.left.expression;
          (a instanceof Te ? a.is_declared(t) : !(a instanceof je && t.option("ie8"))) && (e.left = a, e.right = k(pr, e.right).optimize(t),
          e.operator.length == 2 && (e.operator += "="));
        } else {
          if (e.left instanceof Te && e.right instanceof Te && e.left.definition() === e.right.definition() && Ppt(e.left.fixed_value()))
            return k(e.operator[0] == "=" ? ln : Ss, e);
          if (e.left.is_32_bit_integer() && e.right.is_32_bit_integer()) {
            let C = /* @__PURE__ */ s((T) => k($e, T, {
              operator: "!",
              expression: T
            }), "not"), z = /* @__PURE__ */ s((T, R) => R ? t.in_boolean_context() ? T : C(C(T)) : C(T), "booleanify");
            if (e.left instanceof We && e.left.value === 0)
              return z(e.right, e.operator[0] === "!");
            if (e.right instanceof We && e.right.value === 0)
              return z(e.left, e.operator[0] === "!");
            let w, D, N;
            if ((w = e.left instanceof ce ? e.left : e.right instanceof ce ? e.right : null) && (N = w === e.left ? e.right : e.left) && w.operator ===
            "&" && N instanceof We && N.is_32_bit_integer() && (D = w.left.equivalent_to(N) ? w.right : w.right.equivalent_to(N) ? w.left : null)) {
              let T = z(k(ce, e, {
                operator: "&",
                left: N,
                right: k($e, e, {
                  operator: "~",
                  expression: D
                })
              }), e.operator[0] === "!");
              return us(t, T, e);
            }
          }
        }
        break;
      case "&&":
      case "||":
        var o = e.left;
        if (o.operator == e.operator && (o = o.right), o instanceof ce && o.operator == (e.operator == "&&" ? "!==" : "===") && e.right instanceof
        ce && o.operator == e.right.operator && (Ra(o.left, t) && e.right.left instanceof Xi || o.left instanceof Xi && Ra(e.right.left, t)) &&
        !o.right.has_side_effects(t) && o.right.equivalent_to(e.right.right)) {
          var u = k(ce, e, {
            operator: o.operator.slice(0, -1),
            left: k(Xi, e),
            right: o.right
          });
          return o !== e.left && (u = k(ce, e, {
            operator: e.operator,
            left: e.left.left,
            right: u
          })), u;
        }
        break;
    }
    if (e.operator == "+" && t.in_boolean_context()) {
      var l = e.left.evaluate(t), c = e.right.evaluate(t);
      if (l && typeof l == "string")
        return _t(e, [
          e.right,
          k(ln, e)
        ]).optimize(t);
      if (c && typeof c == "string")
        return _t(e, [
          e.left,
          k(ln, e)
        ]).optimize(t);
    }
    if (t.option("comparisons") && e.is_boolean()) {
      if (!(t.parent() instanceof ce) || t.parent() instanceof ct) {
        var p = k($e, e, {
          operator: "!",
          expression: e.negate(t, os(t))
        });
        e = us(t, e, p);
      }
      if (t.option("unsafe_comps"))
        switch (e.operator) {
          case "<":
            i(">");
            break;
          case "<=":
            i(">=");
            break;
        }
    }
    if (e.operator == "+") {
      if (e.right instanceof bt && e.right.getValue() == "" && e.left.is_string(t))
        return e.left;
      if (e.left instanceof bt && e.left.getValue() == "" && e.right.is_string(t))
        return e.right;
      if (e.left instanceof ce && e.left.operator == "+" && e.left.left instanceof bt && e.left.left.getValue() == "" && e.right.is_string(t))
        return e.left = e.left.right, e;
    }
    if (t.option("evaluate")) {
      switch (e.operator) {
        case "&&":
          var l = _i(e.left, 2) ? !0 : _i(e.left, 4) ? !1 : e.left.evaluate(t);
          if (l) {
            if (!(l instanceof Se))
              return _t(e, [e.left, e.right]).optimize(t);
          } else return Qo(t.parent(), t.self(), e.left).optimize(t);
          var c = e.right.evaluate(t);
          if (c) {
            if (!(c instanceof Se)) {
              var h = t.parent();
              if (h.operator == "&&" && h.left === t.self() || t.in_boolean_context())
                return e.left.optimize(t);
            }
          } else {
            if (t.in_boolean_context())
              return _t(e, [
                e.left,
                k(Ss, e)
              ]).optimize(t);
            gn(e, 4);
          }
          if (e.left.operator == "||") {
            var y = e.left.right.evaluate(t);
            if (!y) return k(it, e, {
              condition: e.left.left,
              consequent: e.right,
              alternative: e.left.right
            }).optimize(t);
          }
          break;
        case "||":
          var l = _i(e.left, 2) ? !0 : _i(e.left, 4) ? !1 : e.left.evaluate(t);
          if (l) {
            if (!(l instanceof Se))
              return Qo(t.parent(), t.self(), e.left).optimize(t);
          } else return _t(e, [e.left, e.right]).optimize(t);
          var c = e.right.evaluate(t);
          if (c) {
            if (!(c instanceof Se)) {
              if (t.in_boolean_context())
                return _t(e, [
                  e.left,
                  k(ln, e)
                ]).optimize(t);
              gn(e, 2);
            }
          } else {
            var h = t.parent();
            if (h.operator == "||" && h.left === t.self() || t.in_boolean_context())
              return e.left.optimize(t);
          }
          if (e.left.operator == "&&") {
            var y = e.left.right.evaluate(t);
            if (y && !(y instanceof Se)) return k(it, e, {
              condition: e.left.left,
              consequent: e.left.right,
              alternative: e.right
            }).optimize(t);
          }
          break;
        case "??":
          if (Ia(e.left, t))
            return e.right;
          var l = e.left.evaluate(t);
          if (!(l instanceof Se))
            return l == null ? e.right : e.left;
          if (t.in_boolean_context()) {
            let w = e.right.evaluate(t);
            if (!(w instanceof Se) && !w)
              return e.left;
          }
      }
      var _ = !0;
      switch (e.operator) {
        case "+":
          if (e.right instanceof Ct && e.left instanceof ce && e.left.operator == "+" && e.left.is_string(t)) {
            var g = k(ce, e, {
              operator: "+",
              left: e.left.right,
              right: e.right
            }), m = g.optimize(t);
            g !== m && (e = k(ce, e, {
              operator: "+",
              left: e.left.left,
              right: m
            }));
          }
          if (e.left instanceof ce && e.left.operator == "+" && e.left.is_string(t) && e.right instanceof ce && e.right.operator == "+" && e.
          right.is_string(t)) {
            var g = k(ce, e, {
              operator: "+",
              left: e.left.right,
              right: e.right.left
            }), f = g.optimize(t);
            g !== f && (e = k(ce, e, {
              operator: "+",
              left: k(ce, e.left, {
                operator: "+",
                left: e.left.left,
                right: f
              }),
              right: e.right.right
            }));
          }
          if (e.right instanceof $e && e.right.operator == "-" && e.left.is_number(t)) {
            e = k(ce, e, {
              operator: "-",
              left: e.left,
              right: e.right.expression
            });
            break;
          }
          if (e.left instanceof $e && e.left.operator == "-" && r() && e.right.is_number(t)) {
            e = k(ce, e, {
              operator: "-",
              left: e.right,
              right: e.left.expression
            });
            break;
          }
          if (e.left instanceof jr) {
            var d = e.left, m = e.right.evaluate(t);
            if (m != e.right)
              return d.segments[d.segments.length - 1].value += String(m), d;
          }
          if (e.right instanceof jr) {
            var m = e.right, d = e.left.evaluate(t);
            if (d != e.left)
              return m.segments[0].value = String(d) + m.segments[0].value, m;
          }
          if (e.left instanceof jr && e.right instanceof jr) {
            var d = e.left, v = d.segments, m = e.right;
            v[v.length - 1].value += m.segments[0].value;
            for (var E = 1; E < m.segments.length; E++)
              v.push(m.segments[E]);
            return d;
          }
        case "*":
          _ = t.option("unsafe_math");
        case "&":
        case "|":
        case "^":
          if (e.left.is_number(t) && e.right.is_number(t) && r() && !(e.left instanceof ce && e.left.operator != e.operator && _s[e.left.operator] >=
          _s[e.operator])) {
            var S = k(ce, e, {
              operator: e.operator,
              left: e.right,
              right: e.left
            });
            e.right instanceof Ct && !(e.left instanceof Ct) ? e = us(t, S, e) : e = us(t, e, S);
          }
          _ && e.is_number(t) && (e.right instanceof ce && e.right.operator == e.operator && (e = k(ce, e, {
            operator: e.operator,
            left: k(ce, e.left, {
              operator: e.operator,
              left: e.left,
              right: e.right.left,
              start: e.left.start,
              end: e.right.left.end
            }),
            right: e.right.right
          })), e.right instanceof Ct && e.left instanceof ce && e.left.operator == e.operator && (e.left.left instanceof Ct ? e = k(ce, e, {
            operator: e.operator,
            left: k(ce, e.left, {
              operator: e.operator,
              left: e.left.left,
              right: e.right,
              start: e.left.left.start,
              end: e.right.end
            }),
            right: e.left.right
          }) : e.left.right instanceof Ct && (e = k(ce, e, {
            operator: e.operator,
            left: k(ce, e.left, {
              operator: e.operator,
              left: e.left.right,
              right: e.right,
              start: e.left.right.start,
              end: e.right.end
            }),
            right: e.left.left
          }))), e.left instanceof ce && e.left.operator == e.operator && e.left.right instanceof Ct && e.right instanceof ce && e.right.operator ==
          e.operator && e.right.left instanceof Ct && (e = k(ce, e, {
            operator: e.operator,
            left: k(ce, e.left, {
              operator: e.operator,
              left: k(ce, e.left.left, {
                operator: e.operator,
                left: e.left.right,
                right: e.right.left,
                start: e.left.right.start,
                end: e.right.left.end
              }),
              right: e.left.left
            }),
            right: e.right.right
          })));
      }
      if (c0.has(e.operator)) {
        let C, z, w, D, N = e.left;
        if (e.operator === "&" && e.right instanceof ce && e.right.operator === "|" && typeof (z = e.left.evaluate(t)) == "number" && (typeof (C =
        e.right.right.evaluate(t)) == "number" ? (w = e.right.left, D = e.right.right) : typeof (C = e.right.left.evaluate(t)) == "number" &&
        (w = e.right.right, D = e.right.left), w && D))
          if ((C & z) === 0)
            e = k(ce, e, {
              operator: e.operator,
              left: N,
              right: w
            });
          else {
            let re = k(ce, e, {
              operator: "|",
              left: k(ce, e, {
                operator: "&",
                left: w,
                right: N
              }),
              right: _n(C & z, D)
            });
            e = us(t, e, re);
          }
        if (e.left.equivalent_to(e.right) && !e.left.has_side_effects(t)) {
          if (e.operator === "^")
            return k(We, e, { value: 0 });
          (e.operator === "|" || e.operator === "&") && (e.left = k(We, e, { value: 0 }), e.operator = "|");
        }
        (e.operator === "<<" || e.operator === ">>") && e.right instanceof We && e.right.value === 0 && (e.operator = "|");
        let R = e.right instanceof We && e.right.value === 0 ? e.right : e.left instanceof We && e.left.value === 0 ? e.left : null, j = R &&
        (R === e.right ? e.left : e.right);
        if (R && (e.operator === "|" || e.operator === "^") && (j.is_32_bit_integer() || t.in_32_bit_context()))
          return j;
        if (R && e.operator === "&" && !j.has_side_effects(t))
          return R;
        let J = /* @__PURE__ */ s((re) => re instanceof We && re.value === -1 || re instanceof $e && (re.operator === "-" && re.expression instanceof
        We && re.expression.value === 1 || re.operator === "~" && re.expression instanceof We && re.expression.value === 0), "is_full_mask"),
        H = J(e.right) ? e.right : J(e.left) ? e.left : null, F = H && (H === e.right ? e.left : e.right);
        switch (e.operator) {
          case "|":
            if (H && !F.has_side_effects(t))
              return H;
            break;
          case "&":
            if (H && (F.is_32_bit_integer() || t.in_32_bit_context()))
              return F;
            break;
          case "^":
            if (H)
              return F.bitwise_negate(t.in_32_bit_context());
            e.left instanceof $e && e.left.operator === "~" && e.right instanceof $e && e.right.operator === "~" && (e = k(ce, e, {
              operator: "^",
              left: e.left.expression,
              right: e.right.expression
            }));
            break;
        }
      }
    }
    if (e.right instanceof ce && e.right.operator == e.operator && (_o.has(e.operator) || e.operator == "+" && (e.right.left.is_string(t) ||
    e.left.is_string(t) && e.right.right.is_string(t))))
      return e.left = k(ce, e.left, {
        operator: e.operator,
        left: e.left.transform(t),
        right: e.right.left.transform(t)
      }), e.right = e.right.right.transform(t), e.transform(t);
    var x = e.evaluate(t);
    return x !== e ? (x = _n(x, e).optimize(t), us(t, x, e)) : e;
  });
  At(oo, function(e) {
    return e;
  });
  At(Te, function(e, t) {
    if (!t.option("ie8") && ca(e) && !t.find_parent(di))
      switch (e.name) {
        case "undefined":
          return k(pr, e).optimize(t);
        case "NaN":
          return k(Ul, e).optimize(t);
        case "Infinity":
          return k(mo, e).optimize(t);
      }
    return t.option("reduce_vars") && !t.is_lhs() ? nne(e, t) : e;
  });
  s(p0, "is_atomic");
  At(pr, function(e, t) {
    if (t.option("unsafe_undefined")) {
      var r = Kk(t, "undefined");
      if (r) {
        var i = k(Te, e, {
          name: "undefined",
          scope: r.scope,
          thedef: r
        });
        return gn(i, 8), i;
      }
    }
    var n = t.is_lhs();
    return n && p0(n, e) ? e : k($e, e, {
      operator: "void",
      expression: k(We, e, {
        value: 0
      })
    });
  });
  At(mo, function(e, t) {
    var r = t.is_lhs();
    return r && p0(r, e) || t.option("keep_infinity") && !(r && !p0(r, e)) && !Kk(t, "Infinity") ? e : k(ce, e, {
      operator: "/",
      left: k(We, e, {
        value: 1
      }),
      right: k(We, e, {
        value: 0
      })
    });
  });
  At(Ul, function(e, t) {
    var r = t.is_lhs();
    return r && !p0(r, e) || Kk(t, "NaN") ? k(ce, e, {
      operator: "/",
      left: k(We, e, {
        value: 0
      }),
      right: k(We, e, {
        value: 0
      })
    }) : e;
  });
  Dpt = qt("+ - / * % >> << >>> | ^ &"), wpt = qt("* | ^ &");
  At(ct, function(e, t) {
    if (e.logical)
      return e.lift_sequences(t);
    var r;
    if (e.operator === "=" && e.left instanceof Te && e.left.name !== "arguments" && !(r = e.left.definition()).undeclared && e.right.equivalent_to(
    e.left))
      return e.right;
    if (t.option("dead_code") && e.left instanceof Te && (r = e.left.definition()).scope === t.find_parent(Ue)) {
      var i = 0, n, a = e;
      do
        if (n = a, a = t.parent(i++), a instanceof cn) {
          if (o(i, a) || a0(r.scope, [r])) break;
          return e.operator == "=" ? e.right : (r.fixed = !1, k(ce, e, {
            operator: e.operator.slice(0, -1),
            left: e.left,
            right: e.right
          }).optimize(t));
        }
      while (a instanceof ce && a.right === n || a instanceof Qe && a.tail_node() === n);
    }
    return e = e.lift_sequences(t), e.operator == "=" && e.left instanceof Te && e.right instanceof ce && (e.right.left instanceof Te && e.right.
    left.name == e.left.name && Dpt.has(e.right.operator) ? (e.operator = e.right.operator + "=", e.right = e.right.right) : e.right.right instanceof
    Te && e.right.right.name == e.left.name && wpt.has(e.right.operator) && !e.right.left.has_side_effects(t) && (e.operator = e.right.operator +
    "=", e.right = e.right.left)), e;
    function o(u, l) {
      function c() {
        let y = e.right;
        e.right = k(Xi, y);
        let _ = l.may_throw(t);
        return e.right = y, _;
      }
      s(c, "may_assignment_throw");
      for (var p = e.left.definition().scope.get_defun_scope(), h; (h = t.parent(u++)) !== p; )
        if (h instanceof mi && (h.bfinally || h.bcatch && c()))
          return !0;
    }
    s(o, "in_try");
  });
  At(sn, function(e, t) {
    if (!t.option("evaluate"))
      return e;
    var r = e.right.evaluate(t);
    let i, n;
    return r === void 0 ? (!((i = t.parent()) instanceof Ue) || t.option("keep_fargs") === !1 || (n = t.parent(1)).TYPE === "Call" && n.expression ===
    i) && (e = e.left) : r !== e.right && (r = _n(r, e.right), e.right = yo(r, e.right)), e;
  });
  s(Opt, "is_nullish_check");
  At(it, function(e, t) {
    if (!t.option("conditionals")) return e;
    if (e.condition instanceof Qe) {
      var r = e.condition.expressions.slice();
      return e.condition = r.pop(), r.push(e), _t(e, r);
    }
    var i = e.condition.evaluate(t);
    if (i !== e.condition)
      return i ? Qo(t.parent(), t.self(), e.consequent) : Qo(t.parent(), t.self(), e.alternative);
    var n = i.negate(t, os(t));
    us(t, i, n) === n && (e = k(it, e, {
      condition: n,
      consequent: e.alternative,
      alternative: e.consequent
    }));
    var a = e.condition, o = e.consequent, u = e.alternative;
    if (a instanceof Te && o instanceof Te && a.definition() === o.definition())
      return k(ce, e, {
        operator: "||",
        left: a,
        right: u
      });
    if (o instanceof ct && u instanceof ct && o.operator === u.operator && o.logical === u.logical && o.left.equivalent_to(u.left) && (!e.condition.
    has_side_effects(t) || o.operator == "=" && !o.left.has_side_effects(t)))
      return k(ct, e, {
        operator: o.operator,
        left: o.left,
        logical: o.logical,
        right: k(it, e, {
          condition: e.condition,
          consequent: o.right,
          alternative: u.right
        })
      });
    var l;
    if (o instanceof Fe && u.TYPE === o.TYPE && o.args.length > 0 && o.args.length == u.args.length && o.expression.equivalent_to(u.expression) &&
    !e.condition.has_side_effects(t) && !o.expression.has_side_effects(t) && typeof (l = g()) == "number") {
      var c = o.clone();
      return c.args[l] = k(it, e, {
        condition: e.condition,
        consequent: o.args[l],
        alternative: u.args[l]
      }), c;
    }
    if (u instanceof it && o.equivalent_to(u.consequent))
      return k(it, e, {
        condition: k(ce, e, {
          operator: "||",
          left: a,
          right: u.condition
        }),
        consequent: o,
        alternative: u.alternative
      }).optimize(t);
    if (t.option("ecma") >= 2020 && Opt(a, u, t))
      return k(ce, e, {
        operator: "??",
        left: u,
        right: o
      }).optimize(t);
    if (u instanceof Qe && o.equivalent_to(u.expressions[u.expressions.length - 1]))
      return _t(e, [
        k(ce, e, {
          operator: "||",
          left: a,
          right: _t(e, u.expressions.slice(0, -1))
        }),
        o
      ]).optimize(t);
    if (u instanceof ce && u.operator == "&&" && o.equivalent_to(u.right))
      return k(ce, e, {
        operator: "&&",
        left: k(ce, e, {
          operator: "||",
          left: a,
          right: u.left
        }),
        right: o
      }).optimize(t);
    if (o instanceof it && o.alternative.equivalent_to(u))
      return k(it, e, {
        condition: k(ce, e, {
          left: e.condition,
          operator: "&&",
          right: o.condition
        }),
        consequent: o.consequent,
        alternative: u
      });
    if (o.equivalent_to(u))
      return _t(e, [
        e.condition,
        o
      ]).optimize(t);
    if (o instanceof ce && o.operator == "||" && o.right.equivalent_to(u))
      return k(ce, e, {
        operator: "||",
        left: k(ce, e, {
          operator: "&&",
          left: e.condition,
          right: o.left
        }),
        right: u
      }).optimize(t);
    let p = t.in_boolean_context();
    if (y(e.consequent))
      return _(e.alternative) ? h(e.condition) : k(ce, e, {
        operator: "||",
        left: h(e.condition),
        right: e.alternative
      });
    if (_(e.consequent))
      return y(e.alternative) ? h(e.condition.negate(t)) : k(ce, e, {
        operator: "&&",
        left: h(e.condition.negate(t)),
        right: e.alternative
      });
    if (y(e.alternative))
      return k(ce, e, {
        operator: "||",
        left: h(e.condition.negate(t)),
        right: e.consequent
      });
    if (_(e.alternative))
      return k(ce, e, {
        operator: "&&",
        left: h(e.condition),
        right: e.consequent
      });
    return e;
    function h(m) {
      return m.is_boolean() ? m : k($e, m, {
        operator: "!",
        expression: m.negate(t)
      });
    }
    function y(m) {
      return m instanceof ln || p && m instanceof Ct && m.getValue() || m instanceof $e && m.operator == "!" && m.expression instanceof Ct &&
      !m.expression.getValue();
    }
    function _(m) {
      return m instanceof Ss || p && m instanceof Ct && !m.getValue() || m instanceof $e && m.operator == "!" && m.expression instanceof Ct &&
      m.expression.getValue();
    }
    function g() {
      for (var m = o.args, f = u.args, d = 0, v = m.length; d < v; d++) {
        if (m[d] instanceof ft) return;
        if (!m[d].equivalent_to(f[d])) {
          if (f[d] instanceof ft) return;
          for (var E = d + 1; E < v; E++)
            if (m[E] instanceof ft || !m[E].equivalent_to(f[E])) return;
          return d;
        }
      }
    }
  });
  At(rh, function(e, t) {
    if (t.in_boolean_context()) return k(We, e, {
      value: +e.value
    });
    var r = t.parent();
    return t.option("booleans_as_integers") ? (r instanceof ce && (r.operator == "===" || r.operator == "!==") && (r.operator = r.operator.replace(
    /=$/, "")), k(We, e, {
      value: +e.value
    })) : t.option("booleans") ? r instanceof ce && (r.operator == "==" || r.operator == "!=") ? k(We, e, {
      value: +e.value
    }) : k($e, e, {
      operator: "!",
      expression: k(We, e, {
        value: 1 - e.value
      })
    }) : e;
  });
  s(cne, "safe_to_flatten");
  je.DEFMETHOD("flatten_object", function(e, t) {
    if (t.option("properties") && e !== "__proto__" && !(this instanceof Wi)) {
      var r = t.option("unsafe_arrows") && t.option("ecma") >= 2015, i = this.expression;
      if (i instanceof Tt)
        for (var n = i.properties, a = n.length; --a >= 0; ) {
          var o = n[a];
          if ("" + (o instanceof Kr ? o.key.name : o.key) == e)
            return !n.every(
              (l) => (l instanceof Nt || r && l instanceof Kr && !l.is_generator) && !l.computed_key()
            ) || !cne(o.value, t) ? void 0 : k(fr, this, {
              expression: k(pt, i, {
                elements: n.map(function(l) {
                  var c = l.value;
                  c instanceof rs && (c = k(jt, c, c));
                  var p = l.key;
                  return p instanceof Se && !(p instanceof hi) ? _t(l, [p, c]) : c;
                })
              }),
              property: k(We, this, {
                value: a
              })
            });
        }
    }
  });
  At(fr, function(e, t) {
    var r = e.expression, i = e.property;
    if (t.option("properties")) {
      var n = i.evaluate(t);
      if (n !== i) {
        if (typeof n == "string")
          if (n == "undefined")
            n = void 0;
          else {
            var a = parseFloat(n);
            a.toString() == n && (n = a);
          }
        i = e.property = yo(
          i,
          _n(n, i).transform(t)
        );
        var o = "" + n;
        if (Xc(o) && o.length <= i.size() + 1)
          return k(It, e, {
            expression: r,
            optional: e.optional,
            property: o,
            quote: i.quote
          }).optimize(t);
      }
    }
    var u;
    e: if (t.option("arguments") && r instanceof Te && r.name == "arguments" && r.definition().orig.length == 1 && (u = r.scope) instanceof Ue &&
    u.uses_arguments && !(u instanceof Zt) && i instanceof We) {
      for (var l = i.getValue(), c = /* @__PURE__ */ new Set(), p = u.argnames, h = 0; h < p.length; h++) {
        if (!(p[h] instanceof Nr))
          break e;
        var y = p[h].name;
        if (c.has(y))
          break e;
        c.add(y);
      }
      var _ = u.argnames[l];
      if (_ && t.has_directive("use strict")) {
        var g = _.definition();
        (!t.option("reduce_vars") || g.assignments || g.orig.length > 1) && (_ = null);
      } else if (!_ && !t.option("keep_fargs") && l < u.argnames.length + 5)
        for (; l >= u.argnames.length; )
          _ = u.create_symbol(Nr, {
            source: u,
            scope: u,
            tentative_name: "argument_" + u.argnames.length
          }), u.argnames.push(_);
      if (_) {
        var m = k(Te, e, _);
        return m.reference({}), Jo(_, 1), m;
      }
    }
    if (t.is_lhs()) return e;
    if (n !== i) {
      var f = e.flatten_object(o, t);
      f && (r = e.expression = f.expression, i = e.property = f.property);
    }
    if (t.option("properties") && t.option("side_effects") && i instanceof We && r instanceof pt) {
      var l = i.getValue(), d = r.elements, v = d[l];
      e: if (cne(v, t)) {
        for (var E = !0, S = [], x = d.length; --x > l; ) {
          var a = d[x].drop_side_effect_free(t);
          a && (S.unshift(a), E && a.has_side_effects(t) && (E = !1));
        }
        if (v instanceof ft) break e;
        for (v = v instanceof xn ? k(pr, v) : v, E || S.unshift(v); --x >= 0; ) {
          var a = d[x];
          if (a instanceof ft) break e;
          a = a.drop_side_effect_free(t), a ? S.unshift(a) : l--;
        }
        return E ? (S.push(v), _t(e, S).optimize(t)) : k(fr, e, {
          expression: k(pt, r, {
            elements: S
          }),
          property: k(We, i, {
            value: l
          })
        });
      }
    }
    var C = e.evaluate(t);
    return C !== e ? (C = _n(C, e).optimize(t), us(t, C, e)) : e;
  });
  At(er, function(e, t) {
    if (Ia(e.expression, t)) {
      let r = t.parent();
      return r instanceof $e && r.operator === "delete" ? _n(0, e) : k(pr, e);
    }
    return e.expression instanceof je || e.expression instanceof Fe ? e : e.expression;
  });
  At(It, function(e, t) {
    let r = t.parent();
    if (t.is_lhs()) return e;
    if (t.option("unsafe_proto") && e.expression instanceof It && e.expression.property == "prototype") {
      var i = e.expression.expression;
      if (ca(i)) switch (i.name) {
        case "Array":
          e.expression = k(pt, e.expression, {
            elements: []
          });
          break;
        case "Function":
          e.expression = i0(e.expression);
          break;
        case "Number":
          e.expression = k(We, e.expression, {
            value: 0
          });
          break;
        case "Object":
          e.expression = k(Tt, e.expression, {
            properties: []
          });
          break;
        case "RegExp":
          e.expression = k($r, e.expression, {
            value: { source: "t", flags: "" }
          });
          break;
        case "String":
          e.expression = k(bt, e.expression, {
            value: ""
          });
          break;
      }
    }
    if (!(r instanceof Fe) || !nn(r, po)) {
      let a = e.flatten_object(e.property, t);
      if (a) return a.optimize(t);
    }
    if (e.expression instanceof je && r instanceof je)
      return e;
    let n = e.evaluate(t);
    return n !== e ? (n = _n(n, e).optimize(t), us(t, n, e)) : e;
  });
  s(zk, "literals_in_boolean_context");
  s(fne, "inline_array_like_spread");
  At(pt, function(e, t) {
    var r = zk(e, t);
    return r !== e ? r : (fne(e.elements), e);
  });
  s(kpt, "inline_object_prop_spread");
  At(Tt, function(e, t) {
    var r = zk(e, t);
    return r !== e ? r : (kpt(e.properties), e);
  });
  At($r, zk);
  At(mr, function(e, t) {
    return e.value && Ra(e.value, t) && (e.value = null), e;
  });
  At(Zt, Hk);
  At(jt, function(e, t) {
    return e = Hk(e, t), t.option("unsafe_arrows") && t.option("ecma") >= 2015 && !e.name && !e.is_generator && !e.uses_arguments && !e.pinned() &&
    !_r(e, (i) => {
      if (i instanceof kr) return Yi;
    }) ? k(Zt, e, e).optimize(t) : e;
  });
  At(ht, function(e) {
    for (let t = 0; t < e.properties.length; t++) {
      let r = e.properties[t];
      r instanceof Hr && r.body.length == 0 && (e.properties.splice(t, 1), t--);
    }
    return e;
  });
  At(Hr, function(e, t) {
    return fy(e.body, t), e;
  });
  At(Oi, function(e, t) {
    return e.expression && !e.is_star && Ra(e.expression, t) && (e.expression = null), e;
  });
  At(jr, function(e, t) {
    if (!t.option("evaluate") || t.parent() instanceof pn)
      return e;
    for (var r = [], i = 0; i < e.segments.length; i++) {
      var n = e.segments[i];
      if (n instanceof Se) {
        var a = n.evaluate(t);
        if (a !== n && (a + "").length <= n.size() + 3) {
          r[r.length - 1].value = r[r.length - 1].value + a + e.segments[++i].value;
          continue;
        }
        if (n instanceof jr) {
          var o = n.segments;
          r[r.length - 1].value += o[0].value;
          for (var u = 1; u < o.length; u++)
            n = o[u], r.push(n);
          continue;
        }
      }
      r.push(n);
    }
    if (e.segments = r, r.length == 1)
      return k(bt, e, r[0]);
    if (r.length === 3 && r[1] instanceof Se && (r[1].is_string(t) || r[1].is_number(t) || Ia(r[1], t) || t.option("unsafe"))) {
      if (r[2].value === "")
        return k(ce, e, {
          operator: "+",
          left: k(bt, e, {
            value: r[0].value
          }),
          right: r[1]
        });
      if (r[0].value === "")
        return k(ce, e, {
          operator: "+",
          left: r[1],
          right: k(bt, e, {
            value: r[2].value
          })
        });
    }
    return e;
  });
  At(pn, function(e) {
    return e;
  });
  s(Gk, "lift_key");
  At(gr, Gk);
  At(Kr, function(e, t) {
    if (Gk(e, t), t.option("arrows") && t.parent() instanceof Tt && !e.is_generator && !e.value.uses_arguments && !e.value.pinned() && e.value.
    body.length == 1 && e.value.body[0] instanceof mr && e.value.body[0].value && !e.value.contains_this()) {
      var r = k(Zt, e.value, e.value);
      return r.async = e.async, r.is_generator = e.is_generator, k(Nt, e, {
        key: e.key instanceof hi ? e.key.name : e.key,
        value: r,
        quote: e.quote
      });
    }
    return e;
  });
  At(Nt, function(e, t) {
    Gk(e, t);
    var r = t.option("unsafe_methods");
    if (r && t.option("ecma") >= 2015 && (!(r instanceof RegExp) || r.test(e.key + ""))) {
      var i = e.key, n = e.value, a = n instanceof Zt && Array.isArray(n.body) && !n.contains_this();
      if ((a || n instanceof jt) && !n.name)
        return k(Kr, e, {
          async: n.async,
          is_generator: n.is_generator,
          key: i instanceof Se ? i : k(hi, e, {
            name: i
          }),
          value: k(rs, n, n),
          quote: e.quote
        });
    }
    return e;
  });
  At(Ut, function(e, t) {
    if (t.option("pure_getters") == !0 && t.option("unused") && !e.is_array && Array.isArray(e.names) && !a(t) && !(e.names[e.names.length -
    1] instanceof ft)) {
      for (var r = [], i = 0; i < e.names.length; i++) {
        var n = e.names[i];
        n instanceof Nt && typeof n.key == "string" && n.value instanceof Lr && !o(t, n.value.definition()) || r.push(n);
      }
      r.length != e.names.length && (e.names = r);
    }
    return e;
    function a(u) {
      for (var l = [/^VarDef$/, /^(Const|Let|Var)$/, /^Export$/], c = 0, p = 0, h = l.length; c < h; p++) {
        var y = u.parent(p);
        if (!y) return !1;
        if (!(c === 0 && y.TYPE == "Destructuring")) {
          if (!l[c].test(y.TYPE))
            return !1;
          c++;
        }
      }
      return !0;
    }
    function o(u, l) {
      return l.references.length ? !0 : l.global ? u.toplevel.vars ? u.top_retain ? u.top_retain(l) : !1 : !0 : !1;
    }
  });
});

// ../node_modules/@jridgewell/source-map/dist/source-map.cjs
var hne = b((h0) => {
  "use strict";
  Object.defineProperty(h0, "__esModule", { value: !0 });
  var uf = Xg(), lf = Sx(), Wk = class e {
    static {
      s(this, "SourceMapConsumer");
    }
    constructor(t, r) {
      let i = this._map = new uf.AnyMap(t, r);
      this.file = i.file, this.names = i.names, this.sourceRoot = i.sourceRoot, this.sources = i.resolvedSources, this.sourcesContent = i.sourcesContent,
      this.version = i.version;
    }
    static fromSourceMap(t, r) {
      return t.toDecodedMap ? new e(t.toDecodedMap(), r) : new e(t.toJSON(), r);
    }
    get mappings() {
      return uf.encodedMappings(this._map);
    }
    originalPositionFor(t) {
      return uf.originalPositionFor(this._map, t);
    }
    generatedPositionFor(t) {
      return uf.generatedPositionFor(this._map, t);
    }
    allGeneratedPositionsFor(t) {
      return uf.allGeneratedPositionsFor(this._map, t);
    }
    hasContentsOfAllSources() {
      if (!this.sourcesContent || this.sourcesContent.length !== this.sources.length)
        return !1;
      for (let t of this.sourcesContent)
        if (t == null)
          return !1;
      return !0;
    }
    sourceContentFor(t, r) {
      let i = uf.sourceContentFor(this._map, t);
      if (i != null)
        return i;
      if (r)
        return null;
      throw new Error(`"${t}" is not in the SourceMap.`);
    }
    eachMapping(t, r) {
      uf.eachMapping(this._map, r ? t.bind(r) : t);
    }
    destroy() {
    }
  }, $k = class e {
    static {
      s(this, "SourceMapGenerator");
    }
    constructor(t) {
      this._map = t instanceof lf.GenMapping ? t : new lf.GenMapping(t);
    }
    static fromSourceMap(t) {
      return new e(lf.fromMap(t));
    }
    addMapping(t) {
      lf.maybeAddMapping(this._map, t);
    }
    setSourceContent(t, r) {
      lf.setSourceContent(this._map, t, r);
    }
    toJSON() {
      return lf.toEncodedMap(this._map);
    }
    toString() {
      return JSON.stringify(this.toJSON());
    }
    toDecodedMap() {
      return lf.toDecodedMap(this._map);
    }
  };
  h0.SourceMapConsumer = Wk;
  h0.SourceMapGenerator = $k;
});

// ../node_modules/terser/lib/sourcemap.js
function* dne(e) {
  e = Mn(e, {
    file: null,
    root: null,
    orig: null,
    files: {}
  });
  var t, r = new d0.SourceMapGenerator({
    file: e.file,
    sourceRoot: e.root
  });
  let i = { __proto__: null }, n = e.files;
  for (var a in n) Pi(n, a) && (i[a] = n[a]);
  e.orig && (t = yield new d0.SourceMapConsumer(e.orig), t.sourcesContent && t.sources.forEach(function(h, y) {
    var _ = t.sourcesContent[y];
    _ && (i[h] = _);
  }));
  function o(h, y, _, g, m, f) {
    let d = { line: y, column: _ };
    if (t) {
      var v = t.originalPositionFor({
        line: g,
        column: m
      });
      if (v.source === null) {
        r.addMapping({
          generated: d,
          original: null,
          source: null,
          name: null
        });
        return;
      }
      h = v.source, g = v.line, m = v.column, f = v.name || f;
    }
    r.addMapping({
      generated: d,
      original: { line: g, column: m },
      source: h,
      name: f
    }), r.setSourceContent(h, i[h]);
  }
  s(o, "add");
  function u(h) {
    return h.sourcesContent && h.sourcesContent.every((_) => _ == null) && delete h.sourcesContent, h.file === void 0 && delete h.file, h.sourceRoot ===
    void 0 && delete h.sourceRoot, h;
  }
  s(u, "clean");
  function l() {
    return r.toDecodedMap ? u(r.toDecodedMap()) : null;
  }
  s(l, "getDecoded");
  function c() {
    return u(r.toJSON());
  }
  s(c, "getEncoded");
  function p() {
    t && t.destroy && t.destroy();
  }
  return s(p, "destroy"), {
    add: o,
    getDecoded: l,
    getEncoded: c,
    destroy: p
  };
}
var d0, mne = at(() => {
  "use strict";
  d0 = Gt(hne(), 1);
  Gi();
  s(dne, "SourceMap");
});

// ../node_modules/terser/tools/domprops.js
var yne, gne = at(() => {
  yne = [
    "$&",
    "$'",
    "$*",
    "$+",
    "$1",
    "$2",
    "$3",
    "$4",
    "$5",
    "$6",
    "$7",
    "$8",
    "$9",
    "$_",
    "$`",
    "$input",
    "-moz-animation",
    "-moz-animation-delay",
    "-moz-animation-direction",
    "-moz-animation-duration",
    "-moz-animation-fill-mode",
    "-moz-animation-iteration-count",
    "-moz-animation-name",
    "-moz-animation-play-state",
    "-moz-animation-timing-function",
    "-moz-appearance",
    "-moz-backface-visibility",
    "-moz-border-end",
    "-moz-border-end-color",
    "-moz-border-end-style",
    "-moz-border-end-width",
    "-moz-border-image",
    "-moz-border-start",
    "-moz-border-start-color",
    "-moz-border-start-style",
    "-moz-border-start-width",
    "-moz-box-align",
    "-moz-box-direction",
    "-moz-box-flex",
    "-moz-box-ordinal-group",
    "-moz-box-orient",
    "-moz-box-pack",
    "-moz-box-sizing",
    "-moz-float-edge",
    "-moz-font-feature-settings",
    "-moz-font-language-override",
    "-moz-force-broken-image-icon",
    "-moz-hyphens",
    "-moz-image-region",
    "-moz-margin-end",
    "-moz-margin-start",
    "-moz-orient",
    "-moz-osx-font-smoothing",
    "-moz-outline-radius",
    "-moz-outline-radius-bottomleft",
    "-moz-outline-radius-bottomright",
    "-moz-outline-radius-topleft",
    "-moz-outline-radius-topright",
    "-moz-padding-end",
    "-moz-padding-start",
    "-moz-perspective",
    "-moz-perspective-origin",
    "-moz-tab-size",
    "-moz-text-size-adjust",
    "-moz-transform",
    "-moz-transform-origin",
    "-moz-transform-style",
    "-moz-transition",
    "-moz-transition-delay",
    "-moz-transition-duration",
    "-moz-transition-property",
    "-moz-transition-timing-function",
    "-moz-user-focus",
    "-moz-user-input",
    "-moz-user-modify",
    "-moz-user-select",
    "-moz-window-dragging",
    "-webkit-align-content",
    "-webkit-align-items",
    "-webkit-align-self",
    "-webkit-animation",
    "-webkit-animation-delay",
    "-webkit-animation-direction",
    "-webkit-animation-duration",
    "-webkit-animation-fill-mode",
    "-webkit-animation-iteration-count",
    "-webkit-animation-name",
    "-webkit-animation-play-state",
    "-webkit-animation-timing-function",
    "-webkit-appearance",
    "-webkit-backface-visibility",
    "-webkit-background-clip",
    "-webkit-background-origin",
    "-webkit-background-size",
    "-webkit-border-bottom-left-radius",
    "-webkit-border-bottom-right-radius",
    "-webkit-border-image",
    "-webkit-border-radius",
    "-webkit-border-top-left-radius",
    "-webkit-border-top-right-radius",
    "-webkit-box-align",
    "-webkit-box-direction",
    "-webkit-box-flex",
    "-webkit-box-ordinal-group",
    "-webkit-box-orient",
    "-webkit-box-pack",
    "-webkit-box-shadow",
    "-webkit-box-sizing",
    "-webkit-clip-path",
    "-webkit-filter",
    "-webkit-flex",
    "-webkit-flex-basis",
    "-webkit-flex-direction",
    "-webkit-flex-flow",
    "-webkit-flex-grow",
    "-webkit-flex-shrink",
    "-webkit-flex-wrap",
    "-webkit-font-feature-settings",
    "-webkit-justify-content",
    "-webkit-line-clamp",
    "-webkit-mask",
    "-webkit-mask-clip",
    "-webkit-mask-composite",
    "-webkit-mask-image",
    "-webkit-mask-origin",
    "-webkit-mask-position",
    "-webkit-mask-position-x",
    "-webkit-mask-position-y",
    "-webkit-mask-repeat",
    "-webkit-mask-size",
    "-webkit-order",
    "-webkit-perspective",
    "-webkit-perspective-origin",
    "-webkit-text-fill-color",
    "-webkit-text-security",
    "-webkit-text-size-adjust",
    "-webkit-text-stroke",
    "-webkit-text-stroke-color",
    "-webkit-text-stroke-width",
    "-webkit-transform",
    "-webkit-transform-origin",
    "-webkit-transform-style",
    "-webkit-transition",
    "-webkit-transition-delay",
    "-webkit-transition-duration",
    "-webkit-transition-property",
    "-webkit-transition-timing-function",
    "-webkit-user-select",
    "@@iterator",
    "ABORT_ERR",
    "ACTIVE",
    "ACTIVE_ATTRIBUTES",
    "ACTIVE_TEXTURE",
    "ACTIVE_UNIFORMS",
    "ACTIVE_UNIFORM_BLOCKS",
    "ADDITION",
    "ALIASED_LINE_WIDTH_RANGE",
    "ALIASED_POINT_SIZE_RANGE",
    "ALL",
    "ALLOW_KEYBOARD_INPUT",
    "ALLPASS",
    "ALPHA",
    "ALPHA_BITS",
    "ALREADY_SIGNALED",
    "ALT_MASK",
    "ALWAYS",
    "ANY_SAMPLES_PASSED",
    "ANY_SAMPLES_PASSED_CONSERVATIVE",
    "ANY_TYPE",
    "ANY_UNORDERED_NODE_TYPE",
    "ARRAY_BUFFER",
    "ARRAY_BUFFER_BINDING",
    "ATTACHED_SHADERS",
    "ATTRIBUTE_NODE",
    "AT_TARGET",
    "AbortController",
    "AbortSignal",
    "AbsoluteOrientationSensor",
    "AbstractRange",
    "Accelerometer",
    "AddSearchProvider",
    "AggregateError",
    "AnalyserNode",
    "Animation",
    "AnimationEffect",
    "AnimationEvent",
    "AnimationPlaybackEvent",
    "AnimationTimeline",
    "AnonXMLHttpRequest",
    "Any",
    "AnyPermissions",
    "ApplicationCache",
    "ApplicationCacheErrorEvent",
    "Array",
    "ArrayBuffer",
    "ArrayType",
    "Atomics",
    "Attr",
    "Audio",
    "AudioBuffer",
    "AudioBufferSourceNode",
    "AudioContext",
    "AudioData",
    "AudioDecoder",
    "AudioDestinationNode",
    "AudioEncoder",
    "AudioListener",
    "AudioNode",
    "AudioParam",
    "AudioParamMap",
    "AudioProcessingEvent",
    "AudioScheduledSourceNode",
    "AudioSinkInfo",
    "AudioStreamTrack",
    "AudioWorklet",
    "AudioWorkletNode",
    "AuthenticatorAssertionResponse",
    "AuthenticatorAttestationResponse",
    "AuthenticatorResponse",
    "AutocompleteErrorEvent",
    "BACK",
    "BAD_BOUNDARYPOINTS_ERR",
    "BAD_REQUEST",
    "BANDPASS",
    "BLEND",
    "BLEND_COLOR",
    "BLEND_DST_ALPHA",
    "BLEND_DST_RGB",
    "BLEND_EQUATION",
    "BLEND_EQUATION_ALPHA",
    "BLEND_EQUATION_RGB",
    "BLEND_SRC_ALPHA",
    "BLEND_SRC_RGB",
    "BLUE",
    "BLUE_BITS",
    "BLUR",
    "BOOL",
    "BOOLEAN_TYPE",
    "BOOL_VEC2",
    "BOOL_VEC3",
    "BOOL_VEC4",
    "BOTH",
    "BROWSER_DEFAULT_WEBGL",
    "BUBBLING_PHASE",
    "BUFFER_SIZE",
    "BUFFER_USAGE",
    "BYTE",
    "BYTES_PER_ELEMENT",
    "BackgroundFetchManager",
    "BackgroundFetchRecord",
    "BackgroundFetchRegistration",
    "BarProp",
    "BarcodeDetector",
    "BaseAudioContext",
    "BaseHref",
    "BatteryManager",
    "BeforeInstallPromptEvent",
    "BeforeLoadEvent",
    "BeforeUnloadEvent",
    "BigInt",
    "BigInt64Array",
    "BigUint64Array",
    "BiquadFilterNode",
    "Blob",
    "BlobEvent",
    "Bluetooth",
    "BluetoothCharacteristicProperties",
    "BluetoothDevice",
    "BluetoothRemoteGATTCharacteristic",
    "BluetoothRemoteGATTDescriptor",
    "BluetoothRemoteGATTServer",
    "BluetoothRemoteGATTService",
    "BluetoothUUID",
    "Boolean",
    "BroadcastChannel",
    "BrowserCaptureMediaStreamTrack",
    "BrowserInfo",
    "ByteLengthQueuingStrategy",
    "CAPTURING_PHASE",
    "CCW",
    "CDATASection",
    "CDATA_SECTION_NODE",
    "CHANGE",
    "CHARSET_RULE",
    "CHECKING",
    "CLAMP_TO_EDGE",
    "CLICK",
    "CLOSED",
    "CLOSING",
    "COLOR",
    "COLOR_ATTACHMENT0",
    "COLOR_ATTACHMENT1",
    "COLOR_ATTACHMENT10",
    "COLOR_ATTACHMENT11",
    "COLOR_ATTACHMENT12",
    "COLOR_ATTACHMENT13",
    "COLOR_ATTACHMENT14",
    "COLOR_ATTACHMENT15",
    "COLOR_ATTACHMENT2",
    "COLOR_ATTACHMENT3",
    "COLOR_ATTACHMENT4",
    "COLOR_ATTACHMENT5",
    "COLOR_ATTACHMENT6",
    "COLOR_ATTACHMENT7",
    "COLOR_ATTACHMENT8",
    "COLOR_ATTACHMENT9",
    "COLOR_BUFFER_BIT",
    "COLOR_CLEAR_VALUE",
    "COLOR_WRITEMASK",
    "COMMENT_NODE",
    "COMPARE_REF_TO_TEXTURE",
    "COMPILE_STATUS",
    "COMPLETION_STATUS_KHR",
    "COMPRESSED_RGBA_S3TC_DXT1_EXT",
    "COMPRESSED_RGBA_S3TC_DXT3_EXT",
    "COMPRESSED_RGBA_S3TC_DXT5_EXT",
    "COMPRESSED_RGB_S3TC_DXT1_EXT",
    "COMPRESSED_TEXTURE_FORMATS",
    "COMPUTE",
    "CONDITION_SATISFIED",
    "CONFIGURATION_UNSUPPORTED",
    "CONNECTING",
    "CONSTANT_ALPHA",
    "CONSTANT_COLOR",
    "CONSTRAINT_ERR",
    "CONTEXT_LOST_WEBGL",
    "CONTROL_MASK",
    "COPY_DST",
    "COPY_READ_BUFFER",
    "COPY_READ_BUFFER_BINDING",
    "COPY_SRC",
    "COPY_WRITE_BUFFER",
    "COPY_WRITE_BUFFER_BINDING",
    "COUNTER_STYLE_RULE",
    "CSS",
    "CSS2Properties",
    "CSSAnimation",
    "CSSCharsetRule",
    "CSSConditionRule",
    "CSSContainerRule",
    "CSSCounterStyleRule",
    "CSSFontFaceRule",
    "CSSFontFeatureValuesRule",
    "CSSFontPaletteValuesRule",
    "CSSGroupingRule",
    "CSSImageValue",
    "CSSImportRule",
    "CSSKeyframeRule",
    "CSSKeyframesRule",
    "CSSKeywordValue",
    "CSSLayerBlockRule",
    "CSSLayerStatementRule",
    "CSSMarginRule",
    "CSSMathClamp",
    "CSSMathInvert",
    "CSSMathMax",
    "CSSMathMin",
    "CSSMathNegate",
    "CSSMathProduct",
    "CSSMathSum",
    "CSSMathValue",
    "CSSMatrixComponent",
    "CSSMediaRule",
    "CSSMozDocumentRule",
    "CSSNameSpaceRule",
    "CSSNamespaceRule",
    "CSSNestedDeclarations",
    "CSSNumericArray",
    "CSSNumericValue",
    "CSSPageDescriptors",
    "CSSPageRule",
    "CSSPerspective",
    "CSSPositionTryDescriptors",
    "CSSPositionTryRule",
    "CSSPositionValue",
    "CSSPrimitiveValue",
    "CSSPropertyRule",
    "CSSRotate",
    "CSSRule",
    "CSSRuleList",
    "CSSScale",
    "CSSScopeRule",
    "CSSSkew",
    "CSSSkewX",
    "CSSSkewY",
    "CSSStartingStyleRule",
    "CSSStyleDeclaration",
    "CSSStyleRule",
    "CSSStyleSheet",
    "CSSStyleValue",
    "CSSSupportsRule",
    "CSSTransformComponent",
    "CSSTransformValue",
    "CSSTransition",
    "CSSTranslate",
    "CSSUnitValue",
    "CSSUnknownRule",
    "CSSUnparsedValue",
    "CSSValue",
    "CSSValueList",
    "CSSVariableReferenceValue",
    "CSSVariablesDeclaration",
    "CSSVariablesRule",
    "CSSViewTransitionRule",
    "CSSViewportRule",
    "CSS_ATTR",
    "CSS_CM",
    "CSS_COUNTER",
    "CSS_CUSTOM",
    "CSS_DEG",
    "CSS_DIMENSION",
    "CSS_EMS",
    "CSS_EXS",
    "CSS_FILTER_BLUR",
    "CSS_FILTER_BRIGHTNESS",
    "CSS_FILTER_CONTRAST",
    "CSS_FILTER_CUSTOM",
    "CSS_FILTER_DROP_SHADOW",
    "CSS_FILTER_GRAYSCALE",
    "CSS_FILTER_HUE_ROTATE",
    "CSS_FILTER_INVERT",
    "CSS_FILTER_OPACITY",
    "CSS_FILTER_REFERENCE",
    "CSS_FILTER_SATURATE",
    "CSS_FILTER_SEPIA",
    "CSS_GRAD",
    "CSS_HZ",
    "CSS_IDENT",
    "CSS_IN",
    "CSS_INHERIT",
    "CSS_KHZ",
    "CSS_MATRIX",
    "CSS_MATRIX3D",
    "CSS_MM",
    "CSS_MS",
    "CSS_NUMBER",
    "CSS_PC",
    "CSS_PERCENTAGE",
    "CSS_PERSPECTIVE",
    "CSS_PRIMITIVE_VALUE",
    "CSS_PT",
    "CSS_PX",
    "CSS_RAD",
    "CSS_RECT",
    "CSS_RGBCOLOR",
    "CSS_ROTATE",
    "CSS_ROTATE3D",
    "CSS_ROTATEX",
    "CSS_ROTATEY",
    "CSS_ROTATEZ",
    "CSS_S",
    "CSS_SCALE",
    "CSS_SCALE3D",
    "CSS_SCALEX",
    "CSS_SCALEY",
    "CSS_SCALEZ",
    "CSS_SKEW",
    "CSS_SKEWX",
    "CSS_SKEWY",
    "CSS_STRING",
    "CSS_TRANSLATE",
    "CSS_TRANSLATE3D",
    "CSS_TRANSLATEX",
    "CSS_TRANSLATEY",
    "CSS_TRANSLATEZ",
    "CSS_UNKNOWN",
    "CSS_URI",
    "CSS_VALUE_LIST",
    "CSS_VH",
    "CSS_VMAX",
    "CSS_VMIN",
    "CSS_VW",
    "CULL_FACE",
    "CULL_FACE_MODE",
    "CURRENT_PROGRAM",
    "CURRENT_QUERY",
    "CURRENT_VERTEX_ATTRIB",
    "CUSTOM",
    "CW",
    "Cache",
    "CacheStorage",
    "CanvasCaptureMediaStream",
    "CanvasCaptureMediaStreamTrack",
    "CanvasGradient",
    "CanvasPattern",
    "CanvasRenderingContext2D",
    "CaptureController",
    "CaretPosition",
    "ChannelMergerNode",
    "ChannelSplitterNode",
    "ChapterInformation",
    "CharacterBoundsUpdateEvent",
    "CharacterData",
    "ClientRect",
    "ClientRectList",
    "Clipboard",
    "ClipboardEvent",
    "ClipboardItem",
    "CloseEvent",
    "CloseWatcher",
    "Collator",
    "ColorArray",
    "ColorValue",
    "CommandEvent",
    "Comment",
    "CompileError",
    "CompositionEvent",
    "CompressionStream",
    "Console",
    "ConstantSourceNode",
    "ContentVisibilityAutoStateChangeEvent",
    "ContextFilter",
    "ContextType",
    "Controllers",
    "ConvolverNode",
    "CookieChangeEvent",
    "CookieStore",
    "CookieStoreManager",
    "CountQueuingStrategy",
    "Counter",
    "CreateType",
    "Credential",
    "CredentialsContainer",
    "CropTarget",
    "Crypto",
    "CryptoKey",
    "CustomElementRegistry",
    "CustomEvent",
    "CustomStateSet",
    "DATABASE_ERR",
    "DATA_CLONE_ERR",
    "DATA_ERR",
    "DBLCLICK",
    "DECR",
    "DECR_WRAP",
    "DELETE_STATUS",
    "DEPTH",
    "DEPTH24_STENCIL8",
    "DEPTH32F_STENCIL8",
    "DEPTH_ATTACHMENT",
    "DEPTH_BITS",
    "DEPTH_BUFFER_BIT",
    "DEPTH_CLEAR_VALUE",
    "DEPTH_COMPONENT",
    "DEPTH_COMPONENT16",
    "DEPTH_COMPONENT24",
    "DEPTH_COMPONENT32F",
    "DEPTH_FUNC",
    "DEPTH_RANGE",
    "DEPTH_STENCIL",
    "DEPTH_STENCIL_ATTACHMENT",
    "DEPTH_TEST",
    "DEPTH_WRITEMASK",
    "DEVICE_INELIGIBLE",
    "DIRECTION_DOWN",
    "DIRECTION_LEFT",
    "DIRECTION_RIGHT",
    "DIRECTION_UP",
    "DISABLED",
    "DISPATCH_REQUEST_ERR",
    "DITHER",
    "DOCUMENT_FRAGMENT_NODE",
    "DOCUMENT_NODE",
    "DOCUMENT_POSITION_CONTAINED_BY",
    "DOCUMENT_POSITION_CONTAINS",
    "DOCUMENT_POSITION_DISCONNECTED",
    "DOCUMENT_POSITION_FOLLOWING",
    "DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC",
    "DOCUMENT_POSITION_PRECEDING",
    "DOCUMENT_TYPE_NODE",
    "DOMCursor",
    "DOMError",
    "DOMException",
    "DOMImplementation",
    "DOMImplementationLS",
    "DOMMatrix",
    "DOMMatrixReadOnly",
    "DOMParser",
    "DOMPoint",
    "DOMPointReadOnly",
    "DOMQuad",
    "DOMRect",
    "DOMRectList",
    "DOMRectReadOnly",
    "DOMRequest",
    "DOMSTRING_SIZE_ERR",
    "DOMSettableTokenList",
    "DOMStringList",
    "DOMStringMap",
    "DOMTokenList",
    "DOMTransactionEvent",
    "DOM_DELTA_LINE",
    "DOM_DELTA_PAGE",
    "DOM_DELTA_PIXEL",
    "DOM_INPUT_METHOD_DROP",
    "DOM_INPUT_METHOD_HANDWRITING",
    "DOM_INPUT_METHOD_IME",
    "DOM_INPUT_METHOD_KEYBOARD",
    "DOM_INPUT_METHOD_MULTIMODAL",
    "DOM_INPUT_METHOD_OPTION",
    "DOM_INPUT_METHOD_PASTE",
    "DOM_INPUT_METHOD_SCRIPT",
    "DOM_INPUT_METHOD_UNKNOWN",
    "DOM_INPUT_METHOD_VOICE",
    "DOM_KEY_LOCATION_JOYSTICK",
    "DOM_KEY_LOCATION_LEFT",
    "DOM_KEY_LOCATION_MOBILE",
    "DOM_KEY_LOCATION_NUMPAD",
    "DOM_KEY_LOCATION_RIGHT",
    "DOM_KEY_LOCATION_STANDARD",
    "DOM_VK_0",
    "DOM_VK_1",
    "DOM_VK_2",
    "DOM_VK_3",
    "DOM_VK_4",
    "DOM_VK_5",
    "DOM_VK_6",
    "DOM_VK_7",
    "DOM_VK_8",
    "DOM_VK_9",
    "DOM_VK_A",
    "DOM_VK_ACCEPT",
    "DOM_VK_ADD",
    "DOM_VK_ALT",
    "DOM_VK_ALTGR",
    "DOM_VK_AMPERSAND",
    "DOM_VK_ASTERISK",
    "DOM_VK_AT",
    "DOM_VK_ATTN",
    "DOM_VK_B",
    "DOM_VK_BACKSPACE",
    "DOM_VK_BACK_QUOTE",
    "DOM_VK_BACK_SLASH",
    "DOM_VK_BACK_SPACE",
    "DOM_VK_C",
    "DOM_VK_CANCEL",
    "DOM_VK_CAPS_LOCK",
    "DOM_VK_CIRCUMFLEX",
    "DOM_VK_CLEAR",
    "DOM_VK_CLOSE_BRACKET",
    "DOM_VK_CLOSE_CURLY_BRACKET",
    "DOM_VK_CLOSE_PAREN",
    "DOM_VK_COLON",
    "DOM_VK_COMMA",
    "DOM_VK_CONTEXT_MENU",
    "DOM_VK_CONTROL",
    "DOM_VK_CONVERT",
    "DOM_VK_CRSEL",
    "DOM_VK_CTRL",
    "DOM_VK_D",
    "DOM_VK_DECIMAL",
    "DOM_VK_DELETE",
    "DOM_VK_DIVIDE",
    "DOM_VK_DOLLAR",
    "DOM_VK_DOUBLE_QUOTE",
    "DOM_VK_DOWN",
    "DOM_VK_E",
    "DOM_VK_EISU",
    "DOM_VK_END",
    "DOM_VK_ENTER",
    "DOM_VK_EQUALS",
    "DOM_VK_EREOF",
    "DOM_VK_ESCAPE",
    "DOM_VK_EXCLAMATION",
    "DOM_VK_EXECUTE",
    "DOM_VK_EXSEL",
    "DOM_VK_F",
    "DOM_VK_F1",
    "DOM_VK_F10",
    "DOM_VK_F11",
    "DOM_VK_F12",
    "DOM_VK_F13",
    "DOM_VK_F14",
    "DOM_VK_F15",
    "DOM_VK_F16",
    "DOM_VK_F17",
    "DOM_VK_F18",
    "DOM_VK_F19",
    "DOM_VK_F2",
    "DOM_VK_F20",
    "DOM_VK_F21",
    "DOM_VK_F22",
    "DOM_VK_F23",
    "DOM_VK_F24",
    "DOM_VK_F25",
    "DOM_VK_F26",
    "DOM_VK_F27",
    "DOM_VK_F28",
    "DOM_VK_F29",
    "DOM_VK_F3",
    "DOM_VK_F30",
    "DOM_VK_F31",
    "DOM_VK_F32",
    "DOM_VK_F33",
    "DOM_VK_F34",
    "DOM_VK_F35",
    "DOM_VK_F36",
    "DOM_VK_F4",
    "DOM_VK_F5",
    "DOM_VK_F6",
    "DOM_VK_F7",
    "DOM_VK_F8",
    "DOM_VK_F9",
    "DOM_VK_FINAL",
    "DOM_VK_FRONT",
    "DOM_VK_G",
    "DOM_VK_GREATER_THAN",
    "DOM_VK_H",
    "DOM_VK_HANGUL",
    "DOM_VK_HANJA",
    "DOM_VK_HASH",
    "DOM_VK_HELP",
    "DOM_VK_HK_TOGGLE",
    "DOM_VK_HOME",
    "DOM_VK_HYPHEN_MINUS",
    "DOM_VK_I",
    "DOM_VK_INSERT",
    "DOM_VK_J",
    "DOM_VK_JUNJA",
    "DOM_VK_K",
    "DOM_VK_KANA",
    "DOM_VK_KANJI",
    "DOM_VK_L",
    "DOM_VK_LEFT",
    "DOM_VK_LEFT_TAB",
    "DOM_VK_LESS_THAN",
    "DOM_VK_M",
    "DOM_VK_META",
    "DOM_VK_MODECHANGE",
    "DOM_VK_MULTIPLY",
    "DOM_VK_N",
    "DOM_VK_NONCONVERT",
    "DOM_VK_NUMPAD0",
    "DOM_VK_NUMPAD1",
    "DOM_VK_NUMPAD2",
    "DOM_VK_NUMPAD3",
    "DOM_VK_NUMPAD4",
    "DOM_VK_NUMPAD5",
    "DOM_VK_NUMPAD6",
    "DOM_VK_NUMPAD7",
    "DOM_VK_NUMPAD8",
    "DOM_VK_NUMPAD9",
    "DOM_VK_NUM_LOCK",
    "DOM_VK_O",
    "DOM_VK_OEM_1",
    "DOM_VK_OEM_102",
    "DOM_VK_OEM_2",
    "DOM_VK_OEM_3",
    "DOM_VK_OEM_4",
    "DOM_VK_OEM_5",
    "DOM_VK_OEM_6",
    "DOM_VK_OEM_7",
    "DOM_VK_OEM_8",
    "DOM_VK_OEM_COMMA",
    "DOM_VK_OEM_MINUS",
    "DOM_VK_OEM_PERIOD",
    "DOM_VK_OEM_PLUS",
    "DOM_VK_OPEN_BRACKET",
    "DOM_VK_OPEN_CURLY_BRACKET",
    "DOM_VK_OPEN_PAREN",
    "DOM_VK_P",
    "DOM_VK_PA1",
    "DOM_VK_PAGEDOWN",
    "DOM_VK_PAGEUP",
    "DOM_VK_PAGE_DOWN",
    "DOM_VK_PAGE_UP",
    "DOM_VK_PAUSE",
    "DOM_VK_PERCENT",
    "DOM_VK_PERIOD",
    "DOM_VK_PIPE",
    "DOM_VK_PLAY",
    "DOM_VK_PLUS",
    "DOM_VK_PRINT",
    "DOM_VK_PRINTSCREEN",
    "DOM_VK_PROCESSKEY",
    "DOM_VK_PROPERITES",
    "DOM_VK_Q",
    "DOM_VK_QUESTION_MARK",
    "DOM_VK_QUOTE",
    "DOM_VK_R",
    "DOM_VK_REDO",
    "DOM_VK_RETURN",
    "DOM_VK_RIGHT",
    "DOM_VK_S",
    "DOM_VK_SCROLL_LOCK",
    "DOM_VK_SELECT",
    "DOM_VK_SEMICOLON",
    "DOM_VK_SEPARATOR",
    "DOM_VK_SHIFT",
    "DOM_VK_SLASH",
    "DOM_VK_SLEEP",
    "DOM_VK_SPACE",
    "DOM_VK_SUBTRACT",
    "DOM_VK_T",
    "DOM_VK_TAB",
    "DOM_VK_TILDE",
    "DOM_VK_U",
    "DOM_VK_UNDERSCORE",
    "DOM_VK_UNDO",
    "DOM_VK_UNICODE",
    "DOM_VK_UP",
    "DOM_VK_V",
    "DOM_VK_VOLUME_DOWN",
    "DOM_VK_VOLUME_MUTE",
    "DOM_VK_VOLUME_UP",
    "DOM_VK_W",
    "DOM_VK_WIN",
    "DOM_VK_WINDOW",
    "DOM_VK_WIN_ICO_00",
    "DOM_VK_WIN_ICO_CLEAR",
    "DOM_VK_WIN_ICO_HELP",
    "DOM_VK_WIN_OEM_ATTN",
    "DOM_VK_WIN_OEM_AUTO",
    "DOM_VK_WIN_OEM_BACKTAB",
    "DOM_VK_WIN_OEM_CLEAR",
    "DOM_VK_WIN_OEM_COPY",
    "DOM_VK_WIN_OEM_CUSEL",
    "DOM_VK_WIN_OEM_ENLW",
    "DOM_VK_WIN_OEM_FINISH",
    "DOM_VK_WIN_OEM_FJ_JISHO",
    "DOM_VK_WIN_OEM_FJ_LOYA",
    "DOM_VK_WIN_OEM_FJ_MASSHOU",
    "DOM_VK_WIN_OEM_FJ_ROYA",
    "DOM_VK_WIN_OEM_FJ_TOUROKU",
    "DOM_VK_WIN_OEM_JUMP",
    "DOM_VK_WIN_OEM_PA1",
    "DOM_VK_WIN_OEM_PA2",
    "DOM_VK_WIN_OEM_PA3",
    "DOM_VK_WIN_OEM_RESET",
    "DOM_VK_WIN_OEM_WSCTRL",
    "DOM_VK_X",
    "DOM_VK_XF86XK_ADD_FAVORITE",
    "DOM_VK_XF86XK_APPLICATION_LEFT",
    "DOM_VK_XF86XK_APPLICATION_RIGHT",
    "DOM_VK_XF86XK_AUDIO_CYCLE_TRACK",
    "DOM_VK_XF86XK_AUDIO_FORWARD",
    "DOM_VK_XF86XK_AUDIO_LOWER_VOLUME",
    "DOM_VK_XF86XK_AUDIO_MEDIA",
    "DOM_VK_XF86XK_AUDIO_MUTE",
    "DOM_VK_XF86XK_AUDIO_NEXT",
    "DOM_VK_XF86XK_AUDIO_PAUSE",
    "DOM_VK_XF86XK_AUDIO_PLAY",
    "DOM_VK_XF86XK_AUDIO_PREV",
    "DOM_VK_XF86XK_AUDIO_RAISE_VOLUME",
    "DOM_VK_XF86XK_AUDIO_RANDOM_PLAY",
    "DOM_VK_XF86XK_AUDIO_RECORD",
    "DOM_VK_XF86XK_AUDIO_REPEAT",
    "DOM_VK_XF86XK_AUDIO_REWIND",
    "DOM_VK_XF86XK_AUDIO_STOP",
    "DOM_VK_XF86XK_AWAY",
    "DOM_VK_XF86XK_BACK",
    "DOM_VK_XF86XK_BACK_FORWARD",
    "DOM_VK_XF86XK_BATTERY",
    "DOM_VK_XF86XK_BLUE",
    "DOM_VK_XF86XK_BLUETOOTH",
    "DOM_VK_XF86XK_BOOK",
    "DOM_VK_XF86XK_BRIGHTNESS_ADJUST",
    "DOM_VK_XF86XK_CALCULATOR",
    "DOM_VK_XF86XK_CALENDAR",
    "DOM_VK_XF86XK_CD",
    "DOM_VK_XF86XK_CLOSE",
    "DOM_VK_XF86XK_COMMUNITY",
    "DOM_VK_XF86XK_CONTRAST_ADJUST",
    "DOM_VK_XF86XK_COPY",
    "DOM_VK_XF86XK_CUT",
    "DOM_VK_XF86XK_CYCLE_ANGLE",
    "DOM_VK_XF86XK_DISPLAY",
    "DOM_VK_XF86XK_DOCUMENTS",
    "DOM_VK_XF86XK_DOS",
    "DOM_VK_XF86XK_EJECT",
    "DOM_VK_XF86XK_EXCEL",
    "DOM_VK_XF86XK_EXPLORER",
    "DOM_VK_XF86XK_FAVORITES",
    "DOM_VK_XF86XK_FINANCE",
    "DOM_VK_XF86XK_FORWARD",
    "DOM_VK_XF86XK_FRAME_BACK",
    "DOM_VK_XF86XK_FRAME_FORWARD",
    "DOM_VK_XF86XK_GAME",
    "DOM_VK_XF86XK_GO",
    "DOM_VK_XF86XK_GREEN",
    "DOM_VK_XF86XK_HIBERNATE",
    "DOM_VK_XF86XK_HISTORY",
    "DOM_VK_XF86XK_HOME_PAGE",
    "DOM_VK_XF86XK_HOT_LINKS",
    "DOM_VK_XF86XK_I_TOUCH",
    "DOM_VK_XF86XK_KBD_BRIGHTNESS_DOWN",
    "DOM_VK_XF86XK_KBD_BRIGHTNESS_UP",
    "DOM_VK_XF86XK_KBD_LIGHT_ON_OFF",
    "DOM_VK_XF86XK_LAUNCH0",
    "DOM_VK_XF86XK_LAUNCH1",
    "DOM_VK_XF86XK_LAUNCH2",
    "DOM_VK_XF86XK_LAUNCH3",
    "DOM_VK_XF86XK_LAUNCH4",
    "DOM_VK_XF86XK_LAUNCH5",
    "DOM_VK_XF86XK_LAUNCH6",
    "DOM_VK_XF86XK_LAUNCH7",
    "DOM_VK_XF86XK_LAUNCH8",
    "DOM_VK_XF86XK_LAUNCH9",
    "DOM_VK_XF86XK_LAUNCH_A",
    "DOM_VK_XF86XK_LAUNCH_B",
    "DOM_VK_XF86XK_LAUNCH_C",
    "DOM_VK_XF86XK_LAUNCH_D",
    "DOM_VK_XF86XK_LAUNCH_E",
    "DOM_VK_XF86XK_LAUNCH_F",
    "DOM_VK_XF86XK_LIGHT_BULB",
    "DOM_VK_XF86XK_LOG_OFF",
    "DOM_VK_XF86XK_MAIL",
    "DOM_VK_XF86XK_MAIL_FORWARD",
    "DOM_VK_XF86XK_MARKET",
    "DOM_VK_XF86XK_MEETING",
    "DOM_VK_XF86XK_MEMO",
    "DOM_VK_XF86XK_MENU_KB",
    "DOM_VK_XF86XK_MENU_PB",
    "DOM_VK_XF86XK_MESSENGER",
    "DOM_VK_XF86XK_MON_BRIGHTNESS_DOWN",
    "DOM_VK_XF86XK_MON_BRIGHTNESS_UP",
    "DOM_VK_XF86XK_MUSIC",
    "DOM_VK_XF86XK_MY_COMPUTER",
    "DOM_VK_XF86XK_MY_SITES",
    "DOM_VK_XF86XK_NEW",
    "DOM_VK_XF86XK_NEWS",
    "DOM_VK_XF86XK_OFFICE_HOME",
    "DOM_VK_XF86XK_OPEN",
    "DOM_VK_XF86XK_OPEN_URL",
    "DOM_VK_XF86XK_OPTION",
    "DOM_VK_XF86XK_PASTE",
    "DOM_VK_XF86XK_PHONE",
    "DOM_VK_XF86XK_PICTURES",
    "DOM_VK_XF86XK_POWER_DOWN",
    "DOM_VK_XF86XK_POWER_OFF",
    "DOM_VK_XF86XK_RED",
    "DOM_VK_XF86XK_REFRESH",
    "DOM_VK_XF86XK_RELOAD",
    "DOM_VK_XF86XK_REPLY",
    "DOM_VK_XF86XK_ROCKER_DOWN",
    "DOM_VK_XF86XK_ROCKER_ENTER",
    "DOM_VK_XF86XK_ROCKER_UP",
    "DOM_VK_XF86XK_ROTATE_WINDOWS",
    "DOM_VK_XF86XK_ROTATION_KB",
    "DOM_VK_XF86XK_ROTATION_PB",
    "DOM_VK_XF86XK_SAVE",
    "DOM_VK_XF86XK_SCREEN_SAVER",
    "DOM_VK_XF86XK_SCROLL_CLICK",
    "DOM_VK_XF86XK_SCROLL_DOWN",
    "DOM_VK_XF86XK_SCROLL_UP",
    "DOM_VK_XF86XK_SEARCH",
    "DOM_VK_XF86XK_SEND",
    "DOM_VK_XF86XK_SHOP",
    "DOM_VK_XF86XK_SPELL",
    "DOM_VK_XF86XK_SPLIT_SCREEN",
    "DOM_VK_XF86XK_STANDBY",
    "DOM_VK_XF86XK_START",
    "DOM_VK_XF86XK_STOP",
    "DOM_VK_XF86XK_SUBTITLE",
    "DOM_VK_XF86XK_SUPPORT",
    "DOM_VK_XF86XK_SUSPEND",
    "DOM_VK_XF86XK_TASK_PANE",
    "DOM_VK_XF86XK_TERMINAL",
    "DOM_VK_XF86XK_TIME",
    "DOM_VK_XF86XK_TOOLS",
    "DOM_VK_XF86XK_TOP_MENU",
    "DOM_VK_XF86XK_TO_DO_LIST",
    "DOM_VK_XF86XK_TRAVEL",
    "DOM_VK_XF86XK_USER1KB",
    "DOM_VK_XF86XK_USER2KB",
    "DOM_VK_XF86XK_USER_PB",
    "DOM_VK_XF86XK_UWB",
    "DOM_VK_XF86XK_VENDOR_HOME",
    "DOM_VK_XF86XK_VIDEO",
    "DOM_VK_XF86XK_VIEW",
    "DOM_VK_XF86XK_WAKE_UP",
    "DOM_VK_XF86XK_WEB_CAM",
    "DOM_VK_XF86XK_WHEEL_BUTTON",
    "DOM_VK_XF86XK_WLAN",
    "DOM_VK_XF86XK_WORD",
    "DOM_VK_XF86XK_WWW",
    "DOM_VK_XF86XK_XFER",
    "DOM_VK_XF86XK_YELLOW",
    "DOM_VK_XF86XK_ZOOM_IN",
    "DOM_VK_XF86XK_ZOOM_OUT",
    "DOM_VK_Y",
    "DOM_VK_Z",
    "DOM_VK_ZOOM",
    "DONE",
    "DONT_CARE",
    "DOWNLOADING",
    "DRAGDROP",
    "DRAW_BUFFER0",
    "DRAW_BUFFER1",
    "DRAW_BUFFER10",
    "DRAW_BUFFER11",
    "DRAW_BUFFER12",
    "DRAW_BUFFER13",
    "DRAW_BUFFER14",
    "DRAW_BUFFER15",
    "DRAW_BUFFER2",
    "DRAW_BUFFER3",
    "DRAW_BUFFER4",
    "DRAW_BUFFER5",
    "DRAW_BUFFER6",
    "DRAW_BUFFER7",
    "DRAW_BUFFER8",
    "DRAW_BUFFER9",
    "DRAW_FRAMEBUFFER",
    "DRAW_FRAMEBUFFER_BINDING",
    "DST_ALPHA",
    "DST_COLOR",
    "DYNAMIC_COPY",
    "DYNAMIC_DRAW",
    "DYNAMIC_READ",
    "DataChannel",
    "DataTransfer",
    "DataTransferItem",
    "DataTransferItemList",
    "DataView",
    "Date",
    "DateTimeFormat",
    "DecompressionStream",
    "DelayNode",
    "DelegatedInkTrailPresenter",
    "DeprecationReportBody",
    "DesktopNotification",
    "DesktopNotificationCenter",
    "Details",
    "DeviceLightEvent",
    "DeviceMotionEvent",
    "DeviceMotionEventAcceleration",
    "DeviceMotionEventRotationRate",
    "DeviceOrientationEvent",
    "DeviceProximityEvent",
    "DeviceStorage",
    "DeviceStorageChangeEvent",
    "Directory",
    "DisplayNames",
    "Document",
    "DocumentFragment",
    "DocumentPictureInPicture",
    "DocumentPictureInPictureEvent",
    "DocumentTimeline",
    "DocumentType",
    "DragEvent",
    "DurationFormat",
    "DynamicsCompressorNode",
    "E",
    "ELEMENT_ARRAY_BUFFER",
    "ELEMENT_ARRAY_BUFFER_BINDING",
    "ELEMENT_NODE",
    "EMPTY",
    "ENCODING_ERR",
    "ENDED",
    "END_TO_END",
    "END_TO_START",
    "ENTITY_NODE",
    "ENTITY_REFERENCE_NODE",
    "EPSILON",
    "EQUAL",
    "EQUALPOWER",
    "ERROR",
    "EXPONENTIAL_DISTANCE",
    "EditContext",
    "Element",
    "ElementInternals",
    "ElementQuery",
    "EncodedAudioChunk",
    "EncodedVideoChunk",
    "EnterPictureInPictureEvent",
    "Entity",
    "EntityReference",
    "Error",
    "ErrorEvent",
    "EvalError",
    "Event",
    "EventCounts",
    "EventException",
    "EventSource",
    "EventTarget",
    "Exception",
    "ExtensionContext",
    "ExtensionDisabledReason",
    "ExtensionInfo",
    "ExtensionInstallType",
    "ExtensionType",
    "External",
    "EyeDropper",
    "FASTEST",
    "FIDOSDK",
    "FILTER_ACCEPT",
    "FILTER_INTERRUPT",
    "FILTER_REJECT",
    "FILTER_SKIP",
    "FINISHED_STATE",
    "FIRST_ORDERED_NODE_TYPE",
    "FLOAT",
    "FLOAT_32_UNSIGNED_INT_24_8_REV",
    "FLOAT_MAT2",
    "FLOAT_MAT2x3",
    "FLOAT_MAT2x4",
    "FLOAT_MAT3",
    "FLOAT_MAT3x2",
    "FLOAT_MAT3x4",
    "FLOAT_MAT4",
    "FLOAT_MAT4x2",
    "FLOAT_MAT4x3",
    "FLOAT_VEC2",
    "FLOAT_VEC3",
    "FLOAT_VEC4",
    "FOCUS",
    "FONT_FACE_RULE",
    "FONT_FEATURE_VALUES_RULE",
    "FRAGMENT",
    "FRAGMENT_SHADER",
    "FRAGMENT_SHADER_DERIVATIVE_HINT",
    "FRAGMENT_SHADER_DERIVATIVE_HINT_OES",
    "FRAMEBUFFER",
    "FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE",
    "FRAMEBUFFER_ATTACHMENT_BLUE_SIZE",
    "FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING",
    "FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE",
    "FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE",
    "FRAMEBUFFER_ATTACHMENT_GREEN_SIZE",
    "FRAMEBUFFER_ATTACHMENT_OBJECT_NAME",
    "FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE",
    "FRAMEBUFFER_ATTACHMENT_RED_SIZE",
    "FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE",
    "FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE",
    "FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER",
    "FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL",
    "FRAMEBUFFER_BINDING",
    "FRAMEBUFFER_COMPLETE",
    "FRAMEBUFFER_DEFAULT",
    "FRAMEBUFFER_INCOMPLETE_ATTACHMENT",
    "FRAMEBUFFER_INCOMPLETE_DIMENSIONS",
    "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT",
    "FRAMEBUFFER_INCOMPLETE_MULTISAMPLE",
    "FRAMEBUFFER_UNSUPPORTED",
    "FRONT",
    "FRONT_AND_BACK",
    "FRONT_FACE",
    "FUNC_ADD",
    "FUNC_REVERSE_SUBTRACT",
    "FUNC_SUBTRACT",
    "FeaturePolicy",
    "FeaturePolicyViolationReportBody",
    "FederatedCredential",
    "Feed",
    "FeedEntry",
    "Fence",
    "FencedFrameConfig",
    "File",
    "FileError",
    "FileList",
    "FileReader",
    "FileSystem",
    "FileSystemDirectoryEntry",
    "FileSystemDirectoryHandle",
    "FileSystemDirectoryReader",
    "FileSystemEntry",
    "FileSystemFileEntry",
    "FileSystemFileHandle",
    "FileSystemHandle",
    "FileSystemWritableFileStream",
    "FinalizationRegistry",
    "FindInPage",
    "Float16Array",
    "Float32Array",
    "Float64Array",
    "FocusEvent",
    "FontData",
    "FontFace",
    "FontFaceSet",
    "FontFaceSetLoadEvent",
    "FormData",
    "FormDataEvent",
    "FragmentDirective",
    "Function",
    "GENERATE_MIPMAP_HINT",
    "GEQUAL",
    "GPU",
    "GPUAdapter",
    "GPUAdapterInfo",
    "GPUBindGroup",
    "GPUBindGroupLayout",
    "GPUBuffer",
    "GPUBufferUsage",
    "GPUCanvasContext",
    "GPUColorWrite",
    "GPUCommandBuffer",
    "GPUCommandEncoder",
    "GPUCompilationInfo",
    "GPUCompilationMessage",
    "GPUComputePassEncoder",
    "GPUComputePipeline",
    "GPUDevice",
    "GPUDeviceLostInfo",
    "GPUError",
    "GPUExternalTexture",
    "GPUInternalError",
    "GPUMapMode",
    "GPUOutOfMemoryError",
    "GPUPipelineError",
    "GPUPipelineLayout",
    "GPUQuerySet",
    "GPUQueue",
    "GPURenderBundle",
    "GPURenderBundleEncoder",
    "GPURenderPassEncoder",
    "GPURenderPipeline",
    "GPUSampler",
    "GPUShaderModule",
    "GPUShaderStage",
    "GPUSupportedFeatures",
    "GPUSupportedLimits",
    "GPUTexture",
    "GPUTextureUsage",
    "GPUTextureView",
    "GPUUncapturedErrorEvent",
    "GPUValidationError",
    "GREATER",
    "GREEN",
    "GREEN_BITS",
    "GainNode",
    "Gamepad",
    "GamepadAxisMoveEvent",
    "GamepadButton",
    "GamepadButtonEvent",
    "GamepadEvent",
    "GamepadHapticActuator",
    "GamepadPose",
    "Geolocation",
    "GeolocationCoordinates",
    "GeolocationPosition",
    "GeolocationPositionError",
    "GestureEvent",
    "GetInfo",
    "Global",
    "GravitySensor",
    "Gyroscope",
    "HALF_FLOAT",
    "HAVE_CURRENT_DATA",
    "HAVE_ENOUGH_DATA",
    "HAVE_FUTURE_DATA",
    "HAVE_METADATA",
    "HAVE_NOTHING",
    "HEADERS_RECEIVED",
    "HID",
    "HIDConnectionEvent",
    "HIDDEN",
    "HIDDevice",
    "HIDInputReportEvent",
    "HIERARCHY_REQUEST_ERR",
    "HIGHPASS",
    "HIGHSHELF",
    "HIGH_FLOAT",
    "HIGH_INT",
    "HORIZONTAL",
    "HORIZONTAL_AXIS",
    "HRTF",
    "HTMLAllCollection",
    "HTMLAnchorElement",
    "HTMLAppletElement",
    "HTMLAreaElement",
    "HTMLAudioElement",
    "HTMLBRElement",
    "HTMLBaseElement",
    "HTMLBaseFontElement",
    "HTMLBlockquoteElement",
    "HTMLBodyElement",
    "HTMLButtonElement",
    "HTMLCanvasElement",
    "HTMLCollection",
    "HTMLCommandElement",
    "HTMLContentElement",
    "HTMLDListElement",
    "HTMLDataElement",
    "HTMLDataListElement",
    "HTMLDetailsElement",
    "HTMLDialogElement",
    "HTMLDirectoryElement",
    "HTMLDivElement",
    "HTMLDocument",
    "HTMLElement",
    "HTMLEmbedElement",
    "HTMLFencedFrameElement",
    "HTMLFieldSetElement",
    "HTMLFontElement",
    "HTMLFormControlsCollection",
    "HTMLFormElement",
    "HTMLFrameElement",
    "HTMLFrameSetElement",
    "HTMLHRElement",
    "HTMLHeadElement",
    "HTMLHeadingElement",
    "HTMLHtmlElement",
    "HTMLIFrameElement",
    "HTMLImageElement",
    "HTMLInputElement",
    "HTMLIsIndexElement",
    "HTMLKeygenElement",
    "HTMLLIElement",
    "HTMLLabelElement",
    "HTMLLegendElement",
    "HTMLLinkElement",
    "HTMLMapElement",
    "HTMLMarqueeElement",
    "HTMLMediaElement",
    "HTMLMenuElement",
    "HTMLMenuItemElement",
    "HTMLMetaElement",
    "HTMLMeterElement",
    "HTMLModElement",
    "HTMLOListElement",
    "HTMLObjectElement",
    "HTMLOptGroupElement",
    "HTMLOptionElement",
    "HTMLOptionsCollection",
    "HTMLOutputElement",
    "HTMLParagraphElement",
    "HTMLParamElement",
    "HTMLPictureElement",
    "HTMLPreElement",
    "HTMLProgressElement",
    "HTMLPropertiesCollection",
    "HTMLQuoteElement",
    "HTMLScriptElement",
    "HTMLSelectElement",
    "HTMLShadowElement",
    "HTMLSlotElement",
    "HTMLSourceElement",
    "HTMLSpanElement",
    "HTMLStyleElement",
    "HTMLTableCaptionElement",
    "HTMLTableCellElement",
    "HTMLTableColElement",
    "HTMLTableElement",
    "HTMLTableRowElement",
    "HTMLTableSectionElement",
    "HTMLTemplateElement",
    "HTMLTextAreaElement",
    "HTMLTimeElement",
    "HTMLTitleElement",
    "HTMLTrackElement",
    "HTMLUListElement",
    "HTMLUnknownElement",
    "HTMLVideoElement",
    "HashChangeEvent",
    "Headers",
    "Highlight",
    "HighlightRegistry",
    "History",
    "Hz",
    "ICE_CHECKING",
    "ICE_CLOSED",
    "ICE_COMPLETED",
    "ICE_CONNECTED",
    "ICE_FAILED",
    "ICE_GATHERING",
    "ICE_WAITING",
    "IDBCursor",
    "IDBCursorWithValue",
    "IDBDatabase",
    "IDBDatabaseException",
    "IDBFactory",
    "IDBFileHandle",
    "IDBFileRequest",
    "IDBIndex",
    "IDBKeyRange",
    "IDBMutableFile",
    "IDBObjectStore",
    "IDBOpenDBRequest",
    "IDBRequest",
    "IDBTransaction",
    "IDBVersionChangeEvent",
    "IDLE",
    "IIRFilterNode",
    "IMPLEMENTATION_COLOR_READ_FORMAT",
    "IMPLEMENTATION_COLOR_READ_TYPE",
    "IMPORT_RULE",
    "INCR",
    "INCR_WRAP",
    "INDEX",
    "INDEX_SIZE_ERR",
    "INDIRECT",
    "INT",
    "INTERLEAVED_ATTRIBS",
    "INT_2_10_10_10_REV",
    "INT_SAMPLER_2D",
    "INT_SAMPLER_2D_ARRAY",
    "INT_SAMPLER_3D",
    "INT_SAMPLER_CUBE",
    "INT_VEC2",
    "INT_VEC3",
    "INT_VEC4",
    "INUSE_ATTRIBUTE_ERR",
    "INVALID_ACCESS_ERR",
    "INVALID_CHARACTER_ERR",
    "INVALID_ENUM",
    "INVALID_EXPRESSION_ERR",
    "INVALID_FRAMEBUFFER_OPERATION",
    "INVALID_INDEX",
    "INVALID_MODIFICATION_ERR",
    "INVALID_NODE_TYPE_ERR",
    "INVALID_OPERATION",
    "INVALID_STATE_ERR",
    "INVALID_VALUE",
    "INVERSE_DISTANCE",
    "INVERT",
    "IceCandidate",
    "IconInfo",
    "IdentityCredential",
    "IdentityCredentialError",
    "IdentityProvider",
    "IdleDeadline",
    "IdleDetector",
    "Image",
    "ImageBitmap",
    "ImageBitmapRenderingContext",
    "ImageCapture",
    "ImageData",
    "ImageDataType",
    "ImageDecoder",
    "ImageTrack",
    "ImageTrackList",
    "Infinity",
    "Ink",
    "InputDeviceCapabilities",
    "InputDeviceInfo",
    "InputEvent",
    "InputMethodContext",
    "InstallTrigger",
    "InstallTriggerImpl",
    "Instance",
    "Int16Array",
    "Int32Array",
    "Int8Array",
    "Intent",
    "InternalError",
    "IntersectionObserver",
    "IntersectionObserverEntry",
    "Intl",
    "IsSearchProviderInstalled",
    "Iterator",
    "JSON",
    "JSTag",
    "KEEP",
    "KEYDOWN",
    "KEYFRAMES_RULE",
    "KEYFRAME_RULE",
    "KEYPRESS",
    "KEYUP",
    "KeyEvent",
    "Keyboard",
    "KeyboardEvent",
    "KeyboardLayoutMap",
    "KeyframeEffect",
    "LENGTHADJUST_SPACING",
    "LENGTHADJUST_SPACINGANDGLYPHS",
    "LENGTHADJUST_UNKNOWN",
    "LEQUAL",
    "LESS",
    "LINEAR",
    "LINEAR_DISTANCE",
    "LINEAR_MIPMAP_LINEAR",
    "LINEAR_MIPMAP_NEAREST",
    "LINES",
    "LINE_LOOP",
    "LINE_STRIP",
    "LINE_WIDTH",
    "LINK_STATUS",
    "LIVE",
    "LN10",
    "LN2",
    "LOADED",
    "LOADING",
    "LOG10E",
    "LOG2E",
    "LOWPASS",
    "LOWSHELF",
    "LOW_FLOAT",
    "LOW_INT",
    "LSException",
    "LSParserFilter",
    "LUMINANCE",
    "LUMINANCE_ALPHA",
    "LanguageCode",
    "LargestContentfulPaint",
    "LaunchParams",
    "LaunchQueue",
    "LaunchType",
    "LayoutShift",
    "LayoutShiftAttribution",
    "LinearAccelerationSensor",
    "LinkError",
    "ListFormat",
    "LocalMediaStream",
    "Locale",
    "Location",
    "Lock",
    "LockManager",
    "MAP_READ",
    "MAP_WRITE",
    "MARGIN_RULE",
    "MAX",
    "MAX_3D_TEXTURE_SIZE",
    "MAX_ARRAY_TEXTURE_LAYERS",
    "MAX_CAPTURE_VISIBLE_TAB_CALLS_PER_SECOND",
    "MAX_CLIENT_WAIT_TIMEOUT_WEBGL",
    "MAX_COLOR_ATTACHMENTS",
    "MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS",
    "MAX_COMBINED_TEXTURE_IMAGE_UNITS",
    "MAX_COMBINED_UNIFORM_BLOCKS",
    "MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS",
    "MAX_CUBE_MAP_TEXTURE_SIZE",
    "MAX_DRAW_BUFFERS",
    "MAX_ELEMENTS_INDICES",
    "MAX_ELEMENTS_VERTICES",
    "MAX_ELEMENT_INDEX",
    "MAX_FRAGMENT_INPUT_COMPONENTS",
    "MAX_FRAGMENT_UNIFORM_BLOCKS",
    "MAX_FRAGMENT_UNIFORM_COMPONENTS",
    "MAX_FRAGMENT_UNIFORM_VECTORS",
    "MAX_PROGRAM_TEXEL_OFFSET",
    "MAX_RENDERBUFFER_SIZE",
    "MAX_SAFE_INTEGER",
    "MAX_SAMPLES",
    "MAX_SERVER_WAIT_TIMEOUT",
    "MAX_TEXTURE_IMAGE_UNITS",
    "MAX_TEXTURE_LOD_BIAS",
    "MAX_TEXTURE_MAX_ANISOTROPY_EXT",
    "MAX_TEXTURE_SIZE",
    "MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS",
    "MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS",
    "MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS",
    "MAX_UNIFORM_BLOCK_SIZE",
    "MAX_UNIFORM_BUFFER_BINDINGS",
    "MAX_VALUE",
    "MAX_VARYING_COMPONENTS",
    "MAX_VARYING_VECTORS",
    "MAX_VERTEX_ATTRIBS",
    "MAX_VERTEX_OUTPUT_COMPONENTS",
    "MAX_VERTEX_TEXTURE_IMAGE_UNITS",
    "MAX_VERTEX_UNIFORM_BLOCKS",
    "MAX_VERTEX_UNIFORM_COMPONENTS",
    "MAX_VERTEX_UNIFORM_VECTORS",
    "MAX_VIEWPORT_DIMS",
    "MEDIA_ERR_ABORTED",
    "MEDIA_ERR_DECODE",
    "MEDIA_ERR_ENCRYPTED",
    "MEDIA_ERR_NETWORK",
    "MEDIA_ERR_SRC_NOT_SUPPORTED",
    "MEDIA_KEYERR_CLIENT",
    "MEDIA_KEYERR_DOMAIN",
    "MEDIA_KEYERR_HARDWARECHANGE",
    "MEDIA_KEYERR_OUTPUT",
    "MEDIA_KEYERR_SERVICE",
    "MEDIA_KEYERR_UNKNOWN",
    "MEDIA_RULE",
    "MEDIUM_FLOAT",
    "MEDIUM_INT",
    "META_MASK",
    "MIDIAccess",
    "MIDIConnectionEvent",
    "MIDIInput",
    "MIDIInputMap",
    "MIDIMessageEvent",
    "MIDIOutput",
    "MIDIOutputMap",
    "MIDIPort",
    "MIN",
    "MIN_PROGRAM_TEXEL_OFFSET",
    "MIN_SAFE_INTEGER",
    "MIN_VALUE",
    "MIRRORED_REPEAT",
    "MODE_ASYNCHRONOUS",
    "MODE_SYNCHRONOUS",
    "MODIFICATION",
    "MOUSEDOWN",
    "MOUSEDRAG",
    "MOUSEMOVE",
    "MOUSEOUT",
    "MOUSEOVER",
    "MOUSEUP",
    "MOZ_KEYFRAMES_RULE",
    "MOZ_KEYFRAME_RULE",
    "MOZ_SOURCE_CURSOR",
    "MOZ_SOURCE_ERASER",
    "MOZ_SOURCE_KEYBOARD",
    "MOZ_SOURCE_MOUSE",
    "MOZ_SOURCE_PEN",
    "MOZ_SOURCE_TOUCH",
    "MOZ_SOURCE_UNKNOWN",
    "MSGESTURE_FLAG_BEGIN",
    "MSGESTURE_FLAG_CANCEL",
    "MSGESTURE_FLAG_END",
    "MSGESTURE_FLAG_INERTIA",
    "MSGESTURE_FLAG_NONE",
    "MSPOINTER_TYPE_MOUSE",
    "MSPOINTER_TYPE_PEN",
    "MSPOINTER_TYPE_TOUCH",
    "MS_ASYNC_CALLBACK_STATUS_ASSIGN_DELEGATE",
    "MS_ASYNC_CALLBACK_STATUS_CANCEL",
    "MS_ASYNC_CALLBACK_STATUS_CHOOSEANY",
    "MS_ASYNC_CALLBACK_STATUS_ERROR",
    "MS_ASYNC_CALLBACK_STATUS_JOIN",
    "MS_ASYNC_OP_STATUS_CANCELED",
    "MS_ASYNC_OP_STATUS_ERROR",
    "MS_ASYNC_OP_STATUS_SUCCESS",
    "MS_MANIPULATION_STATE_ACTIVE",
    "MS_MANIPULATION_STATE_CANCELLED",
    "MS_MANIPULATION_STATE_COMMITTED",
    "MS_MANIPULATION_STATE_DRAGGING",
    "MS_MANIPULATION_STATE_INERTIA",
    "MS_MANIPULATION_STATE_PRESELECT",
    "MS_MANIPULATION_STATE_SELECTING",
    "MS_MANIPULATION_STATE_STOPPED",
    "MS_MEDIA_ERR_ENCRYPTED",
    "MS_MEDIA_KEYERR_CLIENT",
    "MS_MEDIA_KEYERR_DOMAIN",
    "MS_MEDIA_KEYERR_HARDWARECHANGE",
    "MS_MEDIA_KEYERR_OUTPUT",
    "MS_MEDIA_KEYERR_SERVICE",
    "MS_MEDIA_KEYERR_UNKNOWN",
    "Map",
    "Math",
    "MathMLElement",
    "MediaCapabilities",
    "MediaCapabilitiesInfo",
    "MediaController",
    "MediaDeviceInfo",
    "MediaDevices",
    "MediaElementAudioSourceNode",
    "MediaEncryptedEvent",
    "MediaError",
    "MediaKeyError",
    "MediaKeyEvent",
    "MediaKeyMessageEvent",
    "MediaKeyNeededEvent",
    "MediaKeySession",
    "MediaKeyStatusMap",
    "MediaKeySystemAccess",
    "MediaKeys",
    "MediaList",
    "MediaMetadata",
    "MediaQueryList",
    "MediaQueryListEvent",
    "MediaRecorder",
    "MediaRecorderErrorEvent",
    "MediaSession",
    "MediaSettingsRange",
    "MediaSource",
    "MediaSourceHandle",
    "MediaStream",
    "MediaStreamAudioDestinationNode",
    "MediaStreamAudioSourceNode",
    "MediaStreamEvent",
    "MediaStreamTrack",
    "MediaStreamTrackAudioSourceNode",
    "MediaStreamTrackAudioStats",
    "MediaStreamTrackEvent",
    "MediaStreamTrackGenerator",
    "MediaStreamTrackProcessor",
    "MediaStreamTrackVideoStats",
    "Memory",
    "MessageChannel",
    "MessageEvent",
    "MessagePort",
    "MessageSender",
    "Methods",
    "MimeType",
    "MimeTypeArray",
    "Module",
    "MouseEvent",
    "MouseScrollEvent",
    "MozAnimation",
    "MozAnimationDelay",
    "MozAnimationDirection",
    "MozAnimationDuration",
    "MozAnimationFillMode",
    "MozAnimationIterationCount",
    "MozAnimationName",
    "MozAnimationPlayState",
    "MozAnimationTimingFunction",
    "MozAppearance",
    "MozBackfaceVisibility",
    "MozBinding",
    "MozBorderBottomColors",
    "MozBorderEnd",
    "MozBorderEndColor",
    "MozBorderEndStyle",
    "MozBorderEndWidth",
    "MozBorderImage",
    "MozBorderLeftColors",
    "MozBorderRightColors",
    "MozBorderStart",
    "MozBorderStartColor",
    "MozBorderStartStyle",
    "MozBorderStartWidth",
    "MozBorderTopColors",
    "MozBoxAlign",
    "MozBoxDirection",
    "MozBoxFlex",
    "MozBoxOrdinalGroup",
    "MozBoxOrient",
    "MozBoxPack",
    "MozBoxSizing",
    "MozCSSKeyframeRule",
    "MozCSSKeyframesRule",
    "MozColumnCount",
    "MozColumnFill",
    "MozColumnGap",
    "MozColumnRule",
    "MozColumnRuleColor",
    "MozColumnRuleStyle",
    "MozColumnRuleWidth",
    "MozColumnWidth",
    "MozColumns",
    "MozContactChangeEvent",
    "MozFloatEdge",
    "MozFontFeatureSettings",
    "MozFontLanguageOverride",
    "MozForceBrokenImageIcon",
    "MozHyphens",
    "MozImageRegion",
    "MozMarginEnd",
    "MozMarginStart",
    "MozMmsEvent",
    "MozMmsMessage",
    "MozMobileMessageThread",
    "MozOSXFontSmoothing",
    "MozOrient",
    "MozOsxFontSmoothing",
    "MozOutlineRadius",
    "MozOutlineRadiusBottomleft",
    "MozOutlineRadiusBottomright",
    "MozOutlineRadiusTopleft",
    "MozOutlineRadiusTopright",
    "MozPaddingEnd",
    "MozPaddingStart",
    "MozPerspective",
    "MozPerspectiveOrigin",
    "MozPowerManager",
    "MozSettingsEvent",
    "MozSmsEvent",
    "MozSmsMessage",
    "MozStackSizing",
    "MozTabSize",
    "MozTextAlignLast",
    "MozTextDecorationColor",
    "MozTextDecorationLine",
    "MozTextDecorationStyle",
    "MozTextSizeAdjust",
    "MozTransform",
    "MozTransformOrigin",
    "MozTransformStyle",
    "MozTransition",
    "MozTransitionDelay",
    "MozTransitionDuration",
    "MozTransitionProperty",
    "MozTransitionTimingFunction",
    "MozUserFocus",
    "MozUserInput",
    "MozUserModify",
    "MozUserSelect",
    "MozWindowDragging",
    "MozWindowShadow",
    "MutationEvent",
    "MutationObserver",
    "MutationRecord",
    "MutedInfo",
    "MutedInfoReason",
    "NAMESPACE_ERR",
    "NAMESPACE_RULE",
    "NEAREST",
    "NEAREST_MIPMAP_LINEAR",
    "NEAREST_MIPMAP_NEAREST",
    "NEGATIVE_INFINITY",
    "NETWORK_EMPTY",
    "NETWORK_ERR",
    "NETWORK_IDLE",
    "NETWORK_LOADED",
    "NETWORK_LOADING",
    "NETWORK_NO_SOURCE",
    "NEVER",
    "NEW",
    "NEXT",
    "NEXT_NO_DUPLICATE",
    "NICEST",
    "NODE_AFTER",
    "NODE_BEFORE",
    "NODE_BEFORE_AND_AFTER",
    "NODE_INSIDE",
    "NONE",
    "NON_TRANSIENT_ERR",
    "NOTATION_NODE",
    "NOTCH",
    "NOTEQUAL",
    "NOT_ALLOWED_ERR",
    "NOT_FOUND_ERR",
    "NOT_READABLE_ERR",
    "NOT_SUPPORTED_ERR",
    "NO_DATA_ALLOWED_ERR",
    "NO_ERR",
    "NO_ERROR",
    "NO_MODIFICATION_ALLOWED_ERR",
    "NUMBER_TYPE",
    "NUM_COMPRESSED_TEXTURE_FORMATS",
    "NaN",
    "NamedNodeMap",
    "NavigateEvent",
    "Navigation",
    "NavigationActivation",
    "NavigationCurrentEntryChangeEvent",
    "NavigationDestination",
    "NavigationHistoryEntry",
    "NavigationPreloadManager",
    "NavigationTransition",
    "Navigator",
    "NavigatorLogin",
    "NavigatorManagedData",
    "NavigatorUAData",
    "NearbyLinks",
    "NetworkInformation",
    "Node",
    "NodeFilter",
    "NodeIterator",
    "NodeList",
    "NotRestoredReasonDetails",
    "NotRestoredReasons",
    "Notation",
    "Notification",
    "NotifyPaintEvent",
    "Number",
    "NumberFormat",
    "OBJECT_TYPE",
    "OBSOLETE",
    "OK",
    "ONE",
    "ONE_MINUS_CONSTANT_ALPHA",
    "ONE_MINUS_CONSTANT_COLOR",
    "ONE_MINUS_DST_ALPHA",
    "ONE_MINUS_DST_COLOR",
    "ONE_MINUS_SRC_ALPHA",
    "ONE_MINUS_SRC_COLOR",
    "OPEN",
    "OPENED",
    "OPENING",
    "ORDERED_NODE_ITERATOR_TYPE",
    "ORDERED_NODE_SNAPSHOT_TYPE",
    "OTHER_ERROR",
    "OTPCredential",
    "OUT_OF_MEMORY",
    "Object",
    "OfflineAudioCompletionEvent",
    "OfflineAudioContext",
    "OfflineResourceList",
    "OffscreenCanvas",
    "OffscreenCanvasRenderingContext2D",
    "OnClickData",
    "OnInstalledReason",
    "OnPerformanceWarningCategory",
    "OnPerformanceWarningSeverity",
    "OnRestartRequiredReason",
    "Option",
    "OrientationSensor",
    "OscillatorNode",
    "OverconstrainedError",
    "OverflowEvent",
    "PACK_ALIGNMENT",
    "PACK_ROW_LENGTH",
    "PACK_SKIP_PIXELS",
    "PACK_SKIP_ROWS",
    "PAGE_RULE",
    "PARSE_ERR",
    "PATHSEG_ARC_ABS",
    "PATHSEG_ARC_REL",
    "PATHSEG_CLOSEPATH",
    "PATHSEG_CURVETO_CUBIC_ABS",
    "PATHSEG_CURVETO_CUBIC_REL",
    "PATHSEG_CURVETO_CUBIC_SMOOTH_ABS",
    "PATHSEG_CURVETO_CUBIC_SMOOTH_REL",
    "PATHSEG_CURVETO_QUADRATIC_ABS",
    "PATHSEG_CURVETO_QUADRATIC_REL",
    "PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS",
    "PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL",
    "PATHSEG_LINETO_ABS",
    "PATHSEG_LINETO_HORIZONTAL_ABS",
    "PATHSEG_LINETO_HORIZONTAL_REL",
    "PATHSEG_LINETO_REL",
    "PATHSEG_LINETO_VERTICAL_ABS",
    "PATHSEG_LINETO_VERTICAL_REL",
    "PATHSEG_MOVETO_ABS",
    "PATHSEG_MOVETO_REL",
    "PATHSEG_UNKNOWN",
    "PATH_EXISTS_ERR",
    "PEAKING",
    "PERMISSION_DENIED",
    "PERSISTENT",
    "PI",
    "PIXEL_PACK_BUFFER",
    "PIXEL_PACK_BUFFER_BINDING",
    "PIXEL_UNPACK_BUFFER",
    "PIXEL_UNPACK_BUFFER_BINDING",
    "PLAYING_STATE",
    "POINTS",
    "POLYGON_OFFSET_FACTOR",
    "POLYGON_OFFSET_FILL",
    "POLYGON_OFFSET_UNITS",
    "POSITION_UNAVAILABLE",
    "POSITIVE_INFINITY",
    "PREV",
    "PREV_NO_DUPLICATE",
    "PROCESSING_INSTRUCTION_NODE",
    "PageChangeEvent",
    "PageRevealEvent",
    "PageSettings",
    "PageSwapEvent",
    "PageTransitionEvent",
    "PaintRequest",
    "PaintRequestList",
    "PannerNode",
    "PasswordCredential",
    "Path2D",
    "PaymentAddress",
    "PaymentInstruments",
    "PaymentManager",
    "PaymentMethodChangeEvent",
    "PaymentRequest",
    "PaymentRequestUpdateEvent",
    "PaymentResponse",
    "Performance",
    "PerformanceElementTiming",
    "PerformanceEntry",
    "PerformanceEventTiming",
    "PerformanceLongAnimationFrameTiming",
    "PerformanceLongTaskTiming",
    "PerformanceMark",
    "PerformanceMeasure",
    "PerformanceNavigation",
    "PerformanceNavigationTiming",
    "PerformanceObserver",
    "PerformanceObserverEntryList",
    "PerformancePaintTiming",
    "PerformanceResourceTiming",
    "PerformanceScriptTiming",
    "PerformanceServerTiming",
    "PerformanceTiming",
    "PeriodicSyncManager",
    "PeriodicWave",
    "PermissionStatus",
    "Permissions",
    "PhotoCapabilities",
    "PictureInPictureEvent",
    "PictureInPictureWindow",
    "PlatformArch",
    "PlatformInfo",
    "PlatformNaclArch",
    "PlatformOs",
    "Plugin",
    "PluginArray",
    "PluralRules",
    "PointerEvent",
    "PopStateEvent",
    "PopupBlockedEvent",
    "Port",
    "Presentation",
    "PresentationAvailability",
    "PresentationConnection",
    "PresentationConnectionAvailableEvent",
    "PresentationConnectionCloseEvent",
    "PresentationConnectionList",
    "PresentationReceiver",
    "PresentationRequest",
    "PressureObserver",
    "PressureRecord",
    "ProcessingInstruction",
    "Profiler",
    "ProgressEvent",
    "Promise",
    "PromiseRejectionEvent",
    "PropertyNodeList",
    "ProtectedAudience",
    "Proxy",
    "PublicKeyCredential",
    "PushManager",
    "PushSubscription",
    "PushSubscriptionOptions",
    "Q",
    "QUERY_RESOLVE",
    "QUERY_RESULT",
    "QUERY_RESULT_AVAILABLE",
    "QUOTA_ERR",
    "QUOTA_EXCEEDED_ERR",
    "QueryInterface",
    "R11F_G11F_B10F",
    "R16F",
    "R16I",
    "R16UI",
    "R32F",
    "R32I",
    "R32UI",
    "R8",
    "R8I",
    "R8UI",
    "R8_SNORM",
    "RASTERIZER_DISCARD",
    "READ",
    "READ_BUFFER",
    "READ_FRAMEBUFFER",
    "READ_FRAMEBUFFER_BINDING",
    "READ_ONLY",
    "READ_ONLY_ERR",
    "READ_WRITE",
    "RED",
    "RED_BITS",
    "RED_INTEGER",
    "REMOVAL",
    "RENDERBUFFER",
    "RENDERBUFFER_ALPHA_SIZE",
    "RENDERBUFFER_BINDING",
    "RENDERBUFFER_BLUE_SIZE",
    "RENDERBUFFER_DEPTH_SIZE",
    "RENDERBUFFER_GREEN_SIZE",
    "RENDERBUFFER_HEIGHT",
    "RENDERBUFFER_INTERNAL_FORMAT",
    "RENDERBUFFER_RED_SIZE",
    "RENDERBUFFER_SAMPLES",
    "RENDERBUFFER_STENCIL_SIZE",
    "RENDERBUFFER_WIDTH",
    "RENDERER",
    "RENDERING_INTENT_ABSOLUTE_COLORIMETRIC",
    "RENDERING_INTENT_AUTO",
    "RENDERING_INTENT_PERCEPTUAL",
    "RENDERING_INTENT_RELATIVE_COLORIMETRIC",
    "RENDERING_INTENT_SATURATION",
    "RENDERING_INTENT_UNKNOWN",
    "RENDER_ATTACHMENT",
    "REPEAT",
    "REPLACE",
    "RG",
    "RG16F",
    "RG16I",
    "RG16UI",
    "RG32F",
    "RG32I",
    "RG32UI",
    "RG8",
    "RG8I",
    "RG8UI",
    "RG8_SNORM",
    "RGB",
    "RGB10_A2",
    "RGB10_A2UI",
    "RGB16F",
    "RGB16I",
    "RGB16UI",
    "RGB32F",
    "RGB32I",
    "RGB32UI",
    "RGB565",
    "RGB5_A1",
    "RGB8",
    "RGB8I",
    "RGB8UI",
    "RGB8_SNORM",
    "RGB9_E5",
    "RGBA",
    "RGBA16F",
    "RGBA16I",
    "RGBA16UI",
    "RGBA32F",
    "RGBA32I",
    "RGBA32UI",
    "RGBA4",
    "RGBA8",
    "RGBA8I",
    "RGBA8UI",
    "RGBA8_SNORM",
    "RGBA_INTEGER",
    "RGBColor",
    "RGB_INTEGER",
    "RG_INTEGER",
    "ROTATION_CLOCKWISE",
    "ROTATION_COUNTERCLOCKWISE",
    "RTCCertificate",
    "RTCDTMFSender",
    "RTCDTMFToneChangeEvent",
    "RTCDataChannel",
    "RTCDataChannelEvent",
    "RTCDtlsTransport",
    "RTCEncodedAudioFrame",
    "RTCEncodedVideoFrame",
    "RTCError",
    "RTCErrorEvent",
    "RTCIceCandidate",
    "RTCIceTransport",
    "RTCPeerConnection",
    "RTCPeerConnectionIceErrorEvent",
    "RTCPeerConnectionIceEvent",
    "RTCRtpReceiver",
    "RTCRtpScriptTransform",
    "RTCRtpSender",
    "RTCRtpTransceiver",
    "RTCSctpTransport",
    "RTCSessionDescription",
    "RTCStatsReport",
    "RTCTrackEvent",
    "RadioNodeList",
    "Range",
    "RangeError",
    "RangeException",
    "ReadableByteStreamController",
    "ReadableStream",
    "ReadableStreamBYOBReader",
    "ReadableStreamBYOBRequest",
    "ReadableStreamDefaultController",
    "ReadableStreamDefaultReader",
    "RecordErrorEvent",
    "Rect",
    "ReferenceError",
    "Reflect",
    "RegExp",
    "RelativeOrientationSensor",
    "RelativeTimeFormat",
    "RemotePlayback",
    "Report",
    "ReportBody",
    "ReportingObserver",
    "Request",
    "RequestUpdateCheckStatus",
    "ResizeObserver",
    "ResizeObserverEntry",
    "ResizeObserverSize",
    "Response",
    "RuntimeError",
    "SAMPLER_2D",
    "SAMPLER_2D_ARRAY",
    "SAMPLER_2D_ARRAY_SHADOW",
    "SAMPLER_2D_SHADOW",
    "SAMPLER_3D",
    "SAMPLER_BINDING",
    "SAMPLER_CUBE",
    "SAMPLER_CUBE_SHADOW",
    "SAMPLES",
    "SAMPLE_ALPHA_TO_COVERAGE",
    "SAMPLE_BUFFERS",
    "SAMPLE_COVERAGE",
    "SAMPLE_COVERAGE_INVERT",
    "SAMPLE_COVERAGE_VALUE",
    "SAWTOOTH",
    "SCHEDULED_STATE",
    "SCISSOR_BOX",
    "SCISSOR_TEST",
    "SCROLL_PAGE_DOWN",
    "SCROLL_PAGE_UP",
    "SDP_ANSWER",
    "SDP_OFFER",
    "SDP_PRANSWER",
    "SECURITY_ERR",
    "SELECT",
    "SEPARATE_ATTRIBS",
    "SERIALIZE_ERR",
    "SEVERITY_ERROR",
    "SEVERITY_FATAL_ERROR",
    "SEVERITY_WARNING",
    "SHADER_COMPILER",
    "SHADER_TYPE",
    "SHADING_LANGUAGE_VERSION",
    "SHIFT_MASK",
    "SHORT",
    "SHOWING",
    "SHOW_ALL",
    "SHOW_ATTRIBUTE",
    "SHOW_CDATA_SECTION",
    "SHOW_COMMENT",
    "SHOW_DOCUMENT",
    "SHOW_DOCUMENT_FRAGMENT",
    "SHOW_DOCUMENT_TYPE",
    "SHOW_ELEMENT",
    "SHOW_ENTITY",
    "SHOW_ENTITY_REFERENCE",
    "SHOW_NOTATION",
    "SHOW_PROCESSING_INSTRUCTION",
    "SHOW_TEXT",
    "SIGNALED",
    "SIGNED_NORMALIZED",
    "SINE",
    "SOUNDFIELD",
    "SQLException",
    "SQRT1_2",
    "SQRT2",
    "SQUARE",
    "SRC_ALPHA",
    "SRC_ALPHA_SATURATE",
    "SRC_COLOR",
    "SRGB",
    "SRGB8",
    "SRGB8_ALPHA8",
    "START_TO_END",
    "START_TO_START",
    "STATIC_COPY",
    "STATIC_DRAW",
    "STATIC_READ",
    "STENCIL",
    "STENCIL_ATTACHMENT",
    "STENCIL_BACK_FAIL",
    "STENCIL_BACK_FUNC",
    "STENCIL_BACK_PASS_DEPTH_FAIL",
    "STENCIL_BACK_PASS_DEPTH_PASS",
    "STENCIL_BACK_REF",
    "STENCIL_BACK_VALUE_MASK",
    "STENCIL_BACK_WRITEMASK",
    "STENCIL_BITS",
    "STENCIL_BUFFER_BIT",
    "STENCIL_CLEAR_VALUE",
    "STENCIL_FAIL",
    "STENCIL_FUNC",
    "STENCIL_INDEX",
    "STENCIL_INDEX8",
    "STENCIL_PASS_DEPTH_FAIL",
    "STENCIL_PASS_DEPTH_PASS",
    "STENCIL_REF",
    "STENCIL_TEST",
    "STENCIL_VALUE_MASK",
    "STENCIL_WRITEMASK",
    "STORAGE",
    "STORAGE_BINDING",
    "STREAM_COPY",
    "STREAM_DRAW",
    "STREAM_READ",
    "STRING_TYPE",
    "STYLE_RULE",
    "SUBPIXEL_BITS",
    "SUPPORTS_RULE",
    "SVGAElement",
    "SVGAltGlyphDefElement",
    "SVGAltGlyphElement",
    "SVGAltGlyphItemElement",
    "SVGAngle",
    "SVGAnimateColorElement",
    "SVGAnimateElement",
    "SVGAnimateMotionElement",
    "SVGAnimateTransformElement",
    "SVGAnimatedAngle",
    "SVGAnimatedBoolean",
    "SVGAnimatedEnumeration",
    "SVGAnimatedInteger",
    "SVGAnimatedLength",
    "SVGAnimatedLengthList",
    "SVGAnimatedNumber",
    "SVGAnimatedNumberList",
    "SVGAnimatedPreserveAspectRatio",
    "SVGAnimatedRect",
    "SVGAnimatedString",
    "SVGAnimatedTransformList",
    "SVGAnimationElement",
    "SVGCircleElement",
    "SVGClipPathElement",
    "SVGColor",
    "SVGComponentTransferFunctionElement",
    "SVGCursorElement",
    "SVGDefsElement",
    "SVGDescElement",
    "SVGDiscardElement",
    "SVGDocument",
    "SVGElement",
    "SVGElementInstance",
    "SVGElementInstanceList",
    "SVGEllipseElement",
    "SVGException",
    "SVGFEBlendElement",
    "SVGFEColorMatrixElement",
    "SVGFEComponentTransferElement",
    "SVGFECompositeElement",
    "SVGFEConvolveMatrixElement",
    "SVGFEDiffuseLightingElement",
    "SVGFEDisplacementMapElement",
    "SVGFEDistantLightElement",
    "SVGFEDropShadowElement",
    "SVGFEFloodElement",
    "SVGFEFuncAElement",
    "SVGFEFuncBElement",
    "SVGFEFuncGElement",
    "SVGFEFuncRElement",
    "SVGFEGaussianBlurElement",
    "SVGFEImageElement",
    "SVGFEMergeElement",
    "SVGFEMergeNodeElement",
    "SVGFEMorphologyElement",
    "SVGFEOffsetElement",
    "SVGFEPointLightElement",
    "SVGFESpecularLightingElement",
    "SVGFESpotLightElement",
    "SVGFETileElement",
    "SVGFETurbulenceElement",
    "SVGFilterElement",
    "SVGFontElement",
    "SVGFontFaceElement",
    "SVGFontFaceFormatElement",
    "SVGFontFaceNameElement",
    "SVGFontFaceSrcElement",
    "SVGFontFaceUriElement",
    "SVGForeignObjectElement",
    "SVGGElement",
    "SVGGeometryElement",
    "SVGGlyphElement",
    "SVGGlyphRefElement",
    "SVGGradientElement",
    "SVGGraphicsElement",
    "SVGHKernElement",
    "SVGImageElement",
    "SVGLength",
    "SVGLengthList",
    "SVGLineElement",
    "SVGLinearGradientElement",
    "SVGMPathElement",
    "SVGMarkerElement",
    "SVGMaskElement",
    "SVGMatrix",
    "SVGMetadataElement",
    "SVGMissingGlyphElement",
    "SVGNumber",
    "SVGNumberList",
    "SVGPaint",
    "SVGPathElement",
    "SVGPathSeg",
    "SVGPathSegArcAbs",
    "SVGPathSegArcRel",
    "SVGPathSegClosePath",
    "SVGPathSegCurvetoCubicAbs",
    "SVGPathSegCurvetoCubicRel",
    "SVGPathSegCurvetoCubicSmoothAbs",
    "SVGPathSegCurvetoCubicSmoothRel",
    "SVGPathSegCurvetoQuadraticAbs",
    "SVGPathSegCurvetoQuadraticRel",
    "SVGPathSegCurvetoQuadraticSmoothAbs",
    "SVGPathSegCurvetoQuadraticSmoothRel",
    "SVGPathSegLinetoAbs",
    "SVGPathSegLinetoHorizontalAbs",
    "SVGPathSegLinetoHorizontalRel",
    "SVGPathSegLinetoRel",
    "SVGPathSegLinetoVerticalAbs",
    "SVGPathSegLinetoVerticalRel",
    "SVGPathSegList",
    "SVGPathSegMovetoAbs",
    "SVGPathSegMovetoRel",
    "SVGPatternElement",
    "SVGPoint",
    "SVGPointList",
    "SVGPolygonElement",
    "SVGPolylineElement",
    "SVGPreserveAspectRatio",
    "SVGRadialGradientElement",
    "SVGRect",
    "SVGRectElement",
    "SVGRenderingIntent",
    "SVGSVGElement",
    "SVGScriptElement",
    "SVGSetElement",
    "SVGStopElement",
    "SVGStringList",
    "SVGStyleElement",
    "SVGSwitchElement",
    "SVGSymbolElement",
    "SVGTRefElement",
    "SVGTSpanElement",
    "SVGTextContentElement",
    "SVGTextElement",
    "SVGTextPathElement",
    "SVGTextPositioningElement",
    "SVGTitleElement",
    "SVGTransform",
    "SVGTransformList",
    "SVGUnitTypes",
    "SVGUseElement",
    "SVGVKernElement",
    "SVGViewElement",
    "SVGViewSpec",
    "SVGZoomAndPan",
    "SVGZoomEvent",
    "SVG_ANGLETYPE_DEG",
    "SVG_ANGLETYPE_GRAD",
    "SVG_ANGLETYPE_RAD",
    "SVG_ANGLETYPE_UNKNOWN",
    "SVG_ANGLETYPE_UNSPECIFIED",
    "SVG_CHANNEL_A",
    "SVG_CHANNEL_B",
    "SVG_CHANNEL_G",
    "SVG_CHANNEL_R",
    "SVG_CHANNEL_UNKNOWN",
    "SVG_COLORTYPE_CURRENTCOLOR",
    "SVG_COLORTYPE_RGBCOLOR",
    "SVG_COLORTYPE_RGBCOLOR_ICCCOLOR",
    "SVG_COLORTYPE_UNKNOWN",
    "SVG_EDGEMODE_DUPLICATE",
    "SVG_EDGEMODE_NONE",
    "SVG_EDGEMODE_UNKNOWN",
    "SVG_EDGEMODE_WRAP",
    "SVG_FEBLEND_MODE_COLOR",
    "SVG_FEBLEND_MODE_COLOR_BURN",
    "SVG_FEBLEND_MODE_COLOR_DODGE",
    "SVG_FEBLEND_MODE_DARKEN",
    "SVG_FEBLEND_MODE_DIFFERENCE",
    "SVG_FEBLEND_MODE_EXCLUSION",
    "SVG_FEBLEND_MODE_HARD_LIGHT",
    "SVG_FEBLEND_MODE_HUE",
    "SVG_FEBLEND_MODE_LIGHTEN",
    "SVG_FEBLEND_MODE_LUMINOSITY",
    "SVG_FEBLEND_MODE_MULTIPLY",
    "SVG_FEBLEND_MODE_NORMAL",
    "SVG_FEBLEND_MODE_OVERLAY",
    "SVG_FEBLEND_MODE_SATURATION",
    "SVG_FEBLEND_MODE_SCREEN",
    "SVG_FEBLEND_MODE_SOFT_LIGHT",
    "SVG_FEBLEND_MODE_UNKNOWN",
    "SVG_FECOLORMATRIX_TYPE_HUEROTATE",
    "SVG_FECOLORMATRIX_TYPE_LUMINANCETOALPHA",
    "SVG_FECOLORMATRIX_TYPE_MATRIX",
    "SVG_FECOLORMATRIX_TYPE_SATURATE",
    "SVG_FECOLORMATRIX_TYPE_UNKNOWN",
    "SVG_FECOMPONENTTRANSFER_TYPE_DISCRETE",
    "SVG_FECOMPONENTTRANSFER_TYPE_GAMMA",
    "SVG_FECOMPONENTTRANSFER_TYPE_IDENTITY",
    "SVG_FECOMPONENTTRANSFER_TYPE_LINEAR",
    "SVG_FECOMPONENTTRANSFER_TYPE_TABLE",
    "SVG_FECOMPONENTTRANSFER_TYPE_UNKNOWN",
    "SVG_FECOMPOSITE_OPERATOR_ARITHMETIC",
    "SVG_FECOMPOSITE_OPERATOR_ATOP",
    "SVG_FECOMPOSITE_OPERATOR_IN",
    "SVG_FECOMPOSITE_OPERATOR_LIGHTER",
    "SVG_FECOMPOSITE_OPERATOR_OUT",
    "SVG_FECOMPOSITE_OPERATOR_OVER",
    "SVG_FECOMPOSITE_OPERATOR_UNKNOWN",
    "SVG_FECOMPOSITE_OPERATOR_XOR",
    "SVG_INVALID_VALUE_ERR",
    "SVG_LENGTHTYPE_CM",
    "SVG_LENGTHTYPE_EMS",
    "SVG_LENGTHTYPE_EXS",
    "SVG_LENGTHTYPE_IN",
    "SVG_LENGTHTYPE_MM",
    "SVG_LENGTHTYPE_NUMBER",
    "SVG_LENGTHTYPE_PC",
    "SVG_LENGTHTYPE_PERCENTAGE",
    "SVG_LENGTHTYPE_PT",
    "SVG_LENGTHTYPE_PX",
    "SVG_LENGTHTYPE_UNKNOWN",
    "SVG_MARKERUNITS_STROKEWIDTH",
    "SVG_MARKERUNITS_UNKNOWN",
    "SVG_MARKERUNITS_USERSPACEONUSE",
    "SVG_MARKER_ORIENT_ANGLE",
    "SVG_MARKER_ORIENT_AUTO",
    "SVG_MARKER_ORIENT_AUTO_START_REVERSE",
    "SVG_MARKER_ORIENT_UNKNOWN",
    "SVG_MASKTYPE_ALPHA",
    "SVG_MASKTYPE_LUMINANCE",
    "SVG_MATRIX_NOT_INVERTABLE",
    "SVG_MEETORSLICE_MEET",
    "SVG_MEETORSLICE_SLICE",
    "SVG_MEETORSLICE_UNKNOWN",
    "SVG_MORPHOLOGY_OPERATOR_DILATE",
    "SVG_MORPHOLOGY_OPERATOR_ERODE",
    "SVG_MORPHOLOGY_OPERATOR_UNKNOWN",
    "SVG_PAINTTYPE_CURRENTCOLOR",
    "SVG_PAINTTYPE_NONE",
    "SVG_PAINTTYPE_RGBCOLOR",
    "SVG_PAINTTYPE_RGBCOLOR_ICCCOLOR",
    "SVG_PAINTTYPE_UNKNOWN",
    "SVG_PAINTTYPE_URI",
    "SVG_PAINTTYPE_URI_CURRENTCOLOR",
    "SVG_PAINTTYPE_URI_NONE",
    "SVG_PAINTTYPE_URI_RGBCOLOR",
    "SVG_PAINTTYPE_URI_RGBCOLOR_ICCCOLOR",
    "SVG_PRESERVEASPECTRATIO_NONE",
    "SVG_PRESERVEASPECTRATIO_UNKNOWN",
    "SVG_PRESERVEASPECTRATIO_XMAXYMAX",
    "SVG_PRESERVEASPECTRATIO_XMAXYMID",
    "SVG_PRESERVEASPECTRATIO_XMAXYMIN",
    "SVG_PRESERVEASPECTRATIO_XMIDYMAX",
    "SVG_PRESERVEASPECTRATIO_XMIDYMID",
    "SVG_PRESERVEASPECTRATIO_XMIDYMIN",
    "SVG_PRESERVEASPECTRATIO_XMINYMAX",
    "SVG_PRESERVEASPECTRATIO_XMINYMID",
    "SVG_PRESERVEASPECTRATIO_XMINYMIN",
    "SVG_SPREADMETHOD_PAD",
    "SVG_SPREADMETHOD_REFLECT",
    "SVG_SPREADMETHOD_REPEAT",
    "SVG_SPREADMETHOD_UNKNOWN",
    "SVG_STITCHTYPE_NOSTITCH",
    "SVG_STITCHTYPE_STITCH",
    "SVG_STITCHTYPE_UNKNOWN",
    "SVG_TRANSFORM_MATRIX",
    "SVG_TRANSFORM_ROTATE",
    "SVG_TRANSFORM_SCALE",
    "SVG_TRANSFORM_SKEWX",
    "SVG_TRANSFORM_SKEWY",
    "SVG_TRANSFORM_TRANSLATE",
    "SVG_TRANSFORM_UNKNOWN",
    "SVG_TURBULENCE_TYPE_FRACTALNOISE",
    "SVG_TURBULENCE_TYPE_TURBULENCE",
    "SVG_TURBULENCE_TYPE_UNKNOWN",
    "SVG_UNIT_TYPE_OBJECTBOUNDINGBOX",
    "SVG_UNIT_TYPE_UNKNOWN",
    "SVG_UNIT_TYPE_USERSPACEONUSE",
    "SVG_WRONG_TYPE_ERR",
    "SVG_ZOOMANDPAN_DISABLE",
    "SVG_ZOOMANDPAN_MAGNIFY",
    "SVG_ZOOMANDPAN_UNKNOWN",
    "SYNC_CONDITION",
    "SYNC_FENCE",
    "SYNC_FLAGS",
    "SYNC_FLUSH_COMMANDS_BIT",
    "SYNC_GPU_COMMANDS_COMPLETE",
    "SYNC_STATUS",
    "SYNTAX_ERR",
    "SavedPages",
    "Scheduler",
    "Scheduling",
    "Screen",
    "ScreenDetailed",
    "ScreenDetails",
    "ScreenOrientation",
    "Script",
    "ScriptProcessorNode",
    "ScrollAreaEvent",
    "ScrollTimeline",
    "SecurityPolicyViolationEvent",
    "Segmenter",
    "Selection",
    "Sensor",
    "SensorErrorEvent",
    "Serial",
    "SerialPort",
    "ServiceWorker",
    "ServiceWorkerContainer",
    "ServiceWorkerRegistration",
    "SessionDescription",
    "Set",
    "ShadowRoot",
    "SharedArrayBuffer",
    "SharedStorage",
    "SharedStorageWorklet",
    "SharedWorker",
    "SharingState",
    "SimpleGestureEvent",
    "SnapEvent",
    "SourceBuffer",
    "SourceBufferList",
    "SpeechSynthesis",
    "SpeechSynthesisErrorEvent",
    "SpeechSynthesisEvent",
    "SpeechSynthesisUtterance",
    "SpeechSynthesisVoice",
    "StaticRange",
    "StereoPannerNode",
    "StopIteration",
    "Storage",
    "StorageBucket",
    "StorageBucketManager",
    "StorageEvent",
    "StorageManager",
    "String",
    "StructType",
    "StylePropertyMap",
    "StylePropertyMapReadOnly",
    "StyleSheet",
    "StyleSheetList",
    "SubmitEvent",
    "SubtleCrypto",
    "Symbol",
    "SyncManager",
    "SyntaxError",
    "TAB_ID_NONE",
    "TAB_INDEX_NONE",
    "TEMPORARY",
    "TEXTPATH_METHODTYPE_ALIGN",
    "TEXTPATH_METHODTYPE_STRETCH",
    "TEXTPATH_METHODTYPE_UNKNOWN",
    "TEXTPATH_SPACINGTYPE_AUTO",
    "TEXTPATH_SPACINGTYPE_EXACT",
    "TEXTPATH_SPACINGTYPE_UNKNOWN",
    "TEXTURE",
    "TEXTURE0",
    "TEXTURE1",
    "TEXTURE10",
    "TEXTURE11",
    "TEXTURE12",
    "TEXTURE13",
    "TEXTURE14",
    "TEXTURE15",
    "TEXTURE16",
    "TEXTURE17",
    "TEXTURE18",
    "TEXTURE19",
    "TEXTURE2",
    "TEXTURE20",
    "TEXTURE21",
    "TEXTURE22",
    "TEXTURE23",
    "TEXTURE24",
    "TEXTURE25",
    "TEXTURE26",
    "TEXTURE27",
    "TEXTURE28",
    "TEXTURE29",
    "TEXTURE3",
    "TEXTURE30",
    "TEXTURE31",
    "TEXTURE4",
    "TEXTURE5",
    "TEXTURE6",
    "TEXTURE7",
    "TEXTURE8",
    "TEXTURE9",
    "TEXTURE_2D",
    "TEXTURE_2D_ARRAY",
    "TEXTURE_3D",
    "TEXTURE_BASE_LEVEL",
    "TEXTURE_BINDING",
    "TEXTURE_BINDING_2D",
    "TEXTURE_BINDING_2D_ARRAY",
    "TEXTURE_BINDING_3D",
    "TEXTURE_BINDING_CUBE_MAP",
    "TEXTURE_COMPARE_FUNC",
    "TEXTURE_COMPARE_MODE",
    "TEXTURE_CUBE_MAP",
    "TEXTURE_CUBE_MAP_NEGATIVE_X",
    "TEXTURE_CUBE_MAP_NEGATIVE_Y",
    "TEXTURE_CUBE_MAP_NEGATIVE_Z",
    "TEXTURE_CUBE_MAP_POSITIVE_X",
    "TEXTURE_CUBE_MAP_POSITIVE_Y",
    "TEXTURE_CUBE_MAP_POSITIVE_Z",
    "TEXTURE_IMMUTABLE_FORMAT",
    "TEXTURE_IMMUTABLE_LEVELS",
    "TEXTURE_MAG_FILTER",
    "TEXTURE_MAX_ANISOTROPY_EXT",
    "TEXTURE_MAX_LEVEL",
    "TEXTURE_MAX_LOD",
    "TEXTURE_MIN_FILTER",
    "TEXTURE_MIN_LOD",
    "TEXTURE_WRAP_R",
    "TEXTURE_WRAP_S",
    "TEXTURE_WRAP_T",
    "TEXT_NODE",
    "TIMEOUT",
    "TIMEOUT_ERR",
    "TIMEOUT_EXPIRED",
    "TIMEOUT_IGNORED",
    "TOO_LARGE_ERR",
    "TRANSACTION_INACTIVE_ERR",
    "TRANSFORM_FEEDBACK",
    "TRANSFORM_FEEDBACK_ACTIVE",
    "TRANSFORM_FEEDBACK_BINDING",
    "TRANSFORM_FEEDBACK_BUFFER",
    "TRANSFORM_FEEDBACK_BUFFER_BINDING",
    "TRANSFORM_FEEDBACK_BUFFER_MODE",
    "TRANSFORM_FEEDBACK_BUFFER_SIZE",
    "TRANSFORM_FEEDBACK_BUFFER_START",
    "TRANSFORM_FEEDBACK_PAUSED",
    "TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN",
    "TRANSFORM_FEEDBACK_VARYINGS",
    "TRIANGLE",
    "TRIANGLES",
    "TRIANGLE_FAN",
    "TRIANGLE_STRIP",
    "TYPE_BACK_FORWARD",
    "TYPE_ERR",
    "TYPE_MISMATCH_ERR",
    "TYPE_NAVIGATE",
    "TYPE_RELOAD",
    "TYPE_RESERVED",
    "Tab",
    "TabStatus",
    "Table",
    "Tag",
    "TaskAttributionTiming",
    "TaskController",
    "TaskPriorityChangeEvent",
    "TaskSignal",
    "Text",
    "TextDecoder",
    "TextDecoderStream",
    "TextEncoder",
    "TextEncoderStream",
    "TextEvent",
    "TextFormat",
    "TextFormatUpdateEvent",
    "TextMetrics",
    "TextTrack",
    "TextTrackCue",
    "TextTrackCueList",
    "TextTrackList",
    "TextUpdateEvent",
    "TimeEvent",
    "TimeRanges",
    "ToggleEvent",
    "Touch",
    "TouchEvent",
    "TouchList",
    "TrackEvent",
    "TransformStream",
    "TransformStreamDefaultController",
    "TransitionEvent",
    "TreeWalker",
    "TrustedHTML",
    "TrustedScript",
    "TrustedScriptURL",
    "TrustedTypePolicy",
    "TrustedTypePolicyFactory",
    "TypeError",
    "TypedObject",
    "U2F",
    "UIEvent",
    "UNCACHED",
    "UNIFORM",
    "UNIFORM_ARRAY_STRIDE",
    "UNIFORM_BLOCK_ACTIVE_UNIFORMS",
    "UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES",
    "UNIFORM_BLOCK_BINDING",
    "UNIFORM_BLOCK_DATA_SIZE",
    "UNIFORM_BLOCK_INDEX",
    "UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER",
    "UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER",
    "UNIFORM_BUFFER",
    "UNIFORM_BUFFER_BINDING",
    "UNIFORM_BUFFER_OFFSET_ALIGNMENT",
    "UNIFORM_BUFFER_SIZE",
    "UNIFORM_BUFFER_START",
    "UNIFORM_IS_ROW_MAJOR",
    "UNIFORM_MATRIX_STRIDE",
    "UNIFORM_OFFSET",
    "UNIFORM_SIZE",
    "UNIFORM_TYPE",
    "UNKNOWN_ERR",
    "UNKNOWN_RULE",
    "UNMASKED_RENDERER_WEBGL",
    "UNMASKED_VENDOR_WEBGL",
    "UNORDERED_NODE_ITERATOR_TYPE",
    "UNORDERED_NODE_SNAPSHOT_TYPE",
    "UNPACK_ALIGNMENT",
    "UNPACK_COLORSPACE_CONVERSION_WEBGL",
    "UNPACK_FLIP_Y_WEBGL",
    "UNPACK_IMAGE_HEIGHT",
    "UNPACK_PREMULTIPLY_ALPHA_WEBGL",
    "UNPACK_ROW_LENGTH",
    "UNPACK_SKIP_IMAGES",
    "UNPACK_SKIP_PIXELS",
    "UNPACK_SKIP_ROWS",
    "UNSCHEDULED_STATE",
    "UNSENT",
    "UNSIGNALED",
    "UNSIGNED_BYTE",
    "UNSIGNED_INT",
    "UNSIGNED_INT_10F_11F_11F_REV",
    "UNSIGNED_INT_24_8",
    "UNSIGNED_INT_2_10_10_10_REV",
    "UNSIGNED_INT_5_9_9_9_REV",
    "UNSIGNED_INT_SAMPLER_2D",
    "UNSIGNED_INT_SAMPLER_2D_ARRAY",
    "UNSIGNED_INT_SAMPLER_3D",
    "UNSIGNED_INT_SAMPLER_CUBE",
    "UNSIGNED_INT_VEC2",
    "UNSIGNED_INT_VEC3",
    "UNSIGNED_INT_VEC4",
    "UNSIGNED_NORMALIZED",
    "UNSIGNED_SHORT",
    "UNSIGNED_SHORT_4_4_4_4",
    "UNSIGNED_SHORT_5_5_5_1",
    "UNSIGNED_SHORT_5_6_5",
    "UNSPECIFIED_EVENT_TYPE_ERR",
    "UPDATEREADY",
    "URIError",
    "URL",
    "URLPattern",
    "URLSearchParams",
    "URLUnencoded",
    "URL_MISMATCH_ERR",
    "USB",
    "USBAlternateInterface",
    "USBConfiguration",
    "USBConnectionEvent",
    "USBDevice",
    "USBEndpoint",
    "USBInTransferResult",
    "USBInterface",
    "USBIsochronousInTransferPacket",
    "USBIsochronousInTransferResult",
    "USBIsochronousOutTransferPacket",
    "USBIsochronousOutTransferResult",
    "USBOutTransferResult",
    "UTC",
    "Uint16Array",
    "Uint32Array",
    "Uint8Array",
    "Uint8ClampedArray",
    "UpdateFilter",
    "UpdatePropertyName",
    "UserActivation",
    "UserMessageHandler",
    "UserMessageHandlersNamespace",
    "UserProximityEvent",
    "VALIDATE_STATUS",
    "VALIDATION_ERR",
    "VARIABLES_RULE",
    "VENDOR",
    "VERSION",
    "VERSION_CHANGE",
    "VERSION_ERR",
    "VERTEX",
    "VERTEX_ARRAY_BINDING",
    "VERTEX_ATTRIB_ARRAY_BUFFER_BINDING",
    "VERTEX_ATTRIB_ARRAY_DIVISOR",
    "VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE",
    "VERTEX_ATTRIB_ARRAY_ENABLED",
    "VERTEX_ATTRIB_ARRAY_INTEGER",
    "VERTEX_ATTRIB_ARRAY_NORMALIZED",
    "VERTEX_ATTRIB_ARRAY_POINTER",
    "VERTEX_ATTRIB_ARRAY_SIZE",
    "VERTEX_ATTRIB_ARRAY_STRIDE",
    "VERTEX_ATTRIB_ARRAY_TYPE",
    "VERTEX_SHADER",
    "VERTICAL",
    "VERTICAL_AXIS",
    "VER_ERR",
    "VIEWPORT",
    "VIEWPORT_RULE",
    "VRDisplay",
    "VRDisplayCapabilities",
    "VRDisplayEvent",
    "VREyeParameters",
    "VRFieldOfView",
    "VRFrameData",
    "VRPose",
    "VRStageParameters",
    "VTTCue",
    "VTTRegion",
    "ValidityState",
    "VideoColorSpace",
    "VideoDecoder",
    "VideoEncoder",
    "VideoFrame",
    "VideoPlaybackQuality",
    "VideoStreamTrack",
    "ViewTimeline",
    "ViewTransition",
    "ViewTransitionTypeSet",
    "ViewType",
    "VirtualKeyboard",
    "VirtualKeyboardGeometryChangeEvent",
    "VisibilityStateEntry",
    "VisualViewport",
    "WAIT_FAILED",
    "WEBKIT_FILTER_RULE",
    "WEBKIT_KEYFRAMES_RULE",
    "WEBKIT_KEYFRAME_RULE",
    "WEBKIT_REGION_RULE",
    "WGSLLanguageFeatures",
    "WINDOW_ID_CURRENT",
    "WINDOW_ID_NONE",
    "WRITE",
    "WRONG_DOCUMENT_ERR",
    "WakeLock",
    "WakeLockSentinel",
    "WasmAnyRef",
    "WaveShaperNode",
    "WeakMap",
    "WeakRef",
    "WeakSet",
    "WebAssembly",
    "WebGL2RenderingContext",
    "WebGLActiveInfo",
    "WebGLBuffer",
    "WebGLContextEvent",
    "WebGLFramebuffer",
    "WebGLObject",
    "WebGLProgram",
    "WebGLQuery",
    "WebGLRenderbuffer",
    "WebGLRenderingContext",
    "WebGLSampler",
    "WebGLShader",
    "WebGLShaderPrecisionFormat",
    "WebGLSync",
    "WebGLTexture",
    "WebGLTransformFeedback",
    "WebGLUniformLocation",
    "WebGLVertexArray",
    "WebGLVertexArrayObject",
    "WebKitAnimationEvent",
    "WebKitBlobBuilder",
    "WebKitCSSFilterRule",
    "WebKitCSSFilterValue",
    "WebKitCSSKeyframeRule",
    "WebKitCSSKeyframesRule",
    "WebKitCSSMatrix",
    "WebKitCSSRegionRule",
    "WebKitCSSTransformValue",
    "WebKitDataCue",
    "WebKitGamepad",
    "WebKitMediaKeyError",
    "WebKitMediaKeyMessageEvent",
    "WebKitMediaKeySession",
    "WebKitMediaKeys",
    "WebKitMediaSource",
    "WebKitMutationObserver",
    "WebKitNamespace",
    "WebKitPlaybackTargetAvailabilityEvent",
    "WebKitPoint",
    "WebKitShadowRoot",
    "WebKitSourceBuffer",
    "WebKitSourceBufferList",
    "WebKitTransitionEvent",
    "WebSocket",
    "WebSocketError",
    "WebSocketStream",
    "WebTransport",
    "WebTransportBidirectionalStream",
    "WebTransportDatagramDuplexStream",
    "WebTransportError",
    "WebTransportReceiveStream",
    "WebTransportSendStream",
    "WebkitAlignContent",
    "WebkitAlignItems",
    "WebkitAlignSelf",
    "WebkitAnimation",
    "WebkitAnimationDelay",
    "WebkitAnimationDirection",
    "WebkitAnimationDuration",
    "WebkitAnimationFillMode",
    "WebkitAnimationIterationCount",
    "WebkitAnimationName",
    "WebkitAnimationPlayState",
    "WebkitAnimationTimingFunction",
    "WebkitAppearance",
    "WebkitBackfaceVisibility",
    "WebkitBackgroundClip",
    "WebkitBackgroundOrigin",
    "WebkitBackgroundSize",
    "WebkitBorderBottomLeftRadius",
    "WebkitBorderBottomRightRadius",
    "WebkitBorderImage",
    "WebkitBorderRadius",
    "WebkitBorderTopLeftRadius",
    "WebkitBorderTopRightRadius",
    "WebkitBoxAlign",
    "WebkitBoxDirection",
    "WebkitBoxFlex",
    "WebkitBoxOrdinalGroup",
    "WebkitBoxOrient",
    "WebkitBoxPack",
    "WebkitBoxShadow",
    "WebkitBoxSizing",
    "WebkitClipPath",
    "WebkitFilter",
    "WebkitFlex",
    "WebkitFlexBasis",
    "WebkitFlexDirection",
    "WebkitFlexFlow",
    "WebkitFlexGrow",
    "WebkitFlexShrink",
    "WebkitFlexWrap",
    "WebkitFontFeatureSettings",
    "WebkitJustifyContent",
    "WebkitLineClamp",
    "WebkitMask",
    "WebkitMaskClip",
    "WebkitMaskComposite",
    "WebkitMaskImage",
    "WebkitMaskOrigin",
    "WebkitMaskPosition",
    "WebkitMaskPositionX",
    "WebkitMaskPositionY",
    "WebkitMaskRepeat",
    "WebkitMaskSize",
    "WebkitOrder",
    "WebkitPerspective",
    "WebkitPerspectiveOrigin",
    "WebkitTextFillColor",
    "WebkitTextSecurity",
    "WebkitTextSizeAdjust",
    "WebkitTextStroke",
    "WebkitTextStrokeColor",
    "WebkitTextStrokeWidth",
    "WebkitTransform",
    "WebkitTransformOrigin",
    "WebkitTransformStyle",
    "WebkitTransition",
    "WebkitTransitionDelay",
    "WebkitTransitionDuration",
    "WebkitTransitionProperty",
    "WebkitTransitionTimingFunction",
    "WebkitUserSelect",
    "WheelEvent",
    "Window",
    "WindowControlsOverlay",
    "WindowControlsOverlayGeometryChangeEvent",
    "WindowState",
    "WindowType",
    "Worker",
    "Worklet",
    "WritableStream",
    "WritableStreamDefaultController",
    "WritableStreamDefaultWriter",
    "XMLDocument",
    "XMLHttpRequest",
    "XMLHttpRequestEventTarget",
    "XMLHttpRequestException",
    "XMLHttpRequestProgressEvent",
    "XMLHttpRequestUpload",
    "XMLSerializer",
    "XMLStylesheetProcessingInstruction",
    "XPathEvaluator",
    "XPathException",
    "XPathExpression",
    "XPathNSResolver",
    "XPathResult",
    "XRAnchor",
    "XRAnchorSet",
    "XRBoundedReferenceSpace",
    "XRCPUDepthInformation",
    "XRCamera",
    "XRDOMOverlayState",
    "XRDepthInformation",
    "XRFrame",
    "XRHand",
    "XRHitTestResult",
    "XRHitTestSource",
    "XRInputSource",
    "XRInputSourceArray",
    "XRInputSourceEvent",
    "XRInputSourcesChangeEvent",
    "XRJointPose",
    "XRJointSpace",
    "XRLayer",
    "XRLightEstimate",
    "XRLightProbe",
    "XRPose",
    "XRRay",
    "XRReferenceSpace",
    "XRReferenceSpaceEvent",
    "XRRenderState",
    "XRRigidTransform",
    "XRSession",
    "XRSessionEvent",
    "XRSpace",
    "XRSystem",
    "XRTransientInputHitTestResult",
    "XRTransientInputHitTestSource",
    "XRView",
    "XRViewerPose",
    "XRViewport",
    "XRWebGLBinding",
    "XRWebGLDepthInformation",
    "XRWebGLLayer",
    "XSLTProcessor",
    "ZERO",
    "ZoomSettings",
    "ZoomSettingsMode",
    "ZoomSettingsScope",
    "_XD0M_",
    "_YD0M_",
    "__REACT_DEVTOOLS_GLOBAL_HOOK__",
    "__brand",
    "__defineGetter__",
    "__defineSetter__",
    "__lookupGetter__",
    "__lookupSetter__",
    "__opera",
    "__proto__",
    "_browserjsran",
    "a",
    "aLink",
    "abbr",
    "abort",
    "aborted",
    "aboutConfigPrefs",
    "abs",
    "absolute",
    "acceleration",
    "accelerationIncludingGravity",
    "accelerator",
    "accent-color",
    "accentColor",
    "accept",
    "acceptCharset",
    "acceptNode",
    "access",
    "accessKey",
    "accessKeyLabel",
    "accuracy",
    "acos",
    "acosh",
    "action",
    "actionURL",
    "actions",
    "activated",
    "activation",
    "activationStart",
    "active",
    "activeCues",
    "activeElement",
    "activeSourceBuffers",
    "activeSourceCount",
    "activeTexture",
    "activeVRDisplays",
    "activityLog",
    "actualBoundingBoxAscent",
    "actualBoundingBoxDescent",
    "actualBoundingBoxLeft",
    "actualBoundingBoxRight",
    "adAuctionComponents",
    "adAuctionHeaders",
    "add",
    "addAll",
    "addBehavior",
    "addCandidate",
    "addColorStop",
    "addCue",
    "addElement",
    "addEventListener",
    "addFilter",
    "addFromString",
    "addFromUri",
    "addIceCandidate",
    "addImport",
    "addListener",
    "addModule",
    "addNamed",
    "addPageRule",
    "addPath",
    "addPointer",
    "addRange",
    "addRegion",
    "addRule",
    "addSearchEngine",
    "addSourceBuffer",
    "addStream",
    "addTextTrack",
    "addTrack",
    "addTransceiver",
    "addWakeLockListener",
    "added",
    "addedNodes",
    "additionalName",
    "additiveSymbols",
    "addons",
    "address",
    "addressLine",
    "addressModeU",
    "addressModeV",
    "addressModeW",
    "adoptNode",
    "adoptedCallback",
    "adoptedStyleSheets",
    "adr",
    "advance",
    "after",
    "alarms",
    "album",
    "alert",
    "algorithm",
    "align",
    "align-content",
    "align-items",
    "align-self",
    "alignContent",
    "alignItems",
    "alignSelf",
    "alignmentBaseline",
    "alinkColor",
    "all",
    "allSettled",
    "allocationSize",
    "allow",
    "allowFullscreen",
    "allowPaymentRequest",
    "allowedDirections",
    "allowedFeatures",
    "allowedToPlay",
    "allowsFeature",
    "alpha",
    "alphaMode",
    "alphaToCoverageEnabled",
    "alphabeticBaseline",
    "alt",
    "altGraphKey",
    "altHtml",
    "altKey",
    "altLeft",
    "alternate",
    "alternateSetting",
    "alternates",
    "altitude",
    "altitudeAccuracy",
    "altitudeAngle",
    "amplitude",
    "ancestorOrigins",
    "anchor",
    "anchorNode",
    "anchorOffset",
    "anchorSpace",
    "anchors",
    "and",
    "angle",
    "angularAcceleration",
    "angularVelocity",
    "animVal",
    "animate",
    "animated",
    "animatedInstanceRoot",
    "animatedNormalizedPathSegList",
    "animatedPathSegList",
    "animatedPoints",
    "animation",
    "animation-composition",
    "animation-delay",
    "animation-direction",
    "animation-duration",
    "animation-fill-mode",
    "animation-iteration-count",
    "animation-name",
    "animation-play-state",
    "animation-timing-function",
    "animationComposition",
    "animationDelay",
    "animationDirection",
    "animationDuration",
    "animationFillMode",
    "animationIterationCount",
    "animationName",
    "animationPlayState",
    "animationStartTime",
    "animationTimingFunction",
    "animationsPaused",
    "anniversary",
    "antialias",
    "anticipatedRemoval",
    "any",
    "app",
    "appCodeName",
    "appMinorVersion",
    "appName",
    "appNotifications",
    "appVersion",
    "appearance",
    "append",
    "appendBuffer",
    "appendChild",
    "appendData",
    "appendItem",
    "appendMedium",
    "appendNamed",
    "appendRule",
    "appendStream",
    "appendWindowEnd",
    "appendWindowStart",
    "applets",
    "applicationCache",
    "applicationServerKey",
    "apply",
    "applyConstraints",
    "applyElement",
    "arc",
    "arcTo",
    "arch",
    "architecture",
    "archive",
    "areas",
    "arguments",
    "ariaAtomic",
    "ariaAutoComplete",
    "ariaBrailleLabel",
    "ariaBrailleRoleDescription",
    "ariaBusy",
    "ariaChecked",
    "ariaColCount",
    "ariaColIndex",
    "ariaColIndexText",
    "ariaColSpan",
    "ariaCurrent",
    "ariaDescription",
    "ariaDisabled",
    "ariaExpanded",
    "ariaHasPopup",
    "ariaHidden",
    "ariaInvalid",
    "ariaKeyShortcuts",
    "ariaLabel",
    "ariaLevel",
    "ariaLive",
    "ariaModal",
    "ariaMultiLine",
    "ariaMultiSelectable",
    "ariaOrientation",
    "ariaPlaceholder",
    "ariaPosInSet",
    "ariaPressed",
    "ariaReadOnly",
    "ariaRelevant",
    "ariaRequired",
    "ariaRoleDescription",
    "ariaRowCount",
    "ariaRowIndex",
    "ariaRowIndexText",
    "ariaRowSpan",
    "ariaSelected",
    "ariaSetSize",
    "ariaSort",
    "ariaValueMax",
    "ariaValueMin",
    "ariaValueNow",
    "ariaValueText",
    "arrayBuffer",
    "arrayLayerCount",
    "arrayStride",
    "artist",
    "artwork",
    "as",
    "asIntN",
    "asUintN",
    "ascentOverride",
    "asin",
    "asinh",
    "aspect",
    "aspect-ratio",
    "aspectRatio",
    "assert",
    "assign",
    "assignedElements",
    "assignedNodes",
    "assignedSlot",
    "async",
    "asyncDispose",
    "asyncIterator",
    "at",
    "atEnd",
    "atan",
    "atan2",
    "atanh",
    "atob",
    "attachEvent",
    "attachInternals",
    "attachShader",
    "attachShadow",
    "attachedElements",
    "attachments",
    "attack",
    "attestationObject",
    "attrChange",
    "attrName",
    "attributeChangedCallback",
    "attributeFilter",
    "attributeName",
    "attributeNamespace",
    "attributeOldValue",
    "attributeStyleMap",
    "attributes",
    "attribution",
    "attributionSrc",
    "audioBitrateMode",
    "audioBitsPerSecond",
    "audioTracks",
    "audioWorklet",
    "authenticatedSignedWrites",
    "authenticatorAttachment",
    "authenticatorData",
    "autoIncrement",
    "autobuffer",
    "autocapitalize",
    "autocomplete",
    "autocorrect",
    "autofocus",
    "automationRate",
    "autoplay",
    "availHeight",
    "availLeft",
    "availTop",
    "availWidth",
    "availability",
    "available",
    "averageLatency",
    "aversion",
    "ax",
    "axes",
    "axis",
    "ay",
    "azimuth",
    "azimuthAngle",
    "b",
    "back",
    "backdrop-filter",
    "backdropFilter",
    "backends",
    "backface-visibility",
    "backfaceVisibility",
    "background",
    "background-attachment",
    "background-blend-mode",
    "background-clip",
    "background-color",
    "background-image",
    "background-origin",
    "background-position",
    "background-position-x",
    "background-position-y",
    "background-repeat",
    "background-size",
    "backgroundAttachment",
    "backgroundBlendMode",
    "backgroundClip",
    "backgroundColor",
    "backgroundFetch",
    "backgroundImage",
    "backgroundOrigin",
    "backgroundPosition",
    "backgroundPositionX",
    "backgroundPositionY",
    "backgroundRepeat",
    "backgroundSize",
    "badInput",
    "badge",
    "balance",
    "baseArrayLayer",
    "baseFrequencyX",
    "baseFrequencyY",
    "baseLatency",
    "baseLayer",
    "baseMipLevel",
    "baseNode",
    "baseOffset",
    "basePalette",
    "baseURI",
    "baseVal",
    "baseline-source",
    "baselineShift",
    "baselineSource",
    "battery",
    "bday",
    "before",
    "beginComputePass",
    "beginElement",
    "beginElementAt",
    "beginOcclusionQuery",
    "beginPath",
    "beginQuery",
    "beginRenderPass",
    "beginTransformFeedback",
    "beginningOfPassWriteIndex",
    "behavior",
    "behaviorCookie",
    "behaviorPart",
    "behaviorUrns",
    "beta",
    "bezierCurveTo",
    "bgColor",
    "bgProperties",
    "bias",
    "big",
    "bigint64",
    "biguint64",
    "binaryType",
    "bind",
    "bindAttribLocation",
    "bindBuffer",
    "bindBufferBase",
    "bindBufferRange",
    "bindFramebuffer",
    "bindGroupLayouts",
    "bindRenderbuffer",
    "bindSampler",
    "bindTexture",
    "bindTransformFeedback",
    "bindVertexArray",
    "binding",
    "bitness",
    "blend",
    "blendColor",
    "blendEquation",
    "blendEquationSeparate",
    "blendFunc",
    "blendFuncSeparate",
    "blink",
    "blitFramebuffer",
    "blob",
    "block-size",
    "blockDirection",
    "blockSize",
    "blockedURI",
    "blocking",
    "blockingDuration",
    "blue",
    "bluetooth",
    "blur",
    "body",
    "bodyUsed",
    "bold",
    "bookmarks",
    "booleanValue",
    "border",
    "border-block",
    "border-block-color",
    "border-block-end",
    "border-block-end-color",
    "border-block-end-style",
    "border-block-end-width",
    "border-block-start",
    "border-block-start-color",
    "border-block-start-style",
    "border-block-start-width",
    "border-block-style",
    "border-block-width",
    "border-bottom",
    "border-bottom-color",
    "border-bottom-left-radius",
    "border-bottom-right-radius",
    "border-bottom-style",
    "border-bottom-width",
    "border-collapse",
    "border-color",
    "border-end-end-radius",
    "border-end-start-radius",
    "border-image",
    "border-image-outset",
    "border-image-repeat",
    "border-image-slice",
    "border-image-source",
    "border-image-width",
    "border-inline",
    "border-inline-color",
    "border-inline-end",
    "border-inline-end-color",
    "border-inline-end-style",
    "border-inline-end-width",
    "border-inline-start",
    "border-inline-start-color",
    "border-inline-start-style",
    "border-inline-start-width",
    "border-inline-style",
    "border-inline-width",
    "border-left",
    "border-left-color",
    "border-left-style",
    "border-left-width",
    "border-radius",
    "border-right",
    "border-right-color",
    "border-right-style",
    "border-right-width",
    "border-spacing",
    "border-start-end-radius",
    "border-start-start-radius",
    "border-style",
    "border-top",
    "border-top-color",
    "border-top-left-radius",
    "border-top-right-radius",
    "border-top-style",
    "border-top-width",
    "border-width",
    "borderBlock",
    "borderBlockColor",
    "borderBlockEnd",
    "borderBlockEndColor",
    "borderBlockEndStyle",
    "borderBlockEndWidth",
    "borderBlockStart",
    "borderBlockStartColor",
    "borderBlockStartStyle",
    "borderBlockStartWidth",
    "borderBlockStyle",
    "borderBlockWidth",
    "borderBottom",
    "borderBottomColor",
    "borderBottomLeftRadius",
    "borderBottomRightRadius",
    "borderBottomStyle",
    "borderBottomWidth",
    "borderBoxSize",
    "borderCollapse",
    "borderColor",
    "borderColorDark",
    "borderColorLight",
    "borderEndEndRadius",
    "borderEndStartRadius",
    "borderImage",
    "borderImageOutset",
    "borderImageRepeat",
    "borderImageSlice",
    "borderImageSource",
    "borderImageWidth",
    "borderInline",
    "borderInlineColor",
    "borderInlineEnd",
    "borderInlineEndColor",
    "borderInlineEndStyle",
    "borderInlineEndWidth",
    "borderInlineStart",
    "borderInlineStartColor",
    "borderInlineStartStyle",
    "borderInlineStartWidth",
    "borderInlineStyle",
    "borderInlineWidth",
    "borderLeft",
    "borderLeftColor",
    "borderLeftStyle",
    "borderLeftWidth",
    "borderRadius",
    "borderRight",
    "borderRightColor",
    "borderRightStyle",
    "borderRightWidth",
    "borderSpacing",
    "borderStartEndRadius",
    "borderStartStartRadius",
    "borderStyle",
    "borderTop",
    "borderTopColor",
    "borderTopLeftRadius",
    "borderTopRightRadius",
    "borderTopStyle",
    "borderTopWidth",
    "borderWidth",
    "bottom",
    "bottomMargin",
    "bound",
    "boundElements",
    "boundingClientRect",
    "boundingHeight",
    "boundingLeft",
    "boundingRect",
    "boundingTop",
    "boundingWidth",
    "bounds",
    "boundsGeometry",
    "box-decoration-break",
    "box-shadow",
    "box-sizing",
    "boxDecorationBreak",
    "boxShadow",
    "boxSizing",
    "brand",
    "brands",
    "break-after",
    "break-before",
    "break-inside",
    "breakAfter",
    "breakBefore",
    "breakInside",
    "broadcast",
    "browser",
    "browserLanguage",
    "browserSettings",
    "browsingData",
    "browsingTopics",
    "btoa",
    "bubbles",
    "buffer",
    "bufferData",
    "bufferDepth",
    "bufferSize",
    "bufferSubData",
    "buffered",
    "bufferedAmount",
    "bufferedAmountLowThreshold",
    "buffers",
    "buildID",
    "buildNumber",
    "button",
    "buttonID",
    "buttons",
    "byobRequest",
    "byteLength",
    "byteOffset",
    "bytes",
    "bytesPerRow",
    "bytesWritten",
    "c",
    "cache",
    "caches",
    "call",
    "caller",
    "camera",
    "canBeFormatted",
    "canBeMounted",
    "canBeShared",
    "canConstructInDedicatedWorker",
    "canGoBack",
    "canGoForward",
    "canHaveChildren",
    "canHaveHTML",
    "canInsertDTMF",
    "canIntercept",
    "canLoadAdAuctionFencedFrame",
    "canLoadOpaqueURL",
    "canMakePayment",
    "canParse",
    "canPlayType",
    "canPresent",
    "canShare",
    "canTransition",
    "canTrickleIceCandidates",
    "cancel",
    "cancelAndHoldAtTime",
    "cancelAnimationFrame",
    "cancelBubble",
    "cancelIdleCallback",
    "cancelScheduledValues",
    "cancelVideoFrameCallback",
    "cancelWatchAvailability",
    "cancelable",
    "candidate",
    "canonicalUUID",
    "canvas",
    "cap",
    "capabilities",
    "caption",
    "caption-side",
    "captionSide",
    "captivePortal",
    "capture",
    "captureEvents",
    "captureStackTrace",
    "captureStream",
    "captureTab",
    "captureVisibleTab",
    "caret-color",
    "caretBidiLevel",
    "caretColor",
    "caretPositionFromPoint",
    "caretRangeFromPoint",
    "cast",
    "catch",
    "category",
    "cbrt",
    "cd",
    "ceil",
    "cellIndex",
    "cellPadding",
    "cellSpacing",
    "cells",
    "ch",
    "chOff",
    "chain",
    "challenge",
    "changeType",
    "changed",
    "changedTouches",
    "channel",
    "channelCount",
    "channelCountMode",
    "channelInterpretation",
    "chapterInfo",
    "char",
    "charAt",
    "charCode",
    "charCodeAt",
    "charIndex",
    "charLength",
    "characterBounds",
    "characterBoundsRangeStart",
    "characterData",
    "characterDataOldValue",
    "characterSet",
    "characteristic",
    "charging",
    "chargingTime",
    "charset",
    "check",
    "checkDCE",
    "checkEnclosure",
    "checkFramebufferStatus",
    "checkIntersection",
    "checkValidity",
    "checkVisibility",
    "checked",
    "childElementCount",
    "childList",
    "childNodes",
    "children",
    "chrome",
    "ciphertext",
    "cite",
    "city",
    "claimInterface",
    "claimed",
    "classList",
    "className",
    "classid",
    "clear",
    "clearAppBadge",
    "clearAttributes",
    "clearBuffer",
    "clearBufferfi",
    "clearBufferfv",
    "clearBufferiv",
    "clearBufferuiv",
    "clearColor",
    "clearData",
    "clearDepth",
    "clearHalt",
    "clearImmediate",
    "clearInterval",
    "clearLiveSeekableRange",
    "clearMarks",
    "clearMaxGCPauseAccumulator",
    "clearMeasures",
    "clearOriginJoinedAdInterestGroups",
    "clearParameters",
    "clearRect",
    "clearResourceTimings",
    "clearShadow",
    "clearStencil",
    "clearTimeout",
    "clearValue",
    "clearWatch",
    "click",
    "clickCount",
    "clientDataJSON",
    "clientHeight",
    "clientInformation",
    "clientLeft",
    "clientRect",
    "clientRects",
    "clientTop",
    "clientWaitSync",
    "clientWidth",
    "clientX",
    "clientY",
    "clip",
    "clip-path",
    "clip-rule",
    "clipBottom",
    "clipLeft",
    "clipPath",
    "clipPathUnits",
    "clipRight",
    "clipRule",
    "clipTop",
    "clipboard",
    "clipboardData",
    "clonable",
    "clone",
    "cloneContents",
    "cloneNode",
    "cloneRange",
    "close",
    "closeCode",
    "closePath",
    "closed",
    "closest",
    "clz",
    "clz32",
    "cm",
    "cmp",
    "code",
    "codeBase",
    "codePointAt",
    "codeType",
    "codedHeight",
    "codedRect",
    "codedWidth",
    "colSpan",
    "collapse",
    "collapseToEnd",
    "collapseToStart",
    "collapsed",
    "collect",
    "collections",
    "colno",
    "color",
    "color-adjust",
    "color-interpolation",
    "color-interpolation-filters",
    "color-scheme",
    "colorAdjust",
    "colorAttachments",
    "colorDepth",
    "colorFormats",
    "colorInterpolation",
    "colorInterpolationFilters",
    "colorMask",
    "colorScheme",
    "colorSpace",
    "colorType",
    "cols",
    "column-count",
    "column-fill",
    "column-gap",
    "column-rule",
    "column-rule-color",
    "column-rule-style",
    "column-rule-width",
    "column-span",
    "column-width",
    "columnCount",
    "columnFill",
    "columnGap",
    "columnNumber",
    "columnRule",
    "columnRuleColor",
    "columnRuleStyle",
    "columnRuleWidth",
    "columnSpan",
    "columnWidth",
    "columns",
    "command",
    "commands",
    "commit",
    "commitLoadTime",
    "commitPreferences",
    "commitStyles",
    "commonAncestorContainer",
    "compact",
    "compare",
    "compareBoundaryPoints",
    "compareDocumentPosition",
    "compareEndPoints",
    "compareExchange",
    "compareNode",
    "comparePoint",
    "compatMode",
    "compatible",
    "compile",
    "compileShader",
    "compileStreaming",
    "complete",
    "completed",
    "component",
    "componentFromPoint",
    "composed",
    "composedPath",
    "composite",
    "compositionEndOffset",
    "compositionStartOffset",
    "compressedTexImage2D",
    "compressedTexImage3D",
    "compressedTexSubImage2D",
    "compressedTexSubImage3D",
    "compute",
    "computedStyleMap",
    "concat",
    "conditionText",
    "coneInnerAngle",
    "coneOuterAngle",
    "coneOuterGain",
    "config",
    "configurable",
    "configuration",
    "configurationName",
    "configurationValue",
    "configurations",
    "configure",
    "confirm",
    "confirmComposition",
    "confirmSiteSpecificTrackingException",
    "confirmWebWideTrackingException",
    "congestionControl",
    "connect",
    "connectEnd",
    "connectNative",
    "connectShark",
    "connectStart",
    "connected",
    "connectedCallback",
    "connection",
    "connectionInfo",
    "connectionList",
    "connectionSpeed",
    "connectionState",
    "connections",
    "console",
    "consolidate",
    "constants",
    "constraint",
    "constrictionActive",
    "construct",
    "constructor",
    "contactID",
    "contain",
    "contain-intrinsic-block-size",
    "contain-intrinsic-height",
    "contain-intrinsic-inline-size",
    "contain-intrinsic-size",
    "contain-intrinsic-width",
    "containIntrinsicBlockSize",
    "containIntrinsicHeight",
    "containIntrinsicInlineSize",
    "containIntrinsicSize",
    "containIntrinsicWidth",
    "container",
    "container-name",
    "container-type",
    "containerId",
    "containerName",
    "containerQuery",
    "containerSrc",
    "containerType",
    "contains",
    "containsNode",
    "content",
    "content-visibility",
    "contentBoxSize",
    "contentDocument",
    "contentEditable",
    "contentHint",
    "contentOverflow",
    "contentRect",
    "contentScriptType",
    "contentStyleType",
    "contentType",
    "contentVisibility",
    "contentWindow",
    "context",
    "contextId",
    "contextIds",
    "contextMenu",
    "contextMenus",
    "contextType",
    "contextTypes",
    "contextmenu",
    "contextualIdentities",
    "continue",
    "continuePrimaryKey",
    "continuous",
    "control",
    "controlTransferIn",
    "controlTransferOut",
    "controller",
    "controls",
    "controlsList",
    "convertPointFromNode",
    "convertQuadFromNode",
    "convertRectFromNode",
    "convertToBlob",
    "convertToSpecifiedUnits",
    "cookie",
    "cookieEnabled",
    "cookieStore",
    "cookies",
    "coords",
    "copyBufferSubData",
    "copyBufferToBuffer",
    "copyBufferToTexture",
    "copyExternalImageToTexture",
    "copyFromChannel",
    "copyTexImage2D",
    "copyTexSubImage2D",
    "copyTexSubImage3D",
    "copyTextureToBuffer",
    "copyTextureToTexture",
    "copyTo",
    "copyToChannel",
    "copyWithin",
    "correspondingElement",
    "correspondingUseElement",
    "corruptedVideoFrames",
    "cos",
    "cosh",
    "count",
    "countReset",
    "counter-increment",
    "counter-reset",
    "counter-set",
    "counterIncrement",
    "counterReset",
    "counterSet",
    "country",
    "cpuClass",
    "cpuSleepAllowed",
    "cqb",
    "cqh",
    "cqi",
    "cqmax",
    "cqmin",
    "cqw",
    "create",
    "createAnalyser",
    "createAnchor",
    "createAnswer",
    "createAttribute",
    "createAttributeNS",
    "createAuctionNonce",
    "createBidirectionalStream",
    "createBindGroup",
    "createBindGroupLayout",
    "createBiquadFilter",
    "createBuffer",
    "createBufferSource",
    "createCDATASection",
    "createCSSStyleSheet",
    "createCaption",
    "createChannelMerger",
    "createChannelSplitter",
    "createCommandEncoder",
    "createComment",
    "createComputePipeline",
    "createComputePipelineAsync",
    "createConicGradient",
    "createConstantSource",
    "createContextualFragment",
    "createControlRange",
    "createConvolver",
    "createDTMFSender",
    "createDataChannel",
    "createDelay",
    "createDelayNode",
    "createDocument",
    "createDocumentFragment",
    "createDocumentType",
    "createDynamicsCompressor",
    "createElement",
    "createElementNS",
    "createEncodedStreams",
    "createEntityReference",
    "createEvent",
    "createEventObject",
    "createExpression",
    "createFramebuffer",
    "createFunction",
    "createGain",
    "createGainNode",
    "createHTML",
    "createHTMLDocument",
    "createIIRFilter",
    "createImageBitmap",
    "createImageData",
    "createIndex",
    "createJavaScriptNode",
    "createLinearGradient",
    "createMediaElementSource",
    "createMediaKeys",
    "createMediaStreamDestination",
    "createMediaStreamSource",
    "createMediaStreamTrackSource",
    "createMutableFile",
    "createNSResolver",
    "createNodeIterator",
    "createNotification",
    "createObjectStore",
    "createObjectURL",
    "createOffer",
    "createOscillator",
    "createPanner",
    "createPattern",
    "createPeriodicWave",
    "createPipelineLayout",
    "createPolicy",
    "createPopup",
    "createProcessingInstruction",
    "createProgram",
    "createQuery",
    "createQuerySet",
    "createRadialGradient",
    "createRange",
    "createRangeCollection",
    "createReader",
    "createRenderBundleEncoder",
    "createRenderPipeline",
    "createRenderPipelineAsync",
    "createRenderbuffer",
    "createSVGAngle",
    "createSVGLength",
    "createSVGMatrix",
    "createSVGNumber",
    "createSVGPathSegArcAbs",
    "createSVGPathSegArcRel",
    "createSVGPathSegClosePath",
    "createSVGPathSegCurvetoCubicAbs",
    "createSVGPathSegCurvetoCubicRel",
    "createSVGPathSegCurvetoCubicSmoothAbs",
    "createSVGPathSegCurvetoCubicSmoothRel",
    "createSVGPathSegCurvetoQuadraticAbs",
    "createSVGPathSegCurvetoQuadraticRel",
    "createSVGPathSegCurvetoQuadraticSmoothAbs",
    "createSVGPathSegCurvetoQuadraticSmoothRel",
    "createSVGPathSegLinetoAbs",
    "createSVGPathSegLinetoHorizontalAbs",
    "createSVGPathSegLinetoHorizontalRel",
    "createSVGPathSegLinetoRel",
    "createSVGPathSegLinetoVerticalAbs",
    "createSVGPathSegLinetoVerticalRel",
    "createSVGPathSegMovetoAbs",
    "createSVGPathSegMovetoRel",
    "createSVGPoint",
    "createSVGRect",
    "createSVGTransform",
    "createSVGTransformFromMatrix",
    "createSampler",
    "createScript",
    "createScriptProcessor",
    "createScriptURL",
    "createSession",
    "createShader",
    "createShaderModule",
    "createShadowRoot",
    "createStereoPanner",
    "createStyleSheet",
    "createTBody",
    "createTFoot",
    "createTHead",
    "createTask",
    "createTextNode",
    "createTextRange",
    "createTexture",
    "createTouch",
    "createTouchList",
    "createTransformFeedback",
    "createTreeWalker",
    "createUnidirectionalStream",
    "createVertexArray",
    "createView",
    "createWaveShaper",
    "createWorklet",
    "createWritable",
    "creationTime",
    "credentialless",
    "credentials",
    "criticalCHRestart",
    "cropTo",
    "crossOrigin",
    "crossOriginIsolated",
    "crypto",
    "csi",
    "csp",
    "cssFloat",
    "cssRules",
    "cssText",
    "cssValueType",
    "ctrlKey",
    "ctrlLeft",
    "cues",
    "cullFace",
    "cullMode",
    "currentCSSZoom",
    "currentDirection",
    "currentEntry",
    "currentLocalDescription",
    "currentNode",
    "currentPage",
    "currentRect",
    "currentRemoteDescription",
    "currentScale",
    "currentScreen",
    "currentScript",
    "currentSrc",
    "currentState",
    "currentStyle",
    "currentTarget",
    "currentTime",
    "currentTranslate",
    "currentView",
    "cursor",
    "curve",
    "customElements",
    "customError",
    "cx",
    "cy",
    "d",
    "data",
    "dataFld",
    "dataFormatAs",
    "dataLoss",
    "dataLossMessage",
    "dataPageSize",
    "dataSrc",
    "dataTransfer",
    "database",
    "databases",
    "datagrams",
    "dataset",
    "dateTime",
    "db",
    "debug",
    "debuggerEnabled",
    "declarativeNetRequest",
    "declare",
    "decode",
    "decodeAudioData",
    "decodeQueueSize",
    "decodeURI",
    "decodeURIComponent",
    "decodedBodySize",
    "decoding",
    "decodingInfo",
    "decrypt",
    "default",
    "defaultCharset",
    "defaultChecked",
    "defaultMuted",
    "defaultPlaybackRate",
    "defaultPolicy",
    "defaultPrevented",
    "defaultQueue",
    "defaultRequest",
    "defaultSelected",
    "defaultStatus",
    "defaultURL",
    "defaultValue",
    "defaultView",
    "defaultstatus",
    "defer",
    "define",
    "defineMagicFunction",
    "defineMagicVariable",
    "defineProperties",
    "defineProperty",
    "deg",
    "delay",
    "delayTime",
    "delegatesFocus",
    "delete",
    "deleteBuffer",
    "deleteCaption",
    "deleteCell",
    "deleteContents",
    "deleteData",
    "deleteDatabase",
    "deleteFramebuffer",
    "deleteFromDocument",
    "deleteIndex",
    "deleteMedium",
    "deleteObjectStore",
    "deleteProgram",
    "deleteProperty",
    "deleteQuery",
    "deleteRenderbuffer",
    "deleteRow",
    "deleteRule",
    "deleteSampler",
    "deleteShader",
    "deleteSync",
    "deleteTFoot",
    "deleteTHead",
    "deleteTexture",
    "deleteTransformFeedback",
    "deleteVertexArray",
    "deleted",
    "deliverChangeRecords",
    "deliveredFrames",
    "deliveredFramesDuration",
    "delivery",
    "deliveryInfo",
    "deliveryStatus",
    "deliveryTimestamp",
    "deliveryType",
    "delta",
    "deltaMode",
    "deltaX",
    "deltaY",
    "deltaZ",
    "dependentLocality",
    "deprecatedReplaceInURN",
    "deprecatedRunAdAuctionEnforcesKAnonymity",
    "deprecatedURNToURL",
    "depthBias",
    "depthBiasClamp",
    "depthBiasSlopeScale",
    "depthClearValue",
    "depthCompare",
    "depthDataFormat",
    "depthFailOp",
    "depthFar",
    "depthFunc",
    "depthLoadOp",
    "depthMask",
    "depthNear",
    "depthOrArrayLayers",
    "depthRange",
    "depthReadOnly",
    "depthStencil",
    "depthStencilAttachment",
    "depthStencilFormat",
    "depthStoreOp",
    "depthUsage",
    "depthWriteEnabled",
    "deref",
    "deriveBits",
    "deriveKey",
    "descentOverride",
    "description",
    "deselectAll",
    "designMode",
    "desiredSize",
    "destination",
    "destinationURL",
    "destroy",
    "detach",
    "detachEvent",
    "detachShader",
    "detached",
    "detail",
    "details",
    "detect",
    "detectLanguage",
    "detune",
    "device",
    "deviceClass",
    "deviceId",
    "deviceMemory",
    "devicePixelContentBoxSize",
    "devicePixelRatio",
    "deviceProtocol",
    "deviceSubclass",
    "deviceVersionMajor",
    "deviceVersionMinor",
    "deviceVersionSubminor",
    "deviceXDPI",
    "deviceYDPI",
    "devtools",
    "devtools_panels",
    "didTimeout",
    "difference",
    "diffuseConstant",
    "digest",
    "dimension",
    "dimensions",
    "dir",
    "dirName",
    "direction",
    "dirxml",
    "disable",
    "disablePictureInPicture",
    "disableRemotePlayback",
    "disableVertexAttribArray",
    "disabled",
    "discard",
    "discardedFrames",
    "dischargingTime",
    "disconnect",
    "disconnectShark",
    "disconnectedCallback",
    "dispatchEvent",
    "dispatchWorkgroups",
    "dispatchWorkgroupsIndirect",
    "display",
    "displayHeight",
    "displayId",
    "displayName",
    "displayWidth",
    "dispose",
    "disposition",
    "distanceModel",
    "div",
    "divisor",
    "djsapi",
    "djsproxy",
    "dns",
    "doImport",
    "doNotTrack",
    "doScroll",
    "doctype",
    "document",
    "documentElement",
    "documentId",
    "documentIds",
    "documentLifecycle",
    "documentMode",
    "documentOrigin",
    "documentOrigins",
    "documentPictureInPicture",
    "documentURI",
    "documentUrl",
    "documentUrls",
    "dolphin",
    "dolphinGameCenter",
    "dolphininfo",
    "dolphinmeta",
    "dom",
    "domComplete",
    "domContentLoadedEventEnd",
    "domContentLoadedEventStart",
    "domInteractive",
    "domLoading",
    "domOverlayState",
    "domain",
    "domainLookupEnd",
    "domainLookupStart",
    "dominant-baseline",
    "dominantBaseline",
    "done",
    "dopplerFactor",
    "dotAll",
    "downDegrees",
    "downlink",
    "download",
    "downloadRequest",
    "downloadTotal",
    "downloaded",
    "downloads",
    "dpcm",
    "dpi",
    "dppx",
    "dragDrop",
    "draggable",
    "draw",
    "drawArrays",
    "drawArraysInstanced",
    "drawArraysInstancedANGLE",
    "drawBuffers",
    "drawCustomFocusRing",
    "drawElements",
    "drawElementsInstanced",
    "drawElementsInstancedANGLE",
    "drawFocusIfNeeded",
    "drawImage",
    "drawImageFromRect",
    "drawIndexed",
    "drawIndexedIndirect",
    "drawIndirect",
    "drawRangeElements",
    "drawSystemFocusRing",
    "drawingBufferColorSpace",
    "drawingBufferFormat",
    "drawingBufferHeight",
    "drawingBufferStorage",
    "drawingBufferWidth",
    "drop",
    "dropEffect",
    "droppedVideoFrames",
    "dropzone",
    "dstFactor",
    "dtmf",
    "dump",
    "dumpProfile",
    "duplex",
    "duplicate",
    "durability",
    "duration",
    "dvb",
    "dvh",
    "dvi",
    "dvmax",
    "dvmin",
    "dvname",
    "dvnum",
    "dvw",
    "dx",
    "dy",
    "dynamicId",
    "dynsrc",
    "e",
    "edgeMode",
    "editContext",
    "effect",
    "effectAllowed",
    "effectiveDirective",
    "effectiveType",
    "effects",
    "elapsedTime",
    "element",
    "elementFromPoint",
    "elementTiming",
    "elements",
    "elementsFromPoint",
    "elevation",
    "ellipse",
    "em",
    "emHeightAscent",
    "emHeightDescent",
    "email",
    "embeds",
    "emit",
    "emma",
    "empty",
    "empty-cells",
    "emptyCells",
    "emptyHTML",
    "emptyScript",
    "emulatedPosition",
    "enable",
    "enableBackground",
    "enableDelegations",
    "enableStyleSheetsForSet",
    "enableVertexAttribArray",
    "enabled",
    "enabledFeatures",
    "enabledPlugin",
    "encode",
    "encodeInto",
    "encodeQueueSize",
    "encodeURI",
    "encodeURIComponent",
    "encodedBodySize",
    "encoding",
    "encodingInfo",
    "encrypt",
    "enctype",
    "end",
    "endContainer",
    "endElement",
    "endElementAt",
    "endOcclusionQuery",
    "endOfPassWriteIndex",
    "endOfStream",
    "endOffset",
    "endQuery",
    "endTime",
    "endTransformFeedback",
    "ended",
    "endpoint",
    "endpointNumber",
    "endpoints",
    "endsWith",
    "enqueue",
    "enterKeyHint",
    "entities",
    "entries",
    "entry",
    "entryPoint",
    "entryType",
    "enumerable",
    "enumerate",
    "enumerateDevices",
    "enumerateEditable",
    "environmentBlendMode",
    "equals",
    "error",
    "errorCode",
    "errorDetail",
    "errorText",
    "escape",
    "estimate",
    "eval",
    "evaluate",
    "event",
    "eventCounts",
    "eventPhase",
    "events",
    "every",
    "ex",
    "exception",
    "exchange",
    "exec",
    "execCommand",
    "execCommandShowHelp",
    "execScript",
    "executeBundles",
    "executionStart",
    "exitFullscreen",
    "exitPictureInPicture",
    "exitPointerLock",
    "exitPresent",
    "exp",
    "expand",
    "expandEntityReferences",
    "expando",
    "expansion",
    "expectedImprovement",
    "experiments",
    "expiration",
    "expirationTime",
    "expires",
    "expiryDate",
    "explicitOriginalTarget",
    "expm1",
    "exponent",
    "exponentialRampToValueAtTime",
    "exportKey",
    "exports",
    "extend",
    "extension",
    "extensionTypes",
    "extensions",
    "extentNode",
    "extentOffset",
    "external",
    "externalResourcesRequired",
    "externalTexture",
    "extractContents",
    "extractable",
    "eye",
    "f",
    "f16round",
    "face",
    "factoryReset",
    "failOp",
    "failureReason",
    "fallback",
    "family",
    "familyName",
    "farthestViewportElement",
    "fastSeek",
    "fatal",
    "featureId",
    "featurePolicy",
    "featureSettings",
    "features",
    "fence",
    "fenceSync",
    "fetch",
    "fetchPriority",
    "fetchStart",
    "fftSize",
    "fgColor",
    "fieldOfView",
    "file",
    "fileCreatedDate",
    "fileHandle",
    "fileModifiedDate",
    "fileName",
    "fileSize",
    "fileUpdatedDate",
    "filename",
    "files",
    "filesystem",
    "fill",
    "fill-opacity",
    "fill-rule",
    "fillJointRadii",
    "fillLightMode",
    "fillOpacity",
    "fillPoses",
    "fillRect",
    "fillRule",
    "fillStyle",
    "fillText",
    "filter",
    "filterResX",
    "filterResY",
    "filterUnits",
    "filters",
    "finally",
    "find",
    "findIndex",
    "findLast",
    "findLastIndex",
    "findRule",
    "findText",
    "finish",
    "finishDocumentLoadTime",
    "finishLoadTime",
    "finished",
    "fireEvent",
    "firesTouchEvents",
    "firstChild",
    "firstElementChild",
    "firstInterimResponseStart",
    "firstPage",
    "firstPaintAfterLoadTime",
    "firstPaintTime",
    "firstUIEventTimestamp",
    "fixed",
    "flags",
    "flat",
    "flatMap",
    "flex",
    "flex-basis",
    "flex-direction",
    "flex-flow",
    "flex-grow",
    "flex-shrink",
    "flex-wrap",
    "flexBasis",
    "flexDirection",
    "flexFlow",
    "flexGrow",
    "flexShrink",
    "flexWrap",
    "flipX",
    "flipY",
    "float",
    "float32",
    "float64",
    "flood-color",
    "flood-opacity",
    "floodColor",
    "floodOpacity",
    "floor",
    "flush",
    "focus",
    "focusNode",
    "focusOffset",
    "font",
    "font-family",
    "font-feature-settings",
    "font-kerning",
    "font-language-override",
    "font-optical-sizing",
    "font-palette",
    "font-size",
    "font-size-adjust",
    "font-stretch",
    "font-style",
    "font-synthesis",
    "font-synthesis-position",
    "font-synthesis-small-caps",
    "font-synthesis-style",
    "font-synthesis-weight",
    "font-variant",
    "font-variant-alternates",
    "font-variant-caps",
    "font-variant-east-asian",
    "font-variant-ligatures",
    "font-variant-numeric",
    "font-variant-position",
    "font-variation-settings",
    "font-weight",
    "fontBoundingBoxAscent",
    "fontBoundingBoxDescent",
    "fontFamily",
    "fontFeatureSettings",
    "fontKerning",
    "fontLanguageOverride",
    "fontOpticalSizing",
    "fontPalette",
    "fontSize",
    "fontSizeAdjust",
    "fontSmoothingEnabled",
    "fontStretch",
    "fontStyle",
    "fontSynthesis",
    "fontSynthesisPosition",
    "fontSynthesisSmallCaps",
    "fontSynthesisStyle",
    "fontSynthesisWeight",
    "fontVariant",
    "fontVariantAlternates",
    "fontVariantCaps",
    "fontVariantEastAsian",
    "fontVariantLigatures",
    "fontVariantNumeric",
    "fontVariantPosition",
    "fontVariationSettings",
    "fontWeight",
    "fontcolor",
    "fontfaces",
    "fonts",
    "fontsize",
    "for",
    "forEach",
    "force",
    "forceFallbackAdapter",
    "forceRedraw",
    "forced-color-adjust",
    "forcedColorAdjust",
    "forcedStyleAndLayoutDuration",
    "forget",
    "form",
    "formAction",
    "formData",
    "formEnctype",
    "formMethod",
    "formNoValidate",
    "formTarget",
    "format",
    "formatToParts",
    "forms",
    "forward",
    "forwardX",
    "forwardY",
    "forwardZ",
    "foundation",
    "fr",
    "fragment",
    "fragmentDirective",
    "frame",
    "frameBorder",
    "frameCount",
    "frameElement",
    "frameId",
    "frameIds",
    "frameSpacing",
    "framebuffer",
    "framebufferHeight",
    "framebufferRenderbuffer",
    "framebufferTexture2D",
    "framebufferTextureLayer",
    "framebufferWidth",
    "frames",
    "freeSpace",
    "freeze",
    "frequency",
    "frequencyBinCount",
    "from",
    "fromAsync",
    "fromBase64",
    "fromCharCode",
    "fromCodePoint",
    "fromElement",
    "fromEntries",
    "fromFloat32Array",
    "fromFloat64Array",
    "fromHex",
    "fromMatrix",
    "fromPoint",
    "fromQuad",
    "fromRect",
    "frontFace",
    "fround",
    "fullName",
    "fullPath",
    "fullRange",
    "fullScreen",
    "fullVersionList",
    "fullscreen",
    "fullscreenElement",
    "fullscreenEnabled",
    "fx",
    "fy",
    "g",
    "gain",
    "gamepad",
    "gamma",
    "gap",
    "gatheringState",
    "gatt",
    "geckoProfiler",
    "genderIdentity",
    "generateCertificate",
    "generateKey",
    "generateMipmap",
    "generateRequest",
    "geolocation",
    "gestureObject",
    "get",
    "getAcceptLanguages",
    "getActiveAttrib",
    "getActiveUniform",
    "getActiveUniformBlockName",
    "getActiveUniformBlockParameter",
    "getActiveUniforms",
    "getAdjacentText",
    "getAll",
    "getAllKeys",
    "getAllResponseHeaders",
    "getAllowlistForFeature",
    "getAnimations",
    "getAsFile",
    "getAsFileSystemHandle",
    "getAsString",
    "getAttachedShaders",
    "getAttribLocation",
    "getAttribute",
    "getAttributeNS",
    "getAttributeNames",
    "getAttributeNode",
    "getAttributeNodeNS",
    "getAttributeType",
    "getAudioTracks",
    "getAuthenticatorData",
    "getAutoplayPolicy",
    "getAvailability",
    "getBBox",
    "getBackgroundPage",
    "getBadgeBackgroundColor",
    "getBadgeText",
    "getBadgeTextColor",
    "getBattery",
    "getBigInt64",
    "getBigUint64",
    "getBindGroupLayout",
    "getBlob",
    "getBookmark",
    "getBoundingClientRect",
    "getBounds",
    "getBoxQuads",
    "getBrowserInfo",
    "getBufferParameter",
    "getBufferSubData",
    "getByteFrequencyData",
    "getByteTimeDomainData",
    "getCSSCanvasContext",
    "getCTM",
    "getCameraImage",
    "getCandidateWindowClientRect",
    "getCanonicalLocales",
    "getCapabilities",
    "getCaptureHandle",
    "getChannelData",
    "getCharNumAtPosition",
    "getCharacteristic",
    "getCharacteristics",
    "getClientExtensionResults",
    "getClientRect",
    "getClientRects",
    "getCoalescedEvents",
    "getCompilationInfo",
    "getCompositionAlternatives",
    "getComputedStyle",
    "getComputedTextLength",
    "getComputedTiming",
    "getConfiguration",
    "getConstraints",
    "getContext",
    "getContextAttributes",
    "getContexts",
    "getContributingSources",
    "getCounterValue",
    "getCueAsHTML",
    "getCueById",
    "getCurrent",
    "getCurrentPosition",
    "getCurrentTexture",
    "getCurrentTime",
    "getData",
    "getDatabaseNames",
    "getDate",
    "getDay",
    "getDefaultComputedStyle",
    "getDepthInMeters",
    "getDepthInformation",
    "getDescriptor",
    "getDescriptors",
    "getDestinationInsertionPoints",
    "getDevices",
    "getDirectory",
    "getDirectoryHandle",
    "getDisplayMedia",
    "getDistributedNodes",
    "getEditable",
    "getElementById",
    "getElementsByClassName",
    "getElementsByName",
    "getElementsByTagName",
    "getElementsByTagNameNS",
    "getEnclosureList",
    "getEndPositionOfChar",
    "getEntries",
    "getEntriesByName",
    "getEntriesByType",
    "getError",
    "getExtension",
    "getExtentOfChar",
    "getEyeParameters",
    "getFeature",
    "getFiberRoots",
    "getFile",
    "getFileHandle",
    "getFiles",
    "getFilesAndDirectories",
    "getFingerprints",
    "getFloat16",
    "getFloat32",
    "getFloat64",
    "getFloatFrequencyData",
    "getFloatTimeDomainData",
    "getFloatValue",
    "getFragDataLocation",
    "getFrameData",
    "getFrameId",
    "getFramebufferAttachmentParameter",
    "getFrequencyResponse",
    "getFullYear",
    "getGamepads",
    "getHTML",
    "getHeaderExtensionsToNegotiate",
    "getHighEntropyValues",
    "getHitTestResults",
    "getHitTestResultsForTransientInput",
    "getHours",
    "getIdentityAssertion",
    "getIds",
    "getImageData",
    "getIndexedParameter",
    "getInfo",
    "getInnerHTML",
    "getInstalledRelatedApps",
    "getInt16",
    "getInt32",
    "getInt8",
    "getInterestGroupAdAuctionData",
    "getInternalModuleRanges",
    "getInternalformatParameter",
    "getIntersectionList",
    "getItem",
    "getItems",
    "getJointPose",
    "getKey",
    "getKeyframes",
    "getLastFocused",
    "getLayers",
    "getLayoutMap",
    "getLightEstimate",
    "getLineDash",
    "getLocalCandidates",
    "getLocalParameters",
    "getLocalStreams",
    "getManagedConfiguration",
    "getManifest",
    "getMappedRange",
    "getMarks",
    "getMatchedCSSRules",
    "getMaxGCPauseSinceClear",
    "getMeasures",
    "getMessage",
    "getMetadata",
    "getMilliseconds",
    "getMinutes",
    "getModifierState",
    "getMonth",
    "getName",
    "getNamedItem",
    "getNamedItemNS",
    "getNativeFramebufferScaleFactor",
    "getNegotiatedHeaderExtensions",
    "getNestedConfigs",
    "getNotifications",
    "getNotifier",
    "getNumberOfChars",
    "getOffsetReferenceSpace",
    "getOutputTimestamp",
    "getOverrideHistoryNavigationMode",
    "getOverrideStyle",
    "getOwnPropertyDescriptor",
    "getOwnPropertyDescriptors",
    "getOwnPropertyNames",
    "getOwnPropertySymbols",
    "getPackageDirectoryEntry",
    "getParameter",
    "getParameters",
    "getParent",
    "getPathSegAtLength",
    "getPermissionWarningsByManifest",
    "getPhotoCapabilities",
    "getPhotoSettings",
    "getPlatformInfo",
    "getPointAtLength",
    "getPopup",
    "getPorts",
    "getPose",
    "getPredictedEvents",
    "getPreference",
    "getPreferenceDefault",
    "getPreferredCanvasFormat",
    "getPresentationAttribute",
    "getPreventDefault",
    "getPrimaryService",
    "getPrimaryServices",
    "getProgramInfoLog",
    "getProgramParameter",
    "getPropertyCSSValue",
    "getPropertyPriority",
    "getPropertyShorthand",
    "getPropertyType",
    "getPropertyValue",
    "getPrototypeOf",
    "getPublicKey",
    "getPublicKeyAlgorithm",
    "getQuery",
    "getQueryParameter",
    "getRGBColorValue",
    "getRandomValues",
    "getRangeAt",
    "getReader",
    "getReceivers",
    "getRectValue",
    "getReflectionCubeMap",
    "getRegistration",
    "getRegistrations",
    "getRemoteCandidates",
    "getRemoteCertificates",
    "getRemoteParameters",
    "getRemoteStreams",
    "getRenderbufferParameter",
    "getResponseHeader",
    "getRoot",
    "getRootNode",
    "getRotationOfChar",
    "getSVGDocument",
    "getSamplerParameter",
    "getScreenCTM",
    "getScreenDetails",
    "getSeconds",
    "getSelectedCandidatePair",
    "getSelection",
    "getSelf",
    "getSenders",
    "getService",
    "getSetCookie",
    "getSettings",
    "getShaderInfoLog",
    "getShaderParameter",
    "getShaderPrecisionFormat",
    "getShaderSource",
    "getSignals",
    "getSimpleDuration",
    "getSiteIcons",
    "getSources",
    "getSpeculativeParserUrls",
    "getStartPositionOfChar",
    "getStartTime",
    "getState",
    "getStats",
    "getStatusForPolicy",
    "getStorageUpdates",
    "getStreamById",
    "getStringValue",
    "getSubStringLength",
    "getSubscription",
    "getSubscriptions",
    "getSupportedConstraints",
    "getSupportedExtensions",
    "getSupportedFormats",
    "getSyncParameter",
    "getSynchronizationSources",
    "getTags",
    "getTargetRanges",
    "getTexParameter",
    "getTextFormats",
    "getTime",
    "getTimezoneOffset",
    "getTiming",
    "getTitle",
    "getTitlebarAreaRect",
    "getTotalLength",
    "getTrackById",
    "getTracks",
    "getTransceivers",
    "getTransform",
    "getTransformFeedbackVarying",
    "getTransformToElement",
    "getTransports",
    "getType",
    "getTypeMapping",
    "getUILanguage",
    "getURL",
    "getUTCDate",
    "getUTCDay",
    "getUTCFullYear",
    "getUTCHours",
    "getUTCMilliseconds",
    "getUTCMinutes",
    "getUTCMonth",
    "getUTCSeconds",
    "getUint16",
    "getUint32",
    "getUint8",
    "getUniform",
    "getUniformBlockIndex",
    "getUniformIndices",
    "getUniformLocation",
    "getUserInfo",
    "getUserMedia",
    "getUserSettings",
    "getVRDisplays",
    "getValues",
    "getVarDate",
    "getVariableValue",
    "getVertexAttrib",
    "getVertexAttribOffset",
    "getVideoPlaybackQuality",
    "getVideoTracks",
    "getViewerPose",
    "getViewport",
    "getViews",
    "getVoices",
    "getWakeLockState",
    "getWriter",
    "getYear",
    "getZoom",
    "getZoomSettings",
    "givenName",
    "global",
    "globalAlpha",
    "globalCompositeOperation",
    "globalPrivacyControl",
    "globalThis",
    "glyphOrientationHorizontal",
    "glyphOrientationVertical",
    "glyphRef",
    "go",
    "goBack",
    "goForward",
    "gpu",
    "grabFrame",
    "grad",
    "gradientTransform",
    "gradientUnits",
    "grammars",
    "green",
    "grid",
    "grid-area",
    "grid-auto-columns",
    "grid-auto-flow",
    "grid-auto-rows",
    "grid-column",
    "grid-column-end",
    "grid-column-gap",
    "grid-column-start",
    "grid-gap",
    "grid-row",
    "grid-row-end",
    "grid-row-gap",
    "grid-row-start",
    "grid-template",
    "grid-template-areas",
    "grid-template-columns",
    "grid-template-rows",
    "gridArea",
    "gridAutoColumns",
    "gridAutoFlow",
    "gridAutoRows",
    "gridColumn",
    "gridColumnEnd",
    "gridColumnGap",
    "gridColumnStart",
    "gridGap",
    "gridRow",
    "gridRowEnd",
    "gridRowGap",
    "gridRowStart",
    "gridTemplate",
    "gridTemplateAreas",
    "gridTemplateColumns",
    "gridTemplateRows",
    "gripSpace",
    "group",
    "groupBy",
    "groupCollapsed",
    "groupEnd",
    "groupId",
    "groups",
    "grow",
    "growable",
    "guestProcessId",
    "guestRenderFrameRoutingId",
    "hadRecentInput",
    "hand",
    "handedness",
    "hangingBaseline",
    "hapticActuators",
    "hardwareConcurrency",
    "has",
    "hasAttribute",
    "hasAttributeNS",
    "hasAttributes",
    "hasBeenActive",
    "hasChildNodes",
    "hasComposition",
    "hasDynamicOffset",
    "hasEnrolledInstrument",
    "hasExtension",
    "hasExternalDisplay",
    "hasFeature",
    "hasFocus",
    "hasIndices",
    "hasInstance",
    "hasLayout",
    "hasOrientation",
    "hasOwn",
    "hasOwnProperty",
    "hasPointerCapture",
    "hasPosition",
    "hasPrivateToken",
    "hasReading",
    "hasRedemptionRecord",
    "hasRegExpGroups",
    "hasStorageAccess",
    "hasUAVisualTransition",
    "hasUnpartitionedCookieAccess",
    "hash",
    "hashChange",
    "head",
    "headers",
    "heading",
    "height",
    "hid",
    "hidden",
    "hide",
    "hideFocus",
    "hidePopover",
    "high",
    "highWaterMark",
    "highlight",
    "highlights",
    "hint",
    "hints",
    "history",
    "honorificPrefix",
    "honorificSuffix",
    "horizontalOverflow",
    "host",
    "hostCandidate",
    "hostname",
    "href",
    "hrefTranslate",
    "hreflang",
    "hspace",
    "html5TagCheckInerface",
    "htmlFor",
    "htmlText",
    "httpEquiv",
    "httpRequestStatusCode",
    "hwTimestamp",
    "hyphenate-character",
    "hyphenateCharacter",
    "hyphens",
    "hypot",
    "i18n",
    "ic",
    "iccId",
    "iceConnectionState",
    "iceGatheringState",
    "iceTransport",
    "icon",
    "iconURL",
    "id",
    "identifier",
    "identity",
    "ideographicBaseline",
    "idle",
    "idpLoginUrl",
    "ignoreBOM",
    "ignoreCase",
    "ignoreDepthValues",
    "image",
    "image-orientation",
    "image-rendering",
    "imageHeight",
    "imageOrientation",
    "imageRendering",
    "imageSizes",
    "imageSmoothingEnabled",
    "imageSmoothingQuality",
    "imageSrcset",
    "imageWidth",
    "images",
    "ime-mode",
    "imeMode",
    "implementation",
    "importExternalTexture",
    "importKey",
    "importNode",
    "importStylesheet",
    "imports",
    "impp",
    "imul",
    "in",
    "in1",
    "in2",
    "inBandMetadataTrackDispatchType",
    "inIncognitoContext",
    "inRange",
    "includes",
    "incognito",
    "incomingBidirectionalStreams",
    "incomingHighWaterMark",
    "incomingMaxAge",
    "incomingUnidirectionalStreams",
    "incremental",
    "indeterminate",
    "index",
    "indexNames",
    "indexOf",
    "indexedDB",
    "indicate",
    "indices",
    "inert",
    "inertiaDestinationX",
    "inertiaDestinationY",
    "info",
    "inherits",
    "init",
    "initAnimationEvent",
    "initBeforeLoadEvent",
    "initClipboardEvent",
    "initCloseEvent",
    "initCommandEvent",
    "initCompositionEvent",
    "initCustomEvent",
    "initData",
    "initDataType",
    "initDeviceMotionEvent",
    "initDeviceOrientationEvent",
    "initDragEvent",
    "initErrorEvent",
    "initEvent",
    "initFocusEvent",
    "initGestureEvent",
    "initHashChangeEvent",
    "initKeyEvent",
    "initKeyboardEvent",
    "initMSManipulationEvent",
    "initMessageEvent",
    "initMouseEvent",
    "initMouseScrollEvent",
    "initMouseWheelEvent",
    "initMutationEvent",
    "initNSMouseEvent",
    "initOverflowEvent",
    "initPageEvent",
    "initPageTransitionEvent",
    "initPointerEvent",
    "initPopStateEvent",
    "initProgressEvent",
    "initScrollAreaEvent",
    "initSimpleGestureEvent",
    "initStorageEvent",
    "initTextEvent",
    "initTimeEvent",
    "initTouchEvent",
    "initTransitionEvent",
    "initUIEvent",
    "initWebKitAnimationEvent",
    "initWebKitTransitionEvent",
    "initWebKitWheelEvent",
    "initWheelEvent",
    "initialTime",
    "initialValue",
    "initialize",
    "initiatorType",
    "inject",
    "ink",
    "inline-size",
    "inlineSize",
    "inlineVerticalFieldOfView",
    "inner",
    "innerHTML",
    "innerHeight",
    "innerText",
    "innerWidth",
    "input",
    "inputBuffer",
    "inputEncoding",
    "inputMethod",
    "inputMode",
    "inputSource",
    "inputSources",
    "inputType",
    "inputs",
    "insertAdjacentElement",
    "insertAdjacentHTML",
    "insertAdjacentText",
    "insertBefore",
    "insertCell",
    "insertDTMF",
    "insertData",
    "insertDebugMarker",
    "insertItemBefore",
    "insertNode",
    "insertRow",
    "insertRule",
    "inset",
    "inset-block",
    "inset-block-end",
    "inset-block-start",
    "inset-inline",
    "inset-inline-end",
    "inset-inline-start",
    "insetBlock",
    "insetBlockEnd",
    "insetBlockStart",
    "insetInline",
    "insetInlineEnd",
    "insetInlineStart",
    "install",
    "installing",
    "instanceRoot",
    "instantiate",
    "instantiateStreaming",
    "instruments",
    "int16",
    "int32",
    "int8",
    "integrity",
    "interactionId",
    "interactionMode",
    "intercept",
    "interfaceClass",
    "interfaceName",
    "interfaceNumber",
    "interfaceProtocol",
    "interfaceSubclass",
    "interfaces",
    "interimResults",
    "internalSubset",
    "interpretation",
    "intersection",
    "intersectionRatio",
    "intersectionRect",
    "intersectsNode",
    "interval",
    "invalidIteratorState",
    "invalidateFramebuffer",
    "invalidateSubFramebuffer",
    "inverse",
    "invertSelf",
    "invoker",
    "invokerType",
    "is",
    "is2D",
    "isActive",
    "isAllowedFileSchemeAccess",
    "isAllowedIncognitoAccess",
    "isAlternate",
    "isArray",
    "isAutoSelected",
    "isBingCurrentSearchDefault",
    "isBuffer",
    "isCandidateWindowVisible",
    "isChar",
    "isCollapsed",
    "isComposing",
    "isConcatSpreadable",
    "isConditionalMediationAvailable",
    "isConfigSupported",
    "isConnected",
    "isContentEditable",
    "isContentHandlerRegistered",
    "isContextLost",
    "isDefaultNamespace",
    "isDirectory",
    "isDisabled",
    "isDisjointFrom",
    "isEnabled",
    "isEqual",
    "isEqualNode",
    "isExtended",
    "isExtensible",
    "isExternalCTAP2SecurityKeySupported",
    "isFallbackAdapter",
    "isFile",
    "isFinite",
    "isFirstPersonObserver",
    "isFramebuffer",
    "isFrozen",
    "isGenerator",
    "isHTML",
    "isHistoryNavigation",
    "isId",
    "isIdentity",
    "isInjected",
    "isInputPending",
    "isInteger",
    "isInternal",
    "isIntersecting",
    "isLockFree",
    "isMap",
    "isMultiLine",
    "isNaN",
    "isOpen",
    "isPointInFill",
    "isPointInPath",
    "isPointInRange",
    "isPointInStroke",
    "isPrefAlternate",
    "isPresenting",
    "isPrimary",
    "isProgram",
    "isPropertyImplicit",
    "isProtocolHandlerRegistered",
    "isPrototypeOf",
    "isQuery",
    "isRawJSON",
    "isRenderbuffer",
    "isSafeInteger",
    "isSameEntry",
    "isSameNode",
    "isSampler",
    "isScript",
    "isScriptURL",
    "isSealed",
    "isSecureContext",
    "isSessionSupported",
    "isShader",
    "isSubsetOf",
    "isSupersetOf",
    "isSupported",
    "isSync",
    "isTextEdit",
    "isTexture",
    "isTransformFeedback",
    "isTrusted",
    "isTypeSupported",
    "isUserVerifyingPlatformAuthenticatorAvailable",
    "isVertexArray",
    "isView",
    "isVisible",
    "isWellFormed",
    "isochronousTransferIn",
    "isochronousTransferOut",
    "isolation",
    "italics",
    "item",
    "itemId",
    "itemProp",
    "itemRef",
    "itemScope",
    "itemType",
    "itemValue",
    "items",
    "iterateNext",
    "iterationComposite",
    "iterator",
    "javaEnabled",
    "jitterBufferTarget",
    "jobTitle",
    "join",
    "joinAdInterestGroup",
    "jointName",
    "json",
    "justify-content",
    "justify-items",
    "justify-self",
    "justifyContent",
    "justifyItems",
    "justifySelf",
    "k1",
    "k2",
    "k3",
    "k4",
    "kHz",
    "keepalive",
    "kernelMatrix",
    "kernelUnitLengthX",
    "kernelUnitLengthY",
    "kerning",
    "key",
    "keyCode",
    "keyFor",
    "keyIdentifier",
    "keyLightEnabled",
    "keyLocation",
    "keyPath",
    "keyStatuses",
    "keySystem",
    "keyText",
    "keyUsage",
    "keyboard",
    "keys",
    "keytype",
    "kind",
    "knee",
    "knownSources",
    "label",
    "labels",
    "lang",
    "language",
    "languages",
    "largeArcFlag",
    "lastChild",
    "lastElementChild",
    "lastError",
    "lastEventId",
    "lastIndex",
    "lastIndexOf",
    "lastInputTime",
    "lastMatch",
    "lastMessageSubject",
    "lastMessageType",
    "lastModified",
    "lastModifiedDate",
    "lastPage",
    "lastParen",
    "lastState",
    "lastStyleSheetSet",
    "latency",
    "latitude",
    "launchQueue",
    "layerName",
    "layerX",
    "layerY",
    "layout",
    "layoutFlow",
    "layoutGrid",
    "layoutGridChar",
    "layoutGridLine",
    "layoutGridMode",
    "layoutGridType",
    "lbound",
    "leaveAdInterestGroup",
    "left",
    "leftContext",
    "leftDegrees",
    "leftMargin",
    "leftProjectionMatrix",
    "leftViewMatrix",
    "length",
    "lengthAdjust",
    "lengthComputable",
    "letter-spacing",
    "letterSpacing",
    "level",
    "lh",
    "lighting-color",
    "lightingColor",
    "limitingConeAngle",
    "limits",
    "line",
    "line-break",
    "line-height",
    "lineAlign",
    "lineBreak",
    "lineCap",
    "lineDashOffset",
    "lineGapOverride",
    "lineHeight",
    "lineJoin",
    "lineNum",
    "lineNumber",
    "linePos",
    "lineTo",
    "lineWidth",
    "linearAcceleration",
    "linearRampToValueAtTime",
    "linearVelocity",
    "lineno",
    "lines",
    "link",
    "linkColor",
    "linkProgram",
    "links",
    "list",
    "list-style",
    "list-style-image",
    "list-style-position",
    "list-style-type",
    "listStyle",
    "listStyleImage",
    "listStylePosition",
    "listStyleType",
    "listener",
    "listeners",
    "load",
    "loadEventEnd",
    "loadEventStart",
    "loadOp",
    "loadTime",
    "loadTimes",
    "loaded",
    "loading",
    "localDescription",
    "localName",
    "localService",
    "localStorage",
    "locale",
    "localeCompare",
    "location",
    "locationbar",
    "lock",
    "locked",
    "lockedFile",
    "locks",
    "lodMaxClamp",
    "lodMinClamp",
    "log",
    "log10",
    "log1p",
    "log2",
    "logicalXDPI",
    "logicalYDPI",
    "login",
    "loglevel",
    "longDesc",
    "longitude",
    "lookupNamespaceURI",
    "lookupPrefix",
    "loop",
    "loopEnd",
    "loopStart",
    "looping",
    "lost",
    "low",
    "lower",
    "lowerBound",
    "lowerOpen",
    "lowsrc",
    "lvb",
    "lvh",
    "lvi",
    "lvmax",
    "lvmin",
    "lvw",
    "m11",
    "m12",
    "m13",
    "m14",
    "m21",
    "m22",
    "m23",
    "m24",
    "m31",
    "m32",
    "m33",
    "m34",
    "m41",
    "m42",
    "m43",
    "m44",
    "magFilter",
    "makeXRCompatible",
    "managed",
    "management",
    "manifest",
    "manufacturer",
    "manufacturerName",
    "map",
    "mapAsync",
    "mapState",
    "mappedAtCreation",
    "mapping",
    "margin",
    "margin-block",
    "margin-block-end",
    "margin-block-start",
    "margin-bottom",
    "margin-inline",
    "margin-inline-end",
    "margin-inline-start",
    "margin-left",
    "margin-right",
    "margin-top",
    "marginBlock",
    "marginBlockEnd",
    "marginBlockStart",
    "marginBottom",
    "marginHeight",
    "marginInline",
    "marginInlineEnd",
    "marginInlineStart",
    "marginLeft",
    "marginRight",
    "marginTop",
    "marginWidth",
    "mark",
    "marker",
    "marker-end",
    "marker-mid",
    "marker-offset",
    "marker-start",
    "markerEnd",
    "markerHeight",
    "markerMid",
    "markerOffset",
    "markerStart",
    "markerUnits",
    "markerWidth",
    "marks",
    "mask",
    "mask-clip",
    "mask-composite",
    "mask-image",
    "mask-mode",
    "mask-origin",
    "mask-position",
    "mask-position-x",
    "mask-position-y",
    "mask-repeat",
    "mask-size",
    "mask-type",
    "maskClip",
    "maskComposite",
    "maskContentUnits",
    "maskImage",
    "maskMode",
    "maskOrigin",
    "maskPosition",
    "maskPositionX",
    "maskPositionY",
    "maskRepeat",
    "maskSize",
    "maskType",
    "maskUnits",
    "match",
    "matchAll",
    "matchMedia",
    "matchMedium",
    "matchPatterns",
    "matches",
    "math-depth",
    "math-style",
    "mathDepth",
    "mathStyle",
    "matrix",
    "matrixTransform",
    "max",
    "max-block-size",
    "max-height",
    "max-inline-size",
    "max-width",
    "maxActions",
    "maxAlternatives",
    "maxAnisotropy",
    "maxBindGroups",
    "maxBindGroupsPlusVertexBuffers",
    "maxBindingsPerBindGroup",
    "maxBlockSize",
    "maxBufferSize",
    "maxByteLength",
    "maxChannelCount",
    "maxChannels",
    "maxColorAttachmentBytesPerSample",
    "maxColorAttachments",
    "maxComputeInvocationsPerWorkgroup",
    "maxComputeWorkgroupSizeX",
    "maxComputeWorkgroupSizeY",
    "maxComputeWorkgroupSizeZ",
    "maxComputeWorkgroupStorageSize",
    "maxComputeWorkgroupsPerDimension",
    "maxConnectionsPerServer",
    "maxDatagramSize",
    "maxDecibels",
    "maxDistance",
    "maxDrawCount",
    "maxDynamicStorageBuffersPerPipelineLayout",
    "maxDynamicUniformBuffersPerPipelineLayout",
    "maxHeight",
    "maxInlineSize",
    "maxInterStageShaderComponents",
    "maxInterStageShaderVariables",
    "maxLayers",
    "maxLength",
    "maxMessageSize",
    "maxPacketLifeTime",
    "maxRetransmits",
    "maxSampledTexturesPerShaderStage",
    "maxSamplersPerShaderStage",
    "maxStorageBufferBindingSize",
    "maxStorageBuffersPerShaderStage",
    "maxStorageTexturesPerShaderStage",
    "maxTextureArrayLayers",
    "maxTextureDimension1D",
    "maxTextureDimension2D",
    "maxTextureDimension3D",
    "maxTouchPoints",
    "maxUniformBufferBindingSize",
    "maxUniformBuffersPerShaderStage",
    "maxValue",
    "maxVertexAttributes",
    "maxVertexBufferArrayStride",
    "maxVertexBuffers",
    "maxWidth",
    "maximumLatency",
    "measure",
    "measureText",
    "media",
    "mediaCapabilities",
    "mediaDevices",
    "mediaElement",
    "mediaGroup",
    "mediaKeys",
    "mediaSession",
    "mediaStream",
    "mediaText",
    "meetOrSlice",
    "memory",
    "menubar",
    "menus",
    "menusChild",
    "menusInternal",
    "mergeAttributes",
    "message",
    "messageClass",
    "messageHandlers",
    "messageType",
    "messages",
    "metaKey",
    "metadata",
    "method",
    "methodDetails",
    "methodName",
    "mid",
    "mimeType",
    "mimeTypes",
    "min",
    "min-block-size",
    "min-height",
    "min-inline-size",
    "min-width",
    "minBindingSize",
    "minBlockSize",
    "minDecibels",
    "minFilter",
    "minHeight",
    "minInlineSize",
    "minLength",
    "minStorageBufferOffsetAlignment",
    "minUniformBufferOffsetAlignment",
    "minValue",
    "minWidth",
    "minimumLatency",
    "mipLevel",
    "mipLevelCount",
    "mipmapFilter",
    "miterLimit",
    "mix-blend-mode",
    "mixBlendMode",
    "mm",
    "mobile",
    "mode",
    "model",
    "modify",
    "module",
    "mount",
    "move",
    "moveBy",
    "moveEnd",
    "moveFirst",
    "moveFocusDown",
    "moveFocusLeft",
    "moveFocusRight",
    "moveFocusUp",
    "moveInSuccession",
    "moveNext",
    "moveRow",
    "moveStart",
    "moveTo",
    "moveToBookmark",
    "moveToElementText",
    "moveToPoint",
    "movementX",
    "movementY",
    "mozAdd",
    "mozAnimationStartTime",
    "mozAnon",
    "mozApps",
    "mozAudioCaptured",
    "mozAudioChannelType",
    "mozAutoplayEnabled",
    "mozCancelAnimationFrame",
    "mozCancelFullScreen",
    "mozCancelRequestAnimationFrame",
    "mozCaptureStream",
    "mozCaptureStreamUntilEnded",
    "mozClearDataAt",
    "mozContact",
    "mozContacts",
    "mozCreateFileHandle",
    "mozCurrentTransform",
    "mozCurrentTransformInverse",
    "mozCursor",
    "mozDash",
    "mozDashOffset",
    "mozDecodedFrames",
    "mozExitPointerLock",
    "mozFillRule",
    "mozFragmentEnd",
    "mozFrameDelay",
    "mozFullScreen",
    "mozFullScreenElement",
    "mozFullScreenEnabled",
    "mozGetAll",
    "mozGetAllKeys",
    "mozGetAsFile",
    "mozGetDataAt",
    "mozGetMetadata",
    "mozGetUserMedia",
    "mozHasAudio",
    "mozHasItem",
    "mozHidden",
    "mozImageSmoothingEnabled",
    "mozIndexedDB",
    "mozInnerScreenX",
    "mozInnerScreenY",
    "mozInputSource",
    "mozIsTextField",
    "mozItem",
    "mozItemCount",
    "mozItems",
    "mozLength",
    "mozLockOrientation",
    "mozMatchesSelector",
    "mozMovementX",
    "mozMovementY",
    "mozOpaque",
    "mozOrientation",
    "mozPaintCount",
    "mozPaintedFrames",
    "mozParsedFrames",
    "mozPay",
    "mozPointerLockElement",
    "mozPresentedFrames",
    "mozPreservesPitch",
    "mozPressure",
    "mozPrintCallback",
    "mozRTCIceCandidate",
    "mozRTCPeerConnection",
    "mozRTCSessionDescription",
    "mozRemove",
    "mozRequestAnimationFrame",
    "mozRequestFullScreen",
    "mozRequestPointerLock",
    "mozSetDataAt",
    "mozSetImageElement",
    "mozSourceNode",
    "mozSrcObject",
    "mozSystem",
    "mozTCPSocket",
    "mozTextStyle",
    "mozTypesAt",
    "mozUnlockOrientation",
    "mozUserCancelled",
    "mozVisibilityState",
    "ms",
    "msAnimation",
    "msAnimationDelay",
    "msAnimationDirection",
    "msAnimationDuration",
    "msAnimationFillMode",
    "msAnimationIterationCount",
    "msAnimationName",
    "msAnimationPlayState",
    "msAnimationStartTime",
    "msAnimationTimingFunction",
    "msBackfaceVisibility",
    "msBlockProgression",
    "msCSSOMElementFloatMetrics",
    "msCaching",
    "msCachingEnabled",
    "msCancelRequestAnimationFrame",
    "msCapsLockWarningOff",
    "msClearImmediate",
    "msClose",
    "msContentZoomChaining",
    "msContentZoomFactor",
    "msContentZoomLimit",
    "msContentZoomLimitMax",
    "msContentZoomLimitMin",
    "msContentZoomSnap",
    "msContentZoomSnapPoints",
    "msContentZoomSnapType",
    "msContentZooming",
    "msConvertURL",
    "msCrypto",
    "msDoNotTrack",
    "msElementsFromPoint",
    "msElementsFromRect",
    "msExitFullscreen",
    "msExtendedCode",
    "msFillRule",
    "msFirstPaint",
    "msFlex",
    "msFlexAlign",
    "msFlexDirection",
    "msFlexFlow",
    "msFlexItemAlign",
    "msFlexLinePack",
    "msFlexNegative",
    "msFlexOrder",
    "msFlexPack",
    "msFlexPositive",
    "msFlexPreferredSize",
    "msFlexWrap",
    "msFlowFrom",
    "msFlowInto",
    "msFontFeatureSettings",
    "msFullscreenElement",
    "msFullscreenEnabled",
    "msGetInputContext",
    "msGetRegionContent",
    "msGetUntransformedBounds",
    "msGraphicsTrustStatus",
    "msGridColumn",
    "msGridColumnAlign",
    "msGridColumnSpan",
    "msGridColumns",
    "msGridRow",
    "msGridRowAlign",
    "msGridRowSpan",
    "msGridRows",
    "msHidden",
    "msHighContrastAdjust",
    "msHyphenateLimitChars",
    "msHyphenateLimitLines",
    "msHyphenateLimitZone",
    "msHyphens",
    "msImageSmoothingEnabled",
    "msImeAlign",
    "msIndexedDB",
    "msInterpolationMode",
    "msIsStaticHTML",
    "msKeySystem",
    "msKeys",
    "msLaunchUri",
    "msLockOrientation",
    "msManipulationViewsEnabled",
    "msMatchMedia",
    "msMatchesSelector",
    "msMaxTouchPoints",
    "msOrientation",
    "msOverflowStyle",
    "msPerspective",
    "msPerspectiveOrigin",
    "msPlayToDisabled",
    "msPlayToPreferredSourceUri",
    "msPlayToPrimary",
    "msPointerEnabled",
    "msRegionOverflow",
    "msReleasePointerCapture",
    "msRequestAnimationFrame",
    "msRequestFullscreen",
    "msSaveBlob",
    "msSaveOrOpenBlob",
    "msScrollChaining",
    "msScrollLimit",
    "msScrollLimitXMax",
    "msScrollLimitXMin",
    "msScrollLimitYMax",
    "msScrollLimitYMin",
    "msScrollRails",
    "msScrollSnapPointsX",
    "msScrollSnapPointsY",
    "msScrollSnapType",
    "msScrollSnapX",
    "msScrollSnapY",
    "msScrollTranslation",
    "msSetImmediate",
    "msSetMediaKeys",
    "msSetPointerCapture",
    "msTextCombineHorizontal",
    "msTextSizeAdjust",
    "msToBlob",
    "msTouchAction",
    "msTouchSelect",
    "msTraceAsyncCallbackCompleted",
    "msTraceAsyncCallbackStarting",
    "msTraceAsyncOperationCompleted",
    "msTraceAsyncOperationStarting",
    "msTransform",
    "msTransformOrigin",
    "msTransformStyle",
    "msTransition",
    "msTransitionDelay",
    "msTransitionDuration",
    "msTransitionProperty",
    "msTransitionTimingFunction",
    "msUnlockOrientation",
    "msUpdateAsyncCallbackRelation",
    "msUserSelect",
    "msVisibilityState",
    "msWrapFlow",
    "msWrapMargin",
    "msWrapThrough",
    "msWriteProfilerMark",
    "msZoom",
    "msZoomTo",
    "mt",
    "mul",
    "multiEntry",
    "multiSelectionObj",
    "multiline",
    "multiple",
    "multiply",
    "multiplySelf",
    "multisample",
    "multisampled",
    "mutableFile",
    "muted",
    "n",
    "nacl_arch",
    "name",
    "nameList",
    "nameProp",
    "namedItem",
    "namedRecordset",
    "names",
    "namespaceURI",
    "namespaces",
    "nativeApplication",
    "nativeMap",
    "nativeObjectCreate",
    "nativeSet",
    "nativeWeakMap",
    "naturalHeight",
    "naturalWidth",
    "navigate",
    "navigation",
    "navigationMode",
    "navigationPreload",
    "navigationStart",
    "navigationType",
    "navigator",
    "near",
    "nearestViewportElement",
    "negative",
    "negotiated",
    "netscape",
    "networkState",
    "networkStatus",
    "newScale",
    "newState",
    "newTranslate",
    "newURL",
    "newValue",
    "newValueSpecifiedUnits",
    "newVersion",
    "newhome",
    "next",
    "nextElementSibling",
    "nextHopProtocol",
    "nextNode",
    "nextPage",
    "nextSibling",
    "nickname",
    "noHref",
    "noModule",
    "noResize",
    "noShade",
    "noValidate",
    "noWrap",
    "node",
    "nodeName",
    "nodeType",
    "nodeValue",
    "nonce",
    "normDepthBufferFromNormView",
    "normalize",
    "normalizedPathSegList",
    "normandyAddonStudy",
    "notRestoredReasons",
    "notationName",
    "notations",
    "note",
    "noteGrainOn",
    "noteOff",
    "noteOn",
    "notifications",
    "notify",
    "now",
    "npnNegotiatedProtocol",
    "numOctaves",
    "number",
    "numberOfChannels",
    "numberOfFrames",
    "numberOfInputs",
    "numberOfItems",
    "numberOfOutputs",
    "numberValue",
    "oMatchesSelector",
    "object",
    "object-fit",
    "object-position",
    "objectFit",
    "objectPosition",
    "objectStore",
    "objectStoreNames",
    "objectType",
    "observe",
    "occlusionQuerySet",
    "of",
    "off",
    "offscreenBuffering",
    "offset",
    "offset-anchor",
    "offset-distance",
    "offset-path",
    "offset-position",
    "offset-rotate",
    "offsetAnchor",
    "offsetDistance",
    "offsetHeight",
    "offsetLeft",
    "offsetNode",
    "offsetParent",
    "offsetPath",
    "offsetPosition",
    "offsetRotate",
    "offsetTop",
    "offsetWidth",
    "offsetX",
    "offsetY",
    "ok",
    "oldState",
    "oldURL",
    "oldValue",
    "oldVersion",
    "olderShadowRoot",
    "omnibox",
    "on",
    "onActivated",
    "onAdded",
    "onAttached",
    "onBoundsChanged",
    "onBrowserUpdateAvailable",
    "onClicked",
    "onCommitFiberRoot",
    "onCommitFiberUnmount",
    "onConnect",
    "onConnectExternal",
    "onConnectNative",
    "onCreated",
    "onDetached",
    "onDisabled",
    "onEnabled",
    "onFocusChanged",
    "onHighlighted",
    "onInstalled",
    "onLine",
    "onMessage",
    "onMessageExternal",
    "onMoved",
    "onPerformanceWarning",
    "onPostCommitFiberRoot",
    "onRemoved",
    "onReplaced",
    "onRestartRequired",
    "onStartup",
    "onSubmittedWorkDone",
    "onSuspend",
    "onSuspendCanceled",
    "onUninstalled",
    "onUpdateAvailable",
    "onUpdated",
    "onUserScriptConnect",
    "onUserScriptMessage",
    "onUserSettingsChanged",
    "onZoomChange",
    "onabort",
    "onabsolutedeviceorientation",
    "onactivate",
    "onactive",
    "onaddsourcebuffer",
    "onaddstream",
    "onaddtrack",
    "onafterprint",
    "onafterscriptexecute",
    "onafterupdate",
    "onanimationcancel",
    "onanimationend",
    "onanimationiteration",
    "onanimationstart",
    "onappinstalled",
    "onaudioend",
    "onaudioprocess",
    "onaudiostart",
    "onautocomplete",
    "onautocompleteerror",
    "onauxclick",
    "onbeforeactivate",
    "onbeforecopy",
    "onbeforecut",
    "onbeforedeactivate",
    "onbeforeeditfocus",
    "onbeforeinput",
    "onbeforeinstallprompt",
    "onbeforematch",
    "onbeforepaste",
    "onbeforeprint",
    "onbeforescriptexecute",
    "onbeforetoggle",
    "onbeforeunload",
    "onbeforeupdate",
    "onbeforexrselect",
    "onbegin",
    "onblocked",
    "onblur",
    "onbounce",
    "onboundary",
    "onbufferedamountlow",
    "oncached",
    "oncancel",
    "oncandidatewindowhide",
    "oncandidatewindowshow",
    "oncandidatewindowupdate",
    "oncanplay",
    "oncanplaythrough",
    "oncapturehandlechange",
    "once",
    "oncellchange",
    "onchange",
    "oncharacterboundsupdate",
    "oncharacteristicvaluechanged",
    "onchargingchange",
    "onchargingtimechange",
    "onchecking",
    "onclick",
    "onclose",
    "onclosing",
    "oncompassneedscalibration",
    "oncomplete",
    "oncompositionend",
    "oncompositionstart",
    "onconnect",
    "onconnecting",
    "onconnectionavailable",
    "onconnectionstatechange",
    "oncontentvisibilityautostatechange",
    "oncontextlost",
    "oncontextmenu",
    "oncontextrestored",
    "oncontrollerchange",
    "oncontrolselect",
    "oncopy",
    "oncuechange",
    "oncurrententrychange",
    "oncurrentscreenchange",
    "oncut",
    "ondataavailable",
    "ondatachannel",
    "ondatasetchanged",
    "ondatasetcomplete",
    "ondblclick",
    "ondeactivate",
    "ondequeue",
    "ondevicechange",
    "ondevicelight",
    "ondevicemotion",
    "ondeviceorientation",
    "ondeviceorientationabsolute",
    "ondeviceproximity",
    "ondischargingtimechange",
    "ondisconnect",
    "ondisplay",
    "ondispose",
    "ondownloading",
    "ondrag",
    "ondragend",
    "ondragenter",
    "ondragexit",
    "ondragleave",
    "ondragover",
    "ondragstart",
    "ondrop",
    "ondurationchange",
    "onemptied",
    "onencrypted",
    "onend",
    "onended",
    "onenter",
    "onenterpictureinpicture",
    "onerror",
    "onerrorupdate",
    "onexit",
    "onfencedtreeclick",
    "onfilterchange",
    "onfinish",
    "onfocus",
    "onfocusin",
    "onfocusout",
    "onformdata",
    "onfreeze",
    "onfullscreenchange",
    "onfullscreenerror",
    "ongamepadconnected",
    "ongamepaddisconnected",
    "ongatheringstatechange",
    "ongattserverdisconnected",
    "ongeometrychange",
    "ongesturechange",
    "ongestureend",
    "ongesturestart",
    "ongotpointercapture",
    "onhashchange",
    "onhelp",
    "onicecandidate",
    "onicecandidateerror",
    "oniceconnectionstatechange",
    "onicegatheringstatechange",
    "oninactive",
    "oninput",
    "oninputreport",
    "oninputsourceschange",
    "oninvalid",
    "onkeydown",
    "onkeypress",
    "onkeystatuseschange",
    "onkeyup",
    "onlanguagechange",
    "onlayoutcomplete",
    "onleavepictureinpicture",
    "onlevelchange",
    "onload",
    "onloadT",
    "onloadeddata",
    "onloadedmetadata",
    "onloadend",
    "onloading",
    "onloadingdone",
    "onloadingerror",
    "onloadstart",
    "onlosecapture",
    "onlostpointercapture",
    "only",
    "onmanagedconfigurationchange",
    "onmark",
    "onmessage",
    "onmessageerror",
    "onmidimessage",
    "onmousedown",
    "onmouseenter",
    "onmouseleave",
    "onmousemove",
    "onmouseout",
    "onmouseover",
    "onmouseup",
    "onmousewheel",
    "onmove",
    "onmoveend",
    "onmovestart",
    "onmozfullscreenchange",
    "onmozfullscreenerror",
    "onmozorientationchange",
    "onmozpointerlockchange",
    "onmozpointerlockerror",
    "onmscontentzoom",
    "onmsfullscreenchange",
    "onmsfullscreenerror",
    "onmsgesturechange",
    "onmsgesturedoubletap",
    "onmsgestureend",
    "onmsgesturehold",
    "onmsgesturestart",
    "onmsgesturetap",
    "onmsgotpointercapture",
    "onmsinertiastart",
    "onmslostpointercapture",
    "onmsmanipulationstatechanged",
    "onmsneedkey",
    "onmsorientationchange",
    "onmspointercancel",
    "onmspointerdown",
    "onmspointerenter",
    "onmspointerhover",
    "onmspointerleave",
    "onmspointermove",
    "onmspointerout",
    "onmspointerover",
    "onmspointerup",
    "onmssitemodejumplistitemremoved",
    "onmsthumbnailclick",
    "onmute",
    "onnavigate",
    "onnavigateerror",
    "onnavigatesuccess",
    "onnegotiationneeded",
    "onnomatch",
    "onnoupdate",
    "onobsolete",
    "onoffline",
    "ononline",
    "onopen",
    "onorientationchange",
    "onpagechange",
    "onpagehide",
    "onpagereveal",
    "onpageshow",
    "onpageswap",
    "onpaste",
    "onpause",
    "onpayerdetailchange",
    "onpaymentmethodchange",
    "onplay",
    "onplaying",
    "onpluginstreamstart",
    "onpointercancel",
    "onpointerdown",
    "onpointerenter",
    "onpointerleave",
    "onpointerlockchange",
    "onpointerlockerror",
    "onpointermove",
    "onpointerout",
    "onpointerover",
    "onpointerrawupdate",
    "onpointerup",
    "onpopstate",
    "onprerenderingchange",
    "onprioritychange",
    "onprocessorerror",
    "onprogress",
    "onpropertychange",
    "onratechange",
    "onreading",
    "onreadystatechange",
    "onreflectionchange",
    "onrejectionhandled",
    "onrelease",
    "onremove",
    "onremovesourcebuffer",
    "onremovestream",
    "onremovetrack",
    "onrepeat",
    "onreset",
    "onresize",
    "onresizeend",
    "onresizestart",
    "onresourcetimingbufferfull",
    "onresult",
    "onresume",
    "onrowenter",
    "onrowexit",
    "onrowsdelete",
    "onrowsinserted",
    "onscreenschange",
    "onscroll",
    "onscrollend",
    "onscrollsnapchange",
    "onscrollsnapchanging",
    "onsearch",
    "onsecuritypolicyviolation",
    "onseeked",
    "onseeking",
    "onselect",
    "onselectedcandidatepairchange",
    "onselectend",
    "onselectionchange",
    "onselectstart",
    "onshippingaddresschange",
    "onshippingoptionchange",
    "onshow",
    "onsignalingstatechange",
    "onsinkchange",
    "onslotchange",
    "onsoundend",
    "onsoundstart",
    "onsourceclose",
    "onsourceclosed",
    "onsourceended",
    "onsourceopen",
    "onspeechend",
    "onspeechstart",
    "onsqueeze",
    "onsqueezeend",
    "onsqueezestart",
    "onstalled",
    "onstart",
    "onstatechange",
    "onstop",
    "onstorage",
    "onstoragecommit",
    "onsubmit",
    "onsuccess",
    "onsuspend",
    "onterminate",
    "ontextformatupdate",
    "ontextinput",
    "ontextupdate",
    "ontimeout",
    "ontimeupdate",
    "ontoggle",
    "ontonechange",
    "ontouchcancel",
    "ontouchend",
    "ontouchmove",
    "ontouchstart",
    "ontrack",
    "ontransitioncancel",
    "ontransitionend",
    "ontransitionrun",
    "ontransitionstart",
    "onuncapturederror",
    "onunhandledrejection",
    "onunload",
    "onunmute",
    "onupdate",
    "onupdateend",
    "onupdatefound",
    "onupdateready",
    "onupdatestart",
    "onupgradeneeded",
    "onuserproximity",
    "onversionchange",
    "onvisibilitychange",
    "onvoiceschanged",
    "onvolumechange",
    "onvrdisplayactivate",
    "onvrdisplayconnect",
    "onvrdisplaydeactivate",
    "onvrdisplaydisconnect",
    "onvrdisplaypresentchange",
    "onwaiting",
    "onwaitingforkey",
    "onwarning",
    "onwebkitanimationend",
    "onwebkitanimationiteration",
    "onwebkitanimationstart",
    "onwebkitcurrentplaybacktargetiswirelesschanged",
    "onwebkitfullscreenchange",
    "onwebkitfullscreenerror",
    "onwebkitkeyadded",
    "onwebkitkeyerror",
    "onwebkitkeymessage",
    "onwebkitneedkey",
    "onwebkitorientationchange",
    "onwebkitplaybacktargetavailabilitychanged",
    "onwebkitpointerlockchange",
    "onwebkitpointerlockerror",
    "onwebkitresourcetimingbufferfull",
    "onwebkittransitionend",
    "onwheel",
    "onzoom",
    "opacity",
    "open",
    "openCursor",
    "openDatabase",
    "openKeyCursor",
    "openOptionsPage",
    "openOrClosedShadowRoot",
    "openPopup",
    "opened",
    "opener",
    "opera",
    "operation",
    "operationType",
    "operator",
    "opr",
    "optimum",
    "options",
    "or",
    "order",
    "orderX",
    "orderY",
    "ordered",
    "org",
    "organization",
    "orient",
    "orientAngle",
    "orientType",
    "orientation",
    "orientationX",
    "orientationY",
    "orientationZ",
    "origin",
    "originAgentCluster",
    "originalPolicy",
    "originalTarget",
    "orphans",
    "os",
    "oscpu",
    "outerHTML",
    "outerHeight",
    "outerText",
    "outerWidth",
    "outgoingHighWaterMark",
    "outgoingMaxAge",
    "outline",
    "outline-color",
    "outline-offset",
    "outline-style",
    "outline-width",
    "outlineColor",
    "outlineOffset",
    "outlineStyle",
    "outlineWidth",
    "outputBuffer",
    "outputChannelCount",
    "outputLatency",
    "outputs",
    "overflow",
    "overflow-anchor",
    "overflow-block",
    "overflow-clip-margin",
    "overflow-inline",
    "overflow-wrap",
    "overflow-x",
    "overflow-y",
    "overflowAnchor",
    "overflowBlock",
    "overflowClipMargin",
    "overflowInline",
    "overflowWrap",
    "overflowX",
    "overflowY",
    "overlaysContent",
    "overrideColors",
    "overrideMimeType",
    "oversample",
    "overscroll-behavior",
    "overscroll-behavior-block",
    "overscroll-behavior-inline",
    "overscroll-behavior-x",
    "overscroll-behavior-y",
    "overscrollBehavior",
    "overscrollBehaviorBlock",
    "overscrollBehaviorInline",
    "overscrollBehaviorX",
    "overscrollBehaviorY",
    "ownKeys",
    "ownerDocument",
    "ownerElement",
    "ownerNode",
    "ownerRule",
    "ownerSVGElement",
    "owningElement",
    "p1",
    "p2",
    "p3",
    "p4",
    "packetSize",
    "packets",
    "pad",
    "padEnd",
    "padStart",
    "padding",
    "padding-block",
    "padding-block-end",
    "padding-block-start",
    "padding-bottom",
    "padding-inline",
    "padding-inline-end",
    "padding-inline-start",
    "padding-left",
    "padding-right",
    "padding-top",
    "paddingBlock",
    "paddingBlockEnd",
    "paddingBlockStart",
    "paddingBottom",
    "paddingInline",
    "paddingInlineEnd",
    "paddingInlineStart",
    "paddingLeft",
    "paddingRight",
    "paddingTop",
    "page",
    "page-break-after",
    "page-break-before",
    "page-break-inside",
    "page-orientation",
    "pageAction",
    "pageBreakAfter",
    "pageBreakBefore",
    "pageBreakInside",
    "pageCount",
    "pageLeft",
    "pageOrientation",
    "pageT",
    "pageTop",
    "pageX",
    "pageXOffset",
    "pageY",
    "pageYOffset",
    "pages",
    "paint-order",
    "paintOrder",
    "paintRequests",
    "paintType",
    "paintWorklet",
    "palette",
    "pan",
    "panningModel",
    "parameterData",
    "parameters",
    "parent",
    "parentElement",
    "parentNode",
    "parentRule",
    "parentStyleSheet",
    "parentTextEdit",
    "parentWindow",
    "parse",
    "parseAll",
    "parseCreationOptionsFromJSON",
    "parseFloat",
    "parseFromString",
    "parseHTMLUnsafe",
    "parseInt",
    "parseRequestOptionsFromJSON",
    "part",
    "participants",
    "passOp",
    "passive",
    "password",
    "pasteHTML",
    "path",
    "pathLength",
    "pathSegList",
    "pathSegType",
    "pathSegTypeAsLetter",
    "pathname",
    "pattern",
    "patternContentUnits",
    "patternMismatch",
    "patternTransform",
    "patternUnits",
    "pause",
    "pauseAnimations",
    "pauseDuration",
    "pauseOnExit",
    "pauseProfilers",
    "pauseTransformFeedback",
    "paused",
    "payerEmail",
    "payerName",
    "payerPhone",
    "paymentManager",
    "pc",
    "pdfViewerEnabled",
    "peerIdentity",
    "pending",
    "pendingLocalDescription",
    "pendingRemoteDescription",
    "percent",
    "performance",
    "periodicSync",
    "permission",
    "permissionState",
    "permissions",
    "persist",
    "persisted",
    "persistentDeviceId",
    "personalbar",
    "perspective",
    "perspective-origin",
    "perspectiveOrigin",
    "phone",
    "phoneticFamilyName",
    "phoneticGivenName",
    "photo",
    "pictureInPictureChild",
    "pictureInPictureElement",
    "pictureInPictureEnabled",
    "pictureInPictureWindow",
    "ping",
    "pipeThrough",
    "pipeTo",
    "pitch",
    "pixelBottom",
    "pixelDepth",
    "pixelHeight",
    "pixelLeft",
    "pixelRight",
    "pixelStorei",
    "pixelTop",
    "pixelUnitToMillimeterX",
    "pixelUnitToMillimeterY",
    "pixelWidth",
    "pkcs11",
    "place-content",
    "place-items",
    "place-self",
    "placeContent",
    "placeItems",
    "placeSelf",
    "placeholder",
    "platform",
    "platformVersion",
    "platforms",
    "play",
    "playEffect",
    "playState",
    "playbackRate",
    "playbackState",
    "playbackTime",
    "played",
    "playoutDelayHint",
    "playsInline",
    "plugins",
    "pluginspage",
    "pname",
    "pointer-events",
    "pointerBeforeReferenceNode",
    "pointerEnabled",
    "pointerEvents",
    "pointerId",
    "pointerLockElement",
    "pointerType",
    "points",
    "pointsAtX",
    "pointsAtY",
    "pointsAtZ",
    "polygonOffset",
    "pop",
    "popDebugGroup",
    "popErrorScope",
    "popover",
    "popoverTargetAction",
    "popoverTargetElement",
    "populateMatrix",
    "popupWindowFeatures",
    "popupWindowName",
    "popupWindowURI",
    "port",
    "port1",
    "port2",
    "ports",
    "posBottom",
    "posHeight",
    "posLeft",
    "posRight",
    "posTop",
    "posWidth",
    "pose",
    "position",
    "position-anchor",
    "position-area",
    "positionAlign",
    "positionAnchor",
    "positionArea",
    "positionX",
    "positionY",
    "positionZ",
    "postError",
    "postMessage",
    "postTask",
    "postalCode",
    "poster",
    "postscriptName",
    "pow",
    "powerEfficient",
    "powerOff",
    "powerPreference",
    "preMultiplySelf",
    "precision",
    "preferredReflectionFormat",
    "preferredStyleSheetSet",
    "preferredStylesheetSet",
    "prefix",
    "preload",
    "premultipliedAlpha",
    "prepend",
    "prerendering",
    "presentation",
    "presentationArea",
    "presentationStyle",
    "preserveAlpha",
    "preserveAspectRatio",
    "preserveAspectRatioString",
    "preservesPitch",
    "pressed",
    "pressure",
    "prevValue",
    "preventDefault",
    "preventExtensions",
    "preventSilentAccess",
    "previousElementSibling",
    "previousNode",
    "previousPage",
    "previousPriority",
    "previousRect",
    "previousScale",
    "previousSibling",
    "previousTranslate",
    "primaries",
    "primaryKey",
    "primaryLightDirection",
    "primaryLightIntensity",
    "primitive",
    "primitiveType",
    "primitiveUnits",
    "principals",
    "print",
    "print-color-adjust",
    "printColorAdjust",
    "printPreview",
    "priority",
    "privacy",
    "privateKey",
    "privateToken",
    "probablySupportsContext",
    "probeSpace",
    "process",
    "processIceMessage",
    "processingEnd",
    "processingStart",
    "processorOptions",
    "product",
    "productId",
    "productName",
    "productSub",
    "profile",
    "profileEnd",
    "profiles",
    "projectionMatrix",
    "promise",
    "prompt",
    "properties",
    "propertyIsEnumerable",
    "propertyName",
    "protectedAudience",
    "protocol",
    "protocolLong",
    "prototype",
    "provider",
    "proxy",
    "pseudoClass",
    "pseudoElement",
    "pt",
    "publicId",
    "publicKey",
    "published",
    "pulse",
    "push",
    "pushDebugGroup",
    "pushErrorScope",
    "pushManager",
    "pushNotification",
    "pushState",
    "put",
    "putImageData",
    "px",
    "quadraticCurveTo",
    "qualifier",
    "quaternion",
    "query",
    "queryCommandEnabled",
    "queryCommandIndeterm",
    "queryCommandState",
    "queryCommandSupported",
    "queryCommandText",
    "queryCommandValue",
    "queryFeatureSupport",
    "queryLocalFonts",
    "queryPermission",
    "querySelector",
    "querySelectorAll",
    "querySet",
    "queue",
    "queueMicrotask",
    "quote",
    "quotes",
    "r",
    "r1",
    "r2",
    "race",
    "rad",
    "radiogroup",
    "radius",
    "radiusX",
    "radiusY",
    "random",
    "randomUUID",
    "range",
    "rangeCount",
    "rangeEnd",
    "rangeMax",
    "rangeMin",
    "rangeOffset",
    "rangeOverflow",
    "rangeParent",
    "rangeStart",
    "rangeUnderflow",
    "rate",
    "ratio",
    "raw",
    "rawId",
    "rawJSON",
    "rawValueToMeters",
    "rcap",
    "rch",
    "read",
    "readAsArrayBuffer",
    "readAsBinaryString",
    "readAsBlob",
    "readAsDataURL",
    "readAsText",
    "readBuffer",
    "readEntries",
    "readOnly",
    "readPixels",
    "readReportRequested",
    "readText",
    "readValue",
    "readable",
    "ready",
    "readyState",
    "reason",
    "reasons",
    "reboot",
    "receiveFeatureReport",
    "receivedAlert",
    "receiver",
    "receivers",
    "recipient",
    "recommendedViewportScale",
    "reconnect",
    "recordNumber",
    "recordsAvailable",
    "recordset",
    "rect",
    "red",
    "redEyeReduction",
    "redirect",
    "redirectCount",
    "redirectEnd",
    "redirectStart",
    "redirected",
    "reduce",
    "reduceRight",
    "reduction",
    "refDistance",
    "refX",
    "refY",
    "referenceNode",
    "referenceSpace",
    "referrer",
    "referrerPolicy",
    "refresh",
    "region",
    "regionAnchorX",
    "regionAnchorY",
    "regionId",
    "regions",
    "register",
    "registerContentHandler",
    "registerElement",
    "registerInternalModuleStart",
    "registerInternalModuleStop",
    "registerProperty",
    "registerProtocolHandler",
    "reject",
    "rel",
    "relList",
    "relatedAddress",
    "relatedNode",
    "relatedPort",
    "relatedTarget",
    "relayProtocol",
    "release",
    "releaseCapture",
    "releaseEvents",
    "releaseInterface",
    "releaseLock",
    "releasePointerCapture",
    "releaseShaderCompiler",
    "released",
    "reliability",
    "reliable",
    "reliableWrite",
    "reload",
    "rem",
    "remainingSpace",
    "remote",
    "remoteDescription",
    "remove",
    "removeAllRanges",
    "removeAttribute",
    "removeAttributeNS",
    "removeAttributeNode",
    "removeBehavior",
    "removeChild",
    "removeCue",
    "removeEntry",
    "removeEventListener",
    "removeFilter",
    "removeImport",
    "removeItem",
    "removeListener",
    "removeNamedItem",
    "removeNamedItemNS",
    "removeNode",
    "removeParameter",
    "removeProperty",
    "removeRange",
    "removeRegion",
    "removeRule",
    "removeSiteSpecificTrackingException",
    "removeSourceBuffer",
    "removeStream",
    "removeTrack",
    "removeVariable",
    "removeWakeLockListener",
    "removeWebWideTrackingException",
    "removed",
    "removedNodes",
    "renderBlockingStatus",
    "renderHeight",
    "renderStart",
    "renderState",
    "renderTime",
    "renderWidth",
    "renderbufferStorage",
    "renderbufferStorageMultisample",
    "renderedBuffer",
    "rendererInterfaces",
    "renderers",
    "renderingMode",
    "renotify",
    "repeat",
    "repetitionCount",
    "replace",
    "replaceAdjacentText",
    "replaceAll",
    "replaceChild",
    "replaceChildren",
    "replaceData",
    "replaceId",
    "replaceItem",
    "replaceNode",
    "replaceState",
    "replaceSync",
    "replaceTrack",
    "replaceWholeText",
    "replaceWith",
    "reportError",
    "reportEvent",
    "reportId",
    "reportValidity",
    "request",
    "requestAdapter",
    "requestAdapterInfo",
    "requestAnimationFrame",
    "requestAutocomplete",
    "requestClose",
    "requestData",
    "requestDevice",
    "requestFrame",
    "requestFullscreen",
    "requestHitTestSource",
    "requestHitTestSourceForTransientInput",
    "requestId",
    "requestIdleCallback",
    "requestLightProbe",
    "requestMIDIAccess",
    "requestMediaKeySystemAccess",
    "requestPermission",
    "requestPictureInPicture",
    "requestPointerLock",
    "requestPort",
    "requestPresent",
    "requestPresenter",
    "requestReferenceSpace",
    "requestSession",
    "requestStart",
    "requestStorageAccess",
    "requestStorageAccessFor",
    "requestSubmit",
    "requestTime",
    "requestUpdateCheck",
    "requestVideoFrameCallback",
    "requestViewportScale",
    "requestWindow",
    "requestingWindow",
    "requireInteraction",
    "required",
    "requiredExtensions",
    "requiredFeatures",
    "requiredLimits",
    "reset",
    "resetLatency",
    "resetPose",
    "resetTransform",
    "resizable",
    "resize",
    "resizeBy",
    "resizeTo",
    "resolve",
    "resolveQuerySet",
    "resolveTarget",
    "resource",
    "respond",
    "respondWithNewView",
    "response",
    "responseBody",
    "responseEnd",
    "responseReady",
    "responseStart",
    "responseStatus",
    "responseText",
    "responseType",
    "responseURL",
    "responseXML",
    "restart",
    "restartAfterDelay",
    "restartIce",
    "restore",
    "result",
    "resultIndex",
    "resultType",
    "results",
    "resume",
    "resumeProfilers",
    "resumeTransformFeedback",
    "retry",
    "returnValue",
    "rev",
    "reverse",
    "reversed",
    "revocable",
    "revokeObjectURL",
    "rex",
    "rgbColor",
    "ric",
    "right",
    "rightContext",
    "rightDegrees",
    "rightMargin",
    "rightProjectionMatrix",
    "rightViewMatrix",
    "rlh",
    "role",
    "rolloffFactor",
    "root",
    "rootBounds",
    "rootElement",
    "rootMargin",
    "rotate",
    "rotateAxisAngle",
    "rotateAxisAngleSelf",
    "rotateFromVector",
    "rotateFromVectorSelf",
    "rotateSelf",
    "rotation",
    "rotationAngle",
    "rotationRate",
    "round",
    "roundRect",
    "row-gap",
    "rowGap",
    "rowIndex",
    "rowSpan",
    "rows",
    "rowsPerImage",
    "rtcpTransport",
    "rtt",
    "ruby-align",
    "ruby-position",
    "rubyAlign",
    "rubyOverhang",
    "rubyPosition",
    "rules",
    "run",
    "runAdAuction",
    "runtime",
    "runtimeStyle",
    "rx",
    "ry",
    "s",
    "safari",
    "sameDocument",
    "sample",
    "sampleCount",
    "sampleCoverage",
    "sampleInterval",
    "sampleRate",
    "sampleType",
    "sampler",
    "samplerParameterf",
    "samplerParameteri",
    "sandbox",
    "save",
    "saveAsPDF",
    "saveData",
    "scale",
    "scale3d",
    "scale3dSelf",
    "scaleNonUniform",
    "scaleNonUniformSelf",
    "scaleSelf",
    "scheduler",
    "scheduling",
    "scheme",
    "scissor",
    "scope",
    "scopeName",
    "scoped",
    "screen",
    "screenBrightness",
    "screenEnabled",
    "screenLeft",
    "screenPixelToMillimeterX",
    "screenPixelToMillimeterY",
    "screenState",
    "screenTop",
    "screenX",
    "screenY",
    "screens",
    "scriptURL",
    "scripting",
    "scripts",
    "scroll",
    "scroll-behavior",
    "scroll-margin",
    "scroll-margin-block",
    "scroll-margin-block-end",
    "scroll-margin-block-start",
    "scroll-margin-bottom",
    "scroll-margin-inline",
    "scroll-margin-inline-end",
    "scroll-margin-inline-start",
    "scroll-margin-left",
    "scroll-margin-right",
    "scroll-margin-top",
    "scroll-padding",
    "scroll-padding-block",
    "scroll-padding-block-end",
    "scroll-padding-block-start",
    "scroll-padding-bottom",
    "scroll-padding-inline",
    "scroll-padding-inline-end",
    "scroll-padding-inline-start",
    "scroll-padding-left",
    "scroll-padding-right",
    "scroll-padding-top",
    "scroll-snap-align",
    "scroll-snap-stop",
    "scroll-snap-type",
    "scrollAmount",
    "scrollBehavior",
    "scrollBy",
    "scrollByLines",
    "scrollByPages",
    "scrollDelay",
    "scrollHeight",
    "scrollIntoView",
    "scrollIntoViewIfNeeded",
    "scrollLeft",
    "scrollLeftMax",
    "scrollMargin",
    "scrollMarginBlock",
    "scrollMarginBlockEnd",
    "scrollMarginBlockStart",
    "scrollMarginBottom",
    "scrollMarginInline",
    "scrollMarginInlineEnd",
    "scrollMarginInlineStart",
    "scrollMarginLeft",
    "scrollMarginRight",
    "scrollMarginTop",
    "scrollMaxX",
    "scrollMaxY",
    "scrollPadding",
    "scrollPaddingBlock",
    "scrollPaddingBlockEnd",
    "scrollPaddingBlockStart",
    "scrollPaddingBottom",
    "scrollPaddingInline",
    "scrollPaddingInlineEnd",
    "scrollPaddingInlineStart",
    "scrollPaddingLeft",
    "scrollPaddingRight",
    "scrollPaddingTop",
    "scrollRestoration",
    "scrollSnapAlign",
    "scrollSnapStop",
    "scrollSnapType",
    "scrollTo",
    "scrollTop",
    "scrollTopMax",
    "scrollWidth",
    "scrollX",
    "scrollY",
    "scrollbar-color",
    "scrollbar-gutter",
    "scrollbar-width",
    "scrollbar3dLightColor",
    "scrollbarArrowColor",
    "scrollbarBaseColor",
    "scrollbarColor",
    "scrollbarDarkShadowColor",
    "scrollbarFaceColor",
    "scrollbarGutter",
    "scrollbarHighlightColor",
    "scrollbarShadowColor",
    "scrollbarTrackColor",
    "scrollbarWidth",
    "scrollbars",
    "scrolling",
    "scrollingElement",
    "sctp",
    "sctpCauseCode",
    "sdp",
    "sdpLineNumber",
    "sdpMLineIndex",
    "sdpMid",
    "seal",
    "search",
    "searchBox",
    "searchBoxJavaBridge_",
    "searchParams",
    "sectionRowIndex",
    "secureConnectionStart",
    "security",
    "seed",
    "seek",
    "seekToNextFrame",
    "seekable",
    "seeking",
    "select",
    "selectAllChildren",
    "selectAlternateInterface",
    "selectAudioOutput",
    "selectConfiguration",
    "selectNode",
    "selectNodeContents",
    "selectNodes",
    "selectSingleNode",
    "selectSubString",
    "selectURL",
    "selected",
    "selectedIndex",
    "selectedOptions",
    "selectedStyleSheetSet",
    "selectedStylesheetSet",
    "selectedTrack",
    "selection",
    "selectionDirection",
    "selectionEnd",
    "selectionStart",
    "selector",
    "selectorText",
    "self",
    "send",
    "sendAsBinary",
    "sendBeacon",
    "sendFeatureReport",
    "sendMessage",
    "sendNativeMessage",
    "sendOrder",
    "sendReport",
    "sender",
    "sentAlert",
    "sentTimestamp",
    "separator",
    "serial",
    "serialNumber",
    "serializable",
    "serializeToString",
    "serverTiming",
    "service",
    "serviceWorker",
    "session",
    "sessionId",
    "sessionStorage",
    "sessions",
    "set",
    "setActionHandler",
    "setActive",
    "setAlpha",
    "setAppBadge",
    "setAttribute",
    "setAttributeNS",
    "setAttributeNode",
    "setAttributeNodeNS",
    "setAttributionReporting",
    "setBadgeBackgroundColor",
    "setBadgeText",
    "setBadgeTextColor",
    "setBaseAndExtent",
    "setBigInt64",
    "setBigUint64",
    "setBindGroup",
    "setBingCurrentSearchDefault",
    "setBlendConstant",
    "setCameraActive",
    "setCapture",
    "setCaptureHandleConfig",
    "setCodecPreferences",
    "setColor",
    "setCompositeOperation",
    "setConfiguration",
    "setConsumer",
    "setCurrentTime",
    "setCustomValidity",
    "setData",
    "setDate",
    "setDragImage",
    "setEnabled",
    "setEnd",
    "setEndAfter",
    "setEndBefore",
    "setEndPoint",
    "setExpires",
    "setFillColor",
    "setFilterRes",
    "setFloat16",
    "setFloat32",
    "setFloat64",
    "setFloatValue",
    "setFocusBehavior",
    "setFormValue",
    "setFromBase64",
    "setFromHex",
    "setFullYear",
    "setHTMLUnsafe",
    "setHeaderExtensionsToNegotiate",
    "setHeaderValue",
    "setHours",
    "setIcon",
    "setIdentityProvider",
    "setImmediate",
    "setIndexBuffer",
    "setInt16",
    "setInt32",
    "setInt8",
    "setInterval",
    "setItem",
    "setKeyframes",
    "setLineCap",
    "setLineDash",
    "setLineJoin",
    "setLineWidth",
    "setLiveSeekableRange",
    "setLocalDescription",
    "setMatrix",
    "setMatrixValue",
    "setMediaKeys",
    "setMicrophoneActive",
    "setMilliseconds",
    "setMinutes",
    "setMiterLimit",
    "setMonth",
    "setNamedItem",
    "setNamedItemNS",
    "setNonUserCodeExceptions",
    "setOrientToAngle",
    "setOrientToAuto",
    "setOrientation",
    "setOverrideHistoryNavigationMode",
    "setPaint",
    "setParameter",
    "setParameters",
    "setPeriodicWave",
    "setPipeline",
    "setPointerCapture",
    "setPopup",
    "setPosition",
    "setPositionState",
    "setPreference",
    "setPriority",
    "setPrivateToken",
    "setProperty",
    "setPrototypeOf",
    "setRGBColor",
    "setRGBColorICCColor",
    "setRadius",
    "setRangeText",
    "setRemoteDescription",
    "setReportEventDataForAutomaticBeacons",
    "setRequestHeader",
    "setResizable",
    "setResourceTimingBufferSize",
    "setRotate",
    "setScale",
    "setScissorRect",
    "setSeconds",
    "setSelectionRange",
    "setServerCertificate",
    "setShadow",
    "setSharedStorageContext",
    "setSignals",
    "setSinkId",
    "setSkewX",
    "setSkewY",
    "setStart",
    "setStartAfter",
    "setStartBefore",
    "setStatus",
    "setStdDeviation",
    "setStencilReference",
    "setStreams",
    "setStrictMode",
    "setStringValue",
    "setStrokeColor",
    "setSuggestResult",
    "setTargetAtTime",
    "setTargetValueAtTime",
    "setTime",
    "setTimeout",
    "setTitle",
    "setTransform",
    "setTranslate",
    "setUTCDate",
    "setUTCFullYear",
    "setUTCHours",
    "setUTCMilliseconds",
    "setUTCMinutes",
    "setUTCMonth",
    "setUTCSeconds",
    "setUint16",
    "setUint32",
    "setUint8",
    "setUninstallURL",
    "setUpdateUrlData",
    "setUri",
    "setValidity",
    "setValueAtTime",
    "setValueCurveAtTime",
    "setVariable",
    "setVelocity",
    "setVersion",
    "setVertexBuffer",
    "setViewport",
    "setYear",
    "setZoom",
    "setZoomSettings",
    "settingName",
    "settingValue",
    "sex",
    "shaderLocation",
    "shaderSource",
    "shadowBlur",
    "shadowColor",
    "shadowOffsetX",
    "shadowOffsetY",
    "shadowRoot",
    "shadowRootClonable",
    "shadowRootDelegatesFocus",
    "shadowRootMode",
    "shadowRootSerializable",
    "shape",
    "shape-image-threshold",
    "shape-margin",
    "shape-outside",
    "shape-rendering",
    "shapeImageThreshold",
    "shapeMargin",
    "shapeOutside",
    "shapeRendering",
    "share",
    "sharedStorage",
    "sharedStorageWritable",
    "sheet",
    "shift",
    "shiftKey",
    "shiftLeft",
    "shippingAddress",
    "shippingOption",
    "shippingType",
    "show",
    "showDirectoryPicker",
    "showHelp",
    "showModal",
    "showModalDialog",
    "showModelessDialog",
    "showNotification",
    "showOpenFilePicker",
    "showPicker",
    "showPopover",
    "showSaveFilePicker",
    "sidebar",
    "sidebarAction",
    "sign",
    "signal",
    "signalingState",
    "signature",
    "silent",
    "sin",
    "singleNodeValue",
    "sinh",
    "sinkId",
    "sittingToStandingTransform",
    "size",
    "sizeAdjust",
    "sizeToContent",
    "sizeX",
    "sizeZ",
    "sizes",
    "skewX",
    "skewXSelf",
    "skewY",
    "skewYSelf",
    "skipTransition",
    "skipped",
    "slice",
    "slope",
    "slot",
    "slotAssignment",
    "small",
    "smil",
    "smooth",
    "smoothingTimeConstant",
    "snapTargetBlock",
    "snapTargetInline",
    "snapToLines",
    "snapshotItem",
    "snapshotLength",
    "some",
    "sort",
    "sortingCode",
    "source",
    "sourceBuffer",
    "sourceBuffers",
    "sourceCapabilities",
    "sourceCharPosition",
    "sourceFile",
    "sourceFunctionName",
    "sourceIndex",
    "sourceMap",
    "sourceURL",
    "sources",
    "spacing",
    "span",
    "speak",
    "speakAs",
    "speaking",
    "species",
    "specified",
    "specularConstant",
    "specularExponent",
    "speechSynthesis",
    "speed",
    "speedOfSound",
    "spellcheck",
    "sphericalHarmonicsCoefficients",
    "splice",
    "split",
    "splitText",
    "spreadMethod",
    "sqrt",
    "src",
    "srcElement",
    "srcFactor",
    "srcFilter",
    "srcObject",
    "srcUrn",
    "srcdoc",
    "srclang",
    "srcset",
    "stack",
    "stackTraceLimit",
    "stacktrace",
    "stageParameters",
    "standalone",
    "standby",
    "start",
    "startContainer",
    "startE",
    "startIce",
    "startLoadTime",
    "startMessages",
    "startNotifications",
    "startOffset",
    "startProfiling",
    "startRendering",
    "startShark",
    "startTime",
    "startViewTransition",
    "startsWith",
    "state",
    "states",
    "stats",
    "status",
    "statusCode",
    "statusMessage",
    "statusText",
    "statusbar",
    "stdDeviationX",
    "stdDeviationY",
    "stencilBack",
    "stencilClearValue",
    "stencilFront",
    "stencilFunc",
    "stencilFuncSeparate",
    "stencilLoadOp",
    "stencilMask",
    "stencilMaskSeparate",
    "stencilOp",
    "stencilOpSeparate",
    "stencilReadMask",
    "stencilReadOnly",
    "stencilStoreOp",
    "stencilWriteMask",
    "step",
    "stepDown",
    "stepMismatch",
    "stepMode",
    "stepUp",
    "sticky",
    "stitchTiles",
    "stop",
    "stop-color",
    "stop-opacity",
    "stopColor",
    "stopImmediatePropagation",
    "stopNotifications",
    "stopOpacity",
    "stopProfiling",
    "stopPropagation",
    "stopShark",
    "stopped",
    "storage",
    "storageArea",
    "storageBuckets",
    "storageName",
    "storageStatus",
    "storageTexture",
    "store",
    "storeOp",
    "storeSiteSpecificTrackingException",
    "storeWebWideTrackingException",
    "stpVersion",
    "stream",
    "streamErrorCode",
    "streams",
    "stretch",
    "strike",
    "string",
    "stringValue",
    "stringify",
    "stripIndexFormat",
    "stroke",
    "stroke-dasharray",
    "stroke-dashoffset",
    "stroke-linecap",
    "stroke-linejoin",
    "stroke-miterlimit",
    "stroke-opacity",
    "stroke-width",
    "strokeDasharray",
    "strokeDashoffset",
    "strokeLinecap",
    "strokeLinejoin",
    "strokeMiterlimit",
    "strokeOpacity",
    "strokeRect",
    "strokeStyle",
    "strokeText",
    "strokeWidth",
    "structuredClone",
    "style",
    "styleAndLayoutStart",
    "styleFloat",
    "styleMap",
    "styleMedia",
    "styleSheet",
    "styleSheetSets",
    "styleSheets",
    "sub",
    "subarray",
    "subject",
    "submit",
    "submitFrame",
    "submitter",
    "subscribe",
    "substr",
    "substring",
    "substringData",
    "subtle",
    "subtree",
    "suffix",
    "suffixes",
    "summary",
    "sup",
    "supported",
    "supportedContentEncodings",
    "supportedEntryTypes",
    "supportedValuesOf",
    "supports",
    "supportsFiber",
    "supportsSession",
    "supportsText",
    "surfaceScale",
    "surroundContents",
    "suspend",
    "suspendRedraw",
    "svb",
    "svh",
    "svi",
    "svmax",
    "svmin",
    "svw",
    "swapCache",
    "swapNode",
    "sweepFlag",
    "symbols",
    "symmetricDifference",
    "sync",
    "syntax",
    "sysexEnabled",
    "system",
    "systemCode",
    "systemId",
    "systemLanguage",
    "systemXDPI",
    "systemYDPI",
    "tBodies",
    "tFoot",
    "tHead",
    "tab",
    "tab-size",
    "tabId",
    "tabIds",
    "tabIndex",
    "tabSize",
    "table",
    "table-layout",
    "tableLayout",
    "tableValues",
    "tabs",
    "tag",
    "tagName",
    "tagUrn",
    "tags",
    "taintEnabled",
    "take",
    "takePhoto",
    "takeRecords",
    "tan",
    "tangentialPressure",
    "tanh",
    "target",
    "targetAddressSpace",
    "targetElement",
    "targetRayMode",
    "targetRaySpace",
    "targetTouches",
    "targetURL",
    "targetX",
    "targetY",
    "targets",
    "tcpType",
    "tee",
    "tel",
    "telemetry",
    "terminate",
    "test",
    "texImage2D",
    "texImage3D",
    "texParameterf",
    "texParameteri",
    "texStorage2D",
    "texStorage3D",
    "texSubImage2D",
    "texSubImage3D",
    "text",
    "text-align",
    "text-align-last",
    "text-anchor",
    "text-combine-upright",
    "text-decoration",
    "text-decoration-color",
    "text-decoration-line",
    "text-decoration-skip-ink",
    "text-decoration-style",
    "text-decoration-thickness",
    "text-emphasis",
    "text-emphasis-color",
    "text-emphasis-position",
    "text-emphasis-style",
    "text-indent",
    "text-justify",
    "text-orientation",
    "text-overflow",
    "text-rendering",
    "text-shadow",
    "text-transform",
    "text-underline-offset",
    "text-underline-position",
    "text-wrap",
    "text-wrap-mode",
    "text-wrap-style",
    "textAlign",
    "textAlignLast",
    "textAnchor",
    "textAutospace",
    "textBaseline",
    "textCombineUpright",
    "textContent",
    "textDecoration",
    "textDecorationBlink",
    "textDecorationColor",
    "textDecorationLine",
    "textDecorationLineThrough",
    "textDecorationNone",
    "textDecorationOverline",
    "textDecorationSkipInk",
    "textDecorationStyle",
    "textDecorationThickness",
    "textDecorationUnderline",
    "textEmphasis",
    "textEmphasisColor",
    "textEmphasisPosition",
    "textEmphasisStyle",
    "textIndent",
    "textJustify",
    "textJustifyTrim",
    "textKashida",
    "textKashidaSpace",
    "textLength",
    "textOrientation",
    "textOverflow",
    "textRendering",
    "textShadow",
    "textTracks",
    "textTransform",
    "textUnderlineOffset",
    "textUnderlinePosition",
    "textWrap",
    "textWrapMode",
    "textWrapStyle",
    "texture",
    "theme",
    "then",
    "threadId",
    "threshold",
    "thresholds",
    "throwIfAborted",
    "tiltX",
    "tiltY",
    "time",
    "timeEnd",
    "timeLog",
    "timeOrigin",
    "timeRemaining",
    "timeStamp",
    "timecode",
    "timeline",
    "timelineTime",
    "timeout",
    "timestamp",
    "timestampOffset",
    "timestampWrites",
    "timing",
    "title",
    "titlebarAreaRect",
    "tlsChannelId",
    "to",
    "toArray",
    "toBase64",
    "toBlob",
    "toDataURL",
    "toDateString",
    "toElement",
    "toExponential",
    "toFixed",
    "toFloat32Array",
    "toFloat64Array",
    "toGMTString",
    "toHex",
    "toISOString",
    "toJSON",
    "toLocaleDateString",
    "toLocaleFormat",
    "toLocaleLowerCase",
    "toLocaleString",
    "toLocaleTimeString",
    "toLocaleUpperCase",
    "toLowerCase",
    "toMatrix",
    "toMethod",
    "toPrecision",
    "toPrimitive",
    "toReversed",
    "toSdp",
    "toSorted",
    "toSource",
    "toSpliced",
    "toStaticHTML",
    "toString",
    "toStringTag",
    "toSum",
    "toTimeString",
    "toUTCString",
    "toUpperCase",
    "toWellFormed",
    "toggle",
    "toggleAttribute",
    "toggleLongPressEnabled",
    "togglePopover",
    "toggleReaderMode",
    "token",
    "tone",
    "toneBuffer",
    "tooLong",
    "tooShort",
    "toolbar",
    "top",
    "topMargin",
    "topSites",
    "topology",
    "total",
    "totalFrameDelay",
    "totalFrames",
    "totalFramesDuration",
    "totalVideoFrames",
    "touch-action",
    "touchAction",
    "touched",
    "touches",
    "trace",
    "track",
    "trackVisibility",
    "trackedAnchors",
    "tracks",
    "tran",
    "transaction",
    "transactions",
    "transceiver",
    "transfer",
    "transferControlToOffscreen",
    "transferFromImageBitmap",
    "transferImageBitmap",
    "transferIn",
    "transferOut",
    "transferSize",
    "transferToFixedLength",
    "transferToImageBitmap",
    "transform",
    "transform-box",
    "transform-origin",
    "transform-style",
    "transformBox",
    "transformFeedbackVaryings",
    "transformOrigin",
    "transformPoint",
    "transformString",
    "transformStyle",
    "transformToDocument",
    "transformToFragment",
    "transition",
    "transition-behavior",
    "transition-delay",
    "transition-duration",
    "transition-property",
    "transition-timing-function",
    "transitionBehavior",
    "transitionDelay",
    "transitionDuration",
    "transitionProperty",
    "transitionTimingFunction",
    "translate",
    "translateSelf",
    "translationX",
    "translationY",
    "transport",
    "traverseTo",
    "trim",
    "trimEnd",
    "trimLeft",
    "trimRight",
    "trimStart",
    "trueSpeed",
    "trunc",
    "truncate",
    "trustedTypes",
    "try",
    "turn",
    "twist",
    "type",
    "typeDetail",
    "typeMismatch",
    "typeMustMatch",
    "types",
    "u2f",
    "ubound",
    "uint16",
    "uint32",
    "uint8",
    "uint8Clamped",
    "unadjustedMovement",
    "unclippedDepth",
    "unconfigure",
    "undefined",
    "underlineStyle",
    "underlineThickness",
    "unescape",
    "uneval",
    "ungroup",
    "unicode",
    "unicode-bidi",
    "unicodeBidi",
    "unicodeRange",
    "unicodeSets",
    "uniform1f",
    "uniform1fv",
    "uniform1i",
    "uniform1iv",
    "uniform1ui",
    "uniform1uiv",
    "uniform2f",
    "uniform2fv",
    "uniform2i",
    "uniform2iv",
    "uniform2ui",
    "uniform2uiv",
    "uniform3f",
    "uniform3fv",
    "uniform3i",
    "uniform3iv",
    "uniform3ui",
    "uniform3uiv",
    "uniform4f",
    "uniform4fv",
    "uniform4i",
    "uniform4iv",
    "uniform4ui",
    "uniform4uiv",
    "uniformBlockBinding",
    "uniformMatrix2fv",
    "uniformMatrix2x3fv",
    "uniformMatrix2x4fv",
    "uniformMatrix3fv",
    "uniformMatrix3x2fv",
    "uniformMatrix3x4fv",
    "uniformMatrix4fv",
    "uniformMatrix4x2fv",
    "uniformMatrix4x3fv",
    "uninstallSelf",
    "union",
    "unique",
    "uniqueID",
    "uniqueNumber",
    "unit",
    "unitType",
    "units",
    "unloadEventEnd",
    "unloadEventStart",
    "unlock",
    "unmap",
    "unmount",
    "unobserve",
    "unpackColorSpace",
    "unpause",
    "unpauseAnimations",
    "unreadCount",
    "unregister",
    "unregisterContentHandler",
    "unregisterProtocolHandler",
    "unscopables",
    "unselectable",
    "unshift",
    "unsubscribe",
    "unsuspendRedraw",
    "unsuspendRedrawAll",
    "unwatch",
    "unwrapKey",
    "upDegrees",
    "upX",
    "upY",
    "upZ",
    "update",
    "updateAdInterestGroups",
    "updateCallbackDone",
    "updateCharacterBounds",
    "updateCommands",
    "updateControlBounds",
    "updateCurrentEntry",
    "updateIce",
    "updateInkTrailStartPoint",
    "updateInterval",
    "updatePlaybackRate",
    "updateRangeEnd",
    "updateRangeStart",
    "updateRenderState",
    "updateSelection",
    "updateSelectionBounds",
    "updateSettings",
    "updateText",
    "updateTiming",
    "updateViaCache",
    "updateWith",
    "updated",
    "updating",
    "upgrade",
    "upload",
    "uploadTotal",
    "uploaded",
    "upper",
    "upperBound",
    "upperOpen",
    "uri",
    "url",
    "urn",
    "urns",
    "usage",
    "usages",
    "usb",
    "usbVersionMajor",
    "usbVersionMinor",
    "usbVersionSubminor",
    "useCurrentView",
    "useMap",
    "useProgram",
    "usedSpace",
    "user-select",
    "userActivation",
    "userAgent",
    "userAgentData",
    "userChoice",
    "userHandle",
    "userHint",
    "userInitiated",
    "userLanguage",
    "userSelect",
    "userState",
    "userVisibleOnly",
    "username",
    "usernameFragment",
    "utterance",
    "uuid",
    "v8BreakIterator",
    "vAlign",
    "vLink",
    "valid",
    "validate",
    "validateProgram",
    "validationMessage",
    "validity",
    "value",
    "valueAsDate",
    "valueAsNumber",
    "valueAsString",
    "valueInSpecifiedUnits",
    "valueMissing",
    "valueOf",
    "valueText",
    "valueType",
    "values",
    "variable",
    "variant",
    "variationSettings",
    "vb",
    "vector-effect",
    "vectorEffect",
    "velocityAngular",
    "velocityExpansion",
    "velocityX",
    "velocityY",
    "vendor",
    "vendorId",
    "vendorSub",
    "verify",
    "version",
    "vertex",
    "vertexAttrib1f",
    "vertexAttrib1fv",
    "vertexAttrib2f",
    "vertexAttrib2fv",
    "vertexAttrib3f",
    "vertexAttrib3fv",
    "vertexAttrib4f",
    "vertexAttrib4fv",
    "vertexAttribDivisor",
    "vertexAttribDivisorANGLE",
    "vertexAttribI4i",
    "vertexAttribI4iv",
    "vertexAttribI4ui",
    "vertexAttribI4uiv",
    "vertexAttribIPointer",
    "vertexAttribPointer",
    "vertical",
    "vertical-align",
    "verticalAlign",
    "verticalOverflow",
    "vh",
    "vi",
    "vibrate",
    "vibrationActuator",
    "videoBitsPerSecond",
    "videoHeight",
    "videoTracks",
    "videoWidth",
    "view",
    "viewBox",
    "viewBoxString",
    "viewDimension",
    "viewFormats",
    "viewTarget",
    "viewTargetString",
    "viewTransition",
    "viewport",
    "viewportAnchorX",
    "viewportAnchorY",
    "viewportElement",
    "views",
    "violatedDirective",
    "virtualKeyboard",
    "virtualKeyboardPolicy",
    "visibility",
    "visibilityState",
    "visible",
    "visibleRect",
    "visualViewport",
    "vlinkColor",
    "vmax",
    "vmin",
    "voice",
    "voiceURI",
    "volume",
    "vrml",
    "vspace",
    "vw",
    "w",
    "wait",
    "waitAsync",
    "waitSync",
    "waiting",
    "wake",
    "wakeLock",
    "wand",
    "warmup",
    "warn",
    "wasAlternateProtocolAvailable",
    "wasClean",
    "wasDiscarded",
    "wasFetchedViaSpdy",
    "wasNpnNegotiated",
    "watch",
    "watchAvailability",
    "watchPosition",
    "webNavigation",
    "webRequest",
    "webdriver",
    "webkitAddKey",
    "webkitAlignContent",
    "webkitAlignItems",
    "webkitAlignSelf",
    "webkitAnimation",
    "webkitAnimationDelay",
    "webkitAnimationDirection",
    "webkitAnimationDuration",
    "webkitAnimationFillMode",
    "webkitAnimationIterationCount",
    "webkitAnimationName",
    "webkitAnimationPlayState",
    "webkitAnimationTimingFunction",
    "webkitAppearance",
    "webkitAudioContext",
    "webkitAudioDecodedByteCount",
    "webkitAudioPannerNode",
    "webkitBackfaceVisibility",
    "webkitBackground",
    "webkitBackgroundAttachment",
    "webkitBackgroundClip",
    "webkitBackgroundColor",
    "webkitBackgroundImage",
    "webkitBackgroundOrigin",
    "webkitBackgroundPosition",
    "webkitBackgroundPositionX",
    "webkitBackgroundPositionY",
    "webkitBackgroundRepeat",
    "webkitBackgroundSize",
    "webkitBackingStorePixelRatio",
    "webkitBorderBottomLeftRadius",
    "webkitBorderBottomRightRadius",
    "webkitBorderImage",
    "webkitBorderImageOutset",
    "webkitBorderImageRepeat",
    "webkitBorderImageSlice",
    "webkitBorderImageSource",
    "webkitBorderImageWidth",
    "webkitBorderRadius",
    "webkitBorderTopLeftRadius",
    "webkitBorderTopRightRadius",
    "webkitBoxAlign",
    "webkitBoxDirection",
    "webkitBoxFlex",
    "webkitBoxOrdinalGroup",
    "webkitBoxOrient",
    "webkitBoxPack",
    "webkitBoxShadow",
    "webkitBoxSizing",
    "webkitCancelAnimationFrame",
    "webkitCancelFullScreen",
    "webkitCancelKeyRequest",
    "webkitCancelRequestAnimationFrame",
    "webkitClearResourceTimings",
    "webkitClipPath",
    "webkitClosedCaptionsVisible",
    "webkitConvertPointFromNodeToPage",
    "webkitConvertPointFromPageToNode",
    "webkitCreateShadowRoot",
    "webkitCurrentFullScreenElement",
    "webkitCurrentPlaybackTargetIsWireless",
    "webkitDecodedFrameCount",
    "webkitDirectionInvertedFromDevice",
    "webkitDisplayingFullscreen",
    "webkitDroppedFrameCount",
    "webkitEnterFullScreen",
    "webkitEnterFullscreen",
    "webkitEntries",
    "webkitExitFullScreen",
    "webkitExitFullscreen",
    "webkitExitPointerLock",
    "webkitFilter",
    "webkitFlex",
    "webkitFlexBasis",
    "webkitFlexDirection",
    "webkitFlexFlow",
    "webkitFlexGrow",
    "webkitFlexShrink",
    "webkitFlexWrap",
    "webkitFontFeatureSettings",
    "webkitFullScreenKeyboardInputAllowed",
    "webkitFullscreenElement",
    "webkitFullscreenEnabled",
    "webkitGenerateKeyRequest",
    "webkitGetAsEntry",
    "webkitGetDatabaseNames",
    "webkitGetEntries",
    "webkitGetEntriesByName",
    "webkitGetEntriesByType",
    "webkitGetFlowByName",
    "webkitGetGamepads",
    "webkitGetImageDataHD",
    "webkitGetNamedFlows",
    "webkitGetRegionFlowRanges",
    "webkitGetUserMedia",
    "webkitHasClosedCaptions",
    "webkitHidden",
    "webkitIDBCursor",
    "webkitIDBDatabase",
    "webkitIDBDatabaseError",
    "webkitIDBDatabaseException",
    "webkitIDBFactory",
    "webkitIDBIndex",
    "webkitIDBKeyRange",
    "webkitIDBObjectStore",
    "webkitIDBRequest",
    "webkitIDBTransaction",
    "webkitImageSmoothingEnabled",
    "webkitIndexedDB",
    "webkitInitMessageEvent",
    "webkitIsFullScreen",
    "webkitJustifyContent",
    "webkitKeys",
    "webkitLineClamp",
    "webkitLineDashOffset",
    "webkitLockOrientation",
    "webkitMask",
    "webkitMaskClip",
    "webkitMaskComposite",
    "webkitMaskImage",
    "webkitMaskOrigin",
    "webkitMaskPosition",
    "webkitMaskPositionX",
    "webkitMaskPositionY",
    "webkitMaskRepeat",
    "webkitMaskSize",
    "webkitMatchesSelector",
    "webkitMediaStream",
    "webkitNotifications",
    "webkitOfflineAudioContext",
    "webkitOrder",
    "webkitOrientation",
    "webkitPeerConnection00",
    "webkitPersistentStorage",
    "webkitPerspective",
    "webkitPerspectiveOrigin",
    "webkitPointerLockElement",
    "webkitPostMessage",
    "webkitPreservesPitch",
    "webkitPutImageDataHD",
    "webkitRTCPeerConnection",
    "webkitRegionOverset",
    "webkitRelativePath",
    "webkitRequestAnimationFrame",
    "webkitRequestFileSystem",
    "webkitRequestFullScreen",
    "webkitRequestFullscreen",
    "webkitRequestPointerLock",
    "webkitResolveLocalFileSystemURL",
    "webkitSetMediaKeys",
    "webkitSetResourceTimingBufferSize",
    "webkitShadowRoot",
    "webkitShowPlaybackTargetPicker",
    "webkitSlice",
    "webkitSpeechGrammar",
    "webkitSpeechGrammarList",
    "webkitSpeechRecognition",
    "webkitSpeechRecognitionError",
    "webkitSpeechRecognitionEvent",
    "webkitStorageInfo",
    "webkitSupportsFullscreen",
    "webkitTemporaryStorage",
    "webkitTextFillColor",
    "webkitTextSecurity",
    "webkitTextSizeAdjust",
    "webkitTextStroke",
    "webkitTextStrokeColor",
    "webkitTextStrokeWidth",
    "webkitTransform",
    "webkitTransformOrigin",
    "webkitTransformStyle",
    "webkitTransition",
    "webkitTransitionDelay",
    "webkitTransitionDuration",
    "webkitTransitionProperty",
    "webkitTransitionTimingFunction",
    "webkitURL",
    "webkitUnlockOrientation",
    "webkitUserSelect",
    "webkitVideoDecodedByteCount",
    "webkitVisibilityState",
    "webkitWirelessVideoPlaybackDisabled",
    "webkitdirectory",
    "webkitdropzone",
    "webstore",
    "weight",
    "wgslLanguageFeatures",
    "whatToShow",
    "wheelDelta",
    "wheelDeltaX",
    "wheelDeltaY",
    "whenDefined",
    "which",
    "white-space",
    "white-space-collapse",
    "whiteSpace",
    "whiteSpaceCollapse",
    "wholeText",
    "widows",
    "width",
    "will-change",
    "willChange",
    "willValidate",
    "window",
    "windowAttribution",
    "windowControlsOverlay",
    "windowId",
    "windowIds",
    "windows",
    "with",
    "withCredentials",
    "withResolvers",
    "word-break",
    "word-spacing",
    "word-wrap",
    "wordBreak",
    "wordSpacing",
    "wordWrap",
    "workerStart",
    "worklet",
    "wow64",
    "wrap",
    "wrapKey",
    "writable",
    "writableAuxiliaries",
    "write",
    "writeBuffer",
    "writeMask",
    "writeText",
    "writeTexture",
    "writeTimestamp",
    "writeValue",
    "writeValueWithResponse",
    "writeValueWithoutResponse",
    "writeWithoutResponse",
    "writeln",
    "writing-mode",
    "writingMode",
    "writingSuggestions",
    "x",
    "x1",
    "x2",
    "xChannelSelector",
    "xmlEncoding",
    "xmlStandalone",
    "xmlVersion",
    "xmlbase",
    "xmllang",
    "xmlspace",
    "xor",
    "xr",
    "y",
    "y1",
    "y2",
    "yChannelSelector",
    "yandex",
    "yield",
    "z",
    "z-index",
    "zIndex",
    "zoom",
    "zoomAndPan",
    "zoomRectScreen"
  ];
});

// ../node_modules/terser/lib/propmangle.js
function Ipt(e) {
  yne.forEach(n);
  var t = ["Symbol", "Map", "Promise", "Proxy", "Reflect", "Set", "WeakMap", "WeakSet"], r = {}, i = typeof global == "object" ? global : self;
  t.forEach(function(a) {
    r[a] = i[a] || function() {
    };
  }), [
    "null",
    "true",
    "false",
    "NaN",
    "Infinity",
    "-Infinity",
    "undefined"
  ].forEach(n), [
    Object,
    Array,
    Function,
    Number,
    String,
    Boolean,
    Error,
    Math,
    Date,
    RegExp,
    r.Symbol,
    ArrayBuffer,
    DataView,
    decodeURI,
    decodeURIComponent,
    encodeURI,
    encodeURIComponent,
    eval,
    EvalError,
    Float32Array,
    Float64Array,
    Int8Array,
    Int16Array,
    Int32Array,
    isFinite,
    isNaN,
    JSON,
    r.Map,
    parseFloat,
    parseInt,
    r.Promise,
    r.Proxy,
    RangeError,
    ReferenceError,
    r.Reflect,
    r.Set,
    SyntaxError,
    TypeError,
    Uint8Array,
    Uint8ClampedArray,
    Uint16Array,
    Uint32Array,
    URIError,
    r.WeakMap,
    r.WeakSet
  ].forEach(function(a) {
    Object.getOwnPropertyNames(a).map(n), a.prototype && Object.getOwnPropertyNames(a.prototype).map(n);
  });
  function n(a) {
    e.add(a);
  }
  s(n, "add");
}
function _ne(e, t) {
  function r(i) {
    Nu(t, i);
  }
  s(r, "add"), e.walk(new Mr(function(i) {
    i instanceof Nt && i.quote ? r(i.key) : i instanceof gr && i.quote ? r(i.key.name) : i instanceof fr && cf(i.property, r);
  }));
}
function cf(e, t) {
  e.walk(new Mr(function(r) {
    return r instanceof Qe ? cf(r.tail_node(), t) : r instanceof bt ? t(r.value) : r instanceof it && (cf(r.consequent, t), cf(r.alternative,
    t)), !0;
  }));
}
function bne(e, t) {
  var r = -1, i = /* @__PURE__ */ new Map(), n = t.nth_identifier || jl;
  return e = e.transform(new qi(function(o) {
    o instanceof Ii || o instanceof ki || o instanceof $i || o instanceof on || o instanceof Un ? o.key.name = a(o.key.name) : o instanceof Wi &&
    (o.property = a(o.property));
  })), e;
  function a(o) {
    let u = i.get(o);
    return u || (u = n.get(++r), i.set(o, u)), u;
  }
  s(a, "mangle_private");
}
function Xk(e) {
  var t = /* @__PURE__ */ new Set();
  return _r(e, (r) => {
    r instanceof Ii || r instanceof ki || r instanceof $i || r instanceof on || r instanceof Wi || (r instanceof Nt ? typeof r.key == "strin\
g" && nn(r, Zc) && t.add(r.key) : r instanceof gr ? nn(r, Zc) && t.add(r.key.name) : r instanceof It ? nn(r, Zc) && t.add(r.property) : r instanceof
    fr && r.property instanceof bt && nn(r, Zc) && t.add(r.property.value));
  }), t;
}
function vne(e, t, r = Xk(e)) {
  t = Mn(t, {
    builtins: !1,
    cache: null,
    debug: !1,
    keep_quoted: !1,
    nth_identifier: jl,
    only_cache: !1,
    regex: null,
    reserved: null,
    undeclared: !1,
    only_annotated: !1
  }, !0);
  var i = t.nth_identifier, n = t.reserved;
  Array.isArray(n) || (n = [n]);
  var a = new Set(n);
  t.builtins || Ipt(a);
  var o = -1, u;
  t.cache ? u = t.cache.props : u = /* @__PURE__ */ new Map();
  var l = t.only_annotated, c = t.regex && new RegExp(t.regex), p = t.debug !== !1, h;
  p && (h = t.debug === !0 ? "" : t.debug);
  var y = /* @__PURE__ */ new Set(), _ = /* @__PURE__ */ new Set();
  u.forEach((S) => _.add(S));
  var g = !!t.keep_quoted;
  return e.walk(new Mr(function(S) {
    if (!(S instanceof Ii || S instanceof ki || S instanceof $i || S instanceof on || S instanceof Wi))
      if (S instanceof Nt)
        typeof S.key == "string" && (!g || !S.quote) && d(S.key);
      else if (S instanceof gr)
        (!g || !S.quote) && d(S.key.name);
      else if (S instanceof It) {
        var x = !!t.undeclared;
        if (!x) {
          for (var C = S; C.expression; )
            C = C.expression;
          x = !(C.thedef && C.thedef.undeclared);
        }
        x && (!g || !S.quote) && d(S.property);
      } else S instanceof fr ? g || cf(S.property, d) : S instanceof Fe && S.expression.print_to_string() == "Object.defineProperty" ? cf(S.
      args[1], d) : S instanceof ce && S.operator === "in" ? cf(S.left, d) : S instanceof bt && nn(S, Qc) && d(S.value);
  })), e.transform(new qi(function(S) {
    S instanceof Ii || S instanceof ki || S instanceof $i || S instanceof on || S instanceof Wi || (S instanceof Nt ? typeof S.key == "strin\
g" && (!g || !S.quote) && (S.key = v(S.key)) : S instanceof gr ? (!g || !S.quote) && (S.computed_key() || (S.key.name = v(S.key.name))) : S instanceof
    It ? (!g || !S.quote) && (S.property = v(S.property)) : !g && S instanceof fr ? S.property = E(S.property) : S instanceof Fe && S.expression.
    print_to_string() == "Object.defineProperty" ? S.args[1] = E(S.args[1]) : S instanceof ce && S.operator === "in" ? S.left = E(S.left) : S instanceof
    bt && nn(S, Qc) && (hk(S, Qc), S.value = v(S.value)));
  }));
  function m(S) {
    return _.has(S) || a.has(S) ? !1 : t.only_cache ? u.has(S) : !/^-?[0-9]+(\.[0-9]+)?(e[+-][0-9]+)?$/.test(S);
  }
  s(m, "can_mangle");
  function f(S) {
    return l && !r.has(S) ? !1 : c && !c.test(S) ? r.has(S) : a.has(S) ? !1 : u.has(S) || y.has(S);
  }
  s(f, "should_mangle");
  function d(S) {
    m(S) && y.add(S), f(S) || _.add(S);
  }
  s(d, "add");
  function v(S) {
    if (!f(S))
      return S;
    var x = u.get(S);
    if (!x) {
      if (p) {
        var C = "_$" + S + "$" + h + "_";
        m(C) && (x = C);
      }
      if (!x)
        do
          x = i.get(++o);
        while (!m(x));
      u.set(S, x);
    }
    return x;
  }
  s(v, "mangle");
  function E(S) {
    return S.transform(new qi(function(x) {
      if (x instanceof Qe) {
        var C = x.expressions.length - 1;
        x.expressions[C] = E(x.expressions[C]);
      } else x instanceof bt ? (hk(x, Qc), x.value = v(x.value)) : x instanceof it && (x.consequent = E(x.consequent), x.alternative = E(x.alternative));
      return x;
    }));
  }
  s(E, "mangleStrings");
}
var Sne = at(() => {
  "use strict";
  Gi();
  ry();
  Di();
  gne();
  s(Ipt, "find_builtins");
  s(_ne, "reserve_quoted_keys");
  s(cf, "addStrings");
  s(bne, "mangle_private_properties");
  s(Xk, "find_annotated_props");
  s(vne, "mangle_properties");
});

// ../node_modules/terser/lib/minify.js
function Lpt(e) {
  var t = /(?:^|[^.])\/\/# sourceMappingURL=data:application\/json(;[\w=-]*)?;base64,([+/0-9A-Za-z]*=*)\s*$/.exec(e);
  return t ? Rpt(t[2]) : (console.warn("inline source map not found"), null);
}
function $l(e, t, r) {
  t[e] && r.forEach(function(i) {
    t[i] && (typeof t[i] != "object" && (t[i] = {}), e in t[i] || (t[i][e] = t[e]));
  });
}
function Tne(e) {
  e && ("props" in e ? e.props instanceof Map || (e.props = Cie(e.props)) : e.props = /* @__PURE__ */ new Map());
}
function Ene(e) {
  return {
    props: Pie(e.props)
  };
}
function Fpt(e, t, r, i) {
  if (!(r && r.writeFileSync && r.mkdirSync))
    return;
  try {
    r.mkdirSync(i);
  } catch (u) {
    if (u.code !== "EEXIST") throw u;
  }
  let n = `${i}/terser-debug-${Math.random() * 9999999 | 0}.log`;
  t = t || {};
  let a = JSON.stringify(t, (u, l) => typeof l == "function" ? "[Function " + l.toString() + "]" : l instanceof RegExp ? "[RegExp " + l.toString() +
  "]" : l, 4), o = /* @__PURE__ */ s((u) => typeof u == "object" && t.parse && t.parse.spidermonkey ? JSON.stringify(u, null, 2) : typeof u ==
  "object" ? Object.keys(u).map((l) => l + ": " + o(u[l])).join(`

`) : typeof u == "string" ? "```\n" + u + "\n```" : u, "files_str");
  r.writeFileSync(n, `Options: 
` + a + `

Input files:

` + o(e) + `
`);
}
function* Ane(e, t, r) {
  r && typeof process == "object" && process.env && typeof process.env.TERSER_DEBUG_DIR == "string" && Fpt(e, t, r, process.env.TERSER_DEBUG_DIR),
  t = Mn(t, {
    compress: {},
    ecma: void 0,
    enclose: !1,
    ie8: !1,
    keep_classnames: void 0,
    keep_fnames: !1,
    mangle: {},
    module: !1,
    nameCache: null,
    output: null,
    format: null,
    parse: {},
    rename: void 0,
    safari10: !1,
    sourceMap: !1,
    spidermonkey: !1,
    timings: !1,
    toplevel: !1,
    warnings: !1,
    wrap: !1
  }, !0);
  var i = t.timings && {
    start: Date.now()
  };
  if (t.keep_classnames === void 0 && (t.keep_classnames = t.keep_fnames), t.rename === void 0 && (t.rename = t.compress && t.mangle), t.output &&
  t.format)
    throw new Error("Please only specify either output or format option, preferrably format.");
  t.format = t.format || t.output || {}, $l("ecma", t, ["parse", "compress", "format"]), $l("ie8", t, ["compress", "mangle", "format"]), $l(
  "keep_classnames", t, ["compress", "mangle"]), $l("keep_fnames", t, ["compress", "mangle"]), $l("module", t, ["parse", "compress", "mangle"]),
  $l("safari10", t, ["mangle", "format"]), $l("toplevel", t, ["compress", "mangle"]), $l("warnings", t, ["compress"]);
  var n;
  t.mangle && (t.mangle = Mn(t.mangle, {
    cache: t.nameCache && (t.nameCache.vars || {}),
    eval: !1,
    ie8: !1,
    keep_classnames: !1,
    keep_fnames: !1,
    module: !1,
    nth_identifier: jl,
    properties: !1,
    reserved: [],
    safari10: !1,
    toplevel: !1
  }, !0), t.mangle.properties && (typeof t.mangle.properties != "object" && (t.mangle.properties = {}), t.mangle.properties.keep_quoted && (n =
  t.mangle.properties.reserved, Array.isArray(n) || (n = []), t.mangle.properties.reserved = n), t.nameCache && !("cache" in t.mangle.properties) &&
  (t.mangle.properties.cache = t.nameCache.props || {})), Tne(t.mangle.cache), Tne(t.mangle.properties.cache)), t.sourceMap && (t.sourceMap =
  Mn(t.sourceMap, {
    asObject: !1,
    content: null,
    filename: null,
    includeSources: !1,
    root: null,
    url: null
  }, !0)), i && (i.parse = Date.now());
  var a;
  if (e instanceof Kt)
    a = e;
  else {
    if ((typeof e == "string" || t.parse.spidermonkey && !Array.isArray(e)) && (e = [e]), t.parse = t.parse || {}, t.parse.toplevel = null, t.
    parse.spidermonkey)
      t.parse.toplevel = Se.from_mozilla_ast(Object.keys(e).reduce(function(y, _) {
        return y ? (y.body = y.body.concat(e[_].body), y) : e[_];
      }, null));
    else {
      delete t.parse.spidermonkey;
      for (var o in e) if (Pi(e, o) && (t.parse.filename = o, t.parse.toplevel = $o(e[o], t.parse), t.sourceMap && t.sourceMap.content == "i\
nline")) {
        if (Object.keys(e).length > 1)
          throw new Error("inline source map only works with singular input");
        t.sourceMap.content = Lpt(e[o]);
      }
    }
    if (t.parse.toplevel === null)
      throw new Error("no source file given");
    a = t.parse.toplevel;
  }
  n && t.mangle.properties.keep_quoted !== "strict" && _ne(a, n);
  var u;
  t.mangle && t.mangle.properties && (u = Xk(a)), t.wrap && (a = a.wrap_commonjs(t.wrap)), t.enclose && (a = a.wrap_enclose(t.enclose)), i &&
  (i.rename = Date.now()), i && (i.compress = Date.now()), t.compress && (a = new py(t.compress, {
    mangle_options: t.mangle
  }).compress(a)), i && (i.scope = Date.now()), t.mangle && a.figure_out_scope(t.mangle), i && (i.mangle = Date.now()), t.mangle && (a.compute_char_frequency(
  t.mangle), a.mangle_names(t.mangle), a = bne(a, t.mangle)), i && (i.properties = Date.now()), t.mangle && t.mangle.properties && (a = vne(
  a, t.mangle.properties, u)), i && (i.format = Date.now());
  var l = {};
  t.format.ast && (l.ast = a), t.format.spidermonkey && (l.ast = a.to_mozilla_ast());
  let c;
  if (!Pi(t.format, "code") || t.format.code) {
    if (c = { ...t.format }, c.ast || (c._destroy_ast = !0, _r(a, (y) => {
      y instanceof Ye && (y.variables = void 0, y.enclosed = void 0, y.parent_scope = void 0), y.block_scope && (y.block_scope.variables = void 0,
      y.block_scope.enclosed = void 0, y.block_scope.parent_scope = void 0);
    })), t.sourceMap) {
      if (t.sourceMap.includeSources && e instanceof Kt)
        throw new Error("original source content unavailable");
      c.source_map = yield* dne({
        file: t.sourceMap.filename,
        orig: t.sourceMap.content,
        root: t.sourceMap.root,
        files: t.sourceMap.includeSources ? e : null
      });
    }
    delete c.ast, delete c.code, delete c.spidermonkey;
    var p = ef(c);
    if (a.print(p), l.code = p.get(), t.sourceMap)
      if (Object.defineProperty(l, "map", {
        configurable: !0,
        enumerable: !0,
        get() {
          let y = c.source_map.getEncoded();
          return l.map = t.sourceMap.asObject ? y : JSON.stringify(y);
        },
        set(y) {
          Object.defineProperty(l, "map", {
            value: y,
            writable: !0
          });
        }
      }), l.decoded_map = c.source_map.getDecoded(), t.sourceMap.url == "inline") {
        var h = typeof l.map == "object" ? JSON.stringify(l.map) : l.map;
        l.code += `
//# sourceMappingURL=data:application/json;charset=utf-8;base64,` + Npt(h);
      } else t.sourceMap.url && (l.code += `
//# sourceMappingURL=` + t.sourceMap.url);
  }
  return t.nameCache && t.mangle && (t.mangle.cache && (t.nameCache.vars = Ene(t.mangle.cache)), t.mangle.properties && t.mangle.properties.
  cache && (t.nameCache.props = Ene(t.mangle.properties.cache))), c && c.source_map && c.source_map.destroy(), i && (i.end = Date.now(), l.timings =
  {
    parse: 1e-3 * (i.rename - i.parse),
    rename: 1e-3 * (i.compress - i.rename),
    compress: 1e-3 * (i.scope - i.compress),
    scope: 1e-3 * (i.mangle - i.scope),
    mangle: 1e-3 * (i.properties - i.mangle),
    properties: 1e-3 * (i.format - i.properties),
    format: 1e-3 * (i.end - i.format),
    total: 1e-3 * (i.end - i.start)
  }), l;
}
async function ff(e, t, r) {
  let i = Ane(e, t, r), n, a;
  do
    a = i.next(await n), n = a.value;
  while (!a.done);
  return a.value;
}
function xne(e, t, r) {
  let i = Ane(e, t, r), n, a;
  do {
    if (n && typeof n.then == "function")
      throw new Error("minify_sync cannot be used with the legacy source-map module");
    a = i.next(n), n = a.value;
  } while (!a.done);
  return a.value;
}
var Rpt, Npt, Yk = at(() => {
  "use strict";
  Gi();
  Di();
  Rl();
  QS();
  pne();
  ry();
  mne();
  Sne();
  Rpt = typeof Buffer < "u" ? (e) => Buffer.from(e, "base64").toString() : (e) => decodeURIComponent(escape(atob(e))), Npt = typeof Buffer <
  "u" ? (e) => Buffer.from(e).toString("base64") : (e) => btoa(unescape(encodeURIComponent(e)));
  s(Lpt, "read_source_map");
  s($l, "set_shorthand");
  s(Tne, "init_cache");
  s(Ene, "cache_to_json");
  s(Fpt, "log_input");
  s(Ane, "minify_sync_or_async");
  s(ff, "minify");
  s(xne, "minify_sync");
});

// ../node_modules/terser/node_modules/acorn/dist/acorn.mjs
var pse = {};
da(pse, {
  Node: () => gy,
  Parser: () => ji,
  Position: () => hh,
  SourceLocation: () => my,
  TokContext: () => Fa,
  Token: () => C0,
  TokenType: () => vr,
  defaultOptions: () => y0,
  getLineInfo: () => nI,
  isIdentifierChar: () => pf,
  isIdentifierStart: () => eu,
  isNewLine: () => hf,
  keywordTypes: () => S0,
  lineBreak: () => fa,
  lineBreakG: () => Rne,
  nonASCIIwhitespace: () => iI,
  parse: () => bht,
  parseExpressionAt: () => vht,
  tokContexts: () => ci,
  tokTypes: () => O,
  tokenizer: () => Sht,
  version: () => fse
});
function eI(e, t) {
  for (var r = 65536, i = 0; i < t.length; i += 2) {
    if (r += t[i], r > e)
      return !1;
    if (r += t[i + 1], r >= e)
      return !0;
  }
  return !1;
}
function eu(e, t) {
  return e < 65 ? e === 36 : e < 91 ? !0 : e < 97 ? e === 95 : e < 123 ? !0 : e <= 65535 ? e >= 170 && jpt.test(String.fromCharCode(e)) : t ===
  !1 ? !1 : eI(e, kne);
}
function pf(e, t) {
  return e < 48 ? e === 36 : e < 58 ? !0 : e < 65 ? !1 : e < 91 ? !0 : e < 97 ? e === 95 : e < 123 ? !0 : e <= 65535 ? e >= 170 && Vpt.test(
  String.fromCharCode(e)) : t === !1 ? !1 : eI(e, kne) || eI(e, Mpt);
}
function Na(e, t) {
  return new vr(e, { beforeExpr: !0, binop: t });
}
function hr(e, t) {
  return t === void 0 && (t = {}), t.keyword = e, S0[e] = new vr(e, t);
}
function hf(e) {
  return e === 10 || e === 13 || e === 8232 || e === 8233;
}
function Nne(e, t, r) {
  r === void 0 && (r = e.length);
  for (var i = t; i < r; i++) {
    var n = e.charCodeAt(i);
    if (hf(n))
      return i < r - 1 && n === 13 && e.charCodeAt(i + 1) === 10 ? i + 2 : i + 1;
  }
  return -1;
}
function Xl(e) {
  return Pne[e] || (Pne[e] = new RegExp("^(?:" + e.replace(/ /g, "|") + ")$"));
}
function Vu(e) {
  return e <= 65535 ? String.fromCharCode(e) : (e -= 65536, String.fromCharCode((e >> 10) + 55296, (e & 1023) + 56320));
}
function nI(e, t) {
  for (var r = 1, i = 0; ; ) {
    var n = Nne(e, i, t);
    if (n < 0)
      return new hh(r, t - i);
    ++r, i = n;
  }
}
function Gpt(e) {
  var t = {};
  for (var r in y0)
    t[r] = e && dh(e, r) ? e[r] : y0[r];
  if (t.ecmaVersion === "latest" ? t.ecmaVersion = 1e8 : t.ecmaVersion == null ? (!Dne && typeof console == "object" && console.warn && (Dne =
  !0, console.warn(`Since Acorn 8.0.0, options.ecmaVersion is required.
Defaulting to 2020, but this will stop working in the future.`)), t.ecmaVersion = 11) : t.ecmaVersion >= 2015 && (t.ecmaVersion -= 2009), t.
  allowReserved == null && (t.allowReserved = t.ecmaVersion < 5), (!e || e.allowHashBang == null) && (t.allowHashBang = t.ecmaVersion >= 14),
  Cne(t.onToken)) {
    var i = t.onToken;
    t.onToken = function(n) {
      return i.push(n);
    };
  }
  return Cne(t.onComment) && (t.onComment = Wpt(t, t.onComment)), t;
}
function Wpt(e, t) {
  return function(r, i, n, a, o, u) {
    var l = {
      type: r ? "Block" : "Line",
      value: i,
      start: n,
      end: a
    };
    e.locations && (l.loc = new my(this, o, u)), e.ranges && (l.range = [n, a]), t.push(l);
  };
}
function oI(e, t) {
  return mh | (e ? sI : 0) | (t ? Fne : 0);
}
function Jpt(e, t) {
  var r = t.key.name, i = e[r], n = "true";
  return t.type === "MethodDefinition" && (t.kind === "get" || t.kind === "set") && (n = (t.static ? "s" : "i") + t.kind), i === "iget" && n ===
  "iset" || i === "iset" && n === "iget" || i === "sget" && n === "sset" || i === "sset" && n === "sget" ? (e[r] = "true", !1) : i ? !0 : (e[r] =
  n, !1);
}
function _0(e, t) {
  var r = e.computed, i = e.key;
  return !r && (i.type === "Identifier" && i.name === t || i.type === "Literal" && i.value === t);
}
function Kne(e) {
  return e.type === "Identifier" || e.type === "ParenthesizedExpression" && Kne(e.expression);
}
function rI(e) {
  return e.type === "MemberExpression" && e.property.type === "PrivateIdentifier" || e.type === "ChainExpression" && rI(e.expression) || e.type ===
  "ParenthesizedExpression" && rI(e.expression);
}
function Hne(e, t, r, i) {
  return e.type = t, e.end = r, this.options.locations && (e.loc.end = i), this.options.ranges && (e.range[1] = r), e;
}
function oht(e) {
  var t = tse[e] = {
    binary: Xl(rht[e] + " " + wne),
    binaryOfStrings: Xl(nht[e]),
    nonBinary: {
      General_Category: Xl(wne),
      Script: Xl(aht[e])
    }
  };
  t.nonBinary.Script_Extensions = t.nonBinary.Script, t.nonBinary.gc = t.nonBinary.General_Category, t.nonBinary.sc = t.nonBinary.Script, t.
  nonBinary.scx = t.nonBinary.Script_Extensions;
}
function uht(e) {
  for (var t in e)
    return !0;
  return !1;
}
function lht(e) {
  return e === 105 || e === 109 || e === 115;
}
function rse(e) {
  return e === 36 || e >= 40 && e <= 43 || e === 46 || e === 63 || e >= 91 && e <= 94 || e >= 123 && e <= 125;
}
function cht(e) {
  return eu(e, !0) || e === 36 || e === 95;
}
function fht(e) {
  return pf(e, !0) || e === 36 || e === 95 || e === 8204 || e === 8205;
}
function ise(e) {
  return e >= 65 && e <= 90 || e >= 97 && e <= 122;
}
function pht(e) {
  return e >= 0 && e <= 1114111;
}
function hht(e) {
  return e === 100 || e === 68 || e === 115 || e === 83 || e === 119 || e === 87;
}
function sse(e) {
  return ise(e) || e === 95;
}
function dht(e) {
  return sse(e) || x0(e);
}
function mht(e) {
  return e === 33 || e >= 35 && e <= 38 || e >= 42 && e <= 44 || e === 46 || e >= 58 && e <= 64 || e === 94 || e === 96 || e === 126;
}
function yht(e) {
  return e === 40 || e === 41 || e === 45 || e === 47 || e >= 91 && e <= 93 || e >= 123 && e <= 125;
}
function ght(e) {
  return e === 33 || e === 35 || e === 37 || e === 38 || e === 44 || e === 45 || e >= 58 && e <= 62 || e === 64 || e === 96 || e === 126;
}
function x0(e) {
  return e >= 48 && e <= 57;
}
function ase(e) {
  return e >= 48 && e <= 57 || e >= 65 && e <= 70 || e >= 97 && e <= 102;
}
function ose(e) {
  return e >= 65 && e <= 70 ? 10 + (e - 65) : e >= 97 && e <= 102 ? 10 + (e - 97) : e - 48;
}
function use(e) {
  return e >= 48 && e <= 55;
}
function _ht(e, t) {
  return t ? parseInt(e, 8) : parseFloat(e.replace(/_/g, ""));
}
function lse(e) {
  return typeof BigInt != "function" ? null : BigInt(e.replace(/_/g, ""));
}
function bht(e, t) {
  return ji.parse(e, t);
}
function vht(e, t, r) {
  return ji.parseExpressionAt(e, t, r);
}
function Sht(e, t) {
  return ji.tokenizer(e, t);
}
var Mpt, kne, Bpt, Ine, Jk, Qk, qpt, Upt, jpt, Vpt, vr, La, Gs, S0, O, fa, Rne, iI, Ma, Lne, Kpt, Hpt, dh, Cne, Pne, zpt, hh, my, y0, Dne, dy,
mh, sI, Fne, aI, Mne, T0, Bne, df, yy, E0, g0, uI, Hu, qne, Une, jne, ji, tu, As, $pt, A0, ut, lI, Xpt, Ypt, hy, tI, Vne, qa, Fa, ci, yh, Dt,
Qpt, b0, Yl, Zpt, gy, _y, eht, zne, Gne, Wne, $ne, Xne, tht, rht, iht, nht, wne, Yne, Jne, Qne, Zne, ese, sht, aht, tse, One, m0, Zk, Ze, v0,
ru, nse, Ku, Ba, C0, ar, cse, fse, hse = at(() => {
  Mpt = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123,
  2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158,
  11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19,
  13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6,
  3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 343, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49,
  4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470,
  0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15,
  0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 726, 6, 110, 6, 6, 9, 4759,
  9, 787719, 239], kne = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5,
  7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2,
  41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43,
  28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 2, 60, 28, 11,
  0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17,
  2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2,
  0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32,
  7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36,
  18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637,
  96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 129, 74,
  6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8,
  8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2,
  24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27,
  229, 29, 3, 0, 496, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0,
  2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719,
  33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191], Bpt = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\
\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\
\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\
\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\
\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65",
  Ine = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA\
-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\
\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\
\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\
\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\
\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CD\uA7D0\uA7D1\uA7D3\uA7D5-\uA7DC\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09\
-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC",
  Jk = {
    3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package pri\
vate protected public short static super synchronized throws transient volatile",
    5: "class enum extends super const export import",
    6: "enum",
    strict: "implements interface let package private protected public static yield",
    strictBind: "eval arguments"
  }, Qk = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false\
 instanceof typeof void delete new in this", qpt = {
    5: Qk,
    "5module": Qk + " export import",
    6: Qk + " const class extends export import super"
  }, Upt = /^in(stanceof)?$/, jpt = new RegExp("[" + Ine + "]"), Vpt = new RegExp("[" + Ine + Bpt + "]");
  s(eI, "isInAstralSet");
  s(eu, "isIdentifierStart");
  s(pf, "isIdentifierChar");
  vr = /* @__PURE__ */ s(function(t, r) {
    r === void 0 && (r = {}), this.label = t, this.keyword = r.keyword, this.beforeExpr = !!r.beforeExpr, this.startsExpr = !!r.startsExpr, this.
    isLoop = !!r.isLoop, this.isAssign = !!r.isAssign, this.prefix = !!r.prefix, this.postfix = !!r.postfix, this.binop = r.binop || null, this.
    updateContext = null;
  }, "TokenType");
  s(Na, "binop");
  La = { beforeExpr: !0 }, Gs = { startsExpr: !0 }, S0 = {};
  s(hr, "kw");
  O = {
    num: new vr("num", Gs),
    regexp: new vr("regexp", Gs),
    string: new vr("string", Gs),
    name: new vr("name", Gs),
    privateId: new vr("privateId", Gs),
    eof: new vr("eof"),
    // Punctuation token types.
    bracketL: new vr("[", { beforeExpr: !0, startsExpr: !0 }),
    bracketR: new vr("]"),
    braceL: new vr("{", { beforeExpr: !0, startsExpr: !0 }),
    braceR: new vr("}"),
    parenL: new vr("(", { beforeExpr: !0, startsExpr: !0 }),
    parenR: new vr(")"),
    comma: new vr(",", La),
    semi: new vr(";", La),
    colon: new vr(":", La),
    dot: new vr("."),
    question: new vr("?", La),
    questionDot: new vr("?."),
    arrow: new vr("=>", La),
    template: new vr("template"),
    invalidTemplate: new vr("invalidTemplate"),
    ellipsis: new vr("...", La),
    backQuote: new vr("`", Gs),
    dollarBraceL: new vr("${", { beforeExpr: !0, startsExpr: !0 }),
    // Operators. These carry several kinds of properties to help the
    // parser use them properly (the presence of these properties is
    // what categorizes them as operators).
    //
    // `binop`, when present, specifies that this operator is a binary
    // operator, and will refer to its precedence.
    //
    // `prefix` and `postfix` mark the operator as a prefix or postfix
    // unary operator.
    //
    // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
    // binary operators with a very low precedence, that should result
    // in AssignmentExpression nodes.
    eq: new vr("=", { beforeExpr: !0, isAssign: !0 }),
    assign: new vr("_=", { beforeExpr: !0, isAssign: !0 }),
    incDec: new vr("++/--", { prefix: !0, postfix: !0, startsExpr: !0 }),
    prefix: new vr("!/~", { beforeExpr: !0, prefix: !0, startsExpr: !0 }),
    logicalOR: Na("||", 1),
    logicalAND: Na("&&", 2),
    bitwiseOR: Na("|", 3),
    bitwiseXOR: Na("^", 4),
    bitwiseAND: Na("&", 5),
    equality: Na("==/!=/===/!==", 6),
    relational: Na("</>/<=/>=", 7),
    bitShift: Na("<</>>/>>>", 8),
    plusMin: new vr("+/-", { beforeExpr: !0, binop: 9, prefix: !0, startsExpr: !0 }),
    modulo: Na("%", 10),
    star: Na("*", 10),
    slash: Na("/", 10),
    starstar: new vr("**", { beforeExpr: !0 }),
    coalesce: Na("??", 1),
    // Keyword token types.
    _break: hr("break"),
    _case: hr("case", La),
    _catch: hr("catch"),
    _continue: hr("continue"),
    _debugger: hr("debugger"),
    _default: hr("default", La),
    _do: hr("do", { isLoop: !0, beforeExpr: !0 }),
    _else: hr("else", La),
    _finally: hr("finally"),
    _for: hr("for", { isLoop: !0 }),
    _function: hr("function", Gs),
    _if: hr("if"),
    _return: hr("return", La),
    _switch: hr("switch"),
    _throw: hr("throw", La),
    _try: hr("try"),
    _var: hr("var"),
    _const: hr("const"),
    _while: hr("while", { isLoop: !0 }),
    _with: hr("with"),
    _new: hr("new", { beforeExpr: !0, startsExpr: !0 }),
    _this: hr("this", Gs),
    _super: hr("super", Gs),
    _class: hr("class", Gs),
    _extends: hr("extends", La),
    _export: hr("export"),
    _import: hr("import", Gs),
    _null: hr("null", Gs),
    _true: hr("true", Gs),
    _false: hr("false", Gs),
    _in: hr("in", { beforeExpr: !0, binop: 7 }),
    _instanceof: hr("instanceof", { beforeExpr: !0, binop: 7 }),
    _typeof: hr("typeof", { beforeExpr: !0, prefix: !0, startsExpr: !0 }),
    _void: hr("void", { beforeExpr: !0, prefix: !0, startsExpr: !0 }),
    _delete: hr("delete", { beforeExpr: !0, prefix: !0, startsExpr: !0 })
  }, fa = /\r\n?|\n|\u2028|\u2029/, Rne = new RegExp(fa.source, "g");
  s(hf, "isNewLine");
  s(Nne, "nextLineBreak");
  iI = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/, Ma = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, Lne = Object.prototype, Kpt = Lne.hasOwnProperty,
  Hpt = Lne.toString, dh = Object.hasOwn || function(e, t) {
    return Kpt.call(e, t);
  }, Cne = Array.isArray || function(e) {
    return Hpt.call(e) === "[object Array]";
  }, Pne = /* @__PURE__ */ Object.create(null);
  s(Xl, "wordsRegexp");
  s(Vu, "codePointToString");
  zpt = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/, hh = /* @__PURE__ */ s(function(t, r) {
    this.line = t, this.column = r;
  }, "Position");
  hh.prototype.offset = /* @__PURE__ */ s(function(t) {
    return new hh(this.line, this.column + t);
  }, "offset");
  my = /* @__PURE__ */ s(function(t, r, i) {
    this.start = r, this.end = i, t.sourceFile !== null && (this.source = t.sourceFile);
  }, "SourceLocation");
  s(nI, "getLineInfo");
  y0 = {
    // `ecmaVersion` indicates the ECMAScript version to parse. Must be
    // either 3, 5, 6 (or 2015), 7 (2016), 8 (2017), 9 (2018), 10
    // (2019), 11 (2020), 12 (2021), 13 (2022), 14 (2023), or `"latest"`
    // (the latest version the library supports). This influences
    // support for strict mode, the set of reserved words, and support
    // for new syntax features.
    ecmaVersion: null,
    // `sourceType` indicates the mode the code should be parsed in.
    // Can be either `"script"` or `"module"`. This influences global
    // strict mode and parsing of `import` and `export` declarations.
    sourceType: "script",
    // `onInsertedSemicolon` can be a callback that will be called when
    // a semicolon is automatically inserted. It will be passed the
    // position of the inserted semicolon as an offset, and if
    // `locations` is enabled, it is given the location as a `{line,
    // column}` object as second argument.
    onInsertedSemicolon: null,
    // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
    // trailing commas.
    onTrailingComma: null,
    // By default, reserved words are only enforced if ecmaVersion >= 5.
    // Set `allowReserved` to a boolean value to explicitly turn this on
    // an off. When this option has the value "never", reserved words
    // and keywords can also not be used as property names.
    allowReserved: null,
    // When enabled, a return at the top level is not considered an
    // error.
    allowReturnOutsideFunction: !1,
    // When enabled, import/export statements are not constrained to
    // appearing at the top of the program, and an import.meta expression
    // in a script isn't considered an error.
    allowImportExportEverywhere: !1,
    // By default, await identifiers are allowed to appear at the top-level scope only if ecmaVersion >= 2022.
    // When enabled, await identifiers are allowed to appear at the top-level scope,
    // but they are still not allowed in non-async functions.
    allowAwaitOutsideFunction: null,
    // When enabled, super identifiers are not constrained to
    // appearing in methods and do not raise an error when they appear elsewhere.
    allowSuperOutsideMethod: null,
    // When enabled, hashbang directive in the beginning of file is
    // allowed and treated as a line comment. Enabled by default when
    // `ecmaVersion` >= 2023.
    allowHashBang: !1,
    // By default, the parser will verify that private properties are
    // only used in places where they are valid and have been declared.
    // Set this to false to turn such checks off.
    checkPrivateFields: !0,
    // When `locations` is on, `loc` properties holding objects with
    // `start` and `end` properties in `{line, column}` form (with
    // line being 1-based and column 0-based) will be attached to the
    // nodes.
    locations: !1,
    // A function can be passed as `onToken` option, which will
    // cause Acorn to call that function with object in the same
    // format as tokens returned from `tokenizer().getToken()`. Note
    // that you are not allowed to call the parser from the
    // callback—that will corrupt its internal state.
    onToken: null,
    // A function can be passed as `onComment` option, which will
    // cause Acorn to call that function with `(block, text, start,
    // end)` parameters whenever a comment is skipped. `block` is a
    // boolean indicating whether this is a block (`/* */`) comment,
    // `text` is the content of the comment, and `start` and `end` are
    // character offsets that denote the start and end of the comment.
    // When the `locations` option is on, two more parameters are
    // passed, the full `{line, column}` locations of the start and
    // end of the comments. Note that you are not allowed to call the
    // parser from the callback—that will corrupt its internal state.
    // When this option has an array as value, objects representing the
    // comments are pushed to it.
    onComment: null,
    // Nodes have their start and end characters offsets recorded in
    // `start` and `end` properties (directly on the node, rather than
    // the `loc` object, which holds line/column data. To also add a
    // [semi-standardized][range] `range` property holding a `[start,
    // end]` array with the same numbers, set the `ranges` option to
    // `true`.
    //
    // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
    ranges: !1,
    // It is possible to parse multiple files into a single AST by
    // passing the tree produced by parsing the first file as
    // `program` option in subsequent parses. This will add the
    // toplevel forms of the parsed file to the `Program` (top) node
    // of an existing parse tree.
    program: null,
    // When `locations` is on, you can pass this to record the source
    // file in every node's `loc` object.
    sourceFile: null,
    // This value, if given, is stored in every node, whether
    // `locations` is on or off.
    directSourceFile: null,
    // When enabled, parenthesized expressions are represented by
    // (non-standard) ParenthesizedExpression nodes
    preserveParens: !1
  }, Dne = !1;
  s(Gpt, "getOptions");
  s(Wpt, "pushComment");
  dy = 1, mh = 2, sI = 4, Fne = 8, aI = 16, Mne = 32, T0 = 64, Bne = 128, df = 256, yy = 512, E0 = dy | mh | df;
  s(oI, "functionFlags");
  g0 = 0, uI = 1, Hu = 2, qne = 3, Une = 4, jne = 5, ji = /* @__PURE__ */ s(function(t, r, i) {
    this.options = t = Gpt(t), this.sourceFile = t.sourceFile, this.keywords = Xl(qpt[t.ecmaVersion >= 6 ? 6 : t.sourceType === "module" ? "\
5module" : 5]);
    var n = "";
    t.allowReserved !== !0 && (n = Jk[t.ecmaVersion >= 6 ? 6 : t.ecmaVersion === 5 ? 5 : 3], t.sourceType === "module" && (n += " await")), this.
    reservedWords = Xl(n);
    var a = (n ? n + " " : "") + Jk.strict;
    this.reservedWordsStrict = Xl(a), this.reservedWordsStrictBind = Xl(a + " " + Jk.strictBind), this.input = String(r), this.containsEsc =
    !1, i ? (this.pos = i, this.lineStart = this.input.lastIndexOf(`
`, i - 1) + 1, this.curLine = this.input.slice(0, this.lineStart).split(fa).length) : (this.pos = this.lineStart = 0, this.curLine = 1), this.
    type = O.eof, this.value = null, this.start = this.end = this.pos, this.startLoc = this.endLoc = this.curPosition(), this.lastTokEndLoc =
    this.lastTokStartLoc = null, this.lastTokStart = this.lastTokEnd = this.pos, this.context = this.initialContext(), this.exprAllowed = !0,
    this.inModule = t.sourceType === "module", this.strict = this.inModule || this.strictDirective(this.pos), this.potentialArrowAt = -1, this.
    potentialArrowInForAwait = !1, this.yieldPos = this.awaitPos = this.awaitIdentPos = 0, this.labels = [], this.undefinedExports = /* @__PURE__ */ Object.
    create(null), this.pos === 0 && t.allowHashBang && this.input.slice(0, 2) === "#!" && this.skipLineComment(2), this.scopeStack = [], this.
    enterScope(dy), this.regexpState = null, this.privateNameStack = [];
  }, "Parser"), tu = { inFunction: { configurable: !0 }, inGenerator: { configurable: !0 }, inAsync: { configurable: !0 }, canAwait: { configurable: !0 },
  allowSuper: { configurable: !0 }, allowDirectSuper: { configurable: !0 }, treatFunctionsAsVar: { configurable: !0 }, allowNewDotTarget: { configurable: !0 },
  inClassStaticBlock: { configurable: !0 } };
  ji.prototype.parse = /* @__PURE__ */ s(function() {
    var t = this.options.program || this.startNode();
    return this.nextToken(), this.parseTopLevel(t);
  }, "parse");
  tu.inFunction.get = function() {
    return (this.currentVarScope().flags & mh) > 0;
  };
  tu.inGenerator.get = function() {
    return (this.currentVarScope().flags & Fne) > 0;
  };
  tu.inAsync.get = function() {
    return (this.currentVarScope().flags & sI) > 0;
  };
  tu.canAwait.get = function() {
    for (var e = this.scopeStack.length - 1; e >= 0; e--) {
      var t = this.scopeStack[e], r = t.flags;
      if (r & (df | yy))
        return !1;
      if (r & mh)
        return (r & sI) > 0;
    }
    return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;
  };
  tu.allowSuper.get = function() {
    var e = this.currentThisScope(), t = e.flags;
    return (t & T0) > 0 || this.options.allowSuperOutsideMethod;
  };
  tu.allowDirectSuper.get = function() {
    return (this.currentThisScope().flags & Bne) > 0;
  };
  tu.treatFunctionsAsVar.get = function() {
    return this.treatFunctionsAsVarInScope(this.currentScope());
  };
  tu.allowNewDotTarget.get = function() {
    for (var e = this.scopeStack.length - 1; e >= 0; e--) {
      var t = this.scopeStack[e], r = t.flags;
      if (r & (df | yy) || r & mh && !(r & aI))
        return !0;
    }
    return !1;
  };
  tu.inClassStaticBlock.get = function() {
    return (this.currentVarScope().flags & df) > 0;
  };
  ji.extend = /* @__PURE__ */ s(function() {
    for (var t = [], r = arguments.length; r--; ) t[r] = arguments[r];
    for (var i = this, n = 0; n < t.length; n++)
      i = t[n](i);
    return i;
  }, "extend");
  ji.parse = /* @__PURE__ */ s(function(t, r) {
    return new this(r, t).parse();
  }, "parse");
  ji.parseExpressionAt = /* @__PURE__ */ s(function(t, r, i) {
    var n = new this(i, t, r);
    return n.nextToken(), n.parseExpression();
  }, "parseExpressionAt");
  ji.tokenizer = /* @__PURE__ */ s(function(t, r) {
    return new this(r, t);
  }, "tokenizer");
  Object.defineProperties(ji.prototype, tu);
  As = ji.prototype, $pt = /^(?:'((?:\\[^]|[^'\\])*?)'|"((?:\\[^]|[^"\\])*?)")/;
  As.strictDirective = function(e) {
    if (this.options.ecmaVersion < 5)
      return !1;
    for (; ; ) {
      Ma.lastIndex = e, e += Ma.exec(this.input)[0].length;
      var t = $pt.exec(this.input.slice(e));
      if (!t)
        return !1;
      if ((t[1] || t[2]) === "use strict") {
        Ma.lastIndex = e + t[0].length;
        var r = Ma.exec(this.input), i = r.index + r[0].length, n = this.input.charAt(i);
        return n === ";" || n === "}" || fa.test(r[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(n) || n === "!" && this.input.charAt(i + 1) === "=");
      }
      e += t[0].length, Ma.lastIndex = e, e += Ma.exec(this.input)[0].length, this.input[e] === ";" && e++;
    }
  };
  As.eat = function(e) {
    return this.type === e ? (this.next(), !0) : !1;
  };
  As.isContextual = function(e) {
    return this.type === O.name && this.value === e && !this.containsEsc;
  };
  As.eatContextual = function(e) {
    return this.isContextual(e) ? (this.next(), !0) : !1;
  };
  As.expectContextual = function(e) {
    this.eatContextual(e) || this.unexpected();
  };
  As.canInsertSemicolon = function() {
    return this.type === O.eof || this.type === O.braceR || fa.test(this.input.slice(this.lastTokEnd, this.start));
  };
  As.insertSemicolon = function() {
    if (this.canInsertSemicolon())
      return this.options.onInsertedSemicolon && this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc), !0;
  };
  As.semicolon = function() {
    !this.eat(O.semi) && !this.insertSemicolon() && this.unexpected();
  };
  As.afterTrailingComma = function(e, t) {
    if (this.type === e)
      return this.options.onTrailingComma && this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc), t || this.next(), !0;
  };
  As.expect = function(e) {
    this.eat(e) || this.unexpected();
  };
  As.unexpected = function(e) {
    this.raise(e ?? this.start, "Unexpected token");
  };
  A0 = /* @__PURE__ */ s(function() {
    this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
  }, "DestructuringErrors");
  As.checkPatternErrors = function(e, t) {
    if (e) {
      e.trailingComma > -1 && this.raiseRecoverable(e.trailingComma, "Comma is not permitted after the rest element");
      var r = t ? e.parenthesizedAssign : e.parenthesizedBind;
      r > -1 && this.raiseRecoverable(r, t ? "Assigning to rvalue" : "Parenthesized pattern");
    }
  };
  As.checkExpressionErrors = function(e, t) {
    if (!e)
      return !1;
    var r = e.shorthandAssign, i = e.doubleProto;
    if (!t)
      return r >= 0 || i >= 0;
    r >= 0 && this.raise(r, "Shorthand property assignments are valid only in destructuring patterns"), i >= 0 && this.raiseRecoverable(i, "\
Redefinition of __proto__ property");
  };
  As.checkYieldAwaitInDefaultParams = function() {
    this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos) && this.raise(this.yieldPos, "Yield expression cannot be a default va\
lue"), this.awaitPos && this.raise(this.awaitPos, "Await expression cannot be a default value");
  };
  As.isSimpleAssignTarget = function(e) {
    return e.type === "ParenthesizedExpression" ? this.isSimpleAssignTarget(e.expression) : e.type === "Identifier" || e.type === "MemberExp\
ression";
  };
  ut = ji.prototype;
  ut.parseTopLevel = function(e) {
    var t = /* @__PURE__ */ Object.create(null);
    for (e.body || (e.body = []); this.type !== O.eof; ) {
      var r = this.parseStatement(null, !0, t);
      e.body.push(r);
    }
    if (this.inModule)
      for (var i = 0, n = Object.keys(this.undefinedExports); i < n.length; i += 1) {
        var a = n[i];
        this.raiseRecoverable(this.undefinedExports[a].start, "Export '" + a + "' is not defined");
      }
    return this.adaptDirectivePrologue(e.body), this.next(), e.sourceType = this.options.sourceType, this.finishNode(e, "Program");
  };
  lI = { kind: "loop" }, Xpt = { kind: "switch" };
  ut.isLet = function(e) {
    if (this.options.ecmaVersion < 6 || !this.isContextual("let"))
      return !1;
    Ma.lastIndex = this.pos;
    var t = Ma.exec(this.input), r = this.pos + t[0].length, i = this.input.charCodeAt(r);
    if (i === 91 || i === 92)
      return !0;
    if (e)
      return !1;
    if (i === 123 || i > 55295 && i < 56320)
      return !0;
    if (eu(i, !0)) {
      for (var n = r + 1; pf(i = this.input.charCodeAt(n), !0); )
        ++n;
      if (i === 92 || i > 55295 && i < 56320)
        return !0;
      var a = this.input.slice(r, n);
      if (!Upt.test(a))
        return !0;
    }
    return !1;
  };
  ut.isAsyncFunction = function() {
    if (this.options.ecmaVersion < 8 || !this.isContextual("async"))
      return !1;
    Ma.lastIndex = this.pos;
    var e = Ma.exec(this.input), t = this.pos + e[0].length, r;
    return !fa.test(this.input.slice(this.pos, t)) && this.input.slice(t, t + 8) === "function" && (t + 8 === this.input.length || !(pf(r = this.
    input.charCodeAt(t + 8)) || r > 55295 && r < 56320));
  };
  ut.parseStatement = function(e, t, r) {
    var i = this.type, n = this.startNode(), a;
    switch (this.isLet(e) && (i = O._var, a = "let"), i) {
      case O._break:
      case O._continue:
        return this.parseBreakContinueStatement(n, i.keyword);
      case O._debugger:
        return this.parseDebuggerStatement(n);
      case O._do:
        return this.parseDoStatement(n);
      case O._for:
        return this.parseForStatement(n);
      case O._function:
        return e && (this.strict || e !== "if" && e !== "label") && this.options.ecmaVersion >= 6 && this.unexpected(), this.parseFunctionStatement(
        n, !1, !e);
      case O._class:
        return e && this.unexpected(), this.parseClass(n, !0);
      case O._if:
        return this.parseIfStatement(n);
      case O._return:
        return this.parseReturnStatement(n);
      case O._switch:
        return this.parseSwitchStatement(n);
      case O._throw:
        return this.parseThrowStatement(n);
      case O._try:
        return this.parseTryStatement(n);
      case O._const:
      case O._var:
        return a = a || this.value, e && a !== "var" && this.unexpected(), this.parseVarStatement(n, a);
      case O._while:
        return this.parseWhileStatement(n);
      case O._with:
        return this.parseWithStatement(n);
      case O.braceL:
        return this.parseBlock(!0, n);
      case O.semi:
        return this.parseEmptyStatement(n);
      case O._export:
      case O._import:
        if (this.options.ecmaVersion > 10 && i === O._import) {
          Ma.lastIndex = this.pos;
          var o = Ma.exec(this.input), u = this.pos + o[0].length, l = this.input.charCodeAt(u);
          if (l === 40 || l === 46)
            return this.parseExpressionStatement(n, this.parseExpression());
        }
        return this.options.allowImportExportEverywhere || (t || this.raise(this.start, "'import' and 'export' may only appear at the top le\
vel"), this.inModule || this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'")), i === O._import ? this.parseImport(
        n) : this.parseExport(n, r);
      // If the statement does not start with a statement keyword or a
      // brace, it's an ExpressionStatement or LabeledStatement. We
      // simply start parsing an expression, and afterwards, if the
      // next token is a colon and the expression was a simple
      // Identifier node, we switch to interpreting it as a label.
      default:
        if (this.isAsyncFunction())
          return e && this.unexpected(), this.next(), this.parseFunctionStatement(n, !0, !e);
        var c = this.value, p = this.parseExpression();
        return i === O.name && p.type === "Identifier" && this.eat(O.colon) ? this.parseLabeledStatement(n, c, p, e) : this.parseExpressionStatement(
        n, p);
    }
  };
  ut.parseBreakContinueStatement = function(e, t) {
    var r = t === "break";
    this.next(), this.eat(O.semi) || this.insertSemicolon() ? e.label = null : this.type !== O.name ? this.unexpected() : (e.label = this.parseIdent(),
    this.semicolon());
    for (var i = 0; i < this.labels.length; ++i) {
      var n = this.labels[i];
      if ((e.label == null || n.name === e.label.name) && (n.kind != null && (r || n.kind === "loop") || e.label && r))
        break;
    }
    return i === this.labels.length && this.raise(e.start, "Unsyntactic " + t), this.finishNode(e, r ? "BreakStatement" : "ContinueStatement");
  };
  ut.parseDebuggerStatement = function(e) {
    return this.next(), this.semicolon(), this.finishNode(e, "DebuggerStatement");
  };
  ut.parseDoStatement = function(e) {
    return this.next(), this.labels.push(lI), e.body = this.parseStatement("do"), this.labels.pop(), this.expect(O._while), e.test = this.parseParenExpression(),
    this.options.ecmaVersion >= 6 ? this.eat(O.semi) : this.semicolon(), this.finishNode(e, "DoWhileStatement");
  };
  ut.parseForStatement = function(e) {
    this.next();
    var t = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
    if (this.labels.push(lI), this.enterScope(0), this.expect(O.parenL), this.type === O.semi)
      return t > -1 && this.unexpected(t), this.parseFor(e, null);
    var r = this.isLet();
    if (this.type === O._var || this.type === O._const || r) {
      var i = this.startNode(), n = r ? "let" : this.value;
      return this.next(), this.parseVar(i, !0, n), this.finishNode(i, "VariableDeclaration"), (this.type === O._in || this.options.ecmaVersion >=
      6 && this.isContextual("of")) && i.declarations.length === 1 ? (this.options.ecmaVersion >= 9 && (this.type === O._in ? t > -1 && this.
      unexpected(t) : e.await = t > -1), this.parseForIn(e, i)) : (t > -1 && this.unexpected(t), this.parseFor(e, i));
    }
    var a = this.isContextual("let"), o = !1, u = this.containsEsc, l = new A0(), c = this.start, p = t > -1 ? this.parseExprSubscripts(l, "\
await") : this.parseExpression(!0, l);
    return this.type === O._in || (o = this.options.ecmaVersion >= 6 && this.isContextual("of")) ? (t > -1 ? (this.type === O._in && this.unexpected(
    t), e.await = !0) : o && this.options.ecmaVersion >= 8 && (p.start === c && !u && p.type === "Identifier" && p.name === "async" ? this.unexpected() :
    this.options.ecmaVersion >= 9 && (e.await = !1)), a && o && this.raise(p.start, "The left-hand side of a for-of loop may not start with \
'let'."), this.toAssignable(p, !1, l), this.checkLValPattern(p), this.parseForIn(e, p)) : (this.checkExpressionErrors(l, !0), t > -1 && this.
    unexpected(t), this.parseFor(e, p));
  };
  ut.parseFunctionStatement = function(e, t, r) {
    return this.next(), this.parseFunction(e, hy | (r ? 0 : tI), !1, t);
  };
  ut.parseIfStatement = function(e) {
    return this.next(), e.test = this.parseParenExpression(), e.consequent = this.parseStatement("if"), e.alternate = this.eat(O._else) ? this.
    parseStatement("if") : null, this.finishNode(e, "IfStatement");
  };
  ut.parseReturnStatement = function(e) {
    return !this.inFunction && !this.options.allowReturnOutsideFunction && this.raise(this.start, "'return' outside of function"), this.next(),
    this.eat(O.semi) || this.insertSemicolon() ? e.argument = null : (e.argument = this.parseExpression(), this.semicolon()), this.finishNode(
    e, "ReturnStatement");
  };
  ut.parseSwitchStatement = function(e) {
    this.next(), e.discriminant = this.parseParenExpression(), e.cases = [], this.expect(O.braceL), this.labels.push(Xpt), this.enterScope(0);
    for (var t, r = !1; this.type !== O.braceR; )
      if (this.type === O._case || this.type === O._default) {
        var i = this.type === O._case;
        t && this.finishNode(t, "SwitchCase"), e.cases.push(t = this.startNode()), t.consequent = [], this.next(), i ? t.test = this.parseExpression() :
        (r && this.raiseRecoverable(this.lastTokStart, "Multiple default clauses"), r = !0, t.test = null), this.expect(O.colon);
      } else
        t || this.unexpected(), t.consequent.push(this.parseStatement(null));
    return this.exitScope(), t && this.finishNode(t, "SwitchCase"), this.next(), this.labels.pop(), this.finishNode(e, "SwitchStatement");
  };
  ut.parseThrowStatement = function(e) {
    return this.next(), fa.test(this.input.slice(this.lastTokEnd, this.start)) && this.raise(this.lastTokEnd, "Illegal newline after throw"),
    e.argument = this.parseExpression(), this.semicolon(), this.finishNode(e, "ThrowStatement");
  };
  Ypt = [];
  ut.parseCatchClauseParam = function() {
    var e = this.parseBindingAtom(), t = e.type === "Identifier";
    return this.enterScope(t ? Mne : 0), this.checkLValPattern(e, t ? Une : Hu), this.expect(O.parenR), e;
  };
  ut.parseTryStatement = function(e) {
    if (this.next(), e.block = this.parseBlock(), e.handler = null, this.type === O._catch) {
      var t = this.startNode();
      this.next(), this.eat(O.parenL) ? t.param = this.parseCatchClauseParam() : (this.options.ecmaVersion < 10 && this.unexpected(), t.param =
      null, this.enterScope(0)), t.body = this.parseBlock(!1), this.exitScope(), e.handler = this.finishNode(t, "CatchClause");
    }
    return e.finalizer = this.eat(O._finally) ? this.parseBlock() : null, !e.handler && !e.finalizer && this.raise(e.start, "Missing catch o\
r finally clause"), this.finishNode(e, "TryStatement");
  };
  ut.parseVarStatement = function(e, t, r) {
    return this.next(), this.parseVar(e, !1, t, r), this.semicolon(), this.finishNode(e, "VariableDeclaration");
  };
  ut.parseWhileStatement = function(e) {
    return this.next(), e.test = this.parseParenExpression(), this.labels.push(lI), e.body = this.parseStatement("while"), this.labels.pop(),
    this.finishNode(e, "WhileStatement");
  };
  ut.parseWithStatement = function(e) {
    return this.strict && this.raise(this.start, "'with' in strict mode"), this.next(), e.object = this.parseParenExpression(), e.body = this.
    parseStatement("with"), this.finishNode(e, "WithStatement");
  };
  ut.parseEmptyStatement = function(e) {
    return this.next(), this.finishNode(e, "EmptyStatement");
  };
  ut.parseLabeledStatement = function(e, t, r, i) {
    for (var n = 0, a = this.labels; n < a.length; n += 1) {
      var o = a[n];
      o.name === t && this.raise(r.start, "Label '" + t + "' is already declared");
    }
    for (var u = this.type.isLoop ? "loop" : this.type === O._switch ? "switch" : null, l = this.labels.length - 1; l >= 0; l--) {
      var c = this.labels[l];
      if (c.statementStart === e.start)
        c.statementStart = this.start, c.kind = u;
      else
        break;
    }
    return this.labels.push({ name: t, kind: u, statementStart: this.start }), e.body = this.parseStatement(i ? i.indexOf("label") === -1 ? i +
    "label" : i : "label"), this.labels.pop(), e.label = r, this.finishNode(e, "LabeledStatement");
  };
  ut.parseExpressionStatement = function(e, t) {
    return e.expression = t, this.semicolon(), this.finishNode(e, "ExpressionStatement");
  };
  ut.parseBlock = function(e, t, r) {
    for (e === void 0 && (e = !0), t === void 0 && (t = this.startNode()), t.body = [], this.expect(O.braceL), e && this.enterScope(0); this.
    type !== O.braceR; ) {
      var i = this.parseStatement(null);
      t.body.push(i);
    }
    return r && (this.strict = !1), this.next(), e && this.exitScope(), this.finishNode(t, "BlockStatement");
  };
  ut.parseFor = function(e, t) {
    return e.init = t, this.expect(O.semi), e.test = this.type === O.semi ? null : this.parseExpression(), this.expect(O.semi), e.update = this.
    type === O.parenR ? null : this.parseExpression(), this.expect(O.parenR), e.body = this.parseStatement("for"), this.exitScope(), this.labels.
    pop(), this.finishNode(e, "ForStatement");
  };
  ut.parseForIn = function(e, t) {
    var r = this.type === O._in;
    return this.next(), t.type === "VariableDeclaration" && t.declarations[0].init != null && (!r || this.options.ecmaVersion < 8 || this.strict ||
    t.kind !== "var" || t.declarations[0].id.type !== "Identifier") && this.raise(
      t.start,
      (r ? "for-in" : "for-of") + " loop variable declaration may not have an initializer"
    ), e.left = t, e.right = r ? this.parseExpression() : this.parseMaybeAssign(), this.expect(O.parenR), e.body = this.parseStatement("for"),
    this.exitScope(), this.labels.pop(), this.finishNode(e, r ? "ForInStatement" : "ForOfStatement");
  };
  ut.parseVar = function(e, t, r, i) {
    for (e.declarations = [], e.kind = r; ; ) {
      var n = this.startNode();
      if (this.parseVarId(n, r), this.eat(O.eq) ? n.init = this.parseMaybeAssign(t) : !i && r === "const" && !(this.type === O._in || this.options.
      ecmaVersion >= 6 && this.isContextual("of")) ? this.unexpected() : !i && n.id.type !== "Identifier" && !(t && (this.type === O._in || this.
      isContextual("of"))) ? this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value") : n.init = null, e.declarations.
      push(this.finishNode(n, "VariableDeclarator")), !this.eat(O.comma))
        break;
    }
    return e;
  };
  ut.parseVarId = function(e, t) {
    e.id = this.parseBindingAtom(), this.checkLValPattern(e.id, t === "var" ? uI : Hu, !1);
  };
  hy = 1, tI = 2, Vne = 4;
  ut.parseFunction = function(e, t, r, i, n) {
    this.initFunction(e), (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !i) && (this.type === O.star && t & tI && this.
    unexpected(), e.generator = this.eat(O.star)), this.options.ecmaVersion >= 8 && (e.async = !!i), t & hy && (e.id = t & Vne && this.type !==
    O.name ? null : this.parseIdent(), e.id && !(t & tI) && this.checkLValSimple(e.id, this.strict || e.generator || e.async ? this.treatFunctionsAsVar ?
    uI : Hu : qne));
    var a = this.yieldPos, o = this.awaitPos, u = this.awaitIdentPos;
    return this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, this.enterScope(oI(e.async, e.generator)), t & hy || (e.id = this.type ===
    O.name ? this.parseIdent() : null), this.parseFunctionParams(e), this.parseFunctionBody(e, r, !1, n), this.yieldPos = a, this.awaitPos =
    o, this.awaitIdentPos = u, this.finishNode(e, t & hy ? "FunctionDeclaration" : "FunctionExpression");
  };
  ut.parseFunctionParams = function(e) {
    this.expect(O.parenL), e.params = this.parseBindingList(O.parenR, !1, this.options.ecmaVersion >= 8), this.checkYieldAwaitInDefaultParams();
  };
  ut.parseClass = function(e, t) {
    this.next();
    var r = this.strict;
    this.strict = !0, this.parseClassId(e, t), this.parseClassSuper(e);
    var i = this.enterClassBody(), n = this.startNode(), a = !1;
    for (n.body = [], this.expect(O.braceL); this.type !== O.braceR; ) {
      var o = this.parseClassElement(e.superClass !== null);
      o && (n.body.push(o), o.type === "MethodDefinition" && o.kind === "constructor" ? (a && this.raiseRecoverable(o.start, "Duplicate cons\
tructor in the same class"), a = !0) : o.key && o.key.type === "PrivateIdentifier" && Jpt(i, o) && this.raiseRecoverable(o.key.start, "Ident\
ifier '#" + o.key.name + "' has already been declared"));
    }
    return this.strict = r, this.next(), e.body = this.finishNode(n, "ClassBody"), this.exitClassBody(), this.finishNode(e, t ? "ClassDeclar\
ation" : "ClassExpression");
  };
  ut.parseClassElement = function(e) {
    if (this.eat(O.semi))
      return null;
    var t = this.options.ecmaVersion, r = this.startNode(), i = "", n = !1, a = !1, o = "method", u = !1;
    if (this.eatContextual("static")) {
      if (t >= 13 && this.eat(O.braceL))
        return this.parseClassStaticBlock(r), r;
      this.isClassElementNameStart() || this.type === O.star ? u = !0 : i = "static";
    }
    if (r.static = u, !i && t >= 8 && this.eatContextual("async") && ((this.isClassElementNameStart() || this.type === O.star) && !this.canInsertSemicolon() ?
    a = !0 : i = "async"), !i && (t >= 9 || !a) && this.eat(O.star) && (n = !0), !i && !a && !n) {
      var l = this.value;
      (this.eatContextual("get") || this.eatContextual("set")) && (this.isClassElementNameStart() ? o = l : i = l);
    }
    if (i ? (r.computed = !1, r.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc), r.key.name = i, this.finishNode(r.key, "Ide\
ntifier")) : this.parseClassElementName(r), t < 13 || this.type === O.parenL || o !== "method" || n || a) {
      var c = !r.static && _0(r, "constructor"), p = c && e;
      c && o !== "method" && this.raise(r.key.start, "Constructor can't have get/set modifier"), r.kind = c ? "constructor" : o, this.parseClassMethod(
      r, n, a, p);
    } else
      this.parseClassField(r);
    return r;
  };
  ut.isClassElementNameStart = function() {
    return this.type === O.name || this.type === O.privateId || this.type === O.num || this.type === O.string || this.type === O.bracketL ||
    this.type.keyword;
  };
  ut.parseClassElementName = function(e) {
    this.type === O.privateId ? (this.value === "constructor" && this.raise(this.start, "Classes can't have an element named '#constructor'"),
    e.computed = !1, e.key = this.parsePrivateIdent()) : this.parsePropertyName(e);
  };
  ut.parseClassMethod = function(e, t, r, i) {
    var n = e.key;
    e.kind === "constructor" ? (t && this.raise(n.start, "Constructor can't be a generator"), r && this.raise(n.start, "Constructor can't be\
 an async method")) : e.static && _0(e, "prototype") && this.raise(n.start, "Classes may not have a static property named prototype");
    var a = e.value = this.parseMethod(t, r, i);
    return e.kind === "get" && a.params.length !== 0 && this.raiseRecoverable(a.start, "getter should have no params"), e.kind === "set" && a.
    params.length !== 1 && this.raiseRecoverable(a.start, "setter should have exactly one param"), e.kind === "set" && a.params[0].type === "\
RestElement" && this.raiseRecoverable(a.params[0].start, "Setter cannot use rest params"), this.finishNode(e, "MethodDefinition");
  };
  ut.parseClassField = function(e) {
    return _0(e, "constructor") ? this.raise(e.key.start, "Classes can't have a field named 'constructor'") : e.static && _0(e, "prototype") &&
    this.raise(e.key.start, "Classes can't have a static field named 'prototype'"), this.eat(O.eq) ? (this.enterScope(yy | T0), e.value = this.
    parseMaybeAssign(), this.exitScope()) : e.value = null, this.semicolon(), this.finishNode(e, "PropertyDefinition");
  };
  ut.parseClassStaticBlock = function(e) {
    e.body = [];
    var t = this.labels;
    for (this.labels = [], this.enterScope(df | T0); this.type !== O.braceR; ) {
      var r = this.parseStatement(null);
      e.body.push(r);
    }
    return this.next(), this.exitScope(), this.labels = t, this.finishNode(e, "StaticBlock");
  };
  ut.parseClassId = function(e, t) {
    this.type === O.name ? (e.id = this.parseIdent(), t && this.checkLValSimple(e.id, Hu, !1)) : (t === !0 && this.unexpected(), e.id = null);
  };
  ut.parseClassSuper = function(e) {
    e.superClass = this.eat(O._extends) ? this.parseExprSubscripts(null, !1) : null;
  };
  ut.enterClassBody = function() {
    var e = { declared: /* @__PURE__ */ Object.create(null), used: [] };
    return this.privateNameStack.push(e), e.declared;
  };
  ut.exitClassBody = function() {
    var e = this.privateNameStack.pop(), t = e.declared, r = e.used;
    if (this.options.checkPrivateFields)
      for (var i = this.privateNameStack.length, n = i === 0 ? null : this.privateNameStack[i - 1], a = 0; a < r.length; ++a) {
        var o = r[a];
        dh(t, o.name) || (n ? n.used.push(o) : this.raiseRecoverable(o.start, "Private field '#" + o.name + "' must be declared in an enclos\
ing class"));
      }
  };
  s(Jpt, "isPrivateNameConflicted");
  s(_0, "checkKeyName");
  ut.parseExportAllDeclaration = function(e, t) {
    return this.options.ecmaVersion >= 11 && (this.eatContextual("as") ? (e.exported = this.parseModuleExportName(), this.checkExport(t, e.exported,
    this.lastTokStart)) : e.exported = null), this.expectContextual("from"), this.type !== O.string && this.unexpected(), e.source = this.parseExprAtom(),
    this.options.ecmaVersion >= 16 && (e.attributes = this.parseWithClause()), this.semicolon(), this.finishNode(e, "ExportAllDeclaration");
  };
  ut.parseExport = function(e, t) {
    if (this.next(), this.eat(O.star))
      return this.parseExportAllDeclaration(e, t);
    if (this.eat(O._default))
      return this.checkExport(t, "default", this.lastTokStart), e.declaration = this.parseExportDefaultDeclaration(), this.finishNode(e, "Ex\
portDefaultDeclaration");
    if (this.shouldParseExportStatement())
      e.declaration = this.parseExportDeclaration(e), e.declaration.type === "VariableDeclaration" ? this.checkVariableExport(t, e.declaration.
      declarations) : this.checkExport(t, e.declaration.id, e.declaration.id.start), e.specifiers = [], e.source = null, this.options.ecmaVersion >=
      16 && (e.attributes = []);
    else {
      if (e.declaration = null, e.specifiers = this.parseExportSpecifiers(t), this.eatContextual("from"))
        this.type !== O.string && this.unexpected(), e.source = this.parseExprAtom(), this.options.ecmaVersion >= 16 && (e.attributes = this.
        parseWithClause());
      else {
        for (var r = 0, i = e.specifiers; r < i.length; r += 1) {
          var n = i[r];
          this.checkUnreserved(n.local), this.checkLocalExport(n.local), n.local.type === "Literal" && this.raise(n.local.start, "A string l\
iteral cannot be used as an exported binding without `from`.");
        }
        e.source = null, this.options.ecmaVersion >= 16 && (e.attributes = []);
      }
      this.semicolon();
    }
    return this.finishNode(e, "ExportNamedDeclaration");
  };
  ut.parseExportDeclaration = function(e) {
    return this.parseStatement(null);
  };
  ut.parseExportDefaultDeclaration = function() {
    var e;
    if (this.type === O._function || (e = this.isAsyncFunction())) {
      var t = this.startNode();
      return this.next(), e && this.next(), this.parseFunction(t, hy | Vne, !1, e);
    } else if (this.type === O._class) {
      var r = this.startNode();
      return this.parseClass(r, "nullableID");
    } else {
      var i = this.parseMaybeAssign();
      return this.semicolon(), i;
    }
  };
  ut.checkExport = function(e, t, r) {
    e && (typeof t != "string" && (t = t.type === "Identifier" ? t.name : t.value), dh(e, t) && this.raiseRecoverable(r, "Duplicate export '" +
    t + "'"), e[t] = !0);
  };
  ut.checkPatternExport = function(e, t) {
    var r = t.type;
    if (r === "Identifier")
      this.checkExport(e, t, t.start);
    else if (r === "ObjectPattern")
      for (var i = 0, n = t.properties; i < n.length; i += 1) {
        var a = n[i];
        this.checkPatternExport(e, a);
      }
    else if (r === "ArrayPattern")
      for (var o = 0, u = t.elements; o < u.length; o += 1) {
        var l = u[o];
        l && this.checkPatternExport(e, l);
      }
    else r === "Property" ? this.checkPatternExport(e, t.value) : r === "AssignmentPattern" ? this.checkPatternExport(e, t.left) : r === "Re\
stElement" && this.checkPatternExport(e, t.argument);
  };
  ut.checkVariableExport = function(e, t) {
    if (e)
      for (var r = 0, i = t; r < i.length; r += 1) {
        var n = i[r];
        this.checkPatternExport(e, n.id);
      }
  };
  ut.shouldParseExportStatement = function() {
    return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" ||
    this.isLet() || this.isAsyncFunction();
  };
  ut.parseExportSpecifier = function(e) {
    var t = this.startNode();
    return t.local = this.parseModuleExportName(), t.exported = this.eatContextual("as") ? this.parseModuleExportName() : t.local, this.checkExport(
      e,
      t.exported,
      t.exported.start
    ), this.finishNode(t, "ExportSpecifier");
  };
  ut.parseExportSpecifiers = function(e) {
    var t = [], r = !0;
    for (this.expect(O.braceL); !this.eat(O.braceR); ) {
      if (r)
        r = !1;
      else if (this.expect(O.comma), this.afterTrailingComma(O.braceR))
        break;
      t.push(this.parseExportSpecifier(e));
    }
    return t;
  };
  ut.parseImport = function(e) {
    return this.next(), this.type === O.string ? (e.specifiers = Ypt, e.source = this.parseExprAtom()) : (e.specifiers = this.parseImportSpecifiers(),
    this.expectContextual("from"), e.source = this.type === O.string ? this.parseExprAtom() : this.unexpected()), this.options.ecmaVersion >=
    16 && (e.attributes = this.parseWithClause()), this.semicolon(), this.finishNode(e, "ImportDeclaration");
  };
  ut.parseImportSpecifier = function() {
    var e = this.startNode();
    return e.imported = this.parseModuleExportName(), this.eatContextual("as") ? e.local = this.parseIdent() : (this.checkUnreserved(e.imported),
    e.local = e.imported), this.checkLValSimple(e.local, Hu), this.finishNode(e, "ImportSpecifier");
  };
  ut.parseImportDefaultSpecifier = function() {
    var e = this.startNode();
    return e.local = this.parseIdent(), this.checkLValSimple(e.local, Hu), this.finishNode(e, "ImportDefaultSpecifier");
  };
  ut.parseImportNamespaceSpecifier = function() {
    var e = this.startNode();
    return this.next(), this.expectContextual("as"), e.local = this.parseIdent(), this.checkLValSimple(e.local, Hu), this.finishNode(e, "Imp\
ortNamespaceSpecifier");
  };
  ut.parseImportSpecifiers = function() {
    var e = [], t = !0;
    if (this.type === O.name && (e.push(this.parseImportDefaultSpecifier()), !this.eat(O.comma)))
      return e;
    if (this.type === O.star)
      return e.push(this.parseImportNamespaceSpecifier()), e;
    for (this.expect(O.braceL); !this.eat(O.braceR); ) {
      if (t)
        t = !1;
      else if (this.expect(O.comma), this.afterTrailingComma(O.braceR))
        break;
      e.push(this.parseImportSpecifier());
    }
    return e;
  };
  ut.parseWithClause = function() {
    var e = [];
    if (!this.eat(O._with))
      return e;
    this.expect(O.braceL);
    for (var t = {}, r = !0; !this.eat(O.braceR); ) {
      if (r)
        r = !1;
      else if (this.expect(O.comma), this.afterTrailingComma(O.braceR))
        break;
      var i = this.parseImportAttribute(), n = i.key.type === "Identifier" ? i.key.name : i.key.value;
      dh(t, n) && this.raiseRecoverable(i.key.start, "Duplicate attribute key '" + n + "'"), t[n] = !0, e.push(i);
    }
    return e;
  };
  ut.parseImportAttribute = function() {
    var e = this.startNode();
    return e.key = this.type === O.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never"), this.expect(O.colon),
    this.type !== O.string && this.unexpected(), e.value = this.parseExprAtom(), this.finishNode(e, "ImportAttribute");
  };
  ut.parseModuleExportName = function() {
    if (this.options.ecmaVersion >= 13 && this.type === O.string) {
      var e = this.parseLiteral(this.value);
      return zpt.test(e.value) && this.raise(e.start, "An export name cannot include a lone surrogate."), e;
    }
    return this.parseIdent(!0);
  };
  ut.adaptDirectivePrologue = function(e) {
    for (var t = 0; t < e.length && this.isDirectiveCandidate(e[t]); ++t)
      e[t].directive = e[t].expression.raw.slice(1, -1);
  };
  ut.isDirectiveCandidate = function(e) {
    return this.options.ecmaVersion >= 5 && e.type === "ExpressionStatement" && e.expression.type === "Literal" && typeof e.expression.value ==
    "string" && // Reject parenthesized strings.
    (this.input[e.start] === '"' || this.input[e.start] === "'");
  };
  qa = ji.prototype;
  qa.toAssignable = function(e, t, r) {
    if (this.options.ecmaVersion >= 6 && e)
      switch (e.type) {
        case "Identifier":
          this.inAsync && e.name === "await" && this.raise(e.start, "Cannot use 'await' as identifier inside an async function");
          break;
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
          break;
        case "ObjectExpression":
          e.type = "ObjectPattern", r && this.checkPatternErrors(r, !0);
          for (var i = 0, n = e.properties; i < n.length; i += 1) {
            var a = n[i];
            this.toAssignable(a, t), a.type === "RestElement" && (a.argument.type === "ArrayPattern" || a.argument.type === "ObjectPattern") &&
            this.raise(a.argument.start, "Unexpected token");
          }
          break;
        case "Property":
          e.kind !== "init" && this.raise(e.key.start, "Object pattern can't contain getter or setter"), this.toAssignable(e.value, t);
          break;
        case "ArrayExpression":
          e.type = "ArrayPattern", r && this.checkPatternErrors(r, !0), this.toAssignableList(e.elements, t);
          break;
        case "SpreadElement":
          e.type = "RestElement", this.toAssignable(e.argument, t), e.argument.type === "AssignmentPattern" && this.raise(e.argument.start, "\
Rest elements cannot have a default value");
          break;
        case "AssignmentExpression":
          e.operator !== "=" && this.raise(e.left.end, "Only '=' operator can be used for specifying default value."), e.type = "AssignmentP\
attern", delete e.operator, this.toAssignable(e.left, t);
          break;
        case "ParenthesizedExpression":
          this.toAssignable(e.expression, t, r);
          break;
        case "ChainExpression":
          this.raiseRecoverable(e.start, "Optional chaining cannot appear in left-hand side");
          break;
        case "MemberExpression":
          if (!t)
            break;
        default:
          this.raise(e.start, "Assigning to rvalue");
      }
    else r && this.checkPatternErrors(r, !0);
    return e;
  };
  qa.toAssignableList = function(e, t) {
    for (var r = e.length, i = 0; i < r; i++) {
      var n = e[i];
      n && this.toAssignable(n, t);
    }
    if (r) {
      var a = e[r - 1];
      this.options.ecmaVersion === 6 && t && a && a.type === "RestElement" && a.argument.type !== "Identifier" && this.unexpected(a.argument.
      start);
    }
    return e;
  };
  qa.parseSpread = function(e) {
    var t = this.startNode();
    return this.next(), t.argument = this.parseMaybeAssign(!1, e), this.finishNode(t, "SpreadElement");
  };
  qa.parseRestBinding = function() {
    var e = this.startNode();
    return this.next(), this.options.ecmaVersion === 6 && this.type !== O.name && this.unexpected(), e.argument = this.parseBindingAtom(), this.
    finishNode(e, "RestElement");
  };
  qa.parseBindingAtom = function() {
    if (this.options.ecmaVersion >= 6)
      switch (this.type) {
        case O.bracketL:
          var e = this.startNode();
          return this.next(), e.elements = this.parseBindingList(O.bracketR, !0, !0), this.finishNode(e, "ArrayPattern");
        case O.braceL:
          return this.parseObj(!0);
      }
    return this.parseIdent();
  };
  qa.parseBindingList = function(e, t, r, i) {
    for (var n = [], a = !0; !this.eat(e); )
      if (a ? a = !1 : this.expect(O.comma), t && this.type === O.comma)
        n.push(null);
      else {
        if (r && this.afterTrailingComma(e))
          break;
        if (this.type === O.ellipsis) {
          var o = this.parseRestBinding();
          this.parseBindingListItem(o), n.push(o), this.type === O.comma && this.raiseRecoverable(this.start, "Comma is not permitted after \
the rest element"), this.expect(e);
          break;
        } else
          n.push(this.parseAssignableListItem(i));
      }
    return n;
  };
  qa.parseAssignableListItem = function(e) {
    var t = this.parseMaybeDefault(this.start, this.startLoc);
    return this.parseBindingListItem(t), t;
  };
  qa.parseBindingListItem = function(e) {
    return e;
  };
  qa.parseMaybeDefault = function(e, t, r) {
    if (r = r || this.parseBindingAtom(), this.options.ecmaVersion < 6 || !this.eat(O.eq))
      return r;
    var i = this.startNodeAt(e, t);
    return i.left = r, i.right = this.parseMaybeAssign(), this.finishNode(i, "AssignmentPattern");
  };
  qa.checkLValSimple = function(e, t, r) {
    t === void 0 && (t = g0);
    var i = t !== g0;
    switch (e.type) {
      case "Identifier":
        this.strict && this.reservedWordsStrictBind.test(e.name) && this.raiseRecoverable(e.start, (i ? "Binding " : "Assigning to ") + e.name +
        " in strict mode"), i && (t === Hu && e.name === "let" && this.raiseRecoverable(e.start, "let is disallowed as a lexically bound nam\
e"), r && (dh(r, e.name) && this.raiseRecoverable(e.start, "Argument name clash"), r[e.name] = !0), t !== jne && this.declareName(e.name, t,
        e.start));
        break;
      case "ChainExpression":
        this.raiseRecoverable(e.start, "Optional chaining cannot appear in left-hand side");
        break;
      case "MemberExpression":
        i && this.raiseRecoverable(e.start, "Binding member expression");
        break;
      case "ParenthesizedExpression":
        return i && this.raiseRecoverable(e.start, "Binding parenthesized expression"), this.checkLValSimple(e.expression, t, r);
      default:
        this.raise(e.start, (i ? "Binding" : "Assigning to") + " rvalue");
    }
  };
  qa.checkLValPattern = function(e, t, r) {
    switch (t === void 0 && (t = g0), e.type) {
      case "ObjectPattern":
        for (var i = 0, n = e.properties; i < n.length; i += 1) {
          var a = n[i];
          this.checkLValInnerPattern(a, t, r);
        }
        break;
      case "ArrayPattern":
        for (var o = 0, u = e.elements; o < u.length; o += 1) {
          var l = u[o];
          l && this.checkLValInnerPattern(l, t, r);
        }
        break;
      default:
        this.checkLValSimple(e, t, r);
    }
  };
  qa.checkLValInnerPattern = function(e, t, r) {
    switch (t === void 0 && (t = g0), e.type) {
      case "Property":
        this.checkLValInnerPattern(e.value, t, r);
        break;
      case "AssignmentPattern":
        this.checkLValPattern(e.left, t, r);
        break;
      case "RestElement":
        this.checkLValPattern(e.argument, t, r);
        break;
      default:
        this.checkLValPattern(e, t, r);
    }
  };
  Fa = /* @__PURE__ */ s(function(t, r, i, n, a) {
    this.token = t, this.isExpr = !!r, this.preserveSpace = !!i, this.override = n, this.generator = !!a;
  }, "TokContext"), ci = {
    b_stat: new Fa("{", !1),
    b_expr: new Fa("{", !0),
    b_tmpl: new Fa("${", !1),
    p_stat: new Fa("(", !1),
    p_expr: new Fa("(", !0),
    q_tmpl: new Fa("`", !0, !0, function(e) {
      return e.tryReadTemplateToken();
    }),
    f_stat: new Fa("function", !1),
    f_expr: new Fa("function", !0),
    f_expr_gen: new Fa("function", !0, !1, null, !0),
    f_gen: new Fa("function", !1, !1, null, !0)
  }, yh = ji.prototype;
  yh.initialContext = function() {
    return [ci.b_stat];
  };
  yh.curContext = function() {
    return this.context[this.context.length - 1];
  };
  yh.braceIsBlock = function(e) {
    var t = this.curContext();
    return t === ci.f_expr || t === ci.f_stat ? !0 : e === O.colon && (t === ci.b_stat || t === ci.b_expr) ? !t.isExpr : e === O._return || e ===
    O.name && this.exprAllowed ? fa.test(this.input.slice(this.lastTokEnd, this.start)) : e === O._else || e === O.semi || e === O.eof || e ===
    O.parenR || e === O.arrow ? !0 : e === O.braceL ? t === ci.b_stat : e === O._var || e === O._const || e === O.name ? !1 : !this.exprAllowed;
  };
  yh.inGeneratorContext = function() {
    for (var e = this.context.length - 1; e >= 1; e--) {
      var t = this.context[e];
      if (t.token === "function")
        return t.generator;
    }
    return !1;
  };
  yh.updateContext = function(e) {
    var t, r = this.type;
    r.keyword && e === O.dot ? this.exprAllowed = !1 : (t = r.updateContext) ? t.call(this, e) : this.exprAllowed = r.beforeExpr;
  };
  yh.overrideContext = function(e) {
    this.curContext() !== e && (this.context[this.context.length - 1] = e);
  };
  O.parenR.updateContext = O.braceR.updateContext = function() {
    if (this.context.length === 1) {
      this.exprAllowed = !0;
      return;
    }
    var e = this.context.pop();
    e === ci.b_stat && this.curContext().token === "function" && (e = this.context.pop()), this.exprAllowed = !e.isExpr;
  };
  O.braceL.updateContext = function(e) {
    this.context.push(this.braceIsBlock(e) ? ci.b_stat : ci.b_expr), this.exprAllowed = !0;
  };
  O.dollarBraceL.updateContext = function() {
    this.context.push(ci.b_tmpl), this.exprAllowed = !0;
  };
  O.parenL.updateContext = function(e) {
    var t = e === O._if || e === O._for || e === O._with || e === O._while;
    this.context.push(t ? ci.p_stat : ci.p_expr), this.exprAllowed = !0;
  };
  O.incDec.updateContext = function() {
  };
  O._function.updateContext = O._class.updateContext = function(e) {
    e.beforeExpr && e !== O._else && !(e === O.semi && this.curContext() !== ci.p_stat) && !(e === O._return && fa.test(this.input.slice(this.
    lastTokEnd, this.start))) && !((e === O.colon || e === O.braceL) && this.curContext() === ci.b_stat) ? this.context.push(ci.f_expr) : this.
    context.push(ci.f_stat), this.exprAllowed = !1;
  };
  O.colon.updateContext = function() {
    this.curContext().token === "function" && this.context.pop(), this.exprAllowed = !0;
  };
  O.backQuote.updateContext = function() {
    this.curContext() === ci.q_tmpl ? this.context.pop() : this.context.push(ci.q_tmpl), this.exprAllowed = !1;
  };
  O.star.updateContext = function(e) {
    if (e === O._function) {
      var t = this.context.length - 1;
      this.context[t] === ci.f_expr ? this.context[t] = ci.f_expr_gen : this.context[t] = ci.f_gen;
    }
    this.exprAllowed = !0;
  };
  O.name.updateContext = function(e) {
    var t = !1;
    this.options.ecmaVersion >= 6 && e !== O.dot && (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) &&
    (t = !0), this.exprAllowed = t;
  };
  Dt = ji.prototype;
  Dt.checkPropClash = function(e, t, r) {
    if (!(this.options.ecmaVersion >= 9 && e.type === "SpreadElement") && !(this.options.ecmaVersion >= 6 && (e.computed || e.method || e.shorthand))) {
      var i = e.key, n;
      switch (i.type) {
        case "Identifier":
          n = i.name;
          break;
        case "Literal":
          n = String(i.value);
          break;
        default:
          return;
      }
      var a = e.kind;
      if (this.options.ecmaVersion >= 6) {
        n === "__proto__" && a === "init" && (t.proto && (r ? r.doubleProto < 0 && (r.doubleProto = i.start) : this.raiseRecoverable(i.start,
        "Redefinition of __proto__ property")), t.proto = !0);
        return;
      }
      n = "$" + n;
      var o = t[n];
      if (o) {
        var u;
        a === "init" ? u = this.strict && o.init || o.get || o.set : u = o.init || o[a], u && this.raiseRecoverable(i.start, "Redefinition o\
f property");
      } else
        o = t[n] = {
          init: !1,
          get: !1,
          set: !1
        };
      o[a] = !0;
    }
  };
  Dt.parseExpression = function(e, t) {
    var r = this.start, i = this.startLoc, n = this.parseMaybeAssign(e, t);
    if (this.type === O.comma) {
      var a = this.startNodeAt(r, i);
      for (a.expressions = [n]; this.eat(O.comma); )
        a.expressions.push(this.parseMaybeAssign(e, t));
      return this.finishNode(a, "SequenceExpression");
    }
    return n;
  };
  Dt.parseMaybeAssign = function(e, t, r) {
    if (this.isContextual("yield")) {
      if (this.inGenerator)
        return this.parseYield(e);
      this.exprAllowed = !1;
    }
    var i = !1, n = -1, a = -1, o = -1;
    t ? (n = t.parenthesizedAssign, a = t.trailingComma, o = t.doubleProto, t.parenthesizedAssign = t.trailingComma = -1) : (t = new A0(), i =
    !0);
    var u = this.start, l = this.startLoc;
    (this.type === O.parenL || this.type === O.name) && (this.potentialArrowAt = this.start, this.potentialArrowInForAwait = e === "await");
    var c = this.parseMaybeConditional(e, t);
    if (r && (c = r.call(this, c, u, l)), this.type.isAssign) {
      var p = this.startNodeAt(u, l);
      return p.operator = this.value, this.type === O.eq && (c = this.toAssignable(c, !1, t)), i || (t.parenthesizedAssign = t.trailingComma =
      t.doubleProto = -1), t.shorthandAssign >= c.start && (t.shorthandAssign = -1), this.type === O.eq ? this.checkLValPattern(c) : this.checkLValSimple(
      c), p.left = c, this.next(), p.right = this.parseMaybeAssign(e), o > -1 && (t.doubleProto = o), this.finishNode(p, "AssignmentExpressi\
on");
    } else
      i && this.checkExpressionErrors(t, !0);
    return n > -1 && (t.parenthesizedAssign = n), a > -1 && (t.trailingComma = a), c;
  };
  Dt.parseMaybeConditional = function(e, t) {
    var r = this.start, i = this.startLoc, n = this.parseExprOps(e, t);
    if (this.checkExpressionErrors(t))
      return n;
    if (this.eat(O.question)) {
      var a = this.startNodeAt(r, i);
      return a.test = n, a.consequent = this.parseMaybeAssign(), this.expect(O.colon), a.alternate = this.parseMaybeAssign(e), this.finishNode(
      a, "ConditionalExpression");
    }
    return n;
  };
  Dt.parseExprOps = function(e, t) {
    var r = this.start, i = this.startLoc, n = this.parseMaybeUnary(t, !1, !1, e);
    return this.checkExpressionErrors(t) || n.start === r && n.type === "ArrowFunctionExpression" ? n : this.parseExprOp(n, r, i, -1, e);
  };
  Dt.parseExprOp = function(e, t, r, i, n) {
    var a = this.type.binop;
    if (a != null && (!n || this.type !== O._in) && a > i) {
      var o = this.type === O.logicalOR || this.type === O.logicalAND, u = this.type === O.coalesce;
      u && (a = O.logicalAND.binop);
      var l = this.value;
      this.next();
      var c = this.start, p = this.startLoc, h = this.parseExprOp(this.parseMaybeUnary(null, !1, !1, n), c, p, a, n), y = this.buildBinary(t,
      r, e, h, l, o || u);
      return (o && this.type === O.coalesce || u && (this.type === O.logicalOR || this.type === O.logicalAND)) && this.raiseRecoverable(this.
      start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses"), this.parseExprOp(y, t, r, i, n);
    }
    return e;
  };
  Dt.buildBinary = function(e, t, r, i, n, a) {
    i.type === "PrivateIdentifier" && this.raise(i.start, "Private identifier can only be left side of binary expression");
    var o = this.startNodeAt(e, t);
    return o.left = r, o.operator = n, o.right = i, this.finishNode(o, a ? "LogicalExpression" : "BinaryExpression");
  };
  Dt.parseMaybeUnary = function(e, t, r, i) {
    var n = this.start, a = this.startLoc, o;
    if (this.isContextual("await") && this.canAwait)
      o = this.parseAwait(i), t = !0;
    else if (this.type.prefix) {
      var u = this.startNode(), l = this.type === O.incDec;
      u.operator = this.value, u.prefix = !0, this.next(), u.argument = this.parseMaybeUnary(null, !0, l, i), this.checkExpressionErrors(e, !0),
      l ? this.checkLValSimple(u.argument) : this.strict && u.operator === "delete" && Kne(u.argument) ? this.raiseRecoverable(u.start, "Del\
eting local variable in strict mode") : u.operator === "delete" && rI(u.argument) ? this.raiseRecoverable(u.start, "Private fields can not b\
e deleted") : t = !0, o = this.finishNode(u, l ? "UpdateExpression" : "UnaryExpression");
    } else if (!t && this.type === O.privateId)
      (i || this.privateNameStack.length === 0) && this.options.checkPrivateFields && this.unexpected(), o = this.parsePrivateIdent(), this.
      type !== O._in && this.unexpected();
    else {
      if (o = this.parseExprSubscripts(e, i), this.checkExpressionErrors(e))
        return o;
      for (; this.type.postfix && !this.canInsertSemicolon(); ) {
        var c = this.startNodeAt(n, a);
        c.operator = this.value, c.prefix = !1, c.argument = o, this.checkLValSimple(o), this.next(), o = this.finishNode(c, "UpdateExpressi\
on");
      }
    }
    if (!r && this.eat(O.starstar))
      if (t)
        this.unexpected(this.lastTokStart);
      else
        return this.buildBinary(n, a, o, this.parseMaybeUnary(null, !1, !1, i), "**", !1);
    else
      return o;
  };
  s(Kne, "isLocalVariableAccess");
  s(rI, "isPrivateFieldAccess");
  Dt.parseExprSubscripts = function(e, t) {
    var r = this.start, i = this.startLoc, n = this.parseExprAtom(e, t);
    if (n.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")")
      return n;
    var a = this.parseSubscripts(n, r, i, !1, t);
    return e && a.type === "MemberExpression" && (e.parenthesizedAssign >= a.start && (e.parenthesizedAssign = -1), e.parenthesizedBind >= a.
    start && (e.parenthesizedBind = -1), e.trailingComma >= a.start && (e.trailingComma = -1)), a;
  };
  Dt.parseSubscripts = function(e, t, r, i, n) {
    for (var a = this.options.ecmaVersion >= 8 && e.type === "Identifier" && e.name === "async" && this.lastTokEnd === e.end && !this.canInsertSemicolon() &&
    e.end - e.start === 5 && this.potentialArrowAt === e.start, o = !1; ; ) {
      var u = this.parseSubscript(e, t, r, i, a, o, n);
      if (u.optional && (o = !0), u === e || u.type === "ArrowFunctionExpression") {
        if (o) {
          var l = this.startNodeAt(t, r);
          l.expression = u, u = this.finishNode(l, "ChainExpression");
        }
        return u;
      }
      e = u;
    }
  };
  Dt.shouldParseAsyncArrow = function() {
    return !this.canInsertSemicolon() && this.eat(O.arrow);
  };
  Dt.parseSubscriptAsyncArrow = function(e, t, r, i) {
    return this.parseArrowExpression(this.startNodeAt(e, t), r, !0, i);
  };
  Dt.parseSubscript = function(e, t, r, i, n, a, o) {
    var u = this.options.ecmaVersion >= 11, l = u && this.eat(O.questionDot);
    i && l && this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
    var c = this.eat(O.bracketL);
    if (c || l && this.type !== O.parenL && this.type !== O.backQuote || this.eat(O.dot)) {
      var p = this.startNodeAt(t, r);
      p.object = e, c ? (p.property = this.parseExpression(), this.expect(O.bracketR)) : this.type === O.privateId && e.type !== "Super" ? p.
      property = this.parsePrivateIdent() : p.property = this.parseIdent(this.options.allowReserved !== "never"), p.computed = !!c, u && (p.
      optional = l), e = this.finishNode(p, "MemberExpression");
    } else if (!i && this.eat(O.parenL)) {
      var h = new A0(), y = this.yieldPos, _ = this.awaitPos, g = this.awaitIdentPos;
      this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0;
      var m = this.parseExprList(O.parenR, this.options.ecmaVersion >= 8, !1, h);
      if (n && !l && this.shouldParseAsyncArrow())
        return this.checkPatternErrors(h, !1), this.checkYieldAwaitInDefaultParams(), this.awaitIdentPos > 0 && this.raise(this.awaitIdentPos,
        "Cannot use 'await' as identifier inside an async function"), this.yieldPos = y, this.awaitPos = _, this.awaitIdentPos = g, this.parseSubscriptAsyncArrow(
        t, r, m, o);
      this.checkExpressionErrors(h, !0), this.yieldPos = y || this.yieldPos, this.awaitPos = _ || this.awaitPos, this.awaitIdentPos = g || this.
      awaitIdentPos;
      var f = this.startNodeAt(t, r);
      f.callee = e, f.arguments = m, u && (f.optional = l), e = this.finishNode(f, "CallExpression");
    } else if (this.type === O.backQuote) {
      (l || a) && this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
      var d = this.startNodeAt(t, r);
      d.tag = e, d.quasi = this.parseTemplate({ isTagged: !0 }), e = this.finishNode(d, "TaggedTemplateExpression");
    }
    return e;
  };
  Dt.parseExprAtom = function(e, t, r) {
    this.type === O.slash && this.readRegexp();
    var i, n = this.potentialArrowAt === this.start;
    switch (this.type) {
      case O._super:
        return this.allowSuper || this.raise(this.start, "'super' keyword outside a method"), i = this.startNode(), this.next(), this.type ===
        O.parenL && !this.allowDirectSuper && this.raise(i.start, "super() call outside constructor of a subclass"), this.type !== O.dot && this.
        type !== O.bracketL && this.type !== O.parenL && this.unexpected(), this.finishNode(i, "Super");
      case O._this:
        return i = this.startNode(), this.next(), this.finishNode(i, "ThisExpression");
      case O.name:
        var a = this.start, o = this.startLoc, u = this.containsEsc, l = this.parseIdent(!1);
        if (this.options.ecmaVersion >= 8 && !u && l.name === "async" && !this.canInsertSemicolon() && this.eat(O._function))
          return this.overrideContext(ci.f_expr), this.parseFunction(this.startNodeAt(a, o), 0, !1, !0, t);
        if (n && !this.canInsertSemicolon()) {
          if (this.eat(O.arrow))
            return this.parseArrowExpression(this.startNodeAt(a, o), [l], !1, t);
          if (this.options.ecmaVersion >= 8 && l.name === "async" && this.type === O.name && !u && (!this.potentialArrowInForAwait || this.value !==
          "of" || this.containsEsc))
            return l = this.parseIdent(!1), (this.canInsertSemicolon() || !this.eat(O.arrow)) && this.unexpected(), this.parseArrowExpression(
            this.startNodeAt(a, o), [l], !0, t);
        }
        return l;
      case O.regexp:
        var c = this.value;
        return i = this.parseLiteral(c.value), i.regex = { pattern: c.pattern, flags: c.flags }, i;
      case O.num:
      case O.string:
        return this.parseLiteral(this.value);
      case O._null:
      case O._true:
      case O._false:
        return i = this.startNode(), i.value = this.type === O._null ? null : this.type === O._true, i.raw = this.type.keyword, this.next(),
        this.finishNode(i, "Literal");
      case O.parenL:
        var p = this.start, h = this.parseParenAndDistinguishExpression(n, t);
        return e && (e.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(h) && (e.parenthesizedAssign = p), e.parenthesizedBind < 0 && (e.
        parenthesizedBind = p)), h;
      case O.bracketL:
        return i = this.startNode(), this.next(), i.elements = this.parseExprList(O.bracketR, !0, !0, e), this.finishNode(i, "ArrayExpressio\
n");
      case O.braceL:
        return this.overrideContext(ci.b_expr), this.parseObj(!1, e);
      case O._function:
        return i = this.startNode(), this.next(), this.parseFunction(i, 0);
      case O._class:
        return this.parseClass(this.startNode(), !1);
      case O._new:
        return this.parseNew();
      case O.backQuote:
        return this.parseTemplate();
      case O._import:
        return this.options.ecmaVersion >= 11 ? this.parseExprImport(r) : this.unexpected();
      default:
        return this.parseExprAtomDefault();
    }
  };
  Dt.parseExprAtomDefault = function() {
    this.unexpected();
  };
  Dt.parseExprImport = function(e) {
    var t = this.startNode();
    if (this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword import"), this.next(), this.type === O.parenL && !e)
      return this.parseDynamicImport(t);
    if (this.type === O.dot) {
      var r = this.startNodeAt(t.start, t.loc && t.loc.start);
      return r.name = "import", t.meta = this.finishNode(r, "Identifier"), this.parseImportMeta(t);
    } else
      this.unexpected();
  };
  Dt.parseDynamicImport = function(e) {
    if (this.next(), e.source = this.parseMaybeAssign(), this.options.ecmaVersion >= 16)
      this.eat(O.parenR) ? e.options = null : (this.expect(O.comma), this.afterTrailingComma(O.parenR) ? e.options = null : (e.options = this.
      parseMaybeAssign(), this.eat(O.parenR) || (this.expect(O.comma), this.afterTrailingComma(O.parenR) || this.unexpected())));
    else if (!this.eat(O.parenR)) {
      var t = this.start;
      this.eat(O.comma) && this.eat(O.parenR) ? this.raiseRecoverable(t, "Trailing comma is not allowed in import()") : this.unexpected(t);
    }
    return this.finishNode(e, "ImportExpression");
  };
  Dt.parseImportMeta = function(e) {
    this.next();
    var t = this.containsEsc;
    return e.property = this.parseIdent(!0), e.property.name !== "meta" && this.raiseRecoverable(e.property.start, "The only valid meta prop\
erty for import is 'import.meta'"), t && this.raiseRecoverable(e.start, "'import.meta' must not contain escaped characters"), this.options.sourceType !==
    "module" && !this.options.allowImportExportEverywhere && this.raiseRecoverable(e.start, "Cannot use 'import.meta' outside a module"), this.
    finishNode(e, "MetaProperty");
  };
  Dt.parseLiteral = function(e) {
    var t = this.startNode();
    return t.value = e, t.raw = this.input.slice(this.start, this.end), t.raw.charCodeAt(t.raw.length - 1) === 110 && (t.bigint = t.raw.slice(
    0, -1).replace(/_/g, "")), this.next(), this.finishNode(t, "Literal");
  };
  Dt.parseParenExpression = function() {
    this.expect(O.parenL);
    var e = this.parseExpression();
    return this.expect(O.parenR), e;
  };
  Dt.shouldParseArrow = function(e) {
    return !this.canInsertSemicolon();
  };
  Dt.parseParenAndDistinguishExpression = function(e, t) {
    var r = this.start, i = this.startLoc, n, a = this.options.ecmaVersion >= 8;
    if (this.options.ecmaVersion >= 6) {
      this.next();
      var o = this.start, u = this.startLoc, l = [], c = !0, p = !1, h = new A0(), y = this.yieldPos, _ = this.awaitPos, g;
      for (this.yieldPos = 0, this.awaitPos = 0; this.type !== O.parenR; )
        if (c ? c = !1 : this.expect(O.comma), a && this.afterTrailingComma(O.parenR, !0)) {
          p = !0;
          break;
        } else if (this.type === O.ellipsis) {
          g = this.start, l.push(this.parseParenItem(this.parseRestBinding())), this.type === O.comma && this.raiseRecoverable(
            this.start,
            "Comma is not permitted after the rest element"
          );
          break;
        } else
          l.push(this.parseMaybeAssign(!1, h, this.parseParenItem));
      var m = this.lastTokEnd, f = this.lastTokEndLoc;
      if (this.expect(O.parenR), e && this.shouldParseArrow(l) && this.eat(O.arrow))
        return this.checkPatternErrors(h, !1), this.checkYieldAwaitInDefaultParams(), this.yieldPos = y, this.awaitPos = _, this.parseParenArrowList(
        r, i, l, t);
      (!l.length || p) && this.unexpected(this.lastTokStart), g && this.unexpected(g), this.checkExpressionErrors(h, !0), this.yieldPos = y ||
      this.yieldPos, this.awaitPos = _ || this.awaitPos, l.length > 1 ? (n = this.startNodeAt(o, u), n.expressions = l, this.finishNodeAt(n,
      "SequenceExpression", m, f)) : n = l[0];
    } else
      n = this.parseParenExpression();
    if (this.options.preserveParens) {
      var d = this.startNodeAt(r, i);
      return d.expression = n, this.finishNode(d, "ParenthesizedExpression");
    } else
      return n;
  };
  Dt.parseParenItem = function(e) {
    return e;
  };
  Dt.parseParenArrowList = function(e, t, r, i) {
    return this.parseArrowExpression(this.startNodeAt(e, t), r, !1, i);
  };
  Qpt = [];
  Dt.parseNew = function() {
    this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword new");
    var e = this.startNode();
    if (this.next(), this.options.ecmaVersion >= 6 && this.type === O.dot) {
      var t = this.startNodeAt(e.start, e.loc && e.loc.start);
      t.name = "new", e.meta = this.finishNode(t, "Identifier"), this.next();
      var r = this.containsEsc;
      return e.property = this.parseIdent(!0), e.property.name !== "target" && this.raiseRecoverable(e.property.start, "The only valid meta \
property for new is 'new.target'"), r && this.raiseRecoverable(e.start, "'new.target' must not contain escaped characters"), this.allowNewDotTarget ||
      this.raiseRecoverable(e.start, "'new.target' can only be used in functions and class static block"), this.finishNode(e, "MetaProperty");
    }
    var i = this.start, n = this.startLoc;
    return e.callee = this.parseSubscripts(this.parseExprAtom(null, !1, !0), i, n, !0, !1), this.eat(O.parenL) ? e.arguments = this.parseExprList(
    O.parenR, this.options.ecmaVersion >= 8, !1) : e.arguments = Qpt, this.finishNode(e, "NewExpression");
  };
  Dt.parseTemplateElement = function(e) {
    var t = e.isTagged, r = this.startNode();
    return this.type === O.invalidTemplate ? (t || this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal"), r.
    value = {
      raw: this.value.replace(/\r\n?/g, `
`),
      cooked: null
    }) : r.value = {
      raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, `
`),
      cooked: this.value
    }, this.next(), r.tail = this.type === O.backQuote, this.finishNode(r, "TemplateElement");
  };
  Dt.parseTemplate = function(e) {
    e === void 0 && (e = {});
    var t = e.isTagged;
    t === void 0 && (t = !1);
    var r = this.startNode();
    this.next(), r.expressions = [];
    var i = this.parseTemplateElement({ isTagged: t });
    for (r.quasis = [i]; !i.tail; )
      this.type === O.eof && this.raise(this.pos, "Unterminated template literal"), this.expect(O.dollarBraceL), r.expressions.push(this.parseExpression()),
      this.expect(O.braceR), r.quasis.push(i = this.parseTemplateElement({ isTagged: t }));
    return this.next(), this.finishNode(r, "TemplateLiteral");
  };
  Dt.isAsyncProp = function(e) {
    return !e.computed && e.key.type === "Identifier" && e.key.name === "async" && (this.type === O.name || this.type === O.num || this.type ===
    O.string || this.type === O.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === O.star) && !fa.test(this.input.
    slice(this.lastTokEnd, this.start));
  };
  Dt.parseObj = function(e, t) {
    var r = this.startNode(), i = !0, n = {};
    for (r.properties = [], this.next(); !this.eat(O.braceR); ) {
      if (i)
        i = !1;
      else if (this.expect(O.comma), this.options.ecmaVersion >= 5 && this.afterTrailingComma(O.braceR))
        break;
      var a = this.parseProperty(e, t);
      e || this.checkPropClash(a, n, t), r.properties.push(a);
    }
    return this.finishNode(r, e ? "ObjectPattern" : "ObjectExpression");
  };
  Dt.parseProperty = function(e, t) {
    var r = this.startNode(), i, n, a, o;
    if (this.options.ecmaVersion >= 9 && this.eat(O.ellipsis))
      return e ? (r.argument = this.parseIdent(!1), this.type === O.comma && this.raiseRecoverable(this.start, "Comma is not permitted after\
 the rest element"), this.finishNode(r, "RestElement")) : (r.argument = this.parseMaybeAssign(!1, t), this.type === O.comma && t && t.trailingComma <
      0 && (t.trailingComma = this.start), this.finishNode(r, "SpreadElement"));
    this.options.ecmaVersion >= 6 && (r.method = !1, r.shorthand = !1, (e || t) && (a = this.start, o = this.startLoc), e || (i = this.eat(O.
    star)));
    var u = this.containsEsc;
    return this.parsePropertyName(r), !e && !u && this.options.ecmaVersion >= 8 && !i && this.isAsyncProp(r) ? (n = !0, i = this.options.ecmaVersion >=
    9 && this.eat(O.star), this.parsePropertyName(r)) : n = !1, this.parsePropertyValue(r, e, i, n, a, o, t, u), this.finishNode(r, "Propert\
y");
  };
  Dt.parseGetterSetter = function(e) {
    var t = e.key.name;
    this.parsePropertyName(e), e.value = this.parseMethod(!1), e.kind = t;
    var r = e.kind === "get" ? 0 : 1;
    if (e.value.params.length !== r) {
      var i = e.value.start;
      e.kind === "get" ? this.raiseRecoverable(i, "getter should have no params") : this.raiseRecoverable(i, "setter should have exactly one\
 param");
    } else
      e.kind === "set" && e.value.params[0].type === "RestElement" && this.raiseRecoverable(e.value.params[0].start, "Setter cannot use rest\
 params");
  };
  Dt.parsePropertyValue = function(e, t, r, i, n, a, o, u) {
    (r || i) && this.type === O.colon && this.unexpected(), this.eat(O.colon) ? (e.value = t ? this.parseMaybeDefault(this.start, this.startLoc) :
    this.parseMaybeAssign(!1, o), e.kind = "init") : this.options.ecmaVersion >= 6 && this.type === O.parenL ? (t && this.unexpected(), e.method =
    !0, e.value = this.parseMethod(r, i), e.kind = "init") : !t && !u && this.options.ecmaVersion >= 5 && !e.computed && e.key.type === "Ide\
ntifier" && (e.key.name === "get" || e.key.name === "set") && this.type !== O.comma && this.type !== O.braceR && this.type !== O.eq ? ((r ||
    i) && this.unexpected(), this.parseGetterSetter(e)) : this.options.ecmaVersion >= 6 && !e.computed && e.key.type === "Identifier" ? ((r ||
    i) && this.unexpected(), this.checkUnreserved(e.key), e.key.name === "await" && !this.awaitIdentPos && (this.awaitIdentPos = n), t ? e.value =
    this.parseMaybeDefault(n, a, this.copyNode(e.key)) : this.type === O.eq && o ? (o.shorthandAssign < 0 && (o.shorthandAssign = this.start),
    e.value = this.parseMaybeDefault(n, a, this.copyNode(e.key))) : e.value = this.copyNode(e.key), e.kind = "init", e.shorthand = !0) : this.
    unexpected();
  };
  Dt.parsePropertyName = function(e) {
    if (this.options.ecmaVersion >= 6) {
      if (this.eat(O.bracketL))
        return e.computed = !0, e.key = this.parseMaybeAssign(), this.expect(O.bracketR), e.key;
      e.computed = !1;
    }
    return e.key = this.type === O.num || this.type === O.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "ne\
ver");
  };
  Dt.initFunction = function(e) {
    e.id = null, this.options.ecmaVersion >= 6 && (e.generator = e.expression = !1), this.options.ecmaVersion >= 8 && (e.async = !1);
  };
  Dt.parseMethod = function(e, t, r) {
    var i = this.startNode(), n = this.yieldPos, a = this.awaitPos, o = this.awaitIdentPos;
    return this.initFunction(i), this.options.ecmaVersion >= 6 && (i.generator = e), this.options.ecmaVersion >= 8 && (i.async = !!t), this.
    yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, this.enterScope(oI(t, i.generator) | T0 | (r ? Bne : 0)), this.expect(O.parenL),
    i.params = this.parseBindingList(O.parenR, !1, this.options.ecmaVersion >= 8), this.checkYieldAwaitInDefaultParams(), this.parseFunctionBody(
    i, !1, !0, !1), this.yieldPos = n, this.awaitPos = a, this.awaitIdentPos = o, this.finishNode(i, "FunctionExpression");
  };
  Dt.parseArrowExpression = function(e, t, r, i) {
    var n = this.yieldPos, a = this.awaitPos, o = this.awaitIdentPos;
    return this.enterScope(oI(r, !1) | aI), this.initFunction(e), this.options.ecmaVersion >= 8 && (e.async = !!r), this.yieldPos = 0, this.
    awaitPos = 0, this.awaitIdentPos = 0, e.params = this.toAssignableList(t, !0), this.parseFunctionBody(e, !0, !1, i), this.yieldPos = n, this.
    awaitPos = a, this.awaitIdentPos = o, this.finishNode(e, "ArrowFunctionExpression");
  };
  Dt.parseFunctionBody = function(e, t, r, i) {
    var n = t && this.type !== O.braceL, a = this.strict, o = !1;
    if (n)
      e.body = this.parseMaybeAssign(i), e.expression = !0, this.checkParams(e, !1);
    else {
      var u = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(e.params);
      (!a || u) && (o = this.strictDirective(this.end), o && u && this.raiseRecoverable(e.start, "Illegal 'use strict' directive in function\
 with non-simple parameter list"));
      var l = this.labels;
      this.labels = [], o && (this.strict = !0), this.checkParams(e, !a && !o && !t && !r && this.isSimpleParamList(e.params)), this.strict &&
      e.id && this.checkLValSimple(e.id, jne), e.body = this.parseBlock(!1, void 0, o && !a), e.expression = !1, this.adaptDirectivePrologue(
      e.body.body), this.labels = l;
    }
    this.exitScope();
  };
  Dt.isSimpleParamList = function(e) {
    for (var t = 0, r = e; t < r.length; t += 1) {
      var i = r[t];
      if (i.type !== "Identifier")
        return !1;
    }
    return !0;
  };
  Dt.checkParams = function(e, t) {
    for (var r = /* @__PURE__ */ Object.create(null), i = 0, n = e.params; i < n.length; i += 1) {
      var a = n[i];
      this.checkLValInnerPattern(a, uI, t ? null : r);
    }
  };
  Dt.parseExprList = function(e, t, r, i) {
    for (var n = [], a = !0; !this.eat(e); ) {
      if (a)
        a = !1;
      else if (this.expect(O.comma), t && this.afterTrailingComma(e))
        break;
      var o = void 0;
      r && this.type === O.comma ? o = null : this.type === O.ellipsis ? (o = this.parseSpread(i), i && this.type === O.comma && i.trailingComma <
      0 && (i.trailingComma = this.start)) : o = this.parseMaybeAssign(!1, i), n.push(o);
    }
    return n;
  };
  Dt.checkUnreserved = function(e) {
    var t = e.start, r = e.end, i = e.name;
    if (this.inGenerator && i === "yield" && this.raiseRecoverable(t, "Cannot use 'yield' as identifier inside a generator"), this.inAsync &&
    i === "await" && this.raiseRecoverable(t, "Cannot use 'await' as identifier inside an async function"), !(this.currentThisScope().flags &
    E0) && i === "arguments" && this.raiseRecoverable(t, "Cannot use 'arguments' in class field initializer"), this.inClassStaticBlock && (i ===
    "arguments" || i === "await") && this.raise(t, "Cannot use " + i + " in class static initialization block"), this.keywords.test(i) && this.
    raise(t, "Unexpected keyword '" + i + "'"), !(this.options.ecmaVersion < 6 && this.input.slice(t, r).indexOf("\\") !== -1)) {
      var n = this.strict ? this.reservedWordsStrict : this.reservedWords;
      n.test(i) && (!this.inAsync && i === "await" && this.raiseRecoverable(t, "Cannot use keyword 'await' outside an async function"), this.
      raiseRecoverable(t, "The keyword '" + i + "' is reserved"));
    }
  };
  Dt.parseIdent = function(e) {
    var t = this.parseIdentNode();
    return this.next(!!e), this.finishNode(t, "Identifier"), e || (this.checkUnreserved(t), t.name === "await" && !this.awaitIdentPos && (this.
    awaitIdentPos = t.start)), t;
  };
  Dt.parseIdentNode = function() {
    var e = this.startNode();
    return this.type === O.name ? e.name = this.value : this.type.keyword ? (e.name = this.type.keyword, (e.name === "class" || e.name === "\
function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46) && this.context.pop(), this.type =
    O.name) : this.unexpected(), e;
  };
  Dt.parsePrivateIdent = function() {
    var e = this.startNode();
    return this.type === O.privateId ? e.name = this.value : this.unexpected(), this.next(), this.finishNode(e, "PrivateIdentifier"), this.options.
    checkPrivateFields && (this.privateNameStack.length === 0 ? this.raise(e.start, "Private field '#" + e.name + "' must be declared in an \
enclosing class") : this.privateNameStack[this.privateNameStack.length - 1].used.push(e)), e;
  };
  Dt.parseYield = function(e) {
    this.yieldPos || (this.yieldPos = this.start);
    var t = this.startNode();
    return this.next(), this.type === O.semi || this.canInsertSemicolon() || this.type !== O.star && !this.type.startsExpr ? (t.delegate = !1,
    t.argument = null) : (t.delegate = this.eat(O.star), t.argument = this.parseMaybeAssign(e)), this.finishNode(t, "YieldExpression");
  };
  Dt.parseAwait = function(e) {
    this.awaitPos || (this.awaitPos = this.start);
    var t = this.startNode();
    return this.next(), t.argument = this.parseMaybeUnary(null, !0, !1, e), this.finishNode(t, "AwaitExpression");
  };
  b0 = ji.prototype;
  b0.raise = function(e, t) {
    var r = nI(this.input, e);
    t += " (" + r.line + ":" + r.column + ")", this.sourceFile && (t += " in " + this.sourceFile);
    var i = new SyntaxError(t);
    throw i.pos = e, i.loc = r, i.raisedAt = this.pos, i;
  };
  b0.raiseRecoverable = b0.raise;
  b0.curPosition = function() {
    if (this.options.locations)
      return new hh(this.curLine, this.pos - this.lineStart);
  };
  Yl = ji.prototype, Zpt = /* @__PURE__ */ s(function(t) {
    this.flags = t, this.var = [], this.lexical = [], this.functions = [];
  }, "Scope");
  Yl.enterScope = function(e) {
    this.scopeStack.push(new Zpt(e));
  };
  Yl.exitScope = function() {
    this.scopeStack.pop();
  };
  Yl.treatFunctionsAsVarInScope = function(e) {
    return e.flags & mh || !this.inModule && e.flags & dy;
  };
  Yl.declareName = function(e, t, r) {
    var i = !1;
    if (t === Hu) {
      var n = this.currentScope();
      i = n.lexical.indexOf(e) > -1 || n.functions.indexOf(e) > -1 || n.var.indexOf(e) > -1, n.lexical.push(e), this.inModule && n.flags & dy &&
      delete this.undefinedExports[e];
    } else if (t === Une) {
      var a = this.currentScope();
      a.lexical.push(e);
    } else if (t === qne) {
      var o = this.currentScope();
      this.treatFunctionsAsVar ? i = o.lexical.indexOf(e) > -1 : i = o.lexical.indexOf(e) > -1 || o.var.indexOf(e) > -1, o.functions.push(e);
    } else
      for (var u = this.scopeStack.length - 1; u >= 0; --u) {
        var l = this.scopeStack[u];
        if (l.lexical.indexOf(e) > -1 && !(l.flags & Mne && l.lexical[0] === e) || !this.treatFunctionsAsVarInScope(l) && l.functions.indexOf(
        e) > -1) {
          i = !0;
          break;
        }
        if (l.var.push(e), this.inModule && l.flags & dy && delete this.undefinedExports[e], l.flags & E0)
          break;
      }
    i && this.raiseRecoverable(r, "Identifier '" + e + "' has already been declared");
  };
  Yl.checkLocalExport = function(e) {
    this.scopeStack[0].lexical.indexOf(e.name) === -1 && this.scopeStack[0].var.indexOf(e.name) === -1 && (this.undefinedExports[e.name] = e);
  };
  Yl.currentScope = function() {
    return this.scopeStack[this.scopeStack.length - 1];
  };
  Yl.currentVarScope = function() {
    for (var e = this.scopeStack.length - 1; ; e--) {
      var t = this.scopeStack[e];
      if (t.flags & (E0 | yy | df))
        return t;
    }
  };
  Yl.currentThisScope = function() {
    for (var e = this.scopeStack.length - 1; ; e--) {
      var t = this.scopeStack[e];
      if (t.flags & (E0 | yy | df) && !(t.flags & aI))
        return t;
    }
  };
  gy = /* @__PURE__ */ s(function(t, r, i) {
    this.type = "", this.start = r, this.end = 0, t.options.locations && (this.loc = new my(t, i)), t.options.directSourceFile && (this.sourceFile =
    t.options.directSourceFile), t.options.ranges && (this.range = [r, 0]);
  }, "Node"), _y = ji.prototype;
  _y.startNode = function() {
    return new gy(this, this.start, this.startLoc);
  };
  _y.startNodeAt = function(e, t) {
    return new gy(this, e, t);
  };
  s(Hne, "finishNodeAt");
  _y.finishNode = function(e, t) {
    return Hne.call(this, e, t, this.lastTokEnd, this.lastTokEndLoc);
  };
  _y.finishNodeAt = function(e, t, r, i) {
    return Hne.call(this, e, t, r, i);
  };
  _y.copyNode = function(e) {
    var t = new gy(this, e.start, this.startLoc);
    for (var r in e)
      t[r] = e[r];
    return t;
  };
  eht = "Gara Garay Gukh Gurung_Khema Hrkt Katakana_Or_Hiragana Kawi Kirat_Rai Krai Nag_Mundari Nagm Ol_Onal Onao Sunu Sunuwar Todhri Todr T\
ulu_Tigalari Tutg Unknown Zzzz", zne = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Ca\
se_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWK\
CF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Com\
ponent Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Bin\
ary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lo\
wercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Ind\
icator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS Whi\
te_Space space XID_Continue XIDC XID_Start XIDS", Gne = zne + " Extended_Pictographic", Wne = Gne, $ne = Wne + " EBase EComp EMod EPres ExtP\
ict", Xne = $ne, tht = Xne, rht = {
    9: zne,
    10: Gne,
    11: Wne,
    12: $ne,
    13: Xne,
    14: tht
  }, iht = "Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Seque\
nce RGI_Emoji", nht = {
    9: "",
    10: "",
    11: "",
    12: "",
    13: "",
    14: iht
  }, wne = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Nu\
mber Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_\
Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C\
 Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z \
Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu", Yne = "Adlam Adlm Ahom Anat\
olian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks\
 Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Ch\
am Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyp\
tian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Gu\
ru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi P\
hli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Kh\
udawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayala\
m Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hier\
oglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu \
Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb O\
ld_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pa\
hlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_S\
ompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Tak\
ri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi \
Wara Yi Yiii Zanabazar_Square Zanb", Jne = Yne + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogd\
ian Sogo Sogdian Sogd", Qne = Jne + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho", Zne = Qne + " Chorasmian Chrs \
Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi", ese = Zne + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith", sht =
  ese + " " + eht, aht = {
    9: Yne,
    10: Jne,
    11: Qne,
    12: Zne,
    13: ese,
    14: sht
  }, tse = {};
  s(oht, "buildUnicodeData");
  for (m0 = 0, Zk = [9, 10, 11, 12, 13, 14]; m0 < Zk.length; m0 += 1)
    One = Zk[m0], oht(One);
  Ze = ji.prototype, v0 = /* @__PURE__ */ s(function(t, r) {
    this.parent = t, this.base = r || this;
  }, "BranchID");
  v0.prototype.separatedFrom = /* @__PURE__ */ s(function(t) {
    for (var r = this; r; r = r.parent)
      for (var i = t; i; i = i.parent)
        if (r.base === i.base && r !== i)
          return !0;
    return !1;
  }, "separatedFrom");
  v0.prototype.sibling = /* @__PURE__ */ s(function() {
    return new v0(this.parent, this.base);
  }, "sibling");
  ru = /* @__PURE__ */ s(function(t) {
    this.parser = t, this.validFlags = "gim" + (t.options.ecmaVersion >= 6 ? "uy" : "") + (t.options.ecmaVersion >= 9 ? "s" : "") + (t.options.
    ecmaVersion >= 13 ? "d" : "") + (t.options.ecmaVersion >= 15 ? "v" : ""), this.unicodeProperties = tse[t.options.ecmaVersion >= 14 ? 14 :
    t.options.ecmaVersion], this.source = "", this.flags = "", this.start = 0, this.switchU = !1, this.switchV = !1, this.switchN = !1, this.
    pos = 0, this.lastIntValue = 0, this.lastStringValue = "", this.lastAssertionIsQuantifiable = !1, this.numCapturingParens = 0, this.maxBackReference =
    0, this.groupNames = /* @__PURE__ */ Object.create(null), this.backReferenceNames = [], this.branchID = null;
  }, "RegExpValidationState");
  ru.prototype.reset = /* @__PURE__ */ s(function(t, r, i) {
    var n = i.indexOf("v") !== -1, a = i.indexOf("u") !== -1;
    this.start = t | 0, this.source = r + "", this.flags = i, n && this.parser.options.ecmaVersion >= 15 ? (this.switchU = !0, this.switchV =
    !0, this.switchN = !0) : (this.switchU = a && this.parser.options.ecmaVersion >= 6, this.switchV = !1, this.switchN = a && this.parser.options.
    ecmaVersion >= 9);
  }, "reset");
  ru.prototype.raise = /* @__PURE__ */ s(function(t) {
    this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + t);
  }, "raise");
  ru.prototype.at = /* @__PURE__ */ s(function(t, r) {
    r === void 0 && (r = !1);
    var i = this.source, n = i.length;
    if (t >= n)
      return -1;
    var a = i.charCodeAt(t);
    if (!(r || this.switchU) || a <= 55295 || a >= 57344 || t + 1 >= n)
      return a;
    var o = i.charCodeAt(t + 1);
    return o >= 56320 && o <= 57343 ? (a << 10) + o - 56613888 : a;
  }, "at");
  ru.prototype.nextIndex = /* @__PURE__ */ s(function(t, r) {
    r === void 0 && (r = !1);
    var i = this.source, n = i.length;
    if (t >= n)
      return n;
    var a = i.charCodeAt(t), o;
    return !(r || this.switchU) || a <= 55295 || a >= 57344 || t + 1 >= n || (o = i.charCodeAt(t + 1)) < 56320 || o > 57343 ? t + 1 : t + 2;
  }, "nextIndex");
  ru.prototype.current = /* @__PURE__ */ s(function(t) {
    return t === void 0 && (t = !1), this.at(this.pos, t);
  }, "current");
  ru.prototype.lookahead = /* @__PURE__ */ s(function(t) {
    return t === void 0 && (t = !1), this.at(this.nextIndex(this.pos, t), t);
  }, "lookahead");
  ru.prototype.advance = /* @__PURE__ */ s(function(t) {
    t === void 0 && (t = !1), this.pos = this.nextIndex(this.pos, t);
  }, "advance");
  ru.prototype.eat = /* @__PURE__ */ s(function(t, r) {
    return r === void 0 && (r = !1), this.current(r) === t ? (this.advance(r), !0) : !1;
  }, "eat");
  ru.prototype.eatChars = /* @__PURE__ */ s(function(t, r) {
    r === void 0 && (r = !1);
    for (var i = this.pos, n = 0, a = t; n < a.length; n += 1) {
      var o = a[n], u = this.at(i, r);
      if (u === -1 || u !== o)
        return !1;
      i = this.nextIndex(i, r);
    }
    return this.pos = i, !0;
  }, "eatChars");
  Ze.validateRegExpFlags = function(e) {
    for (var t = e.validFlags, r = e.flags, i = !1, n = !1, a = 0; a < r.length; a++) {
      var o = r.charAt(a);
      t.indexOf(o) === -1 && this.raise(e.start, "Invalid regular expression flag"), r.indexOf(o, a + 1) > -1 && this.raise(e.start, "Duplic\
ate regular expression flag"), o === "u" && (i = !0), o === "v" && (n = !0);
    }
    this.options.ecmaVersion >= 15 && i && n && this.raise(e.start, "Invalid regular expression flag");
  };
  s(uht, "hasProp");
  Ze.validateRegExpPattern = function(e) {
    this.regexp_pattern(e), !e.switchN && this.options.ecmaVersion >= 9 && uht(e.groupNames) && (e.switchN = !0, this.regexp_pattern(e));
  };
  Ze.regexp_pattern = function(e) {
    e.pos = 0, e.lastIntValue = 0, e.lastStringValue = "", e.lastAssertionIsQuantifiable = !1, e.numCapturingParens = 0, e.maxBackReference =
    0, e.groupNames = /* @__PURE__ */ Object.create(null), e.backReferenceNames.length = 0, e.branchID = null, this.regexp_disjunction(e), e.
    pos !== e.source.length && (e.eat(
      41
      /* ) */
    ) && e.raise("Unmatched ')'"), (e.eat(
      93
      /* ] */
    ) || e.eat(
      125
      /* } */
    )) && e.raise("Lone quantifier brackets")), e.maxBackReference > e.numCapturingParens && e.raise("Invalid escape");
    for (var t = 0, r = e.backReferenceNames; t < r.length; t += 1) {
      var i = r[t];
      e.groupNames[i] || e.raise("Invalid named capture referenced");
    }
  };
  Ze.regexp_disjunction = function(e) {
    var t = this.options.ecmaVersion >= 16;
    for (t && (e.branchID = new v0(e.branchID, null)), this.regexp_alternative(e); e.eat(
      124
      /* | */
    ); )
      t && (e.branchID = e.branchID.sibling()), this.regexp_alternative(e);
    t && (e.branchID = e.branchID.parent), this.regexp_eatQuantifier(e, !0) && e.raise("Nothing to repeat"), e.eat(
      123
      /* { */
    ) && e.raise("Lone quantifier brackets");
  };
  Ze.regexp_alternative = function(e) {
    for (; e.pos < e.source.length && this.regexp_eatTerm(e); )
      ;
  };
  Ze.regexp_eatTerm = function(e) {
    return this.regexp_eatAssertion(e) ? (e.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(e) && e.switchU && e.raise("Invalid qua\
ntifier"), !0) : (e.switchU ? this.regexp_eatAtom(e) : this.regexp_eatExtendedAtom(e)) ? (this.regexp_eatQuantifier(e), !0) : !1;
  };
  Ze.regexp_eatAssertion = function(e) {
    var t = e.pos;
    if (e.lastAssertionIsQuantifiable = !1, e.eat(
      94
      /* ^ */
    ) || e.eat(
      36
      /* $ */
    ))
      return !0;
    if (e.eat(
      92
      /* \ */
    )) {
      if (e.eat(
        66
        /* B */
      ) || e.eat(
        98
        /* b */
      ))
        return !0;
      e.pos = t;
    }
    if (e.eat(
      40
      /* ( */
    ) && e.eat(
      63
      /* ? */
    )) {
      var r = !1;
      if (this.options.ecmaVersion >= 9 && (r = e.eat(
        60
        /* < */
      )), e.eat(
        61
        /* = */
      ) || e.eat(
        33
        /* ! */
      ))
        return this.regexp_disjunction(e), e.eat(
          41
          /* ) */
        ) || e.raise("Unterminated group"), e.lastAssertionIsQuantifiable = !r, !0;
    }
    return e.pos = t, !1;
  };
  Ze.regexp_eatQuantifier = function(e, t) {
    return t === void 0 && (t = !1), this.regexp_eatQuantifierPrefix(e, t) ? (e.eat(
      63
      /* ? */
    ), !0) : !1;
  };
  Ze.regexp_eatQuantifierPrefix = function(e, t) {
    return e.eat(
      42
      /* * */
    ) || e.eat(
      43
      /* + */
    ) || e.eat(
      63
      /* ? */
    ) || this.regexp_eatBracedQuantifier(e, t);
  };
  Ze.regexp_eatBracedQuantifier = function(e, t) {
    var r = e.pos;
    if (e.eat(
      123
      /* { */
    )) {
      var i = 0, n = -1;
      if (this.regexp_eatDecimalDigits(e) && (i = e.lastIntValue, e.eat(
        44
        /* , */
      ) && this.regexp_eatDecimalDigits(e) && (n = e.lastIntValue), e.eat(
        125
        /* } */
      )))
        return n !== -1 && n < i && !t && e.raise("numbers out of order in {} quantifier"), !0;
      e.switchU && !t && e.raise("Incomplete quantifier"), e.pos = r;
    }
    return !1;
  };
  Ze.regexp_eatAtom = function(e) {
    return this.regexp_eatPatternCharacters(e) || e.eat(
      46
      /* . */
    ) || this.regexp_eatReverseSolidusAtomEscape(e) || this.regexp_eatCharacterClass(e) || this.regexp_eatUncapturingGroup(e) || this.regexp_eatCapturingGroup(
    e);
  };
  Ze.regexp_eatReverseSolidusAtomEscape = function(e) {
    var t = e.pos;
    if (e.eat(
      92
      /* \ */
    )) {
      if (this.regexp_eatAtomEscape(e))
        return !0;
      e.pos = t;
    }
    return !1;
  };
  Ze.regexp_eatUncapturingGroup = function(e) {
    var t = e.pos;
    if (e.eat(
      40
      /* ( */
    )) {
      if (e.eat(
        63
        /* ? */
      )) {
        if (this.options.ecmaVersion >= 16) {
          var r = this.regexp_eatModifiers(e), i = e.eat(
            45
            /* - */
          );
          if (r || i) {
            for (var n = 0; n < r.length; n++) {
              var a = r.charAt(n);
              r.indexOf(a, n + 1) > -1 && e.raise("Duplicate regular expression modifiers");
            }
            if (i) {
              var o = this.regexp_eatModifiers(e);
              !r && !o && e.current() === 58 && e.raise("Invalid regular expression modifiers");
              for (var u = 0; u < o.length; u++) {
                var l = o.charAt(u);
                (o.indexOf(l, u + 1) > -1 || r.indexOf(l) > -1) && e.raise("Duplicate regular expression modifiers");
              }
            }
          }
        }
        if (e.eat(
          58
          /* : */
        )) {
          if (this.regexp_disjunction(e), e.eat(
            41
            /* ) */
          ))
            return !0;
          e.raise("Unterminated group");
        }
      }
      e.pos = t;
    }
    return !1;
  };
  Ze.regexp_eatCapturingGroup = function(e) {
    if (e.eat(
      40
      /* ( */
    )) {
      if (this.options.ecmaVersion >= 9 ? this.regexp_groupSpecifier(e) : e.current() === 63 && e.raise("Invalid group"), this.regexp_disjunction(
      e), e.eat(
        41
        /* ) */
      ))
        return e.numCapturingParens += 1, !0;
      e.raise("Unterminated group");
    }
    return !1;
  };
  Ze.regexp_eatModifiers = function(e) {
    for (var t = "", r = 0; (r = e.current()) !== -1 && lht(r); )
      t += Vu(r), e.advance();
    return t;
  };
  s(lht, "isRegularExpressionModifier");
  Ze.regexp_eatExtendedAtom = function(e) {
    return e.eat(
      46
      /* . */
    ) || this.regexp_eatReverseSolidusAtomEscape(e) || this.regexp_eatCharacterClass(e) || this.regexp_eatUncapturingGroup(e) || this.regexp_eatCapturingGroup(
    e) || this.regexp_eatInvalidBracedQuantifier(e) || this.regexp_eatExtendedPatternCharacter(e);
  };
  Ze.regexp_eatInvalidBracedQuantifier = function(e) {
    return this.regexp_eatBracedQuantifier(e, !0) && e.raise("Nothing to repeat"), !1;
  };
  Ze.regexp_eatSyntaxCharacter = function(e) {
    var t = e.current();
    return rse(t) ? (e.lastIntValue = t, e.advance(), !0) : !1;
  };
  s(rse, "isSyntaxCharacter");
  Ze.regexp_eatPatternCharacters = function(e) {
    for (var t = e.pos, r = 0; (r = e.current()) !== -1 && !rse(r); )
      e.advance();
    return e.pos !== t;
  };
  Ze.regexp_eatExtendedPatternCharacter = function(e) {
    var t = e.current();
    return t !== -1 && t !== 36 && !(t >= 40 && t <= 43) && t !== 46 && t !== 63 && t !== 91 && t !== 94 && t !== 124 ? (e.advance(), !0) : !1;
  };
  Ze.regexp_groupSpecifier = function(e) {
    if (e.eat(
      63
      /* ? */
    )) {
      this.regexp_eatGroupName(e) || e.raise("Invalid group");
      var t = this.options.ecmaVersion >= 16, r = e.groupNames[e.lastStringValue];
      if (r)
        if (t)
          for (var i = 0, n = r; i < n.length; i += 1) {
            var a = n[i];
            a.separatedFrom(e.branchID) || e.raise("Duplicate capture group name");
          }
        else
          e.raise("Duplicate capture group name");
      t ? (r || (e.groupNames[e.lastStringValue] = [])).push(e.branchID) : e.groupNames[e.lastStringValue] = !0;
    }
  };
  Ze.regexp_eatGroupName = function(e) {
    if (e.lastStringValue = "", e.eat(
      60
      /* < */
    )) {
      if (this.regexp_eatRegExpIdentifierName(e) && e.eat(
        62
        /* > */
      ))
        return !0;
      e.raise("Invalid capture group name");
    }
    return !1;
  };
  Ze.regexp_eatRegExpIdentifierName = function(e) {
    if (e.lastStringValue = "", this.regexp_eatRegExpIdentifierStart(e)) {
      for (e.lastStringValue += Vu(e.lastIntValue); this.regexp_eatRegExpIdentifierPart(e); )
        e.lastStringValue += Vu(e.lastIntValue);
      return !0;
    }
    return !1;
  };
  Ze.regexp_eatRegExpIdentifierStart = function(e) {
    var t = e.pos, r = this.options.ecmaVersion >= 11, i = e.current(r);
    return e.advance(r), i === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(e, r) && (i = e.lastIntValue), cht(i) ? (e.lastIntValue = i,
    !0) : (e.pos = t, !1);
  };
  s(cht, "isRegExpIdentifierStart");
  Ze.regexp_eatRegExpIdentifierPart = function(e) {
    var t = e.pos, r = this.options.ecmaVersion >= 11, i = e.current(r);
    return e.advance(r), i === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(e, r) && (i = e.lastIntValue), fht(i) ? (e.lastIntValue = i,
    !0) : (e.pos = t, !1);
  };
  s(fht, "isRegExpIdentifierPart");
  Ze.regexp_eatAtomEscape = function(e) {
    return this.regexp_eatBackReference(e) || this.regexp_eatCharacterClassEscape(e) || this.regexp_eatCharacterEscape(e) || e.switchN && this.
    regexp_eatKGroupName(e) ? !0 : (e.switchU && (e.current() === 99 && e.raise("Invalid unicode escape"), e.raise("Invalid escape")), !1);
  };
  Ze.regexp_eatBackReference = function(e) {
    var t = e.pos;
    if (this.regexp_eatDecimalEscape(e)) {
      var r = e.lastIntValue;
      if (e.switchU)
        return r > e.maxBackReference && (e.maxBackReference = r), !0;
      if (r <= e.numCapturingParens)
        return !0;
      e.pos = t;
    }
    return !1;
  };
  Ze.regexp_eatKGroupName = function(e) {
    if (e.eat(
      107
      /* k */
    )) {
      if (this.regexp_eatGroupName(e))
        return e.backReferenceNames.push(e.lastStringValue), !0;
      e.raise("Invalid named reference");
    }
    return !1;
  };
  Ze.regexp_eatCharacterEscape = function(e) {
    return this.regexp_eatControlEscape(e) || this.regexp_eatCControlLetter(e) || this.regexp_eatZero(e) || this.regexp_eatHexEscapeSequence(
    e) || this.regexp_eatRegExpUnicodeEscapeSequence(e, !1) || !e.switchU && this.regexp_eatLegacyOctalEscapeSequence(e) || this.regexp_eatIdentityEscape(
    e);
  };
  Ze.regexp_eatCControlLetter = function(e) {
    var t = e.pos;
    if (e.eat(
      99
      /* c */
    )) {
      if (this.regexp_eatControlLetter(e))
        return !0;
      e.pos = t;
    }
    return !1;
  };
  Ze.regexp_eatZero = function(e) {
    return e.current() === 48 && !x0(e.lookahead()) ? (e.lastIntValue = 0, e.advance(), !0) : !1;
  };
  Ze.regexp_eatControlEscape = function(e) {
    var t = e.current();
    return t === 116 ? (e.lastIntValue = 9, e.advance(), !0) : t === 110 ? (e.lastIntValue = 10, e.advance(), !0) : t === 118 ? (e.lastIntValue =
    11, e.advance(), !0) : t === 102 ? (e.lastIntValue = 12, e.advance(), !0) : t === 114 ? (e.lastIntValue = 13, e.advance(), !0) : !1;
  };
  Ze.regexp_eatControlLetter = function(e) {
    var t = e.current();
    return ise(t) ? (e.lastIntValue = t % 32, e.advance(), !0) : !1;
  };
  s(ise, "isControlLetter");
  Ze.regexp_eatRegExpUnicodeEscapeSequence = function(e, t) {
    t === void 0 && (t = !1);
    var r = e.pos, i = t || e.switchU;
    if (e.eat(
      117
      /* u */
    )) {
      if (this.regexp_eatFixedHexDigits(e, 4)) {
        var n = e.lastIntValue;
        if (i && n >= 55296 && n <= 56319) {
          var a = e.pos;
          if (e.eat(
            92
            /* \ */
          ) && e.eat(
            117
            /* u */
          ) && this.regexp_eatFixedHexDigits(e, 4)) {
            var o = e.lastIntValue;
            if (o >= 56320 && o <= 57343)
              return e.lastIntValue = (n - 55296) * 1024 + (o - 56320) + 65536, !0;
          }
          e.pos = a, e.lastIntValue = n;
        }
        return !0;
      }
      if (i && e.eat(
        123
        /* { */
      ) && this.regexp_eatHexDigits(e) && e.eat(
        125
        /* } */
      ) && pht(e.lastIntValue))
        return !0;
      i && e.raise("Invalid unicode escape"), e.pos = r;
    }
    return !1;
  };
  s(pht, "isValidUnicode");
  Ze.regexp_eatIdentityEscape = function(e) {
    if (e.switchU)
      return this.regexp_eatSyntaxCharacter(e) ? !0 : e.eat(
        47
        /* / */
      ) ? (e.lastIntValue = 47, !0) : !1;
    var t = e.current();
    return t !== 99 && (!e.switchN || t !== 107) ? (e.lastIntValue = t, e.advance(), !0) : !1;
  };
  Ze.regexp_eatDecimalEscape = function(e) {
    e.lastIntValue = 0;
    var t = e.current();
    if (t >= 49 && t <= 57) {
      do
        e.lastIntValue = 10 * e.lastIntValue + (t - 48), e.advance();
      while ((t = e.current()) >= 48 && t <= 57);
      return !0;
    }
    return !1;
  };
  nse = 0, Ku = 1, Ba = 2;
  Ze.regexp_eatCharacterClassEscape = function(e) {
    var t = e.current();
    if (hht(t))
      return e.lastIntValue = -1, e.advance(), Ku;
    var r = !1;
    if (e.switchU && this.options.ecmaVersion >= 9 && ((r = t === 80) || t === 112)) {
      e.lastIntValue = -1, e.advance();
      var i;
      if (e.eat(
        123
        /* { */
      ) && (i = this.regexp_eatUnicodePropertyValueExpression(e)) && e.eat(
        125
        /* } */
      ))
        return r && i === Ba && e.raise("Invalid property name"), i;
      e.raise("Invalid property name");
    }
    return nse;
  };
  s(hht, "isCharacterClassEscape");
  Ze.regexp_eatUnicodePropertyValueExpression = function(e) {
    var t = e.pos;
    if (this.regexp_eatUnicodePropertyName(e) && e.eat(
      61
      /* = */
    )) {
      var r = e.lastStringValue;
      if (this.regexp_eatUnicodePropertyValue(e)) {
        var i = e.lastStringValue;
        return this.regexp_validateUnicodePropertyNameAndValue(e, r, i), Ku;
      }
    }
    if (e.pos = t, this.regexp_eatLoneUnicodePropertyNameOrValue(e)) {
      var n = e.lastStringValue;
      return this.regexp_validateUnicodePropertyNameOrValue(e, n);
    }
    return nse;
  };
  Ze.regexp_validateUnicodePropertyNameAndValue = function(e, t, r) {
    dh(e.unicodeProperties.nonBinary, t) || e.raise("Invalid property name"), e.unicodeProperties.nonBinary[t].test(r) || e.raise("Invalid p\
roperty value");
  };
  Ze.regexp_validateUnicodePropertyNameOrValue = function(e, t) {
    if (e.unicodeProperties.binary.test(t))
      return Ku;
    if (e.switchV && e.unicodeProperties.binaryOfStrings.test(t))
      return Ba;
    e.raise("Invalid property name");
  };
  Ze.regexp_eatUnicodePropertyName = function(e) {
    var t = 0;
    for (e.lastStringValue = ""; sse(t = e.current()); )
      e.lastStringValue += Vu(t), e.advance();
    return e.lastStringValue !== "";
  };
  s(sse, "isUnicodePropertyNameCharacter");
  Ze.regexp_eatUnicodePropertyValue = function(e) {
    var t = 0;
    for (e.lastStringValue = ""; dht(t = e.current()); )
      e.lastStringValue += Vu(t), e.advance();
    return e.lastStringValue !== "";
  };
  s(dht, "isUnicodePropertyValueCharacter");
  Ze.regexp_eatLoneUnicodePropertyNameOrValue = function(e) {
    return this.regexp_eatUnicodePropertyValue(e);
  };
  Ze.regexp_eatCharacterClass = function(e) {
    if (e.eat(
      91
      /* [ */
    )) {
      var t = e.eat(
        94
        /* ^ */
      ), r = this.regexp_classContents(e);
      return e.eat(
        93
        /* ] */
      ) || e.raise("Unterminated character class"), t && r === Ba && e.raise("Negated character class may contain strings"), !0;
    }
    return !1;
  };
  Ze.regexp_classContents = function(e) {
    return e.current() === 93 ? Ku : e.switchV ? this.regexp_classSetExpression(e) : (this.regexp_nonEmptyClassRanges(e), Ku);
  };
  Ze.regexp_nonEmptyClassRanges = function(e) {
    for (; this.regexp_eatClassAtom(e); ) {
      var t = e.lastIntValue;
      if (e.eat(
        45
        /* - */
      ) && this.regexp_eatClassAtom(e)) {
        var r = e.lastIntValue;
        e.switchU && (t === -1 || r === -1) && e.raise("Invalid character class"), t !== -1 && r !== -1 && t > r && e.raise("Range out of or\
der in character class");
      }
    }
  };
  Ze.regexp_eatClassAtom = function(e) {
    var t = e.pos;
    if (e.eat(
      92
      /* \ */
    )) {
      if (this.regexp_eatClassEscape(e))
        return !0;
      if (e.switchU) {
        var r = e.current();
        (r === 99 || use(r)) && e.raise("Invalid class escape"), e.raise("Invalid escape");
      }
      e.pos = t;
    }
    var i = e.current();
    return i !== 93 ? (e.lastIntValue = i, e.advance(), !0) : !1;
  };
  Ze.regexp_eatClassEscape = function(e) {
    var t = e.pos;
    if (e.eat(
      98
      /* b */
    ))
      return e.lastIntValue = 8, !0;
    if (e.switchU && e.eat(
      45
      /* - */
    ))
      return e.lastIntValue = 45, !0;
    if (!e.switchU && e.eat(
      99
      /* c */
    )) {
      if (this.regexp_eatClassControlLetter(e))
        return !0;
      e.pos = t;
    }
    return this.regexp_eatCharacterClassEscape(e) || this.regexp_eatCharacterEscape(e);
  };
  Ze.regexp_classSetExpression = function(e) {
    var t = Ku, r;
    if (!this.regexp_eatClassSetRange(e)) if (r = this.regexp_eatClassSetOperand(e)) {
      r === Ba && (t = Ba);
      for (var i = e.pos; e.eatChars(
        [38, 38]
        /* && */
      ); ) {
        if (e.current() !== 38 && (r = this.regexp_eatClassSetOperand(e))) {
          r !== Ba && (t = Ku);
          continue;
        }
        e.raise("Invalid character in character class");
      }
      if (i !== e.pos)
        return t;
      for (; e.eatChars(
        [45, 45]
        /* -- */
      ); )
        this.regexp_eatClassSetOperand(e) || e.raise("Invalid character in character class");
      if (i !== e.pos)
        return t;
    } else
      e.raise("Invalid character in character class");
    for (; ; )
      if (!this.regexp_eatClassSetRange(e)) {
        if (r = this.regexp_eatClassSetOperand(e), !r)
          return t;
        r === Ba && (t = Ba);
      }
  };
  Ze.regexp_eatClassSetRange = function(e) {
    var t = e.pos;
    if (this.regexp_eatClassSetCharacter(e)) {
      var r = e.lastIntValue;
      if (e.eat(
        45
        /* - */
      ) && this.regexp_eatClassSetCharacter(e)) {
        var i = e.lastIntValue;
        return r !== -1 && i !== -1 && r > i && e.raise("Range out of order in character class"), !0;
      }
      e.pos = t;
    }
    return !1;
  };
  Ze.regexp_eatClassSetOperand = function(e) {
    return this.regexp_eatClassSetCharacter(e) ? Ku : this.regexp_eatClassStringDisjunction(e) || this.regexp_eatNestedClass(e);
  };
  Ze.regexp_eatNestedClass = function(e) {
    var t = e.pos;
    if (e.eat(
      91
      /* [ */
    )) {
      var r = e.eat(
        94
        /* ^ */
      ), i = this.regexp_classContents(e);
      if (e.eat(
        93
        /* ] */
      ))
        return r && i === Ba && e.raise("Negated character class may contain strings"), i;
      e.pos = t;
    }
    if (e.eat(
      92
      /* \ */
    )) {
      var n = this.regexp_eatCharacterClassEscape(e);
      if (n)
        return n;
      e.pos = t;
    }
    return null;
  };
  Ze.regexp_eatClassStringDisjunction = function(e) {
    var t = e.pos;
    if (e.eatChars(
      [92, 113]
      /* \q */
    )) {
      if (e.eat(
        123
        /* { */
      )) {
        var r = this.regexp_classStringDisjunctionContents(e);
        if (e.eat(
          125
          /* } */
        ))
          return r;
      } else
        e.raise("Invalid escape");
      e.pos = t;
    }
    return null;
  };
  Ze.regexp_classStringDisjunctionContents = function(e) {
    for (var t = this.regexp_classString(e); e.eat(
      124
      /* | */
    ); )
      this.regexp_classString(e) === Ba && (t = Ba);
    return t;
  };
  Ze.regexp_classString = function(e) {
    for (var t = 0; this.regexp_eatClassSetCharacter(e); )
      t++;
    return t === 1 ? Ku : Ba;
  };
  Ze.regexp_eatClassSetCharacter = function(e) {
    var t = e.pos;
    if (e.eat(
      92
      /* \ */
    ))
      return this.regexp_eatCharacterEscape(e) || this.regexp_eatClassSetReservedPunctuator(e) ? !0 : e.eat(
        98
        /* b */
      ) ? (e.lastIntValue = 8, !0) : (e.pos = t, !1);
    var r = e.current();
    return r < 0 || r === e.lookahead() && mht(r) || yht(r) ? !1 : (e.advance(), e.lastIntValue = r, !0);
  };
  s(mht, "isClassSetReservedDoublePunctuatorCharacter");
  s(yht, "isClassSetSyntaxCharacter");
  Ze.regexp_eatClassSetReservedPunctuator = function(e) {
    var t = e.current();
    return ght(t) ? (e.lastIntValue = t, e.advance(), !0) : !1;
  };
  s(ght, "isClassSetReservedPunctuator");
  Ze.regexp_eatClassControlLetter = function(e) {
    var t = e.current();
    return x0(t) || t === 95 ? (e.lastIntValue = t % 32, e.advance(), !0) : !1;
  };
  Ze.regexp_eatHexEscapeSequence = function(e) {
    var t = e.pos;
    if (e.eat(
      120
      /* x */
    )) {
      if (this.regexp_eatFixedHexDigits(e, 2))
        return !0;
      e.switchU && e.raise("Invalid escape"), e.pos = t;
    }
    return !1;
  };
  Ze.regexp_eatDecimalDigits = function(e) {
    var t = e.pos, r = 0;
    for (e.lastIntValue = 0; x0(r = e.current()); )
      e.lastIntValue = 10 * e.lastIntValue + (r - 48), e.advance();
    return e.pos !== t;
  };
  s(x0, "isDecimalDigit");
  Ze.regexp_eatHexDigits = function(e) {
    var t = e.pos, r = 0;
    for (e.lastIntValue = 0; ase(r = e.current()); )
      e.lastIntValue = 16 * e.lastIntValue + ose(r), e.advance();
    return e.pos !== t;
  };
  s(ase, "isHexDigit");
  s(ose, "hexToInt");
  Ze.regexp_eatLegacyOctalEscapeSequence = function(e) {
    if (this.regexp_eatOctalDigit(e)) {
      var t = e.lastIntValue;
      if (this.regexp_eatOctalDigit(e)) {
        var r = e.lastIntValue;
        t <= 3 && this.regexp_eatOctalDigit(e) ? e.lastIntValue = t * 64 + r * 8 + e.lastIntValue : e.lastIntValue = t * 8 + r;
      } else
        e.lastIntValue = t;
      return !0;
    }
    return !1;
  };
  Ze.regexp_eatOctalDigit = function(e) {
    var t = e.current();
    return use(t) ? (e.lastIntValue = t - 48, e.advance(), !0) : (e.lastIntValue = 0, !1);
  };
  s(use, "isOctalDigit");
  Ze.regexp_eatFixedHexDigits = function(e, t) {
    var r = e.pos;
    e.lastIntValue = 0;
    for (var i = 0; i < t; ++i) {
      var n = e.current();
      if (!ase(n))
        return e.pos = r, !1;
      e.lastIntValue = 16 * e.lastIntValue + ose(n), e.advance();
    }
    return !0;
  };
  C0 = /* @__PURE__ */ s(function(t) {
    this.type = t.type, this.value = t.value, this.start = t.start, this.end = t.end, t.options.locations && (this.loc = new my(t, t.startLoc,
    t.endLoc)), t.options.ranges && (this.range = [t.start, t.end]);
  }, "Token"), ar = ji.prototype;
  ar.next = function(e) {
    !e && this.type.keyword && this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword), this.
    options.onToken && this.options.onToken(new C0(this)), this.lastTokEnd = this.end, this.lastTokStart = this.start, this.lastTokEndLoc = this.
    endLoc, this.lastTokStartLoc = this.startLoc, this.nextToken();
  };
  ar.getToken = function() {
    return this.next(), new C0(this);
  };
  typeof Symbol < "u" && (ar[Symbol.iterator] = function() {
    var e = this;
    return {
      next: /* @__PURE__ */ s(function() {
        var t = e.getToken();
        return {
          done: t.type === O.eof,
          value: t
        };
      }, "next")
    };
  });
  ar.nextToken = function() {
    var e = this.curContext();
    if ((!e || !e.preserveSpace) && this.skipSpace(), this.start = this.pos, this.options.locations && (this.startLoc = this.curPosition()),
    this.pos >= this.input.length)
      return this.finishToken(O.eof);
    if (e.override)
      return e.override(this);
    this.readToken(this.fullCharCodeAtPos());
  };
  ar.readToken = function(e) {
    return eu(e, this.options.ecmaVersion >= 6) || e === 92 ? this.readWord() : this.getTokenFromCode(e);
  };
  ar.fullCharCodeAtPos = function() {
    var e = this.input.charCodeAt(this.pos);
    if (e <= 55295 || e >= 56320)
      return e;
    var t = this.input.charCodeAt(this.pos + 1);
    return t <= 56319 || t >= 57344 ? e : (e << 10) + t - 56613888;
  };
  ar.skipBlockComment = function() {
    var e = this.options.onComment && this.curPosition(), t = this.pos, r = this.input.indexOf("*/", this.pos += 2);
    if (r === -1 && this.raise(this.pos - 2, "Unterminated comment"), this.pos = r + 2, this.options.locations)
      for (var i = void 0, n = t; (i = Nne(this.input, n, this.pos)) > -1; )
        ++this.curLine, n = this.lineStart = i;
    this.options.onComment && this.options.onComment(
      !0,
      this.input.slice(t + 2, r),
      t,
      this.pos,
      e,
      this.curPosition()
    );
  };
  ar.skipLineComment = function(e) {
    for (var t = this.pos, r = this.options.onComment && this.curPosition(), i = this.input.charCodeAt(this.pos += e); this.pos < this.input.
    length && !hf(i); )
      i = this.input.charCodeAt(++this.pos);
    this.options.onComment && this.options.onComment(
      !1,
      this.input.slice(t + e, this.pos),
      t,
      this.pos,
      r,
      this.curPosition()
    );
  };
  ar.skipSpace = function() {
    e: for (; this.pos < this.input.length; ) {
      var e = this.input.charCodeAt(this.pos);
      switch (e) {
        case 32:
        case 160:
          ++this.pos;
          break;
        case 13:
          this.input.charCodeAt(this.pos + 1) === 10 && ++this.pos;
        case 10:
        case 8232:
        case 8233:
          ++this.pos, this.options.locations && (++this.curLine, this.lineStart = this.pos);
          break;
        case 47:
          switch (this.input.charCodeAt(this.pos + 1)) {
            case 42:
              this.skipBlockComment();
              break;
            case 47:
              this.skipLineComment(2);
              break;
            default:
              break e;
          }
          break;
        default:
          if (e > 8 && e < 14 || e >= 5760 && iI.test(String.fromCharCode(e)))
            ++this.pos;
          else
            break e;
      }
    }
  };
  ar.finishToken = function(e, t) {
    this.end = this.pos, this.options.locations && (this.endLoc = this.curPosition());
    var r = this.type;
    this.type = e, this.value = t, this.updateContext(r);
  };
  ar.readToken_dot = function() {
    var e = this.input.charCodeAt(this.pos + 1);
    if (e >= 48 && e <= 57)
      return this.readNumber(!0);
    var t = this.input.charCodeAt(this.pos + 2);
    return this.options.ecmaVersion >= 6 && e === 46 && t === 46 ? (this.pos += 3, this.finishToken(O.ellipsis)) : (++this.pos, this.finishToken(
    O.dot));
  };
  ar.readToken_slash = function() {
    var e = this.input.charCodeAt(this.pos + 1);
    return this.exprAllowed ? (++this.pos, this.readRegexp()) : e === 61 ? this.finishOp(O.assign, 2) : this.finishOp(O.slash, 1);
  };
  ar.readToken_mult_modulo_exp = function(e) {
    var t = this.input.charCodeAt(this.pos + 1), r = 1, i = e === 42 ? O.star : O.modulo;
    return this.options.ecmaVersion >= 7 && e === 42 && t === 42 && (++r, i = O.starstar, t = this.input.charCodeAt(this.pos + 2)), t === 61 ?
    this.finishOp(O.assign, r + 1) : this.finishOp(i, r);
  };
  ar.readToken_pipe_amp = function(e) {
    var t = this.input.charCodeAt(this.pos + 1);
    if (t === e) {
      if (this.options.ecmaVersion >= 12) {
        var r = this.input.charCodeAt(this.pos + 2);
        if (r === 61)
          return this.finishOp(O.assign, 3);
      }
      return this.finishOp(e === 124 ? O.logicalOR : O.logicalAND, 2);
    }
    return t === 61 ? this.finishOp(O.assign, 2) : this.finishOp(e === 124 ? O.bitwiseOR : O.bitwiseAND, 1);
  };
  ar.readToken_caret = function() {
    var e = this.input.charCodeAt(this.pos + 1);
    return e === 61 ? this.finishOp(O.assign, 2) : this.finishOp(O.bitwiseXOR, 1);
  };
  ar.readToken_plus_min = function(e) {
    var t = this.input.charCodeAt(this.pos + 1);
    return t === e ? t === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || fa.test(this.input.
    slice(this.lastTokEnd, this.pos))) ? (this.skipLineComment(3), this.skipSpace(), this.nextToken()) : this.finishOp(O.incDec, 2) : t === 61 ?
    this.finishOp(O.assign, 2) : this.finishOp(O.plusMin, 1);
  };
  ar.readToken_lt_gt = function(e) {
    var t = this.input.charCodeAt(this.pos + 1), r = 1;
    return t === e ? (r = e === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2, this.input.charCodeAt(this.pos + r) === 61 ? this.
    finishOp(O.assign, r + 1) : this.finishOp(O.bitShift, r)) : t === 33 && e === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) ===
    45 && this.input.charCodeAt(this.pos + 3) === 45 ? (this.skipLineComment(4), this.skipSpace(), this.nextToken()) : (t === 61 && (r = 2),
    this.finishOp(O.relational, r));
  };
  ar.readToken_eq_excl = function(e) {
    var t = this.input.charCodeAt(this.pos + 1);
    return t === 61 ? this.finishOp(O.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) : e === 61 && t === 62 && this.options.ecmaVersion >=
    6 ? (this.pos += 2, this.finishToken(O.arrow)) : this.finishOp(e === 61 ? O.eq : O.prefix, 1);
  };
  ar.readToken_question = function() {
    var e = this.options.ecmaVersion;
    if (e >= 11) {
      var t = this.input.charCodeAt(this.pos + 1);
      if (t === 46) {
        var r = this.input.charCodeAt(this.pos + 2);
        if (r < 48 || r > 57)
          return this.finishOp(O.questionDot, 2);
      }
      if (t === 63) {
        if (e >= 12) {
          var i = this.input.charCodeAt(this.pos + 2);
          if (i === 61)
            return this.finishOp(O.assign, 3);
        }
        return this.finishOp(O.coalesce, 2);
      }
    }
    return this.finishOp(O.question, 1);
  };
  ar.readToken_numberSign = function() {
    var e = this.options.ecmaVersion, t = 35;
    if (e >= 13 && (++this.pos, t = this.fullCharCodeAtPos(), eu(t, !0) || t === 92))
      return this.finishToken(O.privateId, this.readWord1());
    this.raise(this.pos, "Unexpected character '" + Vu(t) + "'");
  };
  ar.getTokenFromCode = function(e) {
    switch (e) {
      // The interpretation of a dot depends on whether it is followed
      // by a digit or another two dots.
      case 46:
        return this.readToken_dot();
      // Punctuation tokens.
      case 40:
        return ++this.pos, this.finishToken(O.parenL);
      case 41:
        return ++this.pos, this.finishToken(O.parenR);
      case 59:
        return ++this.pos, this.finishToken(O.semi);
      case 44:
        return ++this.pos, this.finishToken(O.comma);
      case 91:
        return ++this.pos, this.finishToken(O.bracketL);
      case 93:
        return ++this.pos, this.finishToken(O.bracketR);
      case 123:
        return ++this.pos, this.finishToken(O.braceL);
      case 125:
        return ++this.pos, this.finishToken(O.braceR);
      case 58:
        return ++this.pos, this.finishToken(O.colon);
      case 96:
        if (this.options.ecmaVersion < 6)
          break;
        return ++this.pos, this.finishToken(O.backQuote);
      case 48:
        var t = this.input.charCodeAt(this.pos + 1);
        if (t === 120 || t === 88)
          return this.readRadixNumber(16);
        if (this.options.ecmaVersion >= 6) {
          if (t === 111 || t === 79)
            return this.readRadixNumber(8);
          if (t === 98 || t === 66)
            return this.readRadixNumber(2);
        }
      // Anything else beginning with a digit is an integer, octal
      // number, or float.
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
        return this.readNumber(!1);
      // Quotes produce strings.
      case 34:
      case 39:
        return this.readString(e);
      // Operators are parsed inline in tiny state machines. '=' (61) is
      // often referred to. `finishOp` simply skips the amount of
      // characters it is given as second argument, and returns a token
      // of the type given by its first argument.
      case 47:
        return this.readToken_slash();
      case 37:
      case 42:
        return this.readToken_mult_modulo_exp(e);
      case 124:
      case 38:
        return this.readToken_pipe_amp(e);
      case 94:
        return this.readToken_caret();
      case 43:
      case 45:
        return this.readToken_plus_min(e);
      case 60:
      case 62:
        return this.readToken_lt_gt(e);
      case 61:
      case 33:
        return this.readToken_eq_excl(e);
      case 63:
        return this.readToken_question();
      case 126:
        return this.finishOp(O.prefix, 1);
      case 35:
        return this.readToken_numberSign();
    }
    this.raise(this.pos, "Unexpected character '" + Vu(e) + "'");
  };
  ar.finishOp = function(e, t) {
    var r = this.input.slice(this.pos, this.pos + t);
    return this.pos += t, this.finishToken(e, r);
  };
  ar.readRegexp = function() {
    for (var e, t, r = this.pos; ; ) {
      this.pos >= this.input.length && this.raise(r, "Unterminated regular expression");
      var i = this.input.charAt(this.pos);
      if (fa.test(i) && this.raise(r, "Unterminated regular expression"), e)
        e = !1;
      else {
        if (i === "[")
          t = !0;
        else if (i === "]" && t)
          t = !1;
        else if (i === "/" && !t)
          break;
        e = i === "\\";
      }
      ++this.pos;
    }
    var n = this.input.slice(r, this.pos);
    ++this.pos;
    var a = this.pos, o = this.readWord1();
    this.containsEsc && this.unexpected(a);
    var u = this.regexpState || (this.regexpState = new ru(this));
    u.reset(r, n, o), this.validateRegExpFlags(u), this.validateRegExpPattern(u);
    var l = null;
    try {
      l = new RegExp(n, o);
    } catch {
    }
    return this.finishToken(O.regexp, { pattern: n, flags: o, value: l });
  };
  ar.readInt = function(e, t, r) {
    for (var i = this.options.ecmaVersion >= 12 && t === void 0, n = r && this.input.charCodeAt(this.pos) === 48, a = this.pos, o = 0, u = 0,
    l = 0, c = t ?? 1 / 0; l < c; ++l, ++this.pos) {
      var p = this.input.charCodeAt(this.pos), h = void 0;
      if (i && p === 95) {
        n && this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals"), u === 95 && this.raiseRecoverable(
        this.pos, "Numeric separator must be exactly one underscore"), l === 0 && this.raiseRecoverable(this.pos, "Numeric separator is not \
allowed at the first of digits"), u = p;
        continue;
      }
      if (p >= 97 ? h = p - 97 + 10 : p >= 65 ? h = p - 65 + 10 : p >= 48 && p <= 57 ? h = p - 48 : h = 1 / 0, h >= e)
        break;
      u = p, o = o * e + h;
    }
    return i && u === 95 && this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits"), this.pos === a ||
    t != null && this.pos - a !== t ? null : o;
  };
  s(_ht, "stringToNumber");
  s(lse, "stringToBigInt");
  ar.readRadixNumber = function(e) {
    var t = this.pos;
    this.pos += 2;
    var r = this.readInt(e);
    return r == null && this.raise(this.start + 2, "Expected number in radix " + e), this.options.ecmaVersion >= 11 && this.input.charCodeAt(
    this.pos) === 110 ? (r = lse(this.input.slice(t, this.pos)), ++this.pos) : eu(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identif\
ier directly after number"), this.finishToken(O.num, r);
  };
  ar.readNumber = function(e) {
    var t = this.pos;
    !e && this.readInt(10, void 0, !0) === null && this.raise(t, "Invalid number");
    var r = this.pos - t >= 2 && this.input.charCodeAt(t) === 48;
    r && this.strict && this.raise(t, "Invalid number");
    var i = this.input.charCodeAt(this.pos);
    if (!r && !e && this.options.ecmaVersion >= 11 && i === 110) {
      var n = lse(this.input.slice(t, this.pos));
      return ++this.pos, eu(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number"), this.finishToken(O.num, n);
    }
    r && /[89]/.test(this.input.slice(t, this.pos)) && (r = !1), i === 46 && !r && (++this.pos, this.readInt(10), i = this.input.charCodeAt(
    this.pos)), (i === 69 || i === 101) && !r && (i = this.input.charCodeAt(++this.pos), (i === 43 || i === 45) && ++this.pos, this.readInt(
    10) === null && this.raise(t, "Invalid number")), eu(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number");
    var a = _ht(this.input.slice(t, this.pos), r);
    return this.finishToken(O.num, a);
  };
  ar.readCodePoint = function() {
    var e = this.input.charCodeAt(this.pos), t;
    if (e === 123) {
      this.options.ecmaVersion < 6 && this.unexpected();
      var r = ++this.pos;
      t = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos), ++this.pos, t > 1114111 && this.invalidStringToken(r, "Code point \
out of bounds");
    } else
      t = this.readHexChar(4);
    return t;
  };
  ar.readString = function(e) {
    for (var t = "", r = ++this.pos; ; ) {
      this.pos >= this.input.length && this.raise(this.start, "Unterminated string constant");
      var i = this.input.charCodeAt(this.pos);
      if (i === e)
        break;
      i === 92 ? (t += this.input.slice(r, this.pos), t += this.readEscapedChar(!1), r = this.pos) : i === 8232 || i === 8233 ? (this.options.
      ecmaVersion < 10 && this.raise(this.start, "Unterminated string constant"), ++this.pos, this.options.locations && (this.curLine++, this.
      lineStart = this.pos)) : (hf(i) && this.raise(this.start, "Unterminated string constant"), ++this.pos);
    }
    return t += this.input.slice(r, this.pos++), this.finishToken(O.string, t);
  };
  cse = {};
  ar.tryReadTemplateToken = function() {
    this.inTemplateElement = !0;
    try {
      this.readTmplToken();
    } catch (e) {
      if (e === cse)
        this.readInvalidTemplateToken();
      else
        throw e;
    }
    this.inTemplateElement = !1;
  };
  ar.invalidStringToken = function(e, t) {
    if (this.inTemplateElement && this.options.ecmaVersion >= 9)
      throw cse;
    this.raise(e, t);
  };
  ar.readTmplToken = function() {
    for (var e = "", t = this.pos; ; ) {
      this.pos >= this.input.length && this.raise(this.start, "Unterminated template");
      var r = this.input.charCodeAt(this.pos);
      if (r === 96 || r === 36 && this.input.charCodeAt(this.pos + 1) === 123)
        return this.pos === this.start && (this.type === O.template || this.type === O.invalidTemplate) ? r === 36 ? (this.pos += 2, this.finishToken(
        O.dollarBraceL)) : (++this.pos, this.finishToken(O.backQuote)) : (e += this.input.slice(t, this.pos), this.finishToken(O.template, e));
      if (r === 92)
        e += this.input.slice(t, this.pos), e += this.readEscapedChar(!0), t = this.pos;
      else if (hf(r)) {
        switch (e += this.input.slice(t, this.pos), ++this.pos, r) {
          case 13:
            this.input.charCodeAt(this.pos) === 10 && ++this.pos;
          case 10:
            e += `
`;
            break;
          default:
            e += String.fromCharCode(r);
            break;
        }
        this.options.locations && (++this.curLine, this.lineStart = this.pos), t = this.pos;
      } else
        ++this.pos;
    }
  };
  ar.readInvalidTemplateToken = function() {
    for (; this.pos < this.input.length; this.pos++)
      switch (this.input[this.pos]) {
        case "\\":
          ++this.pos;
          break;
        case "$":
          if (this.input[this.pos + 1] !== "{")
            break;
        // fall through
        case "`":
          return this.finishToken(O.invalidTemplate, this.input.slice(this.start, this.pos));
        case "\r":
          this.input[this.pos + 1] === `
` && ++this.pos;
        // fall through
        case `
`:
        case "\u2028":
        case "\u2029":
          ++this.curLine, this.lineStart = this.pos + 1;
          break;
      }
    this.raise(this.start, "Unterminated template");
  };
  ar.readEscapedChar = function(e) {
    var t = this.input.charCodeAt(++this.pos);
    switch (++this.pos, t) {
      case 110:
        return `
`;
      // 'n' -> '\n'
      case 114:
        return "\r";
      // 'r' -> '\r'
      case 120:
        return String.fromCharCode(this.readHexChar(2));
      // 'x'
      case 117:
        return Vu(this.readCodePoint());
      // 'u'
      case 116:
        return "	";
      // 't' -> '\t'
      case 98:
        return "\b";
      // 'b' -> '\b'
      case 118:
        return "\v";
      // 'v' -> '\u000b'
      case 102:
        return "\f";
      // 'f' -> '\f'
      case 13:
        this.input.charCodeAt(this.pos) === 10 && ++this.pos;
      // '\r\n'
      case 10:
        return this.options.locations && (this.lineStart = this.pos, ++this.curLine), "";
      case 56:
      case 57:
        if (this.strict && this.invalidStringToken(
          this.pos - 1,
          "Invalid escape sequence"
        ), e) {
          var r = this.pos - 1;
          this.invalidStringToken(
            r,
            "Invalid escape sequence in template string"
          );
        }
      default:
        if (t >= 48 && t <= 55) {
          var i = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0], n = parseInt(i, 8);
          return n > 255 && (i = i.slice(0, -1), n = parseInt(i, 8)), this.pos += i.length - 1, t = this.input.charCodeAt(this.pos), (i !== "\
0" || t === 56 || t === 57) && (this.strict || e) && this.invalidStringToken(
            this.pos - 1 - i.length,
            e ? "Octal literal in template string" : "Octal literal in strict mode"
          ), String.fromCharCode(n);
        }
        return hf(t) ? (this.options.locations && (this.lineStart = this.pos, ++this.curLine), "") : String.fromCharCode(t);
    }
  };
  ar.readHexChar = function(e) {
    var t = this.pos, r = this.readInt(16, e);
    return r === null && this.invalidStringToken(t, "Bad character escape sequence"), r;
  };
  ar.readWord1 = function() {
    this.containsEsc = !1;
    for (var e = "", t = !0, r = this.pos, i = this.options.ecmaVersion >= 6; this.pos < this.input.length; ) {
      var n = this.fullCharCodeAtPos();
      if (pf(n, i))
        this.pos += n <= 65535 ? 1 : 2;
      else if (n === 92) {
        this.containsEsc = !0, e += this.input.slice(r, this.pos);
        var a = this.pos;
        this.input.charCodeAt(++this.pos) !== 117 && this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX"), ++this.
        pos;
        var o = this.readCodePoint();
        (t ? eu : pf)(o, i) || this.invalidStringToken(a, "Invalid Unicode escape"), e += Vu(o), r = this.pos;
      } else
        break;
      t = !1;
    }
    return e + this.input.slice(r, this.pos);
  };
  ar.readWord = function() {
    var e = this.readWord1(), t = O.name;
    return this.keywords.test(e) && (t = S0[e]), this.finishToken(t, e);
  };
  fse = "8.14.1";
  ji.acorn = {
    Parser: ji,
    version: fse,
    defaultOptions: y0,
    Position: hh,
    SourceLocation: my,
    getLineInfo: nI,
    Node: gy,
    TokenType: vr,
    tokTypes: O,
    keywordTypes: S0,
    TokContext: Fa,
    tokContexts: ci,
    isIdentifierChar: pf,
    isIdentifierStart: eu,
    Token: C0,
    isNewLine: hf,
    lineBreak: fa,
    lineBreakG: Rne,
    nonASCIIwhitespace: iI
  };
  s(bht, "parse");
  s(vht, "parseExpressionAt");
  s(Sht, "tokenizer");
});

// ../node_modules/terser/lib/cli.js
async function dse({ program: e, packageJson: t, fs: r, path: i }) {
  let n = /* @__PURE__ */ new Set(["cname", "parent_scope", "scope", "uses_eval", "uses_with"]);
  var a = {}, o = {
    compress: !1,
    mangle: !1
  };
  let u = await cI();
  if (e.version(t.name + " " + t.version), e.parseArgv = e.parse, e.parse = void 0, process.argv.includes("ast") ? e.helpInformation = x : process.
  argv.includes("options") && (e.helpInformation = function() {
    var C = [];
    for (var z in u)
      C.push("--" + (z === "sourceMap" ? "source-map" : z) + " options:"), C.push(E(u[z])), C.push("");
    return C.join(`
`);
  }), e.option("-p, --parse <options>", "Specify parser options.", f()), e.option("-c, --compress [options]", "Enable compressor/specify com\
pressor options.", f()), e.option("-m, --mangle [options]", "Mangle names/specify mangler options.", f()), e.option("--mangle-props [options\
]", "Mangle properties/specify mangler options.", f()), e.option("-f, --format [options]", "Format options.", f()), e.option("-b, --beautify\
 [options]", "Alias for --format.", f()), e.option("-o, --output <file>", "Output file (default STDOUT)."), e.option("--comments [filter]", "\
Preserve copyright comments in the output."), e.option("--config-file <file>", "Read minify() options from JSON file."), e.option("-d, --def\
ine <expr>[=value]", "Global definitions.", f("define")), e.option("--ecma <version>", "Specify ECMAScript release: 5, 2015, 2016 or 2017..."),
  e.option("-e, --enclose [arg[,...][:value[,...]]]", "Embed output in a big function with configurable arguments and values."), e.option("-\
-ie8", "Support non-standard Internet Explorer 8."), e.option("--keep-classnames", "Do not mangle/drop class names."), e.option("--keep-fnam\
es", "Do not mangle/drop function names. Useful for code relying on Function.prototype.name."), e.option("--module", "Input is an ES6 module"),
  e.option("--name-cache <file>", "File to hold mangled name mappings."), e.option("--rename", "Force symbol expansion."), e.option("--no-re\
name", "Disable symbol expansion."), e.option("--safari10", "Support non-standard Safari 10."), e.option("--source-map [options]", "Enable s\
ource map/specify source map options.", f()), e.option("--timings", "Display operations run time on STDERR."), e.option("--toplevel", "Compr\
ess and/or mangle variables in toplevel scope."), e.option("--wrap <name>", "Embed everything as a function with \u201Cexports\u201D corresponding to \
\u201Cname\u201D globally."), e.arguments("[files...]").parseArgv(process.argv), e.configFile && (o = JSON.parse(m(e.configFile))), !e.output &&
  e.sourceMap && e.sourceMap.url != "inline" && _("ERROR: cannot write source map to STDOUT"), [
    "compress",
    "enclose",
    "ie8",
    "mangle",
    "module",
    "safari10",
    "sourceMap",
    "toplevel",
    "wrap"
  ].forEach(function(C) {
    C in e && (o[C] = e[C]);
  }), "ecma" in e) {
    e.ecma != (e.ecma | 0) && _("ERROR: ecma must be an integer");
    let C = e.ecma | 0;
    C > 5 && C < 2015 ? o.ecma = C + 2009 : o.ecma = C;
  }
  if (e.format || e.beautify) {
    let C = e.format || e.beautify;
    o.format = typeof C == "object" ? C : {};
  }
  if (e.comments && (typeof o.format != "object" && (o.format = {}), o.format.comments = typeof e.comments == "string" ? e.comments == "fals\
e" ? !1 : e.comments : "some"), e.define) {
    typeof o.compress != "object" && (o.compress = {}), typeof o.compress.global_defs != "object" && (o.compress.global_defs = {});
    for (var l in e.define)
      o.compress.global_defs[l] = e.define[l];
  }
  e.keepClassnames && (o.keep_classnames = !0), e.keepFnames && (o.keep_fnames = !0), e.mangleProps && (e.mangleProps.domprops ? delete e.mangleProps.
  domprops : (typeof e.mangleProps != "object" && (e.mangleProps = {}), Array.isArray(e.mangleProps.reserved) || (e.mangleProps.reserved = [])),
  typeof o.mangle != "object" && (o.mangle = {}), o.mangle.properties = e.mangleProps), e.nameCache && (o.nameCache = JSON.parse(m(e.nameCache,
  "{}"))), e.output == "ast" && (o.format = {
    ast: !0,
    code: !1
  }), e.parse && (!e.parse.acorn && !e.parse.spidermonkey ? o.parse = e.parse : e.sourceMap && e.sourceMap.content == "inline" && _("ERROR: \
inline source map only works with built-in parser")), ~e.rawArgs.indexOf("--rename") ? o.rename = !0 : e.rename || (o.rename = !1);
  let c = /* @__PURE__ */ s((C) => C, "convert_path");
  typeof e.sourceMap == "object" && "base" in e.sourceMap && (c = function() {
    var C = e.sourceMap.base;
    return delete o.sourceMap.base, function(z) {
      return i.relative(C, z);
    };
  }());
  let p;
  o.files && o.files.length ? (p = o.files, delete o.files) : e.args.length && (p = e.args), p ? g(p).forEach(function(C) {
    a[c(C)] = m(C);
  }) : await new Promise((C) => {
    var z = [];
    process.stdin.setEncoding("utf8"), process.stdin.on("data", function(w) {
      z.push(w);
    }).on("end", function() {
      a = [z.join("")], C();
    }), process.stdin.resume();
  }), await y();
  function h(C) {
    return Se.from_mozilla_ast(Object.keys(a).reduce(C, null));
  }
  s(h, "convert_ast");
  async function y() {
    var C = e.sourceMap && e.sourceMap.content;
    C && C !== "inline" && (o.sourceMap.content = m(C, C)), e.timings && (o.timings = !0);
    try {
      e.parse && (e.parse.acorn ? a = h(function(j, J) {
        return (hse(), vf(pse)).parse(a[J], {
          ecmaVersion: 2018,
          locations: !0,
          program: j,
          sourceFile: J,
          sourceType: o.module || e.parse.module ? "module" : "script"
        });
      }) : e.parse.spidermonkey && (a = h(function(j, J) {
        var H = JSON.parse(a[J]);
        return j ? (j.body = j.body.concat(H.body), j) : H;
      })));
    } catch (j) {
      _(j);
    }
    let z;
    try {
      z = await ff(a, o, r);
    } catch (j) {
      if (j.name == "SyntaxError") {
        S("Parse error at " + j.filename + ":" + j.line + "," + j.col);
        var w = j.col, D = a[j.filename].split(/\r?\n/), N = D[j.line - 1];
        if (!N && !w && (N = D[j.line - 2], w = N.length), N) {
          var T = 70;
          w > T && (N = N.slice(w - T), w = T), S(N.slice(0, 80)), S(N.slice(0, w).replace(/\S/g, " ") + "^");
        }
      }
      j.defs && (S("Supported options:"), S(E(j.defs))), _(j);
      return;
    }
    if (e.output == "ast")
      !o.compress && !o.mangle && z.ast.figure_out_scope({}), console.log(JSON.stringify(z.ast, function(j, J) {
        if (J) switch (j) {
          case "thedef":
            return d(J);
          case "enclosed":
            return J.length ? J.map(d) : void 0;
          case "variables":
          case "globals":
            return J.size ? v(J, d) : void 0;
        }
        if (!n.has(j) && !(J instanceof Mu) && !(J instanceof Map)) {
          if (J instanceof Se) {
            var H = {
              _class: "AST_" + J.TYPE
            };
            return J.block_scope && (H.variables = J.block_scope.variables, H.enclosed = J.block_scope.enclosed), J.CTOR.PROPS.forEach(function(F) {
              F !== "block_scope" && (H[F] = J[F]);
            }), H;
          }
          return J;
        }
      }, 2));
    else if (e.output == "spidermonkey")
      try {
        let j = await ff(
          z.code,
          {
            compress: !1,
            mangle: !1,
            format: {
              ast: !0,
              code: !1
            }
          },
          r
        );
        console.log(JSON.stringify(j.ast.to_mozilla_ast(), null, 2));
      } catch (j) {
        _(j);
        return;
      }
    else e.output ? (r.mkdirSync(i.dirname(e.output), { recursive: !0 }), r.writeFileSync(e.output, z.code), o.sourceMap && o.sourceMap.url !==
    "inline" && z.map && r.writeFileSync(e.output + ".map", z.map)) : console.log(z.code);
    if (e.nameCache && r.writeFileSync(e.nameCache, JSON.stringify(o.nameCache)), z.timings) for (var R in z.timings)
      S("- " + R + ": " + z.timings[R].toFixed(3) + "s");
  }
  s(y, "run_cli");
  function _(C) {
    C instanceof Error && (C = C.stack.replace(/^\S*?Error:/, "ERROR:")), S(C), process.exit(1);
  }
  s(_, "fatal");
  function g(C) {
    if (Array.isArray(C))
      return [].concat.apply([], C.map(g));
    if (C && C.match(/[*?]/)) {
      var z = i.dirname(C);
      try {
        var w = r.readdirSync(z);
      } catch {
      }
      if (w) {
        var D = "^" + i.basename(C).replace(/[.+^$[\]\\(){}]/g, "\\$&").replace(/\*/g, "[^/\\\\]*").replace(/\?/g, "[^/\\\\]") + "$", N = process.
        platform === "win32" ? "i" : "", T = new RegExp(D, N), R = w.filter(function(j) {
          return T.test(j);
        }).map(function(j) {
          return i.join(z, j);
        });
        if (R.length) return R;
      }
    }
    return [C];
  }
  s(g, "simple_glob");
  function m(C, z) {
    try {
      return r.readFileSync(C, "utf8");
    } catch (w) {
      if ((w.code == "ENOENT" || w.code == "ENAMETOOLONG") && z != null) return z;
      _(w);
    }
  }
  s(m, "read_file");
  function f(C) {
    return function(z, w) {
      w = w || {};
      try {
        _r($o(z, { expression: !0 }), (D) => {
          if (D instanceof ct) {
            var N = D.left.print_to_string(), T = D.right;
            return C ? w[N] = T : T instanceof pt ? w[N] = T.elements.map(R) : T instanceof $r ? (T = T.value, w[N] = new RegExp(T.source, T.
            flags)) : w[N] = R(T), !0;
          }
          if (D instanceof gt || D instanceof je) {
            var N = D.print_to_string();
            return w[N] = !0, !0;
          }
          if (!(D instanceof Qe)) throw D;
          function R(j) {
            return j instanceof Ct ? j.getValue() : j.print_to_string({
              quote_keys: !0
            });
          }
          s(R, "to_string");
        });
      } catch {
        C ? _("Error parsing arguments for '" + C + "': " + z) : w[z] = null;
      }
      return w;
    };
  }
  s(f, "parse_js");
  function d(C) {
    var z = 1e6 + C.id + " " + C.name;
    return C.mangled_name && (z += " " + C.mangled_name), z;
  }
  s(d, "symdef");
  function v(C, z) {
    var w = [];
    return C.forEach(function(D) {
      w.push(z(D));
    }), w;
  }
  s(v, "collect_from_map");
  function E(C) {
    var z = [], w = "";
    return Object.keys(C).map(function(D) {
      return w.length < D.length && (w = Array(D.length + 1).join(" ")), [D, JSON.stringify(C[D])];
    }).forEach(function(D) {
      z.push("  " + D[0] + w.slice(D[0].length - 2) + D[1]);
    }), z.join(`
`);
  }
  s(E, "format_object");
  function S(C) {
    process.stderr.write(C), process.stderr.write(`
`);
  }
  s(S, "print_error");
  function x() {
    var C = ef({ beautify: !0 });
    function z(w) {
      C.print("AST_" + w.TYPE);
      let D = w.SELF_PROPS.filter((N) => !/^\$/.test(N));
      D.length > 0 && (C.space(), C.with_parens(function() {
        D.forEach(function(N, T) {
          T && C.space(), C.print(N);
        });
      })), w.documentation && (C.space(), C.print_string(w.documentation)), w.SUBCLASSES.length > 0 && (C.space(), C.with_block(function() {
        w.SUBCLASSES.forEach(function(N) {
          C.indent(), z(N), C.newline();
        });
      }));
    }
    return s(z, "doitem"), z(Se), C + `
`;
  }
  s(x, "describe_ast");
}
var mse = at(() => {
  fI();
  Rl();
  Di();
  QS();
  s(dse, "run_cli");
});

// ../node_modules/terser/main.js
var gse = {};
da(gse, {
  _default_options: () => cI,
  _run_cli: () => dse,
  minify: () => ff,
  minify_sync: () => xne
});
async function cI() {
  let e = {};
  return Object.keys(yse({ 0: 0 })).forEach((t) => {
    let r = yse({
      [t]: { 0: 0 }
    });
    r && (e[t] = r);
  }), e;
}
async function yse(e) {
  try {
    await ff("", e);
  } catch (t) {
    return t.defs;
  }
}
var fI = at(() => {
  jie();
  Vie();
  Yk();
  Yk();
  mse();
  s(cI, "_default_options");
  s(yse, "infer_options");
});

// ../node_modules/html-minifier-terser/src/htmlminifier.js
var Bse = b((Mse) => {
  "use strict";
  var Pse = xre(), Dse = Cre().decode, wse = ak().HTMLParser, Tht = ak().endTag, Eht = Tie(), _se = xie(), Aht = (fI(), vf(gse)), O0 = US();
  function Ws(e) {
    return e && e.replace(/^[ \n\r\t\f]+/, "").replace(/[ \n\r\t\f]+$/, "");
  }
  s(Ws, "trimWhitespace");
  function D0(e) {
    return e && e.replace(/[ \n\r\t\f\xA0]+/g, function(t) {
      return t === "	" ? "	" : t.replace(/(^|\xA0+)[^\xA0]+/g, "$1 ");
    });
  }
  s(D0, "collapseWhitespaceAll");
  function mf(e, t, r, i, n) {
    var a = "", o = "";
    return t.preserveLineBreaks && (e = e.replace(/^[ \n\r\t\f]*?[\n\r][ \n\r\t\f]*/, function() {
      return a = `
`, "";
    }).replace(/[ \n\r\t\f]*?[\n\r][ \n\r\t\f]*$/, function() {
      return o = `
`, "";
    })), r && (e = e.replace(/^[ \n\r\t\f\xA0]+/, function(u) {
      var l = !a && t.conservativeCollapse;
      return l && u === "	" ? "	" : u.replace(/^[^\xA0]+/, "").replace(/(\xA0+)[^\xA0]+/g, "$1 ") || (l ? " " : "");
    })), i && (e = e.replace(/[ \n\r\t\f\xA0]+$/, function(u) {
      var l = !o && t.conservativeCollapse;
      return l && u === "	" ? "	" : u.replace(/[^\xA0]+(\xA0+)/g, " $1").replace(/[^\xA0]+$/, "") || (l ? " " : "");
    })), n && (e = D0(e)), a + e + o;
  }
  s(mf, "collapseWhitespace");
  var vi = O0.createMapFromString, pI = vi("a,abbr,acronym,b,bdi,bdo,big,button,cite,code,del,dfn,em,font,i,ins,kbd,label,mark,math,nobr,obj\
ect,q,rp,rt,rtc,ruby,s,samp,select,small,span,strike,strong,sub,sup,svg,textarea,time,tt,u,var"), w0 = vi("a,abbr,acronym,b,big,del,em,font,\
i,ins,kbd,mark,nobr,rp,s,samp,small,span,strike,strong,sub,sup,time,tt,u,var"), bse = vi("comment,img,input,wbr");
  function vse(e, t, r, i) {
    var n = t && !bse(t);
    n && !i.collapseInlineTagWhitespace && (n = t.charAt(0) === "/" ? !pI(t.slice(1)) : !w0(t));
    var a = r && !bse(r);
    return a && !i.collapseInlineTagWhitespace && (a = r.charAt(0) === "/" ? !w0(r.slice(1)) : !pI(r)), mf(e, i, n, a, t && r);
  }
  s(vse, "collapseWhitespaceSmart");
  function xht(e) {
    return /^\[if\s[^\]]+]|\[endif]$/.test(e);
  }
  s(xht, "isConditionalComment");
  function Cht(e, t) {
    for (var r = 0, i = t.ignoreCustomComments.length; r < i; r++)
      if (t.ignoreCustomComments[r].test(e))
        return !0;
    return !1;
  }
  s(Cht, "isIgnoredComment");
  function Pht(e, t) {
    var r = t.customEventAttributes;
    if (r) {
      for (var i = r.length; i--; )
        if (r[i].test(e))
          return !0;
      return !1;
    }
    return /^on[a-z]{3,}$/.test(e);
  }
  s(Pht, "isEventAttribute");
  function Dht(e) {
    return /^[^ \t\n\f\r"'`=<>]+$/.test(e);
  }
  s(Dht, "canRemoveAttributeQuotes");
  function Sse(e, t) {
    for (var r = e.length; r--; )
      if (e[r].name.toLowerCase() === t)
        return !0;
    return !1;
  }
  s(Sse, "attributesInclude");
  function wht(e, t, r, i) {
    return r = r ? Ws(r.toLowerCase()) : "", e === "script" && t === "language" && r === "javascript" || e === "form" && t === "method" && r ===
    "get" || e === "input" && t === "type" && r === "text" || e === "script" && t === "charset" && !Sse(i, "src") || e === "a" && t === "nam\
e" && Sse(i, "id") || e === "area" && t === "shape" && r === "rect";
  }
  s(wht, "isAttributeRedundant");
  var Oht = O0.createMap([
    "text/javascript",
    "text/ecmascript",
    "text/jscript",
    "application/javascript",
    "application/x-javascript",
    "application/ecmascript",
    "module"
  ]), kht = O0.createMap([
    "module"
  ]);
  function Ose(e) {
    return e = Ws(e.split(/;/, 2)[0]).toLowerCase(), e === "" || Oht(e);
  }
  s(Ose, "isScriptTypeAttribute");
  function Iht(e) {
    return e = Ws(e.split(/;/, 2)[0]).toLowerCase(), kht(e);
  }
  s(Iht, "keepScriptTypeAttribute");
  function Rht(e, t) {
    if (e !== "script")
      return !1;
    for (var r = 0, i = t.length; r < i; r++) {
      var n = t[r].name.toLowerCase();
      if (n === "type")
        return Ose(t[r].value);
    }
    return !0;
  }
  s(Rht, "isExecutableScript");
  function kse(e) {
    return e = Ws(e).toLowerCase(), e === "" || e === "text/css";
  }
  s(kse, "isStyleLinkTypeAttribute");
  function Ise(e, t) {
    if (e !== "style")
      return !1;
    for (var r = 0, i = t.length; r < i; r++) {
      var n = t[r].name.toLowerCase();
      if (n === "type")
        return kse(t[r].value);
    }
    return !0;
  }
  s(Ise, "isStyleSheet");
  var Nht = vi("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselecte\
d,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,no\
wrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"), Lht = vi("true,false");
  function Fht(e, t) {
    return Nht(e) || e === "draggable" && !Lht(t);
  }
  s(Fht, "isBooleanAttribute");
  function Mht(e, t) {
    return /^(?:a|area|link|base)$/.test(t) && e === "href" || t === "img" && /^(?:src|longdesc|usemap)$/.test(e) || t === "object" && /^(?:classid|codebase|data|usemap)$/.
    test(e) || t === "q" && e === "cite" || t === "blockquote" && e === "cite" || (t === "ins" || t === "del") && e === "cite" || t === "for\
m" && e === "action" || t === "input" && (e === "src" || e === "usemap") || t === "head" && e === "profile" || t === "script" && (e === "src" ||
    e === "for");
  }
  s(Mht, "isUriTypeAttribute");
  function Bht(e, t) {
    return /^(?:a|area|object|button)$/.test(t) && e === "tabindex" || t === "input" && (e === "maxlength" || e === "tabindex") || t === "se\
lect" && (e === "size" || e === "tabindex") || t === "textarea" && /^(?:rows|cols|tabindex)$/.test(e) || t === "colgroup" && e === "span" ||
    t === "col" && e === "span" || (t === "th" || t === "td") && (e === "rowspan" || e === "colspan");
  }
  s(Bht, "isNumberTypeAttribute");
  function Rse(e, t, r) {
    if (e !== "link")
      return !1;
    for (var i = 0, n = t.length; i < n; i++)
      if (t[i].name === "rel" && t[i].value === r)
        return !0;
  }
  s(Rse, "isLinkType");
  function qht(e, t, r) {
    return r === "media" && (Rse(e, t, "stylesheet") || Ise(e, t));
  }
  s(qht, "isMediaQuery");
  var Uht = vi("img,source");
  function jht(e, t) {
    return e === "srcset" && Uht(t);
  }
  s(jht, "isSrcset");
  async function Vht(e, t, r, i, n) {
    if (Pht(t, i))
      return r = Ws(r).replace(/^javascript:\s*/i, ""), await i.minifyJS(r, !0);
    if (t === "class")
      return r = Ws(r), i.sortClassName ? r = i.sortClassName(r) : r = D0(r), r;
    if (Mht(t, e))
      return r = Ws(r), Rse(e, n, "canonical") ? r : i.minifyURLs(r);
    if (Bht(t, e))
      return Ws(r);
    if (t === "style")
      return r = Ws(r), r && (/;$/.test(r) && !/&#?[0-9a-zA-Z]+;$/.test(r) && (r = r.replace(/\s*;$/, ";")), r = i.minifyCSS(r, "inline")), r;
    if (jht(t, e))
      r = Ws(r).split(/\s+,\s*|\s*,\s+/).map(function(a) {
        var o = a, u = "", l = a.match(/\s+([1-9][0-9]*w|[0-9]+(?:\.[0-9]+)?x)$/);
        if (l) {
          o = o.slice(0, -l[0].length);
          var c = +l[1].slice(0, -1), p = l[1].slice(-1);
          (c !== 1 || p !== "x") && (u = " " + c + p);
        }
        return i.minifyURLs(o) + u;
      }).join(", ");
    else if (Kht(e, n) && t === "content")
      r = r.replace(/\s+/g, "").replace(/[0-9]+\.[0-9]+/g, function(a) {
        return (+a).toString();
      });
    else {
      if (Hht(e, n) && t.toLowerCase() === "content")
        return D0(r);
      if (i.customAttrCollapse && i.customAttrCollapse.test(t))
        r = Ws(r.replace(/ ?[\n\r]+ ?/g, "").replace(/\s{2,}/g, i.conservativeCollapse ? " " : ""));
      else if (e === "script" && t === "type")
        r = Ws(r.replace(/\s*;\s*/g, ";"));
      else if (qht(e, n, t))
        return r = Ws(r), i.minifyCSS(r, "media");
    }
    return r;
  }
  s(Vht, "cleanAttributeValue");
  function Kht(e, t) {
    if (e !== "meta")
      return !1;
    for (var r = 0, i = t.length; r < i; r++)
      if (t[r].name === "name" && t[r].value === "viewport")
        return !0;
  }
  s(Kht, "isMetaViewport");
  function Hht(e, t) {
    if (e !== "meta")
      return !1;
    for (var r = 0, i = t.length; r < i; r++)
      if (t[r].name.toLowerCase() === "http-equiv" && t[r].value.toLowerCase() === "content-security-policy")
        return !0;
  }
  s(Hht, "isContentSecurityPolicy");
  function Tse(e) {
    return "/* clean-css ignore:start */" + e + "/* clean-css ignore:end */";
  }
  s(Tse, "ignoreCSS");
  function Nse(e, t) {
    switch (t) {
      case "inline":
        return "*{" + e + "}";
      case "media":
        return "@media " + e + "{a{top:0}}";
      default:
        return e;
    }
  }
  s(Nse, "wrapCSS");
  function zht(e, t) {
    var r;
    switch (t) {
      case "inline":
        r = e.match(/^\*\{([\s\S]*)\}$/);
        break;
      case "media":
        r = e.match(/^@media ([\s\S]*?)\s*{[\s\S]*}$/);
        break;
    }
    return r ? r[1] : e;
  }
  s(zht, "unwrapCSS");
  async function Ght(e, t) {
    return t.processConditionalComments ? await O0.replaceAsync(e, /^(\[if\s[^\]]+]>)([\s\S]*?)(<!\[endif])$/, async function(r, i, n, a) {
      return i + await k0(n, t, !0) + a;
    }) : e;
  }
  s(Ght, "cleanConditionalComment");
  async function Wht(e, t, r) {
    for (var i = 0, n = r.length; i < n; i++)
      if (r[i].name.toLowerCase() === "type" && t.processScripts.indexOf(r[i].value) > -1)
        return await k0(e, t);
    return e;
  }
  s(Wht, "processScript");
  var $ht = vi("html,head,body,colgroup,tbody"), Xht = vi("html,head,body,li,dt,dd,p,rb,rt,rtc,rp,optgroup,option,colgroup,caption,thead,tbo\
dy,tfoot,tr,td,th"), Yht = vi("meta,link,script,style,template,noscript"), Jht = vi("dt,dd"), Qht = vi("address,article,aside,blockquote,det\
ails,div,dl,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,header,hgroup,hr,main,menu,nav,ol,p,pre,section,table,ul"), Zht = vi("a\
,audio,del,ins,map,noscript,video"), edt = vi("rb,rt,rtc,rp"), tdt = vi("rb,rtc,rp"), rdt = vi("option,optgroup"), idt = vi("tbody,tfoot"), ndt = vi(
  "thead,tbody,tfoot"), sdt = vi("td,th"), Ese = vi("html,head,body"), adt = vi("html,body"), odt = vi("head,colgroup,caption"), Ase = vi("d\
t,thead"), xse = vi("a,abbr,acronym,address,applet,area,article,aside,audio,b,base,basefont,bdi,bdo,bgsound,big,blink,blockquote,body,br,but\
ton,canvas,caption,center,cite,code,col,colgroup,command,content,data,datalist,dd,del,details,dfn,dialog,dir,div,dl,dt,element,em,embed,fiel\
dset,figcaption,figure,font,footer,form,frame,frameset,h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,i,iframe,image,img,input,ins,isindex,kbd\
,keygen,label,legend,li,link,listing,main,map,mark,marquee,menu,menuitem,meta,meter,multicol,nav,nobr,noembed,noframes,noscript,object,ol,op\
tgroup,option,output,p,param,picture,plaintext,pre,progress,q,rb,rp,rt,rtc,ruby,s,samp,script,section,select,shadow,small,source,spacer,span\
,strike,strong,style,sub,summary,sup,table,tbody,td,template,textarea,tfoot,th,thead,time,title,tr,track,tt,u,ul,var,video,wbr,xmp");
  function udt(e, t) {
    switch (e) {
      case "html":
      case "head":
        return !0;
      case "body":
        return !Yht(t);
      case "colgroup":
        return t === "col";
      case "tbody":
        return t === "tr";
    }
    return !1;
  }
  s(udt, "canRemoveParentTag");
  function ldt(e, t) {
    switch (t) {
      case "colgroup":
        return e === "colgroup";
      case "tbody":
        return ndt(e);
    }
    return !1;
  }
  s(ldt, "isStartTagMandatory");
  function cdt(e, t) {
    switch (e) {
      case "html":
      case "head":
      case "body":
      case "colgroup":
      case "caption":
        return !0;
      case "li":
      case "optgroup":
      case "tr":
        return t === e;
      case "dt":
      case "dd":
        return Jht(t);
      case "p":
        return Qht(t);
      case "rb":
      case "rt":
      case "rp":
        return edt(t);
      case "rtc":
        return tdt(t);
      case "option":
        return rdt(t);
      case "thead":
      case "tbody":
        return idt(t);
      case "tfoot":
        return t === "tbody";
      case "td":
      case "th":
        return sdt(t);
    }
    return !1;
  }
  s(cdt, "canRemovePrecedingTag");
  var fdt = new RegExp(
    "^(?:class|id|style|title|lang|dir|on(?:focus|blur|change|click|dblclick|mouse(?:down|up|over|move|out)|key(?:press|down|up)))$"
  );
  function pdt(e, t, r, i) {
    var n = !r || /^\s*$/.test(r);
    return n ? typeof i.removeEmptyAttributes == "function" ? i.removeEmptyAttributes(t, e) : e === "input" && t === "value" || fdt.test(t) :
    !1;
  }
  s(pdt, "canDeleteEmptyAttribute");
  function by(e, t) {
    for (var r = t.length - 1; r >= 0; r--)
      if (t[r].name === e)
        return !0;
    return !1;
  }
  s(by, "hasAttrName");
  function hdt(e, t) {
    switch (e) {
      case "textarea":
        return !1;
      case "audio":
      case "script":
      case "video":
        if (by("src", t))
          return !1;
        break;
      case "iframe":
        if (by("src", t) || by("srcdoc", t))
          return !1;
        break;
      case "object":
        if (by("data", t))
          return !1;
        break;
      case "applet":
        if (by("code", t))
          return !1;
        break;
    }
    return !0;
  }
  s(hdt, "canRemoveElement");
  function Lse(e) {
    return !/^(?:script|style|pre|textarea)$/.test(e);
  }
  s(Lse, "canCollapseWhitespace");
  function Fse(e) {
    return !/^(?:pre|textarea)$/.test(e);
  }
  s(Fse, "canTrimWhitespace");
  async function ddt(e, t, r, i) {
    var n = i.name(e.name), a = e.value;
    if (i.decodeEntities && a && (a = Dse(a, { isAttributeValue: !0 })), !(i.removeRedundantAttributes && wht(r, n, a, t) || i.removeScriptTypeAttributes &&
    r === "script" && n === "type" && Ose(a) && !Iht(a) || i.removeStyleLinkTypeAttributes && (r === "style" || r === "link") && n === "type" &&
    kse(a)) && (a && (a = await Vht(r, n, a, i, t)), !(i.removeEmptyAttributes && pdt(r, n, a, i))))
      return i.decodeEntities && a && (a = a.replace(/&(#?[0-9a-zA-Z]+;)/g, "&amp;$1")), {
        attr: e,
        name: n,
        value: a
      };
  }
  s(ddt, "normalizeAttr");
  function mdt(e, t, r, i, n) {
    var a = e.name, o = e.value, u = e.attr, l = u.quote, c, p;
    if (typeof o < "u" && (!r.removeAttributeQuotes || ~o.indexOf(n) || !Dht(o))) {
      if (!r.preventAttributesEscaping) {
        if (typeof r.quoteCharacter > "u") {
          var h = (o.match(/'/g) || []).length, y = (o.match(/"/g) || []).length;
          l = h < y ? "'" : '"';
        } else
          l = r.quoteCharacter === "'" ? "'" : '"';
        l === '"' ? o = o.replace(/"/g, "&#34;") : o = o.replace(/'/g, "&#39;");
      }
      p = l + o + l, !i && !r.removeTagWhitespace && (p += " ");
    } else i && !t && !/\/$/.test(o) ? p = o : p = o + " ";
    return typeof o > "u" || r.collapseBooleanAttributes && Fht(a.toLowerCase(), o.toLowerCase()) ? (c = a, i || (c += " ")) : c = a + u.customAssign +
    p, u.customOpen + c + u.customClose;
  }
  s(mdt, "buildAttr");
  function zu(e) {
    return e;
  }
  s(zu, "identity");
  function ydt(e) {
    var t = {
      name: /* @__PURE__ */ s(function(r) {
        return r.toLowerCase();
      }, "name"),
      canCollapseWhitespace: Lse,
      canTrimWhitespace: Fse,
      html5: !0,
      ignoreCustomComments: [
        /^!/,
        /^\s*#/
      ],
      ignoreCustomFragments: [
        /<%[\s\S]*?%>/,
        /<\?[\s\S]*?\?>/
      ],
      includeAutoGeneratedTags: !0,
      log: zu,
      minifyCSS: zu,
      minifyJS: zu,
      minifyURLs: zu
    };
    return Object.keys(e).forEach(function(r) {
      var i = e[r];
      if (r === "caseSensitive")
        i && (t.name = zu);
      else if (r === "log")
        typeof i == "function" && (t.log = i);
      else if (r === "minifyCSS" && typeof i != "function") {
        if (!i)
          return;
        typeof i != "object" && (i = {}), t.minifyCSS = function(n, a) {
          n = n.replace(/(url\s*\(\s*)("|'|)(.*?)\2(\s*\))/ig, function(u, l, c, p, h) {
            return l + c + t.minifyURLs(p) + c + h;
          });
          var o = new Pse(i).minify(Nse(n, a));
          return o.errors.length > 0 ? (o.errors.forEach(t.log), n) : zht(o.styles, a);
        };
      } else if (r === "minifyJS" && typeof i != "function") {
        if (!i)
          return;
        typeof i != "object" && (i = {}), (i.parse || (i.parse = {})).bare_returns = !1, t.minifyJS = async function(n, a) {
          var o = n.match(/^\s*<!--.*/), u = o ? n.slice(o[0].length).replace(/\n\s*-->\s*$/, "") : n;
          i.parse.bare_returns = a;
          try {
            return (await Aht.minify(u, i)).code.replace(/;$/, "");
          } catch (l) {
            return t.log(l), n;
          }
        };
      } else if (r === "minifyURLs" && typeof i != "function") {
        if (!i)
          return;
        typeof i == "string" ? i = { site: i } : typeof i != "object" && (i = {}), t.minifyURLs = function(n) {
          try {
            return Eht.relate(n, i);
          } catch (a) {
            return t.log(a), n;
          }
        };
      } else
        t[r] = i;
    }), t;
  }
  s(ydt, "processOptions");
  function Cse(e) {
    var t;
    do
      t = Math.random().toString(36).replace(/^0\.[0-9]*/, "");
    while (~e.indexOf(t));
    return t;
  }
  s(Cse, "uniqueId");
  var P0 = vi("script,style");
  async function gdt(e, t, r, i) {
    var n = t.sortAttributes && /* @__PURE__ */ Object.create(null), a = t.sortClassName && new _se();
    function o(g) {
      return g.map(function(m) {
        return t.name(m.name);
      });
    }
    s(o, "attrNames");
    function u(g, m) {
      return !m || g.indexOf(m) === -1;
    }
    s(u, "shouldSkipUID");
    function l(g) {
      return u(g, r) && u(g, i);
    }
    s(l, "shouldSkipUIDs");
    async function c(g) {
      var m, f;
      await new wse(g, {
        start: /* @__PURE__ */ s(function(v, E) {
          n && (n[v] || (n[v] = new _se()), n[v].add(o(E).filter(l)));
          for (var S = 0, x = E.length; S < x; S++) {
            var C = E[S];
            a && C.value && t.name(C.name) === "class" ? a.add(Ws(C.value).split(/[ \t\n\f\r]+/).filter(l)) : t.processScripts && C.name.toLowerCase() ===
            "type" && (m = v, f = C.value);
          }
        }, "start"),
        end: /* @__PURE__ */ s(function() {
          m = "";
        }, "end"),
        chars: /* @__PURE__ */ s(async function(v) {
          t.processScripts && P0(m) && t.processScripts.indexOf(f) > -1 && await c(v);
        }, "chars")
      }).parse();
    }
    s(c, "scan");
    var p = t.log;
    if (t.log = zu, t.sortAttributes = !1, t.sortClassName = !1, await c(await k0(e, t)), t.log = p, n) {
      var h = /* @__PURE__ */ Object.create(null);
      for (var y in n)
        h[y] = n[y].createSorter();
      t.sortAttributes = function(g, m) {
        var f = h[g];
        if (f) {
          var d = /* @__PURE__ */ Object.create(null), v = o(m);
          v.forEach(function(E, S) {
            (d[E] || (d[E] = [])).push(m[S]);
          }), f.sort(v).forEach(function(E, S) {
            m[S] = d[E].shift();
          });
        }
      };
    }
    if (a) {
      var _ = a.createSorter();
      t.sortClassName = function(g) {
        return _.sort(g.split(/[ \n\f\r]+/)).join(" ");
      };
    }
  }
  s(gdt, "createSortFns");
  async function k0(e, t, r) {
    t.collapseWhitespace && (e = mf(e, t, !0, !0));
    var i = [], n, a = "", o, u = "", l = [], c = [], p = [], h = "", y = "", _ = [], g = [], m, f, d;
    e = e.replace(/<!-- htmlmin:ignore -->([\s\S]*?)<!-- htmlmin:ignore -->/g, function(T, R) {
      if (!m) {
        m = Cse(e);
        var j = new RegExp("^" + m + "([0-9]+)$");
        t.ignoreCustomComments ? t.ignoreCustomComments = t.ignoreCustomComments.slice() : t.ignoreCustomComments = [], t.ignoreCustomComments.
        push(j);
      }
      var J = "<!--" + m + _.length + "-->";
      return _.push(R), J;
    });
    var v = t.ignoreCustomFragments.map(function(T) {
      return T.source;
    });
    if (v.length) {
      var E = new RegExp("\\s*(?:" + v.join("|") + ")+\\s*", "g");
      e = e.replace(E, function(T) {
        f || (f = Cse(e), d = new RegExp("(\\s*)" + f + "([0-9]+)" + f + "(\\s*)", "g"), t.minifyCSS && (t.minifyCSS = /* @__PURE__ */ function(j) {
          return function(J, H) {
            J = J.replace(d, function(re, se, de) {
              var he = g[+de];
              return he[1] + f + de + f + he[2];
            });
            var F = [];
            return new Pse().minify(Nse(J, H)).warnings.forEach(function(re) {
              var se = d.exec(re);
              if (se) {
                var de = f + se[2] + f;
                J = J.replace(de, Tse(de)), F.push(de);
              }
            }), J = j(J, H), F.forEach(function(re) {
              J = J.replace(Tse(re), re);
            }), J;
          };
        }(t.minifyCSS)), t.minifyJS && (t.minifyJS = /* @__PURE__ */ function(j) {
          return function(J, H) {
            return j(J.replace(d, function(F, re, se) {
              var de = g[+se];
              return de[1] + f + se + f + de[2];
            }), H);
          };
        }(t.minifyJS)));
        var R = f + g.length + f;
        return g.push(/^(\s*)[\s\S]*?(\s*)$/.exec(T)), "	" + R + "	";
      });
    }
    (t.sortAttributes && typeof t.sortAttributes != "function" || t.sortClassName && typeof t.sortClassName != "function") && await gdt(e, t,
    m, f);
    function S(T, R) {
      return t.canCollapseWhitespace(T, R, Lse);
    }
    s(S, "_canCollapseWhitespace");
    function x(T, R) {
      return t.canTrimWhitespace(T, R, Fse);
    }
    s(x, "_canTrimWhitespace");
    function C() {
      for (var T = i.length - 1; T > 0 && !/^<[^/!]/.test(i[T]); )
        T--;
      i.length = Math.max(0, T);
    }
    s(C, "removeStartTag");
    function z() {
      for (var T = i.length - 1; T > 0 && !/^<\//.test(i[T]); )
        T--;
      i.length = Math.max(0, T);
    }
    s(z, "removeEndTag");
    function w(T, R) {
      for (var j = null; T >= 0 && x(j); T--) {
        var J = i[T], H = J.match(/^<\/([\w:-]+)>$/);
        if (H)
          j = H[1];
        else if (/>$/.test(J) || (i[T] = vse(J, null, R, t)))
          break;
      }
    }
    s(w, "trimTrailingWhitespace");
    function D(T) {
      var R = i.length - 1;
      if (i.length > 1) {
        var j = i[i.length - 1];
        /^(?:<!|$)/.test(j) && j.indexOf(m) === -1 && R--;
      }
      w(R, T);
    }
    return s(D, "squashTrailingWhitespace"), await new wse(e, {
      partialMarkup: r,
      continueOnParseError: t.continueOnParseError,
      customAttrAssign: t.customAttrAssign,
      customAttrSurround: t.customAttrSurround,
      html5: t.html5,
      start: /* @__PURE__ */ s(async function(T, R, j, J, H) {
        T.toLowerCase() === "svg" && (t = Object.create(t), t.caseSensitive = !0, t.keepClosingSlash = !0, t.name = zu), T = t.name(T), u = T,
        n = T, w0(T) || (a = ""), o = !1, l = R;
        var F = t.removeOptionalTags;
        if (F) {
          var re = xse(T);
          re && udt(h, T) && C(), h = "", re && cdt(y, T) && (z(), F = !ldt(y, T)), y = "";
        }
        t.collapseWhitespace && (c.length || D(T), j || ((!x(T, R) || c.length) && c.push(T), (!S(T, R) || p.length) && p.push(T)));
        var se = "<" + T, de = J && t.keepClosingSlash;
        i.push(se), t.sortAttributes && t.sortAttributes(T, R);
        for (var he = [], xe = R.length, G = !0; --xe >= 0; ) {
          var ie = await ddt(R[xe], R, T, t);
          ie && (he.unshift(mdt(ie, de, t, G, f)), G = !1);
        }
        he.length > 0 ? (i.push(" "), i.push.apply(i, he)) : F && $ht(T) && (h = T), i.push(i.pop() + (de ? "/" : "") + ">"), H && !t.includeAutoGeneratedTags &&
        (C(), h = "");
      }, "start"),
      end: /* @__PURE__ */ s(function(T, R, j) {
        T.toLowerCase() === "svg" && (t = Object.getPrototypeOf(t)), T = t.name(T), t.collapseWhitespace && (c.length ? T === c[c.length - 1] &&
        c.pop() : D("/" + T), p.length && T === p[p.length - 1] && p.pop());
        var J = !1;
        T === u && (u = "", J = !o), t.removeOptionalTags && (J && Ese(h) && C(), h = "", xse(T) && y && !Ase(y) && (y !== "p" || !Zht(T)) &&
        z(), y = Xht(T) ? T : ""), t.removeEmptyElements && J && hdt(T, R) ? (C(), h = "", y = "") : (j && !t.includeAutoGeneratedTags ? y =
        "" : i.push("</" + T + ">"), n = "/" + T, pI(T) ? J && (a += "|") : a = "");
      }, "end"),
      chars: /* @__PURE__ */ s(async function(T, R, j) {
        if (R = R === "" ? "comment" : R, j = j === "" ? "comment" : j, t.decodeEntities && T && !P0(u) && (T = Dse(T)), t.collapseWhitespace) {
          if (!c.length) {
            if (R === "comment") {
              var J = i[i.length - 1];
              if (J.indexOf(m) === -1 && (J || (R = n), i.length > 1 && (!J || !t.conservativeCollapse && / $/.test(a)))) {
                var H = i.length - 2;
                i[H] = i[H].replace(/\s+$/, function(re) {
                  return T = re + T, "";
                });
              }
            }
            if (R)
              if (R === "/nobr" || R === "wbr") {
                if (/^\s/.test(T)) {
                  for (var F = i.length - 1; F > 0 && i[F].lastIndexOf("<" + R) !== 0; )
                    F--;
                  w(F - 1, "br");
                }
              } else w0(R.charAt(0) === "/" ? R.slice(1) : R) && (T = mf(T, t, /(?:^|\s)$/.test(a)));
            R || j ? T = vse(T, R, j, t) : T = mf(T, t, !0, !0), !T && /\s$/.test(a) && R && R.charAt(0) === "/" && w(i.length - 1, j);
          }
          !p.length && j !== "html" && !(R && j) && (T = mf(T, t, !1, !1, !0));
        }
        t.processScripts && P0(u) && (T = await Wht(T, t, l)), Rht(u, l) && (T = await t.minifyJS(T)), Ise(u, l) && (T = t.minifyCSS(T)), t.
        removeOptionalTags && T && ((h === "html" || h === "body" && !/^\s/.test(T)) && C(), h = "", (adt(y) || odt(y) && !/^\s/.test(T)) &&
        z(), y = ""), n = /^\s*$/.test(T) ? R : "comment", t.decodeEntities && T && !P0(u) && (T = T.replace(/&((?:Iacute|aacute|uacute|plusmn|Otilde|otilde|agrave|Agrave|Yacute|yacute|Oslash|oslash|atilde|Atilde|brvbar|ccedil|Ccedil|Ograve|curren|divide|eacute|Eacute|ograve|Oacute|egrave|Egrave|Ugrave|frac12|frac14|frac34|ugrave|oacute|iacute|Ntilde|ntilde|Uacute|middot|igrave|Igrave|iquest|Aacute|cedil|laquo|micro|iexcl|Icirc|icirc|acirc|Ucirc|Ecirc|ocirc|Ocirc|ecirc|ucirc|Aring|aring|AElig|aelig|acute|pound|raquo|Acirc|times|THORN|szlig|thorn|COPY|auml|ordf|ordm|Uuml|macr|uuml|Auml|ouml|Ouml|para|nbsp|euml|quot|QUOT|Euml|yuml|cent|sect|copy|sup1|sup2|sup3|iuml|Iuml|ETH|shy|reg|not|yen|amp|AMP|REG|uml|eth|deg|gt|GT|LT|lt)(?!;)|(?:#?[0-9a-zA-Z]+;))/g,
        "&amp$1").replace(/</g, "&lt;")), d && t.collapseWhitespace && c.length && (T = T.replace(d, function(re, se, de) {
          return g[+de][0];
        })), a += T, T && (o = !0), i.push(T);
      }, "chars"),
      comment: /* @__PURE__ */ s(async function(T, R) {
        var j = R ? "<!" : "<!--", J = R ? ">" : "-->";
        xht(T) ? T = j + await Ght(T, t) + J : t.removeComments ? Cht(T, t) ? T = "<!--" + T + "-->" : T = "" : T = j + T + J, t.removeOptionalTags &&
        T && (h = "", y = ""), i.push(T);
      }, "comment"),
      doctype: /* @__PURE__ */ s(function(T) {
        i.push(t.useShortDoctype ? "<!doctype" + (t.removeTagWhitespace ? "" : " ") + "html>" : D0(T));
      }, "doctype")
    }).parse(), t.removeOptionalTags && (Ese(h) && C(), y && !Ase(y) && z()), t.collapseWhitespace && D("br"), _dt(i, t, d ? function(T) {
      return T.replace(d, function(R, j, J, H) {
        var F = g[+J][0];
        return t.collapseWhitespace ? (j !== "	" && (F = j + F), H !== "	" && (F += H), mf(F, {
          preserveLineBreaks: t.preserveLineBreaks,
          conservativeCollapse: !t.trimCustomFragments
        }, /^[ \n\r\t\f]/.test(F), /[ \n\r\t\f]$/.test(F))) : F;
      });
    } : zu, m ? function(T) {
      return T.replace(new RegExp("<!--" + m + "([0-9]+)-->", "g"), function(R, j) {
        return _[+j];
      });
    } : zu);
  }
  s(k0, "minify");
  function _dt(e, t, r, i) {
    var n, a = t.maxLineLength, o = t.noNewlinesBeforeTagClose;
    if (a) {
      for (var u = "", l = []; e.length; ) {
        var c = u.length, p = e[0].indexOf(`
`), h = !!e[0].match(Tht), y = o && h;
        p < 0 ? u += i(r(e.shift())) : (u += i(r(e[0].slice(0, p))), e[0] = e[0].slice(p + 1)), c > 0 && u.length > a && !y ? (l.push(u.slice(
        0, c)), u = u.slice(c)) : p >= 0 && (l.push(u), u = "");
      }
      u && l.push(u), n = l.join(`
`);
    } else
      n = i(r(e.join("")));
    return t.collapseWhitespace ? mf(n, t, !0, !0) : n;
  }
  s(_dt, "joinResultSegments");
  Mse.minify = async function(e, t) {
    var r = Date.now();
    t = ydt(t || {});
    var i = await k0(e, t);
    return t.log("minified in: " + (Date.now() - r) + "ms"), i;
  };
});

// ../node_modules/html-webpack-plugin/index.js
var Hse = b((Q4t, Kse) => {
  "use strict";
  var bdt = require("util").promisify, qse = require("vm"), vdt = require("fs"), Sdt = nj(), xs = require("path"), { CachedChildCompilation: Tdt } = uj(),
  {
    createHtmlTagObject: Edt,
    htmlTagObjectToString: hI,
    HtmlTagArray: Adt
  } = cj(), I0 = hX(), Use = dX(), { AsyncSeriesWaterfallHook: gh } = eY(), jse = /* @__PURE__ */ new WeakMap(), yf = class e {
    static {
      s(this, "HtmlWebpackPlugin");
    }
    // The following is the API definition for all available hooks
    // For the TypeScript definition, see the Hooks type in typings.d.ts
    /**
     beforeAssetTagGeneration:
     AsyncSeriesWaterfallHook<{
        assets: {
          publicPath: string,
          js: Array<string>,
          css: Array<string>,
          favicon?: string | undefined,
          manifest?: string | undefined
        },
        outputName: string,
        plugin: HtmlWebpackPlugin
      }>,
     alterAssetTags:
     AsyncSeriesWaterfallHook<{
        assetTags: {
          scripts: Array<HtmlTagObject>,
          styles: Array<HtmlTagObject>,
          meta: Array<HtmlTagObject>,
        },
        publicPath: string,
        outputName: string,
        plugin: HtmlWebpackPlugin
      }>,
     alterAssetTagGroups:
     AsyncSeriesWaterfallHook<{
        headTags: Array<HtmlTagObject | HtmlTagObject>,
        bodyTags: Array<HtmlTagObject | HtmlTagObject>,
        publicPath: string,
        outputName: string,
        plugin: HtmlWebpackPlugin
      }>,
     afterTemplateExecution:
     AsyncSeriesWaterfallHook<{
        html: string,
        headTags: Array<HtmlTagObject | HtmlTagObject>,
        bodyTags: Array<HtmlTagObject | HtmlTagObject>,
        outputName: string,
        plugin: HtmlWebpackPlugin,
      }>,
     beforeEmit:
     AsyncSeriesWaterfallHook<{
        html: string,
        outputName: string,
        plugin: HtmlWebpackPlugin,
      }>,
     afterEmit:
     AsyncSeriesWaterfallHook<{
        outputName: string,
        plugin: HtmlWebpackPlugin
      }>
     */
    /**
     * Returns all public hooks of the html webpack plugin for the given compilation
     *
     * @param {Compilation} compilation
     * @returns {HtmlWebpackPluginHooks}
     */
    static getCompilationHooks(t) {
      let r = jse.get(t);
      return r || (r = {
        beforeAssetTagGeneration: new gh(["pluginArgs"]),
        alterAssetTags: new gh(["pluginArgs"]),
        alterAssetTagGroups: new gh(["pluginArgs"]),
        afterTemplateExecution: new gh(["pluginArgs"]),
        beforeEmit: new gh(["pluginArgs"]),
        afterEmit: new gh(["pluginArgs"])
      }, jse.set(t, r)), r;
    }
    /**
     * @param {HtmlWebpackOptions} [options]
     */
    constructor(t) {
      this.userOptions = t || {}, this.version = e.version;
      let r = {
        template: "auto",
        templateContent: !1,
        templateParameters: Vse,
        filename: "index.html",
        publicPath: this.userOptions.publicPath === void 0 ? "auto" : this.userOptions.publicPath,
        hash: !1,
        inject: this.userOptions.scriptLoading === "blocking" ? "body" : "head",
        scriptLoading: "defer",
        compile: !0,
        favicon: !1,
        minify: "auto",
        cache: !0,
        showErrors: !0,
        chunks: "all",
        excludeChunks: [],
        chunksSortMode: "auto",
        meta: {},
        base: !1,
        title: "Webpack App",
        xhtml: !1
      };
      this.options = Object.assign(r, this.userOptions);
    }
    /**
     *
     * @param {Compiler} compiler
     * @returns {void}
     */
    apply(t) {
      this.logger = t.getInfrastructureLogger("HtmlWebpackPlugin");
      let r = this.options;
      r.template = this.getTemplatePath(
        this.options.template,
        t.context
      ), r.scriptLoading !== "defer" && r.scriptLoading !== "blocking" && r.scriptLoading !== "module" && r.scriptLoading !== "systemjs-modu\
le" && this.logger.error(
        'The "scriptLoading" option need to be set to "defer", "blocking" or "module" or "systemjs-module"'
      ), r.inject !== !0 && r.inject !== !1 && r.inject !== "head" && r.inject !== "body" && this.logger.error(
        'The `inject` option needs to be set to true, false, "head" or "body'
      ), this.options.templateParameters !== !1 && typeof this.options.templateParameters != "function" && typeof this.options.templateParameters !=
      "object" && this.logger.error(
        "The `templateParameters` has to be either a function or an object or false"
      ), !this.userOptions.template && r.templateContent === !1 && r.meta && (r.meta = Object.assign(
        {},
        r.meta,
        {
          // TODO remove in the next major release
          // From https://developer.mozilla.org/en-US/docs/Mozilla/Mobile/Viewport_meta_tag
          viewport: "width=device-width, initial-scale=1"
        },
        this.userOptions.meta
      ));
      let i = this.userOptions.filename || this.options.filename, n = typeof i == "function" ? i : (
        // Replace '[name]' with entry name
        (u) => i.replace(/\[name\]/g, u)
      ), a = Object.keys(t.options.entry);
      new Set(
        (a.length ? a : ["main"]).map(n)
      ).forEach((u) => {
        let l = { value: void 0 }, c = [], p = new Tdt(t);
        this.options.templateContent || p.addEntry(this.options.template);
        let h = u;
        if (xs.resolve(h) === xs.normalize(h)) {
          let y = (
            /** @type {string} - Once initialized the path is always a string */
            t.options.output.path
          );
          h = xs.relative(y, h);
        }
        t.hooks.thisCompilation.tap(
          "HtmlWebpackPlugin",
          /**
           * Hook into the webpack compilation
           * @param {Compilation} compilation
           */
          (y) => {
            y.hooks.processAssets.tapAsync(
              {
                name: "HtmlWebpackPlugin",
                stage: (
                  /**
                   * Generate the html after minification and dev tooling is done
                   */
                  t.webpack.Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_INLINE
                )
              },
              /**
               * Hook into the process assets hook
               * @param {any} _
               * @param {(err?: Error) => void} callback
               */
              (_, g) => {
                this.generateHTML(
                  t,
                  y,
                  h,
                  p,
                  c,
                  l,
                  g
                );
              }
            );
          }
        );
      });
    }
    /**
     * Helper to return the absolute template path with a fallback loader
     *
     * @private
     * @param {string} template The path to the template e.g. './index.html'
     * @param {string} context The webpack base resolution path for relative paths e.g. process.cwd()
     */
    getTemplatePath(t, r) {
      return t === "auto" && (t = xs.resolve(r, "src/index.ejs"), vdt.existsSync(t) || (t = xs.join(__dirname, "default_index.ejs"))), t.indexOf(
      "!") === -1 && (t = require.resolve("./lib/loader.js") + "!" + xs.resolve(r, t)), t.replace(
        /([!])([^/\\][^!?]+|[^/\\!?])($|\?[^!?\n]+$)/,
        (i, n, a, o) => n + xs.resolve(a) + o
      );
    }
    /**
     * Return all chunks from the compilation result which match the exclude and include filters
     *
     * @private
     * @param {any} chunks
     * @param {string[]|'all'} includedChunks
     * @param {string[]} excludedChunks
     */
    filterEntryChunks(t, r, i) {
      return t.filter((n) => !(Array.isArray(r) && r.indexOf(n) === -1 || Array.isArray(i) && i.indexOf(n) !== -1));
    }
    /**
     * Helper to sort chunks
     *
     * @private
     * @param {string[]} entryNames
     * @param {string|((entryNameA: string, entryNameB: string) => number)} sortMode
     * @param {Compilation} compilation
     */
    sortEntryChunks(t, r, i) {
      if (typeof r == "function")
        return t.sort(r);
      if (typeof Use[r] < "u")
        return Use[r](t, i, this.options);
      throw new Error('"' + r + '" is not a valid chunk sort mode');
    }
    /**
     * Encode each path component using `encodeURIComponent` as files can contain characters
     * which needs special encoding in URLs like `+ `.
     *
     * Valid filesystem characters which need to be encoded for urls:
     *
     * # pound, % percent, & ampersand, { left curly bracket, } right curly bracket,
     * \ back slash, < left angle bracket, > right angle bracket, * asterisk, ? question mark,
     * blank spaces, $ dollar sign, ! exclamation point, ' single quotes, " double quotes,
     * : colon, @ at sign, + plus sign, ` backtick, | pipe, = equal sign
     *
     * However the query string must not be encoded:
     *
     *  fo:demonstration-path/very fancy+name.js?path=/home?value=abc&value=def#zzz
     *    ^             ^    ^    ^     ^    ^  ^    ^^    ^     ^   ^     ^   ^
     *    |             |    |    |     |    |  |    ||    |     |   |     |   |
     *    encoded       |    |    encoded    |  |    ||    |     |   |     |   |
     *                 ignored              ignored  ignored     ignored   ignored
     *
     * @private
     * @param {string} filePath
     */
    urlencodePath(t) {
      let r = t.indexOf("?"), i = r === -1 ? t : t.substr(0, r), n = t.substr(i.length);
      return i.split("/").map(encodeURIComponent).join("/") + n;
    }
    /**
     * Appends a cache busting hash to the query string of the url
     * E.g. http://localhost:8080/ -> http://localhost:8080/?50c9096ba6183fd728eeb065a26ec175
     *
     * @private
     * @param {string | undefined} url
     * @param {string} hash
     */
    appendHash(t, r) {
      return t && t + (t.indexOf("?") === -1 ? "?" : "&") + r;
    }
    /**
     * Generate the relative or absolute base url to reference images, css, and javascript files
     * from within the html file - the publicPath
     *
     * @private
     * @param {Compilation} compilation
     * @param {string} filename
     * @param {string | 'auto'} customPublicPath
     * @returns {string}
     */
    getPublicPath(t, r, i) {
      let n = t.getAssetPath(
        /** @type {NonNullable<Compilation["outputOptions"]["publicPath"]>} */
        t.outputOptions.publicPath,
        { hash: t.hash }
      ), o = (
        // If the html-webpack-plugin options contain a custom public path unset it
        i !== "auto" ? i : n !== "auto" ? (
          // If a hard coded public path exists use it
          n
        ) : (
          // If no public path was set get a relative url path
          xs.relative(
            xs.resolve(
              /** @type {string} */
              t.options.output.path,
              xs.dirname(r)
            ),
            /** @type {string} */
            t.options.output.path
          ).split(xs.sep).join("/")
        )
      );
      return o.length && o.substr(-1, 1) !== "/" && (o += "/"), o;
    }
    /**
     * The getAssetsForHTML extracts the asset information of a webpack compilation for all given entry names.
     *
     * @private
     * @param {Compilation} compilation
     * @param {string} outputName
     * @param {string[]} entryNames
     * @returns {AssetsInformationByGroups}
     */
    getAssetsInformationByGroups(t, r, i) {
      let n = this.getPublicPath(
        t,
        r,
        this.options.publicPath
      ), a = {
        // The public path
        publicPath: n,
        // Will contain all js and mjs files
        js: [],
        // Will contain all css files
        css: [],
        // Will contain the html5 appcache manifest files if it exists
        manifest: Object.keys(t.assets).find(
          (l) => xs.extname(l) === ".appcache"
        ),
        // Favicon
        favicon: void 0
      };
      this.options.hash && a.manifest && (a.manifest = this.appendHash(
        a.manifest,
        /** @type {string} */
        t.hash
      ));
      let o = {}, u = /\.(css|js|mjs)(\?|$)/;
      for (let l = 0; l < i.length; l++) {
        let c = i[l];
        /** @type {Entrypoint} */
        t.entrypoints.get(c).getFiles().filter((_) => {
          let g = t.getAsset(_);
          if (!g)
            return !0;
          let m = g.info || {};
          return !(m.hotModuleReplacement || m.development);
        }).map((_) => {
          let g = n + this.urlencodePath(_);
          return this.options.hash ? this.appendHash(
            g,
            /** @type {string} */
            t.hash
          ) : g;
        }).forEach((_) => {
          let g = u.exec(
            /** @type {string} */
            _
          );
          if (!g || o[_])
            return;
          o[_] = !0;
          let m = g[1] === "mjs" ? "js" : g[1];
          a[m].push(_);
        });
      }
      return a;
    }
    /**
     * Once webpack is done with compiling the template into a NodeJS code this function
     * evaluates it to generate the html result
     *
     * The evaluateCompilationResult is only a class function to allow spying during testing.
     * Please change that in a further refactoring
     *
     * @param {string} source
     * @param {string} publicPath
     * @param {string} templateFilename
     * @returns {Promise<string | (() => string | Promise<string>)>}
     */
    evaluateCompilationResult(t, r, i) {
      if (!t)
        return Promise.reject(
          new Error("The child compilation didn't provide a result")
        );
      t.indexOf("HTML_WEBPACK_PLUGIN_RESULT") >= 0 && (t += `;
HTML_WEBPACK_PLUGIN_RESULT`);
      let n = i.replace(/^.+!/, "").replace(/\?.+$/, ""), a = qse.createContext({
        ...global,
        HTML_WEBPACK_PLUGIN: !0,
        require,
        htmlWebpackPluginPublicPath: r,
        __filename: n,
        __dirname: xs.dirname(n),
        AbortController: global.AbortController,
        AbortSignal: global.AbortSignal,
        Blob: global.Blob,
        Buffer: global.Buffer,
        ByteLengthQueuingStrategy: global.ByteLengthQueuingStrategy,
        BroadcastChannel: global.BroadcastChannel,
        CompressionStream: global.CompressionStream,
        CountQueuingStrategy: global.CountQueuingStrategy,
        Crypto: global.Crypto,
        CryptoKey: global.CryptoKey,
        CustomEvent: global.CustomEvent,
        DecompressionStream: global.DecompressionStream,
        Event: global.Event,
        EventTarget: global.EventTarget,
        File: global.File,
        FormData: global.FormData,
        Headers: global.Headers,
        MessageChannel: global.MessageChannel,
        MessageEvent: global.MessageEvent,
        MessagePort: global.MessagePort,
        PerformanceEntry: global.PerformanceEntry,
        PerformanceMark: global.PerformanceMark,
        PerformanceMeasure: global.PerformanceMeasure,
        PerformanceObserver: global.PerformanceObserver,
        PerformanceObserverEntryList: global.PerformanceObserverEntryList,
        PerformanceResourceTiming: global.PerformanceResourceTiming,
        ReadableByteStreamController: global.ReadableByteStreamController,
        ReadableStream: global.ReadableStream,
        ReadableStreamBYOBReader: global.ReadableStreamBYOBReader,
        ReadableStreamBYOBRequest: global.ReadableStreamBYOBRequest,
        ReadableStreamDefaultController: global.ReadableStreamDefaultController,
        ReadableStreamDefaultReader: global.ReadableStreamDefaultReader,
        Response: global.Response,
        Request: global.Request,
        SubtleCrypto: global.SubtleCrypto,
        DOMException: global.DOMException,
        TextDecoder: global.TextDecoder,
        TextDecoderStream: global.TextDecoderStream,
        TextEncoder: global.TextEncoder,
        TextEncoderStream: global.TextEncoderStream,
        TransformStream: global.TransformStream,
        TransformStreamDefaultController: global.TransformStreamDefaultController,
        URL: global.URL,
        URLSearchParams: global.URLSearchParams,
        WebAssembly: global.WebAssembly,
        WritableStream: global.WritableStream,
        WritableStreamDefaultController: global.WritableStreamDefaultController,
        WritableStreamDefaultWriter: global.WritableStreamDefaultWriter
      }), o = new qse.Script(t, {
        filename: n
      }), u;
      try {
        u = o.runInContext(a);
      } catch (l) {
        return Promise.reject(l);
      }
      return typeof u == "object" && u.__esModule && u.default !== void 0 && (u = u.default), typeof u == "string" || typeof u == "function" ?
      Promise.resolve(u) : Promise.reject(
        new Error(
          'The loader "' + n + `" didn't return html.`
        )
      );
    }
    /**
     * Add toString methods for easier rendering inside the template
     *
     * @private
     * @param {Array<HtmlTagObject>} assetTagGroup
     * @returns {Array<HtmlTagObject>}
     */
    prepareAssetTagGroupForRendering(t) {
      let r = this.options.xhtml;
      return Adt.from(
        t.map((i) => {
          let n = Object.assign({}, i);
          return n.toString = function() {
            return hI(this, r);
          }, n;
        })
      );
    }
    /**
     * Generate the template parameters for the template function
     *
     * @private
     * @param {Compilation} compilation
     * @param {AssetsInformationByGroups} assetsInformationByGroups
     * @param {{
         headTags: HtmlTagObject[],
         bodyTags: HtmlTagObject[]
       }} assetTags
     * @returns {Promise<{[key: any]: any}>}
     */
    getTemplateParameters(t, r, i) {
      let n = this.options.templateParameters;
      if (n === !1)
        return Promise.resolve({});
      if (typeof n != "function" && typeof n != "object")
        throw new Error(
          "templateParameters has to be either a function or an object"
        );
      let a = typeof n == "function" ? (
        // A custom function can overwrite the entire template parameter preparation
        n
      ) : (
        // If the template parameters is an object merge it with the default values
        (u, l, c, p) => Object.assign(
          {},
          Vse(
            u,
            l,
            c,
            p
          ),
          n
        )
      ), o = {
        headTags: this.prepareAssetTagGroupForRendering(i.headTags),
        bodyTags: this.prepareAssetTagGroupForRendering(i.bodyTags)
      };
      return Promise.resolve().then(
        () => a(
          t,
          r,
          o,
          this.options
        )
      );
    }
    /**
     * This function renders the actual html by executing the template function
     *
     * @private
     * @param {(templateParameters) => string | Promise<string>} templateFunction
     * @param {AssetsInformationByGroups} assetsInformationByGroups
     * @param {{
         headTags: HtmlTagObject[],
         bodyTags: HtmlTagObject[]
       }} assetTags
     * @param {Compilation} compilation
     * @returns Promise<string>
     */
    executeTemplate(t, r, i, n) {
      return this.getTemplateParameters(
        n,
        r,
        i
      ).then((o) => {
        try {
          return t(o);
        } catch (u) {
          return n.errors.push(new Error("Template execution failed: " + u)), Promise.reject(u);
        }
      });
    }
    /**
     * Html Post processing
     *
     * @private
     * @param {Compiler} compiler The compiler instance
     * @param {any} originalHtml The input html
     * @param {AssetsInformationByGroups} assetsInformationByGroups
     * @param {{headTags: HtmlTagObject[], bodyTags: HtmlTagObject[]}} assetTags The asset tags to inject
     * @returns {Promise<string>}
     */
    postProcessHtml(t, r, i, n) {
      let a = r;
      if (typeof a != "string")
        return Promise.reject(
          new Error(
            "Expected html to be a string but got " + JSON.stringify(a)
          )
        );
      if (this.options.inject) {
        let c = /(<html[^>]*>)/i, p = /(<\/head\s*>)/i, h = /(<\/body\s*>)/i, y = /<meta[^>]+name=["']viewport["'][^>]*>/i, _ = n.bodyTags.map(
          (m) => hI(m, this.options.xhtml)
        ), g = n.headTags.filter((m) => !(m.tagName === "meta" && m.attributes && m.attributes.name === "viewport" && y.test(a))).map(
          (m) => hI(m, this.options.xhtml)
        );
        _.length && (h.test(a) ? a = a.replace(h, (m) => _.join("") + m) : a += _.join("")), g.length && (p.test(a) || (c.test(a) ? a = a.replace(
        c, (m) => m + "<head></head>") : a = "<head></head>" + a), a = a.replace(p, (m) => g.join("") + m)), i.manifest && (a = a.replace(/(<html[^>]*)(>)/i,
        (m, f, d) => /\smanifest\s*=/.test(m) ? m : f + ' manifest="' + i.manifest + '"' + d));
      }
      let o = t.options.mode === "production" || !t.options.mode;
      if (!(this.options.minify === !0 || typeof this.options.minify == "object" || this.options.minify === "auto" && o))
        return Promise.resolve(a);
      let l = typeof this.options.minify == "object" ? this.options.minify : {
        // https://www.npmjs.com/package/html-minifier-terser#options-quick-reference
        collapseWhitespace: !0,
        keepClosingSlash: !0,
        removeComments: !0,
        removeRedundantAttributes: !0,
        removeScriptTypeAttributes: !0,
        removeStyleLinkTypeAttributes: !0,
        useShortDoctype: !0
      };
      try {
        a = Bse().minify(a, l);
      } catch (c) {
        return String(c.message).indexOf("Parse Error") === 0 && (c.message = `html-webpack-plugin could not minify the generated output.
In production mode the html minification is enabled by default.
If you are not generating a valid html output please disable it manually.
You can do so by adding the following setting to your HtmlWebpackPlugin config:
|
|    minify: false
|
See https://github.com/jantimon/html-webpack-plugin#options for details.

For parser dedicated bugs please create an issue here:
https://danielruf.github.io/html-minifier-terser/
` + c.message), Promise.reject(c);
      }
      return Promise.resolve(a);
    }
    /**
     * Helper to return a sorted unique array of all asset files out of the asset object
     * @private
     */
    getAssetFiles(t) {
      let r = Sdt(
        Object.keys(t).filter((i) => i !== "chunks" && t[i]).reduce((i, n) => i.concat(t[n]), [])
      );
      return r.sort(), r;
    }
    /**
     * Converts a favicon file from disk to a webpack resource and returns the url to the resource
     *
     * @private
     * @param {Compiler} compiler
     * @param {string|false} favicon
     * @param {Compilation} compilation
     * @param {string} publicPath
     * @param {PreviousEmittedAssets} previousEmittedAssets
     * @returns {Promise<string|undefined>}
     */
    generateFavicon(t, r, i, n, a) {
      if (!r)
        return Promise.resolve(void 0);
      let o = xs.resolve(i.compiler.context, r);
      return bdt(i.inputFileSystem.readFile)(o).then((u) => {
        let l = new t.webpack.sources.RawSource(
          /** @type {string | Buffer} */
          u,
          !1
        ), c = xs.basename(o);
        i.fileDependencies.add(o), i.emitAsset(c, l), a.push({ name: c, source: l });
        let p = n + c;
        return this.options.hash ? this.appendHash(
          p,
          /** @type {string} */
          i.hash
        ) : p;
      }).catch(
        () => Promise.reject(
          new Error("HtmlWebpackPlugin: could not load file " + o)
        )
      );
    }
    /**
     * Generate all tags script for the given file paths
     *
     * @private
     * @param {Array<string>} jsAssets
     * @returns {Array<HtmlTagObject>}
     */
    generatedScriptTags(t) {
      return t.map((r) => {
        let i = {};
        return this.options.scriptLoading === "defer" ? i.defer = !0 : this.options.scriptLoading === "module" ? i.type = "module" : this.options.
        scriptLoading === "systemjs-module" && (i.type = "systemjs-module"), i.src = r, {
          tagName: "script",
          voidTag: !1,
          meta: { plugin: "html-webpack-plugin" },
          attributes: i
        };
      });
    }
    /**
     * Generate all style tags for the given file paths
     *
     * @private
     * @param {Array<string>} cssAssets
     * @returns {Array<HtmlTagObject>}
     */
    generateStyleTags(t) {
      return t.map((r) => ({
        tagName: "link",
        voidTag: !0,
        meta: { plugin: "html-webpack-plugin" },
        attributes: {
          href: r,
          rel: "stylesheet"
        }
      }));
    }
    /**
     * Generate an optional base tag
     *
     * @param {string | {[attributeName: string]: string}} base
     * @returns {Array<HtmlTagObject>}
     */
    generateBaseTag(t) {
      return [
        {
          tagName: "base",
          voidTag: !0,
          meta: { plugin: "html-webpack-plugin" },
          // attributes e.g. { href:"http://example.com/page.html" target:"_blank" }
          attributes: typeof t == "string" ? {
            href: t
          } : t
        }
      ];
    }
    /**
     * Generate all meta tags for the given meta configuration
     *
     * @private
     * @param {false | {[name: string]:  false | string | {[attributeName: string]: string|boolean}}} metaOptions
     * @returns {Array<HtmlTagObject>}
     */
    generatedMetaTags(t) {
      return t === !1 ? [] : Object.keys(t).map((i) => {
        let n = t[i];
        return typeof n == "string" ? {
          name: i,
          content: n
        } : n;
      }).filter((i) => i !== !1).map((i) => {
        if (i === !1)
          throw new Error("Invalid meta tag");
        return {
          tagName: "meta",
          voidTag: !0,
          meta: { plugin: "html-webpack-plugin" },
          attributes: i
        };
      });
    }
    /**
     * Generate a favicon tag for the given file path
     *
     * @private
     * @param {string} favicon
     * @returns {Array<HtmlTagObject>}
     */
    generateFaviconTag(t) {
      return [
        {
          tagName: "link",
          voidTag: !0,
          meta: { plugin: "html-webpack-plugin" },
          attributes: {
            rel: "icon",
            href: t
          }
        }
      ];
    }
    /**
     * Group assets to head and body tags
     *
     * @param {{
        scripts: Array<HtmlTagObject>;
        styles: Array<HtmlTagObject>;
        meta: Array<HtmlTagObject>;
      }} assetTags
     * @param {"body" | "head"} scriptTarget
     * @returns {{
        headTags: Array<HtmlTagObject>;
        bodyTags: Array<HtmlTagObject>;
      }}
     */
    groupAssetsByElements(t, r) {
      let i = {
        headTags: [...t.meta, ...t.styles],
        bodyTags: []
      };
      if (r === "body")
        i.bodyTags.push(...t.scripts);
      else {
        let n = this.options.scriptLoading === "blocking" ? i.headTags.length : t.meta.length;
        i.headTags.splice(n, 0, ...t.scripts);
      }
      return i;
    }
    /**
     * Replace [contenthash] in filename
     *
     * @see https://survivejs.com/webpack/optimizing/adding-hashes-to-filenames/
     *
     * @private
     * @param {Compiler} compiler
     * @param {string} filename
     * @param {string|Buffer} fileContent
     * @param {Compilation} compilation
     * @returns {{ path: string, info: {} }}
     */
    replacePlaceholdersInFilename(t, r, i, n) {
      if (/\[\\*([\w:]+)\\*\]/i.test(r) === !1)
        return { path: r, info: {} };
      let a = t.webpack.util.createHash(
        n.outputOptions.hashFunction
      );
      a.update(i), n.outputOptions.hashSalt && a.update(n.outputOptions.hashSalt);
      let o = (
        /** @type {string} */
        a.digest(n.outputOptions.hashDigest).slice(0, n.outputOptions.hashDigestLength)
      );
      return n.getPathWithInfo(r, {
        contentHash: o,
        chunk: {
          hash: o,
          // @ts-ignore
          contentHash: o
        }
      });
    }
    /**
     * Function to generate HTML file.
     *
     * @private
     * @param {Compiler} compiler
     * @param {Compilation} compilation
     * @param {string} outputName
     * @param {CachedChildCompilation} childCompilerPlugin
     * @param {PreviousEmittedAssets} previousEmittedAssets
     * @param {{ value: string | undefined }} assetJson
     * @param {(err?: Error) => void} callback
     */
    generateHTML(t, r, i, n, a, o, u) {
      let l = Array.from(r.entrypoints.keys()), c = this.filterEntryChunks(
        l,
        this.options.chunks,
        this.options.excludeChunks
      ), p = this.sortEntryChunks(
        c,
        this.options.chunksSortMode,
        r
      ), h = this.options.templateContent ? { mainCompilationHash: r.hash } : n.getCompilationEntryResult(this.options.template);
      "error" in h && r.errors.push(
        I0(h.error, t.context).toString()
      );
      let y = h.mainCompilationHash !== r.hash, _ = this.getAssetsInformationByGroups(
        r,
        i,
        p
      ), g = JSON.stringify(
        this.getAssetFiles(_)
      );
      if (y && this.options.cache && o.value === g)
        return a.forEach(({ name: x, source: C, info: z }) => {
          r.emitAsset(x, C, z);
        }), u();
      a.length = 0, o.value = g;
      let m = this.generateFavicon(
        t,
        this.options.favicon,
        r,
        _.publicPath,
        a
      ).then((x) => (_.favicon = x, e.getCompilationHooks(
        r
      ).beforeAssetTagGeneration.promise({
        assets: _,
        outputName: i,
        plugin: this
      }))), f = m.then(
        ({ assets: x }) => e.getCompilationHooks(
          r
        ).alterAssetTags.promise({
          assetTags: {
            scripts: this.generatedScriptTags(x.js),
            styles: this.generateStyleTags(x.css),
            meta: [
              ...this.options.base !== !1 ? this.generateBaseTag(this.options.base) : [],
              ...this.generatedMetaTags(this.options.meta),
              ...x.favicon ? this.generateFaviconTag(x.favicon) : []
            ]
          },
          outputName: i,
          publicPath: _.publicPath,
          plugin: this
        })
      ).then(({ assetTags: x }) => {
        let C = this.options.inject === "head" || this.options.inject !== "body" && this.options.scriptLoading !== "blocking" ? "head" : "bo\
dy", z = this.groupAssetsByElements(x, C);
        return e.getCompilationHooks(
          r
        ).alterAssetTagGroups.promise({
          headTags: z.headTags,
          bodyTags: z.bodyTags,
          outputName: i,
          publicPath: _.publicPath,
          plugin: this
        });
      }), d = Promise.resolve().then(() => {
        if ("error" in h)
          return this.options.showErrors ? I0(h.error, t.context).toHtml() : "ERROR";
        if (this.options.templateContent !== !1)
          return this.options.templateContent;
        if ("compiledEntry" in h) {
          let x = h.compiledEntry, C = x.assets;
          for (let z in C)
            a.push({
              name: z,
              source: C[z].source,
              info: C[z].info
            });
          return this.evaluateCompilationResult(
            x.content,
            _.publicPath,
            this.options.template
          );
        }
        return Promise.reject(
          new Error("Child compilation contained no compiledEntry")
        );
      }), v = Promise.all([
        m,
        f,
        d
      ]).then(
        ([x, C, z]) => typeof z != "function" ? z : this.executeTemplate(
          z,
          x.assets,
          { headTags: C.headTags, bodyTags: C.bodyTags },
          r
        )
      );
      Promise.all([
        f,
        v
      ]).then(([x, C]) => {
        let z = {
          html: C,
          headTags: x.headTags,
          bodyTags: x.bodyTags,
          plugin: this,
          outputName: i
        };
        return e.getCompilationHooks(
          r
        ).afterTemplateExecution.promise(z);
      }).then(({ html: x, headTags: C, bodyTags: z }) => this.postProcessHtml(t, x, _, {
        headTags: C,
        bodyTags: z
      })).then((x) => {
        let C = { html: x, plugin: this, outputName: i };
        return e.getCompilationHooks(r).beforeEmit.promise(C).then((z) => z.html);
      }).catch((x) => (r.errors.push(I0(x, t.context).toString()), this.options.showErrors ? I0(x, t.context).toHtml() : "ERROR")).then((x) => {
        let C = i.replace(
          /\[templatehash([^\]]*)\]/g,
          require("util").deprecate(
            (D, N) => `[contenthash${N}]`,
            "[templatehash] is now [contenthash]"
          )
        ), z = this.replacePlaceholdersInFilename(
          t,
          C,
          x,
          r
        ), w = new t.webpack.sources.RawSource(x, !1);
        return r.emitAsset(
          z.path,
          w,
          z.info
        ), a.push({ name: z.path, source: w }), z.path;
      }).then(
        (x) => e.getCompilationHooks(r).afterEmit.promise({
          outputName: x,
          plugin: this
        }).catch((C) => (this.logger.error(C), null)).then(() => null)
      ).then(() => {
        u();
      });
    }
  };
  function Vse(e, t, r, i) {
    return {
      compilation: e,
      webpackConfig: e.options,
      htmlWebpackPlugin: {
        tags: r,
        files: t,
        options: i
      }
    };
  }
  s(Vse, "templateParametersGenerator");
  yf.version = 5;
  yf.getHooks = yf.getCompilationHooks;
  yf.createHtmlTagObject = Edt;
  Kse.exports = yf;
});

// src/core-server/presets/webpack/plugins/webpack-inject-mocker-runtime-plugin.ts
var Wse = {};
da(Wse, {
  WebpackInjectMockerRuntimePlugin: () => mI
});
var zse, Gse, dI, mI, $se = at(() => {
  "use strict";
  zse = require("node:path"), Gse = require("esbuild"), dI = "WebpackInjectMockerRuntimePlugin", mI = class {
    static {
      s(this, "WebpackInjectMockerRuntimePlugin");
    }
    // We need to lazy-require HtmlWebpackPlugin because it's an optional peer dependency.
    getHtmlWebpackPlugin(t) {
      try {
        let r = t.options.plugins.find(
          (i) => i?.constructor?.name === "HtmlWebpackPlugin"
        )?.constructor;
        return r || Hse();
      } catch {
        return t.getInfrastructureLogger(dI).warn("html-webpack-plugin is not installed. Cannot inject mocker runtime."), null;
      }
    }
    /**
     * The main entry point for the Webpack plugin.
     *
     * @param {Compiler} compiler The Webpack compiler instance.
     */
    apply(t) {
      let r = this.getHtmlWebpackPlugin(t);
      r && t.hooks.compilation.tap(dI, (i) => {
        r.getHooks(i).beforeAssetTagGeneration.tapAsync(
          dI,
          (n, a) => {
            try {
              let o = require.resolve((0, zse.join)(__dirname, "..", "..", "..", "templates", "mocker-runtime.template.js")), l = (0, Gse.buildSync)(
              {
                entryPoints: [o],
                bundle: !0,
                write: !1,
                // Return the result in memory instead of writing to disk
                format: "esm",
                target: "es2020",
                external: ["msw/browser", "msw/core/http"]
              }).outputFiles[0].text, c = "mocker-runtime-injected.js";
              i.emitAsset(
                c,
                new t.webpack.sources.RawSource(l)
              ), n.assets.js.unshift(c), a(null, n);
            } catch (o) {
              a(o);
            }
          }
        );
      });
    }
  };
});

// src/core-server/presets/common-preset.ts
var $dt = {};
da($dt, {
  babel: () => wdt,
  core: () => Mdt,
  csfIndexer: () => tae,
  env: () => Rdt,
  experimental_indexers: () => qdt,
  experimental_serverAPI: () => Fdt,
  experimental_serverChannel: () => Vdt,
  favicon: () => Ddt,
  features: () => Bdt,
  frameworkOptions: () => Udt,
  logLevel: () => kdt,
  managerEntries: () => zdt,
  managerHead: () => jdt,
  previewBody: () => Ndt,
  previewHead: () => Idt,
  resolvedReact: () => Kdt,
  staticDirs: () => Pdt,
  tags: () => Hdt,
  title: () => Odt,
  typescript: () => Ldt,
  viteFinal: () => Gdt,
  webpackFinal: () => Wdt
});
module.exports = vf($dt);
var yI = require("node:fs"), Xse = require("node:fs/promises"), pa = require("node:path"), Yse = require("storybook/internal/common"), ls = require("storybook/internal/common"),
Jse = require("storybook/internal/csf-tools"), Qse = require("storybook/internal/node-logger"), Zse = require("storybook/internal/telemetry"),
eae = Gt(Gu(), 1);

// src/core-server/server-channel/create-new-story-channel.ts
var jI = require("node:fs"), VI = require("node:fs/promises"), B0 = require("node:path"), KI = require("storybook/internal/common"), Af = require("storybook/internal/core-events"),
xy = require("storybook/internal/telemetry");

// src/core-server/utils/get-new-story-file.ts
var Ah = require("node:fs"), BI = require("node:fs/promises"), Rn = require("node:path"), vo = require("storybook/internal/common"), qI = require("storybook/internal/csf-tools");

// src/csf-tools/ConfigFile.ts
var vI = require("node:fs/promises"), fe = require("storybook/internal/babel"), Ty = require("storybook/internal/node-logger"), SI = Gt(Gu(), 1);
var R0 = /* @__PURE__ */ s(({
  expectedType: e,
  foundType: t,
  node: r
}) => SI.dedent`
      CSF Parsing error: Expected '${e}' but found '${t}' instead in '${r?.type}'.
    `, "getCsfParsingErrorMessage"), Tf = /* @__PURE__ */ s((e) => fe.types.isIdentifier(e.key) ? e.key.name : fe.types.isStringLiteral(e.key) ?
e.key.value : null, "propKey"), Ey = /* @__PURE__ */ s((e) => fe.types.isTSAsExpression(e) || fe.types.isTSSatisfiesExpression(e) ? Ey(e.expression) :
e, "unwrap"), TI = /* @__PURE__ */ s((e, t) => {
  if (e.length === 0)
    return t;
  if (fe.types.isObjectExpression(t)) {
    let [r, ...i] = e, n = t.properties.find((a) => Tf(a) === r);
    if (n)
      return TI(i, n.value);
  }
}, "_getPath"), EI = /* @__PURE__ */ s((e, t) => {
  if (e.length === 0) {
    if (fe.types.isObjectExpression(t))
      return t.properties;
    throw new Error("Expected object expression");
  }
  if (fe.types.isObjectExpression(t)) {
    let [r, ...i] = e, n = t.properties.find((a) => Tf(a) === r);
    if (n)
      return i.length === 0 ? t.properties : EI(i, n.value);
  }
}, "_getPathProperties"), Ay = /* @__PURE__ */ s((e, t) => {
  let r = null, i = null;
  return t.body.find((n) => (fe.types.isVariableDeclaration(n) ? i = n.declarations : fe.types.isExportNamedDeclaration(n) && fe.types.isVariableDeclaration(
  n.declaration) && (i = n.declaration.declarations), i && i.find((a) => fe.types.isVariableDeclarator(a) && fe.types.isIdentifier(a.id) && a.
  id.name === e ? (r = a, !0) : !1))), r;
}, "_findVarDeclarator"), Sf = /* @__PURE__ */ s((e, t) => Ay(e, t)?.init, "_findVarInitialization"), Eh = /* @__PURE__ */ s((e, t) => {
  if (e.length === 0)
    return t;
  let [r, ...i] = e, n = Eh(i, t);
  return fe.types.objectExpression([fe.types.objectProperty(fe.types.identifier(r), n)]);
}, "_makeObjectExpression"), Th = /* @__PURE__ */ s((e, t, r) => {
  let [i, ...n] = e, a = r.properties.find(
    (o) => Tf(o) === i
  );
  a ? fe.types.isObjectExpression(a.value) && n.length > 0 ? Th(n, t, a.value) : a.value = Eh(n, t) : r.properties.push(
    fe.types.objectProperty(fe.types.identifier(i), Eh(n, t))
  );
}, "_updateExportNode"), N0 = class {
  constructor(t, r, i) {
    this._exports = {};
    // FIXME: this is a hack. this is only used in the case where the user is
    // modifying a named export that's a scalar. The _exports map is not suitable
    // for that. But rather than refactor the whole thing, we just use this as a stopgap.
    this._exportDecls = {};
    this.hasDefaultExport = !1;
    this._ast = t, this._code = r, this.fileName = i;
  }
  static {
    s(this, "ConfigFile");
  }
  _parseExportsObject(t) {
    this._exportsObject = t, t.properties.forEach((r) => {
      let i = Tf(r);
      if (i) {
        let n = r.value;
        fe.types.isIdentifier(n) && (n = Sf(n.name, this._ast.program)), this._exports[i] = n;
      }
    });
  }
  parse() {
    let t = this;
    return (0, fe.traverse)(this._ast, {
      ExportDefaultDeclaration: {
        enter({ node: r, parent: i }) {
          t.hasDefaultExport = !0;
          let n = fe.types.isIdentifier(r.declaration) && fe.types.isProgram(i) ? Sf(r.declaration.name, i) : r.declaration;
          n = Ey(n), fe.types.isCallExpression(n) && fe.types.isObjectExpression(n.arguments[0]) && (n = n.arguments[0]), fe.types.isObjectExpression(
          n) ? t._parseExportsObject(n) : Ty.logger.warn(
            R0({
              expectedType: "ObjectExpression",
              foundType: n?.type,
              node: n || r.declaration
            })
          );
        }
      },
      ExportNamedDeclaration: {
        enter({ node: r, parent: i }) {
          if (fe.types.isVariableDeclaration(r.declaration))
            r.declaration.declarations.forEach((n) => {
              if (fe.types.isVariableDeclarator(n) && fe.types.isIdentifier(n.id)) {
                let { name: a } = n.id, o = n.init;
                fe.types.isIdentifier(o) && (o = Sf(o.name, i)), t._exports[a] = o, t._exportDecls[a] = n;
              }
            });
          else if (fe.types.isFunctionDeclaration(r.declaration)) {
            let n = r.declaration;
            if (fe.types.isIdentifier(n.id)) {
              let { name: a } = n.id;
              t._exportDecls[a] = n;
            }
          } else r.specifiers ? r.specifiers.forEach((n) => {
            if (fe.types.isExportSpecifier(n) && fe.types.isIdentifier(n.local) && fe.types.isIdentifier(n.exported)) {
              let { name: a } = n.local, { name: o } = n.exported, u = Ay(a, i);
              u && (t._exports[o] = u.init, t._exportDecls[o] = u);
            }
          }) : Ty.logger.warn(
            R0({
              expectedType: "VariableDeclaration",
              foundType: r.declaration?.type,
              node: r.declaration
            })
          );
        }
      },
      ExpressionStatement: {
        enter({ node: r, parent: i }) {
          if (fe.types.isAssignmentExpression(r.expression) && r.expression.operator === "=") {
            let { left: n, right: a } = r.expression;
            if (fe.types.isMemberExpression(n) && fe.types.isIdentifier(n.object) && n.object.name === "module" && fe.types.isIdentifier(n.property) &&
            n.property.name === "exports") {
              let o = a;
              fe.types.isIdentifier(a) && (o = Sf(a.name, i)), o = Ey(o), fe.types.isObjectExpression(o) ? (t._exportsObject = o, o.properties.
              forEach((u) => {
                let l = Tf(u);
                if (l) {
                  let c = u.value;
                  fe.types.isIdentifier(c) && (c = Sf(
                    c.name,
                    i
                  )), t._exports[l] = c;
                }
              })) : Ty.logger.warn(
                R0({
                  expectedType: "ObjectExpression",
                  foundType: o?.type,
                  node: o
                })
              );
            }
          }
        }
      },
      CallExpression: {
        enter: /* @__PURE__ */ s(({ node: r }) => {
          fe.types.isIdentifier(r.callee) && r.callee.name === "definePreview" && r.arguments.length === 1 && fe.types.isObjectExpression(r.
          arguments[0]) && t._parseExportsObject(r.arguments[0]);
        }, "enter")
      }
    }), t;
  }
  getFieldNode(t) {
    let [r, ...i] = t, n = this._exports[r];
    if (n)
      return TI(i, n);
  }
  getFieldProperties(t) {
    let [r, ...i] = t, n = this._exports[r];
    if (n)
      return EI(i, n);
  }
  getFieldValue(t) {
    let r = this.getFieldNode(t);
    if (r) {
      let { code: i } = (0, fe.generate)(r, {});
      return (0, eval)(`(() => (${i}))()`);
    }
  }
  getSafeFieldValue(t) {
    try {
      return this.getFieldValue(t);
    } catch {
    }
  }
  setFieldNode(t, r) {
    let [i, ...n] = t, a = this._exports[i];
    if (this._exportsObject) {
      let l = this._exportsObject.properties.find((c) => Tf(c) === i);
      if (l && fe.types.isIdentifier(l.value)) {
        let c = Ay(l.value.name, this._ast.program);
        if (c && fe.types.isObjectExpression(c.init)) {
          Th(n, r, c.init);
          return;
        }
      }
      Th(t, r, this._exportsObject), this._exports[t[0]] = r;
      return;
    }
    if (a && fe.types.isObjectExpression(a) && n.length > 0) {
      Th(n, r, a);
      return;
    }
    let o = Ay(i, this._ast.program);
    if (o && fe.types.isObjectExpression(o.init)) {
      Th(n, r, o.init);
      return;
    }
    if (a && n.length === 0 && this._exportDecls[t[0]]) {
      let u = this._exportDecls[t[0]];
      fe.types.isVariableDeclarator(u) && (u.init = Eh([], r));
    } else {
      if (this.hasDefaultExport)
        throw new Error(
          `Could not set the "${t.join(
            "."
          )}" field as the default export is not an object in this file.`
        );
      {
        let u = Eh(n, r), l = fe.types.exportNamedDeclaration(
          fe.types.variableDeclaration("const", [fe.types.variableDeclarator(fe.types.identifier(i), u)])
        );
        this._exports[i] = u, this._ast.program.body.push(l);
      }
    }
  }
  /**
   * @example
   *
   * ```ts
   * // 1. { framework: 'framework-name' }
   * // 2. { framework: { name: 'framework-name', options: {} }
   * getNameFromPath(['framework']); // => 'framework-name'
   * ```
   *
   * @returns The name of a node in a given path, supporting the following formats:
   */
  getNameFromPath(t) {
    let r = this.getFieldNode(t);
    if (r)
      return this._getPresetValue(r, "name");
  }
  /**
   * Returns an array of names of a node in a given path, supporting the following formats:
   *
   * @example
   *
   * ```ts
   * const config = {
   *   addons: ['first-addon', { name: 'second-addon', options: {} }],
   * };
   * // => ['first-addon', 'second-addon']
   * getNamesFromPath(['addons']);
   * ```
   */
  getNamesFromPath(t) {
    let r = this.getFieldNode(t);
    if (!r)
      return;
    let i = [];
    return fe.types.isArrayExpression(r) && r.elements.forEach((n) => {
      i.push(this._getPresetValue(n, "name"));
    }), i;
  }
  _getPnpWrappedValue(t) {
    if (fe.types.isCallExpression(t)) {
      let r = t.arguments[0];
      if (fe.types.isStringLiteral(r))
        return r.value;
    }
  }
  /**
   * Given a node and a fallback property, returns a **non-evaluated** string value of the node.
   *
   * 1. `{ node: 'value' }`
   * 2. `{ node: { fallbackProperty: 'value' } }`
   */
  _getPresetValue(t, r) {
    let i;
    if (fe.types.isStringLiteral(t) ? i = t.value : fe.types.isObjectExpression(t) ? t.properties.forEach((n) => {
      fe.types.isObjectProperty(n) && fe.types.isIdentifier(n.key) && n.key.name === r && (fe.types.isStringLiteral(n.value) ? i = n.value.value :
      i = this._getPnpWrappedValue(n.value)), fe.types.isObjectProperty(n) && fe.types.isStringLiteral(n.key) && n.key.value === "name" && fe.types.
      isStringLiteral(n.value) && (i = n.value.value);
    }) : fe.types.isCallExpression(t) && (i = this._getPnpWrappedValue(t)), !i)
      throw new Error(
        `The given node must be a string literal or an object expression with a "${r}" property that is a string literal.`
      );
    return i;
  }
  removeField(t) {
    let r = /* @__PURE__ */ s((n, a) => {
      let o = n.findIndex(
        (u) => fe.types.isIdentifier(u.key) && u.key.name === a || fe.types.isStringLiteral(u.key) && u.key.value === a
      );
      o >= 0 && n.splice(o, 1);
    }, "removeProperty");
    if (t.length === 1) {
      let n = !1;
      if (this._ast.program.body.forEach((a) => {
        if (fe.types.isExportNamedDeclaration(a) && fe.types.isVariableDeclaration(a.declaration)) {
          let o = a.declaration.declarations[0];
          fe.types.isIdentifier(o.id) && o.id.name === t[0] && (this._ast.program.body.splice(this._ast.program.body.indexOf(a), 1), n = !0);
        }
        if (fe.types.isExportDefaultDeclaration(a)) {
          let o = a.declaration;
          if (fe.types.isIdentifier(o) && (o = Sf(o.name, this._ast.program)), o = Ey(o), fe.types.isObjectExpression(o)) {
            let u = o.properties;
            r(u, t[0]), n = !0;
          }
        }
        if (fe.types.isExpressionStatement(a) && fe.types.isAssignmentExpression(a.expression) && fe.types.isMemberExpression(a.expression.left) &&
        fe.types.isIdentifier(a.expression.left.object) && a.expression.left.object.name === "module" && fe.types.isIdentifier(a.expression.
        left.property) && a.expression.left.property.name === "exports" && fe.types.isObjectExpression(a.expression.right)) {
          let o = a.expression.right.properties;
          r(o, t[0]), n = !0;
        }
      }), n)
        return;
    }
    let i = this.getFieldProperties(t);
    if (i) {
      let n = t.at(-1);
      r(i, n);
    }
  }
  appendValueToArray(t, r) {
    let i = this.valueToNode(r);
    i && this.appendNodeToArray(t, i);
  }
  appendNodeToArray(t, r) {
    let i = this.getFieldNode(t);
    if (!i)
      this.setFieldNode(t, fe.types.arrayExpression([r]));
    else if (fe.types.isArrayExpression(i))
      i.elements.push(r);
    else
      throw new Error(`Expected array at '${t.join(".")}', got '${i.type}'`);
  }
  /**
   * Specialized helper to remove addons or other array entries that can either be strings or
   * objects with a name property.
   */
  removeEntryFromArray(t, r) {
    let i = this.getFieldNode(t);
    if (i)
      if (fe.types.isArrayExpression(i)) {
        let n = i.elements.findIndex((a) => fe.types.isStringLiteral(a) ? a.value === r : fe.types.isObjectExpression(a) ? this._getPresetValue(
        a, "name") === r : this._getPnpWrappedValue(a) === r);
        if (n >= 0)
          i.elements.splice(n, 1);
        else
          throw new Error(`Could not find '${r}' in array at '${t.join(".")}'`);
      } else
        throw new Error(`Expected array at '${t.join(".")}', got '${i.type}'`);
  }
  _inferQuotes() {
    if (!this._quotes) {
      let t = (this._ast.tokens || []).slice(0, 500).reduce(
        (r, i) => (i.type.label === "string" && (r[this._code[i.start]] += 1), r),
        { "'": 0, '"': 0 }
      );
      this._quotes = t["'"] > t['"'] ? "single" : "double";
    }
    return this._quotes;
  }
  valueToNode(t) {
    let r = this._inferQuotes(), i;
    if (r === "single") {
      let { code: n } = (0, fe.generate)(fe.types.valueToNode(t), { jsescOption: { quotes: r } }), a = (0, fe.babelParse)(`const __x = ${n}`);
      (0, fe.traverse)(a, {
        VariableDeclaration: {
          enter({ node: o }) {
            o.declarations.length === 1 && fe.types.isVariableDeclarator(o.declarations[0]) && fe.types.isIdentifier(o.declarations[0].id) &&
            o.declarations[0].id.name === "__x" && (i = o.declarations[0].init);
          }
        }
      });
    } else
      i = fe.types.valueToNode(t);
    return i;
  }
  setFieldValue(t, r) {
    let i = this.valueToNode(r);
    if (!i)
      throw new Error(`Unexpected value ${JSON.stringify(r)}`);
    this.setFieldNode(t, i);
  }
  getBodyDeclarations() {
    return this._ast.program.body;
  }
  setBodyDeclaration(t) {
    this._ast.program.body.push(t);
  }
  /**
   * Import specifiers for a specific require import
   *
   * @example
   *
   * ```ts
   * // const { foo } = require('bar');
   * setRequireImport(['foo'], 'bar');
   *
   * // const foo = require('bar');
   * setRequireImport('foo', 'bar');
   * ```
   *
   * @param importSpecifiers - The import specifiers to set. If a string is passed in, a default
   *   import will be set. Otherwise, an array of named imports will be set
   * @param fromImport - The module to import from
   */
  setRequireImport(t, r) {
    let i = this._ast.program.body.find((o) => {
      let u = fe.types.isVariableDeclaration(o) && o.declarations.length === 1 && fe.types.isVariableDeclarator(o.declarations[0]) && fe.types.
      isCallExpression(o.declarations[0].init) && fe.types.isIdentifier(o.declarations[0].init.callee) && o.declarations[0].init.callee.name ===
      "require" && fe.types.isStringLiteral(o.declarations[0].init.arguments[0]) && (o.declarations[0].init.arguments[0].value === r || o.declarations[0].
      init.arguments[0].value === r.split("node:")[1]);
      return u && (r = o.declarations[0].init.arguments[0].value), u;
    }), n = /* @__PURE__ */ s((o) => fe.types.isObjectPattern(i?.declarations[0].id) && i?.declarations[0].id.properties.find(
      (u) => fe.types.isObjectProperty(u) && fe.types.isIdentifier(u.key) && u.key.name === o
    ), "hasRequireSpecifier"), a = /* @__PURE__ */ s((o, u) => o.declarations.length === 1 && fe.types.isVariableDeclarator(o.declarations[0]) &&
    fe.types.isIdentifier(o.declarations[0].id) && o.declarations[0].id.name === u, "hasDefaultRequireSpecifier");
    if (typeof t == "string") {
      let o = /* @__PURE__ */ s(() => {
        this._ast.program.body.unshift(
          fe.types.variableDeclaration("const", [
            fe.types.variableDeclarator(
              fe.types.identifier(t),
              fe.types.callExpression(fe.types.identifier("require"), [fe.types.stringLiteral(r)])
            )
          ])
        );
      }, "addDefaultRequireSpecifier");
      i && a(i, t) || o();
    } else i ? t.forEach((o) => {
      n(o) || i.declarations[0].id.properties.push(
        fe.types.objectProperty(fe.types.identifier(o), fe.types.identifier(o), void 0, !0)
      );
    }) : this._ast.program.body.unshift(
      fe.types.variableDeclaration("const", [
        fe.types.variableDeclarator(
          fe.types.objectPattern(
            t.map(
              (o) => fe.types.objectProperty(fe.types.identifier(o), fe.types.identifier(o), void 0, !0)
            )
          ),
          fe.types.callExpression(fe.types.identifier("require"), [fe.types.stringLiteral(r)])
        )
      ])
    );
  }
  /**
   * Set import specifiers for a given import statement.
   *
   * Does not support setting type imports (yet)
   *
   * @example
   *
   * ```ts
   * // import { foo } from 'bar';
   * setImport(['foo'], 'bar');
   *
   * // import foo from 'bar';
   * setImport('foo', 'bar');
   *
   * // import * as foo from 'bar';
   * setImport({ namespace: 'foo' }, 'bar');
   *
   * // import 'bar';
   * setImport(null, 'bar');
   * ```
   *
   * @param importSpecifiers - The import specifiers to set. If a string is passed in, a default
   *   import will be set. Otherwise, an array of named imports will be set
   * @param fromImport - The module to import from
   */
  setImport(t, r) {
    let i = this._ast.program.body.find((l) => {
      let c = fe.types.isImportDeclaration(l) && (l.source.value === r || l.source.value === r.split("node:")[1]);
      return c && (r = l.source.value), c;
    }), n = /* @__PURE__ */ s((l) => fe.types.importSpecifier(fe.types.identifier(l), fe.types.identifier(l)), "getNewImportSpecifier"), a = /* @__PURE__ */ s(
    (l, c) => l.specifiers.find(
      (p) => fe.types.isImportSpecifier(p) && fe.types.isIdentifier(p.imported) && p.imported.name === c
    ), "hasImportSpecifier"), o = /* @__PURE__ */ s((l, c) => l.specifiers.find(
      (p) => fe.types.isImportNamespaceSpecifier(p) && fe.types.isIdentifier(p.local) && p.local.name === c
    ), "hasNamespaceImportSpecifier");
    t === null ? i || this._ast.program.body.unshift(fe.types.importDeclaration([], fe.types.stringLiteral(r))) : typeof t == "string" ? i ?
    (/* @__PURE__ */ s((l, c) => l.specifiers.find(
      (p) => fe.types.isImportDefaultSpecifier(p) && fe.types.isIdentifier(p.local) && p.local.name === c
    ), "hasDefaultImportSpecifier"))(i, t) || i.specifiers.push(
      fe.types.importDefaultSpecifier(fe.types.identifier(t))
    ) : this._ast.program.body.unshift(
      fe.types.importDeclaration(
        [fe.types.importDefaultSpecifier(fe.types.identifier(t))],
        fe.types.stringLiteral(r)
      )
    ) : Array.isArray(t) ? i ? t.forEach((l) => {
      a(i, l) || i.specifiers.push(n(l));
    }) : this._ast.program.body.unshift(
      fe.types.importDeclaration(
        t.map(n),
        fe.types.stringLiteral(r)
      )
    ) : t.namespace && (i ? o(i, t.namespace) || i.specifiers.push(
      fe.types.importNamespaceSpecifier(fe.types.identifier(t.namespace))
    ) : this._ast.program.body.unshift(
      fe.types.importDeclaration(
        [fe.types.importNamespaceSpecifier(fe.types.identifier(t.namespace))],
        fe.types.stringLiteral(r)
      )
    ));
  }
}, AI = /* @__PURE__ */ s((e, t) => {
  let r = (0, fe.babelParse)(e);
  return new N0(r, e, t);
}, "loadConfig");

// src/core-server/utils/new-story-templates/csf-factory-template.ts
var II = Gt(Gu(), 1);

// src/core-server/utils/get-component-variable-name.ts
var Ef = /* @__PURE__ */ s(async (e) => (await Promise.resolve().then(() => (kI(), OI))).default(e.replace(/^[^a-zA-Z_$]*/, ""), { pascalCase: !0 }).
replace(/[^a-zA-Z_$]+/, ""), "getComponentVariableName");

// src/core-server/utils/new-story-templates/csf-factory-template.ts
async function RI(e) {
  let t = e.componentIsDefaultExport ? await Ef(e.basenameWithoutExtension) : e.componentExportName, r = e.componentIsDefaultExport ? `impor\
t ${t} from './${e.basenameWithoutExtension}';` : `import { ${t} } from './${e.basenameWithoutExtension}';`;
  return II.dedent`
  ${"import preview from '#.storybook/preview';"}
  
  ${r}

  const meta = preview.meta({
    component: ${t},
  });
  
  export const ${e.exportedStoryName} = meta.story({});
  `;
}
s(RI, "getCsfFactoryTemplateForNewStoryFile");

// src/core-server/utils/new-story-templates/javascript.ts
var NI = Gt(Gu(), 1);
async function LI(e) {
  let t = e.componentIsDefaultExport ? await Ef(e.basenameWithoutExtension) : e.componentExportName, r = e.componentIsDefaultExport ? `impor\
t ${t} from './${e.basenameWithoutExtension}';` : `import { ${t} } from './${e.basenameWithoutExtension}';`;
  return NI.dedent`
  ${r}

  const meta = {
    component: ${t},
  };
  
  export default meta;
  
  export const ${e.exportedStoryName} = {};
  `;
}
s(LI, "getJavaScriptTemplateForNewStoryFile");

// src/core-server/utils/new-story-templates/typescript.ts
var FI = Gt(Gu(), 1);
async function MI(e) {
  let t = e.componentIsDefaultExport ? await Ef(e.basenameWithoutExtension) : e.componentExportName, r = e.componentIsDefaultExport ? `impor\
t ${t} from './${e.basenameWithoutExtension}'` : `import { ${t} } from './${e.basenameWithoutExtension}'`;
  return FI.dedent`
  import type { Meta, StoryObj } from '${e.frameworkPackage}';

  ${r};

  const meta = {
    component: ${t},
  } satisfies Meta<typeof ${t}>;

  export default meta;

  type Story = StoryObj<typeof meta>;

  export const ${e.exportedStoryName}: Story = {};
  `;
}
s(MI, "getTypeScriptTemplateForNewStoryFile");

// src/core-server/utils/get-new-story-file.ts
async function UI({
  componentFilePath: e,
  componentExportName: t,
  componentIsDefaultExport: r,
  componentExportCount: i
}, n) {
  let a = await (0, vo.getFrameworkName)(n), o = (0, vo.extractProperFrameworkName)(a), u = (0, Rn.basename)(e), l = (0, Rn.extname)(e), c = u.
  replace(l, ""), p = (0, Rn.dirname)(e), { storyFileName: h, isTypescript: y, storyFileExtension: _ } = F0(e), g = `${h}.${_}`, m = `${c}.${t}\
.stories.${_}`, f = "Default", d = !1;
  try {
    let S = (0, vo.findConfigFile)("preview", n.configDir);
    if (S) {
      let x = await (0, BI.readFile)(S, "utf-8");
      d = (0, qI.isCsfFactoryPreview)(AI(x));
    }
  } catch {
  }
  let v = "";
  return d ? v = await RI({
    basenameWithoutExtension: c,
    componentExportName: t,
    componentIsDefaultExport: r,
    exportedStoryName: f
  }) : v = y && a ? await MI({
    basenameWithoutExtension: c,
    componentExportName: t,
    componentIsDefaultExport: r,
    frameworkPackage: o,
    exportedStoryName: f
  }) : await LI({
    basenameWithoutExtension: c,
    componentExportName: t,
    componentIsDefaultExport: r,
    exportedStoryName: f
  }), { storyFilePath: M0((0, Rn.join)((0, vo.getProjectRoot)(), p), h) && i > 1 ? (0, Rn.join)((0, vo.getProjectRoot)(), p, m) : (0, Rn.join)(
  (0, vo.getProjectRoot)(), p, g), exportedStoryName: f, storyFileContent: v, dirname: Rn.dirname };
}
s(UI, "getNewStoryFile");
var F0 = /* @__PURE__ */ s((e) => {
  let t = /\.(ts|tsx|mts|cts)$/.test(e), r = (0, Rn.basename)(e), i = (0, Rn.extname)(e), n = r.replace(i, ""), a = t ? "tsx" : "jsx";
  return {
    storyFileName: `${n}.stories`,
    storyFileExtension: a,
    isTypescript: t
  };
}, "getStoryMetadata"), M0 = /* @__PURE__ */ s((e, t) => (0, Ah.existsSync)((0, Rn.join)(e, `${t}.ts`)) || (0, Ah.existsSync)((0, Rn.join)(e,
`${t}.tsx`)) || (0, Ah.existsSync)((0, Rn.join)(e, `${t}.js`)) || (0, Ah.existsSync)((0, Rn.join)(e, `${t}.jsx`)), "doesStoryFileExist");

// src/core-server/server-channel/create-new-story-channel.ts
function HI(e, t, r) {
  return e.on(
    Af.CREATE_NEW_STORYFILE_REQUEST,
    async (i) => {
      try {
        let { storyFilePath: n, exportedStoryName: a, storyFileContent: o } = await UI(
          i.payload,
          t
        ), u = (0, B0.relative)(process.cwd(), n), { storyId: l, kind: c } = await (0, KI.getStoryId)({ storyFilePath: n, exportedStoryName: a },
        t);
        if ((0, jI.existsSync)(n)) {
          e.emit(Af.CREATE_NEW_STORYFILE_RESPONSE, {
            success: !1,
            id: i.id,
            payload: {
              type: "STORY_FILE_EXISTS",
              kind: c
            },
            error: `A story file already exists at ${u}`
          }), r.disableTelemetry || (0, xy.telemetry)("create-new-story-file", {
            success: !1,
            error: "STORY_FILE_EXISTS"
          });
          return;
        }
        await (0, VI.writeFile)(n, o, "utf-8"), e.emit(Af.CREATE_NEW_STORYFILE_RESPONSE, {
          success: !0,
          id: i.id,
          payload: {
            storyId: l,
            storyFilePath: (0, B0.relative)(process.cwd(), n),
            exportedStoryName: a
          },
          error: null
        }), r.disableTelemetry || (0, xy.telemetry)("create-new-story-file", {
          success: !0
        });
      } catch (n) {
        e.emit(Af.CREATE_NEW_STORYFILE_RESPONSE, {
          success: !1,
          id: i.id,
          error: n?.message
        }), r.disableTelemetry || await (0, xy.telemetry)("create-new-story-file", {
          success: !1,
          error: n
        });
      }
    }
  ), e;
}
s(HI, "initCreateNewStoryChannel");

// src/core-server/server-channel/file-search-channel.ts
var IF = require("node:fs/promises"), Lf = require("node:path"), ou = require("storybook/internal/common"), Fh = require("storybook/internal/core-events"),
ug = require("storybook/internal/telemetry");

// src/core-server/utils/parser/generic-parser.ts
var Ds = require("storybook/internal/babel");
var Cy = class {
  static {
    s(this, "GenericParser");
  }
  /**
   * Parse the content of a file and return the exports
   *
   * @param content The content of the file
   * @returns The exports of the file
   */
  async parse(t) {
    let r = Ds.parser.parse(t, {
      allowImportExportEverywhere: !0,
      allowAwaitOutsideFunction: !0,
      allowNewTargetOutsideFunction: !0,
      allowReturnOutsideFunction: !0,
      allowUndeclaredExports: !0,
      plugins: [
        // Language features
        "typescript",
        "jsx",
        // Latest ECMAScript features
        "asyncGenerators",
        "bigInt",
        "classProperties",
        "classPrivateProperties",
        "classPrivateMethods",
        "classStaticBlock",
        "dynamicImport",
        "exportNamespaceFrom",
        "logicalAssignment",
        "moduleStringNames",
        "nullishCoalescingOperator",
        "numericSeparator",
        "objectRestSpread",
        "optionalCatchBinding",
        "optionalChaining",
        "privateIn",
        "regexpUnicodeSets",
        "topLevelAwait",
        // ECMAScript proposals
        "asyncDoExpressions",
        "decimal",
        "decorators",
        "decoratorAutoAccessors",
        "deferredImportEvaluation",
        "destructuringPrivate",
        "doExpressions",
        "explicitResourceManagement",
        "exportDefaultFrom",
        "functionBind",
        "functionSent",
        "importAttributes",
        "importReflection",
        "moduleBlocks",
        "partialApplication",
        "recordAndTuple",
        "sourcePhaseImports",
        "throwExpressions"
      ]
    }), i = [];
    return r.program.body.forEach(/* @__PURE__ */ s(function(a) {
      Ds.types.isExportNamedDeclaration(a) ? (Ds.types.isFunctionDeclaration(a.declaration) && Ds.types.isIdentifier(a.declaration.id) && i.
      push({
        name: a.declaration.id.name,
        default: !1
      }), Ds.types.isClassDeclaration(a.declaration) && Ds.types.isIdentifier(a.declaration.id) && i.push({
        name: a.declaration.id.name,
        default: !1
      }), a.declaration === null && a.specifiers.length > 0 && a.specifiers.forEach((o) => {
        Ds.types.isExportSpecifier(o) && Ds.types.isIdentifier(o.exported) && i.push({
          name: o.exported.name,
          default: !1
        });
      }), Ds.types.isVariableDeclaration(a.declaration) && a.declaration.declarations.forEach((o) => {
        Ds.types.isVariableDeclarator(o) && Ds.types.isIdentifier(o.id) && i.push({
          name: o.id.name,
          default: !1
        });
      })) : Ds.types.isExportDefaultDeclaration(a) && i.push({
        name: "default",
        default: !0
      });
    }, "traverse")), { exports: i };
  }
};

// src/core-server/utils/parser/index.ts
function zI(e) {
  return new Cy();
}
s(zI, "getParser");

// src/core-server/utils/search-files.ts
var ufe = ["js", "mjs", "cjs", "jsx", "mts", "ts", "tsx", "cts"], lfe = [
  "**/node_modules/**",
  "**/*.spec.*",
  "**/*.test.*",
  "**/*.stories.*",
  "**/storybook-static/**"
];
async function kF({
  searchQuery: e,
  cwd: t,
  ignoredFiles: r = lfe,
  fileExtensions: i = ufe
}) {
  let { globby: n, isDynamicPattern: a } = await Promise.resolve().then(() => (OF(), wF)), o = a(e, { cwd: t }), l = /(\.[a-z]+)$/i.test(e),
  c = `{${i.join(",")}}`, p = o ? e : l ? [`**/*${e}*`, `**/*${e}*/**`] : [
    `**/*${e}*.${c}`,
    `**/*${e}*/**/*.${c}`
  ];
  return (await n(p, {
    ignore: r,
    gitignore: !0,
    caseSensitiveMatch: !1,
    cwd: t,
    objectMode: !0
  })).map((y) => y.path).filter((y) => i.some((_) => y.endsWith(`.${_}`)));
}
s(kF, "searchFiles");

// src/core-server/server-channel/file-search-channel.ts
async function RF(e, t, r) {
  return e.on(
    Fh.FILE_COMPONENT_SEARCH_REQUEST,
    async (i) => {
      let n = i.id;
      try {
        if (!n)
          return;
        let a = await (0, ou.getFrameworkName)(t), o = await (0, ou.extractProperRendererNameFromFramework)(
          a
        ), l = (await kF({
          searchQuery: n,
          cwd: (0, ou.getProjectRoot)()
        })).map(async (c) => {
          let p = zI(o);
          try {
            let h = await (0, IF.readFile)((0, Lf.join)((0, ou.getProjectRoot)(), c), "utf-8"), { storyFileName: y } = F0((0, Lf.join)((0, ou.getProjectRoot)(),
            c)), _ = (0, Lf.dirname)(c), g = M0((0, Lf.join)((0, ou.getProjectRoot)(), _), y), m = await p.parse(h);
            return {
              filepath: c,
              exportedComponents: m.exports,
              storyFileExists: g
            };
          } catch (h) {
            return r.disableTelemetry || (0, ug.telemetry)("create-new-story-file-search", {
              success: !1,
              error: `Could not parse file: ${h}`
            }), {
              filepath: c,
              storyFileExists: !1,
              exportedComponents: null
            };
          }
        });
        r.disableTelemetry || (0, ug.telemetry)("create-new-story-file-search", {
          success: !0,
          payload: {
            fileCount: l.length
          }
        }), e.emit(Fh.FILE_COMPONENT_SEARCH_RESPONSE, {
          success: !0,
          id: n,
          payload: {
            files: await Promise.all(l)
          },
          error: null
        });
      } catch (a) {
        e.emit(Fh.FILE_COMPONENT_SEARCH_RESPONSE, {
          success: !1,
          id: n ?? "",
          error: `An error occurred while searching for components in the project.
${a?.message}`
        }), r.disableTelemetry || (0, ug.telemetry)("create-new-story-file-search", {
          success: !1,
          error: `An error occured while searching for components: ${a}`
        });
      }
    }
  ), e;
}
s(RF, "initFileSearchChannel");

// src/core-server/utils/constants.ts
var lg = require("node:path");
var NF = [
  {
    from: (0, lg.join)((0, lg.dirname)(require.resolve("storybook/internal/package.json")), "assets", "browser"),
    to: "/sb-common-assets"
  }
];

// src/core-server/utils/save-story/save-story.ts
var MF = require("node:fs/promises"), fg = require("node:path"), BF = require("storybook/internal/common"), el = require("storybook/internal/core-events"),
Mh = require("storybook/internal/csf"), pg = require("storybook/internal/csf-tools"), qF = require("storybook/internal/node-logger"), Bh = require("storybook/internal/telemetry");

// src/core-server/utils/save-story/duplicate-story-with-new-name.ts
var ba = require("storybook/internal/babel");

// src/core-server/utils/save-story/utils.ts
var _a = class extends Error {
  static {
    s(this, "SaveStoryError");
  }
};

// src/core-server/utils/save-story/duplicate-story-with-new-name.ts
var LF = /* @__PURE__ */ s((e, t, r) => {
  let i = e._storyExports[t], n = ba.types.cloneNode(i);
  if (!n)
    throw new _a("cannot clone Node");
  let a = !1;
  if ((0, ba.traverse)(n, {
    Identifier(u) {
      a || u.node.name === t && (a = !0, u.node.name = r);
    },
    ObjectProperty(u) {
      let l = u.get("key");
      l.isIdentifier() && l.node.name === "args" && u.remove();
    },
    noScope: !0
  }), !(ba.types.isCallExpression(n.init) && ba.types.isMemberExpression(n.init.callee) && ba.types.isIdentifier(n.init.callee.property) && n.
  init.callee.property.name === "story") && (ba.types.isArrowFunctionExpression(n.init) || ba.types.isCallExpression(n.init)))
    throw new _a("Creating a new story based on a CSF2 story is not supported");
  return (0, ba.traverse)(e._ast, {
    Program(u) {
      u.pushContainer(
        "body",
        ba.types.exportNamedDeclaration(ba.types.variableDeclaration("const", [n]))
      );
    }
  }), n;
}, "duplicateStoryWithNewName");

// src/core-server/utils/save-story/update-args-in-csf-file.ts
var Ir = require("storybook/internal/babel");

// src/core-server/utils/save-story/valueToAST.ts
var va = require("storybook/internal/babel");
function cg(e) {
  if (e === null)
    return va.types.nullLiteral();
  switch (typeof e) {
    case "function":
      return va.parser.parse(e.toString(), {
        allowReturnOutsideFunction: !0,
        allowSuperOutsideMethod: !0
      }).program.body[0]?.expression;
    case "number":
      return va.types.numericLiteral(e);
    case "string":
      return va.types.stringLiteral(e);
    case "boolean":
      return va.types.booleanLiteral(e);
    case "undefined":
      return va.types.identifier("undefined");
    default:
      return Array.isArray(e) ? va.types.arrayExpression(e.map(cg)) : va.types.objectExpression(
        Object.keys(e).filter((r) => typeof e[r] < "u").map((r) => {
          let i = e[r];
          return va.types.objectProperty(va.types.stringLiteral(r), cg(i));
        })
      );
  }
}
s(cg, "valueToAST");

// src/core-server/utils/save-story/update-args-in-csf-file.ts
var FF = /* @__PURE__ */ s(async (e, t) => {
  let r = !1, i = Object.fromEntries(
    Object.entries(t).map(([a, o]) => [a, cg(o)])
  );
  if (!(Ir.types.isCallExpression(e) && Ir.types.isMemberExpression(e.callee) && Ir.types.isIdentifier(e.callee.property) && e.callee.property.
  name === "story") && (Ir.types.isArrowFunctionExpression(e) || Ir.types.isCallExpression(e)))
    throw new _a("Updating a CSF2 story is not supported");
  if (Ir.types.isObjectExpression(e)) {
    let a = e.properties, o = a.find((u) => {
      if (Ir.types.isObjectProperty(u)) {
        let l = u.key;
        return Ir.types.isIdentifier(l) && l.name === "args";
      }
      return !1;
    });
    if (o) {
      if (Ir.types.isObjectProperty(o)) {
        let u = o.value;
        if (Ir.types.isObjectExpression(u)) {
          u.properties.forEach((c) => {
            if (Ir.types.isObjectProperty(c)) {
              let p = c.key;
              Ir.types.isIdentifier(p) && p.name in i && (c.value = i[p.name], delete i[p.name]);
            }
          });
          let l = Object.entries(i);
          Object.keys(i).length && l.forEach(([c, p]) => {
            u.properties.push(Ir.types.objectProperty(Ir.types.identifier(c), p));
          });
        }
      }
    } else
      a.unshift(
        Ir.types.objectProperty(
          Ir.types.identifier("args"),
          Ir.types.objectExpression(
            Object.entries(i).map(([u, l]) => Ir.types.objectProperty(Ir.types.identifier(u), l))
          )
        )
      );
    return;
  }
  (0, Ir.traverse)(e, {
    ObjectExpression(a) {
      if (r)
        return;
      r = !0;
      let u = a.get("properties").find((l) => {
        if (l.isObjectProperty()) {
          let c = l.get("key");
          return c.isIdentifier() && c.node.name === "args";
        }
        return !1;
      });
      if (u) {
        if (u.isObjectProperty()) {
          let l = u.get("value");
          if (l.isObjectExpression()) {
            l.traverse({
              ObjectProperty(p) {
                let h = p.get("key");
                h.isIdentifier() && h.node.name in i && (p.get("value").replaceWith(i[h.node.name]), delete i[h.node.name]);
              },
              noScope: !0
            });
            let c = Object.entries(i);
            Object.keys(i).length && c.forEach(([p, h]) => {
              l.pushContainer("properties", Ir.types.objectProperty(Ir.types.identifier(p), h));
            });
          }
        }
      } else
        a.unshiftContainer(
          "properties",
          Ir.types.objectProperty(
            Ir.types.identifier("args"),
            Ir.types.objectExpression(
              Object.entries(i).map(([l, c]) => Ir.types.objectProperty(Ir.types.identifier(l), c))
            )
          )
        );
    },
    noScope: !0
  });
}, "updateArgsInCsfFile");

// src/core-server/utils/save-story/save-story.ts
var cfe = /* @__PURE__ */ s((e) => JSON.parse(e, (t, r) => r === "__sb_empty_function_arg__" ? () => {
} : r), "parseArgs"), ffe = /* @__PURE__ */ s((e, t) => {
  let r = "([\\s\\S])", i = "(\\r\\n|\\r|\\n)", n = i + "};" + i, a = new RegExp(
    // Looks for an export by the given name, considers the first closing brace on its own line
    // to be the end of the story definition.
    `^(?<before>${r}*)(?<story>export const ${t} =${r}+?${n})(?<after>${r}*)$`
  ), { before: o, story: u, after: l } = e.match(a)?.groups || {};
  return u ? o + u.replaceAll(/(\r\n|\r|\n)(\r\n|\r|\n)([ \t]*[a-z0-9_]+): /gi, "$2$3:") + l : e;
}, "removeExtraNewlines");
function UF(e, t, r) {
  e.on(el.SAVE_STORY_REQUEST, async ({ id: i, payload: n }) => {
    let { csfId: a, importPath: o, args: u, name: l } = n, c, p, h, y, _;
    try {
      h = (0, fg.basename)(o), y = (0, fg.join)(process.cwd(), o);
      let g = await (0, pg.readCsf)(y, {
        makeTitle: /* @__PURE__ */ s((C) => C || "myTitle", "makeTitle")
      }), m = g.parse(), f = Object.entries(m._stories), [d, v] = a.split("--");
      p = l && (0, Mh.storyNameFromExport)(l), c = p && (0, Mh.toId)(d, p);
      let [E] = f.find(([C, z]) => z.id.endsWith(`--${v}`)) || [];
      if (!E)
        throw new _a("Source story not found.");
      if (l && g.getStoryExport(l))
        throw new _a("Story already exists.");
      _ = (0, Mh.storyNameFromExport)(E), await FF(
        l ? LF(m, E, l) : g.getStoryExport(E),
        u ? cfe(u) : {}
      );
      let S = await (0, BF.formatFileContent)(
        y,
        ffe((0, pg.printCsf)(g).code, l || E)
      );
      await Promise.all([
        new Promise((C) => {
          e.on(el.STORY_RENDERED, C), setTimeout(() => C(e.off(el.STORY_RENDERED, C)), 3e3);
        }),
        (0, MF.writeFile)(y, S)
      ]), e.emit(el.SAVE_STORY_RESPONSE, {
        id: i,
        success: !0,
        payload: {
          csfId: a,
          newStoryId: c,
          newStoryName: p,
          newStoryExportName: l,
          sourceFileContent: S,
          sourceFileName: h,
          sourceStoryName: _,
          sourceStoryExportName: E
        },
        error: null
      });
      let x = (0, Bh.isExampleStoryId)(c ?? a);
      !r.disableTelemetry && !x && await (0, Bh.telemetry)("save-story", {
        action: l ? "createStory" : "updateStory",
        success: !0
      });
    } catch (g) {
      e.emit(el.SAVE_STORY_RESPONSE, {
        id: i,
        success: !1,
        error: g instanceof _a ? g.message : "Unknown error"
      }), qF.logger.error(
        `Error writing to ${y}:
${g.stack || g.message || g.toString()}`
      ), !r.disableTelemetry && !(g instanceof _a) && await (0, Bh.telemetry)("save-story", {
        action: l ? "createStory" : "updateStory",
        success: !1,
        error: g
      });
    }
  });
}
s(UF, "initializeSaveStory");

// src/core-server/utils/server-statics.ts
var yg = require("node:fs"), iM = require("node:fs/promises"), Wn = require("node:path"), WE = require("storybook/internal/common"), nM = require("storybook/internal/node-logger"),
sM = Gt(KF(), 1), Ofe = Gt(rM(), 1), aM = Gt(Gu(), 1);
var fbt = (0, WE.resolvePathInStorybookCache)("", "ignored-sub").split("ignored-sub")[0];
var pbt = (0, Wn.join)(
  (0, Wn.dirname)(require.resolve("storybook/internal/package.json")),
  "/assets/browser/favicon-wrapper.svg"
);
var oM = /* @__PURE__ */ s((e) => {
  let t = e.lastIndexOf(":"), i = Wn.win32.isAbsolute(e) && t === 1, n = t !== -1 && !i ? t : e.length, [a, o] = [e.slice(0, n), e.slice(n +
  1)], u = (0, Wn.isAbsolute)(a) ? a : `./${a}`, l = (0, Wn.resolve)(u);
  if (!(0, yg.existsSync)(l))
    throw new Error(
      aM.dedent`
        Failed to load static files, no such directory: ${sM.default.cyan(l)}
        Make sure this directory exists.
      `
    );
  let h = (o || ((0, yg.statSync)(l).isFile() ? (0, Wn.basename)(l) : "/")).split(Wn.sep).join(Wn.posix.sep).replace(/^\/?/, "./"), y = h.substring(
  1);
  return { staticDir: u, staticPath: l, targetDir: h, targetEndpoint: y };
}, "parseStaticDir");

// src/core-server/utils/whats-new.ts
var qq = require("node:fs/promises"), Rg = require("storybook/internal/common"), Ha = require("storybook/internal/core-events"), Ng = require("storybook/internal/csf-tools"),
lx = require("storybook/internal/node-logger"), Uq = require("storybook/internal/telemetry");

// ../node_modules/tiny-invariant/dist/esm/tiny-invariant.js
var kfe = process.env.NODE_ENV === "production", $E = "Invariant failed";
function XE(e, t) {
  if (!e) {
    if (kfe)
      throw new Error($E);
    var r = typeof t == "function" ? t() : t, i = r ? "".concat($E, ": ").concat(r) : $E;
    throw new Error(i);
  }
}
s(XE, "invariant");

// src/core-server/withTelemetry.ts
var mu = require("storybook/internal/common"), Fde = require("storybook/internal/node-logger"), jf = require("storybook/internal/telemetry"),
Bq = Gt(Mq(), 1);
var Mde = /* @__PURE__ */ s(async () => {
  if ((0, mu.isCI)() || !process.stdout.isTTY)
    return;
  let { enableCrashReports: e } = await (0, Bq.default)({
    type: "confirm",
    name: "enableCrashReports",
    message: "Would you like to help improve Storybook by sending anonymous crash reports?",
    initial: !0
  });
  return await mu.cache.set("enableCrashReports", e), e;
}, "promptCrashReports");
async function Bde({
  cliOptions: e,
  presetOptions: t,
  skipPrompt: r
}) {
  if (e.disableTelemetry)
    return "none";
  if (!t)
    return "full";
  let n = await (await (0, mu.loadAllPresets)(t)).apply("core");
  if (n?.enableCrashReports !== void 0)
    return n.enableCrashReports ? "full" : "error";
  if (n?.disableTelemetry)
    return "none";
  let a = await mu.cache.get("enableCrashReports") ?? await mu.cache.get("enableCrashreports");
  if (a !== void 0)
    return a ? "full" : "error";
  if (r)
    return "error";
  let o = await Mde();
  return o !== void 0 ? o ? "full" : "error" : "full";
}
s(Bde, "getErrorLevel");
async function ox(e, t, r) {
  try {
    let i = "error";
    try {
      i = await Bde(r);
    } catch {
    }
    if (i !== "none") {
      let n = await (0, jf.getPrecedingUpgrade)(), a = e, o;
      "message" in a ? o = a.message ? (0, jf.oneWayHash)(a.message) : "EMPTY_MESSAGE" : o = "NO_MESSAGE";
      let { code: u, name: l, category: c } = a;
      await (0, jf.telemetry)(
        "error",
        {
          code: u,
          name: l,
          category: c,
          eventType: t,
          precedingUpgrade: n,
          error: i === "full" ? a : void 0,
          errorHash: o,
          // if we ever end up sending a non-error instance, we'd like to know
          isErrorInstance: a instanceof Error
        },
        {
          immediate: !0,
          configDir: r.cliOptions.configDir || r.presetOptions?.configDir,
          enableCrashReports: i === "full"
        }
      );
    }
  } catch {
  }
}
s(ox, "sendTelemetryError");

// src/core-server/utils/whats-new.ts
var ux = "whats-new-cache", qde = "https://storybook.js.org/whats-new/v1";
function jq(e, t, r) {
  e.on(Ha.SET_WHATS_NEW_CACHE, async (i) => {
    let n = await t.cache.get(ux).catch((a) => (lx.logger.verbose(a), {}));
    await t.cache.set(ux, { ...n, ...i });
  }), e.on(Ha.REQUEST_WHATS_NEW_DATA, async () => {
    try {
      let i = await fetch(qde).then(async (l) => {
        if (l.ok)
          return l.json();
        throw l;
      }), a = (await (0, Rg.loadMainConfig)({ configDir: t.configDir, noCache: !0 })).core?.disableWhatsNewNotifications === !0, o = await t.
      cache.get(ux) ?? {}, u = {
        ...i,
        status: "SUCCESS",
        postIsRead: i.url === o.lastReadPost,
        showNotification: i.url !== o.lastDismissedPost && i.url !== o.lastReadPost,
        disableWhatsNewNotifications: a
      };
      e.emit(Ha.RESULT_WHATS_NEW_DATA, { data: u });
    } catch (i) {
      lx.logger.verbose(i instanceof Error ? i.message : String(i)), e.emit(Ha.RESULT_WHATS_NEW_DATA, {
        data: { status: "ERROR" }
      });
    }
  }), e.on(
    Ha.TOGGLE_WHATS_NEW_NOTIFICATIONS,
    async ({ disableWhatsNewNotifications: i }) => {
      let n = r.disableTelemetry !== !0;
      try {
        let a = (0, Rg.findConfigFile)("main", t.configDir);
        XE(a, `unable to find Storybook main file in ${t.configDir}`);
        let o = await (0, Ng.readConfig)(a);
        if (!o._exportsObject)
          throw new Error(
            "Unable to parse Storybook main file while trying to read 'core' property"
          );
        o.setFieldValue(["core", "disableWhatsNewNotifications"], i), await (0, qq.writeFile)(a, (0, Ng.printConfig)(o).code), n && await (0, Uq.telemetry)(
        "core-config", { disableWhatsNewNotifications: i });
      } catch (a) {
        XE(a instanceof Error), n && await ox(a, "core-config", {
          cliOptions: t,
          presetOptions: { ...t, corePresets: [], overridePresets: [] },
          skipPrompt: !0
        });
      }
    }
  ), e.on(Ha.TELEMETRY_ERROR, async (i) => {
    r.disableTelemetry !== !0 && await ox(i, "browser", {
      cliOptions: t,
      presetOptions: { ...t, corePresets: [], overridePresets: [] },
      skipPrompt: !0
    });
  });
}
s(jq, "initializeWhatsNew");

// src/core-server/presets/common-preset.ts
var xdt = /* @__PURE__ */ s((e, t = {}) => Object.entries(t).reduce((r, [i, n]) => r.replace(new RegExp(`%${i}%`, "g"), n), e), "interpolate"),
Cdt = (0, pa.join)(
  (0, pa.dirname)(require.resolve("storybook/internal/package.json")),
  "/assets/browser/favicon.svg"
), Pdt = /* @__PURE__ */ s(async (e = []) => [
  ...NF,
  ...e
], "staticDirs"), Ddt = /* @__PURE__ */ s(async (e, t) => {
  if (e)
    return e;
  let r = await t.presets.apply("staticDirs"), n = (r ? r.map((a) => typeof a == "string" ? a : `${a.from}:${a.to}`) : []).map((a) => {
    let o = [], u = r && !(0, pa.isAbsolute)(a) ? (0, ls.getDirectoryFromWorkingDir)({
      configDir: t.configDir,
      workingDir: process.cwd(),
      directory: a
    }) : a, { staticPath: l, targetEndpoint: c } = oM(u);
    return ["/favicon.svg", "/favicon.ico"].includes(c) && o.push(l), c === "/" && (o.push((0, pa.join)(l, "favicon.svg")), o.push((0, pa.join)(
    l, "favicon.ico"))), o.filter((p) => (0, yI.existsSync)(p));
  }).reduce((a, o) => a.concat(o), []);
  return n.length > 1 && Qse.logger.warn(eae.dedent`
      Looks like multiple favicons were detected. Using the first one.

      ${n.join(", ")}
    `), n[0] || Cdt;
}, "favicon"), wdt = /* @__PURE__ */ s(async (e, t) => {
  let { presets: r } = t, i = await r.apply("babelDefault", {}, t) ?? {};
  return {
    ...i,
    // This override makes sure that we will never transpile babel further down then the browsers that storybook supports.
    // This is needed to support the mount property of the context described here:
    // https://storybook.js.org/docs/writing-tests/interaction-testing#run-code-before-each-test
    overrides: [
      ...i?.overrides ?? [],
      {
        include: /\.(story|stories)\.[cm]?[jt]sx?$/,
        presets: [
          [
            "@babel/preset-env",
            {
              bugfixes: !0,
              targets: {
                // This is the same browser supports that we use to bundle our manager and preview code.
                chrome: 100,
                safari: 15,
                firefox: 91
              }
            }
          ]
        ]
      }
    ]
  };
}, "babel"), Odt = /* @__PURE__ */ s((e, t) => e || t.packageJson?.name || !1, "title"), kdt = /* @__PURE__ */ s((e, t) => e || t.loglevel ||
"info", "logLevel"), Idt = /* @__PURE__ */ s(async (e, { configDir: t, presets: r }) => {
  let i = await r.apply("env");
  return (0, ls.getPreviewHeadTemplate)(t, i);
}, "previewHead"), Rdt = /* @__PURE__ */ s(async () => {
  let { raw: e } = await (0, ls.loadEnvs)({ production: !0 });
  return e;
}, "env"), Ndt = /* @__PURE__ */ s(async (e, { configDir: t, presets: r }) => {
  let i = await r.apply("env");
  return (0, ls.getPreviewBodyTemplate)(t, i);
}, "previewBody"), Ldt = /* @__PURE__ */ s(() => ({
  check: !1,
  // 'react-docgen' faster than `react-docgen-typescript` but produces lower quality results
  reactDocgen: "react-docgen",
  reactDocgenTypescriptOptions: {
    shouldExtractLiteralValuesFromEnum: !0,
    shouldRemoveUndefinedFromOptional: !0,
    propFilter: /* @__PURE__ */ s((e) => e.parent ? !/node_modules/.test(e.parent.fileName) : !0, "propFilter"),
    // NOTE: this default cannot be changed
    savePropValueAsString: !0
  }
}), "typescript"), Fdt = /* @__PURE__ */ s((e, t) => {
  let r = ls.removeAddon, i = ls.JsPackageManagerFactory.getPackageManager({
    configDir: t.configDir
  });
  return t.disableTelemetry || (r = /* @__PURE__ */ s(async (n, a) => (await (0, Zse.telemetry)("remove", { addon: n, source: "api" }), (0, ls.removeAddon)(
  n, { ...a, packageManager: i })), "removeAddon")), { ...e, removeAddon: r };
}, "experimental_serverAPI"), Mdt = /* @__PURE__ */ s(async (e, t) => ({
  ...e,
  disableTelemetry: t.disableTelemetry === !0,
  enableCrashReports: t.enableCrashReports || (0, Yse.optionalEnvToBoolean)(process.env.STORYBOOK_ENABLE_CRASH_REPORTS)
}), "core"), Bdt = /* @__PURE__ */ s(async (e) => ({
  ...e,
  argTypeTargetsV7: !0,
  legacyDecoratorFileOrder: !1,
  disallowImplicitActionsInRenderV8: !0,
  viewport: !0,
  highlight: !0,
  controls: !0,
  interactions: !0,
  actions: !0,
  backgrounds: !0,
  outline: !0,
  measure: !0
}), "features"), tae = {
  test: /(stories|story)\.(m?js|ts)x?$/,
  createIndex: /* @__PURE__ */ s(async (e, t) => (await (0, Jse.readCsf)(e, t)).parse().indexInputs, "createIndex")
}, qdt = /* @__PURE__ */ s((e) => [tae].concat(e || []), "experimental_indexers"), Udt = /* @__PURE__ */ s(async (e, t) => {
  let r = await t.presets.apply("framework");
  return typeof r == "string" ? {} : typeof r > "u" ? null : r.options;
}, "frameworkOptions"), jdt = /* @__PURE__ */ s(async (e, t) => {
  let r = (0, pa.join)(t.configDir, "manager-head.html");
  if ((0, yI.existsSync)(r)) {
    let i = (0, Xse.readFile)(r, { encoding: "utf8" }), n = t.presets.apply("env");
    return xdt(await i, await n);
  }
  return "";
}, "managerHead"), Vdt = /* @__PURE__ */ s(async (e, t) => {
  let r = await t.presets.apply("core");
  return jq(e, t, r), UF(e, t, r), RF(e, t, r), HI(e, t, r), e;
}, "experimental_serverChannel"), Kdt = /* @__PURE__ */ s(async (e) => {
  try {
    return {
      ...e,
      react: (0, pa.dirname)(require.resolve("react/package.json")),
      reactDom: (0, pa.dirname)(require.resolve("react-dom/package.json"))
    };
  } catch {
    return e;
  }
}, "resolvedReact"), Hdt = /* @__PURE__ */ s(async (e) => ({
  ...e,
  "dev-only": { excludeFromDocsStories: !0 },
  "docs-only": { excludeFromSidebar: !0 },
  "test-only": { excludeFromSidebar: !0, excludeFromDocsStories: !0 }
}), "tags"), zdt = /* @__PURE__ */ s(async (e) => [
  (0, pa.join)(
    (0, pa.dirname)(require.resolve("storybook/internal/package.json")),
    "dist/core-server/presets/common-manager.js"
  ),
  ...e || []
], "managerEntries"), Gdt = /* @__PURE__ */ s(async (e, t) => {
  let r = (0, ls.findConfigFile)("preview", t.configDir);
  if (!r)
    return e;
  let { viteInjectMockerRuntime: i } = await Promise.resolve().then(() => (Gq(), zq)), { viteMockPlugin: n } = await Promise.resolve().then(() => (p6(), f6)),
  a = await t.presets.apply("core");
  return {
    ...e,
    plugins: [
      ...e.plugins ?? [],
      ...r ? [
        i({ previewConfigPath: r }),
        n({ previewConfigPath: r, coreOptions: a, configDir: t.configDir })
      ] : []
    ]
  };
}, "viteFinal"), Wdt = /* @__PURE__ */ s(async (e, t) => {
  let r = (0, ls.findConfigFile)("preview", t.configDir);
  if (!r)
    return e;
  let { WebpackMockPlugin: i } = await Promise.resolve().then(() => (d6(), h6)), { WebpackInjectMockerRuntimePlugin: n } = await Promise.resolve().then(() => ($se(), Wse));
  return e.plugins = e.plugins || [], e.module.rules.push({
    test: /preview\.(t|j)sx?$/,
    use: [
      {
        loader: require.resolve("storybook/internal/core-server/presets/webpack/loaders/storybook-mock-transform-loader")
      }
    ]
  }), e.plugins.push(new i({ previewConfigPath: r })), e.plugins.push(new n()), e;
}, "webpackFinal");
