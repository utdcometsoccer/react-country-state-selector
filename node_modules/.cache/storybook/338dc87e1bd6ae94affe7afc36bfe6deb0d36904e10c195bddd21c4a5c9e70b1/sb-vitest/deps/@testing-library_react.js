import {
  require_test_utils
} from "./chunk-2O6HLH5D.js";
import {
  require_client
} from "./chunk-VAZM3RZT.js";
import {
  require_react_dom
} from "./chunk-4ILPS46A.js";
import {
  require_react
} from "./chunk-XHBIXJOK.js";
import {
  buildQueries,
  configure,
  createEvent,
  findAllByAltText,
  findAllByDisplayValue,
  findAllByLabelText,
  findAllByPlaceholderText,
  findAllByRole,
  findAllByTestId,
  findAllByText,
  findAllByTitle,
  findByAltText,
  findByDisplayValue,
  findByLabelText,
  findByPlaceholderText,
  findByRole,
  findByTestId,
  findByText,
  findByTitle,
  fireEvent,
  getAllByAltText,
  getAllByDisplayValue,
  getAllByLabelTextWithSuggestions,
  getAllByPlaceholderText,
  getAllByRole,
  getAllByTestId,
  getAllByText,
  getAllByTitle,
  getByAltText,
  getByDisplayValue,
  getByLabelTextWithSuggestions,
  getByPlaceholderText,
  getByRole,
  getByTestId,
  getByText,
  getByTitle,
  getConfig,
  getDefaultNormalizer,
  getElementError,
  getMultipleElementsFoundError,
  getNodeText,
  getQueriesForElement,
  getRoles,
  getSuggestedQuery,
  isInaccessible,
  logDOM,
  logRoles,
  makeFindQuery,
  makeGetAllQuery,
  makeSingleQuery,
  prettyDOM,
  prettyFormat,
  queries,
  queryAllByAltTextWithSuggestions,
  queryAllByAttribute,
  queryAllByDisplayValueWithSuggestions,
  queryAllByLabelTextWithSuggestions,
  queryAllByPlaceholderTextWithSuggestions,
  queryAllByRoleWithSuggestions,
  queryAllByTestIdWithSuggestions,
  queryAllByTextWithSuggestions,
  queryAllByTitleWithSuggestions,
  queryByAltText,
  queryByAttribute,
  queryByDisplayValue,
  queryByLabelText,
  queryByPlaceholderText,
  queryByRole,
  queryByTestId,
  queryByText,
  queryByTitle,
  queryHelpers,
  screen,
  waitForElementToBeRemoved,
  waitForWrapper,
  wrapAllByQueryWithSuggestion,
  wrapSingleQueryWithSuggestion
} from "./chunk-35ZEXVKQ.js";
import "./chunk-D62XAKL2.js";
import {
  __toESM
} from "./chunk-OL46QLBJ.js";

// node_modules/@testing-library/react/dist/@testing-library/react.esm.js
var React = __toESM(require_react());
var DeprecatedReactTestUtils = __toESM(require_test_utils());
var import_react_dom = __toESM(require_react_dom());
var ReactDOMClient = __toESM(require_client());
var reactAct = typeof React.act === "function" ? React.act : DeprecatedReactTestUtils.act;
function getGlobalThis() {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw new Error("unable to locate global object");
}
function setIsReactActEnvironment(isReactActEnvironment) {
  getGlobalThis().IS_REACT_ACT_ENVIRONMENT = isReactActEnvironment;
}
function getIsReactActEnvironment() {
  return getGlobalThis().IS_REACT_ACT_ENVIRONMENT;
}
function withGlobalActEnvironment(actImplementation) {
  return (callback) => {
    const previousActEnvironment = getIsReactActEnvironment();
    setIsReactActEnvironment(true);
    try {
      let callbackNeedsToBeAwaited = false;
      const actResult = actImplementation(() => {
        const result = callback();
        if (result !== null && typeof result === "object" && typeof result.then === "function") {
          callbackNeedsToBeAwaited = true;
        }
        return result;
      });
      if (callbackNeedsToBeAwaited) {
        const thenable = actResult;
        return {
          then: (resolve, reject) => {
            thenable.then((returnValue) => {
              setIsReactActEnvironment(previousActEnvironment);
              resolve(returnValue);
            }, (error) => {
              setIsReactActEnvironment(previousActEnvironment);
              reject(error);
            });
          }
        };
      } else {
        setIsReactActEnvironment(previousActEnvironment);
        return actResult;
      }
    } catch (error) {
      setIsReactActEnvironment(previousActEnvironment);
      throw error;
    }
  };
}
var act3 = withGlobalActEnvironment(reactAct);
var fireEvent2 = function() {
  return fireEvent(...arguments);
};
Object.keys(fireEvent).forEach((key) => {
  fireEvent2[key] = function() {
    return fireEvent[key](...arguments);
  };
});
var mouseEnter = fireEvent2.mouseEnter;
var mouseLeave = fireEvent2.mouseLeave;
fireEvent2.mouseEnter = function() {
  mouseEnter(...arguments);
  return fireEvent2.mouseOver(...arguments);
};
fireEvent2.mouseLeave = function() {
  mouseLeave(...arguments);
  return fireEvent2.mouseOut(...arguments);
};
var pointerEnter = fireEvent2.pointerEnter;
var pointerLeave = fireEvent2.pointerLeave;
fireEvent2.pointerEnter = function() {
  pointerEnter(...arguments);
  return fireEvent2.pointerOver(...arguments);
};
fireEvent2.pointerLeave = function() {
  pointerLeave(...arguments);
  return fireEvent2.pointerOut(...arguments);
};
var select = fireEvent2.select;
fireEvent2.select = (node, init) => {
  select(node, init);
  node.focus();
  fireEvent2.keyUp(node, init);
};
var blur = fireEvent2.blur;
var focus = fireEvent2.focus;
fireEvent2.blur = function() {
  fireEvent2.focusOut(...arguments);
  return blur(...arguments);
};
fireEvent2.focus = function() {
  fireEvent2.focusIn(...arguments);
  return focus(...arguments);
};
var configForRTL = {
  reactStrictMode: false
};
function getConfig2() {
  return {
    ...getConfig(),
    ...configForRTL
  };
}
function configure2(newConfig) {
  if (typeof newConfig === "function") {
    newConfig = newConfig(getConfig2());
  }
  const {
    reactStrictMode,
    ...configForDTL
  } = newConfig;
  configure(configForDTL);
  configForRTL = {
    ...configForRTL,
    reactStrictMode
  };
}
function jestFakeTimersAreEnabled() {
  if (typeof jest !== "undefined" && jest !== null) {
    return (
      // legacy timers
      setTimeout._isMockFunction === true || // modern timers
      // eslint-disable-next-line prefer-object-has-own -- No Object.hasOwn in all target environments we support.
      Object.prototype.hasOwnProperty.call(setTimeout, "clock")
    );
  }
  return false;
}
configure({
  unstable_advanceTimersWrapper: (cb) => {
    return act3(cb);
  },
  // We just want to run `waitFor` without IS_REACT_ACT_ENVIRONMENT
  // But that's not necessarily how `asyncWrapper` is used since it's a public method.
  // Let's just hope nobody else is using it.
  asyncWrapper: async (cb) => {
    const previousActEnvironment = getIsReactActEnvironment();
    setIsReactActEnvironment(false);
    try {
      const result = await cb();
      await new Promise((resolve) => {
        setTimeout(() => {
          resolve();
        }, 0);
        if (jestFakeTimersAreEnabled()) {
          jest.advanceTimersByTime(0);
        }
      });
      return result;
    } finally {
      setIsReactActEnvironment(previousActEnvironment);
    }
  },
  eventWrapper: (cb) => {
    let result;
    act3(() => {
      result = cb();
    });
    return result;
  }
});
var mountedContainers = /* @__PURE__ */ new Set();
var mountedRootEntries = [];
function strictModeIfNeeded(innerElement, reactStrictMode) {
  return reactStrictMode ?? getConfig2().reactStrictMode ? React.createElement(React.StrictMode, null, innerElement) : innerElement;
}
function wrapUiIfNeeded(innerElement, wrapperComponent) {
  return wrapperComponent ? React.createElement(wrapperComponent, null, innerElement) : innerElement;
}
function createConcurrentRoot(container, _ref) {
  let {
    hydrate,
    onCaughtError,
    onRecoverableError,
    ui,
    wrapper: WrapperComponent,
    reactStrictMode
  } = _ref;
  let root;
  if (hydrate) {
    act3(() => {
      root = ReactDOMClient.hydrateRoot(container, strictModeIfNeeded(wrapUiIfNeeded(ui, WrapperComponent), reactStrictMode), {
        onCaughtError,
        onRecoverableError
      });
    });
  } else {
    root = ReactDOMClient.createRoot(container, {
      onCaughtError,
      onRecoverableError
    });
  }
  return {
    hydrate() {
      if (!hydrate) {
        throw new Error("Attempted to hydrate a non-hydrateable root. This is a bug in `@testing-library/react`.");
      }
    },
    render(element) {
      root.render(element);
    },
    unmount() {
      root.unmount();
    }
  };
}
function createLegacyRoot(container) {
  return {
    hydrate(element) {
      import_react_dom.default.hydrate(element, container);
    },
    render(element) {
      import_react_dom.default.render(element, container);
    },
    unmount() {
      import_react_dom.default.unmountComponentAtNode(container);
    }
  };
}
function renderRoot(ui, _ref2) {
  let {
    baseElement,
    container,
    hydrate,
    queries: queries2,
    root,
    wrapper: WrapperComponent,
    reactStrictMode
  } = _ref2;
  act3(() => {
    if (hydrate) {
      root.hydrate(strictModeIfNeeded(wrapUiIfNeeded(ui, WrapperComponent), reactStrictMode), container);
    } else {
      root.render(strictModeIfNeeded(wrapUiIfNeeded(ui, WrapperComponent), reactStrictMode), container);
    }
  });
  return {
    container,
    baseElement,
    debug: function(el, maxLength, options) {
      if (el === void 0) {
        el = baseElement;
      }
      return Array.isArray(el) ? (
        // eslint-disable-next-line no-console
        el.forEach((e) => console.log(prettyDOM(e, maxLength, options)))
      ) : (
        // eslint-disable-next-line no-console,
        console.log(prettyDOM(el, maxLength, options))
      );
    },
    unmount: () => {
      act3(() => {
        root.unmount();
      });
    },
    rerender: (rerenderUi) => {
      renderRoot(rerenderUi, {
        container,
        baseElement,
        root,
        wrapper: WrapperComponent,
        reactStrictMode
      });
    },
    asFragment: () => {
      if (typeof document.createRange === "function") {
        return document.createRange().createContextualFragment(container.innerHTML);
      } else {
        const template = document.createElement("template");
        template.innerHTML = container.innerHTML;
        return template.content;
      }
    },
    ...getQueriesForElement(baseElement, queries2)
  };
}
function render(ui, _temp) {
  let {
    container,
    baseElement = container,
    legacyRoot = false,
    onCaughtError,
    onUncaughtError,
    onRecoverableError,
    queries: queries2,
    hydrate = false,
    wrapper,
    reactStrictMode
  } = _temp === void 0 ? {} : _temp;
  if (onUncaughtError !== void 0) {
    throw new Error("onUncaughtError is not supported. The `render` call will already throw on uncaught errors.");
  }
  if (legacyRoot && typeof import_react_dom.default.render !== "function") {
    const error = new Error("`legacyRoot: true` is not supported in this version of React. If your app runs React 19 or later, you should remove this flag. If your app runs React 18 or earlier, visit https://react.dev/blog/2022/03/08/react-18-upgrade-guide for upgrade instructions.");
    Error.captureStackTrace(error, render);
    throw error;
  }
  if (!baseElement) {
    baseElement = document.body;
  }
  if (!container) {
    container = baseElement.appendChild(document.createElement("div"));
  }
  let root;
  if (!mountedContainers.has(container)) {
    const createRootImpl = legacyRoot ? createLegacyRoot : createConcurrentRoot;
    root = createRootImpl(container, {
      hydrate,
      onCaughtError,
      onRecoverableError,
      ui,
      wrapper,
      reactStrictMode
    });
    mountedRootEntries.push({
      container,
      root
    });
    mountedContainers.add(container);
  } else {
    mountedRootEntries.forEach((rootEntry) => {
      if (rootEntry.container === container) {
        root = rootEntry.root;
      }
    });
  }
  return renderRoot(ui, {
    container,
    baseElement,
    queries: queries2,
    hydrate,
    wrapper,
    root,
    reactStrictMode
  });
}
function cleanup() {
  mountedRootEntries.forEach((_ref3) => {
    let {
      root,
      container
    } = _ref3;
    act3(() => {
      root.unmount();
    });
    if (container.parentNode === document.body) {
      document.body.removeChild(container);
    }
  });
  mountedRootEntries.length = 0;
  mountedContainers.clear();
}
function renderHook(renderCallback, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    initialProps,
    ...renderOptions
  } = options;
  if (renderOptions.legacyRoot && typeof import_react_dom.default.render !== "function") {
    const error = new Error("`legacyRoot: true` is not supported in this version of React. If your app runs React 19 or later, you should remove this flag. If your app runs React 18 or earlier, visit https://react.dev/blog/2022/03/08/react-18-upgrade-guide for upgrade instructions.");
    Error.captureStackTrace(error, renderHook);
    throw error;
  }
  const result = React.createRef();
  function TestComponent(_ref4) {
    let {
      renderCallbackProps
    } = _ref4;
    const pendingResult = renderCallback(renderCallbackProps);
    React.useEffect(() => {
      result.current = pendingResult;
    });
    return null;
  }
  const {
    rerender: baseRerender,
    unmount
  } = render(React.createElement(TestComponent, {
    renderCallbackProps: initialProps
  }), renderOptions);
  function rerender(rerenderCallbackProps) {
    return baseRerender(React.createElement(TestComponent, {
      renderCallbackProps: rerenderCallbackProps
    }));
  }
  return {
    result,
    rerender,
    unmount
  };
}
if (typeof process === "undefined" || !process.env?.RTL_SKIP_AUTO_CLEANUP) {
  if (typeof afterEach === "function") {
    afterEach(() => {
      cleanup();
    });
  } else if (typeof teardown === "function") {
    teardown(() => {
      cleanup();
    });
  }
  if (typeof beforeAll === "function" && typeof afterAll === "function") {
    let previousIsReactActEnvironment = getIsReactActEnvironment();
    beforeAll(() => {
      previousIsReactActEnvironment = getIsReactActEnvironment();
      setIsReactActEnvironment(true);
    });
    afterAll(() => {
      setIsReactActEnvironment(previousIsReactActEnvironment);
    });
  }
}
export {
  act3 as act,
  buildQueries,
  cleanup,
  configure2 as configure,
  createEvent,
  findAllByAltText,
  findAllByDisplayValue,
  findAllByLabelText,
  findAllByPlaceholderText,
  findAllByRole,
  findAllByTestId,
  findAllByText,
  findAllByTitle,
  findByAltText,
  findByDisplayValue,
  findByLabelText,
  findByPlaceholderText,
  findByRole,
  findByTestId,
  findByText,
  findByTitle,
  fireEvent2 as fireEvent,
  getAllByAltText,
  getAllByDisplayValue,
  getAllByLabelTextWithSuggestions as getAllByLabelText,
  getAllByPlaceholderText,
  getAllByRole,
  getAllByTestId,
  getAllByText,
  getAllByTitle,
  getByAltText,
  getByDisplayValue,
  getByLabelTextWithSuggestions as getByLabelText,
  getByPlaceholderText,
  getByRole,
  getByTestId,
  getByText,
  getByTitle,
  getConfig2 as getConfig,
  getDefaultNormalizer,
  getElementError,
  getMultipleElementsFoundError,
  getNodeText,
  getQueriesForElement,
  getRoles,
  getSuggestedQuery,
  isInaccessible,
  logDOM,
  logRoles,
  makeFindQuery,
  makeGetAllQuery,
  makeSingleQuery,
  prettyDOM,
  prettyFormat,
  queries,
  queryAllByAltTextWithSuggestions as queryAllByAltText,
  queryAllByAttribute,
  queryAllByDisplayValueWithSuggestions as queryAllByDisplayValue,
  queryAllByLabelTextWithSuggestions as queryAllByLabelText,
  queryAllByPlaceholderTextWithSuggestions as queryAllByPlaceholderText,
  queryAllByRoleWithSuggestions as queryAllByRole,
  queryAllByTestIdWithSuggestions as queryAllByTestId,
  queryAllByTextWithSuggestions as queryAllByText,
  queryAllByTitleWithSuggestions as queryAllByTitle,
  queryByAltText,
  queryByAttribute,
  queryByDisplayValue,
  queryByLabelText,
  queryByPlaceholderText,
  queryByRole,
  queryByTestId,
  queryByText,
  queryByTitle,
  queryHelpers,
  render,
  renderHook,
  screen,
  waitForWrapper as waitFor,
  waitForElementToBeRemoved,
  getQueriesForElement as within,
  wrapAllByQueryWithSuggestion,
  wrapSingleQueryWithSuggestion
};
//# sourceMappingURL=@testing-library_react.js.map
