import {
  KTe,
  Qs,
  XTe,
  abe,
  cbe,
  cn,
  dbe,
  lbe,
  ube
} from "./chunk-ITO6PFVY.js";
import {
  z as z2
} from "./chunk-B5GMIZ2B.js";
import {
  B,
  D,
  G,
  H,
  I,
  J,
  K,
  L,
  M,
  O,
  OE,
  P,
  Q,
  TE,
  U,
  V,
  X,
  Y,
  Z,
  b,
  d,
  e,
  h,
  i,
  j,
  k,
  l,
  m,
  o,
  p,
  q,
  r,
  scope,
  w,
  x,
  z
} from "./chunk-IO6IKTJ5.js";
import {
  __require
} from "./chunk-OL46QLBJ.js";

// node_modules/storybook/dist/preview-errors.js
var ie = Object.defineProperty;
var t = (i2, o2) => ie(i2, "name", { value: o2, configurable: true });
function n(i2) {
  for (var o2 = [], e2 = 1; e2 < arguments.length; e2++)
    o2[e2 - 1] = arguments[e2];
  var a = Array.from(typeof i2 == "string" ? [i2] : i2);
  a[a.length - 1] = a[a.length - 1].replace(/\r?\n([\t ]*)$/, "");
  var y = a.reduce(function(c, m2) {
    var p2 = m2.match(/\n([\t ]+|(?!\s).)/g);
    return p2 ? c.concat(p2.map(function(E) {
      var d2, l2;
      return (l2 = (d2 = E.match(/[\t ]/g)) === null || d2 === void 0 ? void 0 : d2.length) !== null && l2 !== void 0 ? l2 : 0;
    })) : c;
  }, []);
  if (y.length) {
    var h2 = new RegExp(`
[	 ]{` + Math.min.apply(Math, y) + "}", "g");
    a = a.map(function(c) {
      return c.replace(h2, `
`);
    });
  }
  a[0] = a[0].replace(/^\r?\n/, "");
  var u = a[0];
  return o2.forEach(function(c, m2) {
    var p2 = u.match(/(?:^|\n)( *)$/), E = p2 ? p2[1] : "", d2 = c;
    typeof c == "string" && c.includes(`
`) && (d2 = String(c).split(`
`).map(function(l2, ae2) {
      return ae2 === 0 ? l2 : "" + E + l2;
    }).join(`
`)), u += d2 + a[m2 + 1];
  }), u;
}
t(n, "dedent");
function j2({
  code: i2,
  category: o2
}) {
  let e2 = String(i2).padStart(4, "0");
  return `SB_${o2}_${e2}`;
}
t(j2, "parseErrorCode");
function L2(i2) {
  if (/^(?!.*storybook\.js\.org)|[?&]ref=error\b/.test(i2))
    return i2;
  try {
    let o2 = new URL(i2);
    return o2.searchParams.set("ref", "error"), o2.toString();
  } catch {
    return i2;
  }
}
t(L2, "appendErrorRef");
var g = class g2 extends Error {
  constructor(e2) {
    super(g2.getFullMessage(e2));
    this.data = {};
    this.fromStorybook = true;
    this.category = e2.category, this.documentation = e2.documentation ?? false, this.code = e2.code;
  }
  get fullErrorCode() {
    return j2({ code: this.code, category: this.category });
  }
  /** Overrides the default `Error.name` property in the format: SB_<CATEGORY>_<CODE>. */
  get name() {
    let e2 = this.constructor.name;
    return `${this.fullErrorCode} (${e2})`;
  }
  /** Generates the error message along with additional documentation link (if applicable). */
  static getFullMessage({
    documentation: e2,
    code: a,
    category: y,
    message: h2
  }) {
    let u;
    return e2 === true ? u = `https://storybook.js.org/error/${j2({ code: a, category: y })}?ref=error` : typeof e2 == "string" ? u = L2(e2) : Array.isArray(e2) && (u = `
${e2.map((c) => `	- ${L2(c)}`).join(`
`)}`), `${h2}${u != null ? `

More info: ${u}
` : ""}`;
  }
};
t(g, "StorybookError");
var s = g;
var ce = ((r2) => (r2.BLOCKS = "BLOCKS", r2.DOCS_TOOLS = "DOCS-TOOLS", r2.PREVIEW_CLIENT_LOGGER = "PREVIEW_CLIENT-LOGGER", r2.PREVIEW_CHANNELS = "PREVIEW_CHANNELS", r2.PREVIEW_CORE_EVENTS = "PREVIEW_CORE-EVENTS", r2.PREVIEW_INSTRUMENTER = "PREVIEW_INSTRUMENTER", r2.PREVIEW_API = "PREVIEW_API", r2.PREVIEW_REACT_DOM_SHIM = "PREVIEW_REACT-DOM-SHIM", r2.PREVIEW_ROUTER = "PREVIEW_ROUTER", r2.PREVIEW_THEMING = "PREVIEW_THEMING", r2.RENDERER_HTML = "RENDERER_HTML", r2.RENDERER_PREACT = "RENDERER_PREACT", r2.RENDERER_REACT = "RENDERER_REACT", r2.RENDERER_SERVER = "RENDERER_SERVER", r2.RENDERER_SVELTE = "RENDERER_SVELTE", r2.RENDERER_VUE = "RENDERER_VUE", r2.RENDERER_VUE3 = "RENDERER_VUE3", r2.RENDERER_WEB_COMPONENTS = "RENDERER_WEB-COMPONENTS", r2.FRAMEWORK_NEXTJS = "FRAMEWORK_NEXTJS", r2.ADDON_VITEST = "ADDON_VITEST", r2.ADDON_A11Y = "ADDON_A11Y", r2))(ce || {});
var f = class f2 extends s {
  constructor(e2) {
    super({
      category: "PREVIEW_API",
      code: 1,
      message: n`
        Couldn't find story matching id '${e2.storyId}' after HMR.
        - Did you just rename a story?
        - Did you remove it from your CSF file?
        - Are you sure a story with the id '${e2.storyId}' exists?
        - Please check the values in the stories field of your main.js config and see if they would match your CSF File.
        - Also check the browser console and terminal for potential error messages.`
    });
    this.data = e2;
  }
};
t(f, "MissingStoryAfterHmrError");
var Y2 = f;
var b2 = class b3 extends s {
  constructor(e2) {
    super({
      category: "PREVIEW_API",
      code: 2,
      documentation: "https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#using-implicit-actions-during-rendering-is-deprecated-for-example-in-the-play-function",
      message: n`
        We detected that you use an implicit action arg while ${e2.phase} of your story.  
        ${e2.deprecated ? `
This is deprecated and won't work in Storybook 8 anymore.
` : ""}
        Please provide an explicit spy to your args like this:
          import { fn } from 'storybook/test';
          ... 
          args: {
           ${e2.name}: fn()
          }`
    });
    this.data = e2;
  }
};
t(b2, "ImplicitActionsDuringRendering");
var G2 = b2;
var R = class R2 extends s {
  constructor() {
    super({
      category: "PREVIEW_API",
      code: 3,
      message: n`
        Cannot call \`storyStore.extract()\` without calling \`storyStore.cacheAllCsfFiles()\` first.

        You probably meant to call \`await preview.extract()\` which does the above for you.`
    });
  }
};
t(R, "CalledExtractOnStoreError");
var F = R;
var I2 = class I3 extends s {
  constructor() {
    super({
      category: "PREVIEW_API",
      code: 4,
      message: n`
        Expected your framework's preset to export a \`renderToCanvas\` field.

        Perhaps it needs to be upgraded for Storybook 7.0?`,
      documentation: "https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#mainjs-framework-field"
    });
  }
};
t(I2, "MissingRenderToCanvasError");
var H2 = I2;
var x2 = class x3 extends s {
  constructor(e2) {
    super({
      category: "PREVIEW_API",
      code: 5,
      message: n`
        Called \`Preview.${e2.methodName}()\` before initialization.
        
        The preview needs to load the story index before most methods can be called. If you want
        to call \`${e2.methodName}\`, try \`await preview.initializationPromise;\` first.
        
        If you didn't call the above code, then likely it was called by an addon that needs to
        do the above.`
    });
    this.data = e2;
  }
};
t(x2, "CalledPreviewMethodBeforeInitializationError");
var M2 = x2;
var P2 = class P3 extends s {
  constructor(e2) {
    super({
      category: "PREVIEW_API",
      code: 6,
      message: n`
        Error fetching \`/index.json\`:
        
        ${e2.text}

        If you are in development, this likely indicates a problem with your Storybook process,
        check the terminal for errors.

        If you are in a deployed Storybook, there may have been an issue deploying the full Storybook
        build.`
    });
    this.data = e2;
  }
};
t(P2, "StoryIndexFetchError");
var K2 = P2;
var w2 = class w3 extends s {
  constructor(e2) {
    super({
      category: "PREVIEW_API",
      code: 7,
      message: n`
        Tried to render docs entry ${e2.storyId} but it is a MDX file that has no CSF
        references, or autodocs for a CSF file that some doesn't refer to itself.
        
        This likely is an internal error in Storybook's indexing, or you've attached the
        \`attached-mdx\` tag to an MDX file that is not attached.`
    });
    this.data = e2;
  }
};
t(w2, "MdxFileWithNoCsfReferencesError");
var U2 = w2;
var T = class T2 extends s {
  constructor() {
    super({
      category: "PREVIEW_API",
      code: 8,
      message: n`
        Couldn't find any stories in your Storybook.

        - Please check your stories field of your main.js config: does it match correctly?
        - Also check the browser console and terminal for error messages.`
    });
  }
};
t(T, "EmptyIndexError");
var X2 = T;
var S = class S2 extends s {
  constructor(e2) {
    super({
      category: "PREVIEW_API",
      code: 9,
      message: n`
        Couldn't find story matching '${e2.storySpecifier}'.

        - Are you sure a story with that id exists?
        - Please check your stories field of your main.js config.
        - Also check the browser console and terminal for error messages.`
    });
    this.data = e2;
  }
};
t(S, "NoStoryMatchError");
var J2 = S;
var k2 = class k3 extends s {
  constructor(e2) {
    super({
      category: "PREVIEW_API",
      code: 10,
      message: n`
        Couldn't find story matching id '${e2.storyId}' after importing a CSF file.

        The file was indexed as if the story was there, but then after importing the file in the browser
        we didn't find the story. Possible reasons:
        - You are using a custom story indexer that is misbehaving.
        - You have a custom file loader that is removing or renaming exports.

        Please check your browser console and terminal for errors that may explain the issue.`
    });
    this.data = e2;
  }
};
t(k2, "MissingStoryFromCsfFileError");
var q2 = k2;
var v = class v2 extends s {
  constructor() {
    super({
      category: "PREVIEW_API",
      code: 11,
      message: n`
        Cannot access the Story Store until the index is ready.

        It is not recommended to use methods directly on the Story Store anyway, in Storybook 9 we will
        remove access to the store entirely`
    });
  }
};
t(v, "StoryStoreAccessedBeforeInitializationError");
var z3 = v;
var _ = class _2 extends s {
  constructor(e2) {
    super({
      category: "PREVIEW_API",
      code: 12,
      message: n`
      Incorrect use of mount in the play function.
      
      To use mount in the play function, you must satisfy the following two requirements: 
      
      1. You *must* destructure the mount property from the \`context\` (the argument passed to your play function). 
         This makes sure that Storybook does not start rendering the story before the play function begins.
      
      2. Your Storybook framework or builder must be configured to transpile to ES2017 or newer. 
         This is because destructuring statements and async/await usages are otherwise transpiled away, 
         which prevents Storybook from recognizing your usage of \`mount\`.
      
      Note that Angular is not supported. As async/await is transpiled to support the zone.js polyfill. 
      
      More info: https://storybook.js.org/docs/writing-tests/interaction-testing?ref=error#run-code-before-the-component-gets-rendered
      
      Received the following play function:
      ${e2.playFunction}`
    });
    this.data = e2;
  }
};
t(_, "MountMustBeDestructuredError");
var B2 = _;
var N = class N2 extends s {
  constructor(e2) {
    super({
      category: "PREVIEW_API",
      code: 14,
      message: n`
        No render function available for storyId '${e2.id}'
      `
    });
    this.data = e2;
  }
};
t(N, "NoRenderFunctionError");
var Q2 = N;
var V2 = class V3 extends s {
  constructor() {
    super({
      category: "PREVIEW_API",
      code: 15,
      message: n`
        No component is mounted in your story.
        
        This usually occurs when you destructure mount in the play function, but forget to call it.
        
        For example:

        async play({ mount, canvasElement }) {
          // 👈 mount should be called: await mount(); 
          const canvas = within(canvasElement);
          const button = await canvas.findByRole('button');
          await userEvent.click(button);
        };

        Make sure to either remove it or call mount in your play function.
      `
    });
  }
};
t(V2, "NoStoryMountedError");
var Z2 = V2;
var A = class A2 extends s {
  constructor(e2) {
    super({
      category: "PREVIEW_API",
      code: 16,
      message: `Status has typeId "${e2.status.typeId}" but was added to store with typeId "${e2.typeId}". Full status: ${JSON.stringify(
        e2.status,
        null,
        2
      )}`
    });
    this.data = e2;
  }
};
t(A, "StatusTypeIdMismatchError");
var O2 = class O3 extends s {
  constructor() {
    super({
      category: "FRAMEWORK_NEXTJS",
      code: 1,
      documentation: "https://storybook.js.org/docs/get-started/nextjs#faq",
      message: n`
      You are importing avif images, but you don't have sharp installed.

      You have to install sharp in order to use image optimization features in Next.js.
      `
    });
  }
};
t(O2, "NextJsSharpError");
var W = class W2 extends s {
  constructor(e2) {
    super({
      category: "FRAMEWORK_NEXTJS",
      code: 2,
      message: n`
        Tried to access router mocks from "${e2.importType}" but they were not created yet. You might be running code in an unsupported environment.
      `
    });
    this.data = e2;
  }
};
t(W, "NextjsRouterMocksNotAvailable");
var $ = class $2 extends s {
  constructor(e2) {
    super({
      category: "DOCS-TOOLS",
      code: 1,
      documentation: "https://github.com/storybookjs/storybook/issues/26606",
      message: n`
        There was a failure when generating detailed ArgTypes in ${e2.language} for:
        ${JSON.stringify(e2.type, null, 2)} 
        
        Storybook will fall back to use a generic type description instead.

        This type is either not supported or it is a bug in the docgen generation in Storybook.
        If you think this is a bug, please detail it as much as possible in the Github issue.
      `
    });
    this.data = e2;
  }
};
t($, "UnknownArgTypesError");
var se = $;
var D2 = class D3 extends s {
  constructor(e2) {
    super({
      category: "ADDON_VITEST",
      code: 1,
      // TODO: Add documentation about viewports support
      // documentation: '',
      message: n`
        Encountered an unsupported value "${e2.value}" when setting the viewport ${e2.dimension} dimension.
        
        The Storybook plugin only supports values in the following units:
        - px, vh, vw, em, rem and %.
        
        You can either change the viewport for this story to use one of the supported units or skip the test by adding '!test' to the story's tags per https://storybook.js.org/docs/writing-stories/tags
      `
    });
    this.data = e2;
  }
};
t(D2, "UnsupportedViewportDimensionError");
var re = D2;
var C = class C2 extends s {
  constructor() {
    super({
      category: "ADDON_A11Y",
      code: 1,
      documentation: "https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#a11y-addon-replace-element-parameter-with-context-parameter",
      message: 'The "element" parameter in parameters.a11y has been removed. Use "context" instead.'
    });
  }
};
t(C, "ElementA11yParameterError");
var ne = C;

// node_modules/storybook/dist/csf/index.js
var Br = Object.create;
var ce2 = Object.defineProperty;
var zr = Object.getOwnPropertyDescriptor;
var Ur = Object.getOwnPropertyNames;
var Gr = Object.getPrototypeOf;
var Wr = Object.prototype.hasOwnProperty;
var n2 = (e2, t2) => ce2(e2, "name", { value: t2, configurable: true });
var Yr = (e2, t2) => () => (t2 || e2((t2 = { exports: {} }).exports, t2), t2.exports);
var xt = (e2, t2) => {
  for (var r2 in t2)
    ce2(e2, r2, { get: t2[r2], enumerable: true });
};
var Vr = (e2, t2, r2, o2) => {
  if (t2 && typeof t2 == "object" || typeof t2 == "function")
    for (let i2 of Ur(t2))
      !Wr.call(e2, i2) && i2 !== r2 && ce2(e2, i2, { get: () => t2[i2], enumerable: !(o2 = zr(t2, i2)) || o2.enumerable });
  return e2;
};
var Kr = (e2, t2, r2) => (r2 = e2 != null ? Br(Gr(e2)) : {}, Vr(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  t2 || !e2 || !e2.__esModule ? ce2(r2, "default", { value: e2, enumerable: true }) : r2,
  e2
));
var Tt = Yr((Ee2) => {
  Object.defineProperty(Ee2, "__esModule", { value: true }), Ee2.isEqual = /* @__PURE__ */ (function() {
    var e2 = Object.prototype.toString, t2 = Object.getPrototypeOf, r2 = Object.getOwnPropertySymbols ? function(o2) {
      return Object.keys(o2).concat(Object.getOwnPropertySymbols(o2));
    } : Object.keys;
    return function(o2, i2) {
      return n2(function s2(a, p2, c) {
        var l2, y, u, h2 = e2.call(a), T3 = e2.call(p2);
        if (a === p2) return true;
        if (a == null || p2 == null) return false;
        if (c.indexOf(a) > -1 && c.indexOf(p2) > -1) return true;
        if (c.push(a, p2), h2 != T3 || (l2 = r2(a), y = r2(p2), l2.length != y.length || l2.some(function(R3) {
          return !s2(a[R3], p2[R3], c);
        }))) return false;
        switch (h2.slice(8, -1)) {
          case "Symbol":
            return a.valueOf() == p2.valueOf();
          case "Date":
          case "Number":
            return +a == +p2 || +a != +a && +p2 != +p2;
          case "RegExp":
          case "Function":
          case "String":
          case "Boolean":
            return "" + a == "" + p2;
          case "Set":
          case "Map":
            l2 = a.entries(), y = p2.entries();
            do
              if (!s2((u = l2.next()).value, y.next().value, c)) return false;
            while (!u.done);
            return true;
          case "ArrayBuffer":
            a = new Uint8Array(a), p2 = new Uint8Array(p2);
          case "DataView":
            a = new Uint8Array(a.buffer), p2 = new Uint8Array(p2.buffer);
          case "Float32Array":
          case "Float64Array":
          case "Int8Array":
          case "Int16Array":
          case "Int32Array":
          case "Uint8Array":
          case "Uint16Array":
          case "Uint32Array":
          case "Uint8ClampedArray":
          case "Arguments":
          case "Array":
            if (a.length != p2.length) return false;
            for (u = 0; u < a.length; u++) if ((u in a || u in p2) && (u in a != u in p2 || !s2(a[u], p2[u], c))) return false;
            return true;
          case "Object":
            return s2(t2(a), t2(p2), c);
          default:
            return false;
        }
      }, "n")(o2, i2, []);
    };
  })();
});
function bt(e2) {
  return e2.replace(/_/g, " ").replace(/-/g, " ").replace(/\./g, " ").replace(/([^\n])([A-Z])([a-z])/g, (t2, r2, o2, i2) => `${r2} ${o2}${i2}`).replace(
    /([a-z])([A-Z])/g,
    (t2, r2, o2) => `${r2} ${o2}`
  ).replace(/([a-z])([0-9])/gi, (t2, r2, o2) => `${r2} ${o2}`).replace(/([0-9])([a-z])/gi, (t2, r2, o2) => `${r2} ${o2}`).replace(/(\s|^)(\w)/g, (t2, r2, o2) => `${r2}${o2.toUpperCase()}`).replace(/ +/g, " ").trim();
}
n2(bt, "toStartCaseStr");
var Ce = Kr(Tt(), 1);
var St = n2((e2) => e2.map((t2) => typeof t2 < "u").filter(Boolean).length, "count");
var qr = n2((e2, t2) => {
  let { exists: r2, eq: o2, neq: i2, truthy: s2 } = e2;
  if (St([r2, o2, i2, s2]) > 1)
    throw new Error(`Invalid conditional test ${JSON.stringify({ exists: r2, eq: o2, neq: i2 })}`);
  if (typeof o2 < "u")
    return (0, Ce.isEqual)(t2, o2);
  if (typeof i2 < "u")
    return !(0, Ce.isEqual)(t2, i2);
  if (typeof r2 < "u") {
    let p2 = typeof t2 < "u";
    return r2 ? p2 : !p2;
  }
  return (typeof s2 > "u" ? true : s2) ? !!t2 : !t2;
}, "testValue");
var Xr = n2((e2, t2, r2) => {
  if (!e2.if)
    return true;
  let { arg: o2, global: i2 } = e2.if;
  if (St([o2, i2]) !== 1)
    throw new Error(`Invalid conditional value ${JSON.stringify({ arg: o2, global: i2 })}`);
  let s2 = o2 ? t2[o2] : r2[i2];
  return qr(e2.if, s2);
}, "includeConditionalArg");
function At() {
  let e2 = {
    setHandler: n2(() => {
    }, "setHandler"),
    send: n2(() => {
    }, "send")
  };
  return new z2({ transport: e2 });
}
n2(At, "mockChannel");
var Me = class Me2 {
  constructor() {
    this.getChannel = n2(() => {
      if (!this.channel) {
        let t2 = At();
        return this.setChannel(t2), t2;
      }
      return this.channel;
    }, "getChannel");
    this.ready = n2(() => this.promise, "ready");
    this.hasChannel = n2(() => !!this.channel, "hasChannel");
    this.setChannel = n2((t2) => {
      this.channel = t2, this.resolve();
    }, "setChannel");
    this.promise = new Promise((t2) => {
      this.resolve = () => t2(this.getChannel());
    });
  }
};
n2(Me, "AddonStore");
var Pe = Me;
var ke = "__STORYBOOK_ADDONS_PREVIEW";
function Jr() {
  return scope[ke] || (scope[ke] = new Pe()), scope[ke];
}
n2(Jr, "getAddonsStore");
var Oe = Jr();
var Ie = class Ie2 {
  constructor() {
    this.hookListsMap = void 0;
    this.mountedDecorators = void 0;
    this.prevMountedDecorators = void 0;
    this.currentHooks = void 0;
    this.nextHookIndex = void 0;
    this.currentPhase = void 0;
    this.currentEffects = void 0;
    this.prevEffects = void 0;
    this.currentDecoratorName = void 0;
    this.hasUpdates = void 0;
    this.currentContext = void 0;
    this.renderListener = n2((t2) => {
      t2 === this.currentContext?.id && (this.triggerEffects(), this.currentContext = null, this.removeRenderListeners());
    }, "renderListener");
    this.init();
  }
  init() {
    this.hookListsMap = /* @__PURE__ */ new WeakMap(), this.mountedDecorators = /* @__PURE__ */ new Set(), this.prevMountedDecorators = /* @__PURE__ */ new Set(), this.currentHooks = [], this.nextHookIndex = 0, this.currentPhase = "NONE", this.currentEffects = [], this.prevEffects = [], this.currentDecoratorName = null, this.hasUpdates = false, this.currentContext = null;
  }
  clean() {
    this.prevEffects.forEach((t2) => {
      t2.destroy && t2.destroy();
    }), this.init(), this.removeRenderListeners();
  }
  getNextHook() {
    let t2 = this.currentHooks[this.nextHookIndex];
    return this.nextHookIndex += 1, t2;
  }
  triggerEffects() {
    this.prevEffects.forEach((t2) => {
      !this.currentEffects.includes(t2) && t2.destroy && t2.destroy();
    }), this.currentEffects.forEach((t2) => {
      this.prevEffects.includes(t2) || (t2.destroy = t2.create());
    }), this.prevEffects = this.currentEffects, this.currentEffects = [];
  }
  addRenderListeners() {
    this.removeRenderListeners(), Oe.getChannel().on(X, this.renderListener);
  }
  removeRenderListeners() {
    Oe.getChannel().removeListener(X, this.renderListener);
  }
};
n2(Ie, "HooksContext");
var de = Ie;
function wt(e2) {
  let t2 = n2((...r2) => {
    let { hooks: o2 } = typeof r2[0] == "function" ? r2[1] : r2[0], i2 = o2.currentPhase, s2 = o2.currentHooks, a = o2.nextHookIndex, p2 = o2.currentDecoratorName;
    o2.currentDecoratorName = e2.name, o2.prevMountedDecorators.has(e2) ? (o2.currentPhase = "UPDATE", o2.currentHooks = o2.hookListsMap.get(e2) || []) : (o2.currentPhase = "MOUNT", o2.currentHooks = [], o2.hookListsMap.set(e2, o2.currentHooks), o2.prevMountedDecorators.add(e2)), o2.nextHookIndex = 0;
    let c = scope.STORYBOOK_HOOKS_CONTEXT;
    scope.STORYBOOK_HOOKS_CONTEXT = o2;
    let l2 = e2(...r2);
    if (scope.STORYBOOK_HOOKS_CONTEXT = c, o2.currentPhase === "UPDATE" && o2.getNextHook() != null)
      throw new Error(
        "Rendered fewer hooks than expected. This may be caused by an accidental early return statement."
      );
    return o2.currentPhase = i2, o2.currentHooks = s2, o2.nextHookIndex = a, o2.currentDecoratorName = p2, l2;
  }, "hookified");
  return t2.originalFn = e2, t2;
}
n2(wt, "hookify");
var Fe = 0;
var Qr = 25;
var Et = n2((e2) => (t2, r2) => {
  let o2 = e2(
    wt(t2),
    r2.map((i2) => wt(i2))
  );
  return (i2) => {
    let { hooks: s2 } = i2;
    s2.prevMountedDecorators ??= /* @__PURE__ */ new Set(), s2.mountedDecorators = /* @__PURE__ */ new Set([t2, ...r2]), s2.currentContext = i2, s2.hasUpdates = false;
    let a = o2(i2);
    for (Fe = 1; s2.hasUpdates; )
      if (s2.hasUpdates = false, s2.currentEffects = [], a = o2(i2), Fe += 1, Fe > Qr)
        throw new Error(
          "Too many re-renders. Storybook limits the number of renders to prevent an infinite loop."
        );
    return s2.addRenderListeners(), a;
  };
}, "applyHooks");
function ee(e2) {
  if (!e2 || typeof e2 != "object")
    return false;
  let t2 = Object.getPrototypeOf(e2);
  return t2 === null || t2 === Object.prototype || Object.getPrototypeOf(t2) === null ? Object.prototype.toString.call(e2) === "[object Object]" : false;
}
n2(ee, "isPlainObject");
function U3(e2, t2) {
  let r2 = {}, o2 = Object.keys(e2);
  for (let i2 = 0; i2 < o2.length; i2++) {
    let s2 = o2[i2], a = e2[s2];
    r2[s2] = t2(a, s2, e2);
  }
  return r2;
}
n2(U3, "mapValues");
function Le(e2, t2) {
  let r2 = {}, o2 = Object.keys(e2);
  for (let i2 = 0; i2 < o2.length; i2++) {
    let s2 = o2[i2], a = e2[s2];
    t2(a, s2) && (r2[s2] = a);
  }
  return r2;
}
n2(Le, "pickBy");
function W3(e2) {
  for (var t2 = [], r2 = 1; r2 < arguments.length; r2++)
    t2[r2 - 1] = arguments[r2];
  var o2 = Array.from(typeof e2 == "string" ? [e2] : e2);
  o2[o2.length - 1] = o2[o2.length - 1].replace(/\r?\n([\t ]*)$/, "");
  var i2 = o2.reduce(function(p2, c) {
    var l2 = c.match(/\n([\t ]+|(?!\s).)/g);
    return l2 ? p2.concat(l2.map(function(y) {
      var u, h2;
      return (h2 = (u = y.match(/[\t ]/g)) === null || u === void 0 ? void 0 : u.length) !== null && h2 !== void 0 ? h2 : 0;
    })) : p2;
  }, []);
  if (i2.length) {
    var s2 = new RegExp(`
[	 ]{` + Math.min.apply(Math, i2) + "}", "g");
    o2 = o2.map(function(p2) {
      return p2.replace(s2, `
`);
    });
  }
  o2[0] = o2[0].replace(/^\r?\n/, "");
  var a = o2[0];
  return t2.forEach(function(p2, c) {
    var l2 = a.match(/(?:^|\n)( *)$/), y = l2 ? l2[1] : "", u = p2;
    typeof p2 == "string" && p2.includes(`
`) && (u = String(p2).split(`
`).map(function(h2, T3) {
      return T3 === 0 ? h2 : "" + y + h2;
    }).join(`
`)), a += u + o2[c + 1];
  }), a;
}
n2(W3, "dedent");
var vi = Symbol("incompatible");
var ki = Symbol("Deeply equal");
var De = "UNTARGETED";
function Ct({
  args: e2,
  argTypes: t2
}) {
  let r2 = {};
  return Object.entries(e2).forEach(([o2, i2]) => {
    let { target: s2 = De } = t2[o2] || {};
    r2[s2] = r2[s2] || {}, r2[s2][o2] = i2;
  }), r2;
}
n2(Ct, "groupArgsByTarget");
var vt = n2((e2 = {}) => Object.entries(e2).reduce((t2, [r2, { defaultValue: o2 }]) => (typeof o2 < "u" && (t2[r2] = o2), t2), {}), "getValuesFromArgTypes");
var eo = n2((e2) => typeof e2 == "string" ? { name: e2 } : e2, "normalizeType");
var to = n2((e2) => typeof e2 == "string" ? { type: e2 } : e2, "normalizeControl");
var ro = n2((e2, t2) => {
  let { type: r2, control: o2, ...i2 } = e2, s2 = {
    name: t2,
    ...i2
  };
  return r2 && (s2.type = eo(r2)), o2 ? s2.control = to(o2) : o2 === false && (s2.control = { disable: true }), s2;
}, "normalizeInputType");
var K3 = n2((e2) => U3(e2, ro), "normalizeInputTypes");
var b4 = n2((e2) => Array.isArray(e2) ? e2 : e2 ? [e2] : [], "normalizeArrays");
var ao = W3`
CSF .story annotations deprecated; annotate story functions directly:
- StoryFn.story.name => StoryFn.storyName
- StoryFn.story.(parameters|decorators) => StoryFn.(parameters|decorators)
See https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#hoisted-csf-annotations for details and codemod.
`;
function _e(e2, t2, r2) {
  let o2 = t2, i2 = typeof t2 == "function" ? t2 : null, { story: s2 } = o2;
  s2 && (i.debug("deprecated story", s2), h(ao));
  let a = cc(e2), p2 = typeof o2 != "function" && o2.name || o2.storyName || s2?.name || a, c = [
    ...b4(o2.decorators),
    ...b4(s2?.decorators)
  ], l2 = { ...s2?.parameters, ...o2.parameters }, y = { ...s2?.args, ...o2.args }, u = { ...s2?.argTypes, ...o2.argTypes }, h2 = [...b4(o2.loaders), ...b4(
    s2?.loaders
  )], T3 = [
    ...b4(o2.beforeEach),
    ...b4(s2?.beforeEach)
  ], R3 = [
    ...b4(o2.afterEach),
    ...b4(s2?.afterEach)
  ], { render: P5, play: L3, tags: O5 = [], globals: F2 = {} } = o2, A3 = l2.__id || lc(r2.id, a);
  return {
    moduleExport: t2,
    id: A3,
    name: p2,
    tags: O5,
    decorators: c,
    parameters: l2,
    args: y,
    argTypes: K3(u),
    loaders: h2,
    beforeEach: T3,
    afterEach: R3,
    globals: F2,
    ...P5 && { render: P5 },
    ...i2 && { userStoryFn: i2 },
    ...L3 && { play: L3 }
  };
}
n2(_e, "normalizeStory");
function kt(e2, t2 = e2.title, r2) {
  let { id: o2, argTypes: i2 } = e2;
  return {
    id: jn(o2 || t2),
    ...e2,
    title: t2,
    ...i2 && { argTypes: K3(i2) },
    parameters: {
      fileName: r2,
      ...e2.parameters
    }
  };
}
n2(kt, "normalizeComponentAnnotations");
function Ot2(e2) {
  return e2 != null && lo(e2).includes("mount");
}
n2(Ot2, "mountDestructured");
function lo(e2) {
  let t2 = e2.toString().match(/[^(]*\(([^)]*)/);
  if (!t2)
    return [];
  let r2 = Pt(t2[1]);
  if (!r2.length)
    return [];
  let o2 = r2[0];
  return o2.startsWith("{") && o2.endsWith("}") ? Pt(o2.slice(1, -1).replace(/\s/g, "")).map((s2) => s2.replace(/:.*|=.*/g, "")) : [];
}
n2(lo, "getUsedProps");
function Pt(e2) {
  let t2 = [], r2 = [], o2 = 0;
  for (let s2 = 0; s2 < e2.length; s2++)
    if (e2[s2] === "{" || e2[s2] === "[")
      r2.push(e2[s2] === "{" ? "}" : "]");
    else if (e2[s2] === r2[r2.length - 1])
      r2.pop();
    else if (!r2.length && e2[s2] === ",") {
      let a = e2.substring(o2, s2).trim();
      a && t2.push(a), o2 = s2 + 1;
    }
  let i2 = e2.substring(o2).trim();
  return i2 && t2.push(i2), t2;
}
n2(Pt, "splitByComma");
function Mt(e2, t2, r2) {
  let o2 = r2(e2);
  return (i2) => t2(o2, i2);
}
n2(Mt, "decorateStory");
function $t({
  componentId: e2,
  title: t2,
  kind: r2,
  id: o2,
  name: i2,
  story: s2,
  parameters: a,
  initialArgs: p2,
  argTypes: c,
  ...l2
} = {}) {
  return l2;
}
n2($t, "sanitizeStoryContextUpdate");
function He(e2, t2) {
  let r2 = {}, o2 = n2((s2) => (a) => {
    if (!r2.value)
      throw new Error("Decorated function called without init");
    return r2.value = {
      ...r2.value,
      ...$t(a)
    }, s2(r2.value);
  }, "bindWithContext"), i2 = t2.reduce(
    (s2, a) => Mt(s2, a, o2),
    e2
  );
  return (s2) => (r2.value = s2, i2(s2));
}
n2(He, "defaultDecorateStory");
var D4 = n2((...e2) => {
  let t2 = {}, r2 = e2.filter(Boolean), o2 = r2.reduce((i2, s2) => (Object.entries(s2).forEach(([a, p2]) => {
    let c = i2[a];
    Array.isArray(p2) || typeof c > "u" ? i2[a] = p2 : ee(p2) && ee(c) ? t2[a] = true : typeof p2 < "u" && (i2[a] = p2);
  }), i2), {});
  return Object.keys(t2).forEach((i2) => {
    let s2 = r2.filter(Boolean).map((a) => a[i2]).filter((a) => typeof a < "u");
    s2.every((a) => ee(a)) ? o2[i2] = D4(...s2) : o2[i2] = s2[s2.length - 1];
  }), o2;
}, "combineParameters");
function Ne(e2, t2, r2) {
  let { moduleExport: o2, id: i2, name: s2 } = e2 || {}, a = go(
    e2,
    t2,
    r2
  ), p2 = n2(async (w4) => {
    let d2 = {};
    for (let m2 of [
      b4(r2.loaders),
      b4(t2.loaders),
      b4(e2.loaders)
    ]) {
      if (w4.abortSignal.aborted)
        return d2;
      let f3 = await Promise.all(m2.map((x4) => x4(w4)));
      Object.assign(d2, ...f3);
    }
    return d2;
  }, "applyLoaders"), c = n2(async (w4) => {
    let d2 = new Array();
    for (let m2 of [
      ...b4(r2.beforeEach),
      ...b4(t2.beforeEach),
      ...b4(e2.beforeEach)
    ]) {
      if (w4.abortSignal.aborted)
        return d2;
      let f3 = await m2(w4);
      f3 && d2.push(f3);
    }
    return d2;
  }, "applyBeforeEach"), l2 = n2(async (w4) => {
    let d2 = [
      ...b4(r2.afterEach),
      ...b4(t2.afterEach),
      ...b4(e2.afterEach)
    ].reverse();
    for (let m2 of d2) {
      if (w4.abortSignal.aborted)
        return;
      await m2(w4);
    }
  }, "applyAfterEach"), y = n2((w4) => w4.originalStoryFn(w4.args, w4), "undecoratedStoryFn"), { applyDecorators: u = He, runStep: h2 } = r2, T3 = [
    ...b4(e2?.decorators),
    ...b4(t2?.decorators),
    ...b4(r2?.decorators)
  ], R3 = e2?.userStoryFn || e2?.render || t2.render || r2.render, P5 = Et(u)(y, T3), L3 = n2((w4) => P5(w4), "unboundStoryFn"), O5 = e2?.play ?? t2?.play, F2 = Ot2(O5);
  if (!R3 && !F2)
    throw new Q2({ id: i2 });
  let A3 = n2((w4) => async () => (await w4.renderToCanvas(), w4.canvas), "defaultMount"), S3 = e2.mount ?? t2.mount ?? r2.mount ?? A3, v3 = r2.testingLibraryRender;
  return {
    storyGlobals: {},
    ...a,
    moduleExport: o2,
    id: i2,
    name: s2,
    story: s2,
    originalStoryFn: R3,
    undecoratedStoryFn: y,
    unboundStoryFn: L3,
    applyLoaders: p2,
    applyBeforeEach: c,
    applyAfterEach: l2,
    playFunction: O5,
    runStep: h2,
    mount: S3,
    testingLibraryRender: v3,
    renderToCanvas: r2.renderToCanvas,
    usesMount: F2
  };
}
n2(Ne, "prepareStory");
function go(e2, t2, r2) {
  let o2 = ["dev", "test"], i2 = scope.DOCS_OPTIONS?.autodocs === true ? ["autodocs"] : [], s2 = uc(
    ...o2,
    ...i2,
    ...r2.tags ?? [],
    ...t2.tags ?? [],
    ...e2?.tags ?? []
  ), a = D4(
    r2.parameters,
    t2.parameters,
    e2?.parameters
  ), { argTypesEnhancers: p2 = [], argsEnhancers: c = [] } = r2, l2 = D4(
    r2.argTypes,
    t2.argTypes,
    e2?.argTypes
  );
  if (e2) {
    let O5 = e2?.userStoryFn || e2?.render || t2.render || r2.render;
    a.__isArgsStory = O5 && O5.length > 0;
  }
  let y = {
    ...r2.args,
    ...t2.args,
    ...e2?.args
  }, u = {
    ...t2.globals,
    ...e2?.globals
  }, h2 = {
    componentId: t2.id,
    title: t2.title,
    kind: t2.title,
    // Back compat
    id: e2?.id || t2.id,
    // if there's no story name, we create a fake one since enhancers expect a name
    name: e2?.name || "__meta",
    story: e2?.name || "__meta",
    // Back compat
    component: t2.component,
    subcomponents: t2.subcomponents,
    tags: s2,
    parameters: a,
    initialArgs: y,
    argTypes: l2,
    storyGlobals: u
  };
  h2.argTypes = p2.reduce(
    (O5, F2) => F2({ ...h2, argTypes: O5 }),
    h2.argTypes
  );
  let T3 = { ...y };
  h2.initialArgs = [...c].reduce(
    (O5, F2) => ({
      ...O5,
      ...F2({
        ...h2,
        initialArgs: O5
      })
    }),
    T3
  );
  let { name: R3, story: P5, ...L3 } = h2;
  return L3;
}
n2(go, "preparePartialAnnotations");
function Ft(e2) {
  let { args: t2 } = e2, r2 = {
    ...e2,
    allArgs: void 0,
    argsByTarget: void 0
  };
  if (scope.FEATURES?.argTypeTargetsV7) {
    let s2 = Ct(e2);
    r2 = {
      ...e2,
      allArgs: e2.args,
      argsByTarget: s2,
      args: s2[De] || {}
    };
  }
  let o2 = Object.entries(r2.args).reduce((s2, [a, p2]) => {
    if (!r2.argTypes[a]?.mapping)
      return s2[a] = p2, s2;
    let c = n2((l2) => {
      let y = r2.argTypes[a].mapping;
      return y && l2 in y ? y[l2] : l2;
    }, "mappingFn");
    return s2[a] = Array.isArray(p2) ? p2.map(c) : c(p2), s2;
  }, {}), i2 = Object.entries(o2).reduce((s2, [a, p2]) => {
    let c = r2.argTypes[a] || {};
    return Xr(c, o2, r2.globals) && (s2[a] = p2), s2;
  }, {});
  return { ...r2, unmappedArgs: t2, args: i2 };
}
n2(Ft, "prepareContext");
var je = n2((e2, t2, r2) => {
  let o2 = typeof e2;
  switch (o2) {
    case "boolean":
    case "string":
    case "number":
    case "function":
    case "symbol":
      return { name: o2 };
    default:
      break;
  }
  return e2 ? r2.has(e2) ? (i.warn(W3`
        We've detected a cycle in arg '${t2}'. Args should be JSON-serializable.

        Consider using the mapping feature or fully custom args:
        - Mapping: https://storybook.js.org/docs/writing-stories/args#mapping-to-complex-arg-values
        - Custom args: https://storybook.js.org/docs/essentials/controls#fully-custom-args
      `), { name: "other", value: "cyclic object" }) : (r2.add(e2), Array.isArray(e2) ? { name: "array", value: e2.length > 0 ? je(e2[0], t2, new Set(
    r2
  )) : { name: "other", value: "unknown" } } : { name: "object", value: U3(e2, (s2) => je(s2, t2, new Set(r2))) }) : { name: "object", value: {} };
}, "inferType");
var Be = n2((e2) => {
  let { id: t2, argTypes: r2 = {}, initialArgs: o2 = {} } = e2, i2 = U3(o2, (a, p2) => ({
    name: p2,
    type: je(a, `${t2}.${p2}`, /* @__PURE__ */ new Set())
  })), s2 = U3(r2, (a, p2) => ({
    name: p2
  }));
  return D4(i2, s2, r2);
}, "inferArgTypes");
Be.secondPass = true;
var It = n2((e2, t2) => Array.isArray(t2) ? t2.includes(e2) : e2.match(t2), "matches");
var ze = n2((e2, t2, r2) => !t2 && !r2 ? e2 : e2 && Le(e2, (o2, i2) => {
  let s2 = o2.name || i2.toString();
  return !!(!t2 || It(s2, t2)) && (!r2 || !It(s2, r2));
}), "filterArgTypes");
var bo = n2((e2, t2, r2) => {
  let { type: o2, options: i2 } = e2;
  if (o2) {
    if (r2.color && r2.color.test(t2)) {
      let s2 = o2.name;
      if (s2 === "string")
        return { control: { type: "color" } };
      s2 !== "enum" && i.warn(
        `Addon controls: Control of type color only supports string, received "${s2}" instead`
      );
    }
    if (r2.date && r2.date.test(t2))
      return { control: { type: "date" } };
    switch (o2.name) {
      case "array":
        return { control: { type: "object" } };
      case "boolean":
        return { control: { type: "boolean" } };
      case "string":
        return { control: { type: "text" } };
      case "number":
        return { control: { type: "number" } };
      case "enum": {
        let { value: s2 } = o2;
        return { control: { type: s2?.length <= 5 ? "radio" : "select" }, options: s2 };
      }
      case "function":
      case "symbol":
        return null;
      default:
        return { control: { type: i2 ? "select" : "object" } };
    }
  }
}, "inferControl");
var me = n2((e2) => {
  let {
    argTypes: t2,
    parameters: { __isArgsStory: r2, controls: { include: o2 = null, exclude: i2 = null, matchers: s2 = {} } = {} }
  } = e2;
  if (!r2)
    return t2;
  let a = ze(t2, o2, i2), p2 = U3(a, (c, l2) => c?.type && bo(c, l2.toString(), s2));
  return D4(p2, a);
}, "inferControls");
me.secondPass = true;
function te({
  argTypes: e2,
  globalTypes: t2,
  argTypesEnhancers: r2,
  decorators: o2,
  loaders: i2,
  beforeEach: s2,
  afterEach: a,
  initialGlobals: p2,
  ...c
}) {
  return {
    ...e2 && { argTypes: K3(e2) },
    ...t2 && { globalTypes: K3(t2) },
    decorators: b4(o2),
    loaders: b4(i2),
    beforeEach: b4(s2),
    afterEach: b4(a),
    argTypesEnhancers: [
      ...r2 || [],
      Be,
      // There's an architectural decision to be made regarding embedded addons in core:
      //
      // Option 1: Keep embedded addons but ensure consistency by moving addon-specific code
      // (like inferControls) to live alongside the addon code itself. This maintains the
      // concept of core addons while improving code organization.
      //
      // Option 2: Fully integrate these addons into core, potentially moving UI components
      // into the manager and treating them as core features rather than addons. This is a
      // bigger architectural change requiring careful consideration.
      //
      // For now, we're keeping inferControls here as we need time to properly evaluate
      // these options and their implications. Some features (like Angular's cleanArgsDecorator)
      // currently rely on this behavior.
      //
      // TODO: Make an architectural decision on the handling of core addons
      me
    ],
    initialGlobals: p2,
    ...c
  };
}
n2(te, "normalizeProjectAnnotations");
var Lt = n2((e2) => async () => {
  let t2 = [];
  for (let r2 of e2) {
    let o2 = await r2();
    o2 && t2.unshift(o2);
  }
  return async () => {
    for (let r2 of t2)
      await r2();
  };
}, "composeBeforeAllHooks");
function Ue(e2) {
  return async (t2, r2, o2) => {
    await e2.reduceRight(
      (s2, a) => async () => a(t2, s2, o2),
      async () => r2(o2)
    )();
  };
}
n2(Ue, "composeStepRunners");
function oe(e2, t2) {
  return e2.map((r2) => r2.default?.[t2] ?? r2[t2]).filter(Boolean);
}
n2(oe, "getField");
function Y3(e2, t2, r2 = {}) {
  return oe(e2, t2).reduce((o2, i2) => {
    let s2 = b4(i2);
    return r2.reverseFileOrder ? [...s2, ...o2] : [...o2, ...s2];
  }, []);
}
n2(Y3, "getArrayField");
function ue(e2, t2) {
  return Object.assign({}, ...oe(e2, t2));
}
n2(ue, "getObjectField");
function re2(e2, t2) {
  return oe(e2, t2).pop();
}
n2(re2, "getSingletonField");
function ne2(e2) {
  let t2 = Y3(e2, "argTypesEnhancers"), r2 = oe(e2, "runStep"), o2 = Y3(e2, "beforeAll");
  return {
    parameters: D4(...oe(e2, "parameters")),
    decorators: Y3(e2, "decorators", {
      reverseFileOrder: !(scope.FEATURES?.legacyDecoratorFileOrder ?? false)
    }),
    args: ue(e2, "args"),
    argsEnhancers: Y3(e2, "argsEnhancers"),
    argTypes: ue(e2, "argTypes"),
    argTypesEnhancers: [
      ...t2.filter((i2) => !i2.secondPass),
      ...t2.filter((i2) => i2.secondPass)
    ],
    initialGlobals: ue(e2, "initialGlobals"),
    globalTypes: ue(e2, "globalTypes"),
    loaders: Y3(e2, "loaders"),
    beforeAll: Lt(o2),
    beforeEach: Y3(e2, "beforeEach"),
    afterEach: Y3(e2, "afterEach"),
    render: re2(e2, "render"),
    renderToCanvas: re2(e2, "renderToCanvas"),
    applyDecorators: re2(e2, "applyDecorators"),
    runStep: Ue(r2),
    tags: Y3(e2, "tags"),
    mount: re2(e2, "mount"),
    testingLibraryRender: re2(e2, "testingLibraryRender")
  };
}
n2(ne2, "composeConfigs");
function Dt() {
  try {
    return (
      // @ts-expect-error This property exists in Vitest browser mode
      !!globalThis.__vitest_browser__ || !!globalThis.window?.navigator?.userAgent?.match(/StorybookTestRunner/)
    );
  } catch {
    return false;
  }
}
n2(Dt, "isTestEnvironment");
function _t(e2 = true) {
  if (!("document" in globalThis && "createElement" in globalThis.document))
    return () => {
    };
  let t2 = document.createElement("style");
  t2.textContent = `*, *:before, *:after {
    animation: none !important;
  }`, document.head.appendChild(t2);
  let r2 = document.createElement("style");
  return r2.textContent = `*, *:before, *:after {
    animation-delay: 0s !important;
    animation-direction: ${e2 ? "reverse" : "normal"} !important;
    animation-play-state: paused !important;
    transition: none !important;
  }`, document.head.appendChild(r2), document.body.clientHeight, document.head.removeChild(t2), () => {
    r2.parentNode?.removeChild(r2);
  };
}
n2(_t, "pauseAnimations");
async function Ht(e2) {
  if (!("document" in globalThis && "getAnimations" in globalThis.document && "querySelectorAll" in globalThis.document))
    return;
  let t2 = false;
  await Promise.race([
    // After 50ms, retrieve any running animations and wait for them to finish
    // If new animations are created while waiting, we'll wait for them too
    new Promise((r2) => {
      setTimeout(() => {
        let o2 = [globalThis.document, ...Nt(globalThis.document)], i2 = n2(async () => {
          if (t2 || e2?.aborted)
            return;
          let s2 = o2.flatMap((a) => a?.getAnimations?.() || []).filter((a) => a.playState === "running" && !So(a));
          s2.length > 0 && (await Promise.all(s2.map((a) => a.finished)), await i2());
        }, "checkAnimationsFinished");
        i2().then(r2);
      }, 100);
    }),
    // If animations don't finish within the timeout, continue without waiting
    new Promise(
      (r2) => setTimeout(() => {
        t2 = true, r2(void 0);
      }, 5e3)
    )
  ]);
}
n2(Ht, "waitForAnimations");
function Nt(e2) {
  return [e2, ...e2.querySelectorAll("*")].reduce(
    (t2, r2) => ("shadowRoot" in r2 && r2.shadowRoot && t2.push(r2.shadowRoot, ...Nt(r2.shadowRoot)), t2),
    []
  );
}
n2(Nt, "getShadowRoots");
function So(e2) {
  if (e2 instanceof CSSAnimation && e2.effect instanceof KeyframeEffect && e2.effect.target) {
    let t2 = getComputedStyle(e2.effect.target, e2.effect.pseudoElement), r2 = t2.animationName?.split(", ").indexOf(e2.animationName);
    return t2.animationIterationCount.split(", ")[r2] === "infinite";
  }
  return false;
}
n2(So, "isInfiniteAnimation");
var Ge = class Ge2 {
  constructor() {
    this.reports = [];
  }
  async addReport(t2) {
    this.reports.push(t2);
  }
};
n2(Ge, "ReporterAPI");
var fe = Ge;
var Ro = "ComposedStory";
var wo = "Unnamed Story";
var V4 = [];
function We(e2, t2, r2, o2, i2) {
  if (e2 === void 0)
    throw new Error("Expected a story but received undefined.");
  t2.title = t2.title ?? Ro;
  let s2 = kt(t2), a = i2 || e2.storyName || e2.story?.name || e2.name || wo, p2 = _e(
    a,
    e2,
    s2
  ), c = te(
    ne2([
      o2 ?? globalThis.globalProjectAnnotations ?? {},
      r2 ?? {}
    ])
  ), l2 = Ne(
    p2,
    s2,
    c
  ), u = {
    ...vt(c.globalTypes),
    ...c.initialGlobals,
    ...l2.storyGlobals
  }, h2 = new fe(), T3 = n2(() => {
    let A3 = Ft({
      hooks: new de(),
      globals: u,
      args: { ...l2.initialArgs },
      viewMode: "story",
      reporting: h2,
      loaded: {},
      abortSignal: new AbortController().signal,
      step: n2((S3, v3) => l2.runStep(S3, v3, A3), "step"),
      canvasElement: null,
      canvas: {},
      userEvent: {},
      globalTypes: c.globalTypes,
      ...l2,
      context: null,
      mount: null
    });
    return A3.parameters.__isPortableStory = true, A3.context = A3, l2.renderToCanvas && (A3.renderToCanvas = async () => {
      let S3 = await l2.renderToCanvas?.(
        {
          componentId: l2.componentId,
          title: l2.title,
          id: l2.id,
          name: l2.name,
          tags: l2.tags,
          showMain: n2(() => {
          }, "showMain"),
          showError: n2((v3) => {
            throw new Error(`${v3.title}
${v3.description}`);
          }, "showError"),
          showException: n2((v3) => {
            throw v3;
          }, "showException"),
          forceRemount: true,
          storyContext: A3,
          storyFn: n2(() => l2.unboundStoryFn(A3), "storyFn"),
          unboundStoryFn: l2.unboundStoryFn
        },
        A3.canvasElement
      );
      S3 && V4.push(S3);
    }), A3.mount = l2.mount(A3), A3;
  }, "initializeContext"), R3, P5 = n2(async (A3) => {
    let S3 = T3();
    return S3.canvasElement ??= globalThis?.document?.body, R3 && (S3.loaded = R3.loaded), Object.assign(S3, A3), l2.playFunction(S3);
  }, "play"), L3 = n2((A3) => {
    let S3 = T3();
    return Object.assign(S3, A3), Eo(l2, S3);
  }, "run"), O5 = l2.playFunction ? P5 : void 0;
  return Object.assign(
    n2(function(S3) {
      let v3 = T3();
      return R3 && (v3.loaded = R3.loaded), v3.args = {
        ...v3.initialArgs,
        ...S3
      }, l2.unboundStoryFn(v3);
    }, "storyFn"),
    {
      id: l2.id,
      storyName: a,
      load: n2(async () => {
        for (let S3 of [...V4].reverse())
          await S3();
        V4.length = 0;
        let A3 = T3();
        A3.loaded = await l2.applyLoaders(A3), V4.push(...(await l2.applyBeforeEach(A3)).filter(Boolean)), R3 = A3;
      }, "load"),
      globals: u,
      args: l2.initialArgs,
      parameters: l2.parameters,
      argTypes: l2.argTypes,
      play: O5,
      run: L3,
      reporting: h2,
      tags: l2.tags
    }
  );
}
n2(We, "composeStory");
async function Eo(e2, t2) {
  for (let s2 of [...V4].reverse())
    await s2();
  if (V4.length = 0, !t2.canvasElement) {
    let s2 = document.createElement("div");
    globalThis?.document?.body?.appendChild(s2), t2.canvasElement = s2, V4.push(() => {
      globalThis?.document?.body?.contains(s2) && globalThis?.document?.body?.removeChild(s2);
    });
  }
  if (t2.loaded = await e2.applyLoaders(t2), t2.abortSignal.aborted)
    return;
  V4.push(...(await e2.applyBeforeEach(t2)).filter(Boolean));
  let r2 = e2.playFunction, o2 = e2.usesMount;
  if (o2 || await t2.mount(), t2.abortSignal.aborted)
    return;
  r2 && (o2 || (t2.mount = async () => {
    throw new B2({ playFunction: r2.toString() });
  }), await r2(t2));
  let i2;
  Dt() ? i2 = _t() : await Ht(t2.abortSignal), await e2.applyAfterEach(t2), await i2?.();
}
n2(Eo, "runStory");
var Co = false;
var Ye = "Invariant failed";
function ye(e2, t2) {
  if (!e2) {
    if (Co)
      throw new Error(Ye);
    var r2 = typeof t2 == "function" ? t2() : t2, o2 = r2 ? "".concat(Ye, ": ").concat(r2) : Ye;
    throw new Error(o2);
  }
}
n2(ye, "invariant");
var Ke = {};
xt(Ke, {
  argsEnhancers: () => Mo
});
var Ve = "storybook/actions";
var Ia = `${Ve}/panel`;
var jt = `${Ve}/action-event`;
var La = `${Ve}/action-clear`;
var Bt = {
  depth: 10,
  clearOnStoryChange: true,
  limit: 50
};
var Ut = n2((e2, t2) => {
  let r2 = Object.getPrototypeOf(e2);
  return !r2 || t2(r2) ? r2 : Ut(r2, t2);
}, "findProto");
var Po = n2((e2) => !!(typeof e2 == "object" && e2 && Ut(e2, (t2) => /^Synthetic(?:Base)?Event$/.test(t2.constructor.name)) && typeof e2.persist == "function"), "isReactSyntheticEvent");
var Oo = n2((e2) => {
  if (Po(e2)) {
    let t2 = Object.create(
      e2.constructor.prototype,
      Object.getOwnPropertyDescriptors(e2)
    );
    t2.persist();
    let r2 = Object.getOwnPropertyDescriptor(t2, "view"), o2 = r2?.value;
    return typeof o2 == "object" && o2?.constructor.name === "Window" && Object.defineProperty(t2, "view", {
      ...r2,
      value: Object.create(o2.constructor.prototype)
    }), t2;
  }
  return e2;
}, "serializeArg");
function ie2(e2, t2 = {}) {
  let r2 = {
    ...Bt,
    ...t2
  }, o2 = n2(function(...s2) {
    if (t2.implicit) {
      let T3 = ("__STORYBOOK_PREVIEW__" in scope ? scope.__STORYBOOK_PREVIEW__ : void 0)?.storyRenders.find(
        (R3) => R3.phase === "playing" || R3.phase === "rendering"
      );
      if (T3) {
        let R3 = !globalThis?.FEATURES?.disallowImplicitActionsInRenderV8, P5 = new G2({
          phase: T3.phase,
          name: e2,
          deprecated: R3
        });
        if (R3)
          console.warn(P5);
        else
          throw P5;
      }
    }
    let a = _3.getChannel(), p2 = Date.now().toString(36) + Math.random().toString(36).substring(2), c = 5, l2 = s2.map(Oo), y = s2.length > 1 ? l2 : l2[0], u = {
      id: p2,
      count: 0,
      data: { name: e2, args: y },
      options: {
        ...r2,
        maxDepth: c + (r2.depth || 3)
      }
    };
    a.emit(jt, u);
  }, "actionHandler");
  return o2.isAction = true, o2.implicit = t2.implicit, o2;
}
n2(ie2, "action");
var Gt = n2((e2, t2) => typeof t2[e2] > "u" && !(e2 in t2), "isInInitialArgs");
var Wt = n2((e2) => {
  let {
    initialArgs: t2,
    argTypes: r2,
    id: o2,
    parameters: { actions: i2 }
  } = e2;
  if (!i2 || i2.disable || !i2.argTypesRegex || !r2)
    return {};
  let s2 = new RegExp(i2.argTypesRegex);
  return Object.entries(r2).filter(
    ([p2]) => !!s2.test(p2)
  ).reduce((p2, [c, l2]) => (Gt(c, t2) && (p2[c] = ie2(c, { implicit: true, id: o2 })), p2), {});
}, "inferActionsFromArgTypesRegex");
var Yt = n2((e2) => {
  let {
    initialArgs: t2,
    argTypes: r2,
    parameters: { actions: o2 }
  } = e2;
  return o2?.disable || !r2 ? {} : Object.entries(r2).filter(([s2, a]) => !!a.action).reduce((s2, [a, p2]) => (Gt(a, t2) && (s2[a] = ie2(typeof p2.action == "string" ? p2.action : a)), s2), {});
}, "addActionsFromArgTypes");
var Mo = [
  Yt,
  Wt
];
var qe = {};
xt(qe, {
  loaders: () => Io
});
var Vt = false;
var Fo = n2((e2) => {
  let { parameters: t2 } = e2;
  t2?.actions?.disable || Vt || (abe((r2, o2) => {
    let i2 = r2.getMockName();
    i2 !== "spy" && (!/^next\/.*::/.test(i2) || [
      "next/router::useRouter()",
      "next/navigation::useRouter()",
      "next/navigation::redirect",
      "next/cache::",
      "next/headers::cookies().set",
      "next/headers::cookies().delete",
      "next/headers::headers().set",
      "next/headers::headers().delete"
    ].some((s2) => i2.startsWith(s2))) && ie2(i2)(o2);
  }), Vt = true);
}, "logActionsWhenMockCalled");
var Io = [Fo];
var Xe = n2(() => rc({
  ...Ke,
  ...qe
}), "default");
var Do = "storybook/background";
var Z3 = "backgrounds";
var rp = {
  UPDATE: `${Do}/update`
};
var Kt = {
  light: { name: "light", value: "#F8F8F8" },
  dark: { name: "dark", value: "#333" }
};
var { document: N3 } = globalThis;
var qt = n2(() => globalThis?.matchMedia ? !!globalThis.matchMedia("(prefers-reduced-motion: reduce)")?.matches : false, "isReduceMotionEnabled");
var Ze = n2((e2) => {
  (Array.isArray(e2) ? e2 : [e2]).forEach(_o);
}, "clearStyles");
var _o = n2((e2) => {
  if (!N3)
    return;
  let t2 = N3.getElementById(e2);
  t2 && t2.parentElement && t2.parentElement.removeChild(t2);
}, "clearStyle");
var Xt = n2((e2, t2) => {
  if (!N3)
    return;
  let r2 = N3.getElementById(e2);
  if (r2)
    r2.innerHTML !== t2 && (r2.innerHTML = t2);
  else {
    let o2 = N3.createElement("style");
    o2.setAttribute("id", e2), o2.innerHTML = t2, N3.head.appendChild(o2);
  }
}, "addGridStyle");
var Zt = n2((e2, t2, r2) => {
  if (!N3)
    return;
  let o2 = N3.getElementById(e2);
  if (o2)
    o2.innerHTML !== t2 && (o2.innerHTML = t2);
  else {
    let i2 = N3.createElement("style");
    i2.setAttribute("id", e2), i2.innerHTML = t2;
    let s2 = `addon-backgrounds-grid${r2 ? `-docs-${r2}` : ""}`, a = N3.getElementById(s2);
    a ? a.parentElement?.insertBefore(i2, a) : N3.head.appendChild(i2);
  }
}, "addBackgroundStyle");
var Ho = {
  cellSize: 100,
  cellAmount: 10,
  opacity: 0.8
};
var Qt = "addon-backgrounds";
var er = "addon-backgrounds-grid";
var No = qt() ? "" : "transition: background-color 0.3s;";
var tr = n2((e2, t2) => {
  let { globals: r2 = {}, parameters: o2 = {}, viewMode: i2, id: s2 } = t2, {
    options: a = Kt,
    disable: p2,
    grid: c = Ho
  } = o2[Z3] || {}, l2 = r2[Z3] || {}, y = typeof l2 == "string" ? l2 : l2?.value, u = y ? a[y] : void 0, h2 = typeof u == "string" ? u : u?.value || "transparent", T3 = typeof l2 == "string" ? false : l2.grid || false, R3 = !!u && !p2, P5 = i2 === "docs" ? `#anchor--${s2} .docs-story` : ".sb-show-main", L3 = i2 === "docs" ? `#anchor--${s2} .docs-story` : ".sb-show-main", O5 = o2.layout === void 0 || o2.layout === "padded", F2 = i2 === "docs" ? 20 : O5 ? 16 : 0, { cellAmount: A3, cellSize: S3, opacity: v3, offsetX: w4 = F2, offsetY: d2 = F2 } = c, m2 = i2 === "docs" ? `${Qt}-docs-${s2}` : `${Qt}-color`, f3 = i2 === "docs" ? s2 : null;
  Ot(() => {
    let g3 = `
    ${P5} {
      background: ${h2} !important;
      ${No}
      }`;
    if (!R3) {
      Ze(m2);
      return;
    }
    Zt(m2, g3, f3);
  }, [P5, m2, f3, R3, h2]);
  let x4 = i2 === "docs" ? `${er}-docs-${s2}` : `${er}`;
  return Ot(() => {
    if (!T3) {
      Ze(x4);
      return;
    }
    let g3 = [
      `${S3 * A3}px ${S3 * A3}px`,
      `${S3 * A3}px ${S3 * A3}px`,
      `${S3}px ${S3}px`,
      `${S3}px ${S3}px`
    ].join(", "), E = `
        ${L3} {
          background-size: ${g3} !important;
          background-position: ${w4}px ${d2}px, ${w4}px ${d2}px, ${w4}px ${d2}px, ${w4}px ${d2}px !important;
          background-blend-mode: difference !important;
          background-image: linear-gradient(rgba(130, 130, 130, ${v3}) 1px, transparent 1px),
           linear-gradient(90deg, rgba(130, 130, 130, ${v3}) 1px, transparent 1px),
           linear-gradient(rgba(130, 130, 130, ${v3 / 2}) 1px, transparent 1px),
           linear-gradient(90deg, rgba(130, 130, 130, ${v3 / 2}) 1px, transparent 1px) !important;
        }
      `;
    Xt(x4, E);
  }, [A3, S3, L3, x4, T3, w4, d2, v3]), e2();
}, "withBackgroundAndGrid");
var Bo = globalThis.FEATURES?.backgrounds ? [tr] : [];
var zo = {
  [Z3]: {
    grid: {
      cellSize: 20,
      opacity: 0.5,
      cellAmount: 5
    },
    disable: false
  }
};
var Uo = {
  [Z3]: { value: void 0, grid: false }
};
var Je = n2(() => rc({
  decorators: Bo,
  parameters: zo,
  initialGlobals: Uo
}), "default");
var { step: Yo } = Qs(
  {
    // It seems like the label is unused, but the instrumenter has access to it
    // The context will be bounded later in StoryRender, so that the user can write just:
    // await step("label", (context) => {
    //   // labeled step
    // });
    step: n2(async (e2, t2, r2) => t2(r2), "step")
  },
  { intercept: true }
);
var Qe = n2(() => rc({
  parameters: {
    throwPlayFunctionExceptions: false
  },
  runStep: Yo
}), "default");
var ge = "storybook/highlight";
var rr = `${ge}/add`;
var or = `${ge}/remove`;
var nr = `${ge}/reset`;
var ir = `${ge}/scroll-into-view`;
var et = 2147483647;
var B3 = 28;
var tt = {
  chevronLeft: [
    "M9.10355 10.1464C9.29882 10.3417 9.29882 10.6583 9.10355 10.8536C8.90829 11.0488 8.59171 11.0488 8.39645 10.8536L4.89645 7.35355C4.70118 7.15829 4.70118 6.84171 4.89645 6.64645L8.39645 3.14645C8.59171 2.95118 8.90829 2.95118 9.10355 3.14645C9.29882 3.34171 9.29882 3.65829 9.10355 3.85355L5.95711 7L9.10355 10.1464Z"
  ],
  chevronRight: [
    "M4.89645 10.1464C4.70118 10.3417 4.70118 10.6583 4.89645 10.8536C5.09171 11.0488 5.40829 11.0488 5.60355 10.8536L9.10355 7.35355C9.29882 7.15829 9.29882 6.84171 9.10355 6.64645L5.60355 3.14645C5.40829 2.95118 5.09171 2.95118 4.89645 3.14645C4.70118 3.34171 4.70118 3.65829 4.89645 3.85355L8.04289 7L4.89645 10.1464Z"
  ],
  info: [
    "M7 5.5a.5.5 0 01.5.5v4a.5.5 0 01-1 0V6a.5.5 0 01.5-.5zM7 4.5A.75.75 0 107 3a.75.75 0 000 1.5z",
    "M7 14A7 7 0 107 0a7 7 0 000 14zm0-1A6 6 0 107 1a6 6 0 000 12z"
  ],
  shareAlt: [
    "M2 1.004a1 1 0 00-1 1v10a1 1 0 001 1h10a1 1 0 001-1v-4.5a.5.5 0 00-1 0v4.5H2v-10h4.5a.5.5 0 000-1H2z",
    "M7.354 7.357L12 2.711v1.793a.5.5 0 001 0v-3a.5.5 0 00-.5-.5h-3a.5.5 0 100 1h1.793L6.646 6.65a.5.5 0 10.708.707z"
  ]
};
var Vo = "svg,path,rect,circle,line,polyline,polygon,ellipse,text".split(",");
var M3 = n2((e2, t2 = {}, r2) => {
  let o2 = Vo.includes(e2) ? document.createElementNS("http://www.w3.org/2000/svg", e2) : document.createElement(e2);
  return Object.entries(t2).forEach(([i2, s2]) => {
    /[A-Z]/.test(i2) ? (i2 === "onClick" && (o2.addEventListener("click", s2), o2.addEventListener("keydown", (a) => {
      (a.key === "Enter" || a.key === " ") && (a.preventDefault(), s2());
    })), i2 === "onMouseEnter" && o2.addEventListener("mouseenter", s2), i2 === "onMouseLeave" && o2.addEventListener("mouseleave", s2)) : o2.setAttribute(
      i2,
      s2
    );
  }), r2?.forEach((i2) => {
    if (!(i2 == null || i2 === false))
      try {
        o2.appendChild(i2);
      } catch {
        o2.appendChild(document.createTextNode(String(i2)));
      }
  }), o2;
}, "createElement");
var ae = n2((e2) => tt[e2] && M3(
  "svg",
  { width: "14", height: "14", viewBox: "0 0 14 14", xmlns: "http://www.w3.org/2000/svg" },
  tt[e2].map(
    (t2) => M3("path", {
      fill: "currentColor",
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: t2
    })
  )
), "createIcon");
var sr = n2((e2) => {
  if ("elements" in e2) {
    let { elements: o2, color: i2, style: s2 } = e2;
    return {
      id: void 0,
      priority: 0,
      selectors: o2,
      styles: {
        outline: `2px ${s2} ${i2}`,
        outlineOffset: "2px",
        boxShadow: "0 0 0 6px rgba(255,255,255,0.6)"
      },
      menu: void 0
    };
  }
  let { menu: t2, ...r2 } = e2;
  return {
    id: void 0,
    priority: 0,
    styles: {
      outline: "2px dashed #029cfd"
    },
    ...r2,
    menu: Array.isArray(t2) ? t2.every(Array.isArray) ? t2 : [t2] : void 0
  };
}, "normalizeOptions");
var Ko = n2((e2) => e2 instanceof Function, "isFunction");
var se2 = /* @__PURE__ */ new Map();
var q3 = /* @__PURE__ */ new Map();
var he = /* @__PURE__ */ new Map();
var z4 = n2((e2) => {
  let t2 = Symbol();
  return q3.set(t2, []), se2.set(t2, e2), { get: n2(() => se2.get(t2), "get"), set: n2((a) => {
    let p2 = se2.get(t2), c = Ko(a) ? a(p2) : a;
    c !== p2 && (se2.set(t2, c), q3.get(t2)?.forEach((l2) => {
      he.get(l2)?.(), he.set(l2, l2(c));
    }));
  }, "set"), subscribe: n2((a) => (q3.get(t2)?.push(a), () => {
    let p2 = q3.get(t2);
    p2 && q3.set(
      t2,
      p2.filter((c) => c !== a)
    );
  }), "subscribe"), teardown: n2(() => {
    q3.get(t2)?.forEach((a) => {
      he.get(a)?.(), he.delete(a);
    }), q3.delete(t2), se2.delete(t2);
  }, "teardown") };
}, "useStore");
var rt = n2((e2) => {
  let t2 = document.getElementById("storybook-root"), r2 = /* @__PURE__ */ new Map();
  for (let o2 of e2) {
    let { priority: i2 = 0 } = o2;
    for (let s2 of o2.selectors) {
      let a = [
        ...document.querySelectorAll(
          // Elements matching the selector, excluding storybook elements and their descendants.
          // Necessary to find portaled elements (e.g. children of `body`).
          `:is(${s2}):not([id^="storybook-"], [id^="storybook-"] *, [class^="sb-"], [class^="sb-"] *)`
        ),
        // Elements matching the selector inside the storybook root, as these were excluded above.
        ...t2?.querySelectorAll(s2) || []
      ];
      for (let p2 of a) {
        let c = r2.get(p2);
        (!c || c.priority <= i2) && r2.set(p2, {
          ...o2,
          priority: i2,
          selectors: Array.from(new Set((c?.selectors || []).concat(s2)))
        });
      }
    }
  }
  return r2;
}, "mapElements");
var ar = n2((e2) => Array.from(e2.entries()).map(([t2, {
  selectors: r2,
  styles: o2,
  hoverStyles: i2,
  focusStyles: s2,
  menu: a
}]) => {
  let { top: p2, left: c, width: l2, height: y } = t2.getBoundingClientRect(), { position: u } = getComputedStyle(t2);
  return {
    element: t2,
    selectors: r2,
    styles: o2,
    hoverStyles: i2,
    focusStyles: s2,
    menu: a,
    top: u === "fixed" ? p2 : p2 + window.scrollY,
    left: u === "fixed" ? c : c + window.scrollX,
    width: l2,
    height: y
  };
}).sort((t2, r2) => r2.width * r2.height - t2.width * t2.height), "mapBoxes");
var ot = n2((e2, t2) => {
  let r2 = e2.getBoundingClientRect(), { x: o2, y: i2 } = t2;
  return r2?.top && r2?.left && o2 >= r2.left && o2 <= r2.left + r2.width && i2 >= r2.top && i2 <= r2.top + r2.height;
}, "isOverMenu");
var nt = n2((e2, t2, r2) => {
  if (!t2 || !r2)
    return false;
  let { left: o2, top: i2, width: s2, height: a } = e2;
  a < B3 && (i2 = i2 - Math.round((B3 - a) / 2), a = B3), s2 < B3 && (o2 = o2 - Math.round((B3 - s2) / 2), s2 = B3), t2.style.position === "fixed" && (o2 += window.scrollX, i2 += window.scrollY);
  let { x: p2, y: c } = r2;
  return p2 >= o2 && p2 <= o2 + s2 && c >= i2 && c <= i2 + a;
}, "isTargeted");
var pr = n2((e2, t2, r2 = {}) => {
  let { x: o2, y: i2 } = t2, { margin: s2 = 5, topOffset: a = 0, centered: p2 = false } = r2, { scrollX: c, scrollY: l2, innerHeight: y, innerWidth: u } = window, h2 = Math.min(
    e2.style.position === "fixed" ? i2 - l2 : i2,
    y - e2.clientHeight - s2 - a + l2
  ), T3 = p2 ? e2.clientWidth / 2 : 0, R3 = e2.style.position === "fixed" ? Math.max(Math.min(o2 - c, u - T3 - s2), T3 + s2) : Math.max(
    Math.min(o2, u - T3 - s2 + c),
    T3 + s2 + c
  );
  Object.assign(e2.style, {
    ...R3 !== o2 && { left: `${R3}px` },
    ...h2 !== i2 && { top: `${h2}px` }
  });
}, "keepInViewport");
var it = n2((e2) => {
  window.HTMLElement.prototype.hasOwnProperty("showPopover") && e2.showPopover();
}, "showPopover");
var lr = n2((e2) => {
  window.HTMLElement.prototype.hasOwnProperty("showPopover") && e2.hidePopover();
}, "hidePopover");
var cr = n2((e2) => ({
  top: e2.top,
  left: e2.left,
  width: e2.width,
  height: e2.height,
  selectors: e2.selectors,
  element: {
    attributes: Object.fromEntries(
      Array.from(e2.element.attributes).map((t2) => [t2.name, t2.value])
    ),
    localName: e2.element.localName,
    tagName: e2.element.tagName,
    outerHTML: e2.element.outerHTML
  }
}), "getEventDetails");
var C3 = "storybook-highlights-menu";
var dr = "storybook-highlights-root";
var Xo = "storybook-root";
var mr = n2((e2) => {
  if (globalThis.__STORYBOOK_HIGHLIGHT_INITIALIZED)
    return;
  globalThis.__STORYBOOK_HIGHLIGHT_INITIALIZED = true;
  let { document: t2 } = globalThis, r2 = z4([]), o2 = z4(/* @__PURE__ */ new Map()), i2 = z4([]), s2 = z4(), a = z4(), p2 = z4([]), c = z4([]), l2 = z4(), y = z4(), u = t2.getElementById(dr);
  r2.subscribe(() => {
    u || (u = M3("div", { id: dr }), t2.body.appendChild(u));
  }), r2.subscribe((d2) => {
    let m2 = t2.getElementById(Xo);
    if (!m2)
      return;
    o2.set(rt(d2));
    let f3 = new MutationObserver(() => o2.set(rt(d2)));
    return f3.observe(m2, { subtree: true, childList: true }), () => {
      f3.disconnect();
    };
  }), o2.subscribe((d2) => {
    let m2 = n2(() => requestAnimationFrame(() => i2.set(ar(d2))), "updateBoxes"), f3 = new ResizeObserver(m2);
    f3.observe(t2.body), Array.from(d2.keys()).forEach((g3) => f3.observe(g3));
    let x4 = Array.from(t2.body.querySelectorAll("*")).filter((g3) => {
      let { overflow: E, overflowX: I5, overflowY: k4 } = window.getComputedStyle(g3);
      return ["auto", "scroll"].some((H3) => [E, I5, k4].includes(H3));
    });
    return x4.forEach((g3) => g3.addEventListener("scroll", m2)), () => {
      f3.disconnect(), x4.forEach((g3) => g3.removeEventListener("scroll", m2));
    };
  }), o2.subscribe((d2) => {
    let m2 = Array.from(d2.keys()).filter(({ style: x4 }) => x4.position === "sticky"), f3 = n2(() => requestAnimationFrame(() => {
      i2.set(
        (x4) => x4.map((g3) => {
          if (m2.includes(g3.element)) {
            let { top: E, left: I5 } = g3.element.getBoundingClientRect();
            return { ...g3, top: E + window.scrollY, left: I5 + window.scrollX };
          }
          return g3;
        })
      );
    }), "updateBoxes");
    return t2.addEventListener("scroll", f3), () => t2.removeEventListener("scroll", f3);
  }), o2.subscribe((d2) => {
    p2.set((m2) => m2.filter(({ element: f3 }) => d2.has(f3)));
  }), p2.subscribe((d2) => {
    d2.length ? (y.set((m2) => d2.some((f3) => f3.element === m2?.element) ? m2 : void 0), l2.set((m2) => d2.some((f3) => f3.element === m2?.element) ? m2 : void 0)) : (y.set(void 0), l2.set(void 0), s2.set(void 0));
  });
  let h2 = new Map(/* @__PURE__ */ new Map());
  r2.subscribe((d2) => {
    d2.forEach(({ keyframes: m2 }) => {
      if (m2) {
        let f3 = h2.get(m2);
        f3 || (f3 = t2.createElement("style"), f3.setAttribute("data-highlight", "keyframes"), h2.set(m2, f3), t2.head.appendChild(f3)), f3.innerHTML = m2;
      }
    }), h2.forEach((m2, f3) => {
      d2.some((x4) => x4.keyframes === f3) || (m2.remove(), h2.delete(f3));
    });
  });
  let T3 = new Map(/* @__PURE__ */ new Map());
  i2.subscribe((d2) => {
    d2.forEach((m2) => {
      let f3 = T3.get(m2.element);
      if (u && !f3) {
        let x4 = {
          popover: "manual",
          "data-highlight-dimensions": `w${m2.width.toFixed(0)}h${m2.height.toFixed(0)}`,
          "data-highlight-coordinates": `x${m2.left.toFixed(0)}y${m2.top.toFixed(0)}`
        };
        f3 = u.appendChild(
          M3("div", x4, [M3("div")])
        ), T3.set(m2.element, f3);
      }
    }), T3.forEach((m2, f3) => {
      d2.some(({ element: x4 }) => x4 === f3) || (m2.remove(), T3.delete(f3));
    });
  }), i2.subscribe((d2) => {
    let m2 = d2.filter((x4) => x4.menu);
    if (!m2.length)
      return;
    let f3 = n2((x4) => {
      requestAnimationFrame(() => {
        let g3 = t2.getElementById(C3), E = { x: x4.pageX, y: x4.pageY };
        if (g3 && !ot(g3, E)) {
          let I5 = m2.filter((k4) => {
            let H3 = T3.get(k4.element);
            return nt(k4, H3, E);
          });
          s2.set(I5.length ? E : void 0), p2.set(I5);
        }
      });
    }, "onClick");
    return t2.addEventListener("click", f3), () => t2.removeEventListener("click", f3);
  });
  let R3 = n2(() => {
    let d2 = t2.getElementById(C3), m2 = a.get();
    !m2 || d2 && ot(d2, m2) || c.set((f3) => {
      let x4 = i2.get().filter((k4) => {
        let H3 = T3.get(k4.element);
        return nt(k4, H3, m2);
      }), g3 = f3.filter((k4) => x4.includes(k4)), E = x4.filter((k4) => !f3.includes(k4)), I5 = f3.length - g3.length;
      return E.length || I5 ? [...g3, ...E] : f3;
    });
  }, "updateHovered");
  a.subscribe(R3), i2.subscribe(R3);
  let P5 = n2(() => {
    let d2 = y.get(), m2 = d2 ? [d2] : p2.get(), f3 = m2.length === 1 ? m2[0] : l2.get(), x4 = s2.get() !== void 0;
    i2.get().forEach((g3) => {
      let E = T3.get(g3.element);
      if (E) {
        let I5 = f3 === g3, k4 = x4 ? f3 ? I5 : m2.includes(g3) : c.get()?.includes(g3);
        Object.assign(E.style, {
          animation: "none",
          background: "transparent",
          border: "none",
          boxSizing: "border-box",
          outline: "none",
          outlineOffset: "0px",
          ...g3.styles,
          ...k4 ? g3.hoverStyles : {},
          ...I5 ? g3.focusStyles : {},
          position: getComputedStyle(g3.element).position === "fixed" ? "fixed" : "absolute",
          zIndex: et - 10,
          top: `${g3.top}px`,
          left: `${g3.left}px`,
          width: `${g3.width}px`,
          height: `${g3.height}px`,
          margin: 0,
          padding: 0,
          cursor: g3.menu && k4 ? "pointer" : "default",
          pointerEvents: g3.menu ? "auto" : "none",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          overflow: "visible"
        }), Object.assign(E.children[0].style, {
          width: "100%",
          height: "100%",
          minHeight: `${B3}px`,
          minWidth: `${B3}px`,
          boxSizing: "content-box",
          padding: E.style.outlineWidth || "0px"
        }), it(E);
      }
    });
  }, "updateBoxStyles");
  i2.subscribe(P5), p2.subscribe(P5), c.subscribe(P5), l2.subscribe(P5), y.subscribe(P5);
  let L3 = n2(() => {
    if (!u)
      return;
    let d2 = t2.getElementById(C3);
    if (d2)
      d2.innerHTML = "";
    else {
      let g3 = { id: C3, popover: "manual" };
      d2 = u.appendChild(M3("div", g3)), u.appendChild(
        M3("style", {}, [
          `
            #${C3} {
              position: absolute;
              z-index: ${et};
              width: 300px;
              padding: 0px;
              margin: 15px 0 0 0;
              transform: translateX(-50%);
              font-family: "Nunito Sans", -apple-system, ".SFNSText-Regular", "San Francisco", BlinkMacSystemFont, "Segoe UI", "Helvetica Neue", Helvetica, Arial, sans-serif;
              font-size: 12px;
              background: white;
              border: none;
              border-radius: 6px;
              box-shadow: 0 2px 5px 0 rgba(0, 0, 0, 0.05), 0 5px 15px 0 rgba(0, 0, 0, 0.1);
              color: #2E3438;
            }
            #${C3} ul {
              list-style: none;
              margin: 0;
              padding: 0;
            }
            #${C3} > ul {
              max-height: 300px;
              overflow-y: auto;
              padding: 4px 0;
            }
            #${C3} li {
              padding: 0 4px;
              margin: 0;
            }
            #${C3} li > :not(ul) {
              display: flex;
              padding: 8px;
              margin: 0;
              align-items: center;
              gap: 8px;
              border-radius: 4px;
            }
            #${C3} button {
              width: 100%;
              border: 0;
              background: transparent;
              color: inherit;
              text-align: left;
              font-family: inherit;
              font-size: inherit;
            }
            #${C3} button:focus-visible {
              outline-color: #029CFD;
            }
            #${C3} button:hover {
              background: rgba(2, 156, 253, 0.07);
              color: #029CFD;
              cursor: pointer;
            }
            #${C3} li code {
              white-space: nowrap;
              overflow: hidden;
              text-overflow: ellipsis;
              line-height: 16px;
              font-size: 11px;
            }
            #${C3} li svg {
              flex-shrink: 0;
              margin: 1px;
              color: #73828C;
            }
            #${C3} li > button:hover svg, #${C3} li > button:focus-visible svg {
              color: #029CFD;
            }
            #${C3} .element-list li svg {
              display: none;
            }
            #${C3} li.selectable svg, #${C3} li.selected svg {
              display: block;
            }
            #${C3} .menu-list {
              border-top: 1px solid rgba(38, 85, 115, 0.15);
            }
            #${C3} .menu-list > li:not(:last-child) {
              padding-bottom: 4px;
              margin-bottom: 4px;
              border-bottom: 1px solid rgba(38, 85, 115, 0.15);
            }
            #${C3} .menu-items, #${C3} .menu-items li {
              padding: 0;
            }
            #${C3} .menu-item {
              display: flex;
            }
            #${C3} .menu-item-content {
              display: flex;
              flex-direction: column;
              flex-grow: 1;
            }
          `
        ])
      );
    }
    let m2 = y.get(), f3 = m2 ? [m2] : p2.get();
    if (f3.length && (d2.style.position = getComputedStyle(f3[0].element).position === "fixed" ? "fixed" : "absolute", d2.appendChild(
      M3(
        "ul",
        { class: "element-list" },
        f3.map((g3) => {
          let E = f3.length > 1 && !!g3.menu?.some(
            (H3) => H3.some(
              (X4) => !X4.selectors || X4.selectors.some((le) => g3.selectors.includes(le))
            )
          ), I5 = E ? {
            class: "selectable",
            onClick: n2(() => y.set(g3), "onClick"),
            onMouseEnter: n2(() => l2.set(g3), "onMouseEnter"),
            onMouseLeave: n2(() => l2.set(void 0), "onMouseLeave")
          } : m2 ? { class: "selected", onClick: n2(() => y.set(void 0), "onClick") } : {}, k4 = E || m2;
          return M3("li", I5, [
            M3(k4 ? "button" : "div", k4 ? { type: "button" } : {}, [
              m2 ? ae("chevronLeft") : null,
              M3("code", {}, [g3.element.outerHTML]),
              E ? ae("chevronRight") : null
            ])
          ]);
        })
      )
    )), y.get() || p2.get().length === 1) {
      let g3 = y.get() || p2.get()[0], E = g3.menu?.filter(
        (I5) => I5.some(
          (k4) => !k4.selectors || k4.selectors.some((H3) => g3.selectors.includes(H3))
        )
      );
      E?.length && d2.appendChild(
        M3(
          "ul",
          { class: "menu-list" },
          E.map(
            (I5) => M3("li", {}, [
              M3(
                "ul",
                { class: "menu-items" },
                I5.map(
                  ({ id: k4, title: H3, description: X4, iconLeft: le, iconRight: gt, clickEvent: ht2 }) => {
                    let we2 = ht2 && (() => e2.emit(ht2, k4, cr(g3)));
                    return M3("li", {}, [
                      M3(
                        we2 ? "button" : "div",
                        we2 ? { class: "menu-item", type: "button", onClick: we2 } : { class: "menu-item" },
                        [
                          le ? ae(le) : null,
                          M3("div", { class: "menu-item-content" }, [
                            M3(X4 ? "strong" : "span", {}, [H3]),
                            X4 && M3("span", {}, [X4])
                          ]),
                          gt ? ae(gt) : null
                        ]
                      )
                    ]);
                  }
                )
              )
            ])
          )
        )
      );
    }
    let x4 = s2.get();
    x4 ? (Object.assign(d2.style, {
      display: "block",
      left: `${d2.style.position === "fixed" ? x4.x - window.scrollX : x4.x}px`,
      top: `${d2.style.position === "fixed" ? x4.y - window.scrollY : x4.y}px`
    }), it(d2), requestAnimationFrame(() => pr(d2, x4, { topOffset: 15, centered: true }))) : (lr(d2), Object.assign(d2.style, { display: "none" }));
  }, "renderMenu");
  p2.subscribe(L3), y.subscribe(L3);
  let O5 = n2((d2) => {
    let m2 = sr(d2);
    r2.set((f3) => {
      let x4 = m2.id ? f3.filter((g3) => g3.id !== m2.id) : f3;
      return m2.selectors?.length ? [...x4, m2] : x4;
    });
  }, "addHighlight"), F2 = n2((d2) => {
    d2 && r2.set((m2) => m2.filter((f3) => f3.id !== d2));
  }, "removeHighlight"), A3 = n2(() => {
    r2.set([]), o2.set(/* @__PURE__ */ new Map()), i2.set([]), s2.set(void 0), a.set(void 0), p2.set([]), c.set([]), l2.set(void 0), y.set(void 0);
  }, "resetState"), S3, v3 = n2((d2, m2) => {
    let f3 = "scrollIntoView-highlight";
    clearTimeout(S3), F2(f3);
    let x4 = t2.querySelector(d2);
    if (!x4) {
      console.warn(`Cannot scroll into view: ${d2} not found`);
      return;
    }
    x4.scrollIntoView({ behavior: "smooth", block: "center", ...m2 });
    let g3 = `kf-${Math.random().toString(36).substring(2, 15)}`;
    r2.set((E) => [
      ...E,
      {
        id: f3,
        priority: 1e3,
        selectors: [d2],
        styles: {
          outline: "2px solid #1EA7FD",
          outlineOffset: "-1px",
          animation: `${g3} 3s linear forwards`
        },
        keyframes: `@keyframes ${g3} {
          0% { outline: 2px solid #1EA7FD; }
          20% { outline: 2px solid #1EA7FD00; }
          40% { outline: 2px solid #1EA7FD; }
          60% { outline: 2px solid #1EA7FD00; }
          80% { outline: 2px solid #1EA7FD; }
          100% { outline: 2px solid #1EA7FD00; }
        }`
      }
    ]), S3 = setTimeout(() => F2(f3), 3500);
  }, "scrollIntoView"), w4 = n2((d2) => {
    requestAnimationFrame(() => a.set({ x: d2.pageX, y: d2.pageY }));
  }, "onMouseMove");
  t2.body.addEventListener("mousemove", w4), e2.on(rr, O5), e2.on(or, F2), e2.on(nr, A3), e2.on(ir, v3), e2.on(B, ({ newPhase: d2 }) => {
    d2 === "loading" && A3();
  });
}, "useHighlights");
globalThis?.FEATURES?.highlight && _3?.ready && _3.ready().then(mr);
var st = n2(() => rc({}), "default");
var xe = "storybook/measure-addon";
var Hp = `${xe}/tool`;
var fr = "measureEnabled";
var Np = {
  RESULT: `${xe}/result`,
  REQUEST: `${xe}/request`,
  CLEAR: `${xe}/clear`
};
function yr() {
  let e2 = scope.document.documentElement, t2 = Math.max(e2.scrollHeight, e2.offsetHeight);
  return { width: Math.max(e2.scrollWidth, e2.offsetWidth), height: t2 };
}
n2(yr, "getDocumentWidthAndHeight");
function Jo() {
  let e2 = scope.document.createElement("canvas");
  e2.id = "storybook-addon-measure";
  let t2 = e2.getContext("2d");
  ye(t2 != null);
  let { width: r2, height: o2 } = yr();
  return at(e2, t2, { width: r2, height: o2 }), e2.style.position = "absolute", e2.style.left = "0", e2.style.top = "0", e2.style.zIndex = "2147483647", e2.style.pointerEvents = "none", scope.document.body.appendChild(e2), { canvas: e2, context: t2, width: r2, height: o2 };
}
n2(Jo, "createCanvas");
function at(e2, t2, { width: r2, height: o2 }) {
  e2.style.width = `${r2}px`, e2.style.height = `${o2}px`;
  let i2 = scope.window.devicePixelRatio;
  e2.width = Math.floor(r2 * i2), e2.height = Math.floor(o2 * i2), t2.scale(i2, i2);
}
n2(at, "setCanvasWidthAndHeight");
var $3 = {};
function gr() {
  $3.canvas || ($3 = Jo());
}
n2(gr, "init");
function hr() {
  $3.context && $3.context.clearRect(0, 0, $3.width ?? 0, $3.height ?? 0);
}
n2(hr, "clear");
function xr(e2) {
  hr(), e2($3.context);
}
n2(xr, "draw");
function br() {
  ye($3.canvas, "Canvas should exist in the state."), ye($3.context, "Context should exist in the state."), at($3.canvas, $3.context, {
    width: 0,
    height: 0
  });
  let { width: e2, height: t2 } = yr();
  at($3.canvas, $3.context, { width: e2, height: t2 }), $3.width = e2, $3.height = t2;
}
n2(br, "rescale");
function Tr() {
  $3.canvas && (hr(), $3.canvas.parentNode?.removeChild($3.canvas), $3 = {});
}
n2(Tr, "destroy");
var J3 = {
  margin: "#f6b26b",
  border: "#ffe599",
  padding: "#93c47d",
  content: "#6fa8dc",
  text: "#232020"
};
var G3 = 6;
function Sr(e2, { x: t2, y: r2, w: o2, h: i2, r: s2 }) {
  t2 = t2 - o2 / 2, r2 = r2 - i2 / 2, o2 < 2 * s2 && (s2 = o2 / 2), i2 < 2 * s2 && (s2 = i2 / 2), e2.beginPath(), e2.moveTo(t2 + s2, r2), e2.arcTo(t2 + o2, r2, t2 + o2, r2 + i2, s2), e2.arcTo(t2 + o2, r2 + i2, t2, r2 + i2, s2), e2.arcTo(t2, r2 + i2, t2, r2, s2), e2.arcTo(t2, r2, t2 + o2, r2, s2), e2.closePath();
}
n2(Sr, "roundedRect");
function Qo(e2, { padding: t2, border: r2, width: o2, height: i2, top: s2, left: a }) {
  let p2 = o2 - r2.left - r2.right - t2.left - t2.right, c = i2 - t2.top - t2.bottom - r2.top - r2.bottom, l2 = a + r2.left + t2.left, y = s2 + r2.top + t2.top;
  return e2 === "top" ? l2 += p2 / 2 : e2 === "right" ? (l2 += p2, y += c / 2) : e2 === "bottom" ? (l2 += p2 / 2, y += c) : e2 === "left" ? y += c / 2 : e2 === "center" && (l2 += p2 / 2, y += c / 2), { x: l2, y };
}
n2(Qo, "positionCoordinate");
function en(e2, t2, { margin: r2, border: o2, padding: i2 }, s2, a) {
  let p2 = n2((h2) => 0, "shift"), c = 0, l2 = 0, y = a ? 1 : 0.5, u = a ? s2 * 2 : 0;
  return e2 === "padding" ? p2 = n2((h2) => i2[h2] * y + u, "shift") : e2 === "border" ? p2 = n2((h2) => i2[h2] + o2[h2] * y + u, "shift") : e2 === "margin" && (p2 = n2((h2) => i2[h2] + o2[h2] + r2[h2] * y + u, "shift")), t2 === "top" ? l2 = -p2("top") : t2 === "right" ? c = p2("right") : t2 === "bottom" ? l2 = p2("bottom") : t2 === "left" && (c = -p2("left")), { offsetX: c, offsetY: l2 };
}
n2(en, "offset");
function tn(e2, t2) {
  return Math.abs(e2.x - t2.x) < Math.abs(e2.w + t2.w) / 2 && Math.abs(e2.y - t2.y) < Math.abs(e2.h + t2.h) / 2;
}
n2(tn, "collide");
function rn(e2, t2, r2) {
  return e2 === "top" ? t2.y = r2.y - r2.h - G3 : e2 === "right" ? t2.x = r2.x + r2.w / 2 + G3 + t2.w / 2 : e2 === "bottom" ? t2.y = r2.y + r2.h + G3 : e2 === "left" && (t2.x = r2.x - r2.w / 2 - G3 - t2.w / 2), { x: t2.x, y: t2.y };
}
n2(rn, "overlapAdjustment");
function Ar(e2, t2, { x: r2, y: o2, w: i2, h: s2 }, a) {
  return Sr(e2, { x: r2, y: o2, w: i2, h: s2, r: 3 }), e2.fillStyle = `${J3[t2]}dd`, e2.fill(), e2.strokeStyle = J3[t2], e2.stroke(), e2.fillStyle = J3.text, e2.fillText(a, r2, o2), Sr(e2, { x: r2, y: o2, w: i2, h: s2, r: 3 }), e2.fillStyle = `${J3[t2]}dd`, e2.fill(), e2.strokeStyle = J3[t2], e2.stroke(), e2.fillStyle = J3.text, e2.fillText(a, r2, o2), { x: r2, y: o2, w: i2, h: s2 };
}
n2(Ar, "textWithRect");
function Rr(e2, t2) {
  e2.font = "600 12px monospace", e2.textBaseline = "middle", e2.textAlign = "center";
  let r2 = e2.measureText(t2), o2 = r2.actualBoundingBoxAscent + r2.actualBoundingBoxDescent, i2 = r2.width + G3 * 2, s2 = o2 + G3 * 2;
  return { w: i2, h: s2 };
}
n2(Rr, "configureText");
function on(e2, t2, { type: r2, position: o2 = "center", text: i2 }, s2, a = false) {
  let { x: p2, y: c } = Qo(o2, t2), { offsetX: l2, offsetY: y } = en(r2, o2, t2, G3 + 1, a);
  p2 += l2, c += y;
  let { w: u, h: h2 } = Rr(e2, i2);
  if (s2 && tn({ x: p2, y: c, w: u, h: h2 }, s2)) {
    let T3 = rn(o2, { x: p2, y: c, w: u, h: h2 }, s2);
    p2 = T3.x, c = T3.y;
  }
  return Ar(e2, r2, { x: p2, y: c, w: u, h: h2 }, i2);
}
n2(on, "drawLabel");
function nn(e2, { w: t2, h: r2 }) {
  let o2 = t2 * 0.5 + G3, i2 = r2 * 0.5 + G3;
  return {
    offsetX: (e2.x === "left" ? -1 : 1) * o2,
    offsetY: (e2.y === "top" ? -1 : 1) * i2
  };
}
n2(nn, "floatingOffset");
function sn(e2, t2, { type: r2, text: o2 }) {
  let { floatingAlignment: i2, extremities: s2 } = t2, a = s2[i2.x], p2 = s2[i2.y], { w: c, h: l2 } = Rr(e2, o2), { offsetX: y, offsetY: u } = nn(i2, {
    w: c,
    h: l2
  });
  return a += y, p2 += u, Ar(e2, r2, { x: a, y: p2, w: c, h: l2 }, o2);
}
n2(sn, "drawFloatingLabel");
function pe(e2, t2, r2, o2) {
  let i2 = [];
  r2.forEach((s2, a) => {
    let p2 = o2 && s2.position === "center" ? sn(e2, t2, s2) : on(e2, t2, s2, i2[a - 1], o2);
    i2[a] = p2;
  });
}
n2(pe, "drawStack");
function wr(e2, t2, r2, o2) {
  let i2 = r2.reduce((s2, a) => (Object.prototype.hasOwnProperty.call(s2, a.position) || (s2[a.position] = []), s2[a.position]?.push(a), s2), {});
  i2.top && pe(e2, t2, i2.top, o2), i2.right && pe(e2, t2, i2.right, o2), i2.bottom && pe(e2, t2, i2.bottom, o2), i2.left && pe(e2, t2, i2.left, o2), i2.center && pe(e2, t2, i2.center, o2);
}
n2(wr, "labelStacks");
var Te = {
  margin: "#f6b26ba8",
  border: "#ffe599a8",
  padding: "#93c47d8c",
  content: "#6fa8dca8"
};
var Er = 30;
function _4(e2) {
  return parseInt(e2.replace("px", ""), 10);
}
n2(_4, "pxToNumber");
function Q3(e2) {
  return Number.isInteger(e2) ? e2 : e2.toFixed(2);
}
n2(Q3, "round");
function pt(e2) {
  return e2.filter((t2) => t2.text !== 0 && t2.text !== "0");
}
n2(pt, "filterZeroValues");
function an(e2) {
  let t2 = {
    top: scope.window.scrollY,
    bottom: scope.window.scrollY + scope.window.innerHeight,
    left: scope.window.scrollX,
    right: scope.window.scrollX + scope.window.innerWidth
  }, r2 = {
    top: Math.abs(t2.top - e2.top),
    bottom: Math.abs(t2.bottom - e2.bottom),
    left: Math.abs(t2.left - e2.left),
    right: Math.abs(t2.right - e2.right)
  };
  return {
    x: r2.left > r2.right ? "left" : "right",
    y: r2.top > r2.bottom ? "top" : "bottom"
  };
}
n2(an, "floatingAlignment");
function pn(e2) {
  let t2 = scope.getComputedStyle(e2), { top: r2, left: o2, right: i2, bottom: s2, width: a, height: p2 } = e2.getBoundingClientRect(), {
    marginTop: c,
    marginBottom: l2,
    marginLeft: y,
    marginRight: u,
    paddingTop: h2,
    paddingBottom: T3,
    paddingLeft: R3,
    paddingRight: P5,
    borderBottomWidth: L3,
    borderTopWidth: O5,
    borderLeftWidth: F2,
    borderRightWidth: A3
  } = t2;
  r2 = r2 + scope.window.scrollY, o2 = o2 + scope.window.scrollX, s2 = s2 + scope.window.scrollY, i2 = i2 + scope.window.scrollX;
  let S3 = {
    top: _4(c),
    bottom: _4(l2),
    left: _4(y),
    right: _4(u)
  }, v3 = {
    top: _4(h2),
    bottom: _4(T3),
    left: _4(R3),
    right: _4(P5)
  }, w4 = {
    top: _4(O5),
    bottom: _4(L3),
    left: _4(F2),
    right: _4(A3)
  }, d2 = {
    top: r2 - S3.top,
    bottom: s2 + S3.bottom,
    left: o2 - S3.left,
    right: i2 + S3.right
  };
  return {
    margin: S3,
    padding: v3,
    border: w4,
    top: r2,
    left: o2,
    bottom: s2,
    right: i2,
    width: a,
    height: p2,
    extremities: d2,
    floatingAlignment: an(d2)
  };
}
n2(pn, "measureElement");
function ln(e2, { margin: t2, width: r2, height: o2, top: i2, left: s2, bottom: a, right: p2 }) {
  let c = o2 + t2.bottom + t2.top;
  e2.fillStyle = Te.margin, e2.fillRect(s2, i2 - t2.top, r2, t2.top), e2.fillRect(p2, i2 - t2.top, t2.right, c), e2.fillRect(s2, a, r2, t2.bottom), e2.fillRect(
    s2 - t2.left,
    i2 - t2.top,
    t2.left,
    c
  );
  let l2 = [
    {
      type: "margin",
      text: Q3(t2.top),
      position: "top"
    },
    {
      type: "margin",
      text: Q3(t2.right),
      position: "right"
    },
    {
      type: "margin",
      text: Q3(t2.bottom),
      position: "bottom"
    },
    {
      type: "margin",
      text: Q3(t2.left),
      position: "left"
    }
  ];
  return pt(l2);
}
n2(ln, "drawMargin");
function cn2(e2, { padding: t2, border: r2, width: o2, height: i2, top: s2, left: a, bottom: p2, right: c }) {
  let l2 = o2 - r2.left - r2.right, y = i2 - t2.top - t2.bottom - r2.top - r2.bottom;
  e2.fillStyle = Te.padding, e2.fillRect(a + r2.left, s2 + r2.top, l2, t2.top), e2.fillRect(
    c - t2.right - r2.right,
    s2 + t2.top + r2.top,
    t2.right,
    y
  ), e2.fillRect(
    a + r2.left,
    p2 - t2.bottom - r2.bottom,
    l2,
    t2.bottom
  ), e2.fillRect(a + r2.left, s2 + t2.top + r2.top, t2.left, y);
  let u = [
    {
      type: "padding",
      text: t2.top,
      position: "top"
    },
    {
      type: "padding",
      text: t2.right,
      position: "right"
    },
    {
      type: "padding",
      text: t2.bottom,
      position: "bottom"
    },
    {
      type: "padding",
      text: t2.left,
      position: "left"
    }
  ];
  return pt(u);
}
n2(cn2, "drawPadding");
function dn(e2, { border: t2, width: r2, height: o2, top: i2, left: s2, bottom: a, right: p2 }) {
  let c = o2 - t2.top - t2.bottom;
  e2.fillStyle = Te.border, e2.fillRect(s2, i2, r2, t2.top), e2.fillRect(s2, a - t2.bottom, r2, t2.bottom), e2.fillRect(s2, i2 + t2.top, t2.left, c), e2.fillRect(
    p2 - t2.right,
    i2 + t2.top,
    t2.right,
    c
  );
  let l2 = [
    {
      type: "border",
      text: t2.top,
      position: "top"
    },
    {
      type: "border",
      text: t2.right,
      position: "right"
    },
    {
      type: "border",
      text: t2.bottom,
      position: "bottom"
    },
    {
      type: "border",
      text: t2.left,
      position: "left"
    }
  ];
  return pt(l2);
}
n2(dn, "drawBorder");
function mn(e2, { padding: t2, border: r2, width: o2, height: i2, top: s2, left: a }) {
  let p2 = o2 - r2.left - r2.right - t2.left - t2.right, c = i2 - t2.top - t2.bottom - r2.top - r2.bottom;
  return e2.fillStyle = Te.content, e2.fillRect(
    a + r2.left + t2.left,
    s2 + r2.top + t2.top,
    p2,
    c
  ), [
    {
      type: "content",
      position: "center",
      text: `${Q3(p2)} x ${Q3(c)}`
    }
  ];
}
n2(mn, "drawContent");
function un(e2) {
  return (t2) => {
    if (e2 && t2) {
      let r2 = pn(e2), o2 = ln(t2, r2), i2 = cn2(t2, r2), s2 = dn(t2, r2), a = mn(t2, r2), p2 = r2.width <= Er * 3 || r2.height <= Er;
      wr(
        t2,
        r2,
        [...a, ...i2, ...s2, ...o2],
        p2
      );
    }
  };
}
n2(un, "drawBoxModel");
function Cr(e2) {
  xr(un(e2));
}
n2(Cr, "drawSelectedElement");
var vr = n2((e2, t2) => {
  let r2 = scope.document.elementFromPoint(e2, t2), o2 = n2((s2) => {
    if (s2 && s2.shadowRoot) {
      let a = s2.shadowRoot.elementFromPoint(e2, t2);
      return s2.isEqualNode(a) ? s2 : a.shadowRoot ? o2(a) : a;
    }
    return s2;
  }, "crawlShadows");
  return o2(r2) || r2;
}, "deepElementFromPoint");
var Pr;
var Se = { x: 0, y: 0 };
function Or(e2, t2) {
  Pr = vr(e2, t2), Cr(Pr);
}
n2(Or, "findAndDrawElement");
var Mr = n2((e2, t2) => {
  let { measureEnabled: r2 } = t2.globals || {};
  return Ot(() => {
    if (typeof globalThis.document > "u")
      return;
    let o2 = n2((i2) => {
      window.requestAnimationFrame(() => {
        i2.stopPropagation(), Se.x = i2.clientX, Se.y = i2.clientY;
      });
    }, "onPointerMove");
    return globalThis.document.addEventListener("pointermove", o2), () => {
      globalThis.document.removeEventListener("pointermove", o2);
    };
  }, []), Ot(() => {
    let o2 = n2((s2) => {
      window.requestAnimationFrame(() => {
        s2.stopPropagation(), Or(s2.clientX, s2.clientY);
      });
    }, "onPointerOver"), i2 = n2(() => {
      window.requestAnimationFrame(() => {
        br();
      });
    }, "onResize");
    return t2.viewMode === "story" && r2 && (globalThis.document.addEventListener("pointerover", o2), gr(), globalThis.window.addEventListener(
      "resize",
      i2
    ), Or(Se.x, Se.y)), () => {
      globalThis.window.removeEventListener("resize", i2), Tr();
    };
  }, [r2, t2.viewMode]), e2();
}, "withMeasure");
var gn = globalThis.FEATURES?.measure ? [Mr] : [];
var hn = {
  [fr]: false
};
var lt = n2(() => rc({
  decorators: gn,
  initialGlobals: hn
}), "default");
var Ae = "outline";
var ct = n2((e2) => {
  (Array.isArray(e2) ? e2 : [e2]).forEach(xn);
}, "clearStyles");
var xn = n2((e2) => {
  let t2 = typeof e2 == "string" ? e2 : e2.join(""), r2 = scope.document.getElementById(t2);
  r2 && r2.parentElement && r2.parentElement.removeChild(r2);
}, "clearStyle");
var $r = n2((e2, t2) => {
  let r2 = scope.document.getElementById(e2);
  if (r2)
    r2.innerHTML !== t2 && (r2.innerHTML = t2);
  else {
    let o2 = scope.document.createElement("style");
    o2.setAttribute("id", e2), o2.innerHTML = t2, scope.document.head.appendChild(o2);
  }
}, "addOutlineStyles");
function dt(e2) {
  return W3`
    ${e2} body {
      outline: 1px solid #2980b9 !important;
    }

    ${e2} article {
      outline: 1px solid #3498db !important;
    }

    ${e2} nav {
      outline: 1px solid #0088c3 !important;
    }

    ${e2} aside {
      outline: 1px solid #33a0ce !important;
    }

    ${e2} section {
      outline: 1px solid #66b8da !important;
    }

    ${e2} header {
      outline: 1px solid #99cfe7 !important;
    }

    ${e2} footer {
      outline: 1px solid #cce7f3 !important;
    }

    ${e2} h1 {
      outline: 1px solid #162544 !important;
    }

    ${e2} h2 {
      outline: 1px solid #314e6e !important;
    }

    ${e2} h3 {
      outline: 1px solid #3e5e85 !important;
    }

    ${e2} h4 {
      outline: 1px solid #449baf !important;
    }

    ${e2} h5 {
      outline: 1px solid #c7d1cb !important;
    }

    ${e2} h6 {
      outline: 1px solid #4371d0 !important;
    }

    ${e2} main {
      outline: 1px solid #2f4f90 !important;
    }

    ${e2} address {
      outline: 1px solid #1a2c51 !important;
    }

    ${e2} div {
      outline: 1px solid #036cdb !important;
    }

    ${e2} p {
      outline: 1px solid #ac050b !important;
    }

    ${e2} hr {
      outline: 1px solid #ff063f !important;
    }

    ${e2} pre {
      outline: 1px solid #850440 !important;
    }

    ${e2} blockquote {
      outline: 1px solid #f1b8e7 !important;
    }

    ${e2} ol {
      outline: 1px solid #ff050c !important;
    }

    ${e2} ul {
      outline: 1px solid #d90416 !important;
    }

    ${e2} li {
      outline: 1px solid #d90416 !important;
    }

    ${e2} dl {
      outline: 1px solid #fd3427 !important;
    }

    ${e2} dt {
      outline: 1px solid #ff0043 !important;
    }

    ${e2} dd {
      outline: 1px solid #e80174 !important;
    }

    ${e2} figure {
      outline: 1px solid #ff00bb !important;
    }

    ${e2} figcaption {
      outline: 1px solid #bf0032 !important;
    }

    ${e2} table {
      outline: 1px solid #00cc99 !important;
    }

    ${e2} caption {
      outline: 1px solid #37ffc4 !important;
    }

    ${e2} thead {
      outline: 1px solid #98daca !important;
    }

    ${e2} tbody {
      outline: 1px solid #64a7a0 !important;
    }

    ${e2} tfoot {
      outline: 1px solid #22746b !important;
    }

    ${e2} tr {
      outline: 1px solid #86c0b2 !important;
    }

    ${e2} th {
      outline: 1px solid #a1e7d6 !important;
    }

    ${e2} td {
      outline: 1px solid #3f5a54 !important;
    }

    ${e2} col {
      outline: 1px solid #6c9a8f !important;
    }

    ${e2} colgroup {
      outline: 1px solid #6c9a9d !important;
    }

    ${e2} button {
      outline: 1px solid #da8301 !important;
    }

    ${e2} datalist {
      outline: 1px solid #c06000 !important;
    }

    ${e2} fieldset {
      outline: 1px solid #d95100 !important;
    }

    ${e2} form {
      outline: 1px solid #d23600 !important;
    }

    ${e2} input {
      outline: 1px solid #fca600 !important;
    }

    ${e2} keygen {
      outline: 1px solid #b31e00 !important;
    }

    ${e2} label {
      outline: 1px solid #ee8900 !important;
    }

    ${e2} legend {
      outline: 1px solid #de6d00 !important;
    }

    ${e2} meter {
      outline: 1px solid #e8630c !important;
    }

    ${e2} optgroup {
      outline: 1px solid #b33600 !important;
    }

    ${e2} option {
      outline: 1px solid #ff8a00 !important;
    }

    ${e2} output {
      outline: 1px solid #ff9619 !important;
    }

    ${e2} progress {
      outline: 1px solid #e57c00 !important;
    }

    ${e2} select {
      outline: 1px solid #e26e0f !important;
    }

    ${e2} textarea {
      outline: 1px solid #cc5400 !important;
    }

    ${e2} details {
      outline: 1px solid #33848f !important;
    }

    ${e2} summary {
      outline: 1px solid #60a1a6 !important;
    }

    ${e2} command {
      outline: 1px solid #438da1 !important;
    }

    ${e2} menu {
      outline: 1px solid #449da6 !important;
    }

    ${e2} del {
      outline: 1px solid #bf0000 !important;
    }

    ${e2} ins {
      outline: 1px solid #400000 !important;
    }

    ${e2} img {
      outline: 1px solid #22746b !important;
    }

    ${e2} iframe {
      outline: 1px solid #64a7a0 !important;
    }

    ${e2} embed {
      outline: 1px solid #98daca !important;
    }

    ${e2} object {
      outline: 1px solid #00cc99 !important;
    }

    ${e2} param {
      outline: 1px solid #37ffc4 !important;
    }

    ${e2} video {
      outline: 1px solid #6ee866 !important;
    }

    ${e2} audio {
      outline: 1px solid #027353 !important;
    }

    ${e2} source {
      outline: 1px solid #012426 !important;
    }

    ${e2} canvas {
      outline: 1px solid #a2f570 !important;
    }

    ${e2} track {
      outline: 1px solid #59a600 !important;
    }

    ${e2} map {
      outline: 1px solid #7be500 !important;
    }

    ${e2} area {
      outline: 1px solid #305900 !important;
    }

    ${e2} a {
      outline: 1px solid #ff62ab !important;
    }

    ${e2} em {
      outline: 1px solid #800b41 !important;
    }

    ${e2} strong {
      outline: 1px solid #ff1583 !important;
    }

    ${e2} i {
      outline: 1px solid #803156 !important;
    }

    ${e2} b {
      outline: 1px solid #cc1169 !important;
    }

    ${e2} u {
      outline: 1px solid #ff0430 !important;
    }

    ${e2} s {
      outline: 1px solid #f805e3 !important;
    }

    ${e2} small {
      outline: 1px solid #d107b2 !important;
    }

    ${e2} abbr {
      outline: 1px solid #4a0263 !important;
    }

    ${e2} q {
      outline: 1px solid #240018 !important;
    }

    ${e2} cite {
      outline: 1px solid #64003c !important;
    }

    ${e2} dfn {
      outline: 1px solid #b4005a !important;
    }

    ${e2} sub {
      outline: 1px solid #dba0c8 !important;
    }

    ${e2} sup {
      outline: 1px solid #cc0256 !important;
    }

    ${e2} time {
      outline: 1px solid #d6606d !important;
    }

    ${e2} code {
      outline: 1px solid #e04251 !important;
    }

    ${e2} kbd {
      outline: 1px solid #5e001f !important;
    }

    ${e2} samp {
      outline: 1px solid #9c0033 !important;
    }

    ${e2} var {
      outline: 1px solid #d90047 !important;
    }

    ${e2} mark {
      outline: 1px solid #ff0053 !important;
    }

    ${e2} bdi {
      outline: 1px solid #bf3668 !important;
    }

    ${e2} bdo {
      outline: 1px solid #6f1400 !important;
    }

    ${e2} ruby {
      outline: 1px solid #ff7b93 !important;
    }

    ${e2} rt {
      outline: 1px solid #ff2f54 !important;
    }

    ${e2} rp {
      outline: 1px solid #803e49 !important;
    }

    ${e2} span {
      outline: 1px solid #cc2643 !important;
    }

    ${e2} br {
      outline: 1px solid #db687d !important;
    }

    ${e2} wbr {
      outline: 1px solid #db175b !important;
    }`;
}
n2(dt, "outlineCSS");
var Fr = n2((e2, t2) => {
  let r2 = t2.globals || {}, o2 = [true, "true"].includes(r2[Ae]), i2 = t2.viewMode === "docs", s2 = ss(() => dt(i2 ? '[data-story-block="true"]' : ".sb-show-main"), [t2]);
  return Ot(() => {
    let a = i2 ? `addon-outline-docs-${t2.id}` : "addon-outline";
    return o2 ? $r(a, s2) : ct(a), () => {
      ct(a);
    };
  }, [o2, s2, t2]), e2();
}, "withOutline");
var An = globalThis.FEATURES?.outline ? [Fr] : [];
var Rn = {
  [Ae]: false
};
var mt = n2(() => rc({ decorators: An, initialGlobals: Rn }), "default");
var Fn = n2(({ parameters: e2 }) => {
  e2?.test?.mockReset === true ? cbe() : e2?.test?.clearMocks === true ? ube() : e2?.test?.restoreMocks !== false && dbe();
}, "resetAllMocksLoader");
var ut = n2((e2, t2 = 0, r2) => {
  if (t2 > 5 || e2 == null)
    return e2;
  if (cn(e2))
    return r2 && e2.mockName(r2), e2;
  if (typeof e2 == "function" && "isAction" in e2 && e2.isAction && !("implicit" in e2 && e2.implicit)) {
    let o2 = lbe(e2);
    return r2 && o2.mockName(r2), o2;
  }
  if (Array.isArray(e2)) {
    t2++;
    for (let o2 = 0; o2 < e2.length; o2++)
      Object.getOwnPropertyDescriptor(e2, o2)?.writable && (e2[o2] = ut(e2[o2], t2));
    return e2;
  }
  if (typeof e2 == "object" && e2.constructor === Object) {
    t2++;
    for (let [o2, i2] of Object.entries(e2))
      Object.getOwnPropertyDescriptor(e2, o2)?.writable && (e2[o2] = ut(i2, t2, o2));
    return e2;
  }
  return e2;
}, "traverseArgs");
var In = n2(({ initialArgs: e2 }) => {
  ut(e2);
}, "nameSpiesAndWrapActionsInSpies");
var Ir = false;
var Ln = n2(async (e2) => {
  globalThis.HTMLElement && e2.canvasElement instanceof globalThis.HTMLElement && (e2.canvas = KTe(e2.canvasElement));
  let t2 = globalThis.window?.navigator?.clipboard;
  if (t2) {
    e2.userEvent = Qs(
      { userEvent: XTe.setup() },
      { intercept: true }
    ).userEvent, Object.defineProperty(globalThis.window.navigator, "clipboard", {
      get: n2(() => t2, "get"),
      configurable: true
    });
    let r2 = HTMLElement.prototype.focus;
    Ir || Object.defineProperties(HTMLElement.prototype, {
      focus: {
        configurable: true,
        set: n2((o2) => {
          r2 = o2, Ir = true;
        }, "set"),
        get: n2(() => r2, "get")
      }
    });
  }
}, "enhanceContext");
var ft = n2(() => rc({
  loaders: [Fn, In, Ln]
}), "default");
var Lr = "storybook/viewport";
var Dr = "viewport";
var Ll = `${Lr}/panel`;
var Dl = `${Lr}/tool`;
var _n = {
  [Dr]: { value: void 0, isRotated: false }
};
var yt = n2(() => rc({
  initialGlobals: _n
}), "default");
function _r() {
  return [
    // @ts-expect-error CJS fallback
    (lt.default ?? lt)(),
    // @ts-expect-error CJS fallback
    (Je.default ?? Je)(),
    // @ts-expect-error CJS fallback
    (st.default ?? st)(),
    // @ts-expect-error CJS fallback
    (mt.default ?? mt)(),
    // @ts-expect-error CJS fallback
    (yt.default ?? yt)(),
    // @ts-expect-error CJS fallback
    (Xe.default ?? Xe)(),
    // @ts-expect-error CJS fallback
    (Qe.default ?? Qe)(),
    // @ts-expect-error CJS fallback
    (ft.default ?? ft)()
  ];
}
n2(_r, "getCoreAnnotations");
function tc(e2) {
  let t2, r2 = {
    _tag: "Preview",
    input: e2,
    get composed() {
      if (t2)
        return t2;
      let { addons: o2, ...i2 } = e2;
      return t2 = te(
        ne2([..._r(), ...o2 ?? [], i2])
      ), t2;
    },
    meta(o2) {
      return Nn(o2, this);
    }
  };
  return globalThis.globalProjectAnnotations = r2.composed, r2;
}
n2(tc, "definePreview");
function rc(e2) {
  return e2;
}
n2(rc, "definePreviewAddon");
function oc(e2) {
  return e2 != null && typeof e2 == "object" && "_tag" in e2 && e2?._tag === "Preview";
}
n2(oc, "isPreview");
function nc(e2) {
  return e2 != null && typeof e2 == "object" && "_tag" in e2 && e2?._tag === "Meta";
}
n2(nc, "isMeta");
function Nn(e2, t2) {
  return {
    _tag: "Meta",
    input: e2,
    preview: t2,
    get composed() {
      throw new Error("Not implemented");
    },
    // @ts-expect-error hard
    story(r2 = {}) {
      return Hr(typeof r2 == "function" ? { render: r2 } : r2, this);
    }
  };
}
n2(Nn, "defineMeta");
function ic(e2) {
  return e2 != null && typeof e2 == "object" && "_tag" in e2 && e2?._tag === "Story";
}
n2(ic, "isStory");
function Hr(e2, t2) {
  let r2, o2 = n2(() => (r2 || (r2 = We(
    e2,
    t2.input,
    void 0,
    t2.preview.composed
  )), r2), "compose");
  return {
    _tag: "Story",
    input: e2,
    meta: t2,
    __compose: o2,
    get composed() {
      let i2 = o2(), { args: s2, argTypes: a, parameters: p2, id: c, tags: l2, globals: y, storyName: u } = i2;
      return { args: s2, argTypes: a, parameters: p2, id: c, tags: l2, name: u, globals: y };
    },
    get play() {
      return e2.play ?? t2.input?.play ?? (async () => {
      });
    },
    get run() {
      return o2().run ?? (async () => {
      });
    },
    extend(i2) {
      return Hr(
        {
          ...this.input,
          ...i2,
          args: { ...this.input.args, ...i2.args },
          argTypes: D4(this.input.argTypes, i2.argTypes),
          afterEach: [
            ...b4(this.input?.afterEach ?? []),
            ...b4(i2.afterEach ?? [])
          ],
          beforeEach: [
            ...b4(this.input?.beforeEach ?? []),
            ...b4(i2.beforeEach ?? [])
          ],
          decorators: [
            ...b4(this.input?.decorators ?? []),
            ...b4(i2.decorators ?? [])
          ],
          globals: { ...this.input.globals, ...i2.globals },
          loaders: [
            ...b4(this.input?.loaders ?? []),
            ...b4(i2.loaders ?? [])
          ],
          parameters: D4(this.input.parameters, i2.parameters),
          tags: uc(...this.input.tags ?? [], ...i2.tags ?? [])
        },
        this.meta
      );
    }
  };
}
n2(Hr, "defineStory");
var jn = n2((e2) => e2.toLowerCase().replace(/[ ’–—―′¿'`~!@#$%^&*()_|+\-=?;:'",.<>\{\}\[\]\\\/]/gi, "-").replace(
  /-+/g,
  "-"
).replace(/^-+/, "").replace(/-+$/, ""), "sanitize");
var Nr = n2((e2, t2) => {
  let r2 = jn(e2);
  if (r2 === "")
    throw new Error(`Invalid ${t2} '${e2}', must include alphanumeric characters`);
  return r2;
}, "sanitizeSafe");
var lc = n2((e2, t2) => `${Nr(e2, "kind")}${t2 ? `--${Nr(t2, "name")}` : ""}`, "toId");
var cc = n2((e2) => bt(
  e2
), "storyNameFromExport");
function jr(e2, t2) {
  return Array.isArray(t2) ? t2.includes(e2) : e2.match(t2);
}
n2(jr, "matches");
function dc(e2, { includeStories: t2, excludeStories: r2 }) {
  return (
    // https://babeljs.io/docs/en/babel-plugin-transform-modules-commonjs
    e2 !== "__esModule" && (!t2 || jr(e2, t2)) && (!r2 || !jr(e2, r2))
  );
}
n2(dc, "isExportStory");
var mc = n2((e2, { rootSeparator: t2, groupSeparator: r2 }) => {
  let [o2, i2] = e2.split(t2, 2), s2 = (i2 || e2).split(r2).filter((a) => !!a);
  return {
    root: i2 ? o2 : null,
    groups: s2
  };
}, "parseKind");
var uc = n2((...e2) => {
  let t2 = e2.reduce((r2, o2) => (o2.startsWith("!") ? r2.delete(o2.slice(1)) : r2.add(o2), r2), /* @__PURE__ */ new Set());
  return Array.from(t2);
}, "combineTags");

// node_modules/storybook/dist/preview-api/index.js
var Hn = Object.create;
var br2 = Object.defineProperty;
var Vn = Object.getOwnPropertyDescriptor;
var Wn = Object.getOwnPropertyNames;
var $n = Object.getPrototypeOf;
var Yn = Object.prototype.hasOwnProperty;
var n3 = (r2, e2) => br2(r2, "name", { value: e2, configurable: true });
var Ee = ((r2) => typeof __require < "u" ? __require : typeof Proxy < "u" ? new Proxy(r2, {
  get: (e2, t2) => (typeof __require < "u" ? __require : e2)[t2]
}) : r2)(function(r2) {
  if (typeof __require < "u") return __require.apply(this, arguments);
  throw Error('Dynamic require of "' + r2 + '" is not supported');
});
var I4 = (r2, e2) => () => (e2 || r2((e2 = { exports: {} }).exports, e2), e2.exports);
var Kn = (r2, e2, t2, o2) => {
  if (e2 && typeof e2 == "object" || typeof e2 == "function")
    for (let s2 of Wn(e2))
      !Yn.call(r2, s2) && s2 !== t2 && br2(r2, s2, { get: () => e2[s2], enumerable: !(o2 = Vn(e2, s2)) || o2.enumerable });
  return r2;
};
var ue2 = (r2, e2, t2) => (t2 = r2 != null ? Hn($n(r2)) : {}, Kn(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  e2 || !r2 || !r2.__esModule ? br2(t2, "default", { value: r2, enumerable: true }) : t2,
  r2
));
var Mr2 = I4((so, jr2) => {
  (function(r2) {
    if (typeof so == "object" && typeof jr2 < "u")
      jr2.exports = r2();
    else if (typeof define == "function" && define.amd)
      define([], r2);
    else {
      var e2;
      typeof window < "u" ? e2 = window : typeof global < "u" ? e2 = global : typeof self < "u" ? e2 = self : e2 = this, e2.memoizerific = r2();
    }
  })(function() {
    var r2, e2, t2;
    return n3(function o2(s2, i2, a) {
      function l2(p2, u) {
        if (!i2[p2]) {
          if (!s2[p2]) {
            var y = typeof Ee == "function" && Ee;
            if (!u && y) return y(p2, true);
            if (c) return c(p2, true);
            var h2 = new Error("Cannot find module '" + p2 + "'");
            throw h2.code = "MODULE_NOT_FOUND", h2;
          }
          var g3 = i2[p2] = { exports: {} };
          s2[p2][0].call(g3.exports, function(b5) {
            var m2 = s2[p2][1][b5];
            return l2(m2 || b5);
          }, g3, g3.exports, o2, s2, i2, a);
        }
        return i2[p2].exports;
      }
      n3(l2, "s");
      for (var c = typeof Ee == "function" && Ee, d2 = 0; d2 < a.length; d2++) l2(a[d2]);
      return l2;
    }, "e")({ 1: [function(o2, s2, i2) {
      s2.exports = function(a) {
        if (typeof Map != "function" || a) {
          var l2 = o2("./similar");
          return new l2();
        } else
          return /* @__PURE__ */ new Map();
      };
    }, { "./similar": 2 }], 2: [function(o2, s2, i2) {
      function a() {
        return this.list = [], this.lastItem = void 0, this.size = 0, this;
      }
      n3(a, "Similar"), a.prototype.get = function(l2) {
        var c;
        if (this.lastItem && this.isEqual(this.lastItem.key, l2))
          return this.lastItem.val;
        if (c = this.indexOf(l2), c >= 0)
          return this.lastItem = this.list[c], this.list[c].val;
      }, a.prototype.set = function(l2, c) {
        var d2;
        return this.lastItem && this.isEqual(this.lastItem.key, l2) ? (this.lastItem.val = c, this) : (d2 = this.indexOf(l2), d2 >= 0 ? (this.lastItem = this.list[d2], this.list[d2].val = c, this) : (this.lastItem = { key: l2, val: c }, this.list.push(this.lastItem), this.size++, this));
      }, a.prototype.delete = function(l2) {
        var c;
        if (this.lastItem && this.isEqual(this.lastItem.key, l2) && (this.lastItem = void 0), c = this.indexOf(l2), c >= 0)
          return this.size--, this.list.splice(c, 1)[0];
      }, a.prototype.has = function(l2) {
        var c;
        return this.lastItem && this.isEqual(this.lastItem.key, l2) ? true : (c = this.indexOf(l2), c >= 0 ? (this.lastItem = this.list[c], true) : false);
      }, a.prototype.forEach = function(l2, c) {
        var d2;
        for (d2 = 0; d2 < this.size; d2++)
          l2.call(c || this, this.list[d2].val, this.list[d2].key, this);
      }, a.prototype.indexOf = function(l2) {
        var c;
        for (c = 0; c < this.size; c++)
          if (this.isEqual(this.list[c].key, l2))
            return c;
        return -1;
      }, a.prototype.isEqual = function(l2, c) {
        return l2 === c || l2 !== l2 && c !== c;
      }, s2.exports = a;
    }, {}], 3: [function(o2, s2, i2) {
      var a = o2("map-or-similar");
      s2.exports = function(p2) {
        var u = new a(false), y = [];
        return function(h2) {
          var g3 = n3(function() {
            var b5 = u, m2, T3, x4 = arguments.length - 1, f3 = Array(x4 + 1), S3 = true, R3;
            if ((g3.numArgs || g3.numArgs === 0) && g3.numArgs !== x4 + 1)
              throw new Error("Memoizerific functions should always be called with the same number of arguments");
            for (R3 = 0; R3 < x4; R3++) {
              if (f3[R3] = {
                cacheItem: b5,
                arg: arguments[R3]
              }, b5.has(arguments[R3])) {
                b5 = b5.get(arguments[R3]);
                continue;
              }
              S3 = false, m2 = new a(false), b5.set(arguments[R3], m2), b5 = m2;
            }
            return S3 && (b5.has(arguments[x4]) ? T3 = b5.get(arguments[x4]) : S3 = false), S3 || (T3 = h2.apply(null, arguments), b5.set(arguments[x4], T3)), p2 > 0 && (f3[x4] = {
              cacheItem: b5,
              arg: arguments[x4]
            }, S3 ? l2(y, f3) : y.push(f3), y.length > p2 && c(y.shift())), g3.wasMemoized = S3, g3.numArgs = x4 + 1, T3;
          }, "memoizerific");
          return g3.limit = p2, g3.wasMemoized = false, g3.cache = u, g3.lru = y, g3;
        };
      };
      function l2(p2, u) {
        var y = p2.length, h2 = u.length, g3, b5, m2;
        for (b5 = 0; b5 < y; b5++) {
          for (g3 = true, m2 = 0; m2 < h2; m2++)
            if (!d2(p2[b5][m2].arg, u[m2].arg)) {
              g3 = false;
              break;
            }
          if (g3)
            break;
        }
        p2.push(p2.splice(b5, 1)[0]);
      }
      n3(l2, "moveToMostRecentLru");
      function c(p2) {
        var u = p2.length, y = p2[u - 1], h2, g3;
        for (y.cacheItem.delete(y.arg), g3 = u - 2; g3 >= 0 && (y = p2[g3], h2 = y.cacheItem.get(y.arg), !h2 || !h2.size); g3--)
          y.cacheItem.delete(y.arg);
      }
      n3(c, "removeCachedResult");
      function d2(p2, u) {
        return p2 === u || p2 !== p2 && u !== u;
      }
      n3(d2, "isEqual");
    }, { "map-or-similar": 1 }] }, {}, [3])(3);
  });
});
var at2 = I4((it2) => {
  "use strict";
  Object.defineProperty(it2, "__esModule", { value: true });
  it2.encodeString = na;
  var G4 = Array.from({ length: 256 }, (r2, e2) => "%" + ((e2 < 16 ? "0" : "") + e2.toString(16)).toUpperCase()), oa = new Int8Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    0
  ]);
  function na(r2) {
    let e2 = r2.length;
    if (e2 === 0)
      return "";
    let t2 = "", o2 = 0, s2 = 0;
    e: for (; s2 < e2; s2++) {
      let i2 = r2.charCodeAt(s2);
      for (; i2 < 128; ) {
        if (oa[i2] !== 1 && (o2 < s2 && (t2 += r2.slice(o2, s2)), o2 = s2 + 1, t2 += G4[i2]), ++s2 === e2)
          break e;
        i2 = r2.charCodeAt(s2);
      }
      if (o2 < s2 && (t2 += r2.slice(o2, s2)), i2 < 2048) {
        o2 = s2 + 1, t2 += G4[192 | i2 >> 6] + G4[128 | i2 & 63];
        continue;
      }
      if (i2 < 55296 || i2 >= 57344) {
        o2 = s2 + 1, t2 += G4[224 | i2 >> 12] + G4[128 | i2 >> 6 & 63] + G4[128 | i2 & 63];
        continue;
      }
      if (++s2, s2 >= e2)
        throw new Error("URI malformed");
      let a = r2.charCodeAt(s2) & 1023;
      o2 = s2 + 1, i2 = 65536 + ((i2 & 1023) << 10 | a), t2 += G4[240 | i2 >> 18] + G4[128 | i2 >> 12 & 63] + G4[128 | i2 >> 6 & 63] + G4[128 | i2 & 63];
    }
    return o2 === 0 ? r2 : o2 < e2 ? t2 + r2.slice(o2) : t2;
  }
  n3(na, "encodeString");
});
var nr2 = I4((U4) => {
  "use strict";
  Object.defineProperty(U4, "__esModule", { value: true });
  U4.defaultOptions = U4.defaultShouldSerializeObject = U4.defaultValueSerializer = void 0;
  var lt2 = at2(), sa = n3((r2) => {
    switch (typeof r2) {
      case "string":
        return (0, lt2.encodeString)(r2);
      case "bigint":
      case "boolean":
        return "" + r2;
      case "number":
        if (Number.isFinite(r2))
          return r2 < 1e21 ? "" + r2 : (0, lt2.encodeString)("" + r2);
        break;
    }
    return r2 instanceof Date ? (0, lt2.encodeString)(r2.toISOString()) : "";
  }, "defaultValueSerializer");
  U4.defaultValueSerializer = sa;
  var ia = n3((r2) => r2 instanceof Date, "defaultShouldSerializeObject");
  U4.defaultShouldSerializeObject = ia;
  var zo2 = n3((r2) => r2, "identityFunc");
  U4.defaultOptions = {
    nesting: true,
    nestingSyntax: "dot",
    arrayRepeat: false,
    arrayRepeatSyntax: "repeat",
    delimiter: 38,
    valueDeserializer: zo2,
    valueSerializer: U4.defaultValueSerializer,
    keyDeserializer: zo2,
    shouldSerializeObject: U4.defaultShouldSerializeObject
  };
});
var ct2 = I4((sr2) => {
  "use strict";
  Object.defineProperty(sr2, "__esModule", { value: true });
  sr2.getDeepObject = ca;
  sr2.stringifyObject = Bo2;
  var ae2 = nr2(), aa = at2();
  function la(r2) {
    return r2 === "__proto__" || r2 === "constructor" || r2 === "prototype";
  }
  n3(la, "isPrototypeKey");
  function ca(r2, e2, t2, o2, s2) {
    if (la(e2))
      return r2;
    let i2 = r2[e2];
    return typeof i2 == "object" && i2 !== null ? i2 : !o2 && (s2 || typeof t2 == "number" || typeof t2 == "string" && t2 * 0 === 0 && t2.indexOf(".") === -1) ? r2[e2] = [] : r2[e2] = {};
  }
  n3(ca, "getDeepObject");
  var da = 20, pa = "[]", ua = "[", fa = "]", ya = ".";
  function Bo2(r2, e2, t2 = 0, o2, s2) {
    let { nestingSyntax: i2 = ae2.defaultOptions.nestingSyntax, arrayRepeat: a = ae2.defaultOptions.arrayRepeat, arrayRepeatSyntax: l2 = ae2.defaultOptions.arrayRepeatSyntax, nesting: c = ae2.defaultOptions.nesting, delimiter: d2 = ae2.defaultOptions.delimiter, valueSerializer: p2 = ae2.defaultOptions.valueSerializer, shouldSerializeObject: u = ae2.defaultOptions.shouldSerializeObject } = e2, y = typeof d2 == "number" ? String.fromCharCode(
      d2
    ) : d2, h2 = s2 === true && a, g3 = i2 === "dot" || i2 === "js" && !s2;
    if (t2 > da)
      return "";
    let b5 = "", m2 = true, T3 = false;
    for (let x4 in r2) {
      let f3 = r2[x4], S3;
      o2 ? (S3 = o2, h2 ? l2 === "bracket" && (S3 += pa) : g3 ? (S3 += ya, S3 += x4) : (S3 += ua, S3 += x4, S3 += fa)) : S3 = x4, m2 || (b5 += y), typeof f3 == "object" && f3 !== null && !u(f3) ? (T3 = f3.pop !== void 0, (c || a && T3) && (b5 += Bo2(f3, e2, t2 + 1, S3, T3))) : (b5 += (0, aa.encodeString)(S3), b5 += "=", b5 += p2(f3, x4)), m2 && (m2 = false);
    }
    return b5;
  }
  n3(Bo2, "stringifyObject");
});
var Vo2 = I4((rf, Ho2) => {
  "use strict";
  var Go = 12, ma = 0, dt2 = [
    // The first part of the table maps bytes to character to a transition.
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    4,
    4,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    6,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    8,
    7,
    7,
    10,
    9,
    9,
    9,
    11,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    // The second part of the table maps a state to a new state when adding a
    // transition.
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    12,
    0,
    0,
    0,
    0,
    24,
    36,
    48,
    60,
    72,
    84,
    96,
    0,
    12,
    12,
    12,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    24,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    24,
    24,
    24,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    24,
    24,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    48,
    48,
    48,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    48,
    48,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    48,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    // The third part maps the current transition to a mask that needs to apply
    // to the byte.
    127,
    63,
    63,
    63,
    0,
    31,
    15,
    15,
    15,
    7,
    7,
    7
  ];
  function ha(r2) {
    var e2 = r2.indexOf("%");
    if (e2 === -1) return r2;
    for (var t2 = r2.length, o2 = "", s2 = 0, i2 = 0, a = e2, l2 = Go; e2 > -1 && e2 < t2; ) {
      var c = Uo2(r2[e2 + 1], 4), d2 = Uo2(r2[e2 + 2], 0), p2 = c | d2, u = dt2[p2];
      if (l2 = dt2[256 + l2 + u], i2 = i2 << 6 | p2 & dt2[364 + u], l2 === Go)
        o2 += r2.slice(s2, a), o2 += i2 <= 65535 ? String.fromCharCode(i2) : String.fromCharCode(
          55232 + (i2 >> 10),
          56320 + (i2 & 1023)
        ), i2 = 0, s2 = e2 + 3, e2 = a = r2.indexOf("%", s2);
      else {
        if (l2 === ma)
          return null;
        if (e2 += 3, e2 < t2 && r2.charCodeAt(e2) === 37) continue;
        return null;
      }
    }
    return o2 + r2.slice(s2);
  }
  n3(ha, "decodeURIComponent");
  var ga = {
    0: 0,
    1: 1,
    2: 2,
    3: 3,
    4: 4,
    5: 5,
    6: 6,
    7: 7,
    8: 8,
    9: 9,
    a: 10,
    A: 10,
    b: 11,
    B: 11,
    c: 12,
    C: 12,
    d: 13,
    D: 13,
    e: 14,
    E: 14,
    f: 15,
    F: 15
  };
  function Uo2(r2, e2) {
    var t2 = ga[r2];
    return t2 === void 0 ? 255 : t2 << e2;
  }
  n3(Uo2, "hexCodeToInt");
  Ho2.exports = ha;
});
var Ko2 = I4(($4) => {
  "use strict";
  var ba = $4 && $4.__importDefault || function(r2) {
    return r2 && r2.__esModule ? r2 : { default: r2 };
  };
  Object.defineProperty($4, "__esModule", { value: true });
  $4.numberValueDeserializer = $4.numberKeyDeserializer = void 0;
  $4.parse = xa;
  var ir2 = ct2(), le = nr2(), Wo = ba(Vo2()), Sa = n3((r2) => {
    let e2 = Number(r2);
    return Number.isNaN(e2) ? r2 : e2;
  }, "numberKeyDeserializer");
  $4.numberKeyDeserializer = Sa;
  var Ta = n3((r2) => {
    let e2 = Number(r2);
    return Number.isNaN(e2) ? r2 : e2;
  }, "numberValueDeserializer");
  $4.numberValueDeserializer = Ta;
  var $o = /\+/g, Yo2 = n3(function() {
  }, "Empty");
  Yo2.prototype = /* @__PURE__ */ Object.create(null);
  function ar2(r2, e2, t2, o2, s2) {
    let i2 = r2.substring(e2, t2);
    return o2 && (i2 = i2.replace($o, " ")), s2 && (i2 = (0, Wo.default)(i2) || i2), i2;
  }
  n3(ar2, "computeKeySlice");
  function xa(r2, e2) {
    let { valueDeserializer: t2 = le.defaultOptions.valueDeserializer, keyDeserializer: o2 = le.defaultOptions.keyDeserializer, arrayRepeatSyntax: s2 = le.defaultOptions.arrayRepeatSyntax, nesting: i2 = le.defaultOptions.nesting, arrayRepeat: a = le.defaultOptions.arrayRepeat, nestingSyntax: l2 = le.defaultOptions.nestingSyntax, delimiter: c = le.defaultOptions.delimiter } = e2 ?? {}, d2 = typeof c == "string" ? c.charCodeAt(0) : c, p2 = l2 === "js", u = new Yo2();
    if (typeof r2 != "string")
      return u;
    let y = r2.length, h2 = "", g3 = -1, b5 = -1, m2 = -1, T3 = u, x4, f3 = "", S3 = "", R3 = false, w4 = false, E = false, D5 = false, k4 = false, L3 = false, pe2 = false, q4 = 0, v3 = -1, B4 = -1, Et2 = -1;
    for (let F2 = 0; F2 < y + 1; F2++) {
      if (q4 = F2 !== y ? r2.charCodeAt(F2) : d2, q4 === d2) {
        if (pe2 = b5 > g3, pe2 || (b5 = F2), m2 !== b5 - 1 && (S3 = ar2(r2, m2 + 1, v3 > -1 ? v3 : b5, E, R3), f3 = o2(S3), x4 !== void 0 && (T3 = (0, ir2.getDeepObject)(
          T3,
          x4,
          f3,
          p2 && k4,
          p2 && L3
        ))), pe2 || f3 !== "") {
          pe2 && (h2 = r2.slice(b5 + 1, F2), D5 && (h2 = h2.replace($o, " ")), w4 && (h2 = (0, Wo.default)(h2) || h2));
          let Ae2 = t2(h2, f3);
          if (a) {
            let Be2 = T3[f3];
            Be2 === void 0 ? v3 > -1 ? T3[f3] = [Ae2] : T3[f3] = Ae2 : Be2.pop ? Be2.push(Ae2) : T3[f3] = [Be2, Ae2];
          } else
            T3[f3] = Ae2;
        }
        h2 = "", g3 = F2, b5 = F2, R3 = false, w4 = false, E = false, D5 = false, k4 = false, L3 = false, v3 = -1, m2 = F2, T3 = u, x4 = void 0, f3 = "";
      } else q4 === 93 ? (a && s2 === "bracket" && Et2 === 91 && (v3 = B4), i2 && (l2 === "index" || p2) && b5 <= g3 && (m2 !== B4 && (S3 = ar2(
        r2,
        m2 + 1,
        F2,
        E,
        R3
      ), f3 = o2(S3), x4 !== void 0 && (T3 = (0, ir2.getDeepObject)(T3, x4, f3, void 0, p2)), x4 = f3, E = false, R3 = false), m2 = F2, L3 = true, k4 = false)) : q4 === 46 ? i2 && (l2 === "dot" || p2) && b5 <= g3 && (m2 !== B4 && (S3 = ar2(r2, m2 + 1, F2, E, R3), f3 = o2(S3), x4 !== void 0 && (T3 = (0, ir2.getDeepObject)(
        T3,
        x4,
        f3,
        p2
      )), x4 = f3, E = false, R3 = false), k4 = true, L3 = false, m2 = F2) : q4 === 91 ? i2 && (l2 === "index" || p2) && b5 <= g3 && (m2 !== B4 && (S3 = ar2(
        r2,
        m2 + 1,
        F2,
        E,
        R3
      ), f3 = o2(S3), p2 && x4 !== void 0 && (T3 = (0, ir2.getDeepObject)(T3, x4, f3, p2)), x4 = f3, E = false, R3 = false, k4 = false, L3 = true), m2 = F2) : q4 === 61 ? b5 <= g3 ? b5 = F2 : w4 = true : q4 === 43 ? b5 > g3 ? D5 = true : E = true : q4 === 37 && (b5 > g3 ? w4 = true : R3 = true);
      B4 = F2, Et2 = q4;
    }
    return u;
  }
  n3(xa, "parse");
});
var Xo2 = I4((pt2) => {
  "use strict";
  Object.defineProperty(pt2, "__esModule", { value: true });
  pt2.stringify = wa;
  var Ra = ct2();
  function wa(r2, e2) {
    if (r2 === null || typeof r2 != "object")
      return "";
    let t2 = e2 ?? {};
    return (0, Ra.stringifyObject)(r2, t2);
  }
  n3(wa, "stringify");
});
var lr2 = I4((z5) => {
  "use strict";
  var Aa = z5 && z5.__createBinding || (Object.create ? function(r2, e2, t2, o2) {
    o2 === void 0 && (o2 = t2);
    var s2 = Object.getOwnPropertyDescriptor(e2, t2);
    (!s2 || ("get" in s2 ? !e2.__esModule : s2.writable || s2.configurable)) && (s2 = { enumerable: true, get: n3(function() {
      return e2[t2];
    }, "get") }), Object.defineProperty(r2, o2, s2);
  } : function(r2, e2, t2, o2) {
    o2 === void 0 && (o2 = t2), r2[o2] = e2[t2];
  }), Ea = z5 && z5.__exportStar || function(r2, e2) {
    for (var t2 in r2) t2 !== "default" && !Object.prototype.hasOwnProperty.call(e2, t2) && Aa(e2, r2, t2);
  };
  Object.defineProperty(z5, "__esModule", { value: true });
  z5.stringify = z5.parse = void 0;
  var Ca = Ko2();
  Object.defineProperty(z5, "parse", { enumerable: true, get: n3(function() {
    return Ca.parse;
  }, "get") });
  var va = Xo2();
  Object.defineProperty(z5, "stringify", { enumerable: true, get: n3(function() {
    return va.stringify;
  }, "get") });
  Ea(nr2(), z5);
});
var mt2 = I4((Sf, _a) => {
  _a.exports = {
    Aacute: "Á",
    aacute: "á",
    Abreve: "Ă",
    abreve: "ă",
    ac: "∾",
    acd: "∿",
    acE: "∾̳",
    Acirc: "Â",
    acirc: "â",
    acute: "´",
    Acy: "А",
    acy: "а",
    AElig: "Æ",
    aelig: "æ",
    af: "⁡",
    Afr: "𝔄",
    afr: "𝔞",
    Agrave: "À",
    agrave: "à",
    alefsym: "ℵ",
    aleph: "ℵ",
    Alpha: "Α",
    alpha: "α",
    Amacr: "Ā",
    amacr: "ā",
    amalg: "⨿",
    amp: "&",
    AMP: "&",
    andand: "⩕",
    And: "⩓",
    and: "∧",
    andd: "⩜",
    andslope: "⩘",
    andv: "⩚",
    ang: "∠",
    ange: "⦤",
    angle: "∠",
    angmsdaa: "⦨",
    angmsdab: "⦩",
    angmsdac: "⦪",
    angmsdad: "⦫",
    angmsdae: "⦬",
    angmsdaf: "⦭",
    angmsdag: "⦮",
    angmsdah: "⦯",
    angmsd: "∡",
    angrt: "∟",
    angrtvb: "⊾",
    angrtvbd: "⦝",
    angsph: "∢",
    angst: "Å",
    angzarr: "⍼",
    Aogon: "Ą",
    aogon: "ą",
    Aopf: "𝔸",
    aopf: "𝕒",
    apacir: "⩯",
    ap: "≈",
    apE: "⩰",
    ape: "≊",
    apid: "≋",
    apos: "'",
    ApplyFunction: "⁡",
    approx: "≈",
    approxeq: "≊",
    Aring: "Å",
    aring: "å",
    Ascr: "𝒜",
    ascr: "𝒶",
    Assign: "≔",
    ast: "*",
    asymp: "≈",
    asympeq: "≍",
    Atilde: "Ã",
    atilde: "ã",
    Auml: "Ä",
    auml: "ä",
    awconint: "∳",
    awint: "⨑",
    backcong: "≌",
    backepsilon: "϶",
    backprime: "‵",
    backsim: "∽",
    backsimeq: "⋍",
    Backslash: "∖",
    Barv: "⫧",
    barvee: "⊽",
    barwed: "⌅",
    Barwed: "⌆",
    barwedge: "⌅",
    bbrk: "⎵",
    bbrktbrk: "⎶",
    bcong: "≌",
    Bcy: "Б",
    bcy: "б",
    bdquo: "„",
    becaus: "∵",
    because: "∵",
    Because: "∵",
    bemptyv: "⦰",
    bepsi: "϶",
    bernou: "ℬ",
    Bernoullis: "ℬ",
    Beta: "Β",
    beta: "β",
    beth: "ℶ",
    between: "≬",
    Bfr: "𝔅",
    bfr: "𝔟",
    bigcap: "⋂",
    bigcirc: "◯",
    bigcup: "⋃",
    bigodot: "⨀",
    bigoplus: "⨁",
    bigotimes: "⨂",
    bigsqcup: "⨆",
    bigstar: "★",
    bigtriangledown: "▽",
    bigtriangleup: "△",
    biguplus: "⨄",
    bigvee: "⋁",
    bigwedge: "⋀",
    bkarow: "⤍",
    blacklozenge: "⧫",
    blacksquare: "▪",
    blacktriangle: "▴",
    blacktriangledown: "▾",
    blacktriangleleft: "◂",
    blacktriangleright: "▸",
    blank: "␣",
    blk12: "▒",
    blk14: "░",
    blk34: "▓",
    block: "█",
    bne: "=⃥",
    bnequiv: "≡⃥",
    bNot: "⫭",
    bnot: "⌐",
    Bopf: "𝔹",
    bopf: "𝕓",
    bot: "⊥",
    bottom: "⊥",
    bowtie: "⋈",
    boxbox: "⧉",
    boxdl: "┐",
    boxdL: "╕",
    boxDl: "╖",
    boxDL: "╗",
    boxdr: "┌",
    boxdR: "╒",
    boxDr: "╓",
    boxDR: "╔",
    boxh: "─",
    boxH: "═",
    boxhd: "┬",
    boxHd: "╤",
    boxhD: "╥",
    boxHD: "╦",
    boxhu: "┴",
    boxHu: "╧",
    boxhU: "╨",
    boxHU: "╩",
    boxminus: "⊟",
    boxplus: "⊞",
    boxtimes: "⊠",
    boxul: "┘",
    boxuL: "╛",
    boxUl: "╜",
    boxUL: "╝",
    boxur: "└",
    boxuR: "╘",
    boxUr: "╙",
    boxUR: "╚",
    boxv: "│",
    boxV: "║",
    boxvh: "┼",
    boxvH: "╪",
    boxVh: "╫",
    boxVH: "╬",
    boxvl: "┤",
    boxvL: "╡",
    boxVl: "╢",
    boxVL: "╣",
    boxvr: "├",
    boxvR: "╞",
    boxVr: "╟",
    boxVR: "╠",
    bprime: "‵",
    breve: "˘",
    Breve: "˘",
    brvbar: "¦",
    bscr: "𝒷",
    Bscr: "ℬ",
    bsemi: "⁏",
    bsim: "∽",
    bsime: "⋍",
    bsolb: "⧅",
    bsol: "\\",
    bsolhsub: "⟈",
    bull: "•",
    bullet: "•",
    bump: "≎",
    bumpE: "⪮",
    bumpe: "≏",
    Bumpeq: "≎",
    bumpeq: "≏",
    Cacute: "Ć",
    cacute: "ć",
    capand: "⩄",
    capbrcup: "⩉",
    capcap: "⩋",
    cap: "∩",
    Cap: "⋒",
    capcup: "⩇",
    capdot: "⩀",
    CapitalDifferentialD: "ⅅ",
    caps: "∩︀",
    caret: "⁁",
    caron: "ˇ",
    Cayleys: "ℭ",
    ccaps: "⩍",
    Ccaron: "Č",
    ccaron: "č",
    Ccedil: "Ç",
    ccedil: "ç",
    Ccirc: "Ĉ",
    ccirc: "ĉ",
    Cconint: "∰",
    ccups: "⩌",
    ccupssm: "⩐",
    Cdot: "Ċ",
    cdot: "ċ",
    cedil: "¸",
    Cedilla: "¸",
    cemptyv: "⦲",
    cent: "¢",
    centerdot: "·",
    CenterDot: "·",
    cfr: "𝔠",
    Cfr: "ℭ",
    CHcy: "Ч",
    chcy: "ч",
    check: "✓",
    checkmark: "✓",
    Chi: "Χ",
    chi: "χ",
    circ: "ˆ",
    circeq: "≗",
    circlearrowleft: "↺",
    circlearrowright: "↻",
    circledast: "⊛",
    circledcirc: "⊚",
    circleddash: "⊝",
    CircleDot: "⊙",
    circledR: "®",
    circledS: "Ⓢ",
    CircleMinus: "⊖",
    CirclePlus: "⊕",
    CircleTimes: "⊗",
    cir: "○",
    cirE: "⧃",
    cire: "≗",
    cirfnint: "⨐",
    cirmid: "⫯",
    cirscir: "⧂",
    ClockwiseContourIntegral: "∲",
    CloseCurlyDoubleQuote: "”",
    CloseCurlyQuote: "’",
    clubs: "♣",
    clubsuit: "♣",
    colon: ":",
    Colon: "∷",
    Colone: "⩴",
    colone: "≔",
    coloneq: "≔",
    comma: ",",
    commat: "@",
    comp: "∁",
    compfn: "∘",
    complement: "∁",
    complexes: "ℂ",
    cong: "≅",
    congdot: "⩭",
    Congruent: "≡",
    conint: "∮",
    Conint: "∯",
    ContourIntegral: "∮",
    copf: "𝕔",
    Copf: "ℂ",
    coprod: "∐",
    Coproduct: "∐",
    copy: "©",
    COPY: "©",
    copysr: "℗",
    CounterClockwiseContourIntegral: "∳",
    crarr: "↵",
    cross: "✗",
    Cross: "⨯",
    Cscr: "𝒞",
    cscr: "𝒸",
    csub: "⫏",
    csube: "⫑",
    csup: "⫐",
    csupe: "⫒",
    ctdot: "⋯",
    cudarrl: "⤸",
    cudarrr: "⤵",
    cuepr: "⋞",
    cuesc: "⋟",
    cularr: "↶",
    cularrp: "⤽",
    cupbrcap: "⩈",
    cupcap: "⩆",
    CupCap: "≍",
    cup: "∪",
    Cup: "⋓",
    cupcup: "⩊",
    cupdot: "⊍",
    cupor: "⩅",
    cups: "∪︀",
    curarr: "↷",
    curarrm: "⤼",
    curlyeqprec: "⋞",
    curlyeqsucc: "⋟",
    curlyvee: "⋎",
    curlywedge: "⋏",
    curren: "¤",
    curvearrowleft: "↶",
    curvearrowright: "↷",
    cuvee: "⋎",
    cuwed: "⋏",
    cwconint: "∲",
    cwint: "∱",
    cylcty: "⌭",
    dagger: "†",
    Dagger: "‡",
    daleth: "ℸ",
    darr: "↓",
    Darr: "↡",
    dArr: "⇓",
    dash: "‐",
    Dashv: "⫤",
    dashv: "⊣",
    dbkarow: "⤏",
    dblac: "˝",
    Dcaron: "Ď",
    dcaron: "ď",
    Dcy: "Д",
    dcy: "д",
    ddagger: "‡",
    ddarr: "⇊",
    DD: "ⅅ",
    dd: "ⅆ",
    DDotrahd: "⤑",
    ddotseq: "⩷",
    deg: "°",
    Del: "∇",
    Delta: "Δ",
    delta: "δ",
    demptyv: "⦱",
    dfisht: "⥿",
    Dfr: "𝔇",
    dfr: "𝔡",
    dHar: "⥥",
    dharl: "⇃",
    dharr: "⇂",
    DiacriticalAcute: "´",
    DiacriticalDot: "˙",
    DiacriticalDoubleAcute: "˝",
    DiacriticalGrave: "`",
    DiacriticalTilde: "˜",
    diam: "⋄",
    diamond: "⋄",
    Diamond: "⋄",
    diamondsuit: "♦",
    diams: "♦",
    die: "¨",
    DifferentialD: "ⅆ",
    digamma: "ϝ",
    disin: "⋲",
    div: "÷",
    divide: "÷",
    divideontimes: "⋇",
    divonx: "⋇",
    DJcy: "Ђ",
    djcy: "ђ",
    dlcorn: "⌞",
    dlcrop: "⌍",
    dollar: "$",
    Dopf: "𝔻",
    dopf: "𝕕",
    Dot: "¨",
    dot: "˙",
    DotDot: "⃜",
    doteq: "≐",
    doteqdot: "≑",
    DotEqual: "≐",
    dotminus: "∸",
    dotplus: "∔",
    dotsquare: "⊡",
    doublebarwedge: "⌆",
    DoubleContourIntegral: "∯",
    DoubleDot: "¨",
    DoubleDownArrow: "⇓",
    DoubleLeftArrow: "⇐",
    DoubleLeftRightArrow: "⇔",
    DoubleLeftTee: "⫤",
    DoubleLongLeftArrow: "⟸",
    DoubleLongLeftRightArrow: "⟺",
    DoubleLongRightArrow: "⟹",
    DoubleRightArrow: "⇒",
    DoubleRightTee: "⊨",
    DoubleUpArrow: "⇑",
    DoubleUpDownArrow: "⇕",
    DoubleVerticalBar: "∥",
    DownArrowBar: "⤓",
    downarrow: "↓",
    DownArrow: "↓",
    Downarrow: "⇓",
    DownArrowUpArrow: "⇵",
    DownBreve: "̑",
    downdownarrows: "⇊",
    downharpoonleft: "⇃",
    downharpoonright: "⇂",
    DownLeftRightVector: "⥐",
    DownLeftTeeVector: "⥞",
    DownLeftVectorBar: "⥖",
    DownLeftVector: "↽",
    DownRightTeeVector: "⥟",
    DownRightVectorBar: "⥗",
    DownRightVector: "⇁",
    DownTeeArrow: "↧",
    DownTee: "⊤",
    drbkarow: "⤐",
    drcorn: "⌟",
    drcrop: "⌌",
    Dscr: "𝒟",
    dscr: "𝒹",
    DScy: "Ѕ",
    dscy: "ѕ",
    dsol: "⧶",
    Dstrok: "Đ",
    dstrok: "đ",
    dtdot: "⋱",
    dtri: "▿",
    dtrif: "▾",
    duarr: "⇵",
    duhar: "⥯",
    dwangle: "⦦",
    DZcy: "Џ",
    dzcy: "џ",
    dzigrarr: "⟿",
    Eacute: "É",
    eacute: "é",
    easter: "⩮",
    Ecaron: "Ě",
    ecaron: "ě",
    Ecirc: "Ê",
    ecirc: "ê",
    ecir: "≖",
    ecolon: "≕",
    Ecy: "Э",
    ecy: "э",
    eDDot: "⩷",
    Edot: "Ė",
    edot: "ė",
    eDot: "≑",
    ee: "ⅇ",
    efDot: "≒",
    Efr: "𝔈",
    efr: "𝔢",
    eg: "⪚",
    Egrave: "È",
    egrave: "è",
    egs: "⪖",
    egsdot: "⪘",
    el: "⪙",
    Element: "∈",
    elinters: "⏧",
    ell: "ℓ",
    els: "⪕",
    elsdot: "⪗",
    Emacr: "Ē",
    emacr: "ē",
    empty: "∅",
    emptyset: "∅",
    EmptySmallSquare: "◻",
    emptyv: "∅",
    EmptyVerySmallSquare: "▫",
    emsp13: " ",
    emsp14: " ",
    emsp: " ",
    ENG: "Ŋ",
    eng: "ŋ",
    ensp: " ",
    Eogon: "Ę",
    eogon: "ę",
    Eopf: "𝔼",
    eopf: "𝕖",
    epar: "⋕",
    eparsl: "⧣",
    eplus: "⩱",
    epsi: "ε",
    Epsilon: "Ε",
    epsilon: "ε",
    epsiv: "ϵ",
    eqcirc: "≖",
    eqcolon: "≕",
    eqsim: "≂",
    eqslantgtr: "⪖",
    eqslantless: "⪕",
    Equal: "⩵",
    equals: "=",
    EqualTilde: "≂",
    equest: "≟",
    Equilibrium: "⇌",
    equiv: "≡",
    equivDD: "⩸",
    eqvparsl: "⧥",
    erarr: "⥱",
    erDot: "≓",
    escr: "ℯ",
    Escr: "ℰ",
    esdot: "≐",
    Esim: "⩳",
    esim: "≂",
    Eta: "Η",
    eta: "η",
    ETH: "Ð",
    eth: "ð",
    Euml: "Ë",
    euml: "ë",
    euro: "€",
    excl: "!",
    exist: "∃",
    Exists: "∃",
    expectation: "ℰ",
    exponentiale: "ⅇ",
    ExponentialE: "ⅇ",
    fallingdotseq: "≒",
    Fcy: "Ф",
    fcy: "ф",
    female: "♀",
    ffilig: "ﬃ",
    fflig: "ﬀ",
    ffllig: "ﬄ",
    Ffr: "𝔉",
    ffr: "𝔣",
    filig: "ﬁ",
    FilledSmallSquare: "◼",
    FilledVerySmallSquare: "▪",
    fjlig: "fj",
    flat: "♭",
    fllig: "ﬂ",
    fltns: "▱",
    fnof: "ƒ",
    Fopf: "𝔽",
    fopf: "𝕗",
    forall: "∀",
    ForAll: "∀",
    fork: "⋔",
    forkv: "⫙",
    Fouriertrf: "ℱ",
    fpartint: "⨍",
    frac12: "½",
    frac13: "⅓",
    frac14: "¼",
    frac15: "⅕",
    frac16: "⅙",
    frac18: "⅛",
    frac23: "⅔",
    frac25: "⅖",
    frac34: "¾",
    frac35: "⅗",
    frac38: "⅜",
    frac45: "⅘",
    frac56: "⅚",
    frac58: "⅝",
    frac78: "⅞",
    frasl: "⁄",
    frown: "⌢",
    fscr: "𝒻",
    Fscr: "ℱ",
    gacute: "ǵ",
    Gamma: "Γ",
    gamma: "γ",
    Gammad: "Ϝ",
    gammad: "ϝ",
    gap: "⪆",
    Gbreve: "Ğ",
    gbreve: "ğ",
    Gcedil: "Ģ",
    Gcirc: "Ĝ",
    gcirc: "ĝ",
    Gcy: "Г",
    gcy: "г",
    Gdot: "Ġ",
    gdot: "ġ",
    ge: "≥",
    gE: "≧",
    gEl: "⪌",
    gel: "⋛",
    geq: "≥",
    geqq: "≧",
    geqslant: "⩾",
    gescc: "⪩",
    ges: "⩾",
    gesdot: "⪀",
    gesdoto: "⪂",
    gesdotol: "⪄",
    gesl: "⋛︀",
    gesles: "⪔",
    Gfr: "𝔊",
    gfr: "𝔤",
    gg: "≫",
    Gg: "⋙",
    ggg: "⋙",
    gimel: "ℷ",
    GJcy: "Ѓ",
    gjcy: "ѓ",
    gla: "⪥",
    gl: "≷",
    glE: "⪒",
    glj: "⪤",
    gnap: "⪊",
    gnapprox: "⪊",
    gne: "⪈",
    gnE: "≩",
    gneq: "⪈",
    gneqq: "≩",
    gnsim: "⋧",
    Gopf: "𝔾",
    gopf: "𝕘",
    grave: "`",
    GreaterEqual: "≥",
    GreaterEqualLess: "⋛",
    GreaterFullEqual: "≧",
    GreaterGreater: "⪢",
    GreaterLess: "≷",
    GreaterSlantEqual: "⩾",
    GreaterTilde: "≳",
    Gscr: "𝒢",
    gscr: "ℊ",
    gsim: "≳",
    gsime: "⪎",
    gsiml: "⪐",
    gtcc: "⪧",
    gtcir: "⩺",
    gt: ">",
    GT: ">",
    Gt: "≫",
    gtdot: "⋗",
    gtlPar: "⦕",
    gtquest: "⩼",
    gtrapprox: "⪆",
    gtrarr: "⥸",
    gtrdot: "⋗",
    gtreqless: "⋛",
    gtreqqless: "⪌",
    gtrless: "≷",
    gtrsim: "≳",
    gvertneqq: "≩︀",
    gvnE: "≩︀",
    Hacek: "ˇ",
    hairsp: " ",
    half: "½",
    hamilt: "ℋ",
    HARDcy: "Ъ",
    hardcy: "ъ",
    harrcir: "⥈",
    harr: "↔",
    hArr: "⇔",
    harrw: "↭",
    Hat: "^",
    hbar: "ℏ",
    Hcirc: "Ĥ",
    hcirc: "ĥ",
    hearts: "♥",
    heartsuit: "♥",
    hellip: "…",
    hercon: "⊹",
    hfr: "𝔥",
    Hfr: "ℌ",
    HilbertSpace: "ℋ",
    hksearow: "⤥",
    hkswarow: "⤦",
    hoarr: "⇿",
    homtht: "∻",
    hookleftarrow: "↩",
    hookrightarrow: "↪",
    hopf: "𝕙",
    Hopf: "ℍ",
    horbar: "―",
    HorizontalLine: "─",
    hscr: "𝒽",
    Hscr: "ℋ",
    hslash: "ℏ",
    Hstrok: "Ħ",
    hstrok: "ħ",
    HumpDownHump: "≎",
    HumpEqual: "≏",
    hybull: "⁃",
    hyphen: "‐",
    Iacute: "Í",
    iacute: "í",
    ic: "⁣",
    Icirc: "Î",
    icirc: "î",
    Icy: "И",
    icy: "и",
    Idot: "İ",
    IEcy: "Е",
    iecy: "е",
    iexcl: "¡",
    iff: "⇔",
    ifr: "𝔦",
    Ifr: "ℑ",
    Igrave: "Ì",
    igrave: "ì",
    ii: "ⅈ",
    iiiint: "⨌",
    iiint: "∭",
    iinfin: "⧜",
    iiota: "℩",
    IJlig: "Ĳ",
    ijlig: "ĳ",
    Imacr: "Ī",
    imacr: "ī",
    image: "ℑ",
    ImaginaryI: "ⅈ",
    imagline: "ℐ",
    imagpart: "ℑ",
    imath: "ı",
    Im: "ℑ",
    imof: "⊷",
    imped: "Ƶ",
    Implies: "⇒",
    incare: "℅",
    in: "∈",
    infin: "∞",
    infintie: "⧝",
    inodot: "ı",
    intcal: "⊺",
    int: "∫",
    Int: "∬",
    integers: "ℤ",
    Integral: "∫",
    intercal: "⊺",
    Intersection: "⋂",
    intlarhk: "⨗",
    intprod: "⨼",
    InvisibleComma: "⁣",
    InvisibleTimes: "⁢",
    IOcy: "Ё",
    iocy: "ё",
    Iogon: "Į",
    iogon: "į",
    Iopf: "𝕀",
    iopf: "𝕚",
    Iota: "Ι",
    iota: "ι",
    iprod: "⨼",
    iquest: "¿",
    iscr: "𝒾",
    Iscr: "ℐ",
    isin: "∈",
    isindot: "⋵",
    isinE: "⋹",
    isins: "⋴",
    isinsv: "⋳",
    isinv: "∈",
    it: "⁢",
    Itilde: "Ĩ",
    itilde: "ĩ",
    Iukcy: "І",
    iukcy: "і",
    Iuml: "Ï",
    iuml: "ï",
    Jcirc: "Ĵ",
    jcirc: "ĵ",
    Jcy: "Й",
    jcy: "й",
    Jfr: "𝔍",
    jfr: "𝔧",
    jmath: "ȷ",
    Jopf: "𝕁",
    jopf: "𝕛",
    Jscr: "𝒥",
    jscr: "𝒿",
    Jsercy: "Ј",
    jsercy: "ј",
    Jukcy: "Є",
    jukcy: "є",
    Kappa: "Κ",
    kappa: "κ",
    kappav: "ϰ",
    Kcedil: "Ķ",
    kcedil: "ķ",
    Kcy: "К",
    kcy: "к",
    Kfr: "𝔎",
    kfr: "𝔨",
    kgreen: "ĸ",
    KHcy: "Х",
    khcy: "х",
    KJcy: "Ќ",
    kjcy: "ќ",
    Kopf: "𝕂",
    kopf: "𝕜",
    Kscr: "𝒦",
    kscr: "𝓀",
    lAarr: "⇚",
    Lacute: "Ĺ",
    lacute: "ĺ",
    laemptyv: "⦴",
    lagran: "ℒ",
    Lambda: "Λ",
    lambda: "λ",
    lang: "⟨",
    Lang: "⟪",
    langd: "⦑",
    langle: "⟨",
    lap: "⪅",
    Laplacetrf: "ℒ",
    laquo: "«",
    larrb: "⇤",
    larrbfs: "⤟",
    larr: "←",
    Larr: "↞",
    lArr: "⇐",
    larrfs: "⤝",
    larrhk: "↩",
    larrlp: "↫",
    larrpl: "⤹",
    larrsim: "⥳",
    larrtl: "↢",
    latail: "⤙",
    lAtail: "⤛",
    lat: "⪫",
    late: "⪭",
    lates: "⪭︀",
    lbarr: "⤌",
    lBarr: "⤎",
    lbbrk: "❲",
    lbrace: "{",
    lbrack: "[",
    lbrke: "⦋",
    lbrksld: "⦏",
    lbrkslu: "⦍",
    Lcaron: "Ľ",
    lcaron: "ľ",
    Lcedil: "Ļ",
    lcedil: "ļ",
    lceil: "⌈",
    lcub: "{",
    Lcy: "Л",
    lcy: "л",
    ldca: "⤶",
    ldquo: "“",
    ldquor: "„",
    ldrdhar: "⥧",
    ldrushar: "⥋",
    ldsh: "↲",
    le: "≤",
    lE: "≦",
    LeftAngleBracket: "⟨",
    LeftArrowBar: "⇤",
    leftarrow: "←",
    LeftArrow: "←",
    Leftarrow: "⇐",
    LeftArrowRightArrow: "⇆",
    leftarrowtail: "↢",
    LeftCeiling: "⌈",
    LeftDoubleBracket: "⟦",
    LeftDownTeeVector: "⥡",
    LeftDownVectorBar: "⥙",
    LeftDownVector: "⇃",
    LeftFloor: "⌊",
    leftharpoondown: "↽",
    leftharpoonup: "↼",
    leftleftarrows: "⇇",
    leftrightarrow: "↔",
    LeftRightArrow: "↔",
    Leftrightarrow: "⇔",
    leftrightarrows: "⇆",
    leftrightharpoons: "⇋",
    leftrightsquigarrow: "↭",
    LeftRightVector: "⥎",
    LeftTeeArrow: "↤",
    LeftTee: "⊣",
    LeftTeeVector: "⥚",
    leftthreetimes: "⋋",
    LeftTriangleBar: "⧏",
    LeftTriangle: "⊲",
    LeftTriangleEqual: "⊴",
    LeftUpDownVector: "⥑",
    LeftUpTeeVector: "⥠",
    LeftUpVectorBar: "⥘",
    LeftUpVector: "↿",
    LeftVectorBar: "⥒",
    LeftVector: "↼",
    lEg: "⪋",
    leg: "⋚",
    leq: "≤",
    leqq: "≦",
    leqslant: "⩽",
    lescc: "⪨",
    les: "⩽",
    lesdot: "⩿",
    lesdoto: "⪁",
    lesdotor: "⪃",
    lesg: "⋚︀",
    lesges: "⪓",
    lessapprox: "⪅",
    lessdot: "⋖",
    lesseqgtr: "⋚",
    lesseqqgtr: "⪋",
    LessEqualGreater: "⋚",
    LessFullEqual: "≦",
    LessGreater: "≶",
    lessgtr: "≶",
    LessLess: "⪡",
    lesssim: "≲",
    LessSlantEqual: "⩽",
    LessTilde: "≲",
    lfisht: "⥼",
    lfloor: "⌊",
    Lfr: "𝔏",
    lfr: "𝔩",
    lg: "≶",
    lgE: "⪑",
    lHar: "⥢",
    lhard: "↽",
    lharu: "↼",
    lharul: "⥪",
    lhblk: "▄",
    LJcy: "Љ",
    ljcy: "љ",
    llarr: "⇇",
    ll: "≪",
    Ll: "⋘",
    llcorner: "⌞",
    Lleftarrow: "⇚",
    llhard: "⥫",
    lltri: "◺",
    Lmidot: "Ŀ",
    lmidot: "ŀ",
    lmoustache: "⎰",
    lmoust: "⎰",
    lnap: "⪉",
    lnapprox: "⪉",
    lne: "⪇",
    lnE: "≨",
    lneq: "⪇",
    lneqq: "≨",
    lnsim: "⋦",
    loang: "⟬",
    loarr: "⇽",
    lobrk: "⟦",
    longleftarrow: "⟵",
    LongLeftArrow: "⟵",
    Longleftarrow: "⟸",
    longleftrightarrow: "⟷",
    LongLeftRightArrow: "⟷",
    Longleftrightarrow: "⟺",
    longmapsto: "⟼",
    longrightarrow: "⟶",
    LongRightArrow: "⟶",
    Longrightarrow: "⟹",
    looparrowleft: "↫",
    looparrowright: "↬",
    lopar: "⦅",
    Lopf: "𝕃",
    lopf: "𝕝",
    loplus: "⨭",
    lotimes: "⨴",
    lowast: "∗",
    lowbar: "_",
    LowerLeftArrow: "↙",
    LowerRightArrow: "↘",
    loz: "◊",
    lozenge: "◊",
    lozf: "⧫",
    lpar: "(",
    lparlt: "⦓",
    lrarr: "⇆",
    lrcorner: "⌟",
    lrhar: "⇋",
    lrhard: "⥭",
    lrm: "‎",
    lrtri: "⊿",
    lsaquo: "‹",
    lscr: "𝓁",
    Lscr: "ℒ",
    lsh: "↰",
    Lsh: "↰",
    lsim: "≲",
    lsime: "⪍",
    lsimg: "⪏",
    lsqb: "[",
    lsquo: "‘",
    lsquor: "‚",
    Lstrok: "Ł",
    lstrok: "ł",
    ltcc: "⪦",
    ltcir: "⩹",
    lt: "<",
    LT: "<",
    Lt: "≪",
    ltdot: "⋖",
    lthree: "⋋",
    ltimes: "⋉",
    ltlarr: "⥶",
    ltquest: "⩻",
    ltri: "◃",
    ltrie: "⊴",
    ltrif: "◂",
    ltrPar: "⦖",
    lurdshar: "⥊",
    luruhar: "⥦",
    lvertneqq: "≨︀",
    lvnE: "≨︀",
    macr: "¯",
    male: "♂",
    malt: "✠",
    maltese: "✠",
    Map: "⤅",
    map: "↦",
    mapsto: "↦",
    mapstodown: "↧",
    mapstoleft: "↤",
    mapstoup: "↥",
    marker: "▮",
    mcomma: "⨩",
    Mcy: "М",
    mcy: "м",
    mdash: "—",
    mDDot: "∺",
    measuredangle: "∡",
    MediumSpace: " ",
    Mellintrf: "ℳ",
    Mfr: "𝔐",
    mfr: "𝔪",
    mho: "℧",
    micro: "µ",
    midast: "*",
    midcir: "⫰",
    mid: "∣",
    middot: "·",
    minusb: "⊟",
    minus: "−",
    minusd: "∸",
    minusdu: "⨪",
    MinusPlus: "∓",
    mlcp: "⫛",
    mldr: "…",
    mnplus: "∓",
    models: "⊧",
    Mopf: "𝕄",
    mopf: "𝕞",
    mp: "∓",
    mscr: "𝓂",
    Mscr: "ℳ",
    mstpos: "∾",
    Mu: "Μ",
    mu: "μ",
    multimap: "⊸",
    mumap: "⊸",
    nabla: "∇",
    Nacute: "Ń",
    nacute: "ń",
    nang: "∠⃒",
    nap: "≉",
    napE: "⩰̸",
    napid: "≋̸",
    napos: "ŉ",
    napprox: "≉",
    natural: "♮",
    naturals: "ℕ",
    natur: "♮",
    nbsp: " ",
    nbump: "≎̸",
    nbumpe: "≏̸",
    ncap: "⩃",
    Ncaron: "Ň",
    ncaron: "ň",
    Ncedil: "Ņ",
    ncedil: "ņ",
    ncong: "≇",
    ncongdot: "⩭̸",
    ncup: "⩂",
    Ncy: "Н",
    ncy: "н",
    ndash: "–",
    nearhk: "⤤",
    nearr: "↗",
    neArr: "⇗",
    nearrow: "↗",
    ne: "≠",
    nedot: "≐̸",
    NegativeMediumSpace: "​",
    NegativeThickSpace: "​",
    NegativeThinSpace: "​",
    NegativeVeryThinSpace: "​",
    nequiv: "≢",
    nesear: "⤨",
    nesim: "≂̸",
    NestedGreaterGreater: "≫",
    NestedLessLess: "≪",
    NewLine: `
`,
    nexist: "∄",
    nexists: "∄",
    Nfr: "𝔑",
    nfr: "𝔫",
    ngE: "≧̸",
    nge: "≱",
    ngeq: "≱",
    ngeqq: "≧̸",
    ngeqslant: "⩾̸",
    nges: "⩾̸",
    nGg: "⋙̸",
    ngsim: "≵",
    nGt: "≫⃒",
    ngt: "≯",
    ngtr: "≯",
    nGtv: "≫̸",
    nharr: "↮",
    nhArr: "⇎",
    nhpar: "⫲",
    ni: "∋",
    nis: "⋼",
    nisd: "⋺",
    niv: "∋",
    NJcy: "Њ",
    njcy: "њ",
    nlarr: "↚",
    nlArr: "⇍",
    nldr: "‥",
    nlE: "≦̸",
    nle: "≰",
    nleftarrow: "↚",
    nLeftarrow: "⇍",
    nleftrightarrow: "↮",
    nLeftrightarrow: "⇎",
    nleq: "≰",
    nleqq: "≦̸",
    nleqslant: "⩽̸",
    nles: "⩽̸",
    nless: "≮",
    nLl: "⋘̸",
    nlsim: "≴",
    nLt: "≪⃒",
    nlt: "≮",
    nltri: "⋪",
    nltrie: "⋬",
    nLtv: "≪̸",
    nmid: "∤",
    NoBreak: "⁠",
    NonBreakingSpace: " ",
    nopf: "𝕟",
    Nopf: "ℕ",
    Not: "⫬",
    not: "¬",
    NotCongruent: "≢",
    NotCupCap: "≭",
    NotDoubleVerticalBar: "∦",
    NotElement: "∉",
    NotEqual: "≠",
    NotEqualTilde: "≂̸",
    NotExists: "∄",
    NotGreater: "≯",
    NotGreaterEqual: "≱",
    NotGreaterFullEqual: "≧̸",
    NotGreaterGreater: "≫̸",
    NotGreaterLess: "≹",
    NotGreaterSlantEqual: "⩾̸",
    NotGreaterTilde: "≵",
    NotHumpDownHump: "≎̸",
    NotHumpEqual: "≏̸",
    notin: "∉",
    notindot: "⋵̸",
    notinE: "⋹̸",
    notinva: "∉",
    notinvb: "⋷",
    notinvc: "⋶",
    NotLeftTriangleBar: "⧏̸",
    NotLeftTriangle: "⋪",
    NotLeftTriangleEqual: "⋬",
    NotLess: "≮",
    NotLessEqual: "≰",
    NotLessGreater: "≸",
    NotLessLess: "≪̸",
    NotLessSlantEqual: "⩽̸",
    NotLessTilde: "≴",
    NotNestedGreaterGreater: "⪢̸",
    NotNestedLessLess: "⪡̸",
    notni: "∌",
    notniva: "∌",
    notnivb: "⋾",
    notnivc: "⋽",
    NotPrecedes: "⊀",
    NotPrecedesEqual: "⪯̸",
    NotPrecedesSlantEqual: "⋠",
    NotReverseElement: "∌",
    NotRightTriangleBar: "⧐̸",
    NotRightTriangle: "⋫",
    NotRightTriangleEqual: "⋭",
    NotSquareSubset: "⊏̸",
    NotSquareSubsetEqual: "⋢",
    NotSquareSuperset: "⊐̸",
    NotSquareSupersetEqual: "⋣",
    NotSubset: "⊂⃒",
    NotSubsetEqual: "⊈",
    NotSucceeds: "⊁",
    NotSucceedsEqual: "⪰̸",
    NotSucceedsSlantEqual: "⋡",
    NotSucceedsTilde: "≿̸",
    NotSuperset: "⊃⃒",
    NotSupersetEqual: "⊉",
    NotTilde: "≁",
    NotTildeEqual: "≄",
    NotTildeFullEqual: "≇",
    NotTildeTilde: "≉",
    NotVerticalBar: "∤",
    nparallel: "∦",
    npar: "∦",
    nparsl: "⫽⃥",
    npart: "∂̸",
    npolint: "⨔",
    npr: "⊀",
    nprcue: "⋠",
    nprec: "⊀",
    npreceq: "⪯̸",
    npre: "⪯̸",
    nrarrc: "⤳̸",
    nrarr: "↛",
    nrArr: "⇏",
    nrarrw: "↝̸",
    nrightarrow: "↛",
    nRightarrow: "⇏",
    nrtri: "⋫",
    nrtrie: "⋭",
    nsc: "⊁",
    nsccue: "⋡",
    nsce: "⪰̸",
    Nscr: "𝒩",
    nscr: "𝓃",
    nshortmid: "∤",
    nshortparallel: "∦",
    nsim: "≁",
    nsime: "≄",
    nsimeq: "≄",
    nsmid: "∤",
    nspar: "∦",
    nsqsube: "⋢",
    nsqsupe: "⋣",
    nsub: "⊄",
    nsubE: "⫅̸",
    nsube: "⊈",
    nsubset: "⊂⃒",
    nsubseteq: "⊈",
    nsubseteqq: "⫅̸",
    nsucc: "⊁",
    nsucceq: "⪰̸",
    nsup: "⊅",
    nsupE: "⫆̸",
    nsupe: "⊉",
    nsupset: "⊃⃒",
    nsupseteq: "⊉",
    nsupseteqq: "⫆̸",
    ntgl: "≹",
    Ntilde: "Ñ",
    ntilde: "ñ",
    ntlg: "≸",
    ntriangleleft: "⋪",
    ntrianglelefteq: "⋬",
    ntriangleright: "⋫",
    ntrianglerighteq: "⋭",
    Nu: "Ν",
    nu: "ν",
    num: "#",
    numero: "№",
    numsp: " ",
    nvap: "≍⃒",
    nvdash: "⊬",
    nvDash: "⊭",
    nVdash: "⊮",
    nVDash: "⊯",
    nvge: "≥⃒",
    nvgt: ">⃒",
    nvHarr: "⤄",
    nvinfin: "⧞",
    nvlArr: "⤂",
    nvle: "≤⃒",
    nvlt: "<⃒",
    nvltrie: "⊴⃒",
    nvrArr: "⤃",
    nvrtrie: "⊵⃒",
    nvsim: "∼⃒",
    nwarhk: "⤣",
    nwarr: "↖",
    nwArr: "⇖",
    nwarrow: "↖",
    nwnear: "⤧",
    Oacute: "Ó",
    oacute: "ó",
    oast: "⊛",
    Ocirc: "Ô",
    ocirc: "ô",
    ocir: "⊚",
    Ocy: "О",
    ocy: "о",
    odash: "⊝",
    Odblac: "Ő",
    odblac: "ő",
    odiv: "⨸",
    odot: "⊙",
    odsold: "⦼",
    OElig: "Œ",
    oelig: "œ",
    ofcir: "⦿",
    Ofr: "𝔒",
    ofr: "𝔬",
    ogon: "˛",
    Ograve: "Ò",
    ograve: "ò",
    ogt: "⧁",
    ohbar: "⦵",
    ohm: "Ω",
    oint: "∮",
    olarr: "↺",
    olcir: "⦾",
    olcross: "⦻",
    oline: "‾",
    olt: "⧀",
    Omacr: "Ō",
    omacr: "ō",
    Omega: "Ω",
    omega: "ω",
    Omicron: "Ο",
    omicron: "ο",
    omid: "⦶",
    ominus: "⊖",
    Oopf: "𝕆",
    oopf: "𝕠",
    opar: "⦷",
    OpenCurlyDoubleQuote: "“",
    OpenCurlyQuote: "‘",
    operp: "⦹",
    oplus: "⊕",
    orarr: "↻",
    Or: "⩔",
    or: "∨",
    ord: "⩝",
    order: "ℴ",
    orderof: "ℴ",
    ordf: "ª",
    ordm: "º",
    origof: "⊶",
    oror: "⩖",
    orslope: "⩗",
    orv: "⩛",
    oS: "Ⓢ",
    Oscr: "𝒪",
    oscr: "ℴ",
    Oslash: "Ø",
    oslash: "ø",
    osol: "⊘",
    Otilde: "Õ",
    otilde: "õ",
    otimesas: "⨶",
    Otimes: "⨷",
    otimes: "⊗",
    Ouml: "Ö",
    ouml: "ö",
    ovbar: "⌽",
    OverBar: "‾",
    OverBrace: "⏞",
    OverBracket: "⎴",
    OverParenthesis: "⏜",
    para: "¶",
    parallel: "∥",
    par: "∥",
    parsim: "⫳",
    parsl: "⫽",
    part: "∂",
    PartialD: "∂",
    Pcy: "П",
    pcy: "п",
    percnt: "%",
    period: ".",
    permil: "‰",
    perp: "⊥",
    pertenk: "‱",
    Pfr: "𝔓",
    pfr: "𝔭",
    Phi: "Φ",
    phi: "φ",
    phiv: "ϕ",
    phmmat: "ℳ",
    phone: "☎",
    Pi: "Π",
    pi: "π",
    pitchfork: "⋔",
    piv: "ϖ",
    planck: "ℏ",
    planckh: "ℎ",
    plankv: "ℏ",
    plusacir: "⨣",
    plusb: "⊞",
    pluscir: "⨢",
    plus: "+",
    plusdo: "∔",
    plusdu: "⨥",
    pluse: "⩲",
    PlusMinus: "±",
    plusmn: "±",
    plussim: "⨦",
    plustwo: "⨧",
    pm: "±",
    Poincareplane: "ℌ",
    pointint: "⨕",
    popf: "𝕡",
    Popf: "ℙ",
    pound: "£",
    prap: "⪷",
    Pr: "⪻",
    pr: "≺",
    prcue: "≼",
    precapprox: "⪷",
    prec: "≺",
    preccurlyeq: "≼",
    Precedes: "≺",
    PrecedesEqual: "⪯",
    PrecedesSlantEqual: "≼",
    PrecedesTilde: "≾",
    preceq: "⪯",
    precnapprox: "⪹",
    precneqq: "⪵",
    precnsim: "⋨",
    pre: "⪯",
    prE: "⪳",
    precsim: "≾",
    prime: "′",
    Prime: "″",
    primes: "ℙ",
    prnap: "⪹",
    prnE: "⪵",
    prnsim: "⋨",
    prod: "∏",
    Product: "∏",
    profalar: "⌮",
    profline: "⌒",
    profsurf: "⌓",
    prop: "∝",
    Proportional: "∝",
    Proportion: "∷",
    propto: "∝",
    prsim: "≾",
    prurel: "⊰",
    Pscr: "𝒫",
    pscr: "𝓅",
    Psi: "Ψ",
    psi: "ψ",
    puncsp: " ",
    Qfr: "𝔔",
    qfr: "𝔮",
    qint: "⨌",
    qopf: "𝕢",
    Qopf: "ℚ",
    qprime: "⁗",
    Qscr: "𝒬",
    qscr: "𝓆",
    quaternions: "ℍ",
    quatint: "⨖",
    quest: "?",
    questeq: "≟",
    quot: '"',
    QUOT: '"',
    rAarr: "⇛",
    race: "∽̱",
    Racute: "Ŕ",
    racute: "ŕ",
    radic: "√",
    raemptyv: "⦳",
    rang: "⟩",
    Rang: "⟫",
    rangd: "⦒",
    range: "⦥",
    rangle: "⟩",
    raquo: "»",
    rarrap: "⥵",
    rarrb: "⇥",
    rarrbfs: "⤠",
    rarrc: "⤳",
    rarr: "→",
    Rarr: "↠",
    rArr: "⇒",
    rarrfs: "⤞",
    rarrhk: "↪",
    rarrlp: "↬",
    rarrpl: "⥅",
    rarrsim: "⥴",
    Rarrtl: "⤖",
    rarrtl: "↣",
    rarrw: "↝",
    ratail: "⤚",
    rAtail: "⤜",
    ratio: "∶",
    rationals: "ℚ",
    rbarr: "⤍",
    rBarr: "⤏",
    RBarr: "⤐",
    rbbrk: "❳",
    rbrace: "}",
    rbrack: "]",
    rbrke: "⦌",
    rbrksld: "⦎",
    rbrkslu: "⦐",
    Rcaron: "Ř",
    rcaron: "ř",
    Rcedil: "Ŗ",
    rcedil: "ŗ",
    rceil: "⌉",
    rcub: "}",
    Rcy: "Р",
    rcy: "р",
    rdca: "⤷",
    rdldhar: "⥩",
    rdquo: "”",
    rdquor: "”",
    rdsh: "↳",
    real: "ℜ",
    realine: "ℛ",
    realpart: "ℜ",
    reals: "ℝ",
    Re: "ℜ",
    rect: "▭",
    reg: "®",
    REG: "®",
    ReverseElement: "∋",
    ReverseEquilibrium: "⇋",
    ReverseUpEquilibrium: "⥯",
    rfisht: "⥽",
    rfloor: "⌋",
    rfr: "𝔯",
    Rfr: "ℜ",
    rHar: "⥤",
    rhard: "⇁",
    rharu: "⇀",
    rharul: "⥬",
    Rho: "Ρ",
    rho: "ρ",
    rhov: "ϱ",
    RightAngleBracket: "⟩",
    RightArrowBar: "⇥",
    rightarrow: "→",
    RightArrow: "→",
    Rightarrow: "⇒",
    RightArrowLeftArrow: "⇄",
    rightarrowtail: "↣",
    RightCeiling: "⌉",
    RightDoubleBracket: "⟧",
    RightDownTeeVector: "⥝",
    RightDownVectorBar: "⥕",
    RightDownVector: "⇂",
    RightFloor: "⌋",
    rightharpoondown: "⇁",
    rightharpoonup: "⇀",
    rightleftarrows: "⇄",
    rightleftharpoons: "⇌",
    rightrightarrows: "⇉",
    rightsquigarrow: "↝",
    RightTeeArrow: "↦",
    RightTee: "⊢",
    RightTeeVector: "⥛",
    rightthreetimes: "⋌",
    RightTriangleBar: "⧐",
    RightTriangle: "⊳",
    RightTriangleEqual: "⊵",
    RightUpDownVector: "⥏",
    RightUpTeeVector: "⥜",
    RightUpVectorBar: "⥔",
    RightUpVector: "↾",
    RightVectorBar: "⥓",
    RightVector: "⇀",
    ring: "˚",
    risingdotseq: "≓",
    rlarr: "⇄",
    rlhar: "⇌",
    rlm: "‏",
    rmoustache: "⎱",
    rmoust: "⎱",
    rnmid: "⫮",
    roang: "⟭",
    roarr: "⇾",
    robrk: "⟧",
    ropar: "⦆",
    ropf: "𝕣",
    Ropf: "ℝ",
    roplus: "⨮",
    rotimes: "⨵",
    RoundImplies: "⥰",
    rpar: ")",
    rpargt: "⦔",
    rppolint: "⨒",
    rrarr: "⇉",
    Rrightarrow: "⇛",
    rsaquo: "›",
    rscr: "𝓇",
    Rscr: "ℛ",
    rsh: "↱",
    Rsh: "↱",
    rsqb: "]",
    rsquo: "’",
    rsquor: "’",
    rthree: "⋌",
    rtimes: "⋊",
    rtri: "▹",
    rtrie: "⊵",
    rtrif: "▸",
    rtriltri: "⧎",
    RuleDelayed: "⧴",
    ruluhar: "⥨",
    rx: "℞",
    Sacute: "Ś",
    sacute: "ś",
    sbquo: "‚",
    scap: "⪸",
    Scaron: "Š",
    scaron: "š",
    Sc: "⪼",
    sc: "≻",
    sccue: "≽",
    sce: "⪰",
    scE: "⪴",
    Scedil: "Ş",
    scedil: "ş",
    Scirc: "Ŝ",
    scirc: "ŝ",
    scnap: "⪺",
    scnE: "⪶",
    scnsim: "⋩",
    scpolint: "⨓",
    scsim: "≿",
    Scy: "С",
    scy: "с",
    sdotb: "⊡",
    sdot: "⋅",
    sdote: "⩦",
    searhk: "⤥",
    searr: "↘",
    seArr: "⇘",
    searrow: "↘",
    sect: "§",
    semi: ";",
    seswar: "⤩",
    setminus: "∖",
    setmn: "∖",
    sext: "✶",
    Sfr: "𝔖",
    sfr: "𝔰",
    sfrown: "⌢",
    sharp: "♯",
    SHCHcy: "Щ",
    shchcy: "щ",
    SHcy: "Ш",
    shcy: "ш",
    ShortDownArrow: "↓",
    ShortLeftArrow: "←",
    shortmid: "∣",
    shortparallel: "∥",
    ShortRightArrow: "→",
    ShortUpArrow: "↑",
    shy: "­",
    Sigma: "Σ",
    sigma: "σ",
    sigmaf: "ς",
    sigmav: "ς",
    sim: "∼",
    simdot: "⩪",
    sime: "≃",
    simeq: "≃",
    simg: "⪞",
    simgE: "⪠",
    siml: "⪝",
    simlE: "⪟",
    simne: "≆",
    simplus: "⨤",
    simrarr: "⥲",
    slarr: "←",
    SmallCircle: "∘",
    smallsetminus: "∖",
    smashp: "⨳",
    smeparsl: "⧤",
    smid: "∣",
    smile: "⌣",
    smt: "⪪",
    smte: "⪬",
    smtes: "⪬︀",
    SOFTcy: "Ь",
    softcy: "ь",
    solbar: "⌿",
    solb: "⧄",
    sol: "/",
    Sopf: "𝕊",
    sopf: "𝕤",
    spades: "♠",
    spadesuit: "♠",
    spar: "∥",
    sqcap: "⊓",
    sqcaps: "⊓︀",
    sqcup: "⊔",
    sqcups: "⊔︀",
    Sqrt: "√",
    sqsub: "⊏",
    sqsube: "⊑",
    sqsubset: "⊏",
    sqsubseteq: "⊑",
    sqsup: "⊐",
    sqsupe: "⊒",
    sqsupset: "⊐",
    sqsupseteq: "⊒",
    square: "□",
    Square: "□",
    SquareIntersection: "⊓",
    SquareSubset: "⊏",
    SquareSubsetEqual: "⊑",
    SquareSuperset: "⊐",
    SquareSupersetEqual: "⊒",
    SquareUnion: "⊔",
    squarf: "▪",
    squ: "□",
    squf: "▪",
    srarr: "→",
    Sscr: "𝒮",
    sscr: "𝓈",
    ssetmn: "∖",
    ssmile: "⌣",
    sstarf: "⋆",
    Star: "⋆",
    star: "☆",
    starf: "★",
    straightepsilon: "ϵ",
    straightphi: "ϕ",
    strns: "¯",
    sub: "⊂",
    Sub: "⋐",
    subdot: "⪽",
    subE: "⫅",
    sube: "⊆",
    subedot: "⫃",
    submult: "⫁",
    subnE: "⫋",
    subne: "⊊",
    subplus: "⪿",
    subrarr: "⥹",
    subset: "⊂",
    Subset: "⋐",
    subseteq: "⊆",
    subseteqq: "⫅",
    SubsetEqual: "⊆",
    subsetneq: "⊊",
    subsetneqq: "⫋",
    subsim: "⫇",
    subsub: "⫕",
    subsup: "⫓",
    succapprox: "⪸",
    succ: "≻",
    succcurlyeq: "≽",
    Succeeds: "≻",
    SucceedsEqual: "⪰",
    SucceedsSlantEqual: "≽",
    SucceedsTilde: "≿",
    succeq: "⪰",
    succnapprox: "⪺",
    succneqq: "⪶",
    succnsim: "⋩",
    succsim: "≿",
    SuchThat: "∋",
    sum: "∑",
    Sum: "∑",
    sung: "♪",
    sup1: "¹",
    sup2: "²",
    sup3: "³",
    sup: "⊃",
    Sup: "⋑",
    supdot: "⪾",
    supdsub: "⫘",
    supE: "⫆",
    supe: "⊇",
    supedot: "⫄",
    Superset: "⊃",
    SupersetEqual: "⊇",
    suphsol: "⟉",
    suphsub: "⫗",
    suplarr: "⥻",
    supmult: "⫂",
    supnE: "⫌",
    supne: "⊋",
    supplus: "⫀",
    supset: "⊃",
    Supset: "⋑",
    supseteq: "⊇",
    supseteqq: "⫆",
    supsetneq: "⊋",
    supsetneqq: "⫌",
    supsim: "⫈",
    supsub: "⫔",
    supsup: "⫖",
    swarhk: "⤦",
    swarr: "↙",
    swArr: "⇙",
    swarrow: "↙",
    swnwar: "⤪",
    szlig: "ß",
    Tab: "	",
    target: "⌖",
    Tau: "Τ",
    tau: "τ",
    tbrk: "⎴",
    Tcaron: "Ť",
    tcaron: "ť",
    Tcedil: "Ţ",
    tcedil: "ţ",
    Tcy: "Т",
    tcy: "т",
    tdot: "⃛",
    telrec: "⌕",
    Tfr: "𝔗",
    tfr: "𝔱",
    there4: "∴",
    therefore: "∴",
    Therefore: "∴",
    Theta: "Θ",
    theta: "θ",
    thetasym: "ϑ",
    thetav: "ϑ",
    thickapprox: "≈",
    thicksim: "∼",
    ThickSpace: "  ",
    ThinSpace: " ",
    thinsp: " ",
    thkap: "≈",
    thksim: "∼",
    THORN: "Þ",
    thorn: "þ",
    tilde: "˜",
    Tilde: "∼",
    TildeEqual: "≃",
    TildeFullEqual: "≅",
    TildeTilde: "≈",
    timesbar: "⨱",
    timesb: "⊠",
    times: "×",
    timesd: "⨰",
    tint: "∭",
    toea: "⤨",
    topbot: "⌶",
    topcir: "⫱",
    top: "⊤",
    Topf: "𝕋",
    topf: "𝕥",
    topfork: "⫚",
    tosa: "⤩",
    tprime: "‴",
    trade: "™",
    TRADE: "™",
    triangle: "▵",
    triangledown: "▿",
    triangleleft: "◃",
    trianglelefteq: "⊴",
    triangleq: "≜",
    triangleright: "▹",
    trianglerighteq: "⊵",
    tridot: "◬",
    trie: "≜",
    triminus: "⨺",
    TripleDot: "⃛",
    triplus: "⨹",
    trisb: "⧍",
    tritime: "⨻",
    trpezium: "⏢",
    Tscr: "𝒯",
    tscr: "𝓉",
    TScy: "Ц",
    tscy: "ц",
    TSHcy: "Ћ",
    tshcy: "ћ",
    Tstrok: "Ŧ",
    tstrok: "ŧ",
    twixt: "≬",
    twoheadleftarrow: "↞",
    twoheadrightarrow: "↠",
    Uacute: "Ú",
    uacute: "ú",
    uarr: "↑",
    Uarr: "↟",
    uArr: "⇑",
    Uarrocir: "⥉",
    Ubrcy: "Ў",
    ubrcy: "ў",
    Ubreve: "Ŭ",
    ubreve: "ŭ",
    Ucirc: "Û",
    ucirc: "û",
    Ucy: "У",
    ucy: "у",
    udarr: "⇅",
    Udblac: "Ű",
    udblac: "ű",
    udhar: "⥮",
    ufisht: "⥾",
    Ufr: "𝔘",
    ufr: "𝔲",
    Ugrave: "Ù",
    ugrave: "ù",
    uHar: "⥣",
    uharl: "↿",
    uharr: "↾",
    uhblk: "▀",
    ulcorn: "⌜",
    ulcorner: "⌜",
    ulcrop: "⌏",
    ultri: "◸",
    Umacr: "Ū",
    umacr: "ū",
    uml: "¨",
    UnderBar: "_",
    UnderBrace: "⏟",
    UnderBracket: "⎵",
    UnderParenthesis: "⏝",
    Union: "⋃",
    UnionPlus: "⊎",
    Uogon: "Ų",
    uogon: "ų",
    Uopf: "𝕌",
    uopf: "𝕦",
    UpArrowBar: "⤒",
    uparrow: "↑",
    UpArrow: "↑",
    Uparrow: "⇑",
    UpArrowDownArrow: "⇅",
    updownarrow: "↕",
    UpDownArrow: "↕",
    Updownarrow: "⇕",
    UpEquilibrium: "⥮",
    upharpoonleft: "↿",
    upharpoonright: "↾",
    uplus: "⊎",
    UpperLeftArrow: "↖",
    UpperRightArrow: "↗",
    upsi: "υ",
    Upsi: "ϒ",
    upsih: "ϒ",
    Upsilon: "Υ",
    upsilon: "υ",
    UpTeeArrow: "↥",
    UpTee: "⊥",
    upuparrows: "⇈",
    urcorn: "⌝",
    urcorner: "⌝",
    urcrop: "⌎",
    Uring: "Ů",
    uring: "ů",
    urtri: "◹",
    Uscr: "𝒰",
    uscr: "𝓊",
    utdot: "⋰",
    Utilde: "Ũ",
    utilde: "ũ",
    utri: "▵",
    utrif: "▴",
    uuarr: "⇈",
    Uuml: "Ü",
    uuml: "ü",
    uwangle: "⦧",
    vangrt: "⦜",
    varepsilon: "ϵ",
    varkappa: "ϰ",
    varnothing: "∅",
    varphi: "ϕ",
    varpi: "ϖ",
    varpropto: "∝",
    varr: "↕",
    vArr: "⇕",
    varrho: "ϱ",
    varsigma: "ς",
    varsubsetneq: "⊊︀",
    varsubsetneqq: "⫋︀",
    varsupsetneq: "⊋︀",
    varsupsetneqq: "⫌︀",
    vartheta: "ϑ",
    vartriangleleft: "⊲",
    vartriangleright: "⊳",
    vBar: "⫨",
    Vbar: "⫫",
    vBarv: "⫩",
    Vcy: "В",
    vcy: "в",
    vdash: "⊢",
    vDash: "⊨",
    Vdash: "⊩",
    VDash: "⊫",
    Vdashl: "⫦",
    veebar: "⊻",
    vee: "∨",
    Vee: "⋁",
    veeeq: "≚",
    vellip: "⋮",
    verbar: "|",
    Verbar: "‖",
    vert: "|",
    Vert: "‖",
    VerticalBar: "∣",
    VerticalLine: "|",
    VerticalSeparator: "❘",
    VerticalTilde: "≀",
    VeryThinSpace: " ",
    Vfr: "𝔙",
    vfr: "𝔳",
    vltri: "⊲",
    vnsub: "⊂⃒",
    vnsup: "⊃⃒",
    Vopf: "𝕍",
    vopf: "𝕧",
    vprop: "∝",
    vrtri: "⊳",
    Vscr: "𝒱",
    vscr: "𝓋",
    vsubnE: "⫋︀",
    vsubne: "⊊︀",
    vsupnE: "⫌︀",
    vsupne: "⊋︀",
    Vvdash: "⊪",
    vzigzag: "⦚",
    Wcirc: "Ŵ",
    wcirc: "ŵ",
    wedbar: "⩟",
    wedge: "∧",
    Wedge: "⋀",
    wedgeq: "≙",
    weierp: "℘",
    Wfr: "𝔚",
    wfr: "𝔴",
    Wopf: "𝕎",
    wopf: "𝕨",
    wp: "℘",
    wr: "≀",
    wreath: "≀",
    Wscr: "𝒲",
    wscr: "𝓌",
    xcap: "⋂",
    xcirc: "◯",
    xcup: "⋃",
    xdtri: "▽",
    Xfr: "𝔛",
    xfr: "𝔵",
    xharr: "⟷",
    xhArr: "⟺",
    Xi: "Ξ",
    xi: "ξ",
    xlarr: "⟵",
    xlArr: "⟸",
    xmap: "⟼",
    xnis: "⋻",
    xodot: "⨀",
    Xopf: "𝕏",
    xopf: "𝕩",
    xoplus: "⨁",
    xotime: "⨂",
    xrarr: "⟶",
    xrArr: "⟹",
    Xscr: "𝒳",
    xscr: "𝓍",
    xsqcup: "⨆",
    xuplus: "⨄",
    xutri: "△",
    xvee: "⋁",
    xwedge: "⋀",
    Yacute: "Ý",
    yacute: "ý",
    YAcy: "Я",
    yacy: "я",
    Ycirc: "Ŷ",
    ycirc: "ŷ",
    Ycy: "Ы",
    ycy: "ы",
    yen: "¥",
    Yfr: "𝔜",
    yfr: "𝔶",
    YIcy: "Ї",
    yicy: "ї",
    Yopf: "𝕐",
    yopf: "𝕪",
    Yscr: "𝒴",
    yscr: "𝓎",
    YUcy: "Ю",
    yucy: "ю",
    yuml: "ÿ",
    Yuml: "Ÿ",
    Zacute: "Ź",
    zacute: "ź",
    Zcaron: "Ž",
    zcaron: "ž",
    Zcy: "З",
    zcy: "з",
    Zdot: "Ż",
    zdot: "ż",
    zeetrf: "ℨ",
    ZeroWidthSpace: "​",
    Zeta: "Ζ",
    zeta: "ζ",
    zfr: "𝔷",
    Zfr: "ℨ",
    ZHcy: "Ж",
    zhcy: "ж",
    zigrarr: "⇝",
    zopf: "𝕫",
    Zopf: "ℤ",
    Zscr: "𝒵",
    zscr: "𝓏",
    zwj: "‍",
    zwnj: "‌"
  };
});
var on2 = I4((Tf, Na) => {
  Na.exports = {
    Aacute: "Á",
    aacute: "á",
    Acirc: "Â",
    acirc: "â",
    acute: "´",
    AElig: "Æ",
    aelig: "æ",
    Agrave: "À",
    agrave: "à",
    amp: "&",
    AMP: "&",
    Aring: "Å",
    aring: "å",
    Atilde: "Ã",
    atilde: "ã",
    Auml: "Ä",
    auml: "ä",
    brvbar: "¦",
    Ccedil: "Ç",
    ccedil: "ç",
    cedil: "¸",
    cent: "¢",
    copy: "©",
    COPY: "©",
    curren: "¤",
    deg: "°",
    divide: "÷",
    Eacute: "É",
    eacute: "é",
    Ecirc: "Ê",
    ecirc: "ê",
    Egrave: "È",
    egrave: "è",
    ETH: "Ð",
    eth: "ð",
    Euml: "Ë",
    euml: "ë",
    frac12: "½",
    frac14: "¼",
    frac34: "¾",
    gt: ">",
    GT: ">",
    Iacute: "Í",
    iacute: "í",
    Icirc: "Î",
    icirc: "î",
    iexcl: "¡",
    Igrave: "Ì",
    igrave: "ì",
    iquest: "¿",
    Iuml: "Ï",
    iuml: "ï",
    laquo: "«",
    lt: "<",
    LT: "<",
    macr: "¯",
    micro: "µ",
    middot: "·",
    nbsp: " ",
    not: "¬",
    Ntilde: "Ñ",
    ntilde: "ñ",
    Oacute: "Ó",
    oacute: "ó",
    Ocirc: "Ô",
    ocirc: "ô",
    Ograve: "Ò",
    ograve: "ò",
    ordf: "ª",
    ordm: "º",
    Oslash: "Ø",
    oslash: "ø",
    Otilde: "Õ",
    otilde: "õ",
    Ouml: "Ö",
    ouml: "ö",
    para: "¶",
    plusmn: "±",
    pound: "£",
    quot: '"',
    QUOT: '"',
    raquo: "»",
    reg: "®",
    REG: "®",
    sect: "§",
    shy: "­",
    sup1: "¹",
    sup2: "²",
    sup3: "³",
    szlig: "ß",
    THORN: "Þ",
    thorn: "þ",
    times: "×",
    Uacute: "Ú",
    uacute: "ú",
    Ucirc: "Û",
    ucirc: "û",
    Ugrave: "Ù",
    ugrave: "ù",
    uml: "¨",
    Uuml: "Ü",
    uuml: "ü",
    Yacute: "Ý",
    yacute: "ý",
    yen: "¥",
    yuml: "ÿ"
  };
});
var ht = I4((xf, La2) => {
  La2.exports = { amp: "&", apos: "'", gt: ">", lt: "<", quot: '"' };
});
var nn2 = I4((Rf, qa) => {
  qa.exports = {
    "0": 65533,
    "128": 8364,
    "130": 8218,
    "131": 402,
    "132": 8222,
    "133": 8230,
    "134": 8224,
    "135": 8225,
    "136": 710,
    "137": 8240,
    "138": 352,
    "139": 8249,
    "140": 338,
    "142": 381,
    "145": 8216,
    "146": 8217,
    "147": 8220,
    "148": 8221,
    "149": 8226,
    "150": 8211,
    "151": 8212,
    "152": 732,
    "153": 8482,
    "154": 353,
    "155": 8250,
    "156": 339,
    "158": 382,
    "159": 376
  };
});
var an2 = I4((ze2) => {
  "use strict";
  var za = ze2 && ze2.__importDefault || function(r2) {
    return r2 && r2.__esModule ? r2 : { default: r2 };
  };
  Object.defineProperty(ze2, "__esModule", { value: true });
  var sn2 = za(nn2()), Ba = (
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    String.fromCodePoint || function(r2) {
      var e2 = "";
      return r2 > 65535 && (r2 -= 65536, e2 += String.fromCharCode(r2 >>> 10 & 1023 | 55296), r2 = 56320 | r2 & 1023), e2 += String.fromCharCode(r2), e2;
    }
  );
  function Ga(r2) {
    return r2 >= 55296 && r2 <= 57343 || r2 > 1114111 ? "�" : (r2 in sn2.default && (r2 = sn2.default[r2]), Ba(r2));
  }
  n3(Ga, "decodeCodePoint");
  ze2.default = Ga;
});
var bt2 = I4((H3) => {
  "use strict";
  var cr2 = H3 && H3.__importDefault || function(r2) {
    return r2 && r2.__esModule ? r2 : { default: r2 };
  };
  Object.defineProperty(H3, "__esModule", { value: true });
  H3.decodeHTML = H3.decodeHTMLStrict = H3.decodeXML = void 0;
  var gt = cr2(mt2()), Ua = cr2(on2()), Ha = cr2(ht()), ln2 = cr2(an2()), Va = /&(?:[a-zA-Z0-9]+|#[xX][\da-fA-F]+|#\d+);/g;
  H3.decodeXML = dn2(Ha.default);
  H3.decodeHTMLStrict = dn2(gt.default);
  function dn2(r2) {
    var e2 = pn2(r2);
    return function(t2) {
      return String(t2).replace(Va, e2);
    };
  }
  n3(dn2, "getStrictDecoder");
  var cn3 = n3(function(r2, e2) {
    return r2 < e2 ? 1 : -1;
  }, "sorter");
  H3.decodeHTML = (function() {
    for (var r2 = Object.keys(Ua.default).sort(cn3), e2 = Object.keys(gt.default).sort(cn3), t2 = 0, o2 = 0; t2 < e2.length; t2++)
      r2[o2] === e2[t2] ? (e2[t2] += ";?", o2++) : e2[t2] += ";";
    var s2 = new RegExp("&(?:" + e2.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g"), i2 = pn2(gt.default);
    function a(l2) {
      return l2.substr(-1) !== ";" && (l2 += ";"), i2(l2);
    }
    return n3(a, "replacer"), function(l2) {
      return String(l2).replace(s2, a);
    };
  })();
  function pn2(r2) {
    return n3(function(t2) {
      if (t2.charAt(1) === "#") {
        var o2 = t2.charAt(2);
        return o2 === "X" || o2 === "x" ? ln2.default(parseInt(t2.substr(3), 16)) : ln2.default(parseInt(t2.substr(2), 10));
      }
      return r2[t2.slice(1, -1)] || t2;
    }, "replace");
  }
  n3(pn2, "getReplacer");
});
var Tt2 = I4((M4) => {
  "use strict";
  var un2 = M4 && M4.__importDefault || function(r2) {
    return r2 && r2.__esModule ? r2 : { default: r2 };
  };
  Object.defineProperty(M4, "__esModule", { value: true });
  M4.escapeUTF8 = M4.escape = M4.encodeNonAsciiHTML = M4.encodeHTML = M4.encodeXML = void 0;
  var Wa = un2(ht()), fn = mn2(Wa.default), yn = hn2(fn);
  M4.encodeXML = Sn(fn);
  var $a = un2(mt2()), St2 = mn2($a.default), Ya = hn2(St2);
  M4.encodeHTML = Xa(St2, Ya);
  M4.encodeNonAsciiHTML = Sn(St2);
  function mn2(r2) {
    return Object.keys(r2).sort().reduce(function(e2, t2) {
      return e2[r2[t2]] = "&" + t2 + ";", e2;
    }, {});
  }
  n3(mn2, "getInverseObj");
  function hn2(r2) {
    for (var e2 = [], t2 = [], o2 = 0, s2 = Object.keys(r2); o2 < s2.length; o2++) {
      var i2 = s2[o2];
      i2.length === 1 ? e2.push("\\" + i2) : t2.push(i2);
    }
    e2.sort();
    for (var a = 0; a < e2.length - 1; a++) {
      for (var l2 = a; l2 < e2.length - 1 && e2[l2].charCodeAt(1) + 1 === e2[l2 + 1].charCodeAt(1); )
        l2 += 1;
      var c = 1 + l2 - a;
      c < 3 || e2.splice(a, c, e2[a] + "-" + e2[l2]);
    }
    return t2.unshift("[" + e2.join("") + "]"), new RegExp(t2.join("|"), "g");
  }
  n3(hn2, "getInverseReplacer");
  var gn2 = /(?:[\x80-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g, Ka = (
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    String.prototype.codePointAt != null ? (
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      (function(r2) {
        return r2.codePointAt(0);
      })
    ) : (
      // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
      (function(r2) {
        return (r2.charCodeAt(0) - 55296) * 1024 + r2.charCodeAt(1) - 56320 + 65536;
      })
    )
  );
  function dr2(r2) {
    return "&#x" + (r2.length > 1 ? Ka(r2) : r2.charCodeAt(0)).toString(16).toUpperCase() + ";";
  }
  n3(dr2, "singleCharReplacer");
  function Xa(r2, e2) {
    return function(t2) {
      return t2.replace(e2, function(o2) {
        return r2[o2];
      }).replace(gn2, dr2);
    };
  }
  n3(Xa, "getInverse");
  var bn = new RegExp(yn.source + "|" + gn2.source, "g");
  function Ja(r2) {
    return r2.replace(bn, dr2);
  }
  n3(Ja, "escape");
  M4.escape = Ja;
  function Qa(r2) {
    return r2.replace(yn, dr2);
  }
  n3(Qa, "escapeUTF8");
  M4.escapeUTF8 = Qa;
  function Sn(r2) {
    return function(e2) {
      return e2.replace(bn, function(t2) {
        return r2[t2] || dr2(t2);
      });
    };
  }
  n3(Sn, "getASCIIEncoder");
});
var xn2 = I4((A3) => {
  "use strict";
  Object.defineProperty(A3, "__esModule", { value: true });
  A3.decodeXMLStrict = A3.decodeHTML5Strict = A3.decodeHTML4Strict = A3.decodeHTML5 = A3.decodeHTML4 = A3.decodeHTMLStrict = A3.decodeHTML = A3.decodeXML = A3.encodeHTML5 = A3.encodeHTML4 = A3.escapeUTF8 = A3.escape = A3.encodeNonAsciiHTML = A3.encodeHTML = A3.encodeXML = A3.encode = A3.decodeStrict = A3.decode = void 0;
  var pr2 = bt2(), Tn = Tt2();
  function Za(r2, e2) {
    return (!e2 || e2 <= 0 ? pr2.decodeXML : pr2.decodeHTML)(r2);
  }
  n3(Za, "decode");
  A3.decode = Za;
  function el(r2, e2) {
    return (!e2 || e2 <= 0 ? pr2.decodeXML : pr2.decodeHTMLStrict)(r2);
  }
  n3(el, "decodeStrict");
  A3.decodeStrict = el;
  function rl(r2, e2) {
    return (!e2 || e2 <= 0 ? Tn.encodeXML : Tn.encodeHTML)(r2);
  }
  n3(rl, "encode");
  A3.encode = rl;
  var ce3 = Tt2();
  Object.defineProperty(A3, "encodeXML", { enumerable: true, get: n3(function() {
    return ce3.encodeXML;
  }, "get") });
  Object.defineProperty(A3, "encodeHTML", { enumerable: true, get: n3(function() {
    return ce3.encodeHTML;
  }, "get") });
  Object.defineProperty(A3, "encodeNonAsciiHTML", { enumerable: true, get: n3(function() {
    return ce3.encodeNonAsciiHTML;
  }, "get") });
  Object.defineProperty(A3, "escape", { enumerable: true, get: n3(function() {
    return ce3.escape;
  }, "get") });
  Object.defineProperty(A3, "escapeUTF8", { enumerable: true, get: n3(function() {
    return ce3.escapeUTF8;
  }, "get") });
  Object.defineProperty(A3, "encodeHTML4", { enumerable: true, get: n3(function() {
    return ce3.encodeHTML;
  }, "get") });
  Object.defineProperty(A3, "encodeHTML5", { enumerable: true, get: n3(function() {
    return ce3.encodeHTML;
  }, "get") });
  var ee2 = bt2();
  Object.defineProperty(A3, "decodeXML", { enumerable: true, get: n3(function() {
    return ee2.decodeXML;
  }, "get") });
  Object.defineProperty(A3, "decodeHTML", { enumerable: true, get: n3(function() {
    return ee2.decodeHTML;
  }, "get") });
  Object.defineProperty(A3, "decodeHTMLStrict", { enumerable: true, get: n3(function() {
    return ee2.decodeHTMLStrict;
  }, "get") });
  Object.defineProperty(A3, "decodeHTML4", { enumerable: true, get: n3(function() {
    return ee2.decodeHTML;
  }, "get") });
  Object.defineProperty(A3, "decodeHTML5", { enumerable: true, get: n3(function() {
    return ee2.decodeHTML;
  }, "get") });
  Object.defineProperty(A3, "decodeHTML4Strict", { enumerable: true, get: n3(function() {
    return ee2.decodeHTMLStrict;
  }, "get") });
  Object.defineProperty(A3, "decodeHTML5Strict", { enumerable: true, get: n3(function() {
    return ee2.decodeHTMLStrict;
  }, "get") });
  Object.defineProperty(A3, "decodeXMLStrict", { enumerable: true, get: n3(function() {
    return ee2.decodeXML;
  }, "get") });
});
var Dn = I4((Of, On) => {
  "use strict";
  function tl(r2, e2) {
    if (!(r2 instanceof e2))
      throw new TypeError("Cannot call a class as a function");
  }
  n3(tl, "_classCallCheck");
  function Rn2(r2, e2) {
    for (var t2 = 0; t2 < e2.length; t2++) {
      var o2 = e2[t2];
      o2.enumerable = o2.enumerable || false, o2.configurable = true, "value" in o2 && (o2.writable = true), Object.defineProperty(r2, o2.key, o2);
    }
  }
  n3(Rn2, "_defineProperties");
  function ol(r2, e2, t2) {
    return e2 && Rn2(r2.prototype, e2), t2 && Rn2(r2, t2), r2;
  }
  n3(ol, "_createClass");
  function Pn(r2, e2) {
    var t2 = typeof Symbol < "u" && r2[Symbol.iterator] || r2["@@iterator"];
    if (!t2) {
      if (Array.isArray(r2) || (t2 = nl(r2)) || e2 && r2 && typeof r2.length == "number") {
        t2 && (r2 = t2);
        var o2 = 0, s2 = n3(function() {
        }, "F");
        return { s: s2, n: n3(function() {
          return o2 >= r2.length ? { done: true } : { done: false, value: r2[o2++] };
        }, "n"), e: n3(function(d2) {
          throw d2;
        }, "e"), f: s2 };
      }
      throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    var i2 = true, a = false, l2;
    return { s: n3(function() {
      t2 = t2.call(r2);
    }, "s"), n: n3(function() {
      var d2 = t2.next();
      return i2 = d2.done, d2;
    }, "n"), e: n3(function(d2) {
      a = true, l2 = d2;
    }, "e"), f: n3(function() {
      try {
        !i2 && t2.return != null && t2.return();
      } finally {
        if (a) throw l2;
      }
    }, "f") };
  }
  n3(Pn, "_createForOfIteratorHelper");
  function nl(r2, e2) {
    if (r2) {
      if (typeof r2 == "string") return wn(r2, e2);
      var t2 = Object.prototype.toString.call(r2).slice(8, -1);
      if (t2 === "Object" && r2.constructor && (t2 = r2.constructor.name), t2 === "Map" || t2 === "Set") return Array.from(r2);
      if (t2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t2)) return wn(r2, e2);
    }
  }
  n3(nl, "_unsupportedIterableToArray");
  function wn(r2, e2) {
    (e2 == null || e2 > r2.length) && (e2 = r2.length);
    for (var t2 = 0, o2 = new Array(e2); t2 < e2; t2++)
      o2[t2] = r2[t2];
    return o2;
  }
  n3(wn, "_arrayLikeToArray");
  var sl = xn2(), An2 = {
    fg: "#FFF",
    bg: "#000",
    newline: false,
    escapeXML: false,
    stream: false,
    colors: il()
  };
  function il() {
    var r2 = {
      0: "#000",
      1: "#A00",
      2: "#0A0",
      3: "#A50",
      4: "#00A",
      5: "#A0A",
      6: "#0AA",
      7: "#AAA",
      8: "#555",
      9: "#F55",
      10: "#5F5",
      11: "#FF5",
      12: "#55F",
      13: "#F5F",
      14: "#5FF",
      15: "#FFF"
    };
    return ur(0, 5).forEach(function(e2) {
      ur(0, 5).forEach(function(t2) {
        ur(0, 5).forEach(function(o2) {
          return al(e2, t2, o2, r2);
        });
      });
    }), ur(0, 23).forEach(function(e2) {
      var t2 = e2 + 232, o2 = Fn2(e2 * 10 + 8);
      r2[t2] = "#" + o2 + o2 + o2;
    }), r2;
  }
  n3(il, "getDefaultColors");
  function al(r2, e2, t2, o2) {
    var s2 = 16 + r2 * 36 + e2 * 6 + t2, i2 = r2 > 0 ? r2 * 40 + 55 : 0, a = e2 > 0 ? e2 * 40 + 55 : 0, l2 = t2 > 0 ? t2 * 40 + 55 : 0;
    o2[s2] = ll([i2, a, l2]);
  }
  n3(al, "setStyleColor");
  function Fn2(r2) {
    for (var e2 = r2.toString(16); e2.length < 2; )
      e2 = "0" + e2;
    return e2;
  }
  n3(Fn2, "toHexString");
  function ll(r2) {
    var e2 = [], t2 = Pn(r2), o2;
    try {
      for (t2.s(); !(o2 = t2.n()).done; ) {
        var s2 = o2.value;
        e2.push(Fn2(s2));
      }
    } catch (i2) {
      t2.e(i2);
    } finally {
      t2.f();
    }
    return "#" + e2.join("");
  }
  n3(ll, "toColorHexString");
  function En(r2, e2, t2, o2) {
    var s2;
    return e2 === "text" ? s2 = ul(t2, o2) : e2 === "display" ? s2 = dl(r2, t2, o2) : e2 === "xterm256Foreground" ? s2 = yr2(r2, o2.colors[t2]) : e2 === "xterm256Background" ? s2 = mr2(r2, o2.colors[t2]) : e2 === "rgb" && (s2 = cl(r2, t2)), s2;
  }
  n3(En, "generateOutput");
  function cl(r2, e2) {
    e2 = e2.substring(2).slice(0, -1);
    var t2 = +e2.substr(0, 2), o2 = e2.substring(5).split(";"), s2 = o2.map(function(i2) {
      return ("0" + Number(i2).toString(16)).substr(-2);
    }).join("");
    return fr2(r2, (t2 === 38 ? "color:#" : "background-color:#") + s2);
  }
  n3(cl, "handleRgb");
  function dl(r2, e2, t2) {
    e2 = parseInt(e2, 10);
    var o2 = {
      "-1": n3(function() {
        return "<br/>";
      }, "_"),
      0: n3(function() {
        return r2.length && In2(r2);
      }, "_"),
      1: n3(function() {
        return re3(r2, "b");
      }, "_"),
      3: n3(function() {
        return re3(r2, "i");
      }, "_"),
      4: n3(function() {
        return re3(r2, "u");
      }, "_"),
      8: n3(function() {
        return fr2(r2, "display:none");
      }, "_"),
      9: n3(function() {
        return re3(r2, "strike");
      }, "_"),
      22: n3(function() {
        return fr2(r2, "font-weight:normal;text-decoration:none;font-style:normal");
      }, "_"),
      23: n3(function() {
        return vn(r2, "i");
      }, "_"),
      24: n3(function() {
        return vn(r2, "u");
      }, "_"),
      39: n3(function() {
        return yr2(r2, t2.fg);
      }, "_"),
      49: n3(function() {
        return mr2(r2, t2.bg);
      }, "_"),
      53: n3(function() {
        return fr2(r2, "text-decoration:overline");
      }, "_")
    }, s2;
    return o2[e2] ? s2 = o2[e2]() : 4 < e2 && e2 < 7 ? s2 = re3(r2, "blink") : 29 < e2 && e2 < 38 ? s2 = yr2(r2, t2.colors[e2 - 30]) : 39 < e2 && e2 < 48 ? s2 = mr2(r2, t2.colors[e2 - 40]) : 89 < e2 && e2 < 98 ? s2 = yr2(r2, t2.colors[8 + (e2 - 90)]) : 99 < e2 && e2 < 108 && (s2 = mr2(r2, t2.colors[8 + (e2 - 100)])), s2;
  }
  n3(dl, "handleDisplay");
  function In2(r2) {
    var e2 = r2.slice(0);
    return r2.length = 0, e2.reverse().map(function(t2) {
      return "</" + t2 + ">";
    }).join("");
  }
  n3(In2, "resetStyles");
  function ur(r2, e2) {
    for (var t2 = [], o2 = r2; o2 <= e2; o2++)
      t2.push(o2);
    return t2;
  }
  n3(ur, "range");
  function pl(r2) {
    return function(e2) {
      return (r2 === null || e2.category !== r2) && r2 !== "all";
    };
  }
  n3(pl, "notCategory");
  function Cn(r2) {
    r2 = parseInt(r2, 10);
    var e2 = null;
    return r2 === 0 ? e2 = "all" : r2 === 1 ? e2 = "bold" : 2 < r2 && r2 < 5 ? e2 = "underline" : 4 < r2 && r2 < 7 ? e2 = "blink" : r2 === 8 ? e2 = "hide" : r2 === 9 ? e2 = "strike" : 29 < r2 && r2 < 38 || r2 === 39 || 89 < r2 && r2 < 98 ? e2 = "foreground-color" : (39 < r2 && r2 < 48 || r2 === 49 || 99 < r2 && r2 < 108) && (e2 = "background-color"), e2;
  }
  n3(Cn, "categoryForCode");
  function ul(r2, e2) {
    return e2.escapeXML ? sl.encodeXML(r2) : r2;
  }
  n3(ul, "pushText");
  function re3(r2, e2, t2) {
    return t2 || (t2 = ""), r2.push(e2), "<".concat(e2).concat(t2 ? ' style="'.concat(t2, '"') : "", ">");
  }
  n3(re3, "pushTag");
  function fr2(r2, e2) {
    return re3(r2, "span", e2);
  }
  n3(fr2, "pushStyle");
  function yr2(r2, e2) {
    return re3(r2, "span", "color:" + e2);
  }
  n3(yr2, "pushForegroundColor");
  function mr2(r2, e2) {
    return re3(r2, "span", "background-color:" + e2);
  }
  n3(mr2, "pushBackgroundColor");
  function vn(r2, e2) {
    var t2;
    if (r2.slice(-1)[0] === e2 && (t2 = r2.pop()), t2)
      return "</" + e2 + ">";
  }
  n3(vn, "closeTag");
  function fl(r2, e2, t2) {
    var o2 = false, s2 = 3;
    function i2() {
      return "";
    }
    n3(i2, "remove");
    function a(R3, w4) {
      return t2("xterm256Foreground", w4), "";
    }
    n3(a, "removeXterm256Foreground");
    function l2(R3, w4) {
      return t2("xterm256Background", w4), "";
    }
    n3(l2, "removeXterm256Background");
    function c(R3) {
      return e2.newline ? t2("display", -1) : t2("text", R3), "";
    }
    n3(c, "newline");
    function d2(R3, w4) {
      o2 = true, w4.trim().length === 0 && (w4 = "0"), w4 = w4.trimRight(";").split(";");
      var E = Pn(w4), D5;
      try {
        for (E.s(); !(D5 = E.n()).done; ) {
          var k4 = D5.value;
          t2("display", k4);
        }
      } catch (L3) {
        E.e(L3);
      } finally {
        E.f();
      }
      return "";
    }
    n3(d2, "ansiMess");
    function p2(R3) {
      return t2("text", R3), "";
    }
    n3(p2, "realText");
    function u(R3) {
      return t2("rgb", R3), "";
    }
    n3(u, "rgb");
    var y = [{
      pattern: /^\x08+/,
      sub: i2
    }, {
      pattern: /^\x1b\[[012]?K/,
      sub: i2
    }, {
      pattern: /^\x1b\[\(B/,
      sub: i2
    }, {
      pattern: /^\x1b\[[34]8;2;\d+;\d+;\d+m/,
      sub: u
    }, {
      pattern: /^\x1b\[38;5;(\d+)m/,
      sub: a
    }, {
      pattern: /^\x1b\[48;5;(\d+)m/,
      sub: l2
    }, {
      pattern: /^\n/,
      sub: c
    }, {
      pattern: /^\r+\n/,
      sub: c
    }, {
      pattern: /^\r/,
      sub: c
    }, {
      pattern: /^\x1b\[((?:\d{1,3};?)+|)m/,
      sub: d2
    }, {
      // CSI n J
      // ED - Erase in Display Clears part of the screen.
      // If n is 0 (or missing), clear from cursor to end of screen.
      // If n is 1, clear from cursor to beginning of the screen.
      // If n is 2, clear entire screen (and moves cursor to upper left on DOS ANSI.SYS).
      // If n is 3, clear entire screen and delete all lines saved in the scrollback buffer
      //   (this feature was added for xterm and is supported by other terminal applications).
      pattern: /^\x1b\[\d?J/,
      sub: i2
    }, {
      // CSI n ; m f
      // HVP - Horizontal Vertical Position Same as CUP
      pattern: /^\x1b\[\d{0,3};\d{0,3}f/,
      sub: i2
    }, {
      // catch-all for CSI sequences?
      pattern: /^\x1b\[?[\d;]{0,3}/,
      sub: i2
    }, {
      /**
       * extracts real text - not containing:
       * - `\x1b' - ESC - escape (Ascii 27)
       * - '\x08' - BS - backspace (Ascii 8)
       * - `\n` - Newline - linefeed (LF) (ascii 10)
       * - `\r` - Windows Carriage Return (CR)
       */
      pattern: /^(([^\x1b\x08\r\n])+)/,
      sub: p2
    }];
    function h2(R3, w4) {
      w4 > s2 && o2 || (o2 = false, r2 = r2.replace(R3.pattern, R3.sub));
    }
    n3(h2, "process");
    var g3 = [], b5 = r2, m2 = b5.length;
    e: for (; m2 > 0; ) {
      for (var T3 = 0, x4 = 0, f3 = y.length; x4 < f3; T3 = ++x4) {
        var S3 = y[T3];
        if (h2(S3, T3), r2.length !== m2) {
          m2 = r2.length;
          continue e;
        }
      }
      if (r2.length === m2)
        break;
      g3.push(0), m2 = r2.length;
    }
    return g3;
  }
  n3(fl, "tokenize");
  function yl(r2, e2, t2) {
    return e2 !== "text" && (r2 = r2.filter(pl(Cn(t2))), r2.push({
      token: e2,
      data: t2,
      category: Cn(t2)
    })), r2;
  }
  n3(yl, "updateStickyStack");
  var ml = (function() {
    function r2(e2) {
      tl(this, r2), e2 = e2 || {}, e2.colors && (e2.colors = Object.assign({}, An2.colors, e2.colors)), this.options = Object.assign({}, An2, e2), this.stack = [], this.stickyStack = [];
    }
    return n3(r2, "Filter"), ol(r2, [{
      key: "toHtml",
      value: n3(function(t2) {
        var o2 = this;
        t2 = typeof t2 == "string" ? [t2] : t2;
        var s2 = this.stack, i2 = this.options, a = [];
        return this.stickyStack.forEach(function(l2) {
          var c = En(s2, l2.token, l2.data, i2);
          c && a.push(c);
        }), fl(t2.join(""), i2, function(l2, c) {
          var d2 = En(s2, l2, c, i2);
          d2 && a.push(d2), i2.stream && (o2.stickyStack = yl(o2.stickyStack, l2, c));
        }), s2.length && a.push(In2(s2)), a.join("");
      }, "toHtml")
    }]), r2;
  })();
  On.exports = ml;
});
function Sr2() {
  let r2 = {
    setHandler: n3(() => {
    }, "setHandler"),
    send: n3(() => {
    }, "send")
  };
  return new z2({ transport: r2 });
}
n3(Sr2, "mockChannel");
var wr2 = class wr3 {
  constructor() {
    this.getChannel = n3(() => {
      if (!this.channel) {
        let e2 = Sr2();
        return this.setChannel(e2), e2;
      }
      return this.channel;
    }, "getChannel");
    this.ready = n3(() => this.promise, "ready");
    this.hasChannel = n3(() => !!this.channel, "hasChannel");
    this.setChannel = n3((e2) => {
      this.channel = e2, this.resolve();
    }, "setChannel");
    this.promise = new Promise((e2) => {
      this.resolve = () => e2(this.getChannel());
    });
  }
};
n3(wr2, "AddonStore");
var Rr2 = wr2;
var xr2 = "__STORYBOOK_ADDONS_PREVIEW";
function Jn() {
  return scope[xr2] || (scope[xr2] = new Rr2()), scope[xr2];
}
n3(Jn, "getAddonsStore");
var _3 = Jn();
var Pr2 = class Pr3 {
  constructor() {
    this.hookListsMap = void 0;
    this.mountedDecorators = void 0;
    this.prevMountedDecorators = void 0;
    this.currentHooks = void 0;
    this.nextHookIndex = void 0;
    this.currentPhase = void 0;
    this.currentEffects = void 0;
    this.prevEffects = void 0;
    this.currentDecoratorName = void 0;
    this.hasUpdates = void 0;
    this.currentContext = void 0;
    this.renderListener = n3((e2) => {
      e2 === this.currentContext?.id && (this.triggerEffects(), this.currentContext = null, this.removeRenderListeners());
    }, "renderListener");
    this.init();
  }
  init() {
    this.hookListsMap = /* @__PURE__ */ new WeakMap(), this.mountedDecorators = /* @__PURE__ */ new Set(), this.prevMountedDecorators = /* @__PURE__ */ new Set(), this.currentHooks = [], this.nextHookIndex = 0, this.currentPhase = "NONE", this.currentEffects = [], this.prevEffects = [], this.currentDecoratorName = null, this.hasUpdates = false, this.currentContext = null;
  }
  clean() {
    this.prevEffects.forEach((e2) => {
      e2.destroy && e2.destroy();
    }), this.init(), this.removeRenderListeners();
  }
  getNextHook() {
    let e2 = this.currentHooks[this.nextHookIndex];
    return this.nextHookIndex += 1, e2;
  }
  triggerEffects() {
    this.prevEffects.forEach((e2) => {
      !this.currentEffects.includes(e2) && e2.destroy && e2.destroy();
    }), this.currentEffects.forEach((e2) => {
      this.prevEffects.includes(e2) || (e2.destroy = e2.create());
    }), this.prevEffects = this.currentEffects, this.currentEffects = [];
  }
  addRenderListeners() {
    this.removeRenderListeners(), _3.getChannel().on(X, this.renderListener);
  }
  removeRenderListeners() {
    _3.getChannel().removeListener(X, this.renderListener);
  }
};
n3(Pr2, "HooksContext");
var te2 = Pr2;
function vt2(r2) {
  let e2 = n3((...t2) => {
    let { hooks: o2 } = typeof t2[0] == "function" ? t2[1] : t2[0], s2 = o2.currentPhase, i2 = o2.currentHooks, a = o2.nextHookIndex, l2 = o2.currentDecoratorName;
    o2.currentDecoratorName = r2.name, o2.prevMountedDecorators.has(r2) ? (o2.currentPhase = "UPDATE", o2.currentHooks = o2.hookListsMap.get(r2) || []) : (o2.currentPhase = "MOUNT", o2.currentHooks = [], o2.hookListsMap.set(r2, o2.currentHooks), o2.prevMountedDecorators.add(r2)), o2.nextHookIndex = 0;
    let c = scope.STORYBOOK_HOOKS_CONTEXT;
    scope.STORYBOOK_HOOKS_CONTEXT = o2;
    let d2 = r2(...t2);
    if (scope.STORYBOOK_HOOKS_CONTEXT = c, o2.currentPhase === "UPDATE" && o2.getNextHook() != null)
      throw new Error(
        "Rendered fewer hooks than expected. This may be caused by an accidental early return statement."
      );
    return o2.currentPhase = s2, o2.currentHooks = i2, o2.nextHookIndex = a, o2.currentDecoratorName = l2, d2;
  }, "hookified");
  return e2.originalFn = r2, e2;
}
n3(vt2, "hookify");
var Ar2 = 0;
var ts = 25;
var Er2 = n3((r2) => (e2, t2) => {
  let o2 = r2(
    vt2(e2),
    t2.map((s2) => vt2(s2))
  );
  return (s2) => {
    let { hooks: i2 } = s2;
    i2.prevMountedDecorators ??= /* @__PURE__ */ new Set(), i2.mountedDecorators = /* @__PURE__ */ new Set([e2, ...t2]), i2.currentContext = s2, i2.hasUpdates = false;
    let a = o2(s2);
    for (Ar2 = 1; i2.hasUpdates; )
      if (i2.hasUpdates = false, i2.currentEffects = [], a = o2(s2), Ar2 += 1, Ar2 > ts)
        throw new Error(
          "Too many re-renders. Storybook limits the number of renders to prevent an infinite loop."
        );
    return i2.addRenderListeners(), a;
  };
}, "applyHooks");
var os = n3((r2, e2) => r2.length === e2.length && r2.every((t2, o2) => t2 === e2[o2]), "areDepsEqual");
var Cr2 = n3(
  () => new Error("Storybook preview hooks can only be called inside decorators and story functions."),
  "invalidHooksError"
);
function Pt2() {
  return scope.STORYBOOK_HOOKS_CONTEXT || null;
}
n3(Pt2, "getHooksContextOrNull");
function vr2() {
  let r2 = Pt2();
  if (r2 == null)
    throw Cr2();
  return r2;
}
n3(vr2, "getHooksContextOrThrow");
function ns(r2, e2, t2) {
  let o2 = vr2();
  if (o2.currentPhase === "MOUNT") {
    t2 != null && !Array.isArray(t2) && i.warn(
      `${r2} received a final argument that is not an array (instead, received ${t2}). When specified, the final argument must be an array.`
    );
    let s2 = { name: r2, deps: t2 };
    return o2.currentHooks.push(s2), e2(s2), s2;
  }
  if (o2.currentPhase === "UPDATE") {
    let s2 = o2.getNextHook();
    if (s2 == null)
      throw new Error("Rendered more hooks than during the previous render.");
    return s2.name !== r2 && i.warn(
      `Storybook has detected a change in the order of Hooks${o2.currentDecoratorName ? ` called by ${o2.currentDecoratorName}` : ""}. This will lead to bugs and errors if not fixed.`
    ), t2 != null && s2.deps == null && i.warn(
      `${r2} received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.`
    ), t2 != null && s2.deps != null && t2.length !== s2.deps.length && i.warn(`The final argument passed to ${r2} changed size between renders. The order and size of this array must remain constant.
Previous: ${s2.deps}
Incoming: ${t2}`), (t2 == null || s2.deps == null || !os(t2, s2.deps)) && (e2(s2), s2.deps = t2), s2;
  }
  throw Cr2();
}
n3(ns, "useHook");
function Ue2(r2, e2, t2) {
  let { memoizedState: o2 } = ns(
    r2,
    (s2) => {
      s2.memoizedState = e2();
    },
    t2
  );
  return o2;
}
n3(Ue2, "useMemoLike");
function ss(r2, e2) {
  return Ue2("useMemo", r2, e2);
}
n3(ss, "useMemo");
function ve(r2, e2) {
  return Ue2("useCallback", () => r2, e2);
}
n3(ve, "useCallback");
function Ft2(r2, e2) {
  return Ue2(r2, () => ({ current: e2 }), []);
}
n3(Ft2, "useRefLike");
function is(r2) {
  return Ft2("useRef", r2);
}
n3(is, "useRef");
function as() {
  let r2 = Pt2();
  if (r2 != null && r2.currentPhase !== "NONE")
    r2.hasUpdates = true;
  else
    try {
      _3.getChannel().emit(P);
    } catch {
      i.warn("State updates of Storybook preview hooks work only in browser");
    }
}
n3(as, "triggerUpdate");
function It2(r2, e2) {
  let t2 = Ft2(
    r2,
    // @ts-expect-error S type should never be function, but there's no way to tell that to TypeScript
    typeof e2 == "function" ? e2() : e2
  ), o2 = n3((s2) => {
    t2.current = typeof s2 == "function" ? s2(t2.current) : s2, as();
  }, "setState");
  return [t2.current, o2];
}
n3(It2, "useStateLike");
function ls(r2) {
  return It2("useState", r2);
}
n3(ls, "useState");
function cs(r2, e2, t2) {
  let o2 = t2 != null ? () => t2(e2) : e2, [s2, i2] = It2("useReducer", o2);
  return [s2, n3((l2) => i2((c) => r2(c, l2)), "dispatch")];
}
n3(cs, "useReducer");
function Ot(r2, e2) {
  let t2 = vr2(), o2 = Ue2("useEffect", () => ({ create: r2 }), e2);
  t2.currentEffects.includes(o2) || t2.currentEffects.push(o2);
}
n3(Ot, "useEffect");
function ds(r2, e2 = []) {
  let t2 = _3.getChannel();
  return Ot(() => (Object.entries(r2).forEach(([o2, s2]) => t2.on(o2, s2)), () => {
    Object.entries(r2).forEach(
      ([o2, s2]) => t2.removeListener(o2, s2)
    );
  }), [...Object.keys(r2), ...e2]), ve(t2.emit.bind(t2), [t2]);
}
n3(ds, "useChannel");
function He2() {
  let { currentContext: r2 } = vr2();
  if (r2 == null)
    throw Cr2();
  return r2;
}
n3(He2, "useStoryContext");
function ps(r2, e2) {
  let { parameters: t2 } = He2();
  if (r2)
    return t2[r2] ?? e2;
}
n3(ps, "useParameter");
function us() {
  let r2 = _3.getChannel(), { id: e2, args: t2 } = He2(), o2 = ve(
    (i2) => r2.emit(Z, { storyId: e2, updatedArgs: i2 }),
    [r2, e2]
  ), s2 = ve(
    (i2) => r2.emit(p, { storyId: e2, argNames: i2 }),
    [r2, e2]
  );
  return [t2, o2, s2];
}
n3(us, "useArgs");
function fs() {
  let r2 = _3.getChannel(), { globals: e2 } = He2(), t2 = ve(
    (o2) => r2.emit(z, { globals: o2 }),
    [r2]
  );
  return [e2, t2];
}
n3(fs, "useGlobals");
var ys = n3(({
  name: r2,
  parameterName: e2,
  wrapper: t2,
  skipIfNoParametersOrOptions: o2 = false
}) => {
  let s2 = n3((i2) => (a, l2) => {
    let c = l2.parameters && l2.parameters[e2];
    return c && c.disable || o2 && !i2 && !c ? a(l2) : t2(a, l2, {
      options: i2,
      parameters: c
    });
  }, "decorator");
  return (...i2) => typeof i2[0] == "function" ? s2()(...i2) : (...a) => {
    if (a.length > 1)
      return i2.length > 1 ? s2(i2)(...a) : s2(...i2)(...a);
    throw new Error(
      `Passing stories directly into ${r2}() is not allowed,
        instead use addDecorator(${r2}) and pass options with the '${e2}' parameter`
    );
  };
}, "makeDecorator");
function Dt2() {
}
n3(Dt2, "noop");
function Fr2(r2) {
  return Object.getOwnPropertySymbols(r2).filter((e2) => Object.prototype.propertyIsEnumerable.call(r2, e2));
}
n3(Fr2, "getSymbols");
function Ir2(r2) {
  return r2 == null ? r2 === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(r2);
}
n3(Ir2, "getTag");
var kt2 = "[object RegExp]";
var jt2 = "[object String]";
var Mt2 = "[object Number]";
var _t2 = "[object Boolean]";
var Or2 = "[object Arguments]";
var Nt2 = "[object Symbol]";
var Lt2 = "[object Date]";
var qt2 = "[object Map]";
var zt = "[object Set]";
var Bt2 = "[object Array]";
var Gt2 = "[object Function]";
var Ut2 = "[object ArrayBuffer]";
var Ve2 = "[object Object]";
var Ht2 = "[object Error]";
var Vt2 = "[object DataView]";
var Wt2 = "[object Uint8Array]";
var $t2 = "[object Uint8ClampedArray]";
var Yt2 = "[object Uint16Array]";
var Kt2 = "[object Uint32Array]";
var Xt2 = "[object BigUint64Array]";
var Jt = "[object Int8Array]";
var Qt2 = "[object Int16Array]";
var Zt2 = "[object Int32Array]";
var eo2 = "[object BigInt64Array]";
var ro2 = "[object Float32Array]";
var to2 = "[object Float64Array]";
function j3(r2) {
  if (!r2 || typeof r2 != "object")
    return false;
  let e2 = Object.getPrototypeOf(r2);
  return e2 === null || e2 === Object.prototype || Object.getPrototypeOf(e2) === null ? Object.prototype.toString.call(r2) === "[object Object]" : false;
}
n3(j3, "isPlainObject");
function V5(r2, e2) {
  let t2 = {}, o2 = Object.keys(r2);
  for (let s2 = 0; s2 < o2.length; s2++) {
    let i2 = o2[s2], a = r2[i2];
    t2[i2] = e2(a, i2, r2);
  }
  return t2;
}
n3(V5, "mapValues");
function Dr2(r2, e2) {
  let t2 = {}, o2 = Object.keys(r2);
  for (let s2 = 0; s2 < o2.length; s2++) {
    let i2 = o2[s2], a = r2[i2];
    e2(a, i2) && (t2[i2] = a);
  }
  return t2;
}
n3(Dr2, "pickBy");
function oo(r2, e2) {
  return r2 === e2 || Number.isNaN(r2) && Number.isNaN(e2);
}
n3(oo, "eq");
function no(r2, e2, t2) {
  return Pe2(r2, e2, void 0, void 0, void 0, void 0, t2);
}
n3(no, "isEqualWith");
function Pe2(r2, e2, t2, o2, s2, i2, a) {
  let l2 = a(r2, e2, t2, o2, s2, i2);
  if (l2 !== void 0)
    return l2;
  if (typeof r2 == typeof e2)
    switch (typeof r2) {
      case "bigint":
      case "string":
      case "boolean":
      case "symbol":
      case "undefined":
        return r2 === e2;
      case "number":
        return r2 === e2 || Object.is(r2, e2);
      case "function":
        return r2 === e2;
      case "object":
        return Fe2(r2, e2, i2, a);
    }
  return Fe2(r2, e2, i2, a);
}
n3(Pe2, "isEqualWithImpl");
function Fe2(r2, e2, t2, o2) {
  if (Object.is(r2, e2))
    return true;
  let s2 = Ir2(r2), i2 = Ir2(e2);
  if (s2 === Or2 && (s2 = Ve2), i2 === Or2 && (i2 = Ve2), s2 !== i2)
    return false;
  switch (s2) {
    case jt2:
      return r2.toString() === e2.toString();
    case Mt2: {
      let c = r2.valueOf(), d2 = e2.valueOf();
      return oo(c, d2);
    }
    case _t2:
    case Lt2:
    case Nt2:
      return Object.is(r2.valueOf(), e2.valueOf());
    case kt2:
      return r2.source === e2.source && r2.flags === e2.flags;
    case Gt2:
      return r2 === e2;
  }
  t2 = t2 ?? /* @__PURE__ */ new Map();
  let a = t2.get(r2), l2 = t2.get(e2);
  if (a != null && l2 != null)
    return a === e2;
  t2.set(r2, e2), t2.set(e2, r2);
  try {
    switch (s2) {
      case qt2: {
        if (r2.size !== e2.size)
          return false;
        for (let [c, d2] of r2.entries())
          if (!e2.has(c) || !Pe2(d2, e2.get(c), c, r2, e2, t2, o2))
            return false;
        return true;
      }
      case zt: {
        if (r2.size !== e2.size)
          return false;
        let c = Array.from(r2.values()), d2 = Array.from(e2.values());
        for (let p2 = 0; p2 < c.length; p2++) {
          let u = c[p2], y = d2.findIndex((h2) => Pe2(u, h2, void 0, r2, e2, t2, o2));
          if (y === -1)
            return false;
          d2.splice(y, 1);
        }
        return true;
      }
      case Bt2:
      case Wt2:
      case $t2:
      case Yt2:
      case Kt2:
      case Xt2:
      case Jt:
      case Qt2:
      case Zt2:
      case eo2:
      case ro2:
      case to2: {
        if (typeof Buffer < "u" && Buffer.isBuffer(r2) !== Buffer.isBuffer(e2) || r2.length !== e2.length)
          return false;
        for (let c = 0; c < r2.length; c++)
          if (!Pe2(r2[c], e2[c], c, r2, e2, t2, o2))
            return false;
        return true;
      }
      case Ut2:
        return r2.byteLength !== e2.byteLength ? false : Fe2(new Uint8Array(r2), new Uint8Array(e2), t2, o2);
      case Vt2:
        return r2.byteLength !== e2.byteLength || r2.byteOffset !== e2.byteOffset ? false : Fe2(new Uint8Array(r2), new Uint8Array(e2), t2, o2);
      case Ht2:
        return r2.name === e2.name && r2.message === e2.message;
      case Ve2: {
        if (!(Fe2(r2.constructor, e2.constructor, t2, o2) || j3(r2) && j3(e2)))
          return false;
        let d2 = [...Object.keys(r2), ...Fr2(r2)], p2 = [...Object.keys(e2), ...Fr2(e2)];
        if (d2.length !== p2.length)
          return false;
        for (let u = 0; u < d2.length; u++) {
          let y = d2[u], h2 = r2[y];
          if (!Object.hasOwn(e2, y))
            return false;
          let g3 = e2[y];
          if (!Pe2(h2, g3, y, r2, e2, t2, o2))
            return false;
        }
        return true;
      }
      default:
        return false;
    }
  } finally {
    t2.delete(r2), t2.delete(e2);
  }
}
n3(Fe2, "areObjectsEqual");
function kr(r2, e2) {
  return no(r2, e2, Dt2);
}
n3(kr, "isEqual");
var rr2 = ue2(Mr2(), 1);
function P4(r2) {
  for (var e2 = [], t2 = 1; t2 < arguments.length; t2++)
    e2[t2 - 1] = arguments[t2];
  var o2 = Array.from(typeof r2 == "string" ? [r2] : r2);
  o2[o2.length - 1] = o2[o2.length - 1].replace(/\r?\n([\t ]*)$/, "");
  var s2 = o2.reduce(function(l2, c) {
    var d2 = c.match(/\n([\t ]+|(?!\s).)/g);
    return d2 ? l2.concat(d2.map(function(p2) {
      var u, y;
      return (y = (u = p2.match(/[\t ]/g)) === null || u === void 0 ? void 0 : u.length) !== null && y !== void 0 ? y : 0;
    })) : l2;
  }, []);
  if (s2.length) {
    var i2 = new RegExp(`
[	 ]{` + Math.min.apply(Math, s2) + "}", "g");
    o2 = o2.map(function(l2) {
      return l2.replace(i2, `
`);
    });
  }
  o2[0] = o2[0].replace(/^\r?\n/, "");
  var a = o2[0];
  return e2.forEach(function(l2, c) {
    var d2 = a.match(/(?:^|\n)( *)$/), p2 = d2 ? d2[1] : "", u = l2;
    typeof l2 == "string" && l2.includes(`
`) && (u = String(l2).split(`
`).map(function(y, h2) {
      return h2 === 0 ? y : "" + p2 + y;
    }).join(`
`)), a += u + o2[c + 1];
  }), a;
}
n3(P4, "dedent");
var fe2 = Symbol("incompatible");
var Nr2 = n3((r2, e2) => {
  let t2 = e2.type;
  if (r2 == null || !t2 || e2.mapping)
    return r2;
  switch (t2.name) {
    case "string":
      return String(r2);
    case "enum":
      return r2;
    case "number":
      return Number(r2);
    case "boolean":
      return String(r2) === "true";
    case "array":
      return !t2.value || !Array.isArray(r2) ? fe2 : r2.reduce((o2, s2, i2) => {
        let a = Nr2(s2, { type: t2.value });
        return a !== fe2 && (o2[i2] = a), o2;
      }, new Array(r2.length));
    case "object":
      return typeof r2 == "string" || typeof r2 == "number" ? r2 : !t2.value || typeof r2 != "object" ? fe2 : Object.entries(r2).reduce((o2, [s2, i2]) => {
        let a = Nr2(i2, { type: t2.value[s2] });
        return a === fe2 ? o2 : Object.assign(o2, { [s2]: a });
      }, {});
    default:
      return fe2;
  }
}, "map");
var io = n3((r2, e2) => Object.entries(r2).reduce((t2, [o2, s2]) => {
  if (!e2[o2])
    return t2;
  let i2 = Nr2(s2, e2[o2]);
  return i2 === fe2 ? t2 : Object.assign(t2, { [o2]: i2 });
}, {}), "mapArgsToTypes");
var Ie3 = n3((r2, e2) => Array.isArray(r2) && Array.isArray(e2) ? e2.reduce(
  (t2, o2, s2) => (t2[s2] = Ie3(r2[s2], e2[s2]), t2),
  [...r2]
).filter((t2) => t2 !== void 0) : !j3(r2) || !j3(e2) ? e2 : Object.keys({ ...r2, ...e2 }).reduce((t2, o2) => {
  if (o2 in e2) {
    let s2 = Ie3(r2[o2], e2[o2]);
    s2 !== void 0 && (t2[o2] = s2);
  } else
    t2[o2] = r2[o2];
  return t2;
}, {}), "combineArgs");
var ao2 = n3((r2, e2) => Object.entries(e2).reduce((t2, [o2, { options: s2 }]) => {
  function i2() {
    return o2 in r2 && (t2[o2] = r2[o2]), t2;
  }
  if (n3(i2, "allowArg"), !s2)
    return i2();
  if (!Array.isArray(s2))
    return o.error(P4`
        Invalid argType: '${o2}.options' should be an array.

        More info: https://storybook.js.org/docs/api/arg-types?ref=error
      `), i2();
  if (s2.some((u) => u && ["object", "function"].includes(typeof u)))
    return o.error(P4`
        Invalid argType: '${o2}.options' should only contain primitives. Use a 'mapping' for complex values.

        More info: https://storybook.js.org/docs/writing-stories/args?ref=error#mapping-to-complex-arg-values
      `), i2();
  let a = Array.isArray(r2[o2]), l2 = a && r2[o2].findIndex((u) => !s2.includes(u)), c = a && l2 === -1;
  if (r2[o2] === void 0 || s2.includes(r2[o2]) || c)
    return i2();
  let d2 = a ? `${o2}[${l2}]` : o2, p2 = s2.map((u) => typeof u == "string" ? `'${u}'` : String(u)).join(", ");
  return o.warn(`Received illegal value for '${d2}'. Supported options: ${p2}`), t2;
}, {}), "validateOptions");
var oe2 = Symbol("Deeply equal");
var ye2 = n3((r2, e2) => {
  if (typeof r2 != typeof e2)
    return e2;
  if (kr(r2, e2))
    return oe2;
  if (Array.isArray(r2) && Array.isArray(e2)) {
    let t2 = e2.reduce((o2, s2, i2) => {
      let a = ye2(r2[i2], s2);
      return a !== oe2 && (o2[i2] = a), o2;
    }, new Array(e2.length));
    return e2.length >= r2.length ? t2 : t2.concat(new Array(r2.length - e2.length).fill(void 0));
  }
  return j3(r2) && j3(e2) ? Object.keys({ ...r2, ...e2 }).reduce((t2, o2) => {
    let s2 = ye2(r2?.[o2], e2?.[o2]);
    return s2 === oe2 ? t2 : Object.assign(t2, { [o2]: s2 });
  }, {}) : e2;
}, "deepDiff");
var Lr2 = "UNTARGETED";
function lo2({
  args: r2,
  argTypes: e2
}) {
  let t2 = {};
  return Object.entries(r2).forEach(([o2, s2]) => {
    let { target: i2 = Lr2 } = e2[o2] || {};
    t2[i2] = t2[i2] || {}, t2[i2][o2] = s2;
  }), t2;
}
n3(lo2, "groupArgsByTarget");
function ms(r2) {
  return Object.keys(r2).forEach((e2) => r2[e2] === void 0 && delete r2[e2]), r2;
}
n3(ms, "deleteUndefined");
var qr2 = class qr3 {
  constructor() {
    this.initialArgsByStoryId = {};
    this.argsByStoryId = {};
  }
  get(e2) {
    if (!(e2 in this.argsByStoryId))
      throw new Error(`No args known for ${e2} -- has it been rendered yet?`);
    return this.argsByStoryId[e2];
  }
  setInitial(e2) {
    if (!this.initialArgsByStoryId[e2.id])
      this.initialArgsByStoryId[e2.id] = e2.initialArgs, this.argsByStoryId[e2.id] = e2.initialArgs;
    else if (this.initialArgsByStoryId[e2.id] !== e2.initialArgs) {
      let t2 = ye2(this.initialArgsByStoryId[e2.id], this.argsByStoryId[e2.id]);
      this.initialArgsByStoryId[e2.id] = e2.initialArgs, this.argsByStoryId[e2.id] = e2.initialArgs, t2 !== oe2 && this.updateFromDelta(e2, t2);
    }
  }
  updateFromDelta(e2, t2) {
    let o2 = ao2(t2, e2.argTypes);
    this.argsByStoryId[e2.id] = Ie3(this.argsByStoryId[e2.id], o2);
  }
  updateFromPersisted(e2, t2) {
    let o2 = io(t2, e2.argTypes);
    return this.updateFromDelta(e2, o2);
  }
  update(e2, t2) {
    if (!(e2 in this.argsByStoryId))
      throw new Error(`No args known for ${e2} -- has it been rendered yet?`);
    this.argsByStoryId[e2] = ms({
      ...this.argsByStoryId[e2],
      ...t2
    });
  }
};
n3(qr2, "ArgsStore");
var We2 = qr2;
var $e = n3((r2 = {}) => Object.entries(r2).reduce((e2, [t2, { defaultValue: o2 }]) => (typeof o2 < "u" && (e2[t2] = o2), e2), {}), "getValuesFromArgTypes");
var zr2 = class zr3 {
  constructor({
    globals: e2 = {},
    globalTypes: t2 = {}
  }) {
    this.set({ globals: e2, globalTypes: t2 });
  }
  set({ globals: e2 = {}, globalTypes: t2 = {} }) {
    let o2 = this.initialGlobals && ye2(this.initialGlobals, this.globals);
    this.allowedGlobalNames = /* @__PURE__ */ new Set([...Object.keys(e2), ...Object.keys(t2)]);
    let s2 = $e(t2);
    this.initialGlobals = { ...s2, ...e2 }, this.globals = this.initialGlobals, o2 && o2 !== oe2 && this.updateFromPersisted(o2);
  }
  filterAllowedGlobals(e2) {
    return Object.entries(e2).reduce((t2, [o2, s2]) => (this.allowedGlobalNames.has(o2) ? t2[o2] = s2 : i.warn(
      `Attempted to set a global (${o2}) that is not defined in initial globals or globalTypes`
    ), t2), {});
  }
  updateFromPersisted(e2) {
    let t2 = this.filterAllowedGlobals(e2);
    this.globals = { ...this.globals, ...t2 };
  }
  get() {
    return this.globals;
  }
  update(e2) {
    this.globals = { ...this.globals, ...this.filterAllowedGlobals(e2) };
    for (let t2 in e2)
      e2[t2] === void 0 && (this.globals[t2] = this.initialGlobals[t2]);
  }
};
n3(zr2, "GlobalsStore");
var Ye2 = zr2;
var co = ue2(Mr2(), 1);
var bs = (0, co.default)(1)(
  (r2) => Object.values(r2).reduce(
    (e2, t2) => (e2[t2.importPath] = e2[t2.importPath] || t2, e2),
    {}
  )
);
var Br2 = class Br3 {
  constructor({ entries: e2 } = { v: 5, entries: {} }) {
    this.entries = e2;
  }
  entryFromSpecifier(e2) {
    let t2 = Object.values(this.entries);
    if (e2 === "*")
      return t2[0];
    if (typeof e2 == "string")
      return this.entries[e2] ? this.entries[e2] : t2.find((i2) => i2.id.startsWith(e2));
    let { name: o2, title: s2 } = e2;
    return t2.find((i2) => i2.name === o2 && i2.title === s2);
  }
  storyIdToEntry(e2) {
    let t2 = this.entries[e2];
    if (!t2)
      throw new Y2({ storyId: e2 });
    return t2;
  }
  importPathToEntry(e2) {
    return bs(this.entries)[e2];
  }
};
n3(Br2, "StoryIndexStore");
var Ke2 = Br2;
var Ss = n3((r2) => typeof r2 == "string" ? { name: r2 } : r2, "normalizeType");
var Ts = n3((r2) => typeof r2 == "string" ? { type: r2 } : r2, "normalizeControl");
var xs = n3((r2, e2) => {
  let { type: t2, control: o2, ...s2 } = r2, i2 = {
    name: e2,
    ...s2
  };
  return t2 && (i2.type = Ss(t2)), o2 ? i2.control = Ts(o2) : o2 === false && (i2.control = { disable: true }), i2;
}, "normalizeInputType");
var ne3 = n3((r2) => V5(r2, xs), "normalizeInputTypes");
var C4 = n3((r2) => Array.isArray(r2) ? r2 : r2 ? [r2] : [], "normalizeArrays");
var Cs = P4`
CSF .story annotations deprecated; annotate story functions directly:
- StoryFn.story.name => StoryFn.storyName
- StoryFn.story.(parameters|decorators) => StoryFn.(parameters|decorators)
See https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#hoisted-csf-annotations for details and codemod.
`;
function me2(r2, e2, t2) {
  let o2 = e2, s2 = typeof e2 == "function" ? e2 : null, { story: i2 } = o2;
  i2 && (i.debug("deprecated story", i2), h(Cs));
  let a = cc(r2), l2 = typeof o2 != "function" && o2.name || o2.storyName || i2?.name || a, c = [
    ...C4(o2.decorators),
    ...C4(i2?.decorators)
  ], d2 = { ...i2?.parameters, ...o2.parameters }, p2 = { ...i2?.args, ...o2.args }, u = { ...i2?.argTypes, ...o2.argTypes }, y = [...C4(o2.loaders), ...C4(
    i2?.loaders
  )], h2 = [
    ...C4(o2.beforeEach),
    ...C4(i2?.beforeEach)
  ], g3 = [
    ...C4(o2.afterEach),
    ...C4(i2?.afterEach)
  ], { render: b5, play: m2, tags: T3 = [], globals: x4 = {} } = o2, f3 = d2.__id || lc(t2.id, a);
  return {
    moduleExport: e2,
    id: f3,
    name: l2,
    tags: T3,
    decorators: c,
    parameters: d2,
    args: p2,
    argTypes: ne3(u),
    loaders: y,
    beforeEach: h2,
    afterEach: g3,
    globals: x4,
    ...b5 && { render: b5 },
    ...s2 && { userStoryFn: s2 },
    ...m2 && { play: m2 }
  };
}
n3(me2, "normalizeStory");
function Oe2(r2, e2 = r2.title, t2) {
  let { id: o2, argTypes: s2 } = r2;
  return {
    id: jn(o2 || e2),
    ...r2,
    title: e2,
    ...s2 && { argTypes: ne3(s2) },
    parameters: {
      fileName: t2,
      ...r2.parameters
    }
  };
}
n3(Oe2, "normalizeComponentAnnotations");
var Fs = n3((r2) => {
  let { globals: e2, globalTypes: t2 } = r2;
  (e2 || t2) && i.error(
    "Global args/argTypes can only be set globally",
    JSON.stringify({
      globals: e2,
      globalTypes: t2
    })
  );
}, "checkGlobals");
var Is = n3((r2) => {
  let { options: e2 } = r2;
  e2?.storySort && i.error("The storySort option parameter can only be set globally");
}, "checkStorySort");
var Xe2 = n3((r2) => {
  r2 && (Fs(r2), Is(r2));
}, "checkDisallowedParameters");
function fo(r2, e2, t2) {
  let { default: o2, __namedExportsOrder: s2, ...i2 } = r2, a = Object.values(i2)[0];
  if (ic(a)) {
    let d2 = Oe2(a.meta.input, t2, e2);
    Xe2(d2.parameters);
    let p2 = { meta: d2, stories: {}, moduleExports: r2 };
    return Object.keys(i2).forEach((u) => {
      if (dc(u, d2)) {
        let y = me2(u, i2[u].input, d2);
        Xe2(y.parameters), p2.stories[y.id] = y;
      }
    }), p2.projectAnnotations = a.meta.preview.composed, p2;
  }
  let l2 = Oe2(
    o2,
    t2,
    e2
  );
  Xe2(l2.parameters);
  let c = { meta: l2, stories: {}, moduleExports: r2 };
  return Object.keys(i2).forEach((d2) => {
    if (dc(d2, l2)) {
      let p2 = me2(d2, i2[d2], l2);
      Xe2(p2.parameters), c.stories[p2.id] = p2;
    }
  }), c;
}
n3(fo, "processCSFFile");
function mo(r2) {
  return r2 != null && Os(r2).includes("mount");
}
n3(mo, "mountDestructured");
function Os(r2) {
  let e2 = r2.toString().match(/[^(]*\(([^)]*)/);
  if (!e2)
    return [];
  let t2 = yo(e2[1]);
  if (!t2.length)
    return [];
  let o2 = t2[0];
  return o2.startsWith("{") && o2.endsWith("}") ? yo(o2.slice(1, -1).replace(/\s/g, "")).map((i2) => i2.replace(/:.*|=.*/g, "")) : [];
}
n3(Os, "getUsedProps");
function yo(r2) {
  let e2 = [], t2 = [], o2 = 0;
  for (let i2 = 0; i2 < r2.length; i2++)
    if (r2[i2] === "{" || r2[i2] === "[")
      t2.push(r2[i2] === "{" ? "}" : "]");
    else if (r2[i2] === t2[t2.length - 1])
      t2.pop();
    else if (!t2.length && r2[i2] === ",") {
      let a = r2.substring(o2, i2).trim();
      a && e2.push(a), o2 = i2 + 1;
    }
  let s2 = r2.substring(o2).trim();
  return s2 && e2.push(s2), e2;
}
n3(yo, "splitByComma");
function ho(r2, e2, t2) {
  let o2 = t2(r2);
  return (s2) => e2(o2, s2);
}
n3(ho, "decorateStory");
function go2({
  componentId: r2,
  title: e2,
  kind: t2,
  id: o2,
  name: s2,
  story: i2,
  parameters: a,
  initialArgs: l2,
  argTypes: c,
  ...d2
} = {}) {
  return d2;
}
n3(go2, "sanitizeStoryContextUpdate");
function Gr2(r2, e2) {
  let t2 = {}, o2 = n3((i2) => (a) => {
    if (!t2.value)
      throw new Error("Decorated function called without init");
    return t2.value = {
      ...t2.value,
      ...go2(a)
    }, i2(t2.value);
  }, "bindWithContext"), s2 = e2.reduce(
    (i2, a) => ho(i2, a, o2),
    r2
  );
  return (i2) => (t2.value = i2, s2(i2));
}
n3(Gr2, "defaultDecorateStory");
var N4 = n3((...r2) => {
  let e2 = {}, t2 = r2.filter(Boolean), o2 = t2.reduce((s2, i2) => (Object.entries(i2).forEach(([a, l2]) => {
    let c = s2[a];
    Array.isArray(l2) || typeof c > "u" ? s2[a] = l2 : j3(l2) && j3(c) ? e2[a] = true : typeof l2 < "u" && (s2[a] = l2);
  }), s2), {});
  return Object.keys(e2).forEach((s2) => {
    let i2 = t2.filter(Boolean).map((a) => a[s2]).filter((a) => typeof a < "u");
    i2.every((a) => j3(a)) ? o2[s2] = N4(...i2) : o2[s2] = i2[i2.length - 1];
  }), o2;
}, "combineParameters");
function De2(r2, e2, t2) {
  let { moduleExport: o2, id: s2, name: i2 } = r2 || {}, a = bo2(
    r2,
    e2,
    t2
  ), l2 = n3(async (w4) => {
    let E = {};
    for (let D5 of [
      C4(t2.loaders),
      C4(e2.loaders),
      C4(r2.loaders)
    ]) {
      if (w4.abortSignal.aborted)
        return E;
      let k4 = await Promise.all(D5.map((L3) => L3(w4)));
      Object.assign(E, ...k4);
    }
    return E;
  }, "applyLoaders"), c = n3(async (w4) => {
    let E = new Array();
    for (let D5 of [
      ...C4(t2.beforeEach),
      ...C4(e2.beforeEach),
      ...C4(r2.beforeEach)
    ]) {
      if (w4.abortSignal.aborted)
        return E;
      let k4 = await D5(w4);
      k4 && E.push(k4);
    }
    return E;
  }, "applyBeforeEach"), d2 = n3(async (w4) => {
    let E = [
      ...C4(t2.afterEach),
      ...C4(e2.afterEach),
      ...C4(r2.afterEach)
    ].reverse();
    for (let D5 of E) {
      if (w4.abortSignal.aborted)
        return;
      await D5(w4);
    }
  }, "applyAfterEach"), p2 = n3((w4) => w4.originalStoryFn(w4.args, w4), "undecoratedStoryFn"), { applyDecorators: u = Gr2, runStep: y } = t2, h2 = [
    ...C4(r2?.decorators),
    ...C4(e2?.decorators),
    ...C4(t2?.decorators)
  ], g3 = r2?.userStoryFn || r2?.render || e2.render || t2.render, b5 = Er2(u)(p2, h2), m2 = n3((w4) => b5(w4), "unboundStoryFn"), T3 = r2?.play ?? e2?.play, x4 = mo(T3);
  if (!g3 && !x4)
    throw new Q2({ id: s2 });
  let f3 = n3((w4) => async () => (await w4.renderToCanvas(), w4.canvas), "defaultMount"), S3 = r2.mount ?? e2.mount ?? t2.mount ?? f3, R3 = t2.testingLibraryRender;
  return {
    storyGlobals: {},
    ...a,
    moduleExport: o2,
    id: s2,
    name: i2,
    story: i2,
    originalStoryFn: g3,
    undecoratedStoryFn: p2,
    unboundStoryFn: m2,
    applyLoaders: l2,
    applyBeforeEach: c,
    applyAfterEach: d2,
    playFunction: T3,
    runStep: y,
    mount: S3,
    testingLibraryRender: R3,
    renderToCanvas: t2.renderToCanvas,
    usesMount: x4
  };
}
n3(De2, "prepareStory");
function Ur2(r2, e2, t2) {
  return {
    ...bo2(void 0, r2, e2),
    moduleExport: t2
  };
}
n3(Ur2, "prepareMeta");
function bo2(r2, e2, t2) {
  let o2 = ["dev", "test"], s2 = scope.DOCS_OPTIONS?.autodocs === true ? ["autodocs"] : [], i2 = uc(
    ...o2,
    ...s2,
    ...t2.tags ?? [],
    ...e2.tags ?? [],
    ...r2?.tags ?? []
  ), a = N4(
    t2.parameters,
    e2.parameters,
    r2?.parameters
  ), { argTypesEnhancers: l2 = [], argsEnhancers: c = [] } = t2, d2 = N4(
    t2.argTypes,
    e2.argTypes,
    r2?.argTypes
  );
  if (r2) {
    let T3 = r2?.userStoryFn || r2?.render || e2.render || t2.render;
    a.__isArgsStory = T3 && T3.length > 0;
  }
  let p2 = {
    ...t2.args,
    ...e2.args,
    ...r2?.args
  }, u = {
    ...e2.globals,
    ...r2?.globals
  }, y = {
    componentId: e2.id,
    title: e2.title,
    kind: e2.title,
    // Back compat
    id: r2?.id || e2.id,
    // if there's no story name, we create a fake one since enhancers expect a name
    name: r2?.name || "__meta",
    story: r2?.name || "__meta",
    // Back compat
    component: e2.component,
    subcomponents: e2.subcomponents,
    tags: i2,
    parameters: a,
    initialArgs: p2,
    argTypes: d2,
    storyGlobals: u
  };
  y.argTypes = l2.reduce(
    (T3, x4) => x4({ ...y, argTypes: T3 }),
    y.argTypes
  );
  let h2 = { ...p2 };
  y.initialArgs = [...c].reduce(
    (T3, x4) => ({
      ...T3,
      ...x4({
        ...y,
        initialArgs: T3
      })
    }),
    h2
  );
  let { name: g3, story: b5, ...m2 } = y;
  return m2;
}
n3(bo2, "preparePartialAnnotations");
function Je2(r2) {
  let { args: e2 } = r2, t2 = {
    ...r2,
    allArgs: void 0,
    argsByTarget: void 0
  };
  if (scope.FEATURES?.argTypeTargetsV7) {
    let i2 = lo2(r2);
    t2 = {
      ...r2,
      allArgs: r2.args,
      argsByTarget: i2,
      args: i2[Lr2] || {}
    };
  }
  let o2 = Object.entries(t2.args).reduce((i2, [a, l2]) => {
    if (!t2.argTypes[a]?.mapping)
      return i2[a] = l2, i2;
    let c = n3((d2) => {
      let p2 = t2.argTypes[a].mapping;
      return p2 && d2 in p2 ? p2[d2] : d2;
    }, "mappingFn");
    return i2[a] = Array.isArray(l2) ? l2.map(c) : c(l2), i2;
  }, {}), s2 = Object.entries(o2).reduce((i2, [a, l2]) => {
    let c = t2.argTypes[a] || {};
    return Xr(c, o2, t2.globals) && (i2[a] = l2), i2;
  }, {});
  return { ...t2, unmappedArgs: e2, args: s2 };
}
n3(Je2, "prepareContext");
var Hr2 = n3((r2, e2, t2) => {
  let o2 = typeof r2;
  switch (o2) {
    case "boolean":
    case "string":
    case "number":
    case "function":
    case "symbol":
      return { name: o2 };
    default:
      break;
  }
  return r2 ? t2.has(r2) ? (i.warn(P4`
        We've detected a cycle in arg '${e2}'. Args should be JSON-serializable.

        Consider using the mapping feature or fully custom args:
        - Mapping: https://storybook.js.org/docs/writing-stories/args#mapping-to-complex-arg-values
        - Custom args: https://storybook.js.org/docs/essentials/controls#fully-custom-args
      `), { name: "other", value: "cyclic object" }) : (t2.add(r2), Array.isArray(r2) ? { name: "array", value: r2.length > 0 ? Hr2(r2[0], e2, new Set(
    t2
  )) : { name: "other", value: "unknown" } } : { name: "object", value: V5(r2, (i2) => Hr2(i2, e2, new Set(t2))) }) : { name: "object", value: {} };
}, "inferType");
var Vr2 = n3((r2) => {
  let { id: e2, argTypes: t2 = {}, initialArgs: o2 = {} } = r2, s2 = V5(o2, (a, l2) => ({
    name: l2,
    type: Hr2(a, `${e2}.${l2}`, /* @__PURE__ */ new Set())
  })), i2 = V5(t2, (a, l2) => ({
    name: l2
  }));
  return N4(s2, i2, t2);
}, "inferArgTypes");
Vr2.secondPass = true;
var So2 = n3((r2, e2) => Array.isArray(e2) ? e2.includes(r2) : r2.match(e2), "matches");
var Qe2 = n3((r2, e2, t2) => !e2 && !t2 ? r2 : r2 && Dr2(r2, (o2, s2) => {
  let i2 = o2.name || s2.toString();
  return !!(!e2 || So2(i2, e2)) && (!t2 || !So2(i2, t2));
}), "filterArgTypes");
var qs = n3((r2, e2, t2) => {
  let { type: o2, options: s2 } = r2;
  if (o2) {
    if (t2.color && t2.color.test(e2)) {
      let i2 = o2.name;
      if (i2 === "string")
        return { control: { type: "color" } };
      i2 !== "enum" && i.warn(
        `Addon controls: Control of type color only supports string, received "${i2}" instead`
      );
    }
    if (t2.date && t2.date.test(e2))
      return { control: { type: "date" } };
    switch (o2.name) {
      case "array":
        return { control: { type: "object" } };
      case "boolean":
        return { control: { type: "boolean" } };
      case "string":
        return { control: { type: "text" } };
      case "number":
        return { control: { type: "number" } };
      case "enum": {
        let { value: i2 } = o2;
        return { control: { type: i2?.length <= 5 ? "radio" : "select" }, options: i2 };
      }
      case "function":
      case "symbol":
        return null;
      default:
        return { control: { type: s2 ? "select" : "object" } };
    }
  }
}, "inferControl");
var ke2 = n3((r2) => {
  let {
    argTypes: e2,
    parameters: { __isArgsStory: t2, controls: { include: o2 = null, exclude: s2 = null, matchers: i2 = {} } = {} }
  } = r2;
  if (!t2)
    return e2;
  let a = Qe2(e2, o2, s2), l2 = V5(a, (c, d2) => c?.type && qs(c, d2.toString(), i2));
  return N4(l2, a);
}, "inferControls");
ke2.secondPass = true;
function he2({
  argTypes: r2,
  globalTypes: e2,
  argTypesEnhancers: t2,
  decorators: o2,
  loaders: s2,
  beforeEach: i2,
  afterEach: a,
  initialGlobals: l2,
  ...c
}) {
  return {
    ...r2 && { argTypes: ne3(r2) },
    ...e2 && { globalTypes: ne3(e2) },
    decorators: C4(o2),
    loaders: C4(s2),
    beforeEach: C4(i2),
    afterEach: C4(a),
    argTypesEnhancers: [
      ...t2 || [],
      Vr2,
      // There's an architectural decision to be made regarding embedded addons in core:
      //
      // Option 1: Keep embedded addons but ensure consistency by moving addon-specific code
      // (like inferControls) to live alongside the addon code itself. This maintains the
      // concept of core addons while improving code organization.
      //
      // Option 2: Fully integrate these addons into core, potentially moving UI components
      // into the manager and treating them as core features rather than addons. This is a
      // bigger architectural change requiring careful consideration.
      //
      // For now, we're keeping inferControls here as we need time to properly evaluate
      // these options and their implications. Some features (like Angular's cleanArgsDecorator)
      // currently rely on this behavior.
      //
      // TODO: Make an architectural decision on the handling of core addons
      ke2
    ],
    initialGlobals: l2,
    ...c
  };
}
n3(he2, "normalizeProjectAnnotations");
var To = n3((r2) => async () => {
  let e2 = [];
  for (let t2 of r2) {
    let o2 = await t2();
    o2 && e2.unshift(o2);
  }
  return async () => {
    for (let t2 of e2)
      await t2();
  };
}, "composeBeforeAllHooks");
function Wr2(r2) {
  return async (e2, t2, o2) => {
    await r2.reduceRight(
      (i2, a) => async () => a(e2, i2, o2),
      async () => t2(o2)
    )();
  };
}
n3(Wr2, "composeStepRunners");
function Me3(r2, e2) {
  return r2.map((t2) => t2.default?.[e2] ?? t2[e2]).filter(Boolean);
}
n3(Me3, "getField");
function Y4(r2, e2, t2 = {}) {
  return Me3(r2, e2).reduce((o2, s2) => {
    let i2 = C4(s2);
    return t2.reverseFileOrder ? [...i2, ...o2] : [...o2, ...i2];
  }, []);
}
n3(Y4, "getArrayField");
function Ze2(r2, e2) {
  return Object.assign({}, ...Me3(r2, e2));
}
n3(Ze2, "getObjectField");
function je2(r2, e2) {
  return Me3(r2, e2).pop();
}
n3(je2, "getSingletonField");
function K4(r2) {
  let e2 = Y4(r2, "argTypesEnhancers"), t2 = Me3(r2, "runStep"), o2 = Y4(r2, "beforeAll");
  return {
    parameters: N4(...Me3(r2, "parameters")),
    decorators: Y4(r2, "decorators", {
      reverseFileOrder: !(scope.FEATURES?.legacyDecoratorFileOrder ?? false)
    }),
    args: Ze2(r2, "args"),
    argsEnhancers: Y4(r2, "argsEnhancers"),
    argTypes: Ze2(r2, "argTypes"),
    argTypesEnhancers: [
      ...e2.filter((s2) => !s2.secondPass),
      ...e2.filter((s2) => s2.secondPass)
    ],
    initialGlobals: Ze2(r2, "initialGlobals"),
    globalTypes: Ze2(r2, "globalTypes"),
    loaders: Y4(r2, "loaders"),
    beforeAll: To(o2),
    beforeEach: Y4(r2, "beforeEach"),
    afterEach: Y4(r2, "afterEach"),
    render: je2(r2, "render"),
    renderToCanvas: je2(r2, "renderToCanvas"),
    applyDecorators: je2(r2, "applyDecorators"),
    runStep: Wr2(t2),
    tags: Y4(r2, "tags"),
    mount: je2(r2, "mount"),
    testingLibraryRender: je2(r2, "testingLibraryRender")
  };
}
n3(K4, "composeConfigs");
function er2() {
  try {
    return (
      // @ts-expect-error This property exists in Vitest browser mode
      !!globalThis.__vitest_browser__ || !!globalThis.window?.navigator?.userAgent?.match(/StorybookTestRunner/)
    );
  } catch {
    return false;
  }
}
n3(er2, "isTestEnvironment");
function ge2(r2 = true) {
  if (!("document" in globalThis && "createElement" in globalThis.document))
    return () => {
    };
  let e2 = document.createElement("style");
  e2.textContent = `*, *:before, *:after {
    animation: none !important;
  }`, document.head.appendChild(e2);
  let t2 = document.createElement("style");
  return t2.textContent = `*, *:before, *:after {
    animation-delay: 0s !important;
    animation-direction: ${r2 ? "reverse" : "normal"} !important;
    animation-play-state: paused !important;
    transition: none !important;
  }`, document.head.appendChild(t2), document.body.clientHeight, document.head.removeChild(e2), () => {
    t2.parentNode?.removeChild(t2);
  };
}
n3(ge2, "pauseAnimations");
async function be(r2) {
  if (!("document" in globalThis && "getAnimations" in globalThis.document && "querySelectorAll" in globalThis.document))
    return;
  let e2 = false;
  await Promise.race([
    // After 50ms, retrieve any running animations and wait for them to finish
    // If new animations are created while waiting, we'll wait for them too
    new Promise((t2) => {
      setTimeout(() => {
        let o2 = [globalThis.document, ...xo(globalThis.document)], s2 = n3(async () => {
          if (e2 || r2?.aborted)
            return;
          let i2 = o2.flatMap((a) => a?.getAnimations?.() || []).filter((a) => a.playState === "running" && !Bs(a));
          i2.length > 0 && (await Promise.all(i2.map((a) => a.finished)), await s2());
        }, "checkAnimationsFinished");
        s2().then(t2);
      }, 100);
    }),
    // If animations don't finish within the timeout, continue without waiting
    new Promise(
      (t2) => setTimeout(() => {
        e2 = true, t2(void 0);
      }, 5e3)
    )
  ]);
}
n3(be, "waitForAnimations");
function xo(r2) {
  return [r2, ...r2.querySelectorAll("*")].reduce(
    (e2, t2) => ("shadowRoot" in t2 && t2.shadowRoot && e2.push(t2.shadowRoot, ...xo(t2.shadowRoot)), e2),
    []
  );
}
n3(xo, "getShadowRoots");
function Bs(r2) {
  if (r2 instanceof CSSAnimation && r2.effect instanceof KeyframeEffect && r2.effect.target) {
    let e2 = getComputedStyle(r2.effect.target, r2.effect.pseudoElement), t2 = e2.animationName?.split(", ").indexOf(r2.animationName);
    return e2.animationIterationCount.split(", ")[t2] === "infinite";
  }
  return false;
}
n3(Bs, "isInfiniteAnimation");
var $r2 = class $r3 {
  constructor() {
    this.reports = [];
  }
  async addReport(e2) {
    this.reports.push(e2);
  }
};
n3($r2, "ReporterAPI");
var se3 = $r2;
function Yr2(r2, e2, t2) {
  return ic(r2) ? {
    story: r2.input,
    meta: r2.meta.input,
    preview: r2.meta.preview.composed
  } : { story: r2, meta: e2, preview: t2 };
}
n3(Yr2, "getCsfFactoryAnnotations");
function Ws(r2) {
  globalThis.defaultProjectAnnotations = r2;
}
n3(Ws, "setDefaultProjectAnnotations");
var $s = "ComposedStory";
var Ys = "Unnamed Story";
function Ks(r2) {
  return r2 ? K4([r2]) : {};
}
n3(Ks, "extractAnnotation");
function Xs(r2) {
  let e2 = Array.isArray(r2) ? r2 : [r2];
  return globalThis.globalProjectAnnotations = K4([
    ..._r(),
    globalThis.defaultProjectAnnotations ?? {},
    K4(e2.map(Ks))
  ]), globalThis.globalProjectAnnotations ?? {};
}
n3(Xs, "setProjectAnnotations");
var X3 = [];
function Ro2(r2, e2, t2, o2, s2) {
  if (r2 === void 0)
    throw new Error("Expected a story but received undefined.");
  e2.title = e2.title ?? $s;
  let i2 = Oe2(e2), a = s2 || r2.storyName || r2.story?.name || r2.name || Ys, l2 = me2(
    a,
    r2,
    i2
  ), c = he2(
    K4([
      o2 ?? globalThis.globalProjectAnnotations ?? {},
      t2 ?? {}
    ])
  ), d2 = De2(
    l2,
    i2,
    c
  ), u = {
    ...$e(c.globalTypes),
    ...c.initialGlobals,
    ...d2.storyGlobals
  }, y = new se3(), h2 = n3(() => {
    let f3 = Je2({
      hooks: new te2(),
      globals: u,
      args: { ...d2.initialArgs },
      viewMode: "story",
      reporting: y,
      loaded: {},
      abortSignal: new AbortController().signal,
      step: n3((S3, R3) => d2.runStep(S3, R3, f3), "step"),
      canvasElement: null,
      canvas: {},
      userEvent: {},
      globalTypes: c.globalTypes,
      ...d2,
      context: null,
      mount: null
    });
    return f3.parameters.__isPortableStory = true, f3.context = f3, d2.renderToCanvas && (f3.renderToCanvas = async () => {
      let S3 = await d2.renderToCanvas?.(
        {
          componentId: d2.componentId,
          title: d2.title,
          id: d2.id,
          name: d2.name,
          tags: d2.tags,
          showMain: n3(() => {
          }, "showMain"),
          showError: n3((R3) => {
            throw new Error(`${R3.title}
${R3.description}`);
          }, "showError"),
          showException: n3((R3) => {
            throw R3;
          }, "showException"),
          forceRemount: true,
          storyContext: f3,
          storyFn: n3(() => d2.unboundStoryFn(f3), "storyFn"),
          unboundStoryFn: d2.unboundStoryFn
        },
        f3.canvasElement
      );
      S3 && X3.push(S3);
    }), f3.mount = d2.mount(f3), f3;
  }, "initializeContext"), g3, b5 = n3(async (f3) => {
    let S3 = h2();
    return S3.canvasElement ??= globalThis?.document?.body, g3 && (S3.loaded = g3.loaded), Object.assign(S3, f3), d2.playFunction(S3);
  }, "play"), m2 = n3((f3) => {
    let S3 = h2();
    return Object.assign(S3, f3), ei(d2, S3);
  }, "run"), T3 = d2.playFunction ? b5 : void 0;
  return Object.assign(
    n3(function(S3) {
      let R3 = h2();
      return g3 && (R3.loaded = g3.loaded), R3.args = {
        ...R3.initialArgs,
        ...S3
      }, d2.unboundStoryFn(R3);
    }, "storyFn"),
    {
      id: d2.id,
      storyName: a,
      load: n3(async () => {
        for (let S3 of [...X3].reverse())
          await S3();
        X3.length = 0;
        let f3 = h2();
        f3.loaded = await d2.applyLoaders(f3), X3.push(...(await d2.applyBeforeEach(f3)).filter(Boolean)), g3 = f3;
      }, "load"),
      globals: u,
      args: d2.initialArgs,
      parameters: d2.parameters,
      argTypes: d2.argTypes,
      play: T3,
      run: m2,
      reporting: y,
      tags: d2.tags
    }
  );
}
n3(Ro2, "composeStory");
var Js = n3((r2, e2, t2, o2) => Ro2(r2, e2, t2, {}, o2), "defaultComposeStory");
function Qs2(r2, e2, t2 = Js) {
  let { default: o2, __esModule: s2, __namedExportsOrder: i2, ...a } = r2, l2 = o2;
  return Object.entries(a).reduce(
    (d2, [p2, u]) => {
      let { story: y, meta: h2 } = Yr2(u);
      return !l2 && h2 && (l2 = h2), dc(p2, l2) ? Object.assign(d2, {
        [p2]: t2(y, l2, e2, p2)
      }) : d2;
    },
    {}
  );
}
n3(Qs2, "composeStories");
function Zs(r2) {
  return r2.extend({
    mount: n3(async ({ mount: e2, page: t2 }, o2) => {
      await o2(async (s2, ...i2) => {
        if (!("__pw_type" in s2) || "__pw_type" in s2 && s2.__pw_type !== "jsx")
          throw new Error(P4`
              Portable stories in Playwright CT only work when referencing JSX elements.
              Please use JSX format for your components such as:

              instead of:
              await mount(MyComponent, { props: { foo: 'bar' } })

              do:
              await mount(<MyComponent foo="bar"/>)

              More info: https://storybook.js.org/docs/api/portable-stories/portable-stories-playwright?ref=error
            `);
        let { props: a, ...l2 } = s2;
        await t2.evaluate(async (d2) => {
          let p2 = await globalThis.__pwUnwrapObject?.(d2);
          return ("__pw_type" in p2 ? p2.type : p2)?.load?.();
        }, l2);
        let c = await e2(s2, ...i2);
        return await t2.evaluate(async (d2) => {
          let p2 = await globalThis.__pwUnwrapObject?.(d2), u = "__pw_type" in p2 ? p2.type : p2, y = document.querySelector("#root");
          return u?.play?.({ canvasElement: y });
        }, l2), c;
      });
    }, "mount")
  });
}
n3(Zs, "createPlaywrightTest");
async function ei(r2, e2) {
  for (let i2 of [...X3].reverse())
    await i2();
  if (X3.length = 0, !e2.canvasElement) {
    let i2 = document.createElement("div");
    globalThis?.document?.body?.appendChild(i2), e2.canvasElement = i2, X3.push(() => {
      globalThis?.document?.body?.contains(i2) && globalThis?.document?.body?.removeChild(i2);
    });
  }
  if (e2.loaded = await r2.applyLoaders(e2), e2.abortSignal.aborted)
    return;
  X3.push(...(await r2.applyBeforeEach(e2)).filter(Boolean));
  let t2 = r2.playFunction, o2 = r2.usesMount;
  if (o2 || await e2.mount(), e2.abortSignal.aborted)
    return;
  t2 && (o2 || (e2.mount = async () => {
    throw new B2({ playFunction: t2.toString() });
  }), await t2(e2));
  let s2;
  er2() ? s2 = ge2() : await be(e2.abortSignal), await r2.applyAfterEach(e2), await s2?.();
}
n3(ei, "runStory");
var wo2 = 1e3;
var ni = 1e4;
var Kr2 = class Kr3 {
  constructor(e2, t2, o2) {
    this.importFn = t2;
    this.storyIndex = new Ke2(e2), this.projectAnnotations = he2(
      K4([..._r(), o2])
    );
    let { initialGlobals: s2, globalTypes: i2 } = this.projectAnnotations;
    this.args = new We2(), this.userGlobals = new Ye2({ globals: s2, globalTypes: i2 }), this.hooks = {}, this.cleanupCallbacks = {}, this.processCSFFileWithCache = (0, rr2.default)(wo2)(fo), this.prepareMetaWithCache = (0, rr2.default)(wo2)(Ur2), this.prepareStoryWithCache = (0, rr2.default)(ni)(De2);
  }
  setProjectAnnotations(e2) {
    this.projectAnnotations = he2(e2);
    let { initialGlobals: t2, globalTypes: o2 } = e2;
    this.userGlobals.set({ globals: t2, globalTypes: o2 });
  }
  // This means that one of the CSF files has changed.
  // If the `importFn` has changed, we will invalidate both caches.
  // If the `storyIndex` data has changed, we may or may not invalidate the caches, depending
  // on whether we've loaded the relevant files yet.
  async onStoriesChanged({
    importFn: e2,
    storyIndex: t2
  }) {
    e2 && (this.importFn = e2), t2 && (this.storyIndex.entries = t2.entries), this.cachedCSFFiles && await this.cacheAllCSFFiles();
  }
  // Get an entry from the index, waiting on initialization if necessary
  async storyIdToEntry(e2) {
    return this.storyIndex.storyIdToEntry(e2);
  }
  // To load a single CSF file to service a story we need to look up the importPath in the index
  async loadCSFFileByStoryId(e2) {
    let { importPath: t2, title: o2 } = this.storyIndex.storyIdToEntry(e2), s2 = await this.importFn(t2);
    return this.processCSFFileWithCache(s2, t2, o2);
  }
  async loadAllCSFFiles() {
    let e2 = {};
    return Object.entries(this.storyIndex.entries).forEach(([o2, { importPath: s2 }]) => {
      e2[s2] = o2;
    }), (await Promise.all(
      Object.entries(e2).map(async ([o2, s2]) => ({
        importPath: o2,
        csfFile: await this.loadCSFFileByStoryId(s2)
      }))
    )).reduce(
      (o2, { importPath: s2, csfFile: i2 }) => (o2[s2] = i2, o2),
      {}
    );
  }
  async cacheAllCSFFiles() {
    this.cachedCSFFiles = await this.loadAllCSFFiles();
  }
  preparedMetaFromCSFFile({ csfFile: e2 }) {
    let t2 = e2.meta;
    return this.prepareMetaWithCache(
      t2,
      this.projectAnnotations,
      e2.moduleExports.default
    );
  }
  // Load the CSF file for a story and prepare the story from it and the project annotations.
  async loadStory({ storyId: e2 }) {
    let t2 = await this.loadCSFFileByStoryId(e2);
    return this.storyFromCSFFile({ storyId: e2, csfFile: t2 });
  }
  // This function is synchronous for convenience -- often times if you have a CSF file already
  // it is easier not to have to await `loadStory`.
  storyFromCSFFile({
    storyId: e2,
    csfFile: t2
  }) {
    let o2 = t2.stories[e2];
    if (!o2)
      throw new q2({ storyId: e2 });
    let s2 = t2.meta, i2 = this.prepareStoryWithCache(
      o2,
      s2,
      t2.projectAnnotations ?? this.projectAnnotations
    );
    return this.args.setInitial(i2), this.hooks[i2.id] = this.hooks[i2.id] || new te2(), i2;
  }
  // If we have a CSF file we can get all the stories from it synchronously
  componentStoriesFromCSFFile({
    csfFile: e2
  }) {
    return Object.keys(this.storyIndex.entries).filter((t2) => !!e2.stories[t2]).map((t2) => this.storyFromCSFFile({ storyId: t2, csfFile: e2 }));
  }
  async loadEntry(e2) {
    let t2 = await this.storyIdToEntry(e2), o2 = t2.type === "docs" ? t2.storiesImports : [], [s2, ...i2] = await Promise.all([
      this.importFn(t2.importPath),
      ...o2.map((a) => {
        let l2 = this.storyIndex.importPathToEntry(a);
        return this.loadCSFFileByStoryId(l2.id);
      })
    ]);
    return { entryExports: s2, csfFiles: i2 };
  }
  // A prepared story does not include args, globals or hooks. These are stored in the story store
  // and updated separtely to the (immutable) story.
  getStoryContext(e2, { forceInitialArgs: t2 = false } = {}) {
    let o2 = this.userGlobals.get(), { initialGlobals: s2 } = this.userGlobals, i2 = new se3();
    return Je2({
      ...e2,
      args: t2 ? e2.initialArgs : this.args.get(e2.id),
      initialGlobals: s2,
      globalTypes: this.projectAnnotations.globalTypes,
      userGlobals: o2,
      reporting: i2,
      globals: {
        ...o2,
        ...e2.storyGlobals
      },
      hooks: this.hooks[e2.id]
    });
  }
  addCleanupCallbacks(e2, ...t2) {
    this.cleanupCallbacks[e2.id] = (this.cleanupCallbacks[e2.id] || []).concat(t2);
  }
  async cleanupStory(e2) {
    this.hooks[e2.id].clean();
    let t2 = this.cleanupCallbacks[e2.id];
    if (t2)
      for (let o2 of [...t2].reverse())
        await o2();
    delete this.cleanupCallbacks[e2.id];
  }
  extract(e2 = { includeDocsOnly: false }) {
    let { cachedCSFFiles: t2 } = this;
    if (!t2)
      throw new F();
    return Object.entries(this.storyIndex.entries).reduce(
      (o2, [s2, { type: i2, importPath: a }]) => {
        if (i2 === "docs")
          return o2;
        let l2 = t2[a], c = this.storyFromCSFFile({ storyId: s2, csfFile: l2 });
        return !e2.includeDocsOnly && c.parameters.docsOnly || (o2[s2] = Object.entries(c).reduce(
          (d2, [p2, u]) => p2 === "moduleExport" || typeof u == "function" ? d2 : Array.isArray(u) ? Object.assign(d2, { [p2]: u.slice().sort() }) : Object.assign(d2, { [p2]: u }),
          {
            //
            args: c.initialArgs,
            globals: {
              ...this.userGlobals.initialGlobals,
              ...this.userGlobals.globals,
              ...c.storyGlobals
            }
          }
        )), o2;
      },
      {}
    );
  }
};
n3(Kr2, "StoryStore");
var Se2 = Kr2;
function Xr2(r2) {
  return r2.startsWith("\\\\?\\") ? r2 : r2.replace(/\\/g, "/");
}
n3(Xr2, "slash");
var ii = n3((r2) => {
  if (r2.length === 0)
    return r2;
  let e2 = r2[r2.length - 1], t2 = e2?.replace(/(?:[.](?:story|stories))?([.][^.]+)$/i, "");
  if (r2.length === 1)
    return [t2];
  let o2 = r2[r2.length - 2];
  return t2 && o2 && t2.toLowerCase() === o2.toLowerCase() ? [...r2.slice(0, -2), t2] : t2 && (/^(story|stories)([.][^.]+)$/i.test(e2) || /^index$/i.test(t2)) ? r2.slice(0, -1) : [...r2.slice(0, -1), t2];
}, "sanitize");
function Ao(r2) {
  return r2.flatMap((e2) => e2.split("/")).filter(Boolean).join("/");
}
n3(Ao, "pathJoin");
var Eo2 = n3((r2, e2, t2) => {
  let { directory: o2, importPathMatcher: s2, titlePrefix: i2 = "" } = e2 || {};
  typeof r2 == "number" && o.warn(P4`
      CSF Auto-title received a numeric fileName. This typically happens when
      webpack is mis-configured in production mode. To force webpack to produce
      filenames, set optimization.moduleIds = "named" in your webpack config.
    `);
  let a = Xr2(String(r2));
  if (s2.exec(a)) {
    if (!t2) {
      let l2 = a.replace(o2, ""), c = Ao([i2, l2]).split("/");
      return c = ii(c), c.join("/");
    }
    return i2 ? Ao([i2, t2]) : t2;
  }
}, "userOrAutoTitleFromSpecifier");
var ai = n3((r2, e2, t2) => {
  for (let o2 = 0; o2 < e2.length; o2 += 1) {
    let s2 = Eo2(r2, e2[o2], t2);
    if (s2)
      return s2;
  }
  return t2 || void 0;
}, "userOrAutoTitle");
var Co2 = /\s*\/\s*/;
var vo = n3((r2 = {}) => (e2, t2) => {
  if (e2.title === t2.title && !r2.includeNames)
    return 0;
  let o2 = r2.method || "configure", s2 = r2.order || [], i2 = e2.title.trim().split(Co2), a = t2.title.trim().split(Co2);
  r2.includeNames && (i2.push(e2.name), a.push(t2.name));
  let l2 = 0;
  for (; i2[l2] || a[l2]; ) {
    if (!i2[l2])
      return -1;
    if (!a[l2])
      return 1;
    let c = i2[l2], d2 = a[l2];
    if (c !== d2) {
      let u = s2.indexOf(c), y = s2.indexOf(d2), h2 = s2.indexOf("*");
      return u !== -1 || y !== -1 ? (u === -1 && (h2 !== -1 ? u = h2 : u = s2.length), y === -1 && (h2 !== -1 ? y = h2 : y = s2.length), u - y) : o2 === "configure" ? 0 : c.localeCompare(d2, r2.locales ? r2.locales : void 0, {
        numeric: true,
        sensitivity: "accent"
      });
    }
    let p2 = s2.indexOf(c);
    p2 === -1 && (p2 = s2.indexOf("*")), s2 = p2 !== -1 && Array.isArray(s2[p2 + 1]) ? s2[p2 + 1] : [], l2 += 1;
  }
  return 0;
}, "storySort");
var li = n3((r2, e2, t2) => {
  if (e2) {
    let o2;
    typeof e2 == "function" ? o2 = e2 : o2 = vo(e2), r2.sort(o2);
  } else
    r2.sort(
      (o2, s2) => t2.indexOf(o2.importPath) - t2.indexOf(s2.importPath)
    );
  return r2;
}, "sortStoriesCommon");
var ci = n3((r2, e2, t2) => {
  try {
    return li(r2, e2, t2);
  } catch (o2) {
    throw new Error(P4`
    Error sorting stories with sort parameter ${e2}:

    > ${o2.message}
    
    Are you using a V6-style sort function in V7 mode?

    More info: https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#v7-style-story-sort
  `);
  }
}, "sortStoriesV7");
var J4 = new Error("prepareAborted");
var { AbortController: Io2 } = globalThis;
function Oo2(r2) {
  try {
    let { name: e2 = "Error", message: t2 = String(r2), stack: o2 } = r2;
    return { name: e2, message: t2, stack: o2 };
  } catch {
    return { name: "Error", message: String(r2) };
  }
}
n3(Oo2, "serializeError");
var Jr2 = class Jr3 {
  constructor(e2, t2, o2, s2, i2, a, l2 = { autoplay: true, forceInitialArgs: false }, c) {
    this.channel = e2;
    this.store = t2;
    this.renderToScreen = o2;
    this.callbacks = s2;
    this.id = i2;
    this.viewMode = a;
    this.renderOptions = l2;
    this.type = "story";
    this.notYetRendered = true;
    this.rerenderEnqueued = false;
    this.disableKeyListeners = false;
    this.teardownRender = n3(() => {
    }, "teardownRender");
    this.torndown = false;
    this.abortController = new Io2(), this.renderId = Date.now(), c && (this.story = c, this.phase = "preparing");
  }
  async runPhase(e2, t2, o2) {
    this.phase = t2, this.channel.emit(B, {
      newPhase: this.phase,
      renderId: this.renderId,
      storyId: this.id
    }), o2 && (await o2(), this.checkIfAborted(e2));
  }
  checkIfAborted(e2) {
    return e2.aborted ? (this.phase = "aborted", this.channel.emit(B, {
      newPhase: this.phase,
      renderId: this.renderId,
      storyId: this.id
    }), true) : false;
  }
  async prepare() {
    if (await this.runPhase(this.abortController.signal, "preparing", async () => {
      this.story = await this.store.loadStory({ storyId: this.id });
    }), this.abortController.signal.aborted)
      throw await this.store.cleanupStory(this.story), J4;
  }
  // The two story "renders" are equal and have both loaded the same story
  isEqual(e2) {
    return !!(this.id === e2.id && this.story && this.story === e2.story);
  }
  isPreparing() {
    return ["preparing"].includes(this.phase);
  }
  isPending() {
    return ["loading", "beforeEach", "rendering", "playing", "afterEach"].includes(
      this.phase
    );
  }
  async renderToElement(e2) {
    return this.canvasElement = e2, this.render({ initial: true, forceRemount: true });
  }
  storyContext() {
    if (!this.story)
      throw new Error("Cannot call storyContext before preparing");
    let { forceInitialArgs: e2 } = this.renderOptions;
    return this.store.getStoryContext(this.story, { forceInitialArgs: e2 });
  }
  async render({
    initial: e2 = false,
    forceRemount: t2 = false
  } = {}) {
    let { canvasElement: o2 } = this;
    if (!this.story)
      throw new Error("cannot render when not prepared");
    let s2 = this.story;
    if (!o2)
      throw new Error("cannot render when canvasElement is unset");
    let {
      id: i2,
      componentId: a,
      title: l2,
      name: c,
      tags: d2,
      applyLoaders: p2,
      applyBeforeEach: u,
      applyAfterEach: y,
      unboundStoryFn: h2,
      playFunction: g3,
      runStep: b5
    } = s2;
    t2 && !e2 && (this.cancelRender(), this.abortController = new Io2());
    let m2 = this.abortController.signal, T3 = false, x4 = s2.usesMount;
    try {
      let f3 = {
        ...this.storyContext(),
        viewMode: this.viewMode,
        abortSignal: m2,
        canvasElement: o2,
        loaded: {},
        step: n3((v3, B4) => b5(v3, B4, f3), "step"),
        context: null,
        canvas: {},
        userEvent: {},
        renderToCanvas: n3(async () => {
          let v3 = await this.renderToScreen(S3, o2);
          this.teardownRender = v3 || (() => {
          }), T3 = true;
        }, "renderToCanvas"),
        // The story provides (set in a renderer) a mount function that is a higher order function
        // (context) => (...args) => Canvas
        //
        // Before assigning it to the context, we resolve the context dependency,
        // so that a user can just call it as await mount(...args) in their play function.
        mount: n3(async (...v3) => {
          this.callbacks.showStoryDuringRender?.();
          let B4 = null;
          return await this.runPhase(m2, "rendering", async () => {
            B4 = await s2.mount(f3)(...v3);
          }), x4 && await this.runPhase(m2, "playing"), B4;
        }, "mount")
      };
      f3.context = f3;
      let S3 = {
        componentId: a,
        title: l2,
        kind: l2,
        id: i2,
        name: c,
        story: c,
        tags: d2,
        ...this.callbacks,
        showError: n3((v3) => (this.phase = "errored", this.callbacks.showError(v3)), "showError"),
        showException: n3((v3) => (this.phase = "errored", this.callbacks.showException(v3)), "showException"),
        forceRemount: t2 || this.notYetRendered,
        storyContext: f3,
        storyFn: n3(() => h2(f3), "storyFn"),
        unboundStoryFn: h2
      };
      if (await this.runPhase(m2, "loading", async () => {
        f3.loaded = await p2(f3);
      }), m2.aborted)
        return;
      let R3 = await u(f3);
      if (this.store.addCleanupCallbacks(s2, ...R3), this.checkIfAborted(m2) || (!T3 && !x4 && await f3.mount(), this.notYetRendered = false, m2.aborted))
        return;
      let w4 = this.story.parameters?.test?.dangerouslyIgnoreUnhandledErrors === true, E = /* @__PURE__ */ new Set(), D5 = n3((v3) => {
        v3.error && E.add(v3.error);
      }, "onError"), k4 = n3((v3) => {
        v3.reason && E.add(v3.reason);
      }, "onUnhandledRejection");
      if (this.renderOptions.autoplay && t2 && g3 && this.phase !== "errored") {
        window?.addEventListener?.("error", D5), window?.addEventListener?.("unhandledrejection", k4), this.disableKeyListeners = true;
        try {
          if (x4 ? await g3(f3) : (f3.mount = async () => {
            throw new B2({ playFunction: g3.toString() });
          }, await this.runPhase(m2, "playing", async () => g3(f3))), !T3)
            throw new Z2();
          this.checkIfAborted(m2), !w4 && E.size > 0 ? await this.runPhase(m2, "errored") : await this.runPhase(m2, "played");
        } catch (v3) {
          if (this.callbacks.showStoryDuringRender?.(), await this.runPhase(m2, "errored", async () => {
            this.channel.emit(U, Oo2(v3));
          }), this.story.parameters.throwPlayFunctionExceptions !== false)
            throw v3;
          console.error(v3);
        }
        if (!w4 && E.size > 0 && this.channel.emit(
          H,
          Array.from(E).map(Oo2)
        ), this.disableKeyListeners = false, window?.removeEventListener?.("unhandledrejection", k4), window?.removeEventListener?.("error", D5), m2.aborted)
          return;
      }
      await this.runPhase(m2, "completing", async () => {
        er2() ? this.store.addCleanupCallbacks(s2, ge2()) : await be(m2);
      }), await this.runPhase(m2, "completed", async () => {
        this.channel.emit(X, i2);
      }), this.phase !== "errored" && await this.runPhase(m2, "afterEach", async () => {
        await y(f3);
      });
      let L3 = !w4 && E.size > 0, pe2 = f3.reporting.reports.some(
        (v3) => v3.status === "failed"
      ), q4 = L3 || pe2;
      await this.runPhase(
        m2,
        "finished",
        async () => this.channel.emit(b, {
          storyId: i2,
          status: q4 ? "error" : "success",
          reporters: f3.reporting.reports
        })
      );
    } catch (f3) {
      this.phase = "errored", this.callbacks.showException(f3), await this.runPhase(
        m2,
        "finished",
        async () => this.channel.emit(b, {
          storyId: i2,
          status: "error",
          reporters: []
        })
      );
    }
    this.rerenderEnqueued && (this.rerenderEnqueued = false, this.render());
  }
  /**
   * Rerender the story. If the story is currently pending (loading/rendering), the rerender will be
   * enqueued, and will be executed after the current render is completed. Rerendering while playing
   * will not be enqueued, and will be executed immediately, to support rendering args changes while
   * playing.
   */
  async rerender() {
    if (this.isPending() && this.phase !== "playing")
      this.rerenderEnqueued = true;
    else
      return this.render();
  }
  async remount() {
    return await this.teardown(), this.render({ forceRemount: true });
  }
  // If the story is torn down (either a new story is rendered or the docs page removes it)
  // we need to consider the fact that the initial render may not be finished
  // (possibly the loaders or the play function are still running). We use the controller
  // as a method to abort them, ASAP, but this is not foolproof as we cannot control what
  // happens inside the user's code.
  cancelRender() {
    this.abortController.abort();
  }
  cancelPlayFunction() {
    this.phase === "playing" && (this.abortController.abort(), this.runPhase(this.abortController.signal, "aborted"));
  }
  async teardown() {
    this.torndown = true, this.cancelRender(), this.story && await this.store.cleanupStory(this.story);
    for (let e2 = 0; e2 < 3; e2 += 1) {
      if (!this.isPending()) {
        await this.teardownRender();
        return;
      }
      await new Promise((t2) => setTimeout(t2, 0));
    }
    window?.location?.reload?.(), await new Promise(() => {
    });
  }
};
n3(Jr2, "StoryRender");
var ie3 = Jr2;
var { fetch: Oi } = scope;
var Di = "./index.json";
var Qr2 = class Qr3 {
  constructor(e2, t2, o2 = _3.getChannel(), s2 = true) {
    this.importFn = e2;
    this.getProjectAnnotations = t2;
    this.channel = o2;
    this.storyRenders = [];
    this.storeInitializationPromise = new Promise((i2, a) => {
      this.resolveStoreInitializationPromise = i2, this.rejectStoreInitializationPromise = a;
    }), s2 && this.initialize();
  }
  // Create a proxy object for `__STORYBOOK_STORY_STORE__` and `__STORYBOOK_PREVIEW__.storyStore`
  // That proxies through to the store once ready, and errors beforehand. This means we can set
  // `__STORYBOOK_STORY_STORE__ = __STORYBOOK_PREVIEW__.storyStore` without having to wait, and
  // similarly integrators can access the `storyStore` on the preview at any time, although
  // it is considered deprecated and we will no longer allow access in 9.0
  get storyStore() {
    return new Proxy(
      {},
      {
        get: n3((e2, t2) => {
          if (this.storyStoreValue)
            return h("Accessing the Story Store is deprecated and will be removed in 9.0"), this.storyStoreValue[t2];
          throw new z3();
        }, "get")
      }
    );
  }
  // INITIALIZATION
  async initialize() {
    this.setupListeners();
    try {
      let e2 = await this.getProjectAnnotationsOrRenderError();
      await this.runBeforeAllHook(e2), await this.initializeWithProjectAnnotations(e2);
    } catch (e2) {
      this.rejectStoreInitializationPromise(e2);
    }
  }
  ready() {
    return this.storeInitializationPromise;
  }
  setupListeners() {
    this.channel.on(Q, this.onStoryIndexChanged.bind(this)), this.channel.on(z, this.onUpdateGlobals.bind(this)), this.channel.on(Z, this.onUpdateArgs.bind(this)), this.channel.on(TE, this.onRequestArgTypesInfo.bind(this)), this.channel.on(p, this.onResetArgs.bind(this)), this.channel.on(P, this.onForceReRender.bind(this)), this.channel.on(L, this.onForceRemount.bind(this)), this.channel.on(k, this.onStoryHotUpdated.bind(this));
  }
  async getProjectAnnotationsOrRenderError() {
    try {
      let e2 = await this.getProjectAnnotations();
      if (this.renderToCanvas = e2.renderToCanvas, !this.renderToCanvas)
        throw new H2();
      return e2;
    } catch (e2) {
      throw this.renderPreviewEntryError("Error reading preview.js:", e2), e2;
    }
  }
  // If initialization gets as far as project annotations, this function runs.
  async initializeWithProjectAnnotations(e2) {
    this.projectAnnotationsBeforeInitialization = e2;
    try {
      let t2 = await this.getStoryIndexFromServer();
      return this.initializeWithStoryIndex(t2);
    } catch (t2) {
      throw this.renderPreviewEntryError("Error loading story index:", t2), t2;
    }
  }
  async runBeforeAllHook(e2) {
    try {
      await this.beforeAllCleanup?.(), this.beforeAllCleanup = await e2.beforeAll?.();
    } catch (t2) {
      throw this.renderPreviewEntryError("Error in beforeAll hook:", t2), t2;
    }
  }
  async getStoryIndexFromServer() {
    let e2 = await Oi(Di);
    if (e2.status === 200)
      return e2.json();
    throw new K2({ text: await e2.text() });
  }
  // If initialization gets as far as the story index, this function runs.
  initializeWithStoryIndex(e2) {
    if (!this.projectAnnotationsBeforeInitialization)
      throw new Error("Cannot call initializeWithStoryIndex until project annotations resolve");
    this.storyStoreValue = new Se2(
      e2,
      this.importFn,
      this.projectAnnotationsBeforeInitialization
    ), delete this.projectAnnotationsBeforeInitialization, this.setInitialGlobals(), this.resolveStoreInitializationPromise();
  }
  async setInitialGlobals() {
    this.emitGlobals();
  }
  emitGlobals() {
    if (!this.storyStoreValue)
      throw new M2({ methodName: "emitGlobals" });
    let e2 = {
      globals: this.storyStoreValue.userGlobals.get() || {},
      globalTypes: this.storyStoreValue.projectAnnotations.globalTypes || {}
    };
    this.channel.emit(e, e2);
  }
  // EVENT HANDLERS
  // This happens when a config file gets reloaded
  async onGetProjectAnnotationsChanged({
    getProjectAnnotations: e2
  }) {
    delete this.previewEntryError, this.getProjectAnnotations = e2;
    let t2 = await this.getProjectAnnotationsOrRenderError();
    if (await this.runBeforeAllHook(t2), !this.storyStoreValue) {
      await this.initializeWithProjectAnnotations(t2);
      return;
    }
    this.storyStoreValue.setProjectAnnotations(t2), this.emitGlobals();
  }
  async onStoryIndexChanged() {
    if (delete this.previewEntryError, !(!this.storyStoreValue && !this.projectAnnotationsBeforeInitialization))
      try {
        let e2 = await this.getStoryIndexFromServer();
        if (this.projectAnnotationsBeforeInitialization) {
          this.initializeWithStoryIndex(e2);
          return;
        }
        await this.onStoriesChanged({ storyIndex: e2 });
      } catch (e2) {
        throw this.renderPreviewEntryError("Error loading story index:", e2), e2;
      }
  }
  // This happens when a glob gets HMR-ed
  async onStoriesChanged({
    importFn: e2,
    storyIndex: t2
  }) {
    if (!this.storyStoreValue)
      throw new M2({ methodName: "onStoriesChanged" });
    await this.storyStoreValue.onStoriesChanged({ importFn: e2, storyIndex: t2 });
  }
  async onUpdateGlobals({
    globals: e2,
    currentStory: t2
  }) {
    if (this.storyStoreValue || await this.storeInitializationPromise, !this.storyStoreValue)
      throw new M2({ methodName: "onUpdateGlobals" });
    if (this.storyStoreValue.userGlobals.update(e2), t2) {
      let { initialGlobals: o2, storyGlobals: s2, userGlobals: i2, globals: a } = this.storyStoreValue.getStoryContext(t2);
      this.channel.emit(Y, {
        initialGlobals: o2,
        userGlobals: i2,
        storyGlobals: s2,
        globals: a
      });
    } else {
      let { initialGlobals: o2, globals: s2 } = this.storyStoreValue.userGlobals;
      this.channel.emit(Y, {
        initialGlobals: o2,
        userGlobals: s2,
        storyGlobals: {},
        globals: s2
      });
    }
    await Promise.all(this.storyRenders.map((o2) => o2.rerender()));
  }
  async onUpdateArgs({ storyId: e2, updatedArgs: t2 }) {
    if (!this.storyStoreValue)
      throw new M2({ methodName: "onUpdateArgs" });
    this.storyStoreValue.args.update(e2, t2), await Promise.all(
      this.storyRenders.filter((o2) => o2.id === e2 && !o2.renderOptions.forceInitialArgs).map(
        (o2) => (
          // We only run the play function, with in a force remount.
          // But when mount is destructured, the rendering happens inside of the play function.
          o2.story && o2.story.usesMount ? o2.remount() : o2.rerender()
        )
      )
    ), this.channel.emit(x, {
      storyId: e2,
      args: this.storyStoreValue.args.get(e2)
    });
  }
  async onRequestArgTypesInfo({ id: e2, payload: t2 }) {
    try {
      await this.storeInitializationPromise;
      let o2 = await this.storyStoreValue?.loadStory(t2);
      this.channel.emit(OE, {
        id: e2,
        success: true,
        payload: { argTypes: o2?.argTypes || {} },
        error: null
      });
    } catch (o2) {
      this.channel.emit(OE, {
        id: e2,
        success: false,
        error: o2?.message
      });
    }
  }
  async onResetArgs({ storyId: e2, argNames: t2 }) {
    if (!this.storyStoreValue)
      throw new M2({ methodName: "onResetArgs" });
    let s2 = this.storyRenders.find((l2) => l2.id === e2)?.story || await this.storyStoreValue.loadStory({ storyId: e2 }), a = (t2 || [
      .../* @__PURE__ */ new Set([
        ...Object.keys(s2.initialArgs),
        ...Object.keys(this.storyStoreValue.args.get(e2))
      ])
    ]).reduce((l2, c) => (l2[c] = s2.initialArgs[c], l2), {});
    await this.onUpdateArgs({ storyId: e2, updatedArgs: a });
  }
  // ForceReRender does not include a story id, so we simply must
  // re-render all stories in case they are relevant
  async onForceReRender() {
    await Promise.all(this.storyRenders.map((e2) => e2.rerender()));
  }
  async onForceRemount({ storyId: e2 }) {
    await Promise.all(this.storyRenders.filter((t2) => t2.id === e2).map((t2) => t2.remount()));
  }
  async onStoryHotUpdated() {
    await Promise.all(this.storyRenders.map((e2) => e2.cancelPlayFunction()));
  }
  // Used by docs to render a story to a given element
  // Note this short-circuits the `prepare()` phase of the StoryRender,
  // main to be consistent with the previous behaviour. In the future,
  // we will change it to go ahead and load the story, which will end up being
  // "instant", although async.
  renderStoryToElement(e2, t2, o2, s2) {
    if (!this.renderToCanvas || !this.storyStoreValue)
      throw new M2({
        methodName: "renderStoryToElement"
      });
    let i2 = new ie3(
      this.channel,
      this.storyStoreValue,
      this.renderToCanvas,
      o2,
      e2.id,
      "docs",
      s2,
      e2
    );
    return i2.renderToElement(t2), this.storyRenders.push(i2), async () => {
      await this.teardownRender(i2);
    };
  }
  async teardownRender(e2, { viewModeChanged: t2 } = {}) {
    this.storyRenders = this.storyRenders.filter((o2) => o2 !== e2), await e2?.teardown?.({ viewModeChanged: t2 });
  }
  // API
  async loadStory({ storyId: e2 }) {
    if (!this.storyStoreValue)
      throw new M2({ methodName: "loadStory" });
    return this.storyStoreValue.loadStory({ storyId: e2 });
  }
  getStoryContext(e2, { forceInitialArgs: t2 = false } = {}) {
    if (!this.storyStoreValue)
      throw new M2({ methodName: "getStoryContext" });
    return this.storyStoreValue.getStoryContext(e2, { forceInitialArgs: t2 });
  }
  async extract(e2) {
    if (!this.storyStoreValue)
      throw new M2({ methodName: "extract" });
    if (this.previewEntryError)
      throw this.previewEntryError;
    return await this.storyStoreValue.cacheAllCSFFiles(), this.storyStoreValue.extract(e2);
  }
  // UTILITIES
  renderPreviewEntryError(e2, t2) {
    this.previewEntryError = t2, i.error(e2), i.error(t2), this.channel.emit(O, t2);
  }
};
n3(Qr2, "Preview");
var Te2 = Qr2;
var ki2 = false;
var Zr = "Invariant failed";
function tr2(r2, e2) {
  if (!r2) {
    if (ki2)
      throw new Error(Zr);
    var t2 = typeof e2 == "function" ? e2() : e2, o2 = t2 ? "".concat(Zr, ": ").concat(t2) : Zr;
    throw new Error(o2);
  }
}
n3(tr2, "invariant");
var et2 = class et3 {
  constructor(e2, t2, o2, s2) {
    this.channel = e2;
    this.store = t2;
    this.renderStoryToElement = o2;
    this.storyIdByName = n3((e3) => {
      let t3 = this.nameToStoryId.get(e3);
      if (t3)
        return t3;
      throw new Error(`No story found with that name: ${e3}`);
    }, "storyIdByName");
    this.componentStories = n3(() => this.componentStoriesValue, "componentStories");
    this.componentStoriesFromCSFFile = n3((e3) => this.store.componentStoriesFromCSFFile({ csfFile: e3 }), "componentStoriesFromCSFFile");
    this.storyById = n3((e3) => {
      if (!e3) {
        if (!this.primaryStory)
          throw new Error(
            "No primary story defined for docs entry. Did you forget to use `<Meta>`?"
          );
        return this.primaryStory;
      }
      let t3 = this.storyIdToCSFFile.get(e3);
      if (!t3)
        throw new Error(`Called \`storyById\` for story that was never loaded: ${e3}`);
      return this.store.storyFromCSFFile({ storyId: e3, csfFile: t3 });
    }, "storyById");
    this.getStoryContext = n3((e3) => ({
      ...this.store.getStoryContext(e3),
      loaded: {},
      viewMode: "docs"
    }), "getStoryContext");
    this.loadStory = n3((e3) => this.store.loadStory({ storyId: e3 }), "loadStory");
    this.componentStoriesValue = [], this.storyIdToCSFFile = /* @__PURE__ */ new Map(), this.exportToStory = /* @__PURE__ */ new Map(), this.exportsToCSFFile = /* @__PURE__ */ new Map(), this.nameToStoryId = /* @__PURE__ */ new Map(), this.attachedCSFFiles = /* @__PURE__ */ new Set(), s2.forEach((i2, a) => {
      this.referenceCSFFile(i2);
    });
  }
  // This docs entry references this CSF file and can synchronously load the stories, as well
  // as reference them by module export. If the CSF is part of the "component" stories, they
  // can also be referenced by name and are in the componentStories list.
  referenceCSFFile(e2) {
    this.exportsToCSFFile.set(e2.moduleExports, e2), this.exportsToCSFFile.set(e2.moduleExports.default, e2), this.store.componentStoriesFromCSFFile(
      { csfFile: e2 }
    ).forEach((o2) => {
      let s2 = e2.stories[o2.id];
      this.storyIdToCSFFile.set(s2.id, e2), this.exportToStory.set(s2.moduleExport, o2);
    });
  }
  attachCSFFile(e2) {
    if (!this.exportsToCSFFile.has(e2.moduleExports))
      throw new Error("Cannot attach a CSF file that has not been referenced");
    if (this.attachedCSFFiles.has(e2))
      return;
    this.attachedCSFFiles.add(e2), this.store.componentStoriesFromCSFFile({ csfFile: e2 }).forEach((o2) => {
      this.nameToStoryId.set(o2.name, o2.id), this.componentStoriesValue.push(o2), this.primaryStory || (this.primaryStory = o2);
    });
  }
  referenceMeta(e2, t2) {
    let o2 = this.resolveModuleExport(e2);
    if (o2.type !== "meta")
      throw new Error(
        "<Meta of={} /> must reference a CSF file module export or meta export. Did you mistakenly reference your component instead of your CSF file?"
      );
    t2 && this.attachCSFFile(o2.csfFile);
  }
  get projectAnnotations() {
    let { projectAnnotations: e2 } = this.store;
    if (!e2)
      throw new Error("Can't get projectAnnotations from DocsContext before they are initialized");
    return e2;
  }
  resolveAttachedModuleExportType(e2) {
    if (e2 === "story") {
      if (!this.primaryStory)
        throw new Error(
          "No primary story attached to this docs file, did you forget to use <Meta of={} />?"
        );
      return { type: "story", story: this.primaryStory };
    }
    if (this.attachedCSFFiles.size === 0)
      throw new Error(
        "No CSF file attached to this docs file, did you forget to use <Meta of={} />?"
      );
    let t2 = Array.from(this.attachedCSFFiles)[0];
    if (e2 === "meta")
      return { type: "meta", csfFile: t2 };
    let { component: o2 } = t2.meta;
    if (!o2)
      throw new Error(
        "Attached CSF file does not defined a component, did you forget to export one?"
      );
    return { type: "component", component: o2 };
  }
  resolveModuleExport(e2) {
    let t2 = this.exportsToCSFFile.get(e2);
    if (t2)
      return { type: "meta", csfFile: t2 };
    let o2 = this.exportToStory.get(
      ic(e2) ? e2.input : e2
    );
    return o2 ? { type: "story", story: o2 } : { type: "component", component: e2 };
  }
  resolveOf(e2, t2 = []) {
    let o2;
    if (["component", "meta", "story"].includes(e2)) {
      let s2 = e2;
      o2 = this.resolveAttachedModuleExportType(s2);
    } else
      o2 = this.resolveModuleExport(e2);
    if (t2.length && !t2.includes(o2.type)) {
      let s2 = o2.type === "component" ? "component or unknown" : o2.type;
      throw new Error(P4`Invalid value passed to the 'of' prop. The value was resolved to a '${s2}' type but the only types for this block are: ${t2.join(
        ", "
      )}.
        - Did you pass a component to the 'of' prop when the block only supports a story or a meta?
        - ... or vice versa?
        - Did you pass a story, CSF file or meta to the 'of' prop that is not indexed, ie. is not targeted by the 'stories' globs in the main configuration?`);
    }
    switch (o2.type) {
      case "component":
        return {
          ...o2,
          projectAnnotations: this.projectAnnotations
        };
      case "meta":
        return {
          ...o2,
          preparedMeta: this.store.preparedMetaFromCSFFile({ csfFile: o2.csfFile })
        };
      case "story":
      default:
        return o2;
    }
  }
};
n3(et2, "DocsContext");
var Q4 = et2;
var rt2 = class rt3 {
  constructor(e2, t2, o2, s2) {
    this.channel = e2;
    this.store = t2;
    this.entry = o2;
    this.callbacks = s2;
    this.type = "docs";
    this.subtype = "csf";
    this.torndown = false;
    this.disableKeyListeners = false;
    this.preparing = false;
    this.id = o2.id, this.renderId = Date.now();
  }
  isPreparing() {
    return this.preparing;
  }
  async prepare() {
    this.preparing = true;
    let { entryExports: e2, csfFiles: t2 = [] } = await this.store.loadEntry(this.id);
    if (this.torndown)
      throw J4;
    let { importPath: o2, title: s2 } = this.entry, i2 = this.store.processCSFFileWithCache(
      e2,
      o2,
      s2
    ), a = Object.keys(i2.stories)[0];
    this.story = this.store.storyFromCSFFile({ storyId: a, csfFile: i2 }), this.csfFiles = [i2, ...t2], this.preparing = false;
  }
  isEqual(e2) {
    return !!(this.id === e2.id && this.story && this.story === e2.story);
  }
  docsContext(e2) {
    if (!this.csfFiles)
      throw new Error("Cannot render docs before preparing");
    let t2 = new Q4(
      this.channel,
      this.store,
      e2,
      this.csfFiles
    );
    return this.csfFiles.forEach((o2) => t2.attachCSFFile(o2)), t2;
  }
  async renderToElement(e2, t2) {
    if (!this.story || !this.csfFiles)
      throw new Error("Cannot render docs before preparing");
    let o2 = this.docsContext(t2), { docs: s2 } = this.story.parameters || {};
    if (!s2)
      throw new Error(
        "Cannot render a story in viewMode=docs if `@storybook/addon-docs` is not installed"
      );
    let i2 = await s2.renderer(), { render: a } = i2, l2 = n3(async () => {
      try {
        await a(o2, s2, e2), this.channel.emit(I, this.id);
      } catch (c) {
        this.callbacks.showException(c);
      }
    }, "renderDocs");
    return this.rerender = async () => l2(), this.teardownRender = async ({ viewModeChanged: c }) => {
      !c || !e2 || i2.unmount(e2);
    }, l2();
  }
  async teardown({ viewModeChanged: e2 } = {}) {
    this.teardownRender?.({ viewModeChanged: e2 }), this.torndown = true;
  }
};
n3(rt2, "CsfDocsRender");
var _e2 = rt2;
var tt2 = class tt3 {
  constructor(e2, t2, o2, s2) {
    this.channel = e2;
    this.store = t2;
    this.entry = o2;
    this.callbacks = s2;
    this.type = "docs";
    this.subtype = "mdx";
    this.torndown = false;
    this.disableKeyListeners = false;
    this.preparing = false;
    this.id = o2.id, this.renderId = Date.now();
  }
  isPreparing() {
    return this.preparing;
  }
  async prepare() {
    this.preparing = true;
    let { entryExports: e2, csfFiles: t2 = [] } = await this.store.loadEntry(this.id);
    if (this.torndown)
      throw J4;
    this.csfFiles = t2, this.exports = e2, this.preparing = false;
  }
  isEqual(e2) {
    return !!(this.id === e2.id && this.exports && this.exports === e2.exports);
  }
  docsContext(e2) {
    if (!this.csfFiles)
      throw new Error("Cannot render docs before preparing");
    return new Q4(
      this.channel,
      this.store,
      e2,
      this.csfFiles
    );
  }
  async renderToElement(e2, t2) {
    if (!this.exports || !this.csfFiles || !this.store.projectAnnotations)
      throw new Error("Cannot render docs before preparing");
    let o2 = this.docsContext(t2), { docs: s2 } = this.store.projectAnnotations.parameters ?? {};
    if (!s2)
      throw new Error(
        "Cannot render a story in viewMode=docs if `@storybook/addon-docs` is not installed"
      );
    let i2 = { ...s2, page: this.exports.default }, a = await s2.renderer(), { render: l2 } = a, c = n3(async () => {
      try {
        await l2(o2, i2, e2), this.channel.emit(I, this.id);
      } catch (d2) {
        this.callbacks.showException(d2);
      }
    }, "renderDocs");
    return this.rerender = async () => c(), this.teardownRender = async ({ viewModeChanged: d2 } = {}) => {
      !d2 || !e2 || (a.unmount(e2), this.torndown = true);
    }, c();
  }
  async teardown({ viewModeChanged: e2 } = {}) {
    this.teardownRender?.({ viewModeChanged: e2 }), this.torndown = true;
  }
};
n3(tt2, "MdxDocsRender");
var Ne2 = tt2;
var Ji = globalThis;
function Qi(r2) {
  let e2 = r2.composedPath && r2.composedPath()[0] || r2.target;
  return /input|textarea/i.test(e2.tagName) || e2.getAttribute("contenteditable") !== null;
}
n3(Qi, "focusInInput");
var qo = "attached-mdx";
var Zi = "unattached-mdx";
function ea({ tags: r2 }) {
  return r2?.includes(Zi) || r2?.includes(qo);
}
n3(ea, "isMdxEntry");
function nt2(r2) {
  return r2.type === "story";
}
n3(nt2, "isStoryRender");
function ra(r2) {
  return r2.type === "docs";
}
n3(ra, "isDocsRender");
function ta(r2) {
  return ra(r2) && r2.subtype === "csf";
}
n3(ta, "isCsfDocsRender");
var st2 = class st3 extends Te2 {
  constructor(t2, o2, s2, i2) {
    super(t2, o2, void 0, false);
    this.importFn = t2;
    this.getProjectAnnotations = o2;
    this.selectionStore = s2;
    this.view = i2;
    this.initialize();
  }
  setupListeners() {
    super.setupListeners(), Ji.onkeydown = this.onKeydown.bind(this), this.channel.on(l, this.onSetCurrentStory.bind(this)), this.channel.on(
      J,
      this.onUpdateQueryParams.bind(this)
    ), this.channel.on(G, this.onPreloadStories.bind(this));
  }
  async setInitialGlobals() {
    if (!this.storyStoreValue)
      throw new M2({ methodName: "setInitialGlobals" });
    let { globals: t2 } = this.selectionStore.selectionSpecifier || {};
    t2 && this.storyStoreValue.userGlobals.updateFromPersisted(t2), this.emitGlobals();
  }
  // If initialization gets as far as the story index, this function runs.
  async initializeWithStoryIndex(t2) {
    return await super.initializeWithStoryIndex(t2), this.selectSpecifiedStory();
  }
  // Use the selection specifier to choose a story, then render it
  async selectSpecifiedStory() {
    if (!this.storyStoreValue)
      throw new M2({
        methodName: "selectSpecifiedStory"
      });
    if (this.selectionStore.selection) {
      await this.renderSelection();
      return;
    }
    if (!this.selectionStore.selectionSpecifier) {
      this.renderMissingStory();
      return;
    }
    let { storySpecifier: t2, args: o2 } = this.selectionStore.selectionSpecifier, s2 = this.storyStoreValue.storyIndex.entryFromSpecifier(t2);
    if (!s2) {
      t2 === "*" ? this.renderStoryLoadingException(t2, new X2()) : this.renderStoryLoadingException(
        t2,
        new J2({ storySpecifier: t2.toString() })
      );
      return;
    }
    let { id: i2, type: a } = s2;
    this.selectionStore.setSelection({ storyId: i2, viewMode: a }), this.channel.emit(q, this.selectionStore.selection), this.channel.emit(
      r,
      this.selectionStore.selection
    ), await this.renderSelection({ persistedArgs: o2 });
  }
  // EVENT HANDLERS
  // This happens when a config file gets reloaded
  async onGetProjectAnnotationsChanged({
    getProjectAnnotations: t2
  }) {
    await super.onGetProjectAnnotationsChanged({ getProjectAnnotations: t2 }), this.selectionStore.selection && this.renderSelection();
  }
  // This happens when a glob gets HMR-ed
  async onStoriesChanged({
    importFn: t2,
    storyIndex: o2
  }) {
    await super.onStoriesChanged({ importFn: t2, storyIndex: o2 }), this.selectionStore.selection ? await this.renderSelection() : await this.selectSpecifiedStory();
  }
  onKeydown(t2) {
    if (!this.storyRenders.find((o2) => o2.disableKeyListeners) && !Qi(t2)) {
      let { altKey: o2, ctrlKey: s2, metaKey: i2, shiftKey: a, key: l2, code: c, keyCode: d2 } = t2;
      this.channel.emit(d, {
        event: { altKey: o2, ctrlKey: s2, metaKey: i2, shiftKey: a, key: l2, code: c, keyCode: d2 }
      });
    }
  }
  async onSetCurrentStory(t2) {
    this.selectionStore.setSelection({ viewMode: "story", ...t2 }), await this.storeInitializationPromise, this.channel.emit(r, this.selectionStore.selection), this.renderSelection();
  }
  onUpdateQueryParams(t2) {
    this.selectionStore.setQueryParams(t2);
  }
  async onUpdateGlobals({ globals: t2 }) {
    let o2 = this.currentRender instanceof ie3 && this.currentRender.story || void 0;
    super.onUpdateGlobals({ globals: t2, currentStory: o2 }), (this.currentRender instanceof Ne2 || this.currentRender instanceof _e2) && await this.currentRender.rerender?.();
  }
  async onUpdateArgs({ storyId: t2, updatedArgs: o2 }) {
    super.onUpdateArgs({ storyId: t2, updatedArgs: o2 });
  }
  async onPreloadStories({ ids: t2 }) {
    await this.storeInitializationPromise, this.storyStoreValue && await Promise.allSettled(t2.map((o2) => this.storyStoreValue?.loadEntry(o2)));
  }
  // RENDERING
  // We can either have:
  // - a story selected in "story" viewMode,
  //     in which case we render it to the root element, OR
  // - a story selected in "docs" viewMode,
  //     in which case we render the docsPage for that story
  async renderSelection({ persistedArgs: t2 } = {}) {
    let { renderToCanvas: o2 } = this;
    if (!this.storyStoreValue || !o2)
      throw new M2({ methodName: "renderSelection" });
    let { selection: s2 } = this.selectionStore;
    if (!s2)
      throw new Error("Cannot call renderSelection as no selection was made");
    let { storyId: i2 } = s2, a;
    try {
      a = await this.storyStoreValue.storyIdToEntry(i2);
    } catch (h2) {
      this.currentRender && await this.teardownRender(this.currentRender), this.renderStoryLoadingException(i2, h2);
      return;
    }
    let l2 = this.currentSelection?.storyId !== i2, c = this.currentRender?.type !== a.type;
    a.type === "story" ? this.view.showPreparingStory({ immediate: c }) : this.view.showPreparingDocs({ immediate: c }), this.currentRender?.isPreparing() && await this.teardownRender(this.currentRender);
    let d2;
    a.type === "story" ? d2 = new ie3(
      this.channel,
      this.storyStoreValue,
      o2,
      this.mainStoryCallbacks(i2),
      i2,
      "story"
    ) : ea(a) ? d2 = new Ne2(
      this.channel,
      this.storyStoreValue,
      a,
      this.mainStoryCallbacks(i2)
    ) : d2 = new _e2(
      this.channel,
      this.storyStoreValue,
      a,
      this.mainStoryCallbacks(i2)
    );
    let p2 = this.currentSelection;
    this.currentSelection = s2;
    let u = this.currentRender;
    this.currentRender = d2;
    try {
      await d2.prepare();
    } catch (h2) {
      u && await this.teardownRender(u), h2 !== J4 && this.renderStoryLoadingException(i2, h2);
      return;
    }
    let y = !l2 && u && !d2.isEqual(u);
    if (t2 && nt2(d2) && (tr2(!!d2.story), this.storyStoreValue.args.updateFromPersisted(d2.story, t2)), u && !u.torndown && !l2 && !y && !c) {
      this.currentRender = u, this.channel.emit(j, i2), this.view.showMain();
      return;
    }
    if (u && await this.teardownRender(u, { viewModeChanged: c }), p2 && (l2 || c) && this.channel.emit(m, i2), nt2(d2)) {
      tr2(!!d2.story);
      let {
        parameters: h2,
        initialArgs: g3,
        argTypes: b5,
        unmappedArgs: m2,
        initialGlobals: T3,
        userGlobals: x4,
        storyGlobals: f3,
        globals: S3
      } = this.storyStoreValue.getStoryContext(d2.story);
      this.channel.emit(w, {
        id: i2,
        parameters: h2,
        initialArgs: g3,
        argTypes: b5,
        args: m2
      }), this.channel.emit(Y, { userGlobals: x4, storyGlobals: f3, globals: S3, initialGlobals: T3 });
    } else {
      let { parameters: h2 } = this.storyStoreValue.projectAnnotations, { initialGlobals: g3, globals: b5 } = this.storyStoreValue.userGlobals;
      if (this.channel.emit(Y, {
        globals: b5,
        initialGlobals: g3,
        storyGlobals: {},
        userGlobals: b5
      }), ta(d2) || d2.entry.tags?.includes(qo)) {
        if (!d2.csfFiles)
          throw new U2({ storyId: i2 });
        ({ parameters: h2 } = this.storyStoreValue.preparedMetaFromCSFFile({
          csfFile: d2.csfFiles[0]
        }));
      }
      this.channel.emit(D, {
        id: i2,
        parameters: h2
      });
    }
    nt2(d2) ? (tr2(!!d2.story), this.storyRenders.push(d2), this.currentRender.renderToElement(
      this.view.prepareForStory(d2.story)
    )) : this.currentRender.renderToElement(
      this.view.prepareForDocs(),
      // This argument is used for docs, which is currently only compatible with HTMLElements
      this.renderStoryToElement.bind(this)
    );
  }
  async teardownRender(t2, { viewModeChanged: o2 = false } = {}) {
    this.storyRenders = this.storyRenders.filter((s2) => s2 !== t2), await t2?.teardown?.({ viewModeChanged: o2 });
  }
  // UTILITIES
  mainStoryCallbacks(t2) {
    return {
      showStoryDuringRender: n3(() => this.view.showStoryDuringRender(), "showStoryDuringRender"),
      showMain: n3(() => this.view.showMain(), "showMain"),
      showError: n3((o2) => this.renderError(t2, o2), "showError"),
      showException: n3((o2) => this.renderException(t2, o2), "showException")
    };
  }
  renderPreviewEntryError(t2, o2) {
    super.renderPreviewEntryError(t2, o2), this.view.showErrorDisplay(o2);
  }
  renderMissingStory() {
    this.view.showNoPreview(), this.channel.emit(V);
  }
  renderStoryLoadingException(t2, o2) {
    i.error(o2), this.view.showErrorDisplay(o2), this.channel.emit(V, t2);
  }
  // renderException is used if we fail to render the story and it is uncaught by the app layer
  renderException(t2, o2) {
    let { name: s2 = "Error", message: i2 = String(o2), stack: a } = o2, l2 = this.currentRender?.renderId;
    this.channel.emit(K, { name: s2, message: i2, stack: a }), this.channel.emit(B, { newPhase: "errored", renderId: l2, storyId: t2 }), this.view.showErrorDisplay(o2), i.error(`Error rendering story '${t2}':`), i.error(o2);
  }
  // renderError is used by the various app layers to inform the user they have done something
  // wrong -- for instance returned the wrong thing from a story
  renderError(t2, { title: o2, description: s2 }) {
    let i2 = this.currentRender?.renderId;
    this.channel.emit(M, { title: o2, description: s2 }), this.channel.emit(B, { newPhase: "errored", renderId: i2, storyId: t2 }), this.view.showErrorDisplay({ message: o2, stack: s2 }), i.error(`Error rendering story ${o2}: ${s2}`);
  }
};
n3(st2, "PreviewWithSelection");
var xe2 = st2;
var qe2 = ue2(lr2(), 1);
var Qo2 = ue2(lr2(), 1);
var Jo2 = /^[a-zA-Z0-9 _-]*$/;
var Zo = /^-?[0-9]+(\.[0-9]+)?$/;
var Fa = /^#([a-f0-9]{3,4}|[a-f0-9]{6}|[a-f0-9]{8})$/i;
var en2 = /^(rgba?|hsla?)\(([0-9]{1,3}),\s?([0-9]{1,3})%?,\s?([0-9]{1,3})%?,?\s?([0-9](\.[0-9]{1,2})?)?\)$/i;
var ut2 = n3((r2 = "", e2) => r2 === null || r2 === "" || !Jo2.test(r2) ? false : e2 == null || e2 instanceof Date || typeof e2 == "number" || typeof e2 == "boolean" ? true : typeof e2 == "string" ? Jo2.test(e2) || Zo.test(e2) || Fa.test(e2) || en2.test(e2) : Array.isArray(e2) ? e2.every((t2) => ut2(
  r2,
  t2
)) : j3(e2) ? Object.entries(e2).every(([t2, o2]) => ut2(t2, o2)) : false, "validateArgs");
var Ia2 = {
  delimiter: ";",
  // we're parsing a single query param
  nesting: true,
  arrayRepeat: true,
  arrayRepeatSyntax: "bracket",
  nestingSyntax: "js",
  // objects are encoded using dot notation
  valueDeserializer(r2) {
    if (r2.startsWith("!")) {
      if (r2 === "!undefined")
        return;
      if (r2 === "!null")
        return null;
      if (r2 === "!true")
        return true;
      if (r2 === "!false")
        return false;
      if (r2.startsWith("!date(") && r2.endsWith(")"))
        return new Date(r2.replaceAll(" ", "+").slice(6, -1));
      if (r2.startsWith("!hex(") && r2.endsWith(")"))
        return `#${r2.slice(5, -1)}`;
      let e2 = r2.slice(1).match(en2);
      if (e2)
        return r2.startsWith("!rgba") || r2.startsWith("!RGBA") ? `${e2[1]}(${e2[2]}, ${e2[3]}, ${e2[4]}, ${e2[5]})` : r2.startsWith("!hsla") || r2.startsWith(
          "!HSLA"
        ) ? `${e2[1]}(${e2[2]}, ${e2[3]}%, ${e2[4]}%, ${e2[5]})` : r2.startsWith("!rgb") || r2.startsWith("!RGB") ? `${e2[1]}(${e2[2]}, ${e2[3]}, ${e2[4]})` : `${e2[1]}(${e2[2]}, ${e2[3]}%, ${e2[4]}%)`;
    }
    return Zo.test(r2) ? Number(r2) : r2;
  }
};
var ft2 = n3((r2) => {
  let e2 = r2.split(";").map((t2) => t2.replace("=", "~").replace(":", "="));
  return Object.entries((0, Qo2.parse)(e2.join(";"), Ia2)).reduce((t2, [o2, s2]) => ut2(o2, s2) ? Object.assign(t2, { [o2]: s2 }) : (o.warn(P4`
      Omitted potentially unsafe URL args.

      More info: https://storybook.js.org/docs/writing-stories/args#setting-args-through-the-url?ref=error
    `), t2), {});
}, "parseArgsParam");
var { history: rn2, document: Z4 } = scope;
function Da(r2) {
  let e2 = (r2 || "").match(/^\/story\/(.+)/);
  if (!e2)
    throw new Error(`Invalid path '${r2}',  must start with '/story/'`);
  return e2[1];
}
n3(Da, "pathToId");
var tn2 = n3(({
  selection: r2,
  extraParams: e2
}) => {
  let t2 = Z4?.location.search.slice(1), { path: o2, selectedKind: s2, selectedStory: i2, ...a } = (0, qe2.parse)(t2);
  return `?${(0, qe2.stringify)({
    ...a,
    ...e2,
    ...r2 && { id: r2.storyId, viewMode: r2.viewMode }
  })}`;
}, "getQueryString");
var ka = n3((r2) => {
  if (!r2)
    return;
  let e2 = tn2({ selection: r2 }), { hash: t2 = "" } = Z4.location;
  Z4.title = r2.storyId, rn2.replaceState({}, "", `${Z4.location.pathname}${e2}${t2}`);
}, "setPath");
var ja = n3((r2) => r2 != null && typeof r2 == "object" && Array.isArray(r2) === false, "isObject");
var Le2 = n3(
  (r2) => {
    if (r2 !== void 0) {
      if (typeof r2 == "string")
        return r2;
      if (Array.isArray(r2))
        return Le2(r2[0]);
      if (ja(r2))
        return Le2(
          Object.values(r2).filter(Boolean)
        );
    }
  },
  "getFirstString"
);
var Ma = n3(() => {
  if (typeof Z4 < "u") {
    let r2 = Z4.location.search.slice(1), e2 = (0, qe2.parse)(r2), t2 = typeof e2.args == "string" ? ft2(e2.args) : void 0, o2 = typeof e2.globals == "string" ? ft2(e2.globals) : void 0, s2 = Le2(e2.viewMode);
    (typeof s2 != "string" || !s2.match(/docs|story/)) && (s2 = "story");
    let i2 = Le2(e2.path), a = i2 ? Da(i2) : Le2(e2.id);
    if (a)
      return { storySpecifier: a, args: t2, globals: o2, viewMode: s2 };
  }
  return null;
}, "getSelectionSpecifierFromPath");
var yt2 = class yt3 {
  constructor() {
    this.selectionSpecifier = Ma();
  }
  setSelection(e2) {
    this.selection = e2, ka(this.selection);
  }
  setQueryParams(e2) {
    let t2 = tn2({ extraParams: e2 }), { hash: o2 = "" } = Z4.location;
    rn2.replaceState({}, "", `${Z4.location.pathname}${t2}${o2}`);
  }
};
n3(yt2, "UrlStore");
var Re = yt2;
var Mn = ue2(Dn(), 1);
var _n2 = ue2(lr2(), 1);
var { document: O4 } = scope;
var kn = 100;
var Nn2 = ((i2) => (i2.MAIN = "MAIN", i2.NOPREVIEW = "NOPREVIEW", i2.PREPARING_STORY = "PREPARING_STORY", i2.PREPARING_DOCS = "PREPARING_DOCS", i2.ERROR = "ERROR", i2))(Nn2 || {});
var xt2 = {
  PREPARING_STORY: "sb-show-preparing-story",
  PREPARING_DOCS: "sb-show-preparing-docs",
  MAIN: "sb-show-main",
  NOPREVIEW: "sb-show-nopreview",
  ERROR: "sb-show-errordisplay"
};
var Rt = {
  centered: "sb-main-centered",
  fullscreen: "sb-main-fullscreen",
  padded: "sb-main-padded"
};
var jn2 = new Mn.default({
  escapeXML: true
});
var wt2 = class wt3 {
  constructor() {
    this.testing = false;
    if (typeof O4 < "u") {
      let { __SPECIAL_TEST_PARAMETER__: e2 } = (0, _n2.parse)(O4.location.search.slice(1));
      switch (e2) {
        case "preparing-story": {
          this.showPreparingStory(), this.testing = true;
          break;
        }
        case "preparing-docs": {
          this.showPreparingDocs(), this.testing = true;
          break;
        }
        default:
      }
    }
  }
  // Get ready to render a story, returning the element to render to
  prepareForStory(e2) {
    return this.showStory(), this.applyLayout(e2.parameters.layout), O4.documentElement.scrollTop = 0, O4.documentElement.scrollLeft = 0, this.storyRoot();
  }
  storyRoot() {
    return O4.getElementById("storybook-root");
  }
  prepareForDocs() {
    return this.showMain(), this.showDocs(), this.applyLayout("fullscreen"), O4.documentElement.scrollTop = 0, O4.documentElement.scrollLeft = 0, this.docsRoot();
  }
  docsRoot() {
    return O4.getElementById("storybook-docs");
  }
  applyLayout(e2 = "padded") {
    if (e2 === "none") {
      O4.body.classList.remove(this.currentLayoutClass), this.currentLayoutClass = null;
      return;
    }
    this.checkIfLayoutExists(e2);
    let t2 = Rt[e2];
    O4.body.classList.remove(this.currentLayoutClass), O4.body.classList.add(t2), this.currentLayoutClass = t2;
  }
  checkIfLayoutExists(e2) {
    Rt[e2] || i.warn(
      P4`
          The desired layout: ${e2} is not a valid option.
          The possible options are: ${Object.keys(Rt).join(", ")}, none.
        `
    );
  }
  showMode(e2) {
    clearTimeout(this.preparingTimeout), Object.keys(Nn2).forEach((t2) => {
      t2 === e2 ? O4.body.classList.add(xt2[t2]) : O4.body.classList.remove(xt2[t2]);
    });
  }
  showErrorDisplay({ message: e2 = "", stack: t2 = "" }) {
    let o2 = e2, s2 = t2, i2 = e2.split(`
`);
    i2.length > 1 && ([o2] = i2, s2 = i2.slice(1).join(`
`).replace(/^\n/, "")), O4.getElementById("error-message").innerHTML = jn2.toHtml(o2), O4.getElementById("error-stack").innerHTML = jn2.toHtml(s2), this.showMode("ERROR");
  }
  showNoPreview() {
    this.testing || (this.showMode("NOPREVIEW"), this.storyRoot()?.setAttribute("hidden", "true"), this.docsRoot()?.setAttribute("hidden", "true"));
  }
  showPreparingStory({ immediate: e2 = false } = {}) {
    clearTimeout(this.preparingTimeout), e2 ? this.showMode("PREPARING_STORY") : this.preparingTimeout = setTimeout(
      () => this.showMode("PREPARING_STORY"),
      kn
    );
  }
  showPreparingDocs({ immediate: e2 = false } = {}) {
    clearTimeout(this.preparingTimeout), e2 ? this.showMode("PREPARING_DOCS") : this.preparingTimeout = setTimeout(() => this.showMode("PREPARING_DOCS"), kn);
  }
  showMain() {
    this.showMode("MAIN");
  }
  showDocs() {
    this.storyRoot().setAttribute("hidden", "true"), this.docsRoot().removeAttribute("hidden");
  }
  showStory() {
    this.docsRoot().setAttribute("hidden", "true"), this.storyRoot().removeAttribute("hidden");
  }
  showStoryDuringRender() {
    O4.body.classList.add(xt2.MAIN);
  }
};
n3(wt2, "WebView");
var we = wt2;
var At2 = class At3 extends xe2 {
  constructor(t2, o2) {
    super(t2, o2, new Re(), new we());
    this.importFn = t2;
    this.getProjectAnnotations = o2;
    scope.__STORYBOOK_PREVIEW__ = this;
  }
};
n3(At2, "PreviewWeb");
var { document: de2 } = scope;
var Tl = [
  "application/javascript",
  "application/ecmascript",
  "application/x-ecmascript",
  "application/x-javascript",
  "text/ecmascript",
  "text/javascript",
  "text/javascript1.0",
  "text/javascript1.1",
  "text/javascript1.2",
  "text/javascript1.3",
  "text/javascript1.4",
  "text/javascript1.5",
  "text/jscript",
  "text/livescript",
  "text/x-ecmascript",
  "text/x-javascript",
  // Support modern javascript
  "module"
];
var xl = "script";
var Ln2 = "scripts-root";
function gr2() {
  let r2 = de2.createEvent("Event");
  r2.initEvent("DOMContentLoaded", true, true), de2.dispatchEvent(r2);
}
n3(gr2, "simulateDOMContentLoaded");
function Rl(r2, e2, t2) {
  let o2 = de2.createElement("script");
  o2.type = r2.type === "module" ? "module" : "text/javascript", r2.src ? (o2.onload = e2, o2.onerror = e2, o2.src = r2.src) : o2.textContent = r2.innerText, t2 ? t2.appendChild(o2) : de2.head.appendChild(o2), r2.parentNode.removeChild(r2), r2.src || e2();
}
n3(Rl, "insertScript");
function qn(r2, e2, t2 = 0) {
  r2[t2](() => {
    t2++, t2 === r2.length ? e2() : qn(r2, e2, t2);
  });
}
n3(qn, "insertScriptsSequentially");
function zn(r2) {
  let e2 = de2.getElementById(Ln2);
  e2 ? e2.innerHTML = "" : (e2 = de2.createElement("div"), e2.id = Ln2, de2.body.appendChild(e2));
  let t2 = Array.from(r2.querySelectorAll(xl));
  if (t2.length) {
    let o2 = [];
    t2.forEach((s2) => {
      let i2 = s2.getAttribute("type");
      (!i2 || Tl.includes(i2)) && o2.push((a) => Rl(s2, a, e2));
    }), o2.length && qn(o2, gr2, void 0);
  } else
    gr2();
}
n3(zn, "simulatePageLoad");
var Bn = "storybook/docs";
var $f = `${Bn}/panel`;
var Gn = `${Bn}/snippet-rendered`;
async function Un(r2, e2) {
  let t2 = e2.parameters?.docs?.source?.transform, { id: o2, unmappedArgs: s2 } = e2, i2 = t2 && r2 ? t2?.(r2, e2) : r2, a = i2 ? await i2 : void 0;
  _3.getChannel().emit(Gn, {
    id: o2,
    source: a,
    args: s2
  });
}
n3(Un, "emitTransformCode");

export {
  se,
  re,
  ne,
  _3 as _,
  is,
  Ot,
  Gr2 as Gr,
  Qe2 as Qe,
  K4 as K,
  be,
  Yr2 as Yr,
  Ws,
  Xs,
  Ro2 as Ro,
  Qs2 as Qs,
  Un,
  Xr,
  tc,
  rc,
  jn,
  lc,
  cc,
  dc,
  uc
};
//# sourceMappingURL=chunk-A5NB2TSE.js.map
